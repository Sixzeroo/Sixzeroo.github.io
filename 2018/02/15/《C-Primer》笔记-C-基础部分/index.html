<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="unDM_uE8uu2mZxh8kTTsrR_tk8grv9nQAz6QQoaIOcU" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C/C++," />





  <link rel="alternate" href="/atom.xml" title="Sixzeroo" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="https://data1.liuin.cn/bitbug_favicon2.ico?v=5.1.2" />






<meta name="description" content="《C++ Primer》笔记 C++基础部分">
<meta name="keywords" content="C&#x2F;C++">
<meta property="og:type" content="article">
<meta property="og:title" content="《C++ Primer》笔记 C++基础部分">
<meta property="og:url" content="https://www.liuin.cn/2018/02/15/《C-Primer》笔记-C-基础部分/index.html">
<meta property="og:site_name" content="Sixzeroo">
<meta property="og:description" content="《C++ Primer》笔记 C++基础部分">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_1_29_1517231165506.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_1_29_1517232990644.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_2_1517572296753.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_2_1517572788565.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_3_1517659028911.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_3_1517659661001.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_3_1517659702856.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_3_1517659938792.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_3_1517660460874.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_3_1517660778235.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_3_1517661137672.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_4_1517751109803.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_4_1517751057230.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_4_1517751134864.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_4_1517752932745.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_4_1517752958321.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_7_1518014704271.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_13_1518491517567.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_13_1518491662122.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_14_1518603468039.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_14_1518603659447.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_14_1518610183005.jpg">
<meta property="og:image" content="https://data2.liuin.cn/story-writer/2018_2_14_1518610514067.jpg">
<meta property="og:updated_time" content="2018-02-23T04:05:57.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《C++ Primer》笔记 C++基础部分">
<meta name="twitter:description" content="《C++ Primer》笔记 C++基础部分">
<meta name="twitter:image" content="https://data2.liuin.cn/story-writer/2018_1_29_1517231165506.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.liuin.cn/2018/02/15/《C-Primer》笔记-C-基础部分/"/>






  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "4a50fc75"
    });
  daovoice('update');
  </script>


  <title>《C++ Primer》笔记 C++基础部分 | Sixzeroo</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?eb51bd4c48350fa08cbc200aead6109f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

	

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sixzeroo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-taiwan">
          <a href="/categories/台湾" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-train"></i> <br />
            
            台湾
          </a>
        </li>
      
        
        <li class="menu-item menu-item-link">
          <a href="/link" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-link"></i> <br />
            
            友链
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.liuin.cn/2018/02/15/《C-Primer》笔记-C-基础部分/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sixzeroo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://data1.liuin.cn/ava1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sixzeroo">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">《C++ Primer》笔记 C++基础部分</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-15T21:15:06+08:00">
                2018-02-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/02/15/《C-Primer》笔记-C-基础部分/" class="leancloud_visitors" data-flag-title="《C++ Primer》笔记 C++基础部分">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  14,516 字
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>《C++ Primer》笔记 C++基础部分</p>
<a id="more"></a>
<h1 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h1><h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><h3 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h3><p>类型char和类型signed char并不一样。尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。</p>
<p>当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）</p>
<p>与一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。把int转换成无符号数的过程和把int直接赋给无符号数—样。</p>
<h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517231165506.jpg" alt="enter description here"></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>初始化不是赋值，初始化的含义是创建一个变量的时候赋予其一个初始值，而赋值的含义是把对象的当前值删除，而以一个新值来代替</p>
<p>默认初始化：如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将不被初始化(uninitialized)。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。</p>
<p>使用未初始化的值将带来无法预计的后果</p>
<h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>变量能且只能被定义一次，但可以被声明多次</p>
<h3 id="标识符（identifier）"><a href="#标识符（identifier）" class="headerlink" title="标识符（identifier）"></a>标识符（identifier）</h3><h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>建议：当你第一次使用变量的时候再定义它</p>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用（reference）为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。</p>
<p>一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定（bind)在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此<strong>引用必须初始化</strong>。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517232990644.jpg" alt="enter description here"></p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针必须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，将拥有一个不确定的值。</p>
<p>指针的他（即地址）应属下列4种状态之一:</p>
<ol>
<li>指向一个对象。</li>
<li>指叫紧邻对象所占空间的下一个位置。</li>
<li>空指针，意味着指针没有指向任何对象。</li>
<li>无效指针，也就是上述情况之外的其他值。</li>
</ol>
<p>访问无效指针和空指针或者未知指针的后果无法预计</p>
<p><code>void*</code>指针时一种特殊的指针类型，可用于存放任意对象的地址。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象做哪些操作。</p>
<h3 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h3><p>引用本身不是对象，因此不能定义指向引用的指针。但是指针是对象，所以存在对指针的引用。</p>
<h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p>const对象被设定为仅在文件内有效</p>
<p>对const的引用可能引用一个并非const的对象：常量引用仅对引用可参与的操作做出了限定，对于引用对象本身是不是一个常量未作限定。</p>
<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p>用名词<strong>顶层const</strong>(top-levelconst)表示指针本身是个常量，而用名词<strong>底层const</strong>(low-levelconst)表示指针所指的对象是一个常量。</p>
<h3 id="constexpr-和常量表达式"><a href="#constexpr-和常量表达式" class="headerlink" title="constexpr 和常量表达式"></a>constexpr 和常量表达式</h3><p>常量表达式（constexpression)是指值不会改变而且在编译过程就能得到汁算结果的表达式。当然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。</p>
<p>C++11标准规定，允许将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量表达式。</p>
<h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h3><p>编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，C++11新标准引入了auto类型说明符，用它就能让编译器帮我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如double)不同，auto让编译器通始值来推算变量的类型。显然，auto定义的变量必须有初始值：</p>
<p>auto一般会忽略顶层const，同时底层const则会保留下来</p>
<h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h3><p>有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变蛩。为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数椐类型。在此过程中，编译器分忻表达式并得到它的类型，却不实际汁算表达式的值:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">decltype</span>(f()) sum = x;   <span class="comment">// sum的类型就是函数f的返回类型</span></div></pre></td></tr></table></figure>
<p>decltype 处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）</p>
<hr>
<h1 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a>字符串、向量和数组</h1><h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p>如果提供一个字符串字面值，则该字面值中除了最后那个空字符外其他所有字符都被拷贝新建的string对象中。</p>
<blockquote>
<p>直接初始化和拷贝初始化</p>
</blockquote>
<p>如果使用等号（=）初始化一个变量，实际上执行的是<strong>拷贝初始化</strong>（copy initialization），编译器将等号右侧的初始值拷贝到新创建的对象中去。<br>与之相反，不使用等号，则执行的是<strong>直接初始化</strong>（direct initialization）</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517572296753.jpg" alt="enter description here"></p>
<blockquote>
<p>string:size_type 类型</p>
</blockquote>
<p>string类及其他大多数标准库类型都定义了几种配套的类型。这些配套体现了标准库类型与机器无关的特性，类型size_type即是其中的一种。在具体使用的时候，通过作用域操作符表明名字size_type是在类string中定义的。</p>
<blockquote>
<p>字面值和string对象相加</p>
</blockquote>
<p>当把string对象和字符字面值以及字符串字面值混在一条语句中使用的时候，必须保证每个加法运算符的两侧至少有一个是string对象</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517572788565.jpg" alt="enter description here"></p>
<h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p>如果循环体内部包含有向 vector对象添加元元素的语句,则不能使用范 围for循环</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517659028911.jpg" alt="enter description here"></p>
<p>不能用下标形式添加元素：vector对象(以及 string对象)的下标运算符可用于访问已存在的元素, 而不能用于添加元素。</p>
<h2 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h2><p>所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符</p>
<p>类似于指针类型,迭代器也<strong>提供了对对象的间接访问</strong>。就迭代器而言,其对对象是容器中的元素或者者 string对象中的字符。使用迭代器可以访问某 个元素,迭代器也能从一个元素移动到另外一个元素。迭代器有有效和无效之分,这一点 和指针差不多。<strong>有效的迭代器或者指向某个元素,或者指向容器中尾元素的下一位置</strong>，其他所有情况都属于无效。</p>
<h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>end成员负责返回指向容器(或 string对象)“尾元素的下一位置( one past the end) 的迭代器,也就是说,该迭代器指示的是容器的一个本不存在的“尾后( off the end)”元 素。这样的迭代器没什么实际含义,仅是个标记而已,表示我们已经处理完了容器中的所 有元素。end成员返回的迭代器常被称作尾后迭代器( off-the- end iterator)或者简称为尾 迭代器( end iterator)。特殊情况下如果容器为空,则beg1n和end返回的是同一个迭 代器。（都是尾后迭代器）</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517659661001.jpg" alt="enter description here"></p>
<p>迭代器运算符</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517659702856.jpg" alt="enter description here"></p>
<blockquote>
<p>迭代器类型</p>
</blockquote>
<p>就像不知道 string和 vector的 size type成员员到底是什么类型一样,一般来说我们也不知道(其实是无须知道)迭代器的精确类型。而实际上, 那些拥有迭代器的标准库类型使用 iterator和 const iterator来表示迭代器的类型</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517659938792.jpg" alt="enter description here"></p>
<blockquote>
<p>某些对vector对象的操作会使迭代器失效</p>
</blockquote>
<p>不能在for循环范围内向vector对象添加元素；任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效</p>
<h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><p>迭代器的递增运算令迭代器每次移动一个元素,所有的标准库容器都有支持递增运算 的迭代器。类似的,也能用=和!=对任意标准库类型的两个有效迭代器进行比较</p>
<p>vector和string迭代器支持更多的迭代器运算</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517660460874.jpg" alt="enter description here"></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>不允许拷贝和赋值</p>
</blockquote>
<p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值</p>
<blockquote>
<p>理解复杂的数组声明</p>
</blockquote>
<p>类型修饰符从右向左依次绑定，就数组而言，由内向外阅读比从右向左好很多</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517660778235.jpg" alt="enter description here"></p>
<blockquote>
<p>访问数组元素</p>
</blockquote>
<p>在使用数组下标的时候,通常将其定义为size_t类型。size_t是一种机器相关的 无符号类型,它被设计得足够大以便能表示内存中任意对象的大小。</p>
<blockquote>
<p>标准库函数</p>
</blockquote>
<p>尽管能计算得到尾后指针,但这种用法极易出错。为了让指针的使用更简单、更安全, C++11新标准引引入了两个名为 begin和end的函数。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517661137672.jpg" alt="enter description here"></p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>严格来说，C++语言中没有多维数组，通常所说的的多维数组其实是数组的数组。</p>
<hr>
<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p>重载运算符</p>
</blockquote>
<p>C++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时,用户可以自行定义其含义义。因为这种自定义的过程事实 上是为已存在的运算符赋予了另外一层含义,所以称之为<strong>重載运算符</strong>( overloaded operator)。</p>
<blockquote>
<p>左值和右值</p>
</blockquote>
<p>C++的表达式要不然是右值( rvalue,读作“are- value”),要不然就是左值( lvalue, 读作“ ell-value”)。这两个名词是从C语言继承过来的,原本是为了帮助记忆:左值可以 位于赋值语句的左侧,右值则不能。</p>
<p>在C++语言中,二者的区别就没那么简单了。一个左值表达式的求值结果是一个对象 或者一个函数,然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对 象。此外,虽然某些表达式的求值结果是对象,但它们是右值而非左值。可以做一个简单 的归纳:<strong>当一个对象被用作右值的时候,用的是对象的值(内容);当对象被用作左值的 时候,用用的是对象的身份(在内存中的位置)。</strong> </p>
<p>不同的运算符对运算对象的要求各不相同,有的需要左值运算对象、有的需要右值运 算对象:返回值也有差异,有的得到左值结果、有的得到右值结果。一个重要的原则是：<strong>在需要右值的地方可以用左值来代替,但 是不能把右值当成左值(也就是位置)使用</strong>。 当一个左值被当成右值使用时,实际使用的 是它的内容(值)。</p>
<h3 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h3><p>对于那些没有指定执行顺序的运算符来说,如果表达式指向并修改了同一个对象,将会引发错误并产生<strong>未定义的行为</strong>。</p>
<p>举个简单的例子,&lt;&lt;运算符 没有明确规定何时以及如何对运算对象求值,因此下面的输出表达式是末定义的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"+"</span> &lt;&lt; ++i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 未定义的</span></div></pre></td></tr></table></figure></p>
<p>C++语言没有明确规定大多数二元运算符的求值顺序,给编译器优化留下了 余地。这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡.</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517751109803.jpg" alt="enter description here"></p>
<p>算术运算符能作用域任何算术类型以及任意能转化为算术类型的类型。</p>
<p>算术表达式有可能产生未定义的结果。一部分原因是数学性质本身:例如除数是0 的情况;另外一部分则源于计算机的特点:例如溢出,当计算的结果超出该类型所能表 示的范围时就会产生溢出。</p>
<blockquote>
<p>除法和取模运算</p>
</blockquote>
<p>在除法运算中,如果两个运算对象的符号相同则商为正(如果不为0的话),否则商 为负。C++语言的早期版本允许结果为负值的商向上或向下取整,C++11新标准则规定商 律向0取整(即直接切除小数部分) </p>
<p>根据取余运算的定义,如果m和n是整数且n非0,则表达式(m/n)*n+m%n的求值 结果与m相等。隐含的意思是,如果m%n不等于0,则它的符号和m相同。C++语言的早 期版本允许m%n的符号匹配n的符号,而且商向负无穷一侧取整,这一方式在新标准中 已经被禁止使用了。除了-m导致溢出的特殊情况,其他时候(-m)/n和m/(-n)都等于 (m/n),m%(-n)等于m%n,(-m)%n等于-(m%n)。</p>
<p>具体示例如下:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517751057230.jpg" alt="enter description here"></p>
<h2 id="逻辑运算符和关系运算符"><a href="#逻辑运算符和关系运算符" class="headerlink" title="逻辑运算符和关系运算符"></a>逻辑运算符和关系运算符</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517751134864.jpg" alt="enter description here"></p>
<p>逻辑与运算符和逻辑或运算符都是先求左側运算对象的值再求右侧运算对象的值,当 且仅当左側运算对象无法确定表达式的结果时オ会计算右侧运算对象的值。这种种策略称为 短路求值( short- circuit evaluation)。</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符的左侧运算对象必须是一个可修改的左值</p>
<h2 id="递增运算符和递减运算符"><a href="#递增运算符和递减运算符" class="headerlink" title="递增运算符和递减运算符"></a>递增运算符和递减运算符</h2><p>递增和递减运算符有两种形式:前置版本和后置版本。前置递增运算符首先将运算对象加1(或减1),然后将改变后的对象作为求 值结果。后置版本也会将运算对象加1(或减1),但是求值结果是运算对象改变之前那个 值的副本</p>
<p>建议:除非必须,否则不用递增递减运算符的后置版本：<br>有C语言背景的读者可能对优先使用前置版本递增运算符有所疑间问,其实原因非常 简单:前置版本的递增运算符避免了不必要的工作,它把值加1后直接返回改变了的运 算对象。与之相比,后置版本需要将原始值存储下来以便于返回这个未修改的内容。如 果我们不需要修改前的值,那么后置版本的操作就是一种浪费。</p>
<h2 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h2><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律,其所得得的值是一个size_t类型</p>
<p>运算符的运算对象有两种形式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">sizeof</span>(type)</div><div class="line"><span class="keyword">sizeof</span> expr</div></pre></td></tr></table></figure></p>
<p>在第二种形式中，sizeof返回的是表达式结果类型的大小。与众不同的一点是，sizeof并不实际计算其运算对象的值：</p>
<p>因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中的元素个数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(ia)/<span class="keyword">sizeof</span>(*ia);</div><div class="line"><span class="keyword">int</span> arr2[sz]; <span class="comment">// ok sizeof returns a constant expression</span></div></pre></td></tr></table></figure></p>
<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p>逗号运算符( comma operator)含有两个运算对象,按照从左向右的顺序依次求值 和逻辑与、逻辑或以及条件运算符一样,逗号运算符也规定了运算对象求值的顺序。 对于逗号运算符来说,首先对左侧的表达式求值,然后将求值结果丢弃掉。逗号运算符真正的结果是右側表达式的值。如果右侧运算对象是左值,那么最终的求值结果也是左值。</p>
<h2 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="其他隐式类型转换"><a href="#其他隐式类型转换" class="headerlink" title="其他隐式类型转换"></a>其他隐式类型转换</h3><p>数组转换为指针：在大多数用到数组的表达式中，数组自动转换为指向数组首元素的指针</p>
<p>指针的转换:C++还规定了几种其他的指针转换方式,包括常量整数值0或者者字面值 nu11ptr能转换成任意指针类型:指向任意非常量的指针能转换成void<em>;指向任意对 象的指针能转换成 const void</em>。</p>
<p>转换为布尔类型：存在一种从算术类型或指针类型向布尔类型自动转换的机制</p>
<p>转换为常量：允许将指向非常量类型的指针转换成为相应常量类型的指针，对于引用也是这样。</p>
<h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p>待整理</p>
<h2 id="运算符优先级表"><a href="#运算符优先级表" class="headerlink" title="运算符优先级表"></a>运算符优先级表</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517752932745.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517752958321.jpg" alt="enter description here"></p>
<hr>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><blockquote>
<p>悬垂else</p>
</blockquote>
<p>当一个if语句嵌套在另一个if语句内部时,很可能if分支会多于else分支。事实上,之前那个成绩转换的程序就有4个if分支,而只有2个else分支。这时候问题 出现了:我们怎么知道某个给定的else是和和哪个if匹配呢? 这个问题通常称作<strong>悬垂else</strong>( dangling else),在那些既有if语句又有if else语句的编程语言中是个普遍存在的问题。不同语言解决该问题的思路也不同,就就C++而言, 它规定else与离它最近的尚未匹配的if匹配,从而消除了程序的的二义性。</p>
<blockquote>
<p>case标签</p>
</blockquote>
<p>case关键字和它对应的值一起被称为case标签( case label)。case标签签必须是整 型常量表达式</p>
<blockquote>
<p>switch内部的变量定义</p>
</blockquote>
<p>如前所述, switch的执行流程有可能会跨过某些case标标签。如果程序跳转到了某个特定的case,则switch结构中该该case标签之前的部分会被忽略掉。这种忽略掉一 部分代码的行为引出了一个有趣的问题:如果被略过的代码中含有变量的定义该怎么办? 答案是:<strong>如果在某处一个带有初值的变量位于作用域之外,在另一处该变量位于作用域之内,则从前一处跳转到后一处的行为是非法行为。</strong></p>
<h2 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h2><h3 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h3><p>C++11新标准引入了一种更简单的for语句,这种语句可以遍历容器或其他序列的 所有元素。范围for语句( range for statement）的语法形式是: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (declaration expression) </div><div class="line">statement</div></pre></td></tr></table></figure>
<p>expression表示的必须是一个序列,比如用花括号括起来的初始值列表、数组或者 vector或string等类型的对象,这些类型的共同特点是拥有能返回迭代器的 begin和end成员。 </p>
<p>declaration定义一个变量,序列中的每个元素都得能转换成该变量的类型。确保类型相容最简单的办法是使用auto类型说明符,这个关键字可以令编译器帮助我们指定合适的类型。</p>
<p>如果需要对序列中的元素执行写操作,循环变量必须声明成引用类型 每次迭代都会重新定义循环控制变量,并将其初始化成序列中的下一个值,之后オ会 执行 statement。像往常一样, statement可以是一条单独的语句也可以是一个块。所有元素 都处理完毕后循环终止。</p>
<h2 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h2><p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。当程序的某部分检测到一个他无法处理的问题的时候，需要用到异常处理。</p>
<p>异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持。在C++语言 中,异常处理包括 </p>
<ul>
<li>throw表达式( throw expression),异常检测部分使用 throw表达式来表示它遇到 了无法处理的问题。我们说 throw引发( raise)了异常。 </li>
<li>ty语句块( try block),异常处理部分使用try语句块处理异常。try语句块以 关键字try开始,并以一个或多个 catch子句( catch clause)结束。try语句块 中代码抛出的异常通常会被某个 catch子句处理。因为 catch子句“处理”异常, 所以它们也被称作异常处理代码( exception handler)。 </li>
<li>套异常类( exception class),用于在 throw表达式和相关的 catch子句之间传 递异常的具体信息。</li>
</ul>
<h3 id="标注异常"><a href="#标注异常" class="headerlink" title="标注异常"></a>标注异常</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_7_1518014704271.jpg" alt="enter description here"></p>
<hr>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>我们通过<strong>调用运算符</strong>( call operator)来执行函数。调用运算符的形式是一对圆括물 它作用于一个表达式,该表达式是函数或者指向函数的指针:圆括号之内是一个用逗号隔 开的实参( argument)列列表,我们用实参初始化函数的形参。调调用表达式的类型就是函数 的返回类型。</p>
<p>函数的调用完成两项工作:一是用实参初始化函数对应的形参,二是将控制权转移给被调 用函数。此时,主调调函数( calling function)的执行被暂时中断,被调函数( called function) 开始执行。</p>
<blockquote>
<p>形参和实参</p>
</blockquote>
<p>实参是形参的初始值。尽管实参和形参存在对应关系，但是并没有规定实参的求值顺序。编译器能以任意可行的顺序对实参求值。</p>
<h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><p>名字有作用域，对象有生命周期（lifetime）：名字的作用域是程序文本的一部分，名字在其中可见；对象的生命周期是程序执行过程中该对象存在的一段时间。</p>
<p>如果局部静态变量没有显式的初始值，它将执行初始化：内置类型的局部静态变量初始化为0</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数的声明不包含函数体，所以也不需要形参的名字，但是加上名字能够让使用者更好地理解函数的功能。</p>
<h3 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h3><p>分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译</p>
<p>编译以后，如果我们修改了其中一个源文件，那么只需要重新编译那个改动的文件即可</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>当形参是引用类型时,我们说它对应的实参被<strong>引用传递</strong>( Dassed by reference )或者函 数被传引用週用( called by reference)。和其他引用一样,引用形参也是它绑定的对象的别 名;也就是说,引用形参是它对应的实参的别名。 </p>
<p>当实参的值被拷贝给形参时,形参和实参是两个相互独立的对象。我们们说这样的实参 被<strong>值传递</strong>( passed by value)或者者函数被传值调用( called by value)</p>
<blockquote>
<p>使用引用避免拷贝</p>
</blockquote>
<p>拷贝大的类类型对象或者容器对象比较低效,甚至有的类类型(包括括1O类型在内) 根本就不支持拷贝操作。当某种类型不支持拷贝操作时,函数只能通过引用形参访问该类 型的对象。</p>
<p>如果函数无需改变引用形参的值，最好将其声明为常量引用</p>
<h3 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h3><p><strong>当形参时const时，其为顶层const，顶层const作用于对象本身。</strong></p>
<p>和其他初始化过程一样,当用实参初始化形参时会忽略掉顶层 const。换句话说,形参的顶层 const被忽略掉了。当形参有顶层 const时,传给它常量对象或者非常量对象都是 可以的:</p>
<h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p>数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响,这两个性质分别 是:<strong>不允许拷贝数组</strong>以及<strong>使用数组时(通常)会将其转换成 指针</strong>。因为不能拷贝数组,所以我们<strong>无法以值传递的方式使用 数组参数</strong>。因为数组会被转换成指针,所以当我们为函数传递一个数组时,实际上传递的 是指向数组首元素的指针。</p>
<p>为了程序的可读性，我们可以把形参写成类似数组的形式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">( <span class="keyword">const</span> *<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">( <span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">( <span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;  <span class="comment">// 这里的维度表示我们期望有多少元素，实际不一定</span></div></pre></td></tr></table></figure></p>
<p>管理指针形参的三种常用技术：</p>
<ul>
<li>使用标记指定数组长度，要求数组本身包含一个结束标记</li>
<li>使用标准库规范，传递指向数组首元素和数组尾元素的指针</li>
<li>显式传递一个表示数组大小的形参</li>
</ul>
<blockquote>
<p>传递多维数组</p>
</blockquote>
<p>和所有数组一样,当将多维数组传递给函数时,真正传递的是指向数组首元素的指针 。因为我们处理的是数组的数组,所以首元素本身就是一个数组, 指针就是一个指向数组的指针。<strong>数组第二维(以及后面所有维度)的大小都是数组类型的 部分,不能省略</strong>:</p>
<h3 id="含有可变形参的参数"><a href="#含有可变形参的参数" class="headerlink" title="含有可变形参的参数"></a>含有可变形参的参数</h3><p>为了编写能处理不同数量实参的函数,C++11新标准提供了两种主要的方法:如如果所 有的实参类型相同,可以传递一个名为initializer_list的标准库类型:如果实参的 类型不同,我们可以编写一种特殊的函数,也就是所谓的可变参数模板,</p>
<blockquote>
<p>initializer_list 形参</p>
</blockquote>
<p>如果函数的实参数量未知但是全部实参的类型都相同,我们可以使用initializer_listt类型的形参。initializer_list是一种标准库类型,用于表示 某种特定类型的值的数组</p>
<blockquote>
<p>省略符形参</p>
</blockquote>
<p>省略符形参是为了便于C++程序访访问某些特殊的C代码而设置的,这些们代码使用了名 为 varargs的C标准库功能。</p>
<p>省略符形参只能出现在形参列表的最后一个位置,它的形式无外乎以下两种: </p>
<ul>
<li>void foo(parm list, …);</li>
<li>void foo(…)</li>
</ul>
<p>第一种形式指定了foo函数的部分形参的类型,对应于这些形参的实参将会执行正常的 类型检査。省略符形参所对应的实参无须类型检査。在第一种形式中,形参声明后面的逗 号是可选的。</p>
<h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h2><blockquote>
<p>不要返回局部对象的引用或指针</p>
</blockquote>
<p>函数完成后,它所占用的存储空间也随之被释放掉。因此, 函数终止意味着局部变量的引用将指向不再有效的内存区域。会引发未定义行为</p>
<blockquote>
<p>引用返回左值</p>
</blockquote>
<p>调用一个返回引用的函数返回左值，返回其他类型得到右值</p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>不允许两个函数除了返回类型外其他所有的要素都相同</p>
<p>一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来</p>
<blockquote>
<p>调用重载函数</p>
</blockquote>
<p>定义了一组重载函数后,我们需要以合理的实参调用它们。<strong>函数匹配</strong>( functionmatching)是指一个过程,在这个过程中我们把函数调用与一组重载函数中的某一个关联起来,函数匹配也叫做<strong>重载确定</strong>( overload resolution)。编编译器首先将调用的实参与重载集合中每一个函数的形参进行比较,然后根据比较的结果决定到底调用哪个函数。</p>
<h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><p>某些函数有这样一种形参,在函数的很多次调用中它们都被赋予一个相同的值,此时,我们把这个反复出现的值称为函数的<strong>默认实参</strong>( default argument)。调调用含有默认实参的函数时,可以包含该实参,也可以省略该实参。</p>
<p>一旦某个形参被赋予了默认值，后面所有的额形参都要赋予默认值。所以当设计含有默认实参的函数时,其中一项任务是合理设置形参的顺序,尽量让不怎么使用默认值的形参出现在前面,而让那些经常使用默认值的形参出现在后面</p>
<p>在给定的作用域中一个形参只能被赋予一次默认实参。换句句话说,函数的后续声明只能为之前那些没有默认值的形参添加默认实参,而且该形参右侧的所有形参必须都有默认值。</p>
<p>局部变量不能作为默认实参。除此之外,只要表达式的类型能转换成形参所需的类型,该表达式就能作为默认实参:</p>
<h3 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h3><p>在大多数机器上,一次次函数调用其实包含着一系列工作:调用前要先保存寄存器,并在返回时恢复;可能需要拷贝实参;程序转向一个新的位置继续执行。</p>
<h4 id="内联函数可以避免函数调用的开销"><a href="#内联函数可以避免函数调用的开销" class="headerlink" title="内联函数可以避免函数调用的开销"></a>内联函数可以避免函数调用的开销</h4><p>将函数定义为内联函数（inline），通常就是把它在每一个调用点上“内联地”展开。函数返回类型前面加上关键字inline，这样就可以将它声明为内联函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="built_in">string</span> &amp; <span class="title">shortString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> s1.size() &lt;= s2.size() ? s1 : s2;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>一般来说,内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数,而而且一个75行的函数也不大可能在调用点内联地展开。</p>
<h4 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h4><p>constexpr函数( constexpr function)是指能用于常量表达式的函数。定义 constexpr函数的方法与其他函数类似,不过要遵循几项约定:函数的返回类型及所有形参的类型都得是字面值类型,而且函数体中必须有且只有一条 return语句:</p>
<p>把內联函数和 constexpr函数放在头文件内和其他函数不一样,内联函数和 constexpr函数可以在程序中多次定义。毕竟,编译器要想展开函数仅有函数声明是不够的,还需要函数的定义。不过,对于某个给定的内联函数或者 constexpr函数来说,它的多个定义必须完全一致。基于这个原因,内联函数和 constexpr函数通常定义在头文件中。</p>
<h3 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h3><p>程序可以包含一些用于调试的代码,但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时,要先屏蔽掉调试代码。这种方法用到两项预处理功能: assert和 NDEBUG</p>
<h4 id="assert-预处理宏"><a href="#assert-预处理宏" class="headerlink" title="assert 预处理宏"></a>assert 预处理宏</h4><p>assert是一种<strong>预处理宏</strong>( preprocessor marco)。所谓预处理宏其实是一个预处理变量,它的行为有点类似于内联函数。 assert宏使用一个表达式作为它的条件:<code>assert(expr)</code> </p>
<p>首先对expr求值,如如果表达式为假(即0), assert输出信息并终止程序的执行。如果表达式为真(即非0), assert什么也不做。</p>
<p>assert宏定义在 assert头文件中。如我们所知,预处理名字由预处理器而非编译器管理,因此我们可以直接使用预处理名字而无须提供uS1ng明。也就是说,我们应该使用 assert而不是std:: assert,也不需要为 assert提供using声明。</p>
<h4 id="NDEBUG-预处理变量"><a href="#NDEBUG-预处理变量" class="headerlink" title="NDEBUG 预处理变量"></a>NDEBUG 预处理变量</h4><p>assert的行为依赖于一个名为 NDEBUG的预处理变量的状态。如果定义了 NDEBUG,则 assert什么也不做。默认状态下没有定义 NDEBUG,此时 assert将执行运行时检查。我们可以使用一个# define语句定义 NDEBUG,从而关闭调试状态。同时,很多编译器都提供了一个命令行选项使我们可以定义预处理变量</p>
<h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><h3 id="确定候选函数和可行函数"><a href="#确定候选函数和可行函数" class="headerlink" title="确定候选函数和可行函数"></a>确定候选函数和可行函数</h3><p>函数匹配的第一步是选定本次调用对应的重载函数集,集合中的函数称为<strong>候选函数</strong>( candidate function)。候选函数具备两个特征:一是与被调用的函数同名,二是其声明在调用点可见。</p>
<p>第二步考察本次调用提供的实参,然后从候选函数中选出能被这组实参调用的函数,这些新选出的函数称为<strong>可行函数数</strong>( viable function)。可行函数也有两个特征:一是其形参数量与本次调用提供的实参数量相等,二是每个实参的类型与对应的形参类型相同,或者能转换成形参的类型。</p>
<blockquote>
<p>寻找最佳匹配</p>
</blockquote>
<p>函数匹配的第三步是从可行函数中选择与本次调用最匹配的函数。实参类型与形参类型越接近，他们匹配得越好。</p>
<blockquote>
<p>含有多个形参的函数匹配</p>
</blockquote>
<p>当实参的数量有两个或更多时,函数匹配就比较复杂了。编译器依次检査每个实参以确定哪个函数是最佳匹配。如如果有且只有个函数满足下列条件,则匹配成功・该该函数每个实参的匹配都不劣于其他可行函数需要的匹配至少有一个实参的匹配优于其他可行函数提供的匹配。如果在检査了所有实参之后没有任何一个函数脱颖而出,则则该调用是错误的。</p>
<h3 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h3><p>为了确定最佳匹配,编译器将实参类型到形参类型的转換划分成儿个等级,具体排序如</p>
<ol>
<li>精确匹配,包括以下情况:实参类型和形参类型相同・实参从数组类型或函数类型转换成对应的指针类型。向实参添加顶层 const或者从实参中删除顶层 const</li>
<li>通过 const转换实现的匹配</li>
<li>通过过类型提升实现的匹配</li>
<li>通过算术类型转换或指针转换实现的匹配。</li>
<li>通过类类型转换实现的匹配配(参见14.9节</li>
</ol>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向的是函数而非对象。和其他指针一样,函数指针指向某种特定类型，函数的类型由它的返回类型和形参类型共同决定,与函数名无关。</p>
<p>想要声明一个可以指向该函数的指针，只需要用指针替换函数名即可</p>
<p>当我们把函数名作为一个值使用时，该函数自动地转换成指针。</p>
<p>此外,我们们还能直接使用指向函数的指针调用该函数,无须提前解引用指针</p>
<blockquote>
<p>函数指针形参</p>
</blockquote>
<p>和数组类似,虽然不能定义函数类型的形参,但是形参可以是指向函数的指针。此时,形参看起来是函数类型,实际上却是当成指针使用:</p>
<blockquote>
<p>返回指向函数的指针</p>
</blockquote>
<p>和数组类似,虽然不能返回一个函数,但是能返回指向函数类型的指针。然而,我们们必须把返回类型写成指针形式,编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样,要想声明一个返回函数指针的函数,最简单的办法是使用类型别名</p>
<hr>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类的基本思想是<strong>数据抽象</strong>( data abstraction)和<strong>封装</strong>( encapsulation)。<strong>数据抽象是二种依赖于接口( interface)和实现( implementation)分离的编程程(以及设计)技术。</strong>类的接口包括用户所能执行的操作;类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。</p>
<p><strong>封装实现了类的接口和实现的分离</strong>。封装后的类隐藏了它的实现细节,也就是说,类的用户只能使用接口而无法访问实现部分。</p>
<h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><h3 id="定义类的基本"><a href="#定义类的基本" class="headerlink" title="定义类的基本"></a>定义类的基本</h3><h4 id="引入-this"><a href="#引入-this" class="headerlink" title="引入 this"></a>引入 this</h4><p>成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时,用请求该函数的对象地址初始化this</p>
<p>对于我们来说,this形参是隐式定义的。实际上,任何自定义名为this的参数或变量的行为都是非法的。我们们可以在成员函数体内部使用this因此尽管没有必要,但我们还是能把isbn定义成如下的形式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; &#125;</div></pre></td></tr></table></figure>
<h4 id="引入const-成员函数"><a href="#引入const-成员函数" class="headerlink" title="引入const 成员函数"></a>引入const 成员函数</h4><p>上面的ibsn函数的另一个关键之处是紧随参数列表之后的 const关键字,这里, const的作用是修改隐式this指针的类型。</p>
<p>默认情况下,<strong>this的类型是指向类类型非常量版本的常量指针</strong>。尽管this是隐式的,但它仍然需要遵循初始化规则,意味着(在默认情况下)我们不能把this绑定到一个常量对象上。</p>
<p>C++语言的做法是允许<strong>把 const关键字放在成员函数的参数列表之后</strong>,此时,紧跟在参数列表后面的 const表示this是一个指向常量的指针。像这样使用 const的成员函数被称作<strong>常量成员函数</strong>( const member function)。</p>
<h4 id="类作用域和成员函数"><a href="#类作用域和成员函数" class="headerlink" title="类作用域和成员函数"></a>类作用域和成员函数</h4><p>编译器分两步处理类:首先编译成员的声明,然后才轮到成员函数体(如果有的话)。因此,成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p>
<h4 id="在类外部定义成员函数"><a href="#在类外部定义成员函数" class="headerlink" title="在类外部定义成员函数"></a>在类外部定义成员函数</h4><p>当我们在类的外部定义成员函数时,成员函数的定义必须与它的声明匹配。也就是说,返回类型、参数列表和函数名都得与类内部的声明保持一致。如果<strong>成员被声明成常量成员函数,那么它的定义也必须在参数列表后明确指定 const属性</strong>。同时,类外部定义的成员的名字必须包含它所属的类名</p>
<h4 id="定义一个返回this对象的函数"><a href="#定义一个返回this对象的函数" class="headerlink" title="定义一个返回this对象的函数"></a>定义一个返回this对象的函数</h4><p>一般来说,当我们定义的函数类似于某个内置运算符时,应该令该函数的行为尽量模仿这个运算符。内置的赋值运算符把它的左側运算对象当成左值返回,因此为了与它保持一致,combine函数必须返回引用类型。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>每个类都分别定义了它的对象被初始化的方式,类通过一个或几个特殊的成员函数来控制其对象的初始化过程,这些函数叫做构造函数( constructor)。<strong>构造函数的任务是初始化类对象的数据成员,无论何时只要类的对象被创建,就会执行构造函数</strong>。</p>
<p>构造函数的名字和类名相同。和其他函数不一样的是,构造函数没有返回类型;除此之外类似于其他的函数,构造函数也有一个(可能为空的)参数列表和一个(可能为空的)函数体。类可以包含多个构造函数,和其他重载函数差不多,不同的构造函数之间必须在参数数量或参数类型上有所区别。</p>
<p>不同于其他成员函数,构造函数不能被声明成 const的</p>
<h4 id="合成的默认构造函数"><a href="#合成的默认构造函数" class="headerlink" title="合成的默认构造函数"></a>合成的默认构造函数</h4><p>我们没有为这些对象提供初始值,因此我们知道它们执行了默认初始化。<strong>类通过一个特殊的构造函数来控制默认初始化过程,这个函数叫做默认构造函数( default constructor）</strong>默认构造函数无须任何实参。</p>
<p>如我们所见,默认构造函数在很多方面都有其特殊性。其中之一是,<strong>如果我们的类没有显式地定义构造函数,那么编译器就会为我们隐式地定义一个默认构造函数</strong>。编译器创建的构造函数又被称为合成的默认构造函数( synthesized defaultconstructor)。对于大多数类来说,这个合成的默认构造函数将按照如下规则初始化类的数据成员:</p>
<ul>
<li>如果存在类内的初始值,用它来初始化成员</li>
<li>否则,默认初始化该成员。</li>
</ul>
<h4 id="某些类不能依赖于合成的默认构造函数"><a href="#某些类不能依赖于合成的默认构造函数" class="headerlink" title="某些类不能依赖于合成的默认构造函数"></a>某些类不能依赖于合成的默认构造函数</h4><p>对于一个普通的类来说,必须定义它自己的默认构造函数,原因有三:</p>
<p>第一个原因也是最容易理解的一个原因就是编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。</p>
<p>第二个原因是对于某些类来说,<strong>合成的默认构造函数可能执行错误的操作</strong>。回忆我们之前介绍过的,如果定义在块中的内置类型或复合类型(比如数组和指针)的对象被默认初始化,则它们的值将是未定义的。该准则则同样适用于默认初始化的内置类型成员。因此,含有内置类型或复合类型成员的类应该在类的内部初始化这些成员,或者定义一个自己的默认构造函数。否则,用户在创建类的对象时就可能得到未定义的值。</p>
<p>第三个原因是有的时候编译器不能为某些类合成默认的构造函数</p>
<h4 id="default的含义"><a href="#default的含义" class="headerlink" title="=default的含义"></a>=default的含义</h4><p>在C++11标准中，如果我们需要默认行为，那么可以通过在参数列表后面写上<code>=default</code>来要求编译器生成构造函数</p>
<h4 id="构造函数的初始值列表"><a href="#构造函数的初始值列表" class="headerlink" title="构造函数的初始值列表"></a>构造函数的初始值列表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>: <span class="built_in">string</span> &amp;s): bookno(s) &#123; &#125; ;</div><div class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>: <span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p):bookno(s), units_sold(n), revenue(p*n) &#123; &#125; ;</div></pre></td></tr></table></figure>
<p>这两个定义中出现了新的部分,即冒号以及冒号和花括号之间的代码,其中花括号定义了函数体。我们把新出现的部分称为<strong>构造函数初始值列表</strong>( constructor initialize list),它负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表,每个名学后面紧跟括号括起来的(或者在花括号内的)成员初始值。不同成员的初始化通过逗号分隔开来</p>
<h3 id="拷贝、赋值和析构"><a href="#拷贝、赋值和析构" class="headerlink" title="拷贝、赋值和析构"></a>拷贝、赋值和析构</h3><h4 id="某些类不能依赖于合成的版本"><a href="#某些类不能依赖于合成的版本" class="headerlink" title="某些类不能依赖于合成的版本"></a>某些类不能依赖于合成的版本</h4><p>尽管编译器能替我们合成拷贝、赋值和销毁的操作,但是必须要清楚的一点是,对于某些类来说合成的版本无法正常工作。特別是,<strong>当类需要分配类对象之外的资源时,合成的版本常常会失效</strong>。</p>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>定义在public说明符之后的成员在整个程序内可被访问,public成员定义类的接口。</p>
<p>定义在 private说明符之后的成员可以被类的成员函数访问,但是不能被使用该类的代码访问, private部分封装了(即隐藏了)类的实现细节。</p>
<blockquote>
<p>使用class 和struct关键字</p>
</blockquote>
<p>我们可以使用class和struct这两个关键字中的任何一个定义类。唯一的一点区别是, struct和class的默认访问权限不太一样。类可以在它的第一个访问说明符之前定义成员,对这种成员的访问权限依赖于类定义。<strong>如果我们使用 struct关键字,则定义在第一个访问说明符之前的成员是public的</strong>;相反,如果<strong>我们使用class关键字,则这些成员是private的</strong>。</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类可以允许其他类或者函数访问它的非公有成员,方法是令其他类或者函数成为它的友元( friend)。如果类想把一个函数作为它的友元,只需要增加一条以friend关键字开始的函数声明语句即可:</p>
<p>友元的声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类成员也不受它所在区域访问控制级别的约束</p>
<blockquote>
<p>封装有两个重要的优点<br>确保用户代码不会无意间破坏封装对象的状态。<br>被封装的类的具体实现细节可以随时改变,而无须调整用户级别的代码。</p>
</blockquote>
<p>友元的声明仅仅指定了访问的权限,而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数,那么我们就必须在友元声明之外再专门对函数进行一次声明</p>
<h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><h3 id="类成员再探"><a href="#类成员再探" class="headerlink" title="类成员再探"></a>类成员再探</h3><p>除了定义数据和函数成员之外,类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制,可以是public或者private中的一种</p>
<blockquote>
<p>令成员函数作为内联函数</p>
</blockquote>
<p>在类中,常有一些规模较小的函数适合于被声明成内联函数。如我们之前所见的,定义在类内部的成员函数是自动inline的。</p>
<p>我们可以在类的内部把inline作为声明的一部分显式地声明成员函数,同样的,也能在类的外部用inline关键字修饰函数的定义</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_13_1518491517567.jpg" alt="enter description here"></p>
<blockquote>
<p>可变数据成员</p>
</blockquote>
<p>有时(但并不频繁)会发生这样一种情况,我们希望能<strong>修改类的某个数据成员</strong>,即使是在一个 const成员函数内。可以通过在变量的声明中加入 mutable关键字做到这点</p>
<p>一个<strong>可変数据成员</strong>( mutable data member)永远不会是 const,即使它是 const对象的成员。因此,一个 const成员函数可以改变一个可变成员的值。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_13_1518491662122.jpg" alt="enter description here"></p>
<h3 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回*this的成员函数</h3><p>返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本</p>
<blockquote>
<p>基于const的重载</p>
</blockquote>
<p>通过区分成员函数是否是 const的,我们可以对其进行重载,其原因与我们之前根据指针参数是否指向 const而重载函数的原因差不多。具体说</p>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>每个类定义了唯一的类型。对于两个类来说,即使它们的成员完全一样,这两个类也是两个不同的类型。</p>
<blockquote>
<p>类的声明</p>
</blockquote>
<p>就像可以把函数的声明和定义分离开来一样,我们也能仅仅声明类而暂时不定义它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Screen;   // screen类的声明</div></pre></td></tr></table></figure></p>
<p>这种声明有时被称作<strong>前向声明</strong>( forward declaration),它向程序中引入了名字 Screen并且指明 Screen是一种类类型。对于类型 Screen来说,在它声明之后定义之前是一个不完全类型( incomplete type),也就是说,此时我们已知 Screen是一个类型,但是不清楚它到底包含哪些成员。</p>
<p>不完全类型只能在非常有限的情景下使用:可以定义指向这种类型的指针或引用,也可以声明(但是不能定义)以不完全类型作为参数或者返回类型的函数。</p>
<h3 id="友元再探"><a href="#友元再探" class="headerlink" title="友元再探"></a>友元再探</h3><p>类还可以把其他的类定义成友元,也可以把其他类(之前已定义过的)的成员函数定义成友元。此外,友元函数能定义在类的内部,这样的函数是隐式内联的。</p>
<p>如果一个类定义了友元类，则友元类的成员函数可以访问此类包括非公有函数在内的所有成员。</p>
<p><strong>友元不具备传递性</strong></p>
<blockquote>
<p>令成员函数作为友元</p>
</blockquote>
<p>除了令整个Window mgr作为友元之外, Screen还可以只为clear提供访问权限。当把一个成员函数声明成友元时,我们必须明确指出该成员函数属于哪个类:</p>
<blockquote>
<p>函数重载和友元</p>
</blockquote>
<p>尽管重载函数的名字相同,但它们仍然是不同的函数。因此,如果一个类想把一组重载函数声明成它的友元,它需要对这组函数中的每一个分别声明:</p>
<blockquote>
<p>友元声明和作用域</p>
</blockquote>
<p>类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在个友元声明中时,我们隐式地假定该名字在当前作用域中是可见的。</p>
<h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><p>每个类都会定义它自己的作用域。<strong>在类的作用域之外,普通的数据和函数成员只能由对象、引用用或者指针使用成员访问运算符来访问</strong>。对于类类型成员则使用作用域运算符访问。不论哪种情况,跟在运算符之后的名字都必须是对应类的成员</p>
<blockquote>
<p>作用域和定义在类外部的成员</p>
</blockquote>
<p>在类的外部,成员的名字被隐藏起来了。一旦遇到了类名,定义的剩余部分就在类的作用域之内了,这里的剩余部分包括参数列表和函数体。结果就是,我们可以直接使用类的其他成员而无须再次授权了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518603468039.jpg" alt="enter description here"></p>
<p>另一方面,函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时,返回类型中使用的名字都位于类的作用域之外。这时,返回类型必须指明它是哪个类的成员。</p>
<h3 id="名字查找和类的作用域"><a href="#名字查找和类的作用域" class="headerlink" title="名字查找和类的作用域"></a>名字查找和类的作用域</h3><p><strong>名字查找( name lookup)</strong>(寻找与所用名字最匹配的声明的过程)的过程比较直截了当:</p>
<ul>
<li>首先,在名字所在的块中寻找其声明语句,只考虑在名字的使用之前出现的声明。</li>
<li>如果没找到,继续查找外层作用域。</li>
<li>如果最终没有找到匹配的声明,则程序报错。</li>
</ul>
<p>一般来说,内层作用域可以重新定义外层作用域中的名字,即使该名字已经在内层作用域中使用过。然而在类中,如果成员使用了外层作用域中的某个名字,而该名字代表种类型,则类不能在之后重新定义该名字:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518603659447.jpg" alt="enter description here"></p>
<h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><blockquote>
<p>构造函数的初始值有时必不可少</p>
</blockquote>
<p>有时我们可以忽略数据成员初始化和赋值之间的差异,但并非总能这样。<strong>如果成员是const或者是引用的话,必须将其初始化</strong>。类似的,当成员属于某种类类型且该类没有定义默认构造函数时,也必须将这个成员初始化。</p>
<p>一些数据成员必须初始化，建议养成使用构造函数初始化值的习惯</p>
<blockquote>
<p>成员初始化的顺序</p>
</blockquote>
<p>构造函数初始值列表只说明用于初始化成员的值,而不限定初始化的具体执行顺序。</p>
<p><strong>成员的初始化顺序与它们在类定义中的出现顺序一致</strong>:第一个成员先被初始化,然后第二个,以此类推。<strong>构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序</strong>。</p>
<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>C++11新标准扩展了构造函数初始值的功能,使得我们可以定义所谓的<strong>委托构造函数</strong>( delegating constructor)。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程,或者说它把它自自己的一些(或者全部)职责委托给了其他构造函数。</p>
<p>和其他构造函数一样,一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数内,成员初始值列表只有一个唯一的入口,就是类名本身。和其他成员初始值一样,类名后面紧跟圆括号括起来的参数列表,参数列表必须与类中另外一个构造函数匹配。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518610183005.jpg" alt="enter description here"></p>
<h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><p>我们能为类定义隐式转换规则。如果<strong>构造函数只接受一个实参,则它实际上定义了转换为此类类型的隐式转换机制</strong>,有时我们]把这种构造函数称作<strong>转换构造函数</strong></p>
<blockquote>
<p>抑制构造函数定义的隐式转换</p>
</blockquote>
<p>在要求隐式转换的程序上下文中,我们们可以通过将构造函数声明为explicit加以阻止:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518610514067.jpg" alt="enter description here"></p>
<h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p>聚合类( aggregate class)使得用户可以直接访问其成员,并且具有特殊的初始化语法形式。当一个类满足如下条件时,我们说它是聚合的:</p>
<ul>
<li>所有成员都是public的</li>
<li>没有定义任何构造函数。</li>
<li>没有类内初始值</li>
<li>没有基类,也没有 virtual函数,关于这部分知识我们将在第15章详细介绍</li>
</ul>
<h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><p><strong>数据成员都是字面值类型的聚合类</strong>是字面值常量类。如果一个类不是聚合类,但它符合下述要求,则它也是一个字面值常量类</p>
<ul>
<li>数据成员都必须是字面值类型。</li>
<li>类必须至少含有一个 constexpr构造造函数。</li>
<li>如果一个数据成员含有类内初始值,则内置类型成员的初始值必须是一条常量表达式;或者如果成员属于某种类类型,则初始值必须使用成员自己的 constexpr构造函数</li>
<li>类必须使用析构函数的默认定义,该成员负责销毀类的对象</li>
</ul>
<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。</p>
<blockquote>
<p>声明静态成员</p>
</blockquote>
<p>我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员样,静态成员可以是 public的或 private的。静态数据成员的类型可以是常量、引用、指针、类型等</p>
<p>我们使用作用域运算符直接访问静态成员：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> r;</div><div class="line">r = Account::rate();</div></pre></td></tr></table></figure></p>
<blockquote>
<p>定义静态成员</p>
</blockquote>
<p>和其他的成员函数一样,我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时,不能重复 static关键字,该关键字只出现在类内部的声明语句:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Account::rate( <span class="keyword">double</span> newRate)</div><div class="line">&#123;</div><div class="line">	interesRate = newRate;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>我们不能在类的内部初始化静态成员。相反的,必须在类的外部定义和初始化每个静态成员。</p>
<blockquote>
<p>静态成员的类内初始化</p>
</blockquote>
<p>通常情况下・类的静态成员不应该在类的内部初始化。然而,我们可以为静态成员提供 const整数类型的类内初始值,不过要求静态成员必须是字面值常量类型的constexpr</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="https://data1.liuin.cn/wechat_pay.png" alt="Sixzeroo WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="https://data1.liuin.cn/alipay.jpg" alt="Sixzeroo Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Sixzeroo
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://www.liuin.cn/2018/02/15/《C-Primer》笔记-C-基础部分/" title="《C++ Primer》笔记 C++基础部分">https://www.liuin.cn/2018/02/15/《C-Primer》笔记-C-基础部分/</a>
  </li>
  <li class="post-copyright-author">
	<strong>发布时间: </strong>
	2018年2月15日 - 21时02分
  </li>
  <li class="post-copyright-author">
	<strong>最后更新: </strong>
	2018年2月23日 - 12时02分
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C-C/" rel="tag"># C/C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/02/14/Nginx-配置反向代理/" rel="next" title="Nginx 配置反向代理">
                <i class="fa fa-chevron-left"></i> Nginx 配置反向代理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/02/16/Docker-Machine-简介/" rel="prev" title="Docker Machine 简介">
                Docker Machine 简介 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMTYzMi84MTk2"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://data1.liuin.cn/ava1.jpg"
               alt="Sixzeroo" />
          <p class="site-author-name" itemprop="name">Sixzeroo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives">
            
                <span class="site-state-item-count">184</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">42</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Sixzeroo" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      github
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="tencent://message/?menu=yes&uin=1790798600&websitename=im.qq.com" target="_blank" title="QQ">
                  
                    <i class="fa fa-fw fa-qq"></i>
                  
                    
                      QQ
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#变量和基本类型"><span class="nav-number">1.</span> <span class="nav-text">变量和基本类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本内置类型"><span class="nav-number">1.1.</span> <span class="nav-text">基本内置类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算术类型"><span class="nav-number">1.1.1.</span> <span class="nav-text">算术类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型转换"><span class="nav-number">1.1.2.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字面值常量"><span class="nav-number">1.1.3.</span> <span class="nav-text">字面值常量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量"><span class="nav-number">1.2.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变量定义"><span class="nav-number">1.2.1.</span> <span class="nav-text">变量定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量声明和定义的关系"><span class="nav-number">1.2.2.</span> <span class="nav-text">变量声明和定义的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标识符（identifier）"><span class="nav-number">1.2.3.</span> <span class="nav-text">标识符（identifier）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#名字的作用域"><span class="nav-number">1.2.4.</span> <span class="nav-text">名字的作用域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复合类型"><span class="nav-number">1.3.</span> <span class="nav-text">复合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引用"><span class="nav-number">1.3.1.</span> <span class="nav-text">引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针"><span class="nav-number">1.3.2.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解复合类型的声明"><span class="nav-number">1.3.3.</span> <span class="nav-text">理解复合类型的声明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const限定符"><span class="nav-number">1.4.</span> <span class="nav-text">const限定符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#顶层const"><span class="nav-number">1.4.1.</span> <span class="nav-text">顶层const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constexpr-和常量表达式"><span class="nav-number">1.4.2.</span> <span class="nav-text">constexpr 和常量表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理类型"><span class="nav-number">1.5.</span> <span class="nav-text">处理类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#auto类型说明符"><span class="nav-number">1.5.1.</span> <span class="nav-text">auto类型说明符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#decltype类型指示符"><span class="nav-number">1.5.2.</span> <span class="nav-text">decltype类型指示符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串、向量和数组"><span class="nav-number">2.</span> <span class="nav-text">字符串、向量和数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#标准库类型string"><span class="nav-number">2.1.</span> <span class="nav-text">标准库类型string</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准库类型vector"><span class="nav-number">2.2.</span> <span class="nav-text">标准库类型vector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器介绍"><span class="nav-number">2.3.</span> <span class="nav-text">迭代器介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用迭代器"><span class="nav-number">2.3.1.</span> <span class="nav-text">使用迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器运算"><span class="nav-number">2.3.2.</span> <span class="nav-text">迭代器运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">2.4.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多维数组"><span class="nav-number">2.5.</span> <span class="nav-text">多维数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#表达式"><span class="nav-number">3.</span> <span class="nav-text">表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础"><span class="nav-number">3.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-number">3.1.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求值顺序"><span class="nav-number">3.1.2.</span> <span class="nav-text">求值顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算术运算符"><span class="nav-number">3.2.</span> <span class="nav-text">算术运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逻辑运算符和关系运算符"><span class="nav-number">3.3.</span> <span class="nav-text">逻辑运算符和关系运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#赋值运算符"><span class="nav-number">3.4.</span> <span class="nav-text">赋值运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递增运算符和递减运算符"><span class="nav-number">3.5.</span> <span class="nav-text">递增运算符和递减运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sizeof运算符"><span class="nav-number">3.6.</span> <span class="nav-text">sizeof运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逗号运算符"><span class="nav-number">3.7.</span> <span class="nav-text">逗号运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型转换-1"><span class="nav-number">3.8.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#其他隐式类型转换"><span class="nav-number">3.8.1.</span> <span class="nav-text">其他隐式类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#显式转换"><span class="nav-number">3.8.2.</span> <span class="nav-text">显式转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符优先级表"><span class="nav-number">3.9.</span> <span class="nav-text">运算符优先级表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#语句"><span class="nav-number">4.</span> <span class="nav-text">语句</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#条件语句"><span class="nav-number">4.1.</span> <span class="nav-text">条件语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代语句"><span class="nav-number">4.2.</span> <span class="nav-text">迭代语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#范围for语句"><span class="nav-number">4.2.1.</span> <span class="nav-text">范围for语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#try语句块和异常处理"><span class="nav-number">4.3.</span> <span class="nav-text">try语句块和异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标注异常"><span class="nav-number">4.3.1.</span> <span class="nav-text">标注异常</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-number">5.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数基础"><span class="nav-number">5.1.</span> <span class="nav-text">函数基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#局部对象"><span class="nav-number">5.1.1.</span> <span class="nav-text">局部对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数声明"><span class="nav-number">5.1.2.</span> <span class="nav-text">函数声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分离式编译"><span class="nav-number">5.1.3.</span> <span class="nav-text">分离式编译</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参数传递"><span class="nav-number">5.2.</span> <span class="nav-text">参数传递</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const形参和实参"><span class="nav-number">5.2.1.</span> <span class="nav-text">const形参和实参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组形参"><span class="nav-number">5.2.2.</span> <span class="nav-text">数组形参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#含有可变形参的参数"><span class="nav-number">5.2.3.</span> <span class="nav-text">含有可变形参的参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#返回类型和return语句"><span class="nav-number">5.3.</span> <span class="nav-text">返回类型和return语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数重载"><span class="nav-number">5.4.</span> <span class="nav-text">函数重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特殊用途语言特性"><span class="nav-number">5.5.</span> <span class="nav-text">特殊用途语言特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#默认实参"><span class="nav-number">5.5.1.</span> <span class="nav-text">默认实参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内联函数和constexpr函数"><span class="nav-number">5.5.2.</span> <span class="nav-text">内联函数和constexpr函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内联函数可以避免函数调用的开销"><span class="nav-number">5.5.2.1.</span> <span class="nav-text">内联函数可以避免函数调用的开销</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#constexpr函数"><span class="nav-number">5.5.2.2.</span> <span class="nav-text">constexpr函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调试帮助"><span class="nav-number">5.5.3.</span> <span class="nav-text">调试帮助</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#assert-预处理宏"><span class="nav-number">5.5.3.1.</span> <span class="nav-text">assert 预处理宏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NDEBUG-预处理变量"><span class="nav-number">5.5.3.2.</span> <span class="nav-text">NDEBUG 预处理变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数匹配"><span class="nav-number">5.6.</span> <span class="nav-text">函数匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#确定候选函数和可行函数"><span class="nav-number">5.6.1.</span> <span class="nav-text">确定候选函数和可行函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实参类型转换"><span class="nav-number">5.6.2.</span> <span class="nav-text">实参类型转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数指针"><span class="nav-number">5.7.</span> <span class="nav-text">函数指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类"><span class="nav-number">6.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义抽象数据类型"><span class="nav-number">6.1.</span> <span class="nav-text">定义抽象数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义类的基本"><span class="nav-number">6.1.1.</span> <span class="nav-text">定义类的基本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#引入-this"><span class="nav-number">6.1.1.1.</span> <span class="nav-text">引入 this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引入const-成员函数"><span class="nav-number">6.1.1.2.</span> <span class="nav-text">引入const 成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类作用域和成员函数"><span class="nav-number">6.1.1.3.</span> <span class="nav-text">类作用域和成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在类外部定义成员函数"><span class="nav-number">6.1.1.4.</span> <span class="nav-text">在类外部定义成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义一个返回this对象的函数"><span class="nav-number">6.1.1.5.</span> <span class="nav-text">定义一个返回this对象的函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数"><span class="nav-number">6.1.2.</span> <span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#合成的默认构造函数"><span class="nav-number">6.1.2.1.</span> <span class="nav-text">合成的默认构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#某些类不能依赖于合成的默认构造函数"><span class="nav-number">6.1.2.2.</span> <span class="nav-text">某些类不能依赖于合成的默认构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#default的含义"><span class="nav-number">6.1.2.3.</span> <span class="nav-text">=default的含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数的初始值列表"><span class="nav-number">6.1.2.4.</span> <span class="nav-text">构造函数的初始值列表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拷贝、赋值和析构"><span class="nav-number">6.1.3.</span> <span class="nav-text">拷贝、赋值和析构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#某些类不能依赖于合成的版本"><span class="nav-number">6.1.3.1.</span> <span class="nav-text">某些类不能依赖于合成的版本</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问控制与封装"><span class="nav-number">6.2.</span> <span class="nav-text">访问控制与封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#友元"><span class="nav-number">6.2.1.</span> <span class="nav-text">友元</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的其他特性"><span class="nav-number">6.3.</span> <span class="nav-text">类的其他特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类成员再探"><span class="nav-number">6.3.1.</span> <span class="nav-text">类成员再探</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回-this的成员函数"><span class="nav-number">6.3.2.</span> <span class="nav-text">返回*this的成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类类型"><span class="nav-number">6.3.3.</span> <span class="nav-text">类类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#友元再探"><span class="nav-number">6.3.4.</span> <span class="nav-text">友元再探</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的作用域"><span class="nav-number">6.4.</span> <span class="nav-text">类的作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#名字查找和类的作用域"><span class="nav-number">6.4.1.</span> <span class="nav-text">名字查找和类的作用域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数再探"><span class="nav-number">6.5.</span> <span class="nav-text">构造函数再探</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数初始值列表"><span class="nav-number">6.5.1.</span> <span class="nav-text">构造函数初始值列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#委托构造函数"><span class="nav-number">6.5.2.</span> <span class="nav-text">委托构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隐式的类类型转换"><span class="nav-number">6.5.3.</span> <span class="nav-text">隐式的类类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚合类"><span class="nav-number">6.5.4.</span> <span class="nav-text">聚合类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字面值常量类"><span class="nav-number">6.5.5.</span> <span class="nav-text">字面值常量类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的静态成员"><span class="nav-number">6.6.</span> <span class="nav-text">类的静态成员</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sixzeroo</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">共</span>
    
    <span title="Site words total count">
      360.4k 字
    </span>
  

  <span> | </span>
  <span id="showDays"></span>
</div>



  <div class="powered-by">皖ICP备17000842号</div>
  <span class="post-meta-divider">|</span>                    
  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>



<script>
	var birthDay = new Date('09/1/2016');
	var now = new Date();
	var duration = now.getTime() - birthDay.getTime();
	var total= Math.floor(duration / (1000 * 60 * 60 * 24));
	document.getElementById('showDays').innerHTML='本站已运行' + total + '天';
</script>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>



<script type="text/javascript">
$(document).ready(function(){
  var $article = $(".post-body");
  var count = [0, 0, 0, 0, 0, 0];
  var mark = [0, 0, 0, 0, 0, 0];

  (function setMark(){
    var hTag = ["h1", "h2", "h3", "h4", "h5", "h6"];
    var index = 0;
    for (var i = 0; i < 6; ++i) {
      if ($article.children(hTag[i]).length > 0) {
        ++index;
        mark[i] = index;
      }
    }
  })();

  $article.children(":header").each(function(){
    var t = $(this);
    var pos = 0;
    switch (t[0].tagName) {
      case "H1": pos = 0; break;
      case "H2": pos = 1; break;
      case "H3": pos = 2; break;
      case "H4": pos = 3; break;
      case "H5": pos = 4; break;
      case "H6": pos = 5; break;
    }

    var len = mark[pos];
    if (len < 6) { count[len] = 0; }
    count[len - 1]++;

    var listStr = count[0] + "";
    for (var i = 1; i < len; ++i) { listStr += "." + count[i]; }
    listStr += " ";
    t.html(listStr + t.html());
  });
});
</script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("3YyBK9PnKj86xfGt1vr8ps6Q-gzGzoHsz", "Sf6vsslcm0nwqrxAcm1MMwRM");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  


  

  

</body>
</html>
