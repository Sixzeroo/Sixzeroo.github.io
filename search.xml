<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[《C++ Primer》笔记 C++标准库部分]]></title>
      <url>/2018/03/04/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-C-%E6%A0%87%E5%87%86%E5%BA%93%E9%83%A8%E5%88%86/</url>
      <content type="html"><![CDATA[<p>《C++ Primer》笔记 C++基础部分</p>
<a id="more"></a>
<h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><p>大部分的I/O库设施：</p>
<ul>
<li>istream(输入流)类型,提供输入操作。</li>
<li>ostream(输出流)类型,提供输出操作。</li>
<li>cin，一个 istream对象,从标准输入读取数据。</li>
<li>cout,一个 ostream对象,向标准输出写入数据。</li>
<li>cerr,一个 ostream对象,通常用于输出程序错误消息,写入到标准错误・</li>
<li><blockquote>
<blockquote>
<p>运算符,用来从一个istream对象读取输入数据。</p>
</blockquote>
</blockquote>
</li>
<li>&lt;&lt;运算符,用来向一个ostream对象写入输出数据。</li>
<li>getline函数,从一个给定的 istream读取一行数据,存入一个给定的 string对象中。</li>
</ul>
<h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><p>我们已经使用过的IO类型和对象都是操纵char数据的。默认情况下,这些对象都是关联到用户的控制台窗口的。</p>
<p>为了支持这些不同种类的IO处理操作,在 istream和ostream之外,标准库还定义了其他一些IO类型:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518671687211.jpg" alt="enter description here"></p>
<p>为了支持宽字符的语言，标准库定义了一组类型和对象来操纵wchat_t类型的数据。宽字符版本的类型和函数的名字以一个w开始。</p>
<blockquote>
<p>IO类型之间的关系</p>
</blockquote>
<p>标准库使我们能忽略这些不同类型的流之间的差异,这是通过<strong>继承机制</strong>( inheritance)实现的。利用模板,我们可以使用具有继承关系的类,而不必了解继承机制如何工作的细节。简单地说,继承机制使我们可以声明一个特定的类继承自另一个类。我们通常可以将一个派生类(继承类)对象当作其基类(所继承的类)对象来使用</p>
<h3 id="IO对象无拷贝或赋值"><a href="#IO对象无拷贝或赋值" class="headerlink" title="IO对象无拷贝或赋值"></a>IO对象无拷贝或赋值</h3><p>我们不能拷贝或者对IO对象赋值，由于不能拷贝IO对象，因此我们也不能将形参或者函数返回类型设置为流类型。进行IO操作的函数通常以引用的方式传递和返回流。</p>
<p>读取或者返回一个IO对象会改变其状态，因此传递和引用不能是const的</p>
<h3 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h3><blockquote>
<p>查询流状态</p>
</blockquote>
<p>IO库定义了一个与机器无关的 iostate类型,它提供了表达流状态的完整功能。这个类型应作为一个位集合来使用</p>
<blockquote>
<p>管理条件状态</p>
</blockquote>
<p>流对象的 rdstate 成员返回一个iostate值,对应流的当前状态。 setstate操作将给定条件位置位,表示发生了对应错误。clear成员是一个重載的成员:它有一个不接受参数的版本,而另一个版本接受一个 iostate类型型的参数。</p>
<h3 id="管理输出缓存"><a href="#管理输出缓存" class="headerlink" title="管理输出缓存"></a>管理输出缓存</h3><p>每一个输出流都管理一个缓冲区，用来保存程序读写的数据。</p>
<p>文本串可能立即打印出来,但也有可能被操作系统保存在缓冲区中,随后再打印。有了缓冲机制,操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很耗时,<strong>允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升</strong>。</p>
<p>导致缓冲刷新(即,数据真正写到输出设备或文件)的原因有很多：</p>
<ul>
<li>程序正常结束,作为main函数的 return操作的一部分,缓冲冲刷新被执行。</li>
<li>缓冲区满时,需要刷新缓冲,而后新的数据才能继续写入缓冲区。</li>
<li>我们可以使用操纵符如endl来显式刷新缓冲区。</li>
<li>在每个输出操作之后,我们可以用操纵符unitbuf设置流的内部状态,来清空缓冲区。</li>
<li>一个输出流可能被关联到另一个流。在这种情况下,当读写被关联的流时,关联到的流的缓冲区会被刷新。</li>
</ul>
<blockquote>
<p>刷新输出缓冲区</p>
</blockquote>
<p>我们已经使用过操纵符endl,它完成换行并刷新缓冲区的工作。IO库中还有两个类似的操纵符:flush和ends。flush刷新缓冲区,但不输出任何额外的字符;ends向缓冲区插入一个空字符,然后刷新缓冲区</p>
<blockquote>
<p>uintbuf操作符</p>
</blockquote>
<p>如果想在每次输出操作后都刷新缓冲区,我们可以使用 unitbuf操纵符。它告诉流在接下来的每次写操作之后都进行一次=flush操作。而 nounitbuf操纵符则重置流,使其恢复使用正常的系统管理的缓冲区刷新机制:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518672433805.jpg" alt="enter description here"></p>
<h2 id="文件的输入输出"><a href="#文件的输入输出" class="headerlink" title="文件的输入输出"></a>文件的输入输出</h2><p>头文件 fstream定义了三个类型来支持文件IO: ifstream从一个给定文件读取数据,ofstream向一个给定文件写入数据,以及 fstream可以读写给定文件。</p>
<p>除了继承自 iostream类型的行为之外, fstream中定义的类型还增加了一些新的成员来管理与流关联的文件</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518672783415.jpg" alt="enter description here"></p>
<h3 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h3><p>当我们想要读写一个文件时,可以定义一个文件流对象,并将对象与文件关联起来。每个文件流类都定义了一个名为open的成员函数,它完成一些系统相关的操作,来定位给定的文件,并视情况打开为读或写模式。</p>
<blockquote>
<p>成员函数open和close</p>
</blockquote>
<p>如果我们定义一个空文件流对象，随后我们可以调用open来将它与文件关联起来。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518672886373.jpg" alt="enter description here"></p>
<p>如果调用open失败, failbit会被置位。因为调用open可能失败,进行open是否成功的检测通常是一个好习惯</p>
<h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><p>每一个流都有一个关联的<strong>文件模式</strong>（file mode），用来指出如何使用文件。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518672976516.jpg" alt="enter description here"></p>
<p>无论用哪种方式打开文件,我们都可以指定文件模式,调用open打开文件时可以,用一个文件名初始化流来隐式打开文件时也可以。</p>
<blockquote>
<p>以out模式打开文件会丢弃</p>
</blockquote>
<p>已有数据默认情况下,当我们打开一个 ofstream时,文件的内容会被丢弃。阻止一个ofstream清空给定文件内容的方法是同时指定aap模式:</p>
<h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><p>sstream头文件定义了三个类型来支持内存IO,这些类型可以向 string写入数据,从string读取数据,就像string是一个IO流一样。</p>
<p>istringstream从 string读取数据，ostringstream向 string写入数据,而头文件 stringstream既可从 string读数据也可向 string写数据。与fstream类型类似,头文件 sstream中定义的类型都继承自我们已经使用过的 iostream头文件中定义的类型。除了继承得来的操作, sstream中定义的类型还增加了一些成员来管理与流相关联的string。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518676701978.jpg" alt="enter description here"></p>
<h3 id="使用istringstream"><a href="#使用istringstream" class="headerlink" title="使用istringstream"></a>使用istringstream</h3><p>当我们的某些工作室对整行的文本进行处理，而其他的一些工作是处理行内的单个单词时，通常可以使用istringstream</p>
<h3 id="使用ostringstream"><a href="#使用ostringstream" class="headerlink" title="使用ostringstream"></a>使用ostringstream</h3><p>当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>C++使用标准库类来处理面向流的输入和输出:</p>
<ol>
<li>iostream处理控制台</li>
<li>fstream处理命名文件</li>
<li>stringstream完成内存string的IO</li>
</ol>
<hr>
<h1 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h1><p>一个容器就是一些特定类型对象的集合。<strong>顺序容器</strong>( sequential container)为程序员提供了<strong>控制元素存储和访问顺序的能力</strong>。这种顺序<strong>不依赖于元素的值,而是与元素加入容器时的位置相对应</strong>。与之相对的,我们将在第11章介绍的有序和无序关联容器,则根据关键字的值来存储元素。</p>
<h2 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_16_1518790789624.jpg" alt="enter description here"></p>
<p>以上就是标准库中的顺序容器了，所有顺序容器提供快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：</p>
<ul>
<li>向容器添加或从容器中删除元素的代价</li>
<li>非顺序访问容器中元素的代价</li>
</ul>
<p>除了固定大小的的 array外,其他容器都提供高效、灵活的内存管理。</p>
<p>list和 forward_list 两个容器的设计目的是<strong>令容器任何位置的添加和删除操作都很快速</strong>。作为代价,这两个容器不支持元素的随机访问:为了访问一个元素,我们只能遍历整个容器。而且,与 vector、 deque和 array相比,这两个容器的额外内存开销也很大。</p>
<p>deque是一个更为复杂的数据结构。与string和 vector类似, deque支持快速的随机访问。与 string和 vector一样,在 deque的中间位置添加或删除元素的代价(可能)很高。但是,<strong>在 deque的两端添加或删除元素都是很快的</strong>,与list或forward_list添加删除元素的速度相当。</p>
<p>以下是选择容器的基本原则：</p>
<ul>
<li>除非你有很好的理由选择其他容器,否则应使用 vector。</li>
<li>如果你的程序有很多小的的元素,且空间的额外开销很重要,则不要使用list或forward_list。</li>
<li>如果程序要求随机访问元素,应使用 vector或 deque如果程序要求在容器的中间插入或删除元素,应使用list或forward_list。</li>
<li>如果程序需要在头尾位置插入或删除元素,但不会在中间位置进行插入或删除操作,则使用 deque</li>
<li>如果程序只有在读取输入时才需要在容器中间位置插入元素,随后需要随机访问元素,则：首先，确定是否真的需要在容器中间添加元素；如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的额内容拷贝到一个vector 中</li>
</ul>
<h2 id="容器库概览"><a href="#容器库概览" class="headerlink" title="容器库概览"></a>容器库概览</h2><p>容器类型上形成了一种层次：</p>
<ul>
<li>某些操作是所有容器类型都提供的</li>
<li>另外一些操作仅针对顺序容器、关联容器或无序容器</li>
<li>还有一些操作只适用于一小部分容器</li>
</ul>
<p>本节我们介绍所有容器都适用的操作</p>
<p>一般来说，每个容器都定义在一个头文件中，文件名与类型名相同；顺序容器几乎可以保存任意类型的元素。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_16_1518793115931.jpg" alt="enter description here"></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>与容器一样,迭代器有着公共的接口:如果一个迭代器提供某个操作,那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。</p>
<p>一个迭代器范围( iterator range)由一对迭代器表示,两个迭代器分别指向同一个容器中的元素或者是<strong>尾元素之后的位置</strong>( one past the last element)。这两个迭代器通常被称为 begin和end,或者者是 first和laste(可能有些误导),它们标记了容器中元素的个范围</p>
<p>这种元素范围被称为<strong>左闭合区间</strong>( left-inclusive interval),其标准数学描述为<code>[begin, end)</code></p>
<h3 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h3><p>反向迭代器就是一种反向遍历容器的迭代器,与正向迭代器相比,各种操作的含义也都发生了颠倒</p>
<p>,通过类型别名,我们可以在不了解容器中元素类型的情况下使用它。如果需要元素类型,可以使用容器的value_type。如果需要元素类型的一个引用,可以使用 reference或 const_reference。这些元素相关的类型别名在泛型编程中非常有用</p>
<h3 id="begin-和-end成员"><a href="#begin-和-end成员" class="headerlink" title="begin 和 end成员"></a>begin 和 end成员</h3><p>begin和end操作生成指向容器中第一个元素和尾元素之后位置的迭代器。这两个迭代器最常见的用途是形成一个包含容器中所有元素的迭代器范围</p>
<h3 id="容器定义和初始化"><a href="#容器定义和初始化" class="headerlink" title="容器定义和初始化"></a>容器定义和初始化</h3><p>每个容器类型都定义了一个默认构造函数。除 array之外,其他容器的默认构造函数都会创建一个指定类型的空容器,且都可以接受指定容器大小和元素初始值的参数。</p>
<blockquote>
<p>将一个容器初始化为另一个容器的拷贝</p>
</blockquote>
<p>将一个新容器创建为另一个容器的拷贝的方法有两种:可以直接拷贝整个容器,或者( array除外)拷贝由一个迭代器对指定的元素范围。为了创建一个容器为另一个容器的拷贝,两个容器的类型及其元素类型必须匹配。不过,当传递迭代器参数来拷贝一个范围时,就不要求容器类型是相同的了。而且,新容器和原容器中的元素类型也可以不同,只要能将要拷贝的元素转换</p>
<blockquote>
<p>与顺序容器大小相关的构造函数</p>
</blockquote>
<p>除了与关联容器相同的构造函数外,顺序容器( array除外)还提供另一个构造函数,它接受一个容器大小和一个(可选的)元素初始值。</p>
<h3 id="赋值与swap"><a href="#赋值与swap" class="headerlink" title="赋值与swap"></a>赋值与swap</h3><p>赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝。</p>
<blockquote>
<p>使用assign</p>
</blockquote>
<p>顺序容器( array除外)还定义了一个名为 assign的成员,允许我们从一个不同但相容的类型赋值,或者从容器的一个子序列赋值。assign操作用参数所指定的元素(的拷贝)替换左边容器中的所有元素。例如,我们可以用 assign实现将一个 vector中的一段char*值赋予一个list中的 string：<br><img src="https://data2.liuin.cn/story-writer/2018_2_16_1518794438240.jpg" alt="enter description here"></p>
<blockquote>
<p>使用swap</p>
</blockquote>
<p>除 array外,交换两个容器内容的操作保证会很快——元素本身并未交换,swap只是交換了两个容器的内部数据结构。</p>
<p>元素不会被移动的事实意味着,除string外,指向容器的迭代器、引用和指针在swap操作之后都不会失效。它们仍指向swap操作之前所指向的那些元素。但是,在swap之后,这些元素已经属于不同的容器了。</p>
<p>与其他容器不同,swap两个 array会真正交换它们的元素。因此,交換两个 array所需的时间与 array中元素的数目成正比。</p>
<h3 id="容器大小操作"><a href="#容器大小操作" class="headerlink" title="容器大小操作"></a>容器大小操作</h3><p>除了一个例外,每个容器类型都有三个与大小相关的操作：</p>
<ul>
<li>成员函数size，返回容器中元素的数目; </li>
<li>empty当size为0时返回布尔值true,否则返回回false</li>
<li>max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。</li>
</ul>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符左右两边的运算对象必须是相同类型的容器,且必须保存相同类型的元素。</p>
<p>比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与string的关系运算类似:</p>
<ul>
<li>如果两个容器具有相同大小且所有元素都两两对应相等,则这两个容器相等;否则两个容器不等</li>
<li>如果两个容器大小不同,但较小容器中每个元素都等于较大容器中的对应元素,则则较小容器小于较大容器。</li>
<li>如果两个容器都不是另一个容器的前缀子序列,则它们的比较结果取決于第一个不相等的元素的比较结果。</li>
</ul>
<h2 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h2><h3 id="向顺序容器添加元素"><a href="#向顺序容器添加元素" class="headerlink" title="向顺序容器添加元素"></a>向顺序容器添加元素</h3><p>除 array外,所有标准库容器都提供灵活的内存管理。在运行时可以动态添加或刑除元素来改变容器大小。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518833554118.jpg" alt="enter description here"></p>
<p>在一个 vector或 string的尾部之外的任何位置,或是一个 deque的首尾之外的任何位置添加元素,都需要移动元素。而且,向一个 vector或 string添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存,并将元素从旧的空间移动到新的空间中。</p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>包括 array在内的每个顺序容器都有一个 front成员函数,而除 forward_list之外的所有顺序容器都有一个back成员函数。这两个操作分别返回首元素和尾元素的引用</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518833711199.jpg" alt="enter description here"></p>
<blockquote>
<p>下标操作和安全的随机访问</p>
</blockquote>
<p>提供快速随机访问的容器( string、 vector、 deque和 array)也都提供下标运算符。就像我们已经看到的那样,下标运算符接受一个下标参数,返回容器中该位置的元素的引用。<strong>给定下标必须“在范围内”</strong>(即,大于等于0,且小于容器的大小)。保证下标有效是程序员的责任,下标运算符并不检査下标是否在合法范围内。<strong>使用越界的下标是一种严重的程序设计错误</strong>,而且编译器并不检査这种错误。</p>
<p>如果我们希望确保下标是合法的,可以使用at成员函数。at成员函数类似下标运算,但如果下标越界,at会地出一个out of range异常:</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518834076074.jpg" alt="enter description here"></p>
<h3 id="特殊的forward-list操作"><a href="#特殊的forward-list操作" class="headerlink" title="特殊的forward_list操作"></a>特殊的forward_list操作</h3><p>在一个单向链表中,没有简单的方法来获取一个元素的前驱。出于这个原因,在一个 forward_list中添加或删除元素的操作是通过改变给定元素之后的元素来完成的</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518834143966.jpg" alt="enter description here"></p>
<h3 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h3><p>我们可以用rsize来增大或缩小容器・与往常一样, array不支持 resize。如果当前大小大于所要求的大小,容器后部的元素会被別除:如果当前大小小于新大小,会将新元素添加到容器后部:</p>
<h3 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h3><p>向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误,很可能引起与使用未初始化指针一样的问题</p>
<p>当你使用迭代器(或指向容器元素的引用或指针)时,最小化要求迭代器必须保持有效的程序片段是一个好的方法。</p>
<p>程序必须保证每个循环中都更新迭代器、引用或指针</p>
<blockquote>
<p>不要保存end返回的迭代器</p>
</blockquote>
<p>当我们添加删除 vector或 string的元素后,或在 deque中首元素之外任何位置添加删除元素后,原来end返回的迭代器总是会失效。因此,<strong>添加或删除元素的循环程序必须反复调用end,而不能在循环之前保存end返回的迭代器</strong>,一直当作容器末尾使用。通常C++标准库的实现中end()操作都很快,部分就是因为这个原因。</p>
<h2 id="vector对象是如何增长的"><a href="#vector对象是如何增长的" class="headerlink" title="vector对象是如何增长的"></a>vector对象是如何增长的</h2><p>为了支持快速随机访问，vector将元素连续存储——每个元素紧挨着前一个元素存储。</p>
<p>假定容器中元素是连续存储的,且容器的大小是可变的,考虑向 vector或string中添加元素会发生什么:如果没有空间容纳新元素,容器不可能简单地将它添加到内存中其他位置一一因为元素必须连续存储。容器必须分配新的内存空间来保存已有元素和新元素,将已有元素从旧位置移动到新空间中,然后添加新元素,释放旧存储空间。如如果我们每添加一个新元素, vector就执行一次这样的内存分配和释放操作,性能会慢到不可</p>
<p>为了避免这种代价,标准库实现者采用了可以减少容器空间重新分配次数的策略。当不得不获取新的内存空间时, vector和 string的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用,可用来保存更多的新元素。</p>
<p>vector 在每次重新分配内存的时候都要移动所有元素</p>
<blockquote>
<p>管理容量的成员函数</p>
</blockquote>
<p> capacity操作告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素。 reserve操作允许我们通知容器它应该准备保存多少个元素。</p>
<blockquote>
<p>capacity和size</p>
</blockquote>
<p>理解 capacity和size的区别非常重要。容器的size是指它已经保存的元素的数目;而 capacity则是在不分配新的内存空间的前提下它最多可以保存多少元素。</p>
<h2 id="额外的string操作"><a href="#额外的string操作" class="headerlink" title="额外的string操作"></a>额外的string操作</h2><h3 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861676844.jpg" alt="enter description here"></p>
<blockquote>
<p>substr操作</p>
</blockquote>
<p>substr操作返回一个str1ng,它是原始 string的一部分或全部的拷贝。可以传递给 substr一个可选的开始位置和计数值:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861736953.jpg" alt="enter description here"></p>
<h3 id="改变string的其他方法"><a href="#改变string的其他方法" class="headerlink" title="改变string的其他方法"></a>改变string的其他方法</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861803653.jpg" alt="enter description here"></p>
<h3 id="string搜索操作"><a href="#string搜索操作" class="headerlink" title="string搜索操作"></a>string搜索操作</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861836971.jpg" alt="enter description here"></p>
<h3 id="compare函数"><a href="#compare函数" class="headerlink" title="compare函数"></a>compare函数</h3><p>除了关系运算符外,标准准库str1ng类型还提供了一组compare函数,这些函数与C标准库的 strcmp函数很相似。类似 strcmp,据据s是等于、大于还是小于参数指定的字符串,s. compare返回回0、正数或负数。</p>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861942715.jpg" alt="enter description here"></p>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>除了顺序容器外,标准库还定义了三个顺序容器适配器: stack、 queue和priority_queue。<strong>适配器</strong>( adaptor)是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上,<strong>一个适配器是一种机制,能使某种事物的行为看起来像另外一种事物一样</strong>。一个容器适配器接受一种已有的容器类型,使其行为看起来像一种不同的类型。</p>
<blockquote>
<p>定义一个适配器</p>
</blockquote>
<p>每个适配器都定义两个构造函数:默认构造函数创建一个空对象,接受一个容器的构造函数拷贝该容器来初始化适配器。</p>
<p>默认情况下, stack和 queue是基于 deque实现的,priority_queue是在 vector之上实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第三个类型参数,来重载默认容器类型。</p>
<p>对于一个给定的适配器,可以使用哪些容器是有限制的。所有适配器都要求容器具有添加和删除元素的能力。因此,适配器不能构造在aray之上。类似的,我们也不能用forward_list来构造适配器,因为所有适配器都要求容器具有添加、删除以及访间尾元素的能力。 stack只要求 push_back、 pop_back和back操作,因此可以使用除 array</p>
<blockquote>
<p>栈适配器<br><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518862439794.jpg" alt="enter description here"></p>
</blockquote>
<p>每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作。我们只可以使用适配器操作,而不能使用底层容器类型的操作。</p>
<blockquote>
<p>队列适配器</p>
</blockquote>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518862492187.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518862504010.jpg" alt="enter description here"></p>
<p>标准库queue使用一种先进先出（first-in，first-out，FIFO）的存储和访问策略</p>
<p>priority_queue 允许我们为队列中的元素建立优先级，新加入的元素会排在所有优先级比它低的已有元素之前。</p>
<hr>
<h1 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h1><p>标准库容器定义的操作集合惊人得小。标准库并未给每个容器添加大量功能,而是提供了一组算法,这些算法中的大多数都独立于任何特定的容器。这些算法是通用的( generic,或称泛型的):它们可用于不同类型的容器和不同类型的元素。</p>
<p>顺序容器只定义了很少的一些操作，我们可以想象用户可能还希望做其他很多有用的操作:查找特定元素、替換或別除二个特定值、重排元素顺序等。</p>
<p>标准库并未给每个容器都定义成员函数来实现这些操作,而是定义了一组<strong>泛型算法</strong>( generic algorithm):称它们为“算法”,是因为它们实现了一些经典算法的公共接接口,如排序和搜索;称它们是“泛型的”,是因为它们可以用于不同类型的元素和多种容器类型</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一般情况下,泛型算法并不直接操作容器,而是遍历由两个迭代器指定的一个元素范围来进行操作。</p>
<p><strong>迭代器令算法不依赖于容器，但是算法依赖于容器的操作类型</strong>。虽然迭代器的使用令算法不依赖于容器类型,但大多数算法都使用了一个(或多个)元素类型上的操作。</p>
<p>泛型算法本身不会执行容器的操作，它们只会运行于迭代器上，执行迭代器的操作。</p>
<h2 id="初始泛型算法"><a href="#初始泛型算法" class="headerlink" title="初始泛型算法"></a>初始泛型算法</h2><h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p>一些算法只会读取其输入范围内的元素,而从不改变元素。find就是这样一种算法</p>
<p>另一个只读算法是 accumulate,它定义在头文件 numeric i中。 accumulate函数接受三个参数,前两个指出了需要求和的元素的范围,第三个参数是和的初值。accumulate将第三个参数作为求和起点,这蕴含着一个编程假定:将元素类型加到和的类型上的操作必须是可行的。即,序列中元素的类型必须与第三个参数匹配,或者能够转换为第三个参数的类型。</p>
<p>另一个只读算法是equal，用于确定两个序列是否保存相同的值。</p>
<h3 id="写容器元素的算法"><a href="#写容器元素的算法" class="headerlink" title="写容器元素的算法"></a>写容器元素的算法</h3><p>一些算法将新值赋予序列中的元素。当我们使用这类算法时,必须注意<strong>确保序列原大小至少不小于我们要求算法写入的元素数目</strong>。记住,<strong>算法不会执行容器操作,因此它们身不可能改变容器的大小</strong>。</p>
<p>一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素,该序列从目的位置迭代器指向的元素开始。</p>
<blockquote>
<p>介绍back_inserter</p>
</blockquote>
<p>一种保证算法有足够元素空间来容纳输出数据的方法是使用<strong>插入迭代器</strong>( InsertIterator)。插入送代器是一种向容器中添加元素的迭代器。通常情况,当我们通过一个送代器向容器元素赋值时,值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时,一个与赋值号右側值相等的元素被添加到容器中。</p>
<p>back_inserter接受一个指向容器的引用,返回一个与该容器绑定的插入迭代器当我们通过此迭代器赋值时,赋值运算符会调用 push_back将一个具有给定值的元素添加到容器中</p>
<blockquote>
<p>拷贝算法</p>
</blockquote>
<p>拷贝(copy)算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器,前两个表示一个输入范围,第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。</p>
<h3 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h3><p>某些算法会重排容器中元素的顺序,一个明显的例子是sort。调用sort会重排输入序列中的元素,使之有序,它是利用元素类型的运算符来实现排序的</p>
<blockquote>
<p>清除重复单词</p>
</blockquote>
<p>我们就可以使用另一个称为unique的标准库算法来重排ⅴector,使得不重复的元素出现在ⅴector的开始部分。由于算法不能执行容器的操作,我们将使用 vector的 erase成员来完成真正的删除操作</p>
<h2 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h2><p>很多算法都会比较输入序列中的元素。默认情况下,这类算法使用元素类型的&lt;或=运算符完成比较。标准库还为这些算法定义了额外的版本,允许<strong>我们提供自己定义的操作来代替默认运算符</strong>。</p>
<h3 id="向算法传递参数"><a href="#向算法传递参数" class="headerlink" title="向算法传递参数"></a>向算法传递参数</h3><blockquote>
<p>谓词</p>
</blockquote>
<p>谓词是一个可调用的表达式,其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类:一元谓词( unary predicate,意味着它们只接受单一参数)和二元谓词binary predicate,,意味着它们有两个参数)。接受谓词参数的算法对输入序列中的元素调用谓词。因此,元素类型必须能转换为谓词的参数类型。接受一个二元谓词参数的sOrt版本用这个谓词代替&lt;来比较元素。</p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>根据算法接受一元谓词还是二元谓词,我们传递给算法的谓词必须严格接受一个或两个参数。但是,有时我们希望进行的操作需要更多参数,超出了算法对谓词的限制。</p>
<blockquote>
<p>介绍lambda</p>
</blockquote>
<p>我们可以向一个算法传递任何类别的<strong>可调用对象</strong>( callable object)。对于一个对象或一个表达式,如果可以对其使用调用运算符,则称它为可调用的。即,如果e是一个可调用的表达式,则我们可以编写代码e(args),其中args是个逗号分隔的一个或多个参数的列表</p>
<p>到目前为止,<strong>我们使用过的仅有的两种可调用对象是函数和函数指针</strong>。还有其他两种可调用对象:重载了函数调用运算符的类,,以及 lambda表达式( lambda expression)</p>
<p>一个 lambda表达达式表示一个可调用的代码单元。我们们可以将其理解为一个未命名的内联函数。与任何函数类似似,一个 lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同, lambda可能定义在函数内部。一个 lambda表达式具有如下形式：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_18_1518953656030.jpg" alt="enter description here"></p>
<blockquote>
<p>向lambda传递参数</p>
</blockquote>
<p>与一个普通函数调用类似,调用一个 lambda时给定的实参被用来初始化 lambda的形参。通常,实参和形参的类型必须匹配。但与普通函数不同, <strong>lambda不能有默认参数</strong>。因此,一个 lambda调用的实参数目永远与形参数目相等。</p>
<blockquote>
<p>使用捕获列表</p>
</blockquote>
<p>虽然一个 lambda可以出现在一个函数中,使用其局部变量,但它只能使用那些明确指明的变量。<strong>一个 lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量</strong>。捕获列表指引 lambda在其内部包含访问局部变量所需的信息。</p>
<h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>当定义一个 lambda时,编译器生成一个与 lambda对应的新的(未命名的)类类型。目前,可以这样理解,当向个函数传递一个 lambda时,同时定义了一个新类型和该类型的一个对象:传递的参数就是此编译器生成的类类型的未命名对象。类似的,当使用auto定义一个用 lambda初始化的变量时,定义了一个从 lambda生成的类型的对象。</p>
<p>默认情況下,从 lambda生成的类都包含一个对应该 lambda 所捕获的変量的数据成员。类似任何普通类的数据成员, lambda的数据成员也在 lambda对象创建时被初始化。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_18_1518954256455.jpg" alt="enter description here"></p>
<blockquote>
<p>值捕获</p>
</blockquote>
<p>类似参数传递，变量的捕获方式也可以是值或引用。与传值参数类似,采用值捕获的前提是变量可以拷贝。与参数不同,被捕获的变量的值是在 lambda创建时拷贝,而不是调用时拷贝</p>
<blockquote>
<p>引用捕获</p>
</blockquote>
<p>一个以引用方式捕获的变量与其他任何类型的引用的行为类似。当我们在 lambda 函数体内使用此变量时,实际上使用用的是引用所绑定的对象。</p>
<blockquote>
<p>隐式捕获</p>
</blockquote>
<p>除了显式列出我们希望使用的来自所在函数的变量之外,还可以让编译器根据 lambda体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表,应在捕获列表中写一个&amp;或=。&amp;告诉编译器采用捕获引用方式,=则表示采用值捕获方式。</p>
<p>当我们混合使用隐式捕获和显式捕获时,捕获列表中的第一个元素必须是一个&amp;或=。此符号指定了默认捕获方式为引用或值。</p>
<p>当混合使用隐式捕获和显式捕获时,显式捕获的变量必须使用与隐式捕获不同的方式。即,如果隐式捕获是引用方式(使用了&amp;),则则显式捕获命名变量必须采用值方式,因此不能在其名字前使用&amp;。类似的,如如果隐式捕获采用的是值方式(使用了=),则显式捕获命名变量必须采用引用方式,即,在名字前使用&amp;。</p>
<blockquote>
<p>可变lambda</p>
</blockquote>
<p>默认情况下,对于一个值被拷贝的变量, lambda不会改变其值。如果我们希望能改变个被捕获的变量的值,就必须在参数列表首加上关键键字 mutale。</p>
<blockquote>
<p>指定的lambda返回类型</p>
</blockquote>
<p>默认情况下,如果一个 lambda体包含 return之外的任何语句,则编译器假定此 lambda返回void。与其他返回void的函数类似,被推断返回void的 lambda不能返回值。</p>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>对于那种只在一两个地方使用的简单操作, lambda表达式是最有用的。如果我们需要在很多地方使用相同的操作,通常应该定义一个函数,而不是多次编写相同的 lambda表达式。类似的,如果一个操作需要很多语句才能完成,通通常使用函数更好。</p>
<p>如果lambda的捕获列表为空，通常可以用函数来替代它。</p>
<p>但是,对于捕获局部变量的 lambda,用函数来替换它就不是那么容易了。</p>
<blockquote>
<p>标准bind函数</p>
</blockquote>
<p>我们可以解决向 check_size传递递一个长度参数的问题,方法是使用一个新的名为bind的标准库函数,它定义在头文件 functiona1中。可以将bind函数看作一个通用的函数适配记器,它接受一个可调用对象,生成一个新的可调用对象来“适应”原对象的参数列表</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_18_1518954580235.jpg" alt="enter description here"></p>
<h2 id="再探迭代器"><a href="#再探迭代器" class="headerlink" title="再探迭代器"></a>再探迭代器</h2><p>除了为每个容器定义的迭代器之外,标准库还定义了额外几种迭代器。这些迭代器包括以下几种</p>
<ul>
<li>插入迭代器( Insert iterator):这些迭代器被绑定到一个容器上,可用来向容器插入元素</li>
<li>流迭代器( stream Iterator):这些迭代器被绑定到输入或输出流上,可用来遍历所关联的IO流。</li>
<li>反向迭代器( reverse Iterator):这些迭代器向后而不是向前移动。除了forward1ist之外的标准库容器都有反向迭代器。</li>
<li>移动迭代器( move iterator):这些专用的迭代器不是拷贝其中的元素,而是移动它们。我们将在13.6.2节(第480页)介绍移动迭代器</li>
</ul>
<h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><p>插入器是一种迭代器适配器,它接受一个容器,生成一个迭代器,能实现向给定容器添加元素。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519893284405.jpg" alt="enter description here"></p>
<p>插入器有三种类型，其差异在于元素插入的位置：</p>
<ul>
<li>back_inserter创建一个使用 push_back的迭代器</li>
<li>front_inserter创建一个使用 push_front的迭代器</li>
<li>inserter创建一个使用 insert的迭代器。此函数接受第二个参数,这个参数必须是一个指向给定容器的迭代器。<strong>元素将被插入到给定迭代器所表示的元素之前</strong>。</li>
</ul>
<h3 id="iostream-迭代器"><a href="#iostream-迭代器" class="headerlink" title="iostream 迭代器"></a>iostream 迭代器</h3><p>虽然 iostream类型不是容器,但标准库定义了可以用于这些IO类型对象的迭代器。istream iterator读取输入流,ostream iterator向一个输出流写数据。<strong>这些迭代器将它们对应的流当作一个特定类型的元素序列来处理</strong>。通过使用流迭代器,我们可以用泛型算法从流对象读取数据以及向其写入数据。</p>
<blockquote>
<p>istream_iterator 允许使用懒惰求值</p>
</blockquote>
<p>当我们将一个 istream_iterator绑定到一个流时,标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据,直到我们使用迭代器时才真正读取。标准库中的实现所保证的是,<strong>在我们第一次解引用迭代器之前,从流中读取数据的操作已经完成了</strong>。对于大多数程序来说,立即读取还是推迟读取没什么差别。</p>
<h3 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h3><p>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器,递增(以及递减)操作的含义会颠倒过来。递增一个反向迭代器(++it)会移动到前一个元素;递减一个迭代器(–it)会移动到下一个元素。</p>
<p>除了 forwardlist之外,其他容器都支持反向迭代器。</p>
<h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><p>任何算法的最基本的特性是它要求其迭代器提供哪些操作。算法所要求的迭代器操作可以分为5个迭代器类别( Iterator category)。每个算法都会对它的每个迭代器参数指明须提供哪类迭代器。</p>
<p>算法还共享了一组参数传递规范和一组命名规范</p>
<h3 id="5类迭代器"><a href="#5类迭代器" class="headerlink" title="5类迭代器"></a>5类迭代器</h3><p>类似容器,迭代器也定义了一组公共操作。一些操作所有迭代器都支持,另外一些只有特定类别的迭代器才支持。例如, ostream_iterator只支持递增、解引用和赋值。vector、 string和 deque的迭代器除了这些操作外,还支持递减、关系和算术运算。</p>
<p>C++标准指明了泛型和数值算法的每个迭代器参数的最小类别。例如,find算法在一个序列上进行一遍扫描,对元素进行只读操作,因此至少需要输入迭代器。 </p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519894770101.jpg" alt="enter description here"></p>
<h3 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h3><p>在任何其他算法分类之上,还有一组参数规范。理解这些参数规范对学习新算法很有帮助—通过理解参数的含义,你可以将注意力集中在算法所做的操作上。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519894916626.jpg" alt="enter description here"></p>
<h3 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h3><p>除了参数规范,算法还遵循一套命名和重载规范。这些规范处理诸如:如何提供一个操作代替默认的&lt;或==运算符以及算法是将输出数据写入输入序列还是一个分离的目的位置等问题。</p>
<h2 id="特定容器算法"><a href="#特定容器算法" class="headerlink" title="特定容器算法"></a>特定容器算法</h2><p>与其他容器不同,链表类型list和forward_list定义了几个成员函数形式的算法。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519895023511.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519895035177.jpg" alt="enter description here"></p>
<hr>
<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>关联容器和顺序容器有着根本的不同:关联容器中的元素是按关键字来保存和访问的。与之相对,顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p>
<p>关联容器支持高效的关键字查找和访问。两个主要的<strong>关联容器</strong>( associative container)类型是map和set。map中的元素是一些关键字-值( key-value)对:关键字起到索引的作用,值则表示与索引相关联的数据。set中每个元素只包含一个关键字;set支持高效的关键字查询操作——检查一个给定关键字是否在set中。</p>
<p>标准库提供8个关联容器,。这8个容器间的不同体现在三个维度上:每个容器<br>(1)<strong>或者是一个set,或者是一个map</strong>;<br>(2)<strong>或者要求不重复的关键字,或者允许重复关键字</strong>;<br>(3)<strong>按顺序保存元素,或无序保存</strong></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519989186109.jpg" alt="enter description here"></p>
<h2 id="使用关联容器"><a href="#使用关联容器" class="headerlink" title="使用关联容器"></a>使用关联容器</h2><p>map是关键字值对的集合。例如,可以将一个人的名字作为关键字,将其电话号码作为值。我们称这样的数据结构为“将名字映射到电话号码”。map类型通常被称为关联数组( associative array)。关联数组与“正常”数组类似,不同之处在于其下标不必是整数。</p>
<p>与之相对,set就是关键字的简单集合。当只是想知道一个值是否存在时,set是最有用的。</p>
<h2 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h2><p>关联容器不支持顺序容器的位置相关的操作,例如 push_front或 push_back。原因是<strong>关联容器中元素是根据关键字存储的,这些操作对关联容器没有意义</strong>。而且,关联容器也<strong>不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作</strong>。</p>
<h3 id="定义关联容器"><a href="#定义关联容器" class="headerlink" title="定义关联容器"></a>定义关联容器</h3><p>当定义一个map时,必须既指明关键字类型又指明值类型;而定义一个set时,只需指明关键字类型,因为set中没有值。</p>
<p>map的初始化：<br><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519990637584.jpg" alt="enter description here"></p>
<h3 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h3><p>对于有序容器—map、 multimap、set以及 multiset,<strong>关键字类型必须定义元素比较的方法</strong>。默认情况下,标准库使用关键字类型的&lt;运算符来比较两个关键字。</p>
<blockquote>
<p>有序容器的关键字类型</p>
</blockquote>
<p>可以向一个算法提供我们自己定义的比较操作,与之类似也可以提供自己定义的操作来代替关键字上的&lt;运算符。所提供的操作必须在关键字类型上定义一个<strong>严格弱序</strong>( strict weak ordering)。</p>
<blockquote>
<p>使用关键字类型的比较函数</p>
</blockquote>
<p>用来组织一个容器中元素的操作的类型也是该容器类型的一部分。<strong>为了指定使用自定义的操作,必须在定义关联容器类型时提供此操作的类型</strong>。如前所述,用尖括号指出要定义哪种类型的容器,自定义的操作类型必须在尖括号中紧跟着元素类型给出</p>
<p>此处,我们使用 decltype来指出自定义操作的类型。记住,当用 decltype来获得一个函数指针类型时,必须加上一个*来指出我们要使用一个给定函数类型的指针</p>
<h3 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h3><p>在介绍关联容器操作之前,我们需要了解名为pair的标准库类型,它定义在头文件utility中。</p>
<p>一个pair保存两个数据成员。类似容器,pair是一个用来生成特定类型的模板当创建一个pair时,我们必须提供两个类型名,pa1r的数据成员将具有对应的类型。两个类型不要求一样:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519991091913.jpg" alt="enter description here"></p>
<p>与其他标准库类型不同,pair的数据成员是public的。两个成员分别命名为 first和 second。我们用普通的成员访问符号来访问它们</p>
<h2 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a>关联容器操作</h2><p>关联容器还定义了一些表示容器关键字和值的类型</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992027517.jpg" alt="enter description here"></p>
<h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><p>当解引用一个关联容器迭代器时,我们会得到一个类型为容器的value_type的值的引用。对map而言,value_type是一个pair类型,其 first成员保存 const的关键字, second成员保存值</p>
<blockquote>
<p>set 的迭代器是const的</p>
</blockquote>
<p>虽然set类型同时定义了 iterator和 const_iterator类型,但两种类型都只允许只读访问set中的元素。与不能改变一个map元素的关键字一样,一个set中的关键字也是 const的。可以用一个set迭代器来读取元素的值,但不能修改:</p>
<blockquote>
<p>遍历关联容器</p>
</blockquote>
<p>map和set类型都支持 begin和end操作。与往常一样我们可以用这些函数获取迭代器,然后用迭代器来遍历容器。</p>
<blockquote>
<p>关联容器和算法</p>
</blockquote>
<p>我们通常不对关联容器使用泛型算法。关键字是 const这一特性意味着<strong>不能将关联容器传递给修改或重排容器元素的算法</strong>,因为这类算法需要向元素写入值,而set类型中的元素是cnst的,map中的元素是pair,其第一个成员是 const的。</p>
<p>关联容器可用于只读取元素的算法。</p>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>关联容器的 insert成员向容器中添加一个元素或一个元素范围。由于map和set(以及对应的无序类型)包含不重复的关键字,因此插入一个已存在的元素对容器没有任何影响</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992536522.jpg" alt="enter description here"></p>
<blockquote>
<p>向map添加元素</p>
</blockquote>
<p>对一个map进行 insert操作时,必须记住元素类型是pair。通常,对于想要插入的数据,并没有一个现成的pair对象。可以在 insert的参数列表中创建一个pair</p>
<blockquote>
<p>检测insert的返回值</p>
</blockquote>
<p>insert(或emplace)返回的值依赖于容器类型和参数。对于不包含重复关键字的容器,添加单一元素的 insert和 emplace版本返回一个pair,告诉我们插入操作是否成功。pair的 first成员是一个迭代器,指向具有给定关键字的元素; second成员是一个bool值,指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中</p>
<h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992521248.jpg" alt="enter description here"></p>
<h3 id="map的下标操作"><a href="#map的下标操作" class="headerlink" title="map的下标操作"></a>map的下标操作</h3><p>map和 unordered_map容器提供了下标运算符和一个对应的at函数。set类型不支持下标,因为set中没有与关键字相关联的“值”。元素本身就是关键字,因此“获取与一个关键字相关联的值”的操作就没有意义了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992604789.jpg" alt="enter description here"></p>
<h3 id="访问元素-1"><a href="#访问元素-1" class="headerlink" title="访问元素"></a>访问元素</h3><p>关联容器提供多种查找一个指定元素的方法</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992681370.jpg" alt="enter description here"></p>
<blockquote>
<p>对map使用find代替下标操作</p>
</blockquote>
<p>对map和 unordered map类型,下标运算符提供了最简单的提取元素的方法。但是如我们所见,使用下标操作有一个严重的副作用:如果关键字还未在map中,下标操作会插入一个具有给定关键字的元素。这种行为是否正确完全依赖于我们的预期是什么。</p>
<h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p>新标准定义了4个<strong>无序关联容器</strong>( unordered associative container)。这些容器不是使用比较运算符来组织元素,而是使用一个哈希函数( hash function)和关键字类型==运算符。在关键字类型的元素没有明显的序关系的情况下,无序容器是非常有用的。</p>
<blockquote>
<p>使用无序容器</p>
</blockquote>
<p>除了哈希管理操作之外,无序容器还提供了与有序容器相同的操作(find、 insert）</p>
<blockquote>
<p>管理桶</p>
</blockquote>
<p>无序容器在存储上组织为一组桶,每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素,容器首先计算元素的哈希值,它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字,所有具有相同关键字的元素也都会在同一个桶中。因此,无序容器的性能依赖于哈希函数的质量和桶的数量和大小。</p>
<hr>
<h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><p>动态对象的正确释放被证明是编程中极其容易出错的地方。为了更安全地使用动态对象,标准库定义了两个智能指针类型来管理动态分配的对象。<strong>当一个对象应该被释放时,指向它的智能指针可以确保自动地释放它</strong>。</p>
<p>除了静态内存和栈内存,每个程序还拥有一个内存池。这部分内存被称作<strong>自由空间</strong>( free store)或<strong>堆</strong>(heap)。程序用堆来存储动态分配( dynamically allocate)的对象——即那些在程序运行时分配的对象。</p>
<h2 id="动态内存和智能指针"><a href="#动态内存和智能指针" class="headerlink" title="动态内存和智能指针"></a>动态内存和智能指针</h2><p>在++中,动态内存的管理是通过一对运算符来完成的:new,在动态内存中为对象分配空间并返回一个指向该对象的指针,我们可以选择对对象进行初始化; delete,接受一个动态对象的指针,销毁该对象,并释放与之关联的内存</p>
<p>为了更容易(同时也更安全)地使用动态内存,新的标准库提供了两种智能指针( smartpointer.)类型来管理动态对象。智能指针的行为类似常规指针,重要的区别是它<strong>负责自动释放所指向的对象</strong>。新标准库提供的这两种智能指针的区别在于管理底层指针的方式shared_ptr允许多个指针指向同一个对于象; unique_ptr则“独占”所指向的对象。标准库还定义了一个名为 weak_ptr的伴随类,它是一种弱引用,指向 shared_ptr所管理的对象。这三种类型都定义在 memory头文件中。</p>
<h3 id="share-ptr类"><a href="#share-ptr类" class="headerlink" title="share_ptr类"></a>share_ptr类</h3><p>类似 vector,智能指针也是模板。因此,当我们创建一个智能指针十时,必须提供额外的信息—指针可以指向的类型。智能指针的使用方式与普通指针类似。解引用一个智能指针返回它指向的对象。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520129716802.jpg" alt="enter description here"></p>
<blockquote>
<p>make_shared 函数</p>
</blockquote>
<p>最安全的分配和使用动态内存的方法是调用一个名为 make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它,返回指向此对象的 shared_ptr。</p>
<p>当要用 make_shared时,必须指定想要创建的对象的类型。定义方式与模板类相同在函数名之后跟一个尖括号,在其中给出类型</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520129795731.jpg" alt="enter description here"></p>
<blockquote>
<p>shared_ptr 的拷贝和赋值</p>
</blockquote>
<p>我们可以认为每个 shared_ptr都有一个关联的计数器,通常称其为<strong>引用计数</strong>( reference count)。无论何时我们拷贝一个 shared_ptr,计数器都会递增。一旦一个 shared_ptr的计数器变为0,它就会自动释放自己所管理的对象</p>
<blockquote>
<p>shared_ptr 自动销毁所管理的对象</p>
</blockquote>
<p>当指向一个对象的最后一个 shared_ptr被销毁时, shared_ptr类会自动销毁此对象。它是通过另一个特殊的成员函数——析构函数( destructor)完成销毁工作的。</p>
<blockquote>
<p>使用动态生存期的资源的类</p>
</blockquote>
<p>程序使用动态内存出于以下三种原因之一：</p>
<ul>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个资源之间共享数据</li>
</ul>
<h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><p>C++语言定义了两个运算符来分配和释放动态内存。运算符new分配内存, delete释放new分配的内存。</p>
<blockquote>
<p>使用new动态分配和初始化对象</p>
</blockquote>
<p>在自由空间分配的内存是无名的,因此new无法为其分配的对象命名,而是返回一个指向该对象的指针。</p>
<p>默认情况下,动态分配的对象是默认初始化的,这意味着内置类型或组合类型的对象的值将是未定义的,而类类型对象将用默认构造函数进行初始化</p>
<blockquote>
<p>内存耗尽</p>
</blockquote>
<p>一旦一个程序用光了它所有可用的内在,new表达式就会失败。默认情况下,加果new不能分配所要求的内存空间,它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常:</p>
<p>动态内存管理的时候非常容易出错：</p>
<ol>
<li>忘记delete内存</li>
<li>使用已经释放掉的对象</li>
<li>同一块内存释放两次</li>
</ol>
<blockquote>
<p>delete 之后重置指针</p>
</blockquote>
<p>当我们 delete一个指针后,指针值就变为无效了。虽然指针已经无效,但在很多机器上指针仍然保存着(已经释放了的)动态内存的地址。在 delete之后,指针就变成了人们所说的<strong>空悬指针</strong>( dangling pointer),即<strong>指向一块曾经保存数据对象但现在已经无效的内存的指针</strong>。</p>
<p>未初始化指针的所有缺点空悬指针也都有。有一种方法可以避免空悬指针的问题:在指针即将要离开其作用域之前释放掉它所关联的内存。</p>
<h3 id="share-ptr和new结合使用"><a href="#share-ptr和new结合使用" class="headerlink" title="share_ptr和new结合使用"></a>share_ptr和new结合使用</h3><p>如果我们不初始化一个智能指针，那么这个指针就会被初始化为一个空指针。</p>
<p>接受指针参数的智能指针构造函数是explicit的（禁止隐式转换）。因此,我们不能将一个内置指针隐式转换为一个智能指针,必须使用直接初始化形式</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520130371151.jpg" alt="enter description here"></p>
<h3 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h3><p>如果使用智能指针,即使程序块过早结束,智能指针类也能确保在内存不再需要时将其释放</p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>个 unique_ptr“拥有”它所指向的对象。与 shared_ptr不同,某个时刻只能有一个 unique_ptr指向一个给定对象。当 unique_ptr被销毁时,它所指向的对象也被销毁。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520130502646.jpg" alt="enter description here"></p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr是一种不控制所指向对象生存期的智能指针,它指向由一个shared_ptr管理的对象。将一个 weak_ptr绑定到一个 shared_ptr不会改变shared_ptr的引用计数。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520130696044.jpg" alt="enter description here"></p>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>new和 delete运算符一次分配释放一个对象,但某些应用需要一次为很多对象分配内存的功能。</p>
<p>为了支持这种需求,C++语言和标准库提供了两种一次分配一个对象数组的方法。C+语言定义了另一种new表达式语法,可以分配并初始化一个对象数组。标准库中包含个名为allocator的类,允许我们们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力</p>
<h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h3><p>为了让new分配一个对象数组,我们要在类型名之后跟一对方括号,在其中指明要分配的对象的数目。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span> [get_size()]; <span class="comment">// pia指向第一个int</span></div></pre></td></tr></table></figure>
<p>虽然我们]通常称newT[]分配的内存为“动态数组”,但这种叫法某种程度上有些误导。当用new分配一个数组时,我们并未得到一个数组类型的对象,而是得到一个数组元素类型的指针。不能对动态数组调用begin和end。</p>
<blockquote>
<p>释放动态数组</p>
</blockquote>
<p>为了释放动态数组,我们使用一种特殊形式的 delete—在指针前加上一个空方括号对:</p>
<blockquote>
<p>智能指针和动态数组</p>
</blockquote>
<p>标准库提供了一个可以管理new分配的数组的 unique_ptr版本。为了用一个unique_ptr管理动态数组,我们必须在对象类型后面跟一对空方括号:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520132049585.jpg" alt="enter description here"></p>
<h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>new有一些灵活性上的局限,其中一方面表现在它将内存分配和对象构造组合在了起。类似的, delete将对象析构和内存释放组合在了一起。我们分配单个对象时,通常希望将内存分配和对象初始化组合在一起。因为在这种情况下,我们几乎肯定知道对象应有什么值。</p>
<p>标准库allocator类定义在头文件 memory中,它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法,它分配的内存是原始的、未构造的。allocator是一个模板。</p>
<blockquote>
<p>allocator 分配未构造的内存</p>
</blockquote>
<p>allocator分配的内存是未构造的( unconstructed)。我们按需要在此内存中构造对象。在新标准库中, construct成员函数接受一个指针和零个或多个额外参数,在给定位置构造一个元素。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Docker部署Hexo博客]]></title>
      <url>/2018/03/02/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>本文展示使用Docker部署Hexo博客（当然也可以是其他的服务）在服务器上的一种方案，主要用到是webhook来触发git pull操作。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之前部署Hexo博客的时候好像配置蛮久的，想着能不能把这些东西都放进Docker里面，以后换服务器以后部署也方面，于是便有了这波操作。</p>
<p>这里使用的是<a href="https://github.com/adnanh/webhook" target="_blank" rel="external">webhook</a>这个轮子来实现持续集成的。</p>
<p>工作示意图：<br>本地编辑—-git push—-&gt;Github—-webhook—-&gt;server—-get pull—-&gt;内容更新</p>
<p>使用到两个Docker：</p>
<ol>
<li><code>webhook</code>:  当push新的commit到GitHub（或其他平台）时解析GitHub发过来的webhook执行脚本更新网站内容</li>
<li><code>nginx</code>: Web服务器，展示网站内容</li>
</ol>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx容器的配置比较简单,只需要修改<code>nginx.conf</code>配置，监听80端口就行了。（如果需要需要https，则需要配置要证书以及配置监听443端口）。</p>
<p>这里贴出我的<code>docker-compose.yml</code>文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">version: &apos;3&apos;</div><div class="line">services:</div><div class="line">    web:</div><div class="line">        image: nginx</div><div class="line">        volumes:</div><div class="line">            - ./nginx.conf:/etc/nginx/nginx.conf</div><div class="line">            - ./sites-enabled:/etc/nginx/sites-enabled</div><div class="line">            - /path-to-your-content:/var/www</div><div class="line">            - ./ssl:/ssl</div><div class="line">        ports:</div><div class="line">            - &quot;80:80&quot;</div><div class="line">            - &quot;443:443&quot;</div></pre></td></tr></table></figure></p>
<p>ssl文件夹中的是证书，<code>path-to-your-content</code>是你静态页面的路径。</p>
<h2 id="Webhook"><a href="#Webhook" class="headerlink" title="Webhook"></a>Webhook</h2><p>Webhook任务是解析发过来的请求，然后执行脚本来从远程仓库中拉取更新。</p>
<p>首先是构建镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">FROM golang</div><div class="line">MAINTAINER sixzeroo &lt;sixzeroo60@gmail.com&gt;</div><div class="line"></div><div class="line">RUN mkdir -p /code/webhook \</div><div class="line">    &amp;&amp; touch /code/webhook/hook.json \</div><div class="line">    &amp;&amp; go get github.com/adnanh/webhook</div><div class="line"></div><div class="line">WORKDIR /code/webhook</div><div class="line"></div><div class="line">ENTRYPOINT /go/bin/webhook -hooks /code/webhook/hooks.json -verbose</div></pre></td></tr></table></figure></p>
<p>成品：<a href="https://hub.docker.com/r/sixzeroo/webhook/" target="_blank" rel="external">sixzeroo/webhook</a></p>
<p>之后就可以使用webhook来创建钩子任务了，其中配置文件在<code>hooks.json</code>中：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  &#123;</div><div class="line">    <span class="attr">"id"</span>: <span class="string">"your-id"</span>,</div><div class="line">    <span class="attr">"execute-command"</span>: <span class="string">"/code/webhook/work.sh"</span>,</div><div class="line">    <span class="attr">"command-working-directory"</span>: <span class="string">"/code/webhook"</span></div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>执行的脚本就是从GitHub中拉取更新而已，<code>work.sh</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#! /bin/sh</div><div class="line"></div><div class="line">cd /var/www &amp;&amp; git pull</div><div class="line"></div><div class="line">curtime=`date +&quot;%Y%m%d%H%M%S&quot;`</div><div class="line"></div><div class="line">if [ $? -eq 0 ];then</div><div class="line">    echo &quot;$curtime pull success!&quot; &gt;&gt; /code/webhook/git.log</div><div class="line">else</div><div class="line">    echo &quot;$curtime pull fail!&quot; &gt;&gt; /code/webhook/git.log</div><div class="line">fi</div></pre></td></tr></table></figure></p>
<p>最后配置整个服务，<code>docker-compose.yml</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">version: &quot;3&quot;</div><div class="line">services:</div><div class="line"></div><div class="line">    webhook:</div><div class="line">        image: sixzeroo/webhook</div><div class="line">        volumes:</div><div class="line">         - ./:/code/webhook</div><div class="line">         - /path-to-your-content:/var/www</div><div class="line">         - /key-path:/root/.ssh</div><div class="line">        ports:</div><div class="line">         - &quot;9000:9000&quot;</div></pre></td></tr></table></figure></p>
<p>其中<code>key-path</code>是你ssh文件夹路径</p>
<p>最后启动两个服务就可以工作了，设置GitHub当有push的时候发送<code>http://your-host:9000/hooks/your-id</code>这样的webhook就行了。</p>
<p>这里不把两个容器放到一个服务里面的原因是Nginx容器之后会有新的服务部署，里面会做一些修改。</p>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker Swarm 简介]]></title>
      <url>/2018/02/28/Docker-Swarm-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>Docker Swarm 为Docker 提供容器集群服务，是 Docker 官 方对容器云生态进行支持的核心方案。</p>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Swarm 是使用 SwarmKit 构建的 Docker 引擎内置（原生）的集群管理和编排工具。 Swarm 集群之前需要了解以下几个概念。</p>
<h3 id="什么是swarm"><a href="#什么是swarm" class="headerlink" title="什么是swarm"></a>什么是swarm</h3><p>嵌入在Docker Engine中的集群管理和编排功能是通过swarmkit构建的。 Swarmkit是一个独立的项目，它实现了Docker的编排层，并直接在Docker中使用。</p>
<p>一个群由多个Docker主机组成，这些主机以群模式运行并充当管理者（管理成员资格和委派）和工作者（运行群集服务）。 给定的Docker主机可以是管理员，工作者或执行这两种角色。 当您创建服务时，您可以定义其理想状态（副本数量，可用的网络和存储资源，将服务暴露给外部世界等等）。 Docker的工作是维持这个理想的状态。 例如，如果工作者节点变得不可用，Docker会在其他节点上调度该节点的任务。 任务是一个正在运行的容器，它是swarm服务的一部分，由swarm管理器管理，而不是独立的容器。</p>
<p>群集服务相对于独立容器的主要优势之一是可以修改服务的配置，其中包括连接的网络和卷，而无需手动重新启动服务。 Docker将更新配置，停止使用过时配置的服务任务，并创建与所需配置相匹配的新服务。</p>
<p>当Docker以群集模式运行时，您仍然可以在参与群集的任何Docker主机以及群集服务上运行独立容器。 独立容器和群集服务之间的一个主要区别是，只有群集管理员可以管理群集，而独立容器可以在任何守护进程上启动。 Docker守护进程可以作为管理者，工作者或两者参与群体。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>与Docker Engine集成的集群管理</li>
<li>分散设计：Docker Engine在部署时不需要处理节点角色之间的差异，而是在运行时处理这些特殊的东西</li>
<li>声明式服务模式：Docker Engine使用声明性方法来让您在应用程序堆栈中定义各种服务的所需状态。</li>
<li>伸缩服务</li>
<li>理想状态调整</li>
<li>多主机联网</li>
<li>服务发现</li>
</ul>
<h3 id="节点（Nodes）"><a href="#节点（Nodes）" class="headerlink" title="节点（Nodes）"></a>节点（Nodes）</h3><p>节点是参与群体的Docker引擎的一个实例。 您也可以将其视为Docker节点。 您可以在单台物理计算机或云服务器上运行一个或多个节点，但生产群部署通常包括分布在多台物理机和云计算机上的Docker节点。</p>
<p>节点分为管理( manager)节点和工作( wor ker)节点。</p>
<p>管理节点用于 Swarm集群的管理, <code>docker swarm</code>命令基本只能在管理节点执行(节点退出集群命令 docker swarm leave可以在工作节点执行)。一个 Swarm集群可以有多个管理节点,但只有一个管理节点可以成为 <code>leader</code> ,<code>leader</code>通过<code>raft</code>协议实现。</p>
<p>工作节点是任务执行节点,管理节点将服务( servlce)下发至工作节点执行。管理节点默认也作为工作节点。你也可以通过配置让服务只运行在管理节点</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_28_1519799540229.jpg" alt="enter description here"></p>
<h3 id="服务（Services）和任务（Tasks）"><a href="#服务（Services）和任务（Tasks）" class="headerlink" title="服务（Services）和任务（Tasks）"></a>服务（Services）和任务（Tasks）</h3><p>服务（Services）是要在管理器或工作节点上执行的任务的定义。它是群体系统的中心结构，也是群体与用户互动的主要根源。</p>
<p>任务（Task）包含一个Docker容器和在容器内运行的命令。它是swarm的原子调度单位。</p>
<p>服务有两种模式：</p>
<ul>
<li><code>replicated services</code> 按照一定规则在各个工作节点上运行指定个数的任务</li>
<li><code>global services</code>每个工作节点上运行一个任务</li>
</ul>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_28_1519799982888.jpg" alt="enter description here"></p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="初始化-swarm-init"><a href="#初始化-swarm-init" class="headerlink" title="初始化 (swarm init)"></a>初始化 (swarm init)</h3><p>使用<code>docker swarm init</code>来在本机初始化一个swarm集群</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ docker swarm init --advertise-addr 192.168.99.100</div><div class="line">Swarm initialized: current node (dxn1zf6l61qsb1josjja83ngz) is now a manager.</div><div class="line"></div><div class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</div><div class="line"></div><div class="line">    docker swarm join \</div><div class="line">    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \</div><div class="line">    192.168.99.100:2377</div><div class="line"></div><div class="line">To add a manager to this swarm, run <span class="string">'docker swarm join-token manager'</span> and follow the instructions.</div></pre></td></tr></table></figure>
<p>如果你的 Docker 主机有多个网卡，拥有多个 IP，必须使用 <code>--advertise-addr</code>指定 IP。</p>
<p>执行 docker swarm init 命令的节点自动成为管理节点。</p>
<h3 id="添加节点-swarm-join"><a href="#添加节点-swarm-join" class="headerlink" title="添加节点 (swarm join)"></a>添加节点 (swarm join)</h3><p>向集群中添加一个工作节点/管理节点</p>
<p>格式： <code>docker swarm join [OPTIONS] HOST:PORT</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker@worker1:~$ docker swarm join \</div><div class="line">    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \</div><div class="line">    192.168.99.100:2377</div></pre></td></tr></table></figure>
<h3 id="查看节点-node-ls"><a href="#查看节点-node-ls" class="headerlink" title="查看节点 (node ls)"></a>查看节点 (node ls)</h3><p>使用 <code>docker node ls</code> 查看集群</p>
<h3 id="新建服务-service-create"><a href="#新建服务-service-create" class="headerlink" title="新建服务 (service create)"></a>新建服务 (service create)</h3><p>命令格式：<code>docker service create [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker service create --replicas 3 -p 80:80 --name nginx nginx:1.13.7-alpine</div></pre></td></tr></table></figure></p>
<p><code>--replicas</code> 表示创建多少任务</p>
<h3 id="查看服务信息-service-ls"><a href="#查看服务信息-service-ls" class="headerlink" title="查看服务信息 (service ls)"></a>查看服务信息 (service ls)</h3><p>使用 <code>docker service ls</code> 来查看当前 Swarm 集群运行的服务</p>
<p>想要查看其中某一个服务的详细信息，可以使用 <code>service inspect</code>命令: <code>docker service inspect [OPTIONS] SERVICE [SERVICE...]</code></p>
<h3 id="查看服务中的任务详情-service-ps"><a href="#查看服务中的任务详情-service-ps" class="headerlink" title="查看服务中的任务详情 (service ps)"></a>查看服务中的任务详情 (service ps)</h3><p>使用 <code>docker service ps</code> 来查看某个服务中的任务(Task)的详情 <code>docker service ps [OPTIONS] SERVICE [SERVICE...]</code></p>
<h3 id="查看服务日志-service-logs"><a href="#查看服务日志-service-logs" class="headerlink" title="查看服务日志 (service logs)"></a>查看服务日志 (service logs)</h3><p>使用 <code>docker service logs</code> 来查看某个服务的日志</p>
<h3 id="删除服务-service-rm"><a href="#删除服务-service-rm" class="headerlink" title="删除服务 (service rm)"></a>删除服务 (service rm)</h3><p>使用 <code>docker service rm</code> 来从 Swarm 集群移除某个服务。</p>
<h3 id="服务伸缩-service-scale"><a href="#服务伸缩-service-scale" class="headerlink" title="服务伸缩 (service scale)"></a>服务伸缩 (service scale)</h3><p>使用 <code>docker service scale</code>调整服务中的任务数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker service scale backend=10</div></pre></td></tr></table></figure>
<h2 id="使用Stack部署服务"><a href="#使用Stack部署服务" class="headerlink" title="使用Stack部署服务"></a>使用Stack部署服务</h2><p>Stack是一组相互关联的服务，它们可以共享依赖关系，并且可以进行协调和缩放。 单个Stack能够定义和协调整个应用程序的功能（尽管非常复杂的应用程序可能需要使用多个Stack）</p>
<p>正如之前使用 docker-compose.yml 来一次配置、启动多个容器，在 Swarm 集群中也可以使用 compose 文件 （docker-compose.yml） 来配置、启动多个服务。</p>
<p>我们使用 docker service create 一次只能部署一个服务，使用 docker-compose.yml 我们可以一次启动多个关联的服务。我们在此以 Swarm 集群中部署 WordPress 为例进行说明。</p>
<p>docker-compose.yml 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">version: &quot;3&quot;</div><div class="line"></div><div class="line">services:</div><div class="line">  wordpress:</div><div class="line">    image: wordpress</div><div class="line">    ports:</div><div class="line">      - 80:80</div><div class="line">    networks:</div><div class="line">      - overlay</div><div class="line">    environment:</div><div class="line">      WORDPRESS_DB_HOST: db:3306</div><div class="line">      WORDPRESS_DB_USER: wordpress</div><div class="line">      WORDPRESS_DB_PASSWORD: wordpress</div><div class="line">    deploy:</div><div class="line">      mode: replicated</div><div class="line">      replicas: 3</div><div class="line"></div><div class="line">  db:</div><div class="line">    image: mysql</div><div class="line">    networks:</div><div class="line">       - overlay</div><div class="line">    volumes:</div><div class="line">      - db-data:/var/lib/mysql</div><div class="line">    environment:</div><div class="line">      MYSQL_ROOT_PASSWORD: somewordpress</div><div class="line">      MYSQL_DATABASE: wordpress</div><div class="line">      MYSQL_USER: wordpress</div><div class="line">      MYSQL_PASSWORD: wordpress</div><div class="line">    deploy:</div><div class="line">      placement:</div><div class="line">        constraints: [node.role == manager]</div><div class="line"></div><div class="line">  visualizer:</div><div class="line">    image: dockersamples/visualizer:stable</div><div class="line">    ports:</div><div class="line">      - &quot;8080:8080&quot;</div><div class="line">    stop_grace_period: 1m30s</div><div class="line">    volumes:</div><div class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</div><div class="line">    deploy:</div><div class="line">      placement:</div><div class="line">        constraints: [node.role == manager]</div><div class="line"></div><div class="line">volumes:</div><div class="line">  db-data:</div><div class="line">networks:</div><div class="line">  overlay:</div></pre></td></tr></table></figure></p>
<p>在 Swarm 集群管理节点新建该文件，其中的 visualizer 服务提供一个可视化页面，我们可以从浏览器中很直观的查看集群中各个服务的运行节点。</p>
<h3 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h3><p>部署服务使用 <code>docker stack deploy</code>，其中 -c 参数指定 compose 文件名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker stack deploy -c docker-compose.yml wordpress</div></pre></td></tr></table></figure></p>
<h3 id="查看服务"><a href="#查看服务" class="headerlink" title="查看服务"></a>查看服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker stack ls</div><div class="line">NAME                SERVICES</div><div class="line">wordpress           3</div></pre></td></tr></table></figure>
<h3 id="移除服务"><a href="#移除服务" class="headerlink" title="移除服务"></a>移除服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">要移除服务，使用 docker stack down</div><div class="line"></div><div class="line">$ docker stack down wordpress</div><div class="line">Removing service wordpress_db</div><div class="line">Removing service wordpress_visualizer</div><div class="line">Removing service wordpress_wordpress</div><div class="line">Removing network wordpress_overlay</div><div class="line">Removing network wordpress_default</div></pre></td></tr></table></figure>
<p>该命令不会移除服务所使用的 数据卷，如果你想移除数据卷请使用 docker volume rm</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://0x9.me/WYIcD" target="_blank" rel="external">https://0x9.me/WYIcD</a></li>
<li><a href="https://0x9.me/Woidc" target="_blank" rel="external">https://0x9.me/Woidc</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode Next Permutation 题解]]></title>
      <url>/2018/02/25/LeetCode-Next-Permutation-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>LeetCode Next Permutation 题解</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目的意思就是求给定序列的下一个字典序</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们要了解什么是字典序，这里参考wiki的解释：</p>
<blockquote>
<p>设想一本英语字典里的单词，何者在前何者在后？</p>
<p>显然的做法是先按照第一个字母、以 a、b、c……z 的顺序排列；如果第一个字母一样，那么比较第二个、第三个乃至后面的字母。如果比到最后两个单词不一样长（比如，sigh 和 sight），那么把短者排在前。</p>
<p>通过这种方法，我们可以给本来不相关的单词强行规定出一个顺序。“单词”可以看作是“字母”的字符串，而把这一点推而广之就可以认为是给对应位置元素所属集合分别相同的各个有序多元组规定顺序</p>
</blockquote>
<p>我的理解是：<strong>把一组数的所有排列情况按照字母顺序进行一次排序得到的就是一个字典序</strong></p>
<p>在这道题中要求给定排列的下一个字典序，可以知道把一个大一点的数往前移动这个序列的字典序一定会变大，那么就要从后往前找到第一个能变大的数（变大指和它后面的某个数互换以后），找到这个数以后把他和比他大的“第一个”数互换获得最小的增量，然后把这个数后面的数字按照从小到大的顺序重新排列。</p>
<p>举个例子：</p>
<p><img src="https://leetcode.com/media/original_images/31_Next_Permutation.gif" alt="enter description here"></p>
<h2 id="代码-C"><a href="#代码-C" class="headerlink" title="代码(C++)"></a>代码(C++)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int first = nums.size(), len = nums.size();</div><div class="line">        // 倒序查找第一个升序数</div><div class="line">        for(int i=len-1; i&gt;0;--i)</div><div class="line">        &#123;</div><div class="line">            if(nums[i] &gt; nums[i-1])</div><div class="line">            &#123;</div><div class="line">                first = i-1;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if(first == len)</div><div class="line">            reverse(nums.begin(), nums.end());</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            int second = len-1;</div><div class="line">            // 在后面找一个刚好比这个数大一点的数和其互换</div><div class="line">            for(int i=first + 1;i&lt;len;++i)</div><div class="line">            &#123;</div><div class="line">                if(nums[i]&lt;=nums[first])</div><div class="line">                &#123;</div><div class="line">                    second = i-1;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            swap(nums[first], nums[second]);</div><div class="line">            // 反转后面的部分</div><div class="line">            reverse(nums.begin()+first+1, nums.end());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker Machine 简介]]></title>
      <url>/2018/02/16/Docker-Machine-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>Docker 继续探索</p>
<a id="more"></a>
<h2 id="什么是Docker-Machine"><a href="#什么是Docker-Machine" class="headerlink" title="什么是Docker Machine"></a>什么是Docker Machine</h2><p>Docker Machine 是一种可让您在虚拟主机上安装 <code>Docker Engine</code> 并使用docker-machine命令管理主机的工具。你能使用Docker Machine 工具在你的本地 Mac 或 Windows boxs，公司网络，数据中心或 Azure 提供商（如 Azure，AWS 或 Digital Ocean）上创建 Docker 主机。</p>
<p>使用 <code>docker-machine</code> 命令，你能够开始、插入、停止和重启一个你所管理的主机、更新Docker的客户端和守护进程、并配置Docker配置以便和主机进行通信。</p>
<p>将Machine CLI指向一个正在运行并且托管的主机，你能够直接使用<code>docker</code>直接命令该主机。比如说，运行<code>docker-machine env default</code>指向一个名为<code>defaule</code>的主机，按照屏幕上的指令完成<code>env</code>的配置，并运行<code>docker ps</code> ，<code>docker run hello-world</code>等等</p>
<p>在Docker v1.12版本之前，Machine是在Mac和Window上运行Docker的唯一方法。从 Beta 版程序和 Docker v1.12 开始，Docker for Mac 和 Docker for Windows 可作为本地应用程序使用，并且是在在较新的台式机和笔记本电脑上的更好选择。我们鼓励您尝试这些新应用。 Docker for Mac 和Docker for Windows 的安装程序包括 Docker Machine，以及 Docker Compose。</p>
<h2 id="在什么情况下使用Docker-Machine"><a href="#在什么情况下使用Docker-Machine" class="headerlink" title="在什么情况下使用Docker Machine"></a>在什么情况下使用Docker Machine</h2><p>Docker Machine提供一种在各种各样的Linux主机上配置Docker的解决方案。此外Machine能够让你在老的的Mac和Windows上像上面一样运行Docker。</p>
<p>Docker有两个基本的应用场景：</p>
<ol>
<li>我有一个旧的桌面系统，并且想在Mac和Windows上运行Docker</li>
</ol>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518682583374.jpg" alt="enter description here"></p>
<p>如果你的主要工作环境是在一台旧的Mac或者Windows笔记本电脑或者台式机上，这些主机无法满足新的<code>Docker for Mac</code>和<code>Docker for Windows</code>的配置要求，那么你可以使用Docker Machine来在本地使用Docker Engine。</p>
<p>使用 Docker Toolbox 安装程序在 Mac 或 Windows box 上安装 Docker Machine 可以使用 Docker Engine 配置本地虚拟机，使您可以连接它并运行 docker 命令。</p>
<ol>
<li>我想在远程系统中配置Docker主机</li>
</ol>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518682822569.jpg" alt="enter description here"></p>
<p>Docker Engine在Linux系统上本机运行。如果有一个Linux box作为你的主系统，并且向运行<code>docker</code>命令，你需要的东西就是下载并安装Docker Engine。但是你想用一种高效的方式在网络、云端甚至本地配置多个Docker主机，你就需要Docker Machine</p>
<p>不管你的主系统是Linux、Max还是Windows，你都能够安装Docker Machine并且使用<code>docker-machine</code>去配置并管理大量的Docker主机。它会自动创建主机、安装Docker Engine并且配置docker 客户端。每个托管主机（“machine”）是 Docker 主机和配置的客户端的组合。</p>
<h2 id="Docker-Engine-和-Docker-Machine的区别"><a href="#Docker-Engine-和-Docker-Machine的区别" class="headerlink" title="Docker Engine 和 Docker Machine的区别"></a>Docker Engine 和 Docker Machine的区别</h2><p>当人们说“Docker”时，他们通常意味着 Docker Engine，即由 Docker 守护程序组成的客户端-服务器应用程序，指定用于与守护程序进行交互的接口的 REST API 以及与守护程序（通过 REST API 包装器）通信的命令行界面（CLI）客户端。<code>Docker Engine</code> 从 CLI 接受<code>docker</code>命令，例如<code>docker run &lt;image&gt;</code>，<code>docker ps</code>列出运行的容器，<code>docker images</code>以列出镜像等。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518683627228.jpg" alt="enter description here"></p>
<p>Docker Machine 是一种用于配置和管理 Docker 化的主机（Docker Engine的主机）的工具。通常，您在本地系统上安装 Docker Machine。Docker Machine 有自己的命令行客户端docker-machine和 Docker Engine 客户端docker。您可以使用 Machine 在一个或多个虚拟系统上安装 Docker Engine。这些虚拟系统可以是本地的（如当您使用 Machine 在 Mac 或 Windows 上的 VirtualBox 中安装和运行 Docker Engine）或远程（当您使用 Machine 在云提供商上配置 Docker 化主机时）。Docker 化主机本身可以被认为是有时被称为托管的“machines”。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518683773491.jpg" alt="enter description here"></p>
<h2 id="安装-Docker-Machine"><a href="#安装-Docker-Machine" class="headerlink" title="安装 Docker Machine"></a>安装 Docker Machine</h2><p>安装Docker Machine的前提是你已经安装好Docker</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -L https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-`uname <span class="_">-s</span>`-`uname -m` &gt;/usr/<span class="built_in">local</span>/bin/docker-machine &amp;&amp; \</div><div class="line"> chmod +x /usr/<span class="built_in">local</span>/bin/docker-machine</div></pre></td></tr></table></figure>
<h3 id="maxOS"><a href="#maxOS" class="headerlink" title="maxOS"></a>maxOS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> curl -L https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-`uname <span class="_">-s</span>`-`uname -m` &gt;/tmp/docker-machine &amp;&amp; \</div><div class="line">sudo install /tmp/docker-machine /usr/<span class="built_in">local</span>/bin/docker-machine</div></pre></td></tr></table></figure>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>使用GIt Bash工具安装，并且这个工具支持像<code>chmod</code>这样的Linux命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> if [[ ! -d &quot;$HOME/bin&quot; ]]; then mkdir -p &quot;$HOME/bin&quot;; fi &amp;&amp; \</div><div class="line">curl -L https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-Windows-x86_64.exe &gt; &quot;$HOME/bin/docker-machine.exe&quot; &amp;&amp; \</div><div class="line">chmod +x &quot;$HOME/bin/docker-machine.exe&quot;</div></pre></td></tr></table></figure></p>
<h2 id="普通情况使用Docker-Machine创建Machine"><a href="#普通情况使用Docker-Machine创建Machine" class="headerlink" title="普通情况使用Docker Machine创建Machine"></a>普通情况使用Docker Machine创建Machine</h2><p>假设我现在有两个主机：主机1运行Docker Machine，创建主机2为Docker 主机</p>
<h3 id="配置免交互认证登录"><a href="#配置免交互认证登录" class="headerlink" title="配置免交互认证登录"></a>配置免交互认证登录</h3><p>将主机1的公钥放入主机2的<code>~/.ssh/authorized_keys</code>文件中</p>
<p>或者使用<code>ssh-copy-id</code>完成上面的操作</p>
<h3 id="修改sudoers文件"><a href="#修改sudoers文件" class="headerlink" title="修改sudoers文件"></a>修改sudoers文件</h3><p>在主机2中的<code>/etc/sudoers</code>文件中添加<code>Defaults  visiblepw</code>一行（或者把<code>!visiblepw</code>改为<code>visiblepw</code>）</p>
<h3 id="创建一个Docker主机"><a href="#创建一个Docker主机" class="headerlink" title="创建一个Docker主机"></a>创建一个Docker主机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine create --driver generic--generic-ip-address=192.168.1.111 Ubuntu-004</div></pre></td></tr></table></figure>
<p>使用docker-machinecreate创建machine时，会检测主机是否已经安装docker，如果安装就简单做相应的检查动作即可，如果未安装，则会安装最新版的docker</p>
<h2 id="在云服务提供商平台使用Docker-Machine"><a href="#在云服务提供商平台使用Docker-Machine" class="headerlink" title="在云服务提供商平台使用Docker Machine"></a>在云服务提供商平台使用Docker Machine</h2><p>Docker Machine支持几个流行的云平台，如Digital Ocean、Amazon Web Services（AWS）、Microsoft Azure、Google Cloud Computing及其它等等，所以我们可以在不同的平台使用相同的接口来部署Docker。这里我们使用Digital Ocean驱动在Digital Ocean的服务器上部署Docker，运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker-machine create --driver digitalocean --digitalocean-access-token &lt;API-Token&gt; Linux-test</div><div class="line"></div><div class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(docker-machine env Linux-test)</span>"</span></div></pre></td></tr></table></figure>
<p><code>--driver</code>选项指定digitalocean驱动，<code>--digitalocean-access-token</code>选项指定<a href="https://cloud.digitalocean.com/settings/applications" target="_blank" rel="external">Digital Ocean Control Panel</a>提供的API Token，命令最后的是我们创建的Docker虚拟机的机器名。</p>
<p>返回的信息如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Creating CA: /root/.docker/machine/certs/ca.pem</div><div class="line">Creating client certificate: /root/.docker/machine/certs/cert.pem</div><div class="line">Running pre-create checks...</div><div class="line">Creating machine...</div><div class="line">(Linux-test) Creating SSH key...</div><div class="line">(Linux-test) Creating Digital Ocean droplet...</div><div class="line">(Linux-test) Waiting <span class="keyword">for</span> IP address to be assigned to the Droplet...</div><div class="line">Waiting <span class="keyword">for</span> machine to be running, this may take a few minutes...</div><div class="line">Detecting operating system of created instance...</div><div class="line">Waiting <span class="keyword">for</span> SSH to be available...</div><div class="line">Detecting the provisioner...</div><div class="line">Provisioning with ubuntu(systemd)...</div><div class="line">Installing Docker...</div><div class="line">Copying certs to the <span class="built_in">local</span> machine directory...</div><div class="line">Copying certs to the remote machine...</div><div class="line">Setting Docker configuration on the remote daemon...</div><div class="line">Checking connection to Docker...</div><div class="line">Docker is up and running!</div><div class="line">To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env Linux-test</div></pre></td></tr></table></figure></p>
<p>运行如上命令后，我们可以在Digital Ocean Droplet Panel中看到一个新的具有默认配置的droplet已经被创建出来了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518684941619.jpg" alt="enter description here"></p>
<p>简便起见，docker-machine会使用默认配置来部署Droplet。我们可以通过增加选项来定制我们的Droplet。这里是一些digitalocean相关的选项，我们可以使用它们来覆盖Docker Machine所使用的默认配置。</p>
<ul>
<li>–digitalocean-image “ubuntu-14-04-x64” 用于选择Droplet的镜像</li>
<li>–digitalocean-ipv6 enable 启用IPv6网络支持</li>
<li>–digitalocean-private-networking enable 启用专用网络</li>
<li>–digitalocean-region “nyc3” 选择部署Droplet的区域</li>
<li>–digitalocean-size “512mb” 选择内存大小和部署的类型</li>
</ul>
<p>如果你想在其他云服务使用docker-machine，并且想覆盖默认的配置，可以运行如下命令来获取Docker Mackine默认支持的对每种平台适用的参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine create -h</div></pre></td></tr></table></figure></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="查看主机"><a href="#查看主机" class="headerlink" title="查看主机"></a>查看主机</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine ls</div></pre></td></tr></table></figure>
<p>ACTIVE一列有“*”标记的是活跃主机，同时可以用<code>docker-machine active</code>命令来标记其他的主机为活跃主机</p>
<h3 id="使用Docker容器"><a href="#使用Docker容器" class="headerlink" title="使用Docker容器"></a>使用Docker容器</h3><p>创建主机成功后，可以通过 env 命令来让后续操作对象都是目标主机。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker-machine env <span class="built_in">test</span></div></pre></td></tr></table></figure></p>
<p>后续根据提示在命令行输入命令之后就可以操作 test 主机。</p>
<p>也可以通过 SSH 登录到主机：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh <span class="built_in">test</span></div><div class="line"></div><div class="line">docker@<span class="built_in">test</span>:~$ docker --version</div><div class="line">Docker version 17.10.0-ce, build f4ffd25</div></pre></td></tr></table></figure></p>
<p>连接到主机之后你就可以在其上使用 Docker 了。</p>
<h3 id="删除主机"><a href="#删除主机" class="headerlink" title="删除主机"></a>删除主机</h3><p>删除在运行的主机以及它的所有镜像和容器，我们可以使用<code>docker-machine rm</code>命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine rm linux-dev</div></pre></td></tr></table></figure></p>
<p>运行完以后，本地和与远端的都将删除，在云平台上的实例也会被删除</p>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><ul>
<li>active 查看活跃的 Docker 主机</li>
<li>config 输出连接的配置信息</li>
<li>create 创建一个 Docker 主机</li>
<li>env 显示连接到某个主机需要的环境变量</li>
<li>inspect 输出主机更多信息</li>
<li>ip 获取主机地址</li>
<li>kill 停止某个主机</li>
<li>ls 列出所有管理的主机</li>
<li>provision 重新设置一个已存在的主机</li>
<li>regenerate-certs 为某个主机重新生成 TLS 认证信息</li>
<li>restart 重启主机</li>
<li>rm 删除某台主机</li>
<li>ssh SSH 到主机上执行命令</li>
<li>scp 在主机之间复制文件</li>
<li>mount 挂载主机目录到本地</li>
<li>start 启动一个主机</li>
<li>status 查看主机状态</li>
<li>stop 停止一个主机</li>
<li>upgrade 更新主机 Docker 版本为最新</li>
<li>url 获取主机的 URL</li>
<li>version 输出 docker-machine 版本信息</li>
<li>help 输出帮助信息</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《C++ Primer》笔记 C++基础部分]]></title>
      <url>/2018/02/15/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-C-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/</url>
      <content type="html"><![CDATA[<p>《C++ Primer》笔记 C++基础部分</p>
<a id="more"></a>
<h1 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h1><h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><h3 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h3><p>类型char和类型signed char并不一样。尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。</p>
<p>当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）</p>
<p>与一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。把int转换成无符号数的过程和把int直接赋给无符号数—样。</p>
<h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517231165506.jpg" alt="enter description here"></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>初始化不是赋值，初始化的含义是创建一个变量的时候赋予其一个初始值，而赋值的含义是把对象的当前值删除，而以一个新值来代替</p>
<p>默认初始化：如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将不被初始化(uninitialized)。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。</p>
<p>使用未初始化的值将带来无法预计的后果</p>
<h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>变量能且只能被定义一次，但可以被声明多次</p>
<h3 id="标识符（identifier）"><a href="#标识符（identifier）" class="headerlink" title="标识符（identifier）"></a>标识符（identifier）</h3><h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>建议：当你第一次使用变量的时候再定义它</p>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用（reference）为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。</p>
<p>一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定（bind)在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此<strong>引用必须初始化</strong>。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517232990644.jpg" alt="enter description here"></p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针必须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，将拥有一个不确定的值。</p>
<p>指针的他（即地址）应属下列4种状态之一:</p>
<ol>
<li>指向一个对象。</li>
<li>指叫紧邻对象所占空间的下一个位置。</li>
<li>空指针，意味着指针没有指向任何对象。</li>
<li>无效指针，也就是上述情况之外的其他值。</li>
</ol>
<p>访问无效指针和空指针或者未知指针的后果无法预计</p>
<p><code>void*</code>指针时一种特殊的指针类型，可用于存放任意对象的地址。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象做哪些操作。</p>
<h3 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h3><p>引用本身不是对象，因此不能定义指向引用的指针。但是指针是对象，所以存在对指针的引用。</p>
<h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p>const对象被设定为仅在文件内有效</p>
<p>对const的引用可能引用一个并非const的对象：常量引用仅对引用可参与的操作做出了限定，对于引用对象本身是不是一个常量未作限定。</p>
<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p>用名词<strong>顶层const</strong>(top-levelconst)表示指针本身是个常量，而用名词<strong>底层const</strong>(low-levelconst)表示指针所指的对象是一个常量。</p>
<h3 id="constexpr-和常量表达式"><a href="#constexpr-和常量表达式" class="headerlink" title="constexpr 和常量表达式"></a>constexpr 和常量表达式</h3><p>常量表达式（constexpression)是指值不会改变而且在编译过程就能得到汁算结果的表达式。当然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。</p>
<p>C++11标准规定，允许将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量表达式。</p>
<h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h3><p>编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，C++11新标准引入了auto类型说明符，用它就能让编译器帮我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如double)不同，auto让编译器通始值来推算变量的类型。显然，auto定义的变量必须有初始值：</p>
<p>auto一般会忽略顶层const，同时底层const则会保留下来</p>
<h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h3><p>有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变蛩。为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数椐类型。在此过程中，编译器分忻表达式并得到它的类型，却不实际汁算表达式的值:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">decltype</span>(f()) sum = x;   <span class="comment">// sum的类型就是函数f的返回类型</span></div></pre></td></tr></table></figure>
<p>decltype 处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）</p>
<hr>
<h1 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a>字符串、向量和数组</h1><h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p>如果提供一个字符串字面值，则该字面值中除了最后那个空字符外其他所有字符都被拷贝新建的string对象中。</p>
<blockquote>
<p>直接初始化和拷贝初始化</p>
</blockquote>
<p>如果使用等号（=）初始化一个变量，实际上执行的是<strong>拷贝初始化</strong>（copy initialization），编译器将等号右侧的初始值拷贝到新创建的对象中去。<br>与之相反，不使用等号，则执行的是<strong>直接初始化</strong>（direct initialization）</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517572296753.jpg" alt="enter description here"></p>
<blockquote>
<p>string:size_type 类型</p>
</blockquote>
<p>string类及其他大多数标准库类型都定义了几种配套的类型。这些配套体现了标准库类型与机器无关的特性，类型size_type即是其中的一种。在具体使用的时候，通过作用域操作符表明名字size_type是在类string中定义的。</p>
<blockquote>
<p>字面值和string对象相加</p>
</blockquote>
<p>当把string对象和字符字面值以及字符串字面值混在一条语句中使用的时候，必须保证每个加法运算符的两侧至少有一个是string对象</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517572788565.jpg" alt="enter description here"></p>
<h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p>如果循环体内部包含有向 vector对象添加元元素的语句,则不能使用范 围for循环</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517659028911.jpg" alt="enter description here"></p>
<p>不能用下标形式添加元素：vector对象(以及 string对象)的下标运算符可用于访问已存在的元素, 而不能用于添加元素。</p>
<h2 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h2><p>所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符</p>
<p>类似于指针类型,迭代器也<strong>提供了对对象的间接访问</strong>。就迭代器而言,其对对象是容器中的元素或者者 string对象中的字符。使用迭代器可以访问某 个元素,迭代器也能从一个元素移动到另外一个元素。迭代器有有效和无效之分,这一点 和指针差不多。<strong>有效的迭代器或者指向某个元素,或者指向容器中尾元素的下一位置</strong>，其他所有情况都属于无效。</p>
<h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>end成员负责返回指向容器(或 string对象)“尾元素的下一位置( one past the end) 的迭代器,也就是说,该迭代器指示的是容器的一个本不存在的“尾后( off the end)”元 素。这样的迭代器没什么实际含义,仅是个标记而已,表示我们已经处理完了容器中的所 有元素。end成员返回的迭代器常被称作尾后迭代器( off-the- end iterator)或者简称为尾 迭代器( end iterator)。特殊情况下如果容器为空,则beg1n和end返回的是同一个迭 代器。（都是尾后迭代器）</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517659661001.jpg" alt="enter description here"></p>
<p>迭代器运算符</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517659702856.jpg" alt="enter description here"></p>
<blockquote>
<p>迭代器类型</p>
</blockquote>
<p>就像不知道 string和 vector的 size type成员员到底是什么类型一样,一般来说我们也不知道(其实是无须知道)迭代器的精确类型。而实际上, 那些拥有迭代器的标准库类型使用 iterator和 const iterator来表示迭代器的类型</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517659938792.jpg" alt="enter description here"></p>
<blockquote>
<p>某些对vector对象的操作会使迭代器失效</p>
</blockquote>
<p>不能在for循环范围内向vector对象添加元素；任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效</p>
<h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><p>迭代器的递增运算令迭代器每次移动一个元素,所有的标准库容器都有支持递增运算 的迭代器。类似的,也能用=和!=对任意标准库类型的两个有效迭代器进行比较</p>
<p>vector和string迭代器支持更多的迭代器运算</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517660460874.jpg" alt="enter description here"></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>不允许拷贝和赋值</p>
</blockquote>
<p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值</p>
<blockquote>
<p>理解复杂的数组声明</p>
</blockquote>
<p>类型修饰符从右向左依次绑定，就数组而言，由内向外阅读比从右向左好很多</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517660778235.jpg" alt="enter description here"></p>
<blockquote>
<p>访问数组元素</p>
</blockquote>
<p>在使用数组下标的时候,通常将其定义为size_t类型。size_t是一种机器相关的 无符号类型,它被设计得足够大以便能表示内存中任意对象的大小。</p>
<blockquote>
<p>标准库函数</p>
</blockquote>
<p>尽管能计算得到尾后指针,但这种用法极易出错。为了让指针的使用更简单、更安全, C++11新标准引引入了两个名为 begin和end的函数。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517661137672.jpg" alt="enter description here"></p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>严格来说，C++语言中没有多维数组，通常所说的的多维数组其实是数组的数组。</p>
<hr>
<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p>重载运算符</p>
</blockquote>
<p>C++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时,用户可以自行定义其含义义。因为这种自定义的过程事实 上是为已存在的运算符赋予了另外一层含义,所以称之为<strong>重載运算符</strong>( overloaded operator)。</p>
<blockquote>
<p>左值和右值</p>
</blockquote>
<p>C++的表达式要不然是右值( rvalue,读作“are- value”),要不然就是左值( lvalue, 读作“ ell-value”)。这两个名词是从C语言继承过来的,原本是为了帮助记忆:左值可以 位于赋值语句的左侧,右值则不能。</p>
<p>在C++语言中,二者的区别就没那么简单了。一个左值表达式的求值结果是一个对象 或者一个函数,然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对 象。此外,虽然某些表达式的求值结果是对象,但它们是右值而非左值。可以做一个简单 的归纳:<strong>当一个对象被用作右值的时候,用的是对象的值(内容);当对象被用作左值的 时候,用用的是对象的身份(在内存中的位置)。</strong> </p>
<p>不同的运算符对运算对象的要求各不相同,有的需要左值运算对象、有的需要右值运 算对象:返回值也有差异,有的得到左值结果、有的得到右值结果。一个重要的原则是：<strong>在需要右值的地方可以用左值来代替,但 是不能把右值当成左值(也就是位置)使用</strong>。 当一个左值被当成右值使用时,实际使用的 是它的内容(值)。</p>
<h3 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h3><p>对于那些没有指定执行顺序的运算符来说,如果表达式指向并修改了同一个对象,将会引发错误并产生<strong>未定义的行为</strong>。</p>
<p>举个简单的例子,&lt;&lt;运算符 没有明确规定何时以及如何对运算对象求值,因此下面的输出表达式是末定义的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"+"</span> &lt;&lt; ++i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 未定义的</span></div></pre></td></tr></table></figure></p>
<p>C++语言没有明确规定大多数二元运算符的求值顺序,给编译器优化留下了 余地。这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡.</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517751109803.jpg" alt="enter description here"></p>
<p>算术运算符能作用域任何算术类型以及任意能转化为算术类型的类型。</p>
<p>算术表达式有可能产生未定义的结果。一部分原因是数学性质本身:例如除数是0 的情况;另外一部分则源于计算机的特点:例如溢出,当计算的结果超出该类型所能表 示的范围时就会产生溢出。</p>
<blockquote>
<p>除法和取模运算</p>
</blockquote>
<p>在除法运算中,如果两个运算对象的符号相同则商为正(如果不为0的话),否则商 为负。C++语言的早期版本允许结果为负值的商向上或向下取整,C++11新标准则规定商 律向0取整(即直接切除小数部分) </p>
<p>根据取余运算的定义,如果m和n是整数且n非0,则表达式(m/n)*n+m%n的求值 结果与m相等。隐含的意思是,如果m%n不等于0,则它的符号和m相同。C++语言的早 期版本允许m%n的符号匹配n的符号,而且商向负无穷一侧取整,这一方式在新标准中 已经被禁止使用了。除了-m导致溢出的特殊情况,其他时候(-m)/n和m/(-n)都等于 (m/n),m%(-n)等于m%n,(-m)%n等于-(m%n)。</p>
<p>具体示例如下:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517751057230.jpg" alt="enter description here"></p>
<h2 id="逻辑运算符和关系运算符"><a href="#逻辑运算符和关系运算符" class="headerlink" title="逻辑运算符和关系运算符"></a>逻辑运算符和关系运算符</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517751134864.jpg" alt="enter description here"></p>
<p>逻辑与运算符和逻辑或运算符都是先求左側运算对象的值再求右侧运算对象的值,当 且仅当左側运算对象无法确定表达式的结果时オ会计算右侧运算对象的值。这种种策略称为 短路求值( short- circuit evaluation)。</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符的左侧运算对象必须是一个可修改的左值</p>
<h2 id="递增运算符和递减运算符"><a href="#递增运算符和递减运算符" class="headerlink" title="递增运算符和递减运算符"></a>递增运算符和递减运算符</h2><p>递增和递减运算符有两种形式:前置版本和后置版本。前置递增运算符首先将运算对象加1(或减1),然后将改变后的对象作为求 值结果。后置版本也会将运算对象加1(或减1),但是求值结果是运算对象改变之前那个 值的副本</p>
<p>建议:除非必须,否则不用递增递减运算符的后置版本：<br>有C语言背景的读者可能对优先使用前置版本递增运算符有所疑间问,其实原因非常 简单:前置版本的递增运算符避免了不必要的工作,它把值加1后直接返回改变了的运 算对象。与之相比,后置版本需要将原始值存储下来以便于返回这个未修改的内容。如 果我们不需要修改前的值,那么后置版本的操作就是一种浪费。</p>
<h2 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h2><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律,其所得得的值是一个size_t类型</p>
<p>运算符的运算对象有两种形式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">sizeof</span>(type)</div><div class="line"><span class="keyword">sizeof</span> expr</div></pre></td></tr></table></figure></p>
<p>在第二种形式中，sizeof返回的是表达式结果类型的大小。与众不同的一点是，sizeof并不实际计算其运算对象的值：</p>
<p>因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中的元素个数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(ia)/<span class="keyword">sizeof</span>(*ia);</div><div class="line"><span class="keyword">int</span> arr2[sz]; <span class="comment">// ok sizeof returns a constant expression</span></div></pre></td></tr></table></figure></p>
<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p>逗号运算符( comma operator)含有两个运算对象,按照从左向右的顺序依次求值 和逻辑与、逻辑或以及条件运算符一样,逗号运算符也规定了运算对象求值的顺序。 对于逗号运算符来说,首先对左侧的表达式求值,然后将求值结果丢弃掉。逗号运算符真正的结果是右側表达式的值。如果右侧运算对象是左值,那么最终的求值结果也是左值。</p>
<h2 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="其他隐式类型转换"><a href="#其他隐式类型转换" class="headerlink" title="其他隐式类型转换"></a>其他隐式类型转换</h3><p>数组转换为指针：在大多数用到数组的表达式中，数组自动转换为指向数组首元素的指针</p>
<p>指针的转换:C++还规定了几种其他的指针转换方式,包括常量整数值0或者者字面值 nu11ptr能转换成任意指针类型:指向任意非常量的指针能转换成void<em>;指向任意对 象的指针能转换成 const void</em>。</p>
<p>转换为布尔类型：存在一种从算术类型或指针类型向布尔类型自动转换的机制</p>
<p>转换为常量：允许将指向非常量类型的指针转换成为相应常量类型的指针，对于引用也是这样。</p>
<h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p>待整理</p>
<h2 id="运算符优先级表"><a href="#运算符优先级表" class="headerlink" title="运算符优先级表"></a>运算符优先级表</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517752932745.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517752958321.jpg" alt="enter description here"></p>
<hr>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><blockquote>
<p>悬垂else</p>
</blockquote>
<p>当一个if语句嵌套在另一个if语句内部时,很可能if分支会多于else分支。事实上,之前那个成绩转换的程序就有4个if分支,而只有2个else分支。这时候问题 出现了:我们怎么知道某个给定的else是和和哪个if匹配呢? 这个问题通常称作<strong>悬垂else</strong>( dangling else),在那些既有if语句又有if else语句的编程语言中是个普遍存在的问题。不同语言解决该问题的思路也不同,就就C++而言, 它规定else与离它最近的尚未匹配的if匹配,从而消除了程序的的二义性。</p>
<blockquote>
<p>case标签</p>
</blockquote>
<p>case关键字和它对应的值一起被称为case标签( case label)。case标签签必须是整 型常量表达式</p>
<blockquote>
<p>switch内部的变量定义</p>
</blockquote>
<p>如前所述, switch的执行流程有可能会跨过某些case标标签。如果程序跳转到了某个特定的case,则switch结构中该该case标签之前的部分会被忽略掉。这种忽略掉一 部分代码的行为引出了一个有趣的问题:如果被略过的代码中含有变量的定义该怎么办? 答案是:<strong>如果在某处一个带有初值的变量位于作用域之外,在另一处该变量位于作用域之内,则从前一处跳转到后一处的行为是非法行为。</strong></p>
<h2 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h2><h3 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h3><p>C++11新标准引入了一种更简单的for语句,这种语句可以遍历容器或其他序列的 所有元素。范围for语句( range for statement）的语法形式是: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (declaration expression) </div><div class="line">statement</div></pre></td></tr></table></figure>
<p>expression表示的必须是一个序列,比如用花括号括起来的初始值列表、数组或者 vector或string等类型的对象,这些类型的共同特点是拥有能返回迭代器的 begin和end成员。 </p>
<p>declaration定义一个变量,序列中的每个元素都得能转换成该变量的类型。确保类型相容最简单的办法是使用auto类型说明符,这个关键字可以令编译器帮助我们指定合适的类型。</p>
<p>如果需要对序列中的元素执行写操作,循环变量必须声明成引用类型 每次迭代都会重新定义循环控制变量,并将其初始化成序列中的下一个值,之后オ会 执行 statement。像往常一样, statement可以是一条单独的语句也可以是一个块。所有元素 都处理完毕后循环终止。</p>
<h2 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h2><p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。当程序的某部分检测到一个他无法处理的问题的时候，需要用到异常处理。</p>
<p>异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持。在C++语言 中,异常处理包括 </p>
<ul>
<li>throw表达式( throw expression),异常检测部分使用 throw表达式来表示它遇到 了无法处理的问题。我们说 throw引发( raise)了异常。 </li>
<li>ty语句块( try block),异常处理部分使用try语句块处理异常。try语句块以 关键字try开始,并以一个或多个 catch子句( catch clause)结束。try语句块 中代码抛出的异常通常会被某个 catch子句处理。因为 catch子句“处理”异常, 所以它们也被称作异常处理代码( exception handler)。 </li>
<li>套异常类( exception class),用于在 throw表达式和相关的 catch子句之间传 递异常的具体信息。</li>
</ul>
<h3 id="标注异常"><a href="#标注异常" class="headerlink" title="标注异常"></a>标注异常</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_7_1518014704271.jpg" alt="enter description here"></p>
<hr>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>我们通过<strong>调用运算符</strong>( call operator)来执行函数。调用运算符的形式是一对圆括물 它作用于一个表达式,该表达式是函数或者指向函数的指针:圆括号之内是一个用逗号隔 开的实参( argument)列列表,我们用实参初始化函数的形参。调调用表达式的类型就是函数 的返回类型。</p>
<p>函数的调用完成两项工作:一是用实参初始化函数对应的形参,二是将控制权转移给被调 用函数。此时,主调调函数( calling function)的执行被暂时中断,被调函数( called function) 开始执行。</p>
<blockquote>
<p>形参和实参</p>
</blockquote>
<p>实参是形参的初始值。尽管实参和形参存在对应关系，但是并没有规定实参的求值顺序。编译器能以任意可行的顺序对实参求值。</p>
<h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><p>名字有作用域，对象有生命周期（lifetime）：名字的作用域是程序文本的一部分，名字在其中可见；对象的生命周期是程序执行过程中该对象存在的一段时间。</p>
<p>如果局部静态变量没有显式的初始值，它将执行初始化：内置类型的局部静态变量初始化为0</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数的声明不包含函数体，所以也不需要形参的名字，但是加上名字能够让使用者更好地理解函数的功能。</p>
<h3 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h3><p>分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译</p>
<p>编译以后，如果我们修改了其中一个源文件，那么只需要重新编译那个改动的文件即可</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>当形参是引用类型时,我们说它对应的实参被<strong>引用传递</strong>( Dassed by reference )或者函 数被传引用週用( called by reference)。和其他引用一样,引用形参也是它绑定的对象的别 名;也就是说,引用形参是它对应的实参的别名。 </p>
<p>当实参的值被拷贝给形参时,形参和实参是两个相互独立的对象。我们们说这样的实参 被<strong>值传递</strong>( passed by value)或者者函数被传值调用( called by value)</p>
<blockquote>
<p>使用引用避免拷贝</p>
</blockquote>
<p>拷贝大的类类型对象或者容器对象比较低效,甚至有的类类型(包括括1O类型在内) 根本就不支持拷贝操作。当某种类型不支持拷贝操作时,函数只能通过引用形参访问该类 型的对象。</p>
<p>如果函数无需改变引用形参的值，最好将其声明为常量引用</p>
<h3 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h3><p><strong>当形参时const时，其为顶层const，顶层const作用于对象本身。</strong></p>
<p>和其他初始化过程一样,当用实参初始化形参时会忽略掉顶层 const。换句话说,形参的顶层 const被忽略掉了。当形参有顶层 const时,传给它常量对象或者非常量对象都是 可以的:</p>
<h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p>数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响,这两个性质分别 是:<strong>不允许拷贝数组</strong>以及<strong>使用数组时(通常)会将其转换成 指针</strong>。因为不能拷贝数组,所以我们<strong>无法以值传递的方式使用 数组参数</strong>。因为数组会被转换成指针,所以当我们为函数传递一个数组时,实际上传递的 是指向数组首元素的指针。</p>
<p>为了程序的可读性，我们可以把形参写成类似数组的形式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">( <span class="keyword">const</span> *<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">( <span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">( <span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;  <span class="comment">// 这里的维度表示我们期望有多少元素，实际不一定</span></div></pre></td></tr></table></figure></p>
<p>管理指针形参的三种常用技术：</p>
<ul>
<li>使用标记指定数组长度，要求数组本身包含一个结束标记</li>
<li>使用标准库规范，传递指向数组首元素和数组尾元素的指针</li>
<li>显式传递一个表示数组大小的形参</li>
</ul>
<blockquote>
<p>传递多维数组</p>
</blockquote>
<p>和所有数组一样,当将多维数组传递给函数时,真正传递的是指向数组首元素的指针 。因为我们处理的是数组的数组,所以首元素本身就是一个数组, 指针就是一个指向数组的指针。<strong>数组第二维(以及后面所有维度)的大小都是数组类型的 部分,不能省略</strong>:</p>
<h3 id="含有可变形参的参数"><a href="#含有可变形参的参数" class="headerlink" title="含有可变形参的参数"></a>含有可变形参的参数</h3><p>为了编写能处理不同数量实参的函数,C++11新标准提供了两种主要的方法:如如果所 有的实参类型相同,可以传递一个名为initializer_list的标准库类型:如果实参的 类型不同,我们可以编写一种特殊的函数,也就是所谓的可变参数模板,</p>
<blockquote>
<p>initializer_list 形参</p>
</blockquote>
<p>如果函数的实参数量未知但是全部实参的类型都相同,我们可以使用initializer_listt类型的形参。initializer_list是一种标准库类型,用于表示 某种特定类型的值的数组</p>
<blockquote>
<p>省略符形参</p>
</blockquote>
<p>省略符形参是为了便于C++程序访访问某些特殊的C代码而设置的,这些们代码使用了名 为 varargs的C标准库功能。</p>
<p>省略符形参只能出现在形参列表的最后一个位置,它的形式无外乎以下两种: </p>
<ul>
<li>void foo(parm list, …);</li>
<li>void foo(…)</li>
</ul>
<p>第一种形式指定了foo函数的部分形参的类型,对应于这些形参的实参将会执行正常的 类型检査。省略符形参所对应的实参无须类型检査。在第一种形式中,形参声明后面的逗 号是可选的。</p>
<h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h2><blockquote>
<p>不要返回局部对象的引用或指针</p>
</blockquote>
<p>函数完成后,它所占用的存储空间也随之被释放掉。因此, 函数终止意味着局部变量的引用将指向不再有效的内存区域。会引发未定义行为</p>
<blockquote>
<p>引用返回左值</p>
</blockquote>
<p>调用一个返回引用的函数返回左值，返回其他类型得到右值</p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>不允许两个函数除了返回类型外其他所有的要素都相同</p>
<p>一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来</p>
<blockquote>
<p>调用重载函数</p>
</blockquote>
<p>定义了一组重载函数后,我们需要以合理的实参调用它们。<strong>函数匹配</strong>( functionmatching)是指一个过程,在这个过程中我们把函数调用与一组重载函数中的某一个关联起来,函数匹配也叫做<strong>重载确定</strong>( overload resolution)。编编译器首先将调用的实参与重载集合中每一个函数的形参进行比较,然后根据比较的结果决定到底调用哪个函数。</p>
<h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><p>某些函数有这样一种形参,在函数的很多次调用中它们都被赋予一个相同的值,此时,我们把这个反复出现的值称为函数的<strong>默认实参</strong>( default argument)。调调用含有默认实参的函数时,可以包含该实参,也可以省略该实参。</p>
<p>一旦某个形参被赋予了默认值，后面所有的额形参都要赋予默认值。所以当设计含有默认实参的函数时,其中一项任务是合理设置形参的顺序,尽量让不怎么使用默认值的形参出现在前面,而让那些经常使用默认值的形参出现在后面</p>
<p>在给定的作用域中一个形参只能被赋予一次默认实参。换句句话说,函数的后续声明只能为之前那些没有默认值的形参添加默认实参,而且该形参右侧的所有形参必须都有默认值。</p>
<p>局部变量不能作为默认实参。除此之外,只要表达式的类型能转换成形参所需的类型,该表达式就能作为默认实参:</p>
<h3 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h3><p>在大多数机器上,一次次函数调用其实包含着一系列工作:调用前要先保存寄存器,并在返回时恢复;可能需要拷贝实参;程序转向一个新的位置继续执行。</p>
<h4 id="内联函数可以避免函数调用的开销"><a href="#内联函数可以避免函数调用的开销" class="headerlink" title="内联函数可以避免函数调用的开销"></a>内联函数可以避免函数调用的开销</h4><p>将函数定义为内联函数（inline），通常就是把它在每一个调用点上“内联地”展开。函数返回类型前面加上关键字inline，这样就可以将它声明为内联函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="built_in">string</span> &amp; <span class="title">shortString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> s1.size() &lt;= s2.size() ? s1 : s2;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>一般来说,内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数,而而且一个75行的函数也不大可能在调用点内联地展开。</p>
<h4 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h4><p>constexpr函数( constexpr function)是指能用于常量表达式的函数。定义 constexpr函数的方法与其他函数类似,不过要遵循几项约定:函数的返回类型及所有形参的类型都得是字面值类型,而且函数体中必须有且只有一条 return语句:</p>
<p>把內联函数和 constexpr函数放在头文件内和其他函数不一样,内联函数和 constexpr函数可以在程序中多次定义。毕竟,编译器要想展开函数仅有函数声明是不够的,还需要函数的定义。不过,对于某个给定的内联函数或者 constexpr函数来说,它的多个定义必须完全一致。基于这个原因,内联函数和 constexpr函数通常定义在头文件中。</p>
<h3 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h3><p>程序可以包含一些用于调试的代码,但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时,要先屏蔽掉调试代码。这种方法用到两项预处理功能: assert和 NDEBUG</p>
<h4 id="assert-预处理宏"><a href="#assert-预处理宏" class="headerlink" title="assert 预处理宏"></a>assert 预处理宏</h4><p>assert是一种<strong>预处理宏</strong>( preprocessor marco)。所谓预处理宏其实是一个预处理变量,它的行为有点类似于内联函数。 assert宏使用一个表达式作为它的条件:<code>assert(expr)</code> </p>
<p>首先对expr求值,如如果表达式为假(即0), assert输出信息并终止程序的执行。如果表达式为真(即非0), assert什么也不做。</p>
<p>assert宏定义在 assert头文件中。如我们所知,预处理名字由预处理器而非编译器管理,因此我们可以直接使用预处理名字而无须提供uS1ng明。也就是说,我们应该使用 assert而不是std:: assert,也不需要为 assert提供using声明。</p>
<h4 id="NDEBUG-预处理变量"><a href="#NDEBUG-预处理变量" class="headerlink" title="NDEBUG 预处理变量"></a>NDEBUG 预处理变量</h4><p>assert的行为依赖于一个名为 NDEBUG的预处理变量的状态。如果定义了 NDEBUG,则 assert什么也不做。默认状态下没有定义 NDEBUG,此时 assert将执行运行时检查。我们可以使用一个# define语句定义 NDEBUG,从而关闭调试状态。同时,很多编译器都提供了一个命令行选项使我们可以定义预处理变量</p>
<h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><h3 id="确定候选函数和可行函数"><a href="#确定候选函数和可行函数" class="headerlink" title="确定候选函数和可行函数"></a>确定候选函数和可行函数</h3><p>函数匹配的第一步是选定本次调用对应的重载函数集,集合中的函数称为<strong>候选函数</strong>( candidate function)。候选函数具备两个特征:一是与被调用的函数同名,二是其声明在调用点可见。</p>
<p>第二步考察本次调用提供的实参,然后从候选函数中选出能被这组实参调用的函数,这些新选出的函数称为<strong>可行函数数</strong>( viable function)。可行函数也有两个特征:一是其形参数量与本次调用提供的实参数量相等,二是每个实参的类型与对应的形参类型相同,或者能转换成形参的类型。</p>
<blockquote>
<p>寻找最佳匹配</p>
</blockquote>
<p>函数匹配的第三步是从可行函数中选择与本次调用最匹配的函数。实参类型与形参类型越接近，他们匹配得越好。</p>
<blockquote>
<p>含有多个形参的函数匹配</p>
</blockquote>
<p>当实参的数量有两个或更多时,函数匹配就比较复杂了。编译器依次检査每个实参以确定哪个函数是最佳匹配。如如果有且只有个函数满足下列条件,则匹配成功・该该函数每个实参的匹配都不劣于其他可行函数需要的匹配至少有一个实参的匹配优于其他可行函数提供的匹配。如果在检査了所有实参之后没有任何一个函数脱颖而出,则则该调用是错误的。</p>
<h3 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h3><p>为了确定最佳匹配,编译器将实参类型到形参类型的转換划分成儿个等级,具体排序如</p>
<ol>
<li>精确匹配,包括以下情况:实参类型和形参类型相同・实参从数组类型或函数类型转换成对应的指针类型。向实参添加顶层 const或者从实参中删除顶层 const</li>
<li>通过 const转换实现的匹配</li>
<li>通过过类型提升实现的匹配</li>
<li>通过算术类型转换或指针转换实现的匹配。</li>
<li>通过类类型转换实现的匹配配(参见14.9节</li>
</ol>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向的是函数而非对象。和其他指针一样,函数指针指向某种特定类型，函数的类型由它的返回类型和形参类型共同决定,与函数名无关。</p>
<p>想要声明一个可以指向该函数的指针，只需要用指针替换函数名即可</p>
<p>当我们把函数名作为一个值使用时，该函数自动地转换成指针。</p>
<p>此外,我们们还能直接使用指向函数的指针调用该函数,无须提前解引用指针</p>
<blockquote>
<p>函数指针形参</p>
</blockquote>
<p>和数组类似,虽然不能定义函数类型的形参,但是形参可以是指向函数的指针。此时,形参看起来是函数类型,实际上却是当成指针使用:</p>
<blockquote>
<p>返回指向函数的指针</p>
</blockquote>
<p>和数组类似,虽然不能返回一个函数,但是能返回指向函数类型的指针。然而,我们们必须把返回类型写成指针形式,编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样,要想声明一个返回函数指针的函数,最简单的办法是使用类型别名</p>
<hr>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类的基本思想是<strong>数据抽象</strong>( data abstraction)和<strong>封装</strong>( encapsulation)。<strong>数据抽象是二种依赖于接口( interface)和实现( implementation)分离的编程程(以及设计)技术。</strong>类的接口包括用户所能执行的操作;类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。</p>
<p><strong>封装实现了类的接口和实现的分离</strong>。封装后的类隐藏了它的实现细节,也就是说,类的用户只能使用接口而无法访问实现部分。</p>
<h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><h3 id="定义类的基本"><a href="#定义类的基本" class="headerlink" title="定义类的基本"></a>定义类的基本</h3><h4 id="引入-this"><a href="#引入-this" class="headerlink" title="引入 this"></a>引入 this</h4><p>成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时,用请求该函数的对象地址初始化this</p>
<p>对于我们来说,this形参是隐式定义的。实际上,任何自定义名为this的参数或变量的行为都是非法的。我们们可以在成员函数体内部使用this因此尽管没有必要,但我们还是能把isbn定义成如下的形式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; &#125;</div></pre></td></tr></table></figure>
<h4 id="引入const-成员函数"><a href="#引入const-成员函数" class="headerlink" title="引入const 成员函数"></a>引入const 成员函数</h4><p>上面的ibsn函数的另一个关键之处是紧随参数列表之后的 const关键字,这里, const的作用是修改隐式this指针的类型。</p>
<p>默认情况下,<strong>this的类型是指向类类型非常量版本的常量指针</strong>。尽管this是隐式的,但它仍然需要遵循初始化规则,意味着(在默认情况下)我们不能把this绑定到一个常量对象上。</p>
<p>C++语言的做法是允许<strong>把 const关键字放在成员函数的参数列表之后</strong>,此时,紧跟在参数列表后面的 const表示this是一个指向常量的指针。像这样使用 const的成员函数被称作<strong>常量成员函数</strong>( const member function)。</p>
<h4 id="类作用域和成员函数"><a href="#类作用域和成员函数" class="headerlink" title="类作用域和成员函数"></a>类作用域和成员函数</h4><p>编译器分两步处理类:首先编译成员的声明,然后才轮到成员函数体(如果有的话)。因此,成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p>
<h4 id="在类外部定义成员函数"><a href="#在类外部定义成员函数" class="headerlink" title="在类外部定义成员函数"></a>在类外部定义成员函数</h4><p>当我们在类的外部定义成员函数时,成员函数的定义必须与它的声明匹配。也就是说,返回类型、参数列表和函数名都得与类内部的声明保持一致。如果<strong>成员被声明成常量成员函数,那么它的定义也必须在参数列表后明确指定 const属性</strong>。同时,类外部定义的成员的名字必须包含它所属的类名</p>
<h4 id="定义一个返回this对象的函数"><a href="#定义一个返回this对象的函数" class="headerlink" title="定义一个返回this对象的函数"></a>定义一个返回this对象的函数</h4><p>一般来说,当我们定义的函数类似于某个内置运算符时,应该令该函数的行为尽量模仿这个运算符。内置的赋值运算符把它的左側运算对象当成左值返回,因此为了与它保持一致,combine函数必须返回引用类型。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>每个类都分别定义了它的对象被初始化的方式,类通过一个或几个特殊的成员函数来控制其对象的初始化过程,这些函数叫做构造函数( constructor)。<strong>构造函数的任务是初始化类对象的数据成员,无论何时只要类的对象被创建,就会执行构造函数</strong>。</p>
<p>构造函数的名字和类名相同。和其他函数不一样的是,构造函数没有返回类型;除此之外类似于其他的函数,构造函数也有一个(可能为空的)参数列表和一个(可能为空的)函数体。类可以包含多个构造函数,和其他重载函数差不多,不同的构造函数之间必须在参数数量或参数类型上有所区别。</p>
<p>不同于其他成员函数,构造函数不能被声明成 const的</p>
<h4 id="合成的默认构造函数"><a href="#合成的默认构造函数" class="headerlink" title="合成的默认构造函数"></a>合成的默认构造函数</h4><p>我们没有为这些对象提供初始值,因此我们知道它们执行了默认初始化。<strong>类通过一个特殊的构造函数来控制默认初始化过程,这个函数叫做默认构造函数( default constructor）</strong>默认构造函数无须任何实参。</p>
<p>如我们所见,默认构造函数在很多方面都有其特殊性。其中之一是,<strong>如果我们的类没有显式地定义构造函数,那么编译器就会为我们隐式地定义一个默认构造函数</strong>。编译器创建的构造函数又被称为合成的默认构造函数( synthesized defaultconstructor)。对于大多数类来说,这个合成的默认构造函数将按照如下规则初始化类的数据成员:</p>
<ul>
<li>如果存在类内的初始值,用它来初始化成员</li>
<li>否则,默认初始化该成员。</li>
</ul>
<h4 id="某些类不能依赖于合成的默认构造函数"><a href="#某些类不能依赖于合成的默认构造函数" class="headerlink" title="某些类不能依赖于合成的默认构造函数"></a>某些类不能依赖于合成的默认构造函数</h4><p>对于一个普通的类来说,必须定义它自己的默认构造函数,原因有三:</p>
<p>第一个原因也是最容易理解的一个原因就是编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。</p>
<p>第二个原因是对于某些类来说,<strong>合成的默认构造函数可能执行错误的操作</strong>。回忆我们之前介绍过的,如果定义在块中的内置类型或复合类型(比如数组和指针)的对象被默认初始化,则它们的值将是未定义的。该准则则同样适用于默认初始化的内置类型成员。因此,含有内置类型或复合类型成员的类应该在类的内部初始化这些成员,或者定义一个自己的默认构造函数。否则,用户在创建类的对象时就可能得到未定义的值。</p>
<p>第三个原因是有的时候编译器不能为某些类合成默认的构造函数</p>
<h4 id="default的含义"><a href="#default的含义" class="headerlink" title="=default的含义"></a>=default的含义</h4><p>在C++11标准中，如果我们需要默认行为，那么可以通过在参数列表后面写上<code>=default</code>来要求编译器生成构造函数</p>
<h4 id="构造函数的初始值列表"><a href="#构造函数的初始值列表" class="headerlink" title="构造函数的初始值列表"></a>构造函数的初始值列表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>: <span class="built_in">string</span> &amp;s): bookno(s) &#123; &#125; ;</div><div class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>: <span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p):bookno(s), units_sold(n), revenue(p*n) &#123; &#125; ;</div></pre></td></tr></table></figure>
<p>这两个定义中出现了新的部分,即冒号以及冒号和花括号之间的代码,其中花括号定义了函数体。我们把新出现的部分称为<strong>构造函数初始值列表</strong>( constructor initialize list),它负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表,每个名学后面紧跟括号括起来的(或者在花括号内的)成员初始值。不同成员的初始化通过逗号分隔开来</p>
<h3 id="拷贝、赋值和析构"><a href="#拷贝、赋值和析构" class="headerlink" title="拷贝、赋值和析构"></a>拷贝、赋值和析构</h3><h4 id="某些类不能依赖于合成的版本"><a href="#某些类不能依赖于合成的版本" class="headerlink" title="某些类不能依赖于合成的版本"></a>某些类不能依赖于合成的版本</h4><p>尽管编译器能替我们合成拷贝、赋值和销毁的操作,但是必须要清楚的一点是,对于某些类来说合成的版本无法正常工作。特別是,<strong>当类需要分配类对象之外的资源时,合成的版本常常会失效</strong>。</p>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>定义在public说明符之后的成员在整个程序内可被访问,public成员定义类的接口。</p>
<p>定义在 private说明符之后的成员可以被类的成员函数访问,但是不能被使用该类的代码访问, private部分封装了(即隐藏了)类的实现细节。</p>
<blockquote>
<p>使用class 和struct关键字</p>
</blockquote>
<p>我们可以使用class和struct这两个关键字中的任何一个定义类。唯一的一点区别是, struct和class的默认访问权限不太一样。类可以在它的第一个访问说明符之前定义成员,对这种成员的访问权限依赖于类定义。<strong>如果我们使用 struct关键字,则定义在第一个访问说明符之前的成员是public的</strong>;相反,如果<strong>我们使用class关键字,则这些成员是private的</strong>。</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类可以允许其他类或者函数访问它的非公有成员,方法是令其他类或者函数成为它的友元( friend)。如果类想把一个函数作为它的友元,只需要增加一条以friend关键字开始的函数声明语句即可:</p>
<p>友元的声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类成员也不受它所在区域访问控制级别的约束</p>
<blockquote>
<p>封装有两个重要的优点<br>确保用户代码不会无意间破坏封装对象的状态。<br>被封装的类的具体实现细节可以随时改变,而无须调整用户级别的代码。</p>
</blockquote>
<p>友元的声明仅仅指定了访问的权限,而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数,那么我们就必须在友元声明之外再专门对函数进行一次声明</p>
<h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><h3 id="类成员再探"><a href="#类成员再探" class="headerlink" title="类成员再探"></a>类成员再探</h3><p>除了定义数据和函数成员之外,类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制,可以是public或者private中的一种</p>
<blockquote>
<p>令成员函数作为内联函数</p>
</blockquote>
<p>在类中,常有一些规模较小的函数适合于被声明成内联函数。如我们之前所见的,定义在类内部的成员函数是自动inline的。</p>
<p>我们可以在类的内部把inline作为声明的一部分显式地声明成员函数,同样的,也能在类的外部用inline关键字修饰函数的定义</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_13_1518491517567.jpg" alt="enter description here"></p>
<blockquote>
<p>可变数据成员</p>
</blockquote>
<p>有时(但并不频繁)会发生这样一种情况,我们希望能<strong>修改类的某个数据成员</strong>,即使是在一个 const成员函数内。可以通过在变量的声明中加入 mutable关键字做到这点</p>
<p>一个<strong>可変数据成员</strong>( mutable data member)永远不会是 const,即使它是 const对象的成员。因此,一个 const成员函数可以改变一个可变成员的值。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_13_1518491662122.jpg" alt="enter description here"></p>
<h3 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回*this的成员函数</h3><p>返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本</p>
<blockquote>
<p>基于const的重载</p>
</blockquote>
<p>通过区分成员函数是否是 const的,我们可以对其进行重载,其原因与我们之前根据指针参数是否指向 const而重载函数的原因差不多。具体说</p>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>每个类定义了唯一的类型。对于两个类来说,即使它们的成员完全一样,这两个类也是两个不同的类型。</p>
<blockquote>
<p>类的声明</p>
</blockquote>
<p>就像可以把函数的声明和定义分离开来一样,我们也能仅仅声明类而暂时不定义它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Screen;   // screen类的声明</div></pre></td></tr></table></figure></p>
<p>这种声明有时被称作<strong>前向声明</strong>( forward declaration),它向程序中引入了名字 Screen并且指明 Screen是一种类类型。对于类型 Screen来说,在它声明之后定义之前是一个不完全类型( incomplete type),也就是说,此时我们已知 Screen是一个类型,但是不清楚它到底包含哪些成员。</p>
<p>不完全类型只能在非常有限的情景下使用:可以定义指向这种类型的指针或引用,也可以声明(但是不能定义)以不完全类型作为参数或者返回类型的函数。</p>
<h3 id="友元再探"><a href="#友元再探" class="headerlink" title="友元再探"></a>友元再探</h3><p>类还可以把其他的类定义成友元,也可以把其他类(之前已定义过的)的成员函数定义成友元。此外,友元函数能定义在类的内部,这样的函数是隐式内联的。</p>
<p>如果一个类定义了友元类，则友元类的成员函数可以访问此类包括非公有函数在内的所有成员。</p>
<p><strong>友元不具备传递性</strong></p>
<blockquote>
<p>令成员函数作为友元</p>
</blockquote>
<p>除了令整个Window mgr作为友元之外, Screen还可以只为clear提供访问权限。当把一个成员函数声明成友元时,我们必须明确指出该成员函数属于哪个类:</p>
<blockquote>
<p>函数重载和友元</p>
</blockquote>
<p>尽管重载函数的名字相同,但它们仍然是不同的函数。因此,如果一个类想把一组重载函数声明成它的友元,它需要对这组函数中的每一个分别声明:</p>
<blockquote>
<p>友元声明和作用域</p>
</blockquote>
<p>类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在个友元声明中时,我们隐式地假定该名字在当前作用域中是可见的。</p>
<h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><p>每个类都会定义它自己的作用域。<strong>在类的作用域之外,普通的数据和函数成员只能由对象、引用用或者指针使用成员访问运算符来访问</strong>。对于类类型成员则使用作用域运算符访问。不论哪种情况,跟在运算符之后的名字都必须是对应类的成员</p>
<blockquote>
<p>作用域和定义在类外部的成员</p>
</blockquote>
<p>在类的外部,成员的名字被隐藏起来了。一旦遇到了类名,定义的剩余部分就在类的作用域之内了,这里的剩余部分包括参数列表和函数体。结果就是,我们可以直接使用类的其他成员而无须再次授权了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518603468039.jpg" alt="enter description here"></p>
<p>另一方面,函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时,返回类型中使用的名字都位于类的作用域之外。这时,返回类型必须指明它是哪个类的成员。</p>
<h3 id="名字查找和类的作用域"><a href="#名字查找和类的作用域" class="headerlink" title="名字查找和类的作用域"></a>名字查找和类的作用域</h3><p><strong>名字查找( name lookup)</strong>(寻找与所用名字最匹配的声明的过程)的过程比较直截了当:</p>
<ul>
<li>首先,在名字所在的块中寻找其声明语句,只考虑在名字的使用之前出现的声明。</li>
<li>如果没找到,继续查找外层作用域。</li>
<li>如果最终没有找到匹配的声明,则程序报错。</li>
</ul>
<p>一般来说,内层作用域可以重新定义外层作用域中的名字,即使该名字已经在内层作用域中使用过。然而在类中,如果成员使用了外层作用域中的某个名字,而该名字代表种类型,则类不能在之后重新定义该名字:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518603659447.jpg" alt="enter description here"></p>
<h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><blockquote>
<p>构造函数的初始值有时必不可少</p>
</blockquote>
<p>有时我们可以忽略数据成员初始化和赋值之间的差异,但并非总能这样。<strong>如果成员是const或者是引用的话,必须将其初始化</strong>。类似的,当成员属于某种类类型且该类没有定义默认构造函数时,也必须将这个成员初始化。</p>
<p>一些数据成员必须初始化，建议养成使用构造函数初始化值的习惯</p>
<blockquote>
<p>成员初始化的顺序</p>
</blockquote>
<p>构造函数初始值列表只说明用于初始化成员的值,而不限定初始化的具体执行顺序。</p>
<p><strong>成员的初始化顺序与它们在类定义中的出现顺序一致</strong>:第一个成员先被初始化,然后第二个,以此类推。<strong>构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序</strong>。</p>
<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>C++11新标准扩展了构造函数初始值的功能,使得我们可以定义所谓的<strong>委托构造函数</strong>( delegating constructor)。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程,或者说它把它自自己的一些(或者全部)职责委托给了其他构造函数。</p>
<p>和其他构造函数一样,一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数内,成员初始值列表只有一个唯一的入口,就是类名本身。和其他成员初始值一样,类名后面紧跟圆括号括起来的参数列表,参数列表必须与类中另外一个构造函数匹配。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518610183005.jpg" alt="enter description here"></p>
<h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><p>我们能为类定义隐式转换规则。如果<strong>构造函数只接受一个实参,则它实际上定义了转换为此类类型的隐式转换机制</strong>,有时我们]把这种构造函数称作<strong>转换构造函数</strong></p>
<blockquote>
<p>抑制构造函数定义的隐式转换</p>
</blockquote>
<p>在要求隐式转换的程序上下文中,我们们可以通过将构造函数声明为explicit加以阻止:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518610514067.jpg" alt="enter description here"></p>
<h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p>聚合类( aggregate class)使得用户可以直接访问其成员,并且具有特殊的初始化语法形式。当一个类满足如下条件时,我们说它是聚合的:</p>
<ul>
<li>所有成员都是public的</li>
<li>没有定义任何构造函数。</li>
<li>没有类内初始值</li>
<li>没有基类,也没有 virtual函数,关于这部分知识我们将在第15章详细介绍</li>
</ul>
<h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><p><strong>数据成员都是字面值类型的聚合类</strong>是字面值常量类。如果一个类不是聚合类,但它符合下述要求,则它也是一个字面值常量类</p>
<ul>
<li>数据成员都必须是字面值类型。</li>
<li>类必须至少含有一个 constexpr构造造函数。</li>
<li>如果一个数据成员含有类内初始值,则内置类型成员的初始值必须是一条常量表达式;或者如果成员属于某种类类型,则初始值必须使用成员自己的 constexpr构造函数</li>
<li>类必须使用析构函数的默认定义,该成员负责销毀类的对象</li>
</ul>
<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。</p>
<blockquote>
<p>声明静态成员</p>
</blockquote>
<p>我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员样,静态成员可以是 public的或 private的。静态数据成员的类型可以是常量、引用、指针、类型等</p>
<p>我们使用作用域运算符直接访问静态成员：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> r;</div><div class="line">r = Account::rate();</div></pre></td></tr></table></figure></p>
<blockquote>
<p>定义静态成员</p>
</blockquote>
<p>和其他的成员函数一样,我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时,不能重复 static关键字,该关键字只出现在类内部的声明语句:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Account::rate( <span class="keyword">double</span> newRate)</div><div class="line">&#123;</div><div class="line">	interesRate = newRate;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>我们不能在类的内部初始化静态成员。相反的,必须在类的外部定义和初始化每个静态成员。</p>
<blockquote>
<p>静态成员的类内初始化</p>
</blockquote>
<p>通常情况下・类的静态成员不应该在类的内部初始化。然而,我们可以为静态成员提供 const整数类型的类内初始值,不过要求静态成员必须是字面值常量类型的constexpr</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nginx 配置反向代理]]></title>
      <url>/2018/02/14/Nginx-%E9%85%8D%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<p>近段时间遇到一个问题：有多个服务要放在一个主机上，但是想用域名来区分这些服务而不是端口号（就像IP地址一样，没有人愿意记端口号）。后面找到了Nginx配置反向代理这个解决方案，这里总结一下。</p>
<a id="more"></a>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>一个Web应用的基本通信流程是：客户端（client）发送一个请求（request）给服务器（server），然后服务器根据请求返回相应的响应（response）给客户端。</p>
<p>那么代理的作用就是让一个机器来替我们发送请求或者返回响应，在客户端替我们发送请求的代理称为正向代理；在服务器替我们接受请求返回响应的代理称为反向代理。</p>
<p>正向代理：client —(send request)—&gt; clinet proxy –(send request)—&gt; server<br>反向代理：clinet –(send request)–&gt; server proxy –(send request)–&gt;other server</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518583313864.jpg" alt="正向代理和反向代理示意图"></p>
<h2 id="Nginx-配置反向代理"><a href="#Nginx-配置反向代理" class="headerlink" title="Nginx 配置反向代理"></a>Nginx 配置反向代理</h2><p>使用Nginx配置反向代理需要用到的配置模块有http模块、server模块、location模块、upstream模块</p>
<h3 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h3><p>http模块负责<strong>HTTP服务器相关属性的配置</strong>，它里面有server和upstream子模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">	# include用来设定文件的mime类型,类型在配置文件目录下的mime.type文件定义，来告诉nginx来识别文件类型。</div><div class="line">    include mime.types;</div><div class="line">    </div><div class="line">	# default_type 设定了默认的类型为二进制流，也就是当文件类型未定义时使用这种方式</div><div class="line">	default_type application/octet-stream;</div><div class="line">	</div><div class="line">	# log_format 用于设置日志的格式，和记录哪些参数</div><div class="line">    log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</div><div class="line">                    &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</div><div class="line">                    &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</div><div class="line">					</div><div class="line">	# 纪录每次的访问日志的文件地址，后面的main是日志的格式样式，对应于log_format的main。</div><div class="line">    access_log /usr/local/var/log/nginx/access.log  main;</div><div class="line">	</div><div class="line">	# sendfile开启高效文件传输模式。将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞。</div><div class="line">    sendfile on;</div><div class="line">    tcp_nopush on;</div><div class="line">    tcp_nodelay on;</div><div class="line">	</div><div class="line">	# keepalive设置客户端连接保持活动的超时时间。在超过这个时间之后，服务器会关闭该连接。</div><div class="line">    keepalive_timeout 10;</div><div class="line">    #gzip on;</div><div class="line">    upstream myproject &#123;</div><div class="line">        .....</div><div class="line">    &#125;</div><div class="line">    server &#123;</div><div class="line">        ....</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="server模块"><a href="#server模块" class="headerlink" title="server模块"></a>server模块</h3><p>为http模块的子模块，定义一个虚拟主机。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">	# listen 指定虚拟主机监听的服务端口</div><div class="line">    listen 8080;</div><div class="line">	</div><div class="line">	# server_name 用来指定IP地址或者域名，多个域名之间用空格分开</div><div class="line">    server_name localhost 192.168.12.10 www.yangyi.com;</div><div class="line">    </div><div class="line">	# 全局定义，如果都是这一个目录，这样定义最简单。</div><div class="line">    # root 表示在这整个server虚拟主机内，全部的root web根目录。</div><div class="line">	root   /Users/yangyi/www;</div><div class="line">	# index 全局定义访问的默认首页地址。</div><div class="line">    index  index.php index.html index.htm; </div><div class="line">	# charset 用于设置网页的默认编码格式。</div><div class="line">    charset utf-8;</div><div class="line">	# access_log 用来指定此虚拟主机的访问日志存放路径，最后的main用于指定访问日志的输出格式。</div><div class="line">    access_log  usr/local/var/log/host.access.log  main;</div><div class="line">    error_log  usr/local/var/log/host.error.log  error;</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="upstream模块"><a href="#upstream模块" class="headerlink" title="upstream模块"></a>upstream模块</h3><p>负责负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">upstream iyangyi.com&#123;</div><div class="line">    ip_hash;</div><div class="line">    server 192.168.12.1:80;</div><div class="line">    server 192.168.12.2:80 down;</div><div class="line">    server 192.168.12.3:8080  max_fails=3  fail_timeout=20s;</div><div class="line">    server 192.168.12.4:8080;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>通过upstream指令指定了一个负载均衡器的名称iyangyi.com。这个名称可以任意指定，在后面需要的地方直接调用即可。</li>
<li>ip_hash这是其中的一种负载均衡调度算法，下面会着重介绍。</li>
<li>紧接着就是各种服务器了。用server关键字表识，后面接ip。</li>
</ul>
<p>Nginx负载均衡模块支持的4种调度算法：</p>
<ul>
<li><strong>weight 轮询</strong>（默认）。每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。weight。指定轮询权值，weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。</li>
<li><strong>ip_hash</strong>。每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。</li>
<li><strong>fair（第三方）</strong>。比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。</li>
<li><strong>url_hash（第三方）</strong>。按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx的hash软件包。</li>
</ul>
<h3 id="location模块"><a href="#location模块" class="headerlink" title="location模块"></a>location模块</h3><p>location模块使用来定位URL、解析URL的，指明定位到的URL的功能是什么。提供了强大的正则匹配功能，也支持条件判断匹配，用户可以通过location指令实现Nginx对动、静态网页进行过滤处理。</p>
<p>最简单的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    root   /Users/yangyi/www;</div><div class="line">    index  index.php index.html index.htm;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>location / 表示匹配根目录</li>
<li>root 指令用于指定访问根目录时，虚拟主机的web目录</li>
<li>index 用于设定我们只输入域名后访问的默认首页地址</li>
</ul>
<p>当我们需要进行反向代理的时候，主要配置也是在这里的，其使用的是location模块下的proxy_pass选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">	proxy_pass          https://gist.github.com;</div><div class="line">	proxy_cache_valid   200 302 1h;</div><div class="line">	proxy_cache_valid   404 1m;</div><div class="line">	proxy_cache_use_stale error timeout invalid_header updating</div><div class="line">		http_500 http_502 http_503 http_504;</div><div class="line">	proxy_set_header    Accept-Encoding &quot;&quot;;</div><div class="line">	proxy_set_header    Accept-Language &quot;zh-CN&quot;;</div><div class="line">	proxy_set_header    User-Agent $http_user_agent;</div><div class="line">	sub_filter  https://gist-assets.github.com/ http://gist.example.com;</div><div class="line">	sub_filter  https://gist.github.com/ http://gist.example.com;</div><div class="line">	sub_filter_once     off;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>proxy_pass 指定反向代理的地址</li>
<li>proxy_set_header 设置 HTTP 请求头，Accept-Encoding “” 表示拒绝任何压缩，这保证了服务器返回给反向代理的内容是未经压缩的，以便进行 URL 替换</li>
<li>proxy_set_header 设置 HTTP 请求头，语言设置</li>
<li>proxy_set_header 设置 HTTP 请求头，设置 UA</li>
<li>sub_filter URL 替换</li>
<li>sub_filter_once 被关闭，替换所有可替换的内容</li>
</ul>
<h2 id="反向代理作用"><a href="#反向代理作用" class="headerlink" title="反向代理作用"></a>反向代理作用</h2><ul>
<li>保护了真实的web服务器，web服务器对外不可见，外网只能看到反向代理服务器，而反向代理服务器上并没有真实数据，因此，保证了web服务器的资源安全</li>
<li>负载均衡，最大化服务器集群的效率</li>
<li>请求的统一控制，包括设置权限、过滤规则等；</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>配置本地主机<code>gist.example.com</code>到github的<code>gist.github.com</code>的server模块配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen  80;</div><div class="line">    server_name gist.example.com;</div><div class="line">    access_log  off;</div><div class="line">    resolver    8.8.8.8;</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass          https://gist.github.com;</div><div class="line">        proxy_cache_valid   200 302 1h;</div><div class="line">        proxy_cache_valid   404 1m;</div><div class="line">        proxy_cache_use_stale error timeout invalid_header updating</div><div class="line">            http_500 http_502 http_503 http_504;</div><div class="line">        proxy_set_header    Accept-Encoding &quot;&quot;;</div><div class="line">        proxy_set_header    Accept-Language &quot;zh-CN&quot;;</div><div class="line">        proxy_set_header    User-Agent $http_user_agent;</div><div class="line">        sub_filter  https://gist-assets.github.com/ http://gist.example.com;</div><div class="line">        sub_filter  https://gist.github.com/ http://gist.example.com;</div><div class="line">        sub_filter_once     off;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>井号开头的行是注释</li>
<li>server 开始了 server 块</li>
<li>listen 表明 Nginx 将会在 80 端口监听</li>
<li>server_name 是我们给反向代理配置的域名，访问这个域名就相当于访问 Gist</li>
<li>access_log 是日志文件的配置，这里为了简化我将它关掉了</li>
<li>resolver 是 DNS 服务器</li>
<li>location 块具体配置反向代理的行为</li>
<li>proxy_pass 说明将会将请求转发至 Gist</li>
<li>proxy_cache_valid 配置缓存</li>
<li>proxy_cache_valid 同上</li>
<li>proxy_cache_use_stale 同上</li>
<li>proxy_set_header 设置 HTTP 请求头，Accept-Encoding “” 表示拒绝任何压缩，这保证了服务器返回给反向代理的内容是未经压缩的，以便进行 URL 替换</li>
<li>proxy_set_header 设置 HTTP 请求头，语言设置</li>
<li>proxy_set_header 设置 HTTP 请求头，设置 UA</li>
<li>sub_filter URL 替换</li>
<li>sub_filter 同上</li>
<li>sub_filter_once 被关闭，替换所有可替换的内容</li>
</ul>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://liam0205.me/2015/09/07/reverse-proxy-to-get-access-to-gist/" target="_blank" rel="external">https://liam0205.me/2015/09/07/reverse-proxy-to-get-access-to-gist/</a></li>
<li><a href="https://www.jianshu.com/p/bed000e1830b" target="_blank" rel="external">https://www.jianshu.com/p/bed000e1830b</a></li>
<li><a href="http://blog.csdn.net/physicsdandan/article/details/45667357" target="_blank" rel="external">http://blog.csdn.net/physicsdandan/article/details/45667357</a></li>
<li><a href="https://paste.ubuntu.com/p/jZ8tBwGYcM/" target="_blank" rel="external">nginx配置整理（含注释）</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 代理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git 内部原理]]></title>
      <url>/2018/02/11/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>《Pro Git》读书笔记</p>
<a id="more"></a>
<p>从根本上来讲 Git 是一个内容寻址（content-addressable）文件系统</p>
<h2 id="底层命令和高层命令"><a href="#底层命令和高层命令" class="headerlink" title="底层命令和高层命令"></a>底层命令和高层命令</h2><p>由于 Git 最初是一套面向版本控制系统的工具集，而不是一个完整的、用户友好的版本控制系统，所以它还包含了一部分用于完成底层工作的命令。这些命令被设计成能以 UNIX 命令行的风格连接在一起，抑或藉由脚本调用，来完成工作。这部分命令一般被称作“<strong>底层（plumbing）”命令</strong>，而那些更友好的命令则被称作“高层（porcelain）”命令。</p>
<p>当在一个新目录或已有目录执行 git init 时，Git 会创建一个 .git 目录。这个目录包含了几乎所有 Git 存储和操作的对象。如若想备份或复制一个版本库，只需把这个目录拷贝至另一处即可。</p>
<p>目录结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ ls -F1</div><div class="line">index				# 保存暂存区信息</div><div class="line">HEAD				# 指示目前被检出的分支</div><div class="line">config*				# 包含项目特有的配置项</div><div class="line">description			# 仅供GitWeb使用</div><div class="line">hooks/				# 包含hook钩子脚本</div><div class="line">info/				# 包含全局性排除（global exclude）文件</div><div class="line">objects/			# 存储所有的数据内容</div><div class="line">refs/				# 存储指向数据（分支）的提交对象的指针</div></pre></td></tr></table></figure></p>
<h2 id="Git-对象"><a href="#Git-对象" class="headerlink" title="Git 对象"></a>Git 对象</h2><p>Git 是一个内容寻址文件系统。Git 的核心部分是一个简单的键值对数据库（key-value data store）。你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。</p>
<h3 id="树对象"><a href="#树对象" class="headerlink" title="树对象"></a>树对象</h3><p>树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起。Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。所有内容均以树对象和数据对象的形式存储，其中<strong>树对象对应了 UNIX 中的目录项</strong>，<strong>数据对象则大致上对应了 inodes 或文件内容</strong>。一个树对象包含了一条或多条树对象记录（tree entry），<strong>每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息</strong>。</p>
<p>通常，Git 根据某一时刻暂存区（即 index 区域，下同）所表示的状态创建并记录一个对应的树对象，如此重复便可依次记录（某个时间段内）一系列的树对象。因此，为创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。</p>
<h3 id="提交对象"><a href="#提交对象" class="headerlink" title="提交对象"></a>提交对象</h3><p>提交对象的格式很简单：它先指定一个顶层树对象，代表当前项目快照；然后是作者/提交者信息（依据你的user.name 和 user.email 配置来设定，外加一个时间戳）；留空一行，最后是提交注释</p>
<p>每次我们运行 git add 和 git commit 命令时， Git 所做的实质工作——<strong>将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。</strong>这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 .git/objects 目录下。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_11_1518354037927.jpg" alt="enter description here"></p>
<h3 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h3><p>在存储内容时，会有个头部信息一并被保存。让我们略花些时间来看看 Git 是如何存储其对象的。</p>
<p>所有的 Git 对象均以这种方式存储，区别仅在于类型标识——另两种对象类型的头部信息以字符串“commit”或“tree”开头，而不是“blob”。另外，虽然数据对象的内容几乎可以是任何东西，但提交对象和树对象的内容却有各自固定的格式。</p>
<h2 id="Git-引用"><a href="#Git-引用" class="headerlink" title="Git 引用"></a>Git 引用</h2><p>为了能遍历那段历史从而找到所有相关对象，你仍须记住 1a410e 是最后一个提交。我们需要一个文件来保存 SHA-1 值，并<strong>给文件起一个简单的名字，然后用这个名字指针来替代原始的 SHA-1 值</strong>。在 Git 里，这样的文件被称为“引用（references，或缩写为 refs）”；你可以在 .git/refs 目录下找到这类含有 SHA-1 值的文件。</p>
<p> <strong>Git 分支的本质：一个指向某一系列提交之首的指针或引用</strong>。</p>
<h3 id="HEAD引用"><a href="#HEAD引用" class="headerlink" title="HEAD引用"></a>HEAD引用</h3><p> HEAD 文件是一个符号引用（symbolic reference），指向目前所在的分支。所谓符号引用，意味着它并不像普通引用那样包含一个 SHA-1 值——它是一个<strong>指向其他引用的指针</strong>。</p>
<p>当我们执行 git commit 时，该命令会创建一个提交对象，并用 HEAD 文件中那个引用所指向的 SHA-1 值设置其父提交字段</p>
<h3 id="标签引用"><a href="#标签引用" class="headerlink" title="标签引用"></a>标签引用</h3><p>前文我们刚讨论过 Git 的三种主要对象类型，事实上还有第四种。标签对象（tag object）非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。主要的区别在于，<strong>标签对象通常指向一个提交对象，而不是一个树对象</strong>。它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。</p>
<p>存在两种类型的标签：附注标签和轻量标签。轻量标签的全部内容——一个固定的引用。一个附注标签则更复杂一些。若要创建一个附注标签，Git 会创建一个标签对象，并记录一个引用来指向该标签对象，而不是直接指向提交对象。</p>
<h3 id="远程引用"><a href="#远程引用" class="headerlink" title="远程引用"></a>远程引用</h3><p>第三种引用类型是远程引用（remote reference）。如果你添加了一个远程版本库并对其执行过推送操作，Git 会记录下最近一次推送操作时每一个分支所对应的值，并保存在 refs/remotes 目录下</p>
<p>远程引用和分支（位于 refs/heads 目录下的引用）之间最主要的区别在于，远程引用是只读的。虽然可以git checkout 到某个远程引用，但是 Git 并不会将 HEAD 引用指向该远程引用。</p>
<h2 id="包文件"><a href="#包文件" class="headerlink" title="包文件"></a>包文件</h2><p>Git 最初向磁盘中存储对象时所使用的格式被称为<strong>“松散（loose）”对象格式</strong>。但是，Git 会时不时地<strong>将多个这些对象打包成一个称为“包文件（packfile）</strong>”的二进制文件，以节省空间和提高效率。当版本库中有太多的松散对象，或者你手动执行 git gc 命令，或者你向远程服务器执行推送时，Git 都会这样做。</p>
<p>包文件包含了刚才从文件系统中移除的所有对象的内容。索引文件包含了包文件的偏移信息，我们通过索引文件就可以快速定位任意一个指定对象。</p>
<p>同样有趣的地方在于，最新版本完整保存了文件内容，而原始的版本反而是以差异方式保存的——这是因为大部分情况下需要快速访问文件的最新版本。</p>
<h2 id="引用规格"><a href="#引用规格" class="headerlink" title="引用规格"></a>引用规格</h2><p>我们已经使用过一些诸如远程分支到本地引用的简单映射方式，但这种映射可以更复杂。</p>
<p>添加一个远程版本库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[remote &quot;origin&quot;]</div><div class="line">url = https://github.com/schacon/simplegit-progit</div><div class="line">fetch = +refs/heads/*:refs/remotes/origin/*</div></pre></td></tr></table></figure></p>
<p>引用规格的格式由一个可选的 + 号和紧随其后的 \<src>:\<dst> 组成，其中 \<src> 是一个模式（pattern），代表远程版本库中的引用；\<dst> 是那些远程引用在本地所对应的位置。+ 号告诉 Git 即使在不能快进的情况下也要（强制）更新引用</dst></src></dst></src></p>
<h3 id="引用规格推送"><a href="#引用规格推送" class="headerlink" title="引用规格推送"></a>引用规格推送</h3><p>如果 QA 团队想把他们的 master 分支推送到远程服务器的 qa/master 分支上，可以运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin master:refs/heads/qa/master</div></pre></td></tr></table></figure></p>
<p>如果他们希望 Git 每次运行 git push origin 时都像上面这样推送，可以在他们的配置文件中添加一条 push值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[remote &quot;origin&quot;]</div><div class="line">url = https://github.com/schacon/simplegit-progit</div><div class="line">fetch = +refs/heads/*:refs/remotes/origin/*</div><div class="line">push = refs/heads/master:refs/heads/qa/master</div></pre></td></tr></table></figure></p>
<h3 id="删除引用"><a href="#删除引用" class="headerlink" title="删除引用"></a>删除引用</h3><p>你还可以借助类似下面的命令通过引用规格从远程服务器上删除引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin :topic</div></pre></td></tr></table></figure></p>
<p>因为引用规格（的格式）是 \<src>:\<dst>，所以上述命令把 \<src> 留空，意味着把远程版本库的 topic 分支<br>定义为空值，也就是删除它。</src></dst></src></p>
<h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h2><p>Git 可以通过两种主要的方式在版本库之间传输数据：“哑（dumb）”协议和“智能（smart）”协议。</p>
<h3 id="哑协议"><a href="#哑协议" class="headerlink" title="哑协议"></a>哑协议</h3><p>如果你正在架设一个基于 HTTP 协议的只读版本库，一般而言这种情况下使用的就是哑协议。</p>
<h3 id="智能协议"><a href="#智能协议" class="headerlink" title="智能协议"></a>智能协议</h3><p>智能协议是更常用的传送数据的方法，但它需要在服务端运行一个进程，而这也是 Git 的智能之处——它可以读取本地数据，理解客户端有什么和需要什么，并为它生成合适的包文件。总共有两组进程用于传输数据，它们分别负责上传和下载数据。</p>
<h2 id="维护与数据恢复"><a href="#维护与数据恢复" class="headerlink" title="维护与数据恢复"></a>维护与数据恢复</h2><h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><p>Git 会不定时地自动运行一个叫做 “auto gc” 的命令。大多数时候，这个命令并不会产生效果。然而，如果有太多松散对象（不在包文件中的对象）或者太多包文件，Git 会运行一个完整的 git gc 命令。“gc” 代表垃圾回收，这个命令会做以下事情：收集所有松散对象并将它们放置到包文件中，将多个包文件合并为一个大的包文件，移除与任何提交都不相关的陈旧对象。</p>
<h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>在你使用 Git 的时候，你可能会意外丢失一次提交。通常这是因为你强制删除了正在工作的分支，但是最后却发现你还需要这个分支；亦或者硬重置了一个分支，放弃了你想要的提交。如果这些事情已经发生，该如何找回你的提交呢？</p>
<p>最方便，也是最常用的方法，是使用一个名叫 <code>git reflog</code> 的工具。当你正在工作时，Git 会默默地记录每一次你改变 HEAD 时它的值。每一次你提交或改变分支，引用日志都会被更新。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自定义 Git]]></title>
      <url>/2018/02/10/%E8%87%AA%E5%AE%9A%E4%B9%89-Git/</url>
      <content type="html"><![CDATA[<p>《Pro Git》读书笔记</p>
<a id="more"></a>
<h2 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h2><p>Git使用一系列配置来保存你自定义的行为：</p>
<ul>
<li>它首先会查找 /etc/gitconfig 文件，该文件含有系统里每位用户及他们所拥有的仓库的配置值。如果你传递 –system 选项给 git config，它就会读写该文件</li>
<li>接下来 Git 会查找每个用户的 ~/.gitconfig 文件（或者 ~/.config/git/config 文件）。你可以传递–global 选项让 Git 读写该文件。</li>
<li>最后 Git 会查找你正在操作的版本库所对应的 Git 目录下的配置文件（.git/config）。这个文件中的值只对该版本库有效。</li>
</ul>
<p>以上三个层次中每层的配置（系统、全局、本地）都会覆盖掉上一层次的配置，所以 .git/config 中的值会覆盖掉 /etc/gitconfig 中所对应的值。</p>
<h3 id="客户端基本配置"><a href="#客户端基本配置" class="headerlink" title="客户端基本配置"></a>客户端基本配置</h3><ul>
<li>core.editor</li>
</ul>
<p>默认情况下，Git 会调用环境变量（$VISUAL 或 $EDITOR）设置的任意文本编辑器，如果没有设置，会调用 vi来创建和编辑你的提交以及标签信息。你可以使用 core.editor 选项来修改默认的编辑器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global core.editor emacs</div></pre></td></tr></table></figure></p>
<ul>
<li>commit.tmplate</li>
</ul>
<p>如果把此项指定为你的系统上某个文件的路径，当你提交的时候， Git 会使用该文件的内容作为提交的默认信息。</p>
<ul>
<li>core.pager</li>
</ul>
<p>该配置项指定 Git 运行诸如 log 和 diff 等命令所使用的分页器。你可以把它设置成用 more 或者任何你喜欢的分页器（默认用的是 less），当然也可以设置成空字符串，关闭该选项</p>
<ul>
<li>user.signingkey</li>
</ul>
<p>如果你要创建经签署的含附注的标签（正如 签署工作 所述），那么把你的 GPG 签署密钥设置为配置项会更好。</p>
<ul>
<li>core.excludesfile</li>
</ul>
<p>正如 忽略文件 所述，你可以在你的项目的 .gitignore 文件里面规定无需纳入 Git 管理的文件的模板，这样它们既不会出现在未跟踪列表，也不会在你运行 git add 后被暂存。不过有些时候，你想要在你所有的版本库中忽略掉某一类文件。</p>
<ul>
<li>help.autocorrect</li>
</ul>
<p>Git 会尝试猜测你的意图，但是它不会越俎代庖。如果你把 help.autocorrect 设置成 1，那么只要有一个命令被模糊匹配到了，Git 会自动运行该命令。</p>
<blockquote>
<p>Git 中的着色</p>
</blockquote>
<p>Git 充分支持对终端内容着色，对你凭肉眼简单、快速分析命令输出有很大帮助。你可以设置许多的相关选项来满足自己的偏好。</p>
<ul>
<li>color.ui </li>
</ul>
<p>Git 会自动着色大部分输出内容，但如果你不喜欢花花绿绿，也可以关掉。这个设置的默认值是 auto。</p>
<ul>
<li>color.*</li>
</ul>
<p>要想具体到哪些命令输出需要被着色以及怎样着色，你需要用到和具体命令有关的颜色配置选项。它们都能被置为 true、false 或 always：</p>
<blockquote>
<p>格式化和多余空白字符</p>
</blockquote>
<p>格式化与多余的空白字符是许多开发人员在协作时，特别是在跨平台情况下，不时会遇到的令人头疼的琐碎的问题。由于编辑器的不同或者文件行尾的换行符在 Windows 下被替换了，一些细微的空格变化会不经意地混入提交的补丁或其它协作成果中。不用怕，Git 提供了一些配置项来帮助你解决这些问题。</p>
<ul>
<li>core.autocrlf</li>
</ul>
<p>Git 可以在你提交时自动地把回车和换行转换成换行，而在检出代码时把换行转换成回车和换行。你可以用core.autocrlf 来打开此项功能。如果是在 Windows 系统上，把它设置成 true，这样在检出代码时，换行会被转换成回车和换行：</p>
<p>如果使用以换行作为行结束符的 Linux 或 Mac，你不需要 Git 在检出文件时进行自动的转换；然而当一个以回车加换行作为行结束符的文件不小心被引入时，你肯定想让 Git 修正。你可以把 core.autocrlf 设置成 input 来告诉 Git 在提交时把回车和换行转换成换行，检出时不转换：</p>
<ul>
<li>core.whitespace</li>
</ul>
<p>Git 预先设置了一些选项来探测和修正多余空白字符问题。它提供了六种处理多余空白字符的主要选项 —— 其中三个默认开启，另外三个默认关闭，不过你可以自由地设置它们。</p>
<p>默认被打开的三个选项是：blank-at-eol，查找行尾的空格；blank-at-eof，盯住文件底部的空行；space-before-tab，警惕行头 tab 前面的空格。</p>
<p>默认被关闭的三个选项是：indent-with-non-tab，揪出以空格而非 tab 开头的行（你可以用 tabwidth 选项控制它）；tab-in-indent，监视在行头表示缩进的 tab；cr-at-eol，告诉 Git 忽略行尾的回车。</p>
<h3 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h3><ul>
<li>receive.fsckObjects</li>
</ul>
<p>Git 能够确认每个对象的有效性以及 SHA-1 检验和是否保持一致。但 Git 不会在每次推送时都这么做。设置 receive.fsckObjects 为 true 来强迫它这么做</p>
<ul>
<li>receive.denyNonFastForwards</li>
</ul>
<p>如果你变基已经被推送的提交，继而再推送，又或者推送一个提交到远程分支，而这个远程分支当前指向的提交不在该提交的历史中，这样的推送会被拒绝。这通常是个很好的策略，但有时在变基的过程中，你确信自己需要更新远程分支，可以在 push 命令后加 -f 标志来强制更新（force-update）。</p>
<p>要禁用这样的强制更新推送（force-pushes），可以设置 receive.denyNonFastForwards：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --system receive.denyNonFastForwards true</div></pre></td></tr></table></figure></p>
<ul>
<li>receive.denyDeletes</li>
</ul>
<p>有一些方法可以绕过 denyNonFastForwards 策略。其中一种是先删除某个分支，再连同新的引用一起推送回该分支。把 receive.denyDeletes 设置为 true 可以把这个漏洞补上：</p>
<h2 id="Git-属性"><a href="#Git-属性" class="headerlink" title="Git 属性"></a>Git 属性</h2><p>你也可以针对特定的路径配置某些设置项，这样 Git 就只对特定的子目录或子文件集运用它们。这些基于路径的设置项被称为 Git 属性，可以在你的目录下的 .gitattributes 文件内进行设置（通常是你的项目的根目录）。如果不想让这些属性文件与其它文件一同提交，你也可以在 .git/info/attributes 文件中进行设置。</p>
<p>通过使用属性，你可以对项目中的文件或目录单独定义不同的合并策略，让 Git 知道怎样比较非文本文件，或者让 Git 在提交或检出前过滤内容。</p>
<h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><p>你可以用 Git 属性让 Git 知道哪些是二进制文件（以防它没有识别出来），并指示其如何处理这些文件。</p>
<blockquote>
<p>识别二进制文件</p>
</blockquote>
<p>要让 Git 把所有 pbxproj 文件当成二进制文件，在 .gitattributes 文件中如下设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*.pbxproj binary</div></pre></td></tr></table></figure></p>
<p>现在，Git 不会尝试转换或修正回车换行（CRLF）问题，当你在项目中运行 git show 或 git diff 时，Git 也不会比较或打印该文件的变化</p>
<blockquote>
<p>比较二进制文件</p>
</blockquote>
<p>可以使用 Git 属性来有效地比较两个二进制文件。秘诀在于，告诉 Git 怎么把你的二进制文件转化为文本格式，从而能够使用普通的 diff 方式进行对比。</p>
<p>把下面这行文本加到你的 .gitattributes 文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*.docx diff=word</div></pre></td></tr></table></figure></p>
<p>这告诉 Git 当你尝试查看包含变更的比较结果时，所有匹配 .docx 模式的文件都应该使用“word”过滤器。“word”过滤器是什么？我们现在就来设置它。我们会对 Git 进行配置，令其能够借助 docx2txt 程序将Word 文档转为可读文本文件，这样不同的文件间就能够正确比较了。</p>
<h3 id="关键字展开"><a href="#关键字展开" class="headerlink" title="关键字展开"></a>关键字展开</h3><p>Git 属性提供了另一种方法：我们可以编写自己的过滤器来实现文件提交或检出时的关键字替换。</p>
<h3 id="导出版本库"><a href="#导出版本库" class="headerlink" title="导出版本库"></a>导出版本库</h3><p>当归档的时候，可以设置 Git 不导出某些文件和目录。如果你不想在归档中包含某个子目录或文件，但想把它们纳入项目的版本管理中，你可以在 export-ignore 属性中指定它们。</p>
<p>例如，假设你在 test/ 子目录下有一些测试文件，不希望它们被包含在项目导出的压缩包（tarball）中。你可以增加下面这行到 Git 属性文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test/ export-ignore</div></pre></td></tr></table></figure>
<h3 id="合并策略"><a href="#合并策略" class="headerlink" title="合并策略"></a>合并策略</h3><p>你还能对项目中的特定文件指定不同的合并策略。一个非常有用的选项就是，告诉 Git 当特定文件发生冲突时不要尝试合并它们，而是直接使用你这边的内容</p>
<h2 id="Git-钩子"><a href="#Git-钩子" class="headerlink" title="Git 钩子"></a>Git 钩子</h2><p>Git 能在<strong>特定的重要动作发生时触发自定义脚本</strong>。有两组这样的钩子：客户端的和服务器端的。客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。</p>
<h3 id="安装一个钩子"><a href="#安装一个钩子" class="headerlink" title="安装一个钩子"></a>安装一个钩子</h3><p>钩子都被存储在 Git 目录下的 hooks 子目录中。也即绝大部分项目中的 .git/hooks 。当你用 git init 初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。这些脚本除了本身可以被调用外，它们还透露了被触发时所传入的参数。所有的示例都是 shell 脚本，其中一些还混杂了 Perl 代码，不过，<strong>任何正确命名的可执行脚本都可以正常使用</strong> —— 你可以用 Ruby 或 Python，或其它语言编写它们。这些示例的名字都是以.sample 结尾，如果你想启用它们，得先移除这个后缀</p>
<p>把一个正确命名且可执行的文件放入 Git 目录下的 hooks 子目录中，即可激活该钩子脚本。</p>
<h3 id="客户端钩子"><a href="#客户端钩子" class="headerlink" title="客户端钩子"></a>客户端钩子</h3><p>克隆某个版本库时，它的客户端钩子 并不 随同复制。如果需要靠这些脚本来强制维持某种策略，建议你在服务器端实现这一功能。</p>
<h4 id="提交工作流钩子"><a href="#提交工作流钩子" class="headerlink" title="提交工作流钩子"></a>提交工作流钩子</h4><p><code>pre-commit</code> 钩子在<strong>键入提交信息前运行</strong>。它用于检查即将提交的快照，例如，检查是否有所遗漏，确保测试运行，以及核查代码。如果该钩子以非零值退出，Git 将放弃此次提交，不过你可以用 git commit –no-verify 来绕过这个环节。你可以利用该钩子，来检查代码风格是否一致（运行类似 lint 的程序）、尾随空白字符是否存在（自带的钩子就是这么做的），或新方法的文档是否适当。</p>
<p><code>prepare-commit-msg</code>钩子在<strong>启动提交信息编辑器之前，默认信息被创建之后运行</strong>。它允许你编辑提交者所看到的默认信息。该钩子接收一些选项：存有当前提交信息的文件的路径、提交类型和修补提交的提交的 SHA-1校验。它对一般的提交来说并没有什么用；然而对那些会自动产生默认信息的提交，如提交信息模板、合并提交、压缩提交和修订提交等非常实用。你可以结合提交模板来使用它，动态地插入信息。</p>
<p><code>commit-msg</code> 钩子接收一个参数，此参数即上文提到的，存有当前提交信息的临时文件的路径。如果该钩子脚本以非零值退出，Git 将放弃提交，因此，可以用来在提交通过前验证项目状态或提交信息。在本章的最后一节，我们将展示如何使用该钩子来核对提交信息是否遵循指定的模板。</p>
<p><code>post-commit</code> 钩子在<strong>整个提交过程完成后运行</strong>。它不接收任何参数，但你可以很容易地通过运行 git log -1HEAD 来获得最后一次的提交信息。该钩子一般用于通知之类的事情。</p>
<h4 id="电子邮件工作流钩子"><a href="#电子邮件工作流钩子" class="headerlink" title="电子邮件工作流钩子"></a>电子邮件工作流钩子</h4><p>可以给电子邮件工作流设置三个客户端钩子。它们都是由 git am 命令调用的</p>
<p>第一个运行的钩子是 <code>applypatch-msg</code> 。它接收单个参数：包含请求合并信息的临时文件的名字。如果脚本返回非零值，Git 将放弃该补丁。你可以用该脚本来确保提交信息符合格式，或直接用脚本修正格式错误。</p>
<p>下一个在 git am 运行期间被调用的是 <code>pre-applypatch</code> 。有些难以理解的是，它正好运行于应用补丁 之后，产生提交之前，所以你可以用它在提交前检查快照。你可以用这个脚本运行测试或检查工作区。如果有什么遗漏，或测试未能通过，脚本会以非零值退出，中断 git am 的运行，这样补丁就不会被提交。</p>
<p><code>post-applypatch</code> 运行于提交产生之后，是在 git am 运行期间最后被调用的钩子。你可以用它把结果通知给一个小组或所拉取的补丁的作者。但你没办法用它停止打补丁的过程。</p>
<h4 id="其他钩子"><a href="#其他钩子" class="headerlink" title="其他钩子"></a>其他钩子</h4><p><code>pre-rebase</code> 钩子运行于变基之前，以非零值退出可以中止变基的过程。你可以使用这个钩子来禁止对已经推送的提交变基。Git 自带的 pre-rebase 钩子示例就是这么做的，</p>
<p><code>post-rewrite</code> 钩子被那些会<strong>替换提交记录的命令调用</strong>，比如 git commit –amend 和 git rebase（不过不包括 git filter-branch）。它唯一的参数是触发重写的命令名，同时从标准输入中接受一系列重写的提交记录。这个钩子的用途很大程度上跟 post-checkout 和 post-merge 差不多。</p>
<p>在 git checkout 成功运行后，<code>post-checkout</code> 钩子会被调用。你可以根据你的项目环境用它调整你的工作目录。其中包括放入大的二进制文件、自动生成文档或进行其他类似这样的操作。</p>
<p>在 git merge 成功运行后，<code>post-merge</code> 钩子会被调用。你可以用它恢复 Git 无法跟踪的工作区数据，比如权限数据。这个钩子也可以用来验证某些在 Git 控制之外的文件是否存在，这样你就能在工作区改变时，把这些文件复制进来。</p>
<p><code>pre-push</code> 钩子会在 git push 运行期间， 更新了远程引用但尚未传送对象时被调用。它接受远程分支的名字和位置作为参数，同时从标准输入中读取一系列待更新的引用。你可以在推送开始之前，用它验证对引用的更新操作（一个非零的退出码将终止推送过程）。</p>
<p>Git 的一些日常操作在运行时，偶尔会调用 git gc –auto 进行垃圾回收。<code>pre-auto-gc</code> 钩子会在垃圾回收开始之前被调用，可以用它来提醒你现在要回收垃圾了，或者依情形判断是否要中断回收。</p>
<h3 id="服务端钩子"><a href="#服务端钩子" class="headerlink" title="服务端钩子"></a>服务端钩子</h3><ul>
<li>pre-receive</li>
</ul>
<p>处理来自客户端的推送操作时，最先被调用的脚本是 pre-receive。它从标准输入获取一系列被推送的引用。如果它以非零值退出，所有的推送内容都不会被接受。你可以用这个钩子阻止对引用进行非快进（non-fastforward）的更新，或者对该推送所修改的所有引用和文件进行访问控制。</p>
<ul>
<li>update</li>
</ul>
<p>update 脚本和 pre-receive 脚本十分类似，不同之处在于它会为每一个准备更新的分支各运行一次。假如推送者同时向多个分支推送内容，pre-receive 只运行一次，相比之下 update 则会为每一个被推送的分支各运行一次。</p>
<ul>
<li>post-receive</li>
</ul>
<p>post-receive 挂钩在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。它接受与 prereceive 相同的标准输入数据。它的用途包括给某个邮件列表发信，通知持续集成（continous integration）的服务器，或者更新问题追踪系统（ticket-tracking system） —— 甚至可以通过分析提交信息来决定某个问题（ticket）是否应该被开启，修改或者关闭。该脚本无法终止推送进程，不过客户端在它结束运行之前将保持连接状态，所以如果你想做其他操作需谨慎使用它，因为它将耗费你很长的一段时间。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git 工具]]></title>
      <url>/2018/02/08/Git-%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<p>《Pro Git》读书笔记</p>
<a id="more"></a>
<h2 id="选择修改版本"><a href="#选择修改版本" class="headerlink" title="选择修改版本"></a>选择修改版本</h2><p>Git 允许你通过几种方法来指明特定的或者一定范围内的提交。</p>
<h3 id="单个修订版本"><a href="#单个修订版本" class="headerlink" title="单个修订版本"></a>单个修订版本</h3><p>Git 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交，当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义</p>
<blockquote>
<p>分支引用</p>
</blockquote>
<p>指明一次提交最直接的方法是有一个指向它的分支引用。这样你就可以在任意一个 Git 命令中使用这个分支名来代替对应的提交对象或者 SHA-1 值。</p>
<blockquote>
<p>引用日志</p>
</blockquote>
<p>当你在工作时， Git 会在后台保存一个引用日志(reflog)，引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史。</p>
<p>你可以使用 git reflog 来查看引用日志</p>
<p>详情可以查看<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%80%89%E6%8B%A9%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC" target="_blank" rel="external">这里</a></p>
<blockquote>
<p>祖先引用</p>
</blockquote>
<p>祖先引用是另一种指明一个提交的方式。如果你在引用的尾部加上一个 ^， Git 会将其解析为该引用的上一个提交。</p>
<p>另一种指明祖先提交的方法是 ~。同样是指向第一父提交，因此 HEAD~ 和 HEAD^ 是等价的</p>
<h3 id="提交区间"><a href="#提交区间" class="headerlink" title="提交区间"></a>提交区间</h3><p>最常用的指明提交区间语法是<strong>双点</strong>。这种语法可以让 Git 选出在一个分支中而不在另一个分支中的提交。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_7_1518003024258.jpg" alt="enter description here"></p>
<p>你想要查看 experiment 分支中还有哪些提交尚未被合并入 master 分支。你可以使用 master..experiment来让 Git 显示这些提交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log master..experiment</div></pre></td></tr></table></figure></p>
<p>双点语法很好用，但有时候你可能需要两个以上的分支才能确定你所需要的修订，比如查看哪些提交是被包含在某些分支中的一个，但是不在你当前的分支上。你想查所有被refA 或 refB 包含的但是不被 refC 包含的提交，你可以输入下面中的任意一个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git log refA refB ^refC</div><div class="line">$ git log refA refB --not refC</div></pre></td></tr></table></figure></p>
<h2 id="交互式暂存"><a href="#交互式暂存" class="headerlink" title="交互式暂存"></a>交互式暂存</h2><p>本节的几个互交命令可以帮助你将文件的特定部分组合成提交。当你修改一组文件后，希望这些改动能放到若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。</p>
<p>通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。如果运行 git add 时使用 -i 或者 –interactive 选项，Git 将会进入一个交互式终端模式</p>
<h2 id="储藏与清理"><a href="#储藏与清理" class="headerlink" title="储藏与清理"></a>储藏与清理</h2><p>有时，当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态，而这时你想要切换到另一个分支做一点别的事情。问题是，你不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交。针对这个问题的答案是 git stash 命令。</p>
<h3 id="储藏工作"><a href="#储藏工作" class="headerlink" title="储藏工作"></a>储藏工作</h3><ul>
<li>将新的储藏推送栈上：<code>git stash</code> 或者<code>git stash save</code></li>
<li>查看栈上的储藏：<code>git stash list</code></li>
<li>将栈顶的储藏应用：<code>git stash apply</code></li>
<li>丢弃指定储藏 <code>git stash drop {name}</code></li>
<li>应用栈顶储藏并弹出 <code>git stash pop</code></li>
</ul>
<h3 id="创造性储藏"><a href="#创造性储藏" class="headerlink" title="创造性储藏"></a>创造性储藏</h3><p>有几个储藏的变种可能也很有用。第一个非常流行的选项是 <code>stash save</code>命令的 <code>--keep-index</code> 选项。它告诉Git 不要储藏任何你通过 git add 命令已暂存的东西。</p>
<p>另一个经常使用储藏来做的事情是像储藏跟踪文件一样储藏未跟踪文件。默认情况下，git stash 只会储藏已经在索引中的文件。如果指定 <code>--include-untracked</code> 或 -u 标记，Git 也会储藏任何创建的未跟踪文件。</p>
<h3 id="从储藏创建一个分支"><a href="#从储藏创建一个分支" class="headerlink" title="从储藏创建一个分支"></a>从储藏创建一个分支</h3><p>如果储藏了一些工作，将它留在那儿了一会儿，然后继续在储藏的分支上工作，在重新应用工作时可能会有问题。如果应用尝试修改刚刚修改的文件，你会得到一个合并冲突并不得不解决它。如果想要一个轻松的方式来再次测试储藏的改动，可以运行 <code>git stash branch</code> 创建一个新分支，检出储藏工作时所在的提交，重新在那应用工作，然后在应用成功后扔掉储藏</p>
<h3 id="清理工作目录"><a href="#清理工作目录" class="headerlink" title="清理工作目录"></a>清理工作目录</h3><p>对于工作目录中一些工作或文件，你想做的也许不是储藏而是移除。git clean 命令会帮你做这些事</p>
<h2 id="签署工作"><a href="#签署工作" class="headerlink" title="签署工作"></a>签署工作</h2><p>Git 虽然是密码级安全的，但它不是万无一失的。如果你从因特网上的其他人那里拿取工作，并且想要验证提交是不是真正地来自于可信来源，Git 提供了几种通过 GPG 来签署和验证工作的方式。</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>无论仓库里的代码量有多少，你经常需要查找一个函数是在哪里调用或者定义的，或者一个方法的变更历史。Git 提供了两个有用的工具来快速地从它的数据库中浏览代码和提交。</p>
<h3 id="Git-Grep"><a href="#Git-Grep" class="headerlink" title="Git Grep"></a>Git Grep</h3><p>Git 提供了一个 grep 命令，你可以很方便地从提交历史或者工作目录中查找一个字符串或者正则表达式。</p>
<p>默认情况下 Git 会查找你工作目录的文件。你可以传入 -n 参数来输出 Git 所找到的匹配行行号。你可以使用 –count 选项来使 Git 输出概述的信息，仅仅包括哪些文件包含匹配以及每个文件包含了多少个匹配。如果你想看匹配的行是属于哪一个方法或者函数，你可以传入 -p 选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ git grep -n gmtime_r</div><div class="line">compat/gmtime.c:3:#undef gmtime_r</div><div class="line">compat/gmtime.c:8: return git_gmtime_r(timep, &amp;result);</div><div class="line">compat/gmtime.c:11:struct tm *git_gmtime_r(const time_t *timep, struct tm</div><div class="line">*result)</div><div class="line">compat/gmtime.c:16: ret = gmtime_r(timep, result);</div><div class="line">compat/mingw.c:606:struct tm *gmtime_r(const time_t *timep, struct tm</div><div class="line">*result)</div><div class="line">compat/mingw.h:162:struct tm *gmtime_r(const time_t *timep, struct tm</div><div class="line">*result);</div><div class="line">date.c:429: if (gmtime_r(&amp;now, &amp;now_tm))</div><div class="line">date.c:492: if (gmtime_r(&amp;time, tm)) &#123;</div><div class="line">    git-compat-util.h:721:struct tm *git_gmtime_r(const time_t *, struct tm</div><div class="line">    *);</div><div class="line">    git-compat-util.h:723:#define gmtime_r git_gmtime_r</div></pre></td></tr></table></figure>
<h3 id="Git-日志搜索"><a href="#Git-日志搜索" class="headerlink" title="Git 日志搜索"></a>Git 日志搜索</h3><p>或许你不想知道某一项在 哪里 ，而是想知道是什么 时候 存在或者引入的。git log 命令有许多强大的工具可以通过提交信息甚至是 diff 的内容来找到某个特定的提交。</p>
<p>例如，如果我们想找到 ZLIB_BUF_MAX 常量是什么时候引入的，我们可以使用 -S 选项来显示新增和删除该字符串的提交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git log -SZLIB_BUF_MAX --oneline</div><div class="line">e01503b zlib: allow feeding more than 4GB in one go</div><div class="line">ef49a7a zlib: zlib can only process 4GB at a time</div></pre></td></tr></table></figure></p>
<h2 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重写历史</h2><p>许多时候，在使用 Git 时，可能会因为某些原因想要修正提交历史。Git 很棒的一点是它允许你在最后时刻做决定。你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 stash 命令来决定不与某些内容工作，也可以重写已经发生的提交就像它们以另一种方式发生的一样。</p>
<h3 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h3><p>修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。对于你的最近一次提交，你往往想做两件事情：修改提交信息，或者修改你添加、修改和移除的文件的快照。</p>
<p>如果，你只是想修改最近一次提交的提交信息，那么很简单：<code>git commit --amend</code></p>
<h3 id="修改多个提交信息"><a href="#修改多个提交信息" class="headerlink" title="修改多个提交信息"></a>修改多个提交信息</h3><p>Git 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 HEAD 而不是将其移动到另一个新的上面。可以通过给 git rebase 增加 -i选项来交互式地运行变基。<code>git rebase -i HEAD~3</code></p>
<blockquote>
<p>重新排序提交</p>
</blockquote>
<p>修改交互式变基中的各个提交的顺序即可</p>
<blockquote>
<p>压缩提交</p>
</blockquote>
<p>通过交互式变基工具，也可以将一连串提交压缩成一个单独的提交。在变基信息中脚本给出了有用的指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Commands:</div><div class="line"># p, pick = use commit</div><div class="line"># r, reword = use commit, but edit the commit message</div><div class="line"># e, edit = use commit, but stop for amending</div><div class="line"># s, squash = use commit, but meld into previous commit</div><div class="line"># f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</div><div class="line"># x, exec = run command (the rest of the line) using shell</div></pre></td></tr></table></figure></p>
<h3 id="核武器级选项：filter-branch"><a href="#核武器级选项：filter-branch" class="headerlink" title="核武器级选项：filter-branch"></a>核武器级选项：filter-branch</h3><p>有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它 - 例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。这个命令是 filter-branch，它可以改写历史中大量的提交，<strong>除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，你不应当使用它</strong>。</p>
<blockquote>
<p>从每一个提交移除一个文件</p>
</blockquote>
<p>这经常发生。有人粗心地通过 git add . 提交了一个巨大的二进制文件，你想要从所有地方删除它。然而你想要开源项目。filter-branch 是一个可能会用来擦洗整个提交历史的工具。为了从整个提交历史中移除一个叫做 passwords.txt 的文件，可以使用 –tree-filter 选项给filter-branch：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git filter-branch --tree-filter &apos;rm -f passwords.txt&apos; HEAD</div></pre></td></tr></table></figure></p>
<p><code>--tree-filter</code> 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。</p>
<blockquote>
<p>使一个子目录做为新的根目录</p>
</blockquote>
<p>假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（trunk、tags 等等）。如果想要让trunk 子目录作为每一个提交的新的项目根目录，filter-branch 也可以帮助你那么做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git filter-branch --subdirectory-filter trunk HEAD</div></pre></td></tr></table></figure></p>
<h2 id="重置揭秘"><a href="#重置揭秘" class="headerlink" title="重置揭秘"></a>重置揭秘</h2><p>这里将讨论reset与checkout</p>
<h3 id="三棵树"><a href="#三棵树" class="headerlink" title="三棵树"></a>三棵树</h3><p>理解 reset 和 checkout 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。“树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构</p>
<p>Git 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：<br>| 树 | 用途 |<br>| – | – |<br>| HEAD | 上一次提交的快照，下一次提交的父结点|<br>| Index| 预期的下一次提交的快照|<br>|Working Directory| 沙盒|</p>
<blockquote>
<p>HEAD</p>
</blockquote>
<p>HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。这表示 HEAD 将是下一次提交的父结点。通常，理解 HEAD 的最简方式，就是将它看做 <strong>你的上一次提交</strong> 的快照。</p>
<blockquote>
<p>Index</p>
</blockquote>
<p>索引是你的 <strong>预期的下一次提交</strong>。我们也会将这个概念引用为 Git 的 “暂存区域”，这就是当你运行 git commit 时 Git 看起来的样子。</p>
<blockquote>
<p>工作流程</p>
</blockquote>
<p>参考<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86" target="_blank" rel="external">这里</a></p>
<h3 id="重置的作用（reset）"><a href="#重置的作用（reset）" class="headerlink" title="重置的作用（reset）"></a>重置的作用（reset）</h3><ul>
<li>第一步：移动HEAD</li>
<li>第二步：更新索引（–mixed）</li>
<li>第三步：更新工作目录（–hard）</li>
</ul>
<p>reset 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：</p>
<ol>
<li>移动 HEAD 分支的指向 （若指定了 –soft，则到此停止）</li>
<li>使索引看起来像 HEAD   （默认执行到这一步）</li>
<li>使工作目录看起来像索引  （指定了 –hard ，才执行这一步）</li>
</ol>
<blockquote>
<p>通过路径来重置</p>
</blockquote>
<p>若指定了一个路径，reset 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。</p>
<blockquote>
<p>压缩</p>
</blockquote>
<p>我们来看看如何利用这种新的功能来做一些有趣的事情 - 压缩提交</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git reset --soft HEAD~2</div><div class="line"> git commit</div></pre></td></tr></table></figure>
<h3 id="检出（checkout）"><a href="#检出（checkout）" class="headerlink" title="检出（checkout）"></a>检出（checkout）</h3><pre><code>运行 `git checkout [branch] `与运行` git reset --hard [branch] `非常相似，它会更新所有三棵树使其看起来像 \[branch\]，不过有两点重要的区别。

 首先不同于 reset --hard，checkout 对工作目录是安全的，它会通过检查来确保不会将已更改的文件吹走。其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有_还未修改过的_文件都会被更新。而 reset --hard 则会不做检查就全面地替换所有东西。

 第二个重要的区别是如何更新 HEAD。reset 会移动 HEAD 分支的指向，而 checkout 只会移动 HEAD 自身来指向另一个分支。

 &gt; 带路径情况

 运行 checkout 的另一种方式就是指定一个文件路径，这会像 reset 一样不会移动 HEAD。它就像是 `git reset --hard [branch] file`（如果 reset 允许你这样运行的话）- 这样对工作目录并不安全，它也不会移动 HEAD。
</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_7_1518007500384.jpg" alt="enter description here"></p>
<h2 id="高级合并"><a href="#高级合并" class="headerlink" title="高级合并"></a>高级合并</h2><p>Git 并不会尝试过于聪明的合并冲突解决方案。Git的哲学是聪明地决定无歧义的合并方案，但是如果有冲突，它不会尝试智能地自动解决它。</p>
<h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><p>首先，在做一次可能有冲突的合并前尽可能保证工作目录是干净的。</p>
<p>在遇到冲突的时候，你可以有以下几种解决方案：</p>
<blockquote>
<p>中断一次合并</p>
</blockquote>
<p>你可能不想处理冲突这种情况，完全可以通过 <code>git merge --abort</code> 来简单地退出合并。他会会尝试恢复到你运行合并前的状态。但当运行命令前，在工作目录中有未储藏、未提交的修改时它不能完美处理，除此之外它都工作地很好。</p>
<blockquote>
<p>忽略空白</p>
</blockquote>
<p>如果你看到在一次合并中有大量的空白问题，你可以简单地中止它并重做一次，这次使用<code>-Xignore-all-space</code>或 <code>-Xignore-space-change</code>选项。第一个选项忽略任意 数量 的已有空白的修改，第二个选项忽略所有空白修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge -Xignore-space-change whitespace</div></pre></td></tr></table></figure></p>
<blockquote>
<p>手动文件再合并</p>
</blockquote>
<p>首先，我们进入到了合并冲突状态。然后我们想要我的版本的文件，他们的版本的文件（从我们将要合并入的分支）和共同的版本的文件（从分支叉开时的位置）的拷贝。</p>
<p>然后我们想要修复任何一边的文件，并且为这个单独的文件重试一次合并。获得这三个文件版本实际上相当容易。Git 在索引中存储了所有这些版本，在 “stages” 下每一个都有一个数字与它们关联。Stage 1 是它们共同的祖先版本，stage 2 是你的版本，stage 3 来自于 MERGE_HEAD，即你将要合并入的版本（“theirs”）</p>
<p>如果你想要在最终提交前看一下我们这边与另一边之间实际的修改，你可以使用 <code>git diff</code></p>
<p>要在合并前比较结果与在你的分支上的内容，换一句话说，看看合并引入了什么，可以运行 <code>git diff --ours</code> ； 如果我们想要查看合并的结果与他们那边有什么不同，可以运行 <code>git diff --theirs</code></p>
<h3 id="子树合并"><a href="#子树合并" class="headerlink" title="子树合并"></a>子树合并</h3><p>子树合并的思想是你有两个项目，并且其中一个映射到另一个项目的一个子目录，或者反过来也行。</p>
<p>我们希望将 Rack 项目拉到 master 项目中作为一个子目录。我们可以在 Git 中执行 <code>git read-tree</code> 来实现。它会读取一个分支的根目录树到当前的暂存区和工作目录里。先切回你的 master 分支，将 rack_back 分支拉取到我们项目的 master 分支中的 rack 子目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git read-tree --prefix=rack/ -u rack_branch</div></pre></td></tr></table></figure></p>
<p>当 Rack 项目有更新时，我们可以切换到那个分支来拉取上游的变更。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout rack_branch</div><div class="line">git pull</div></pre></td></tr></table></figure></p>
<p>接着，我们可以将这些变更合并回我们的 master 分支。使用 –squash 选项和使用 -Xsubtree 选项（它采用递归合并策略），都可以用来可以拉取变更并且预填充提交信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line">git merge --squash -s recursive -Xsubtree=rack rack_branch</div></pre></td></tr></table></figure></p>
<h2 id="Rerere"><a href="#Rerere" class="headerlink" title="Rerere"></a>Rerere</h2><p>git rerere 功能是一个隐藏的功能。正如它的名字 “reuse recorded resolution” 所指，它允许你<strong>让 Git 记住解决一个块冲突的方法，这样在下一次看到相同冲突时，Git 可以为你自动地解决它</strong>。</p>
<p>有几种情形下这个功能会非常有用。在文档中提到的一个例子是如果你想要保证一个长期分支会干净地合并，但是又不想要一串中间的合并提交。将 rerere 功能打开后偶尔合并，解决冲突，然后返回到合并前。如果你持续这样做，那么最终的合并会很容易，因为 rerere 可以为你自动做所有的事情。</p>
<p>可以将同样的策略用在维持一个变基的分支时，这样就不用每次解决同样的变基冲突了。或者你将一个分支合并并修复了一堆冲突后想要用变基来替代合并 - 你可能并不想要再次解决相同的冲突。</p>
<p>另一个情形是当你偶尔将一堆正在改进的特性分支合并到一个可测试的头时，就像 Git 项目自身经常做的。如果测试失败，你可以倒回合并之前然后在去除导致测试失败的那个特性分支后重做合并，而不用再次重新解决所有的冲突。</p>
<p>启用rerere功能的方法：</p>
<ol>
<li><code>git config --global rerere.enabled true</code></li>
<li>在特定的仓库中创建<code>.git/rr-cache</code>目录</li>
</ol>
<p>更多使用方法可以查看<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-Rerere" target="_blank" rel="external">这里</a></p>
<h2 id="Git-调试"><a href="#Git-调试" class="headerlink" title="Git 调试"></a>Git 调试</h2><p>Git 提供两个工具来辅助你调试项目中的问题</p>
<h3 id="文件标注"><a href="#文件标注" class="headerlink" title="文件标注"></a>文件标注</h3><p><strong>如果你在追踪代码中的一个 bug，并且想知道是什么时候以及为何会引入，文件标注通常是最好用的工具。它</strong>展示了文件中每一行最后一次修改的提交。所以，如果你在代码中看到一个有问题的方法，你可以使用 gitblame 标注这个文件，查看这个方法每一行的最后修改时间以及是被谁修改的。这个例子使用 -L 选项来限制输出范围在第12至22行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git blame -L 12,22 simplegit.rb</div></pre></td></tr></table></figure>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>当你知道问题是在哪里引入的情况下文件标注可以帮助你查找问题。如果你不知道哪里出了问题，并且自从上次可以正常运行到现在已经有数十个或者上百个提交，这个时候你可以使用 git bisect 来帮助查找。bisect命令会<strong>对你的提交历史进行二分查找来帮助你尽快找到是哪一个提交引入了问题</strong>。</p>
<p>首先执行 <code>git bisect start</code> 来启动，接着执行<code>git bisect bad</code>来告诉系统当前你所在的提交是有问题的。然后你必须告诉 bisect 已知的最后一次正常状态是哪次提交，使用<code>git bisect good [good_commit]</code></p>
<p>在测试过程中可以通过 <code>git bisect good</code> 来告诉 Git 当前的提交没有问题，通过<code>git bisect bad</code>来告诉Git当前的提交有问题</p>
<h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><p>子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。</p>
<h3 id="开始使用子模块"><a href="#开始使用子模块" class="headerlink" title="开始使用子模块"></a>开始使用子模块</h3><p>你可以通过在 git submodule add 命令后面加上想要跟踪的项目 URL 来添加新的子模块。在本例中，我们将会添加一个名为 “DbConnector” 的库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git submodule add https://github.com/chaconinc/DbConnector</div></pre></td></tr></table></figure></p>
<p>Git首先会生成新的 <code>.gitmodules</code>文件。该置文件保存了项目 URL 与已经拉取的本地目录之间的映射。如果有多个子模块，该文件中就会有多条记录。要重点注意的是，该文件也像 .gitignore 文件一样受到（通过）版本控制。它会和该项目的其他部分一同被拉取推送。</p>
<h3 id="克隆含有子模块的项目"><a href="#克隆含有子模块的项目" class="headerlink" title="克隆含有子模块的项目"></a>克隆含有子模块的项目</h3><p>你必须运行两个命令：<code>git submodule init</code>用来初始化本地配置文件，而 <code>git submodule update</code> 则从该项目中抓取所有数据并检出父项目中列出的合适的提交。</p>
<p>如果给 git clone 命令传递 –recursive 选项，它就会自动初始化并更新仓库中的每一个子模块。</p>
<h3 id="在包含子模块的项目上工作"><a href="#在包含子模块的项目上工作" class="headerlink" title="在包含子模块的项目上工作"></a>在包含子模块的项目上工作</h3><p>在项目中使用子模块的最简模型，就是只使用子项目并不时地获取更新，而并不在你的检出中进行任何更改。</p>
<p>当我们运行 git submodule update 从子模块仓库中抓取修改时，Git 将会获得这些改动并更新子目录中的文件，但是会将子仓库留在一个称作 “游离的 HEAD” 的状态。</p>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>Git 可以将它的数据 “打包” 到一个文件中。这在许多场景中都很有用。有可能你的网络中断了，但你又希望将你的提交传给你的合作者们。可能你不在办公网中并且出于安全考虑没有给你接入内网的权限。</p>
<p>bundle 命令会<strong>将 git push 命令所传输的所有内容打包成一个二进制文件</strong>，你可以将这个文件通过邮件或者闪存传给其他人，然后解包到其他的仓库中。</p>
<p>如果你想把这个仓库发送给其他人但你没有其他仓库的权限，或者就是懒得新建一个仓库，你就可以用 gitbundle create 命令来打包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git bundle create repo.bundle HEAD master</div></pre></td></tr></table></figure></p>
<p>然后你就会有一个名为 repo.bundle 的文件，该文件包含了所有重建该仓库 master 分支所需的数据。</p>
<p>假设别人传给你一个 repo.bundle 文件并希望你在这个项目上工作。你可以从这个二进制文件中克隆出一个目录，就像从一个 URL 克隆一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone repo.bundle repo</div></pre></td></tr></table></figure></p>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>Git 对象是不可改变的，但它提供一种有趣的方式来用其他对象假装替换数据库中的 Git 对象。</p>
<p><code>replace</code>命令可以让你在 Git 中指定一个对象并可以声称“每次你遇到这个 Git 对象时，假装它是其他的东西”。在你用一个不同的提交替换历史中的一个提交时，这会非常有用。</p>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E6%9B%BF%E6%8D%A2" target="_blank" rel="external">详情</a></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[服务器上的Git && 分布式Git]]></title>
      <url>/2018/02/07/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84Git-%E5%88%86%E5%B8%83%E5%BC%8FGit/</url>
      <content type="html"><![CDATA[<p>《Pro Git》读书笔记</p>
<a id="more"></a>
<h1 id="服务器上的Git"><a href="#服务器上的Git" class="headerlink" title="服务器上的Git"></a>服务器上的Git</h1><p>一个远程仓库通常只是一个裸仓库（bare repository）— 即一个没有当前工作目录的仓库。因为该仓库仅仅作为合作媒介，不需要从磁碟检查快照；存放的只有 Git 的资料。简单的说，裸仓库就是你专案目录内的 .git 子目录内容，不包含其他资料</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>Git 可以使用四种主要的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git协议。</p>
<h3 id="本地协议"><a href="#本地协议" class="headerlink" title="本地协议"></a>本地协议</h3><p>最基本的就是 本地协议（Local protocol） ，其中的<strong>远程版本库就是硬盘内的另一个目录</strong>。这常见于团队每一个成员都对一个共享的文件系统（例如一个挂载的 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。后者并不理想，因为你的所有代码版本库如果长存于同一台电脑，更可能发生灾难性的损失。</p>
<p>优点</p>
<ul>
<li>简单，并且直接使用了现有的文件权限和网络访问权限</li>
</ul>
<p>缺点：</p>
<ul>
<li>通常共享文件系统比较难配置，并且比起基本的网络连接访问，这不方便从多个位置访问</li>
<li>在同一个服务器上，如果允许 Git 访问本地硬盘，一般的通过 NFS 访问版本库要比通过 SSH 访问慢。</li>
<li>这个协议并不保护仓库避免意外的损坏。每一个用户都有“远程”目录的完整 shell 权限，没有方法可以阻止他们修改或删除 Git 内部文件和损坏仓库。</li>
</ul>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>智能” HTTP 协议的运行方式和 SSH 及 Git 协议类似，只是运行在标准的 HTTP/S 端口上并且可以使用各种HTTP 验证机制，这意味着使用起来会比 SSH 协议简单的多，比如可以使用 HTTP 协议的用户名／密码的基础授权，免去设置 SSH 公钥。</p>
<p>哑 HTTP 协议里 web 服务器仅把裸版本库当作普通文件来对待，提供文件服务。哑 HTTP 协议的优美之处在于设置起来简单。基本上，只需要把一个裸版本库放在 HTTP 跟目录，设置一个叫做 post-update 的挂钩就可以了</p>
<p>优点（只关注智能“HTTP”协议）：</p>
<ul>
<li>不同的访问方式只需要一个 URL 以及服务器只在需要授权时提示输入授权信息，这两个简便性让终端用户使用Git 变得非常简单。</li>
<li>可以在 HTTPS 协议上提供只读版本库的服务，如此你在传输数据的时候就可以加密数据；或者，你甚至可以让客户端使用指定的 SSL 证书。</li>
<li>HTTP/S 协议被广泛使用，一般的企业防火墙都会允许这些端口的数据通过。</li>
</ul>
<p>缺点：</p>
<ul>
<li>在一些服务器上，架设 HTTP/S 协议的服务端会比 SSH 协议的棘手一些</li>
</ul>
<h3 id="SSH协议"><a href="#SSH协议" class="headerlink" title="SSH协议"></a>SSH协议</h3><p>架设 Git 服务器时常用 SSH 协议作为传输协议。因为大多数环境下已经支持通过 SSH 访问 —— 即时没有也比较很容易架设。SSH 协议也是一个验证授权的网络协议；并且，因为其普遍性，架设和使用都很容易。</p>
<p>优点：</p>
<ul>
<li>SSH 架设相对简单 —— SSH 守护进程很常见，多数管理员都有使用经验，并且多数操作系统都包含了它及相关的管理工具。</li>
<li>通过 SSH 访问是安全的 —— 所有传输数据都要经过授权和加密。</li>
<li>与 HTTP/S 协议、Git 协议及本地协议一样，SSH 协议很高效，在传输前也会尽量压缩数据。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能通过他实现匿名访问。即便只要读取数据，使用者也要有通过 SSH 访问你的主机的权限，这使得 SSH 协议不利于开源的项目。</li>
</ul>
<h3 id="Git协议"><a href="#Git协议" class="headerlink" title="Git协议"></a>Git协议</h3><p>包含在 Git 里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于 SSH服务，但是访问无需任何授权。</p>
<p>优点：</p>
<ul>
<li>Git 协议是 Git 使用的网络传输协议里最快的。</li>
</ul>
<p>缺点：</p>
<ul>
<li>缺乏授权机制。把 Git 协议作为访问项目版本库的唯一手段是不可取的</li>
</ul>
<h2 id="在服务器上搭建Git"><a href="#在服务器上搭建Git" class="headerlink" title="在服务器上搭建Git"></a>在服务器上搭建Git</h2><h3 id="SSH连接"><a href="#SSH连接" class="headerlink" title="SSH连接"></a>SSH连接</h3><p>如果你有一台所有开发者都可以用 SSH 连接的服务器，架设你的第一个仓库就十分简单了，因为你几乎什么都不用做（正如我们上一节所说的）。如果你想在你的仓库上设置更复杂的访问控制权限，只要使用服务器操作系统的普通的文件系统权限就行了。</p>
<p>如果需要团队里的每个人都对仓库有写权限，又不能给每个人在服务器上建立账户，那么提供 SSH 连接就是唯一的选择了。一下提供几种方法：</p>
<ul>
<li>第一个就是给团队里的每个人创建账号，这种方法很直接但也很麻烦。或许你不会想要为每个人运行一次 adduser 并且设置临时密码。</li>
<li>第二个办法是在主机上建立一个 git 账户，让每个需要写权限的人发送一个 SSH 公钥，然后将其加入 git 账户的~/.ssh/authorized_keys 文件。这样一来，所有人都将通过 git 账户访问主机。这一点也不会影响提交的数据——访问主机用的身份不会影响提交对象的提交者信息。</li>
<li>另一个办法是让 SSH 服务器通过某个 LDAP 服务，或者其他已经设定好的集中授权机制，来进行授权。只要每个用户可以获得主机的 shell 访问权限，任何 SSH 授权机制你都可视为是有效的。</li>
</ul>
<h2 id="GitWeb"><a href="#GitWeb" class="headerlink" title="GitWeb"></a>GitWeb</h2><p>如果你对项目有读写权限或只读权限，你可能需要建立起一个基于网页的简易查看器。Git 提供了一个叫做GitWeb 的 CGI 脚本来做这项工作</p>
<p>如果你想要查看 GitWeb 如何展示你的项目，并且在服务器上安装了轻量级网络服务器比如 lighttpd 或webrick， Git 提供了一个命令来让你启动一个临时的服务器。在 Linux 系统的电脑上，lighttpd 通常已经安装了，所以你只需要在项目目录里执行 git instaweb 命令即可。</p>
<h1 id="分布式Git"><a href="#分布式Git" class="headerlink" title="分布式Git"></a>分布式Git</h1><h2 id="分布式工作流程"><a href="#分布式工作流程" class="headerlink" title="分布式工作流程"></a>分布式工作流程</h2><p>在集中式系统中，每个开发者就像是连接在集线器上的节点，彼此的工作方式大体相像。而在 Git 中，<strong>每个开发者同时扮演着节点和集线器的角色</strong>——也就是说，每个开发者既可以将自己的代码贡献到其他的仓库中，同时也能维护自己的公开仓库，让其他人可以在其基础上工作并贡献代码。</p>
<h3 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="集中式工作流"></a>集中式工作流</h3><p>集中式系统中通常使用的是单点协作模型——集中式工作流。</p>
<p>这意味着如果两个开发者从中心仓库克隆代码下来，同时作了一些修改，那么只有第一个开发者可以顺利地把数据推送回共享服务器。第二个开发者在推送修改之前，必须先将第一个人的工作合并进来，这样才不会覆盖第一个人的修改。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517834128254.jpg" alt="enter description here"></p>
<h3 id="集成管理者工作流"><a href="#集成管理者工作流" class="headerlink" title="集成管理者工作流"></a>集成管理者工作流</h3><p>Git 允许多个远程仓库存在，使得这样一种工作流成为可能：每个开发者拥有自己仓库的写权限和其他所有人仓库的读权限。这种情形下通常会有个代表‘官方’’项目的权威的仓库。要为这个项目做贡献，你需要从该项目克隆出一个自己的公开仓库，然后将自己的修改推送上去。接着你可以请求官方仓库的维护者拉取更新合并到主项目。维护者可以将你的仓库作为远程仓库添加进来，在本地测试你的变更，将其合并入他们的分支并推送回官方仓库。</p>
<p>这是 GitHub 和 GitLab 等集线器式（hub-based）工具最常用的工作流程。</p>
<p>这么做最主要的优点之一是你可以持续地工作，而主仓库的维护者可以随时拉取你的修改。贡献者不必等待维护者处理完提交的更新——每一方都可以按照自己节奏工作</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517834212479.jpg" alt="enter description here"></p>
<h3 id="司令官与副官工作流"><a href="#司令官与副官工作流" class="headerlink" title="司令官与副官工作流"></a>司令官与副官工作流</h3><p>这其实是多仓库工作流程的变种。一般拥有数百位协作开发者的超大型项目才会用到这样的工作方式，例如著名的 Linux 内核项目。被称为副官（lieutenant）的各个集成管理者分别负责集成项目中的特定部分。所有这些副官头上还有一位称为司令官（dictator）的总集成管理者负责统筹。司令官维护的仓库作为参考仓库，为所有协作者提供他们需要拉取的项目代码。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517834259058.jpg" alt="enter description here"></p>
<h2 id="向一个项目贡献"><a href="#向一个项目贡献" class="headerlink" title="向一个项目贡献"></a>向一个项目贡献</h2><p>提交准则：</p>
<ul>
<li>你不会想要把空白错误提交上去</li>
<li>尝试让每一个提交成为一个逻辑上的独立变更集。</li>
<li>最后一件要牢记的事是提交信息。有一个创建优质提交信息的习惯会使 Git 的使用与协作容易的多。</li>
</ul>
<h2 id="维护项目"><a href="#维护项目" class="headerlink" title="维护项目"></a>维护项目</h2><h3 id="在特性分支中工作"><a href="#在特性分支中工作" class="headerlink" title="在特性分支中工作"></a>在特性分支中工作</h3><p>如果你想向项目中整合一些新东西，最好将这些尝试局限在特性分支——一种通常用来尝试新东西的临时分支中</p>
<h3 id="应用来自邮件的补丁"><a href="#应用来自邮件的补丁" class="headerlink" title="应用来自邮件的补丁"></a>应用来自邮件的补丁</h3><p>如果你通过电子邮件收到了一个需要整合进入项目的补丁，你需要将其应用到特性分支中进行评估。有两种应用该种补丁的方法：使用 git apply，或者使用 git am。</p>
<p>具体详情可以参考<a href="https://git-scm.com/book/zh/v2/%E5%88%86%E5%B8%83%E5%BC%8F-Git-%E7%BB%B4%E6%8A%A4%E9%A1%B9%E7%9B%AE" target="_blank" rel="external">这里</a></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[APUE Unix 基础知识]]></title>
      <url>/2018/02/06/APUE-Unix-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>《UNIX环境高级编程》第1章笔记</p>
<a id="more"></a>
<h2 id="Unix-体系结构"><a href="#Unix-体系结构" class="headerlink" title="Unix 体系结构"></a>Unix 体系结构</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_6_1517920273064.jpg" alt="enter description here"></p>
<p>可以将操作系统定义为一种软件，其控制计算机硬件资源，提供程序运行环境。我们通常将这种软件称为<strong>内核</strong>( kemel),因为它相对较小, 而且位于环境的核心。</p>
<p>内核的接口被称为<strong>系统调用</strong>( system call)。公用函数库构建在系统调用接口之上,应用程序既可使用公用函数库,也可使用系统调用。</p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>口令文件（通常是/etc/passwd文件）中查看登录名。口令文件中的登录项由7个以冒号分隔的字段组成,依次是:<br><code>登录名、加密口令、数字用户ID(205)、数字组TD(105)、注释字段、起始目录(/home/sar)以及 shel程序(/bin/ksh)</code></p>
<p>shell是一个命令行解释器,它读取用户输入,然后执行命令。 shell的用户输入通常来自 于终端(交互式 shell),有时则来自于文件(称为 shell i脚本)。</p>
<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>UNX文件系统是<strong>目录和文件的一种层次结构</strong>,所有东西的起点是称为根(root)的目录,这个目录的名称是一个字符“/”。 目录( directory)是一个包含目录项的文件。</p>
<h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><p>目录中的各个名字称为文件名( filename)。只有斜线线(/)和空字符这两个字符不能出现在 文件名中。斜线用来分隔构成路径名的各文件名,空字符则用来终止一个路径名。</p>
<h3 id="路径名"><a href="#路径名" class="headerlink" title="路径名"></a>路径名</h3><p>由斜线分隔的一个或多个文件名组成的序列(也可以斜线开头)构成路径名( pathname),以斜线 开头的路径名称为<strong>绝对路径名</strong>( absolute pathname),否则称为<strong>相对路径名</strong>( relative pathname)。</p>
<h3 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h3><p>每个进程都有一个工作目录( working directory),有时称其为当前工作目录( current working directory)。所有相对路径名名都从工作目录开始解释。</p>
<h3 id="起始目录"><a href="#起始目录" class="headerlink" title="起始目录"></a>起始目录</h3><p>登录时，工作目录设置为起始目录（home directory）</p>
<blockquote>
<p>ls(l) 命令的简要实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span>  <span class="comment">//用于本书各个实例 包含某些标准头文件，定义了很多常量和函数模型</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt; // 使用opendir和readdir的函数原型，以及dirent结构的定义</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></div><div class="line">&#123;</div><div class="line">	DIR				*dp;</div><div class="line">	<span class="keyword">struct</span> dirent	*dirp;</div><div class="line"></div><div class="line">	<span class="comment">// 给出的参数不符</span></div><div class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</div><div class="line">		err_quit(<span class="string">"usage: ls directory_name"</span>);</div><div class="line">	<span class="comment">// 获取命令行的第一个参数，	打开目录，返回一个DIR结构指针</span></div><div class="line">	<span class="keyword">if</span> ((dp = opendir(argv[<span class="number">1</span>])) == <span class="literal">NULL</span>)</div><div class="line">		err_sys(<span class="string">"can't open %s"</span>, argv[<span class="number">1</span>]);</div><div class="line">	<span class="comment">// 读取目录并输出目录名</span></div><div class="line">	<span class="keyword">while</span> ((dirp = readdir(dp)) != <span class="literal">NULL</span>)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, dirp-&gt;d_name);</div><div class="line">	<span class="comment">// 关闭目录</span></div><div class="line">	closedir(dp);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>文件描述符( file descriptor)通常是一个小的非负整数,内核用以标识一个特定进程正在访 问的文件。当内核打开一个现有文件或创建一个新文件时,它都返回一个文件描述符。</p>
<h3 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h3><p> 按惯例,每当运行一个新程序时,所有的 shell i都为其打开3个文件描述符,即标准输入 standard input.)、标准输出( Istandard output)以及标准錯误( standard error)</p>
<h3 id="不带缓冲I-O"><a href="#不带缓冲I-O" class="headerlink" title="不带缓冲I/O"></a>不带缓冲I/O</h3><p> 函数open、read、write、lseek以及close提供了不带缓冲的I/O</p>
<p> 复制任意Unix普通文件</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	BUFFSIZE	4096</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span>		n;</div><div class="line">	<span class="keyword">char</span>	buf[BUFFSIZE];</div><div class="line"></div><div class="line">	<span class="comment">// STDIN_FILENO 和 STDOUT_FILENO指定标准输入输出的文件描述符 在POSIX标准，他们分别是0和1</span></div><div class="line">	<span class="comment">// read函数返回读取的字节数，此值作为写入的字节数传入write函数中</span></div><div class="line">	<span class="keyword">while</span> ((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">if</span> (write(STDOUT_FILENO, buf, n) != n)</div><div class="line">			err_sys(<span class="string">"write error"</span>);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</div><div class="line">		err_sys(<span class="string">"read error"</span>);</div><div class="line"></div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h3><p> 标准U/O函数为那些不带缓冲的I/O函数提供了一个带缓冲的接口。使用标准I/O函数无需 担心如何选取最佳的缓冲区大小</p>
<h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p> 程序（program）是存储在磁盘上某个目录中的一个可执行文件</p>
<h3 id="进程和进程ID"><a href="#进程和进程ID" class="headerlink" title="进程和进程ID"></a>进程和进程ID</h3><p> 程序执行实例被称为进程（process），Unix系统确保每一个进程都有唯一一个数字标识符，称为进程ID（process ID）</p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p> 有3个用于控制进程的主要函数：fork、exec和waitpid</p>
<h3 id="线程和线程ID"><a href="#线程和线程ID" class="headerlink" title="线程和线程ID"></a>线程和线程ID</h3><blockquote>
<p>shell 基本实施程序</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span>	buf[MAXLINE];	<span class="comment">/* from apue.h */</span></div><div class="line">	<span class="keyword">pid_t</span>	pid;</div><div class="line">	<span class="keyword">int</span>		status;</div><div class="line"></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%% "</span>);	<span class="comment">/* print prompt (printf requires %% to print %) */</span></div><div class="line"></div><div class="line">	<span class="comment">// 用标准I/O函数fgets从标准输入中读取一行</span></div><div class="line">	<span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</div><div class="line">		<span class="comment">// 因为fgets返回的每一行中都以换行符终止，但是execlp函数要求参数以null结束，所以用null替代每一行后面的换行符</span></div><div class="line">		<span class="keyword">if</span> (buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">'\n'</span>)</div><div class="line">			buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">/* replace newline with null */</span></div><div class="line"></div><div class="line">		<span class="comment">// fork创建子进程失败</span></div><div class="line">		<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</div><div class="line">			err_sys(<span class="string">"fork error"</span>);</div><div class="line">			<span class="comment">// 子进程处理：调用execlp从命令行输入读入命令，用新的程序文件替换子进程原来执行的程序文件</span></div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;		<span class="comment">/* child */</span></div><div class="line">			execlp(buf, buf, (<span class="keyword">char</span> *)<span class="number">0</span>);</div><div class="line">			err_ret(<span class="string">"couldn't execute: %s"</span>, buf);</div><div class="line">			<span class="built_in">exit</span>(<span class="number">127</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">/* parent */</span></div><div class="line">		<span class="comment">// 父进程通过waitpid等待子进程终止，指定等待的进程为参数</span></div><div class="line">		<span class="keyword">if</span> ((pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span>)</div><div class="line">			err_sys(<span class="string">"waitpid error"</span>);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%% "</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h2><p>当UINX系统函数出错时,通常会返回一个负值,而且整型变量 errno通常被设置为具有特定 信息的值。</p>
<p>对于 errno应应当注意两条规则<br>第一条规则是:如果没有出错,其值不会被例程清除。因此,仅当函数的返回值指明出错时,才检验其值。<br>第二条规则是:任何函数都不会将errn值设置为0,而且在&lt; errno.h&gt;中定义的所有常量都不为0</p>
<p>出错恢复</p>
<p>可将在&lt; errno.h&gt;中定义的各种出错分成两类:<strong>致命性的和非致命性的</strong>。对于致命性的错误, 无法执行恢复动作。最多能做的是在用户屏幕上打印出一条出错消息或者将一条出错消息写入日 志文件中,然后退出。对于非致命性的出错,有时可以较妥善地进行处理。大多数非致命性出错 是暂时的(如资源短缺),当系统中的活动较少时,这种出错很可能不会发生。</p>
<h2 id="用户标识"><a href="#用户标识" class="headerlink" title="用户标识"></a>用户标识</h2><h3 id="用户ID"><a href="#用户ID" class="headerlink" title="用户ID"></a>用户ID</h3><p>向系统标识各个不同的用户，用户ID为0的用户为根用户（root）或者超级用户（superuser）</p>
<h3 id="组ID"><a href="#组ID" class="headerlink" title="组ID"></a>组ID</h3><p>口令文件登录项包括用户的组ID（group ID），为一个数值。</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号( signal)用于通知进程发生了某种情况。进程有以下3种处理信号的方式。<br>(1)忽略信号。有些信号表示硬件异常,例如,除以0或访问进程地址空间以外的存储单元 等,因为这些异常产生的后果不确定,所所以不推荐使用这种处理方式。<br>(2)按系统狀认方式处理。对于除数为0,系统默认方式是终止该进程。<br>(3)提供一个函数,信号发生时调用该函数,这被称为捕捉该信号。通过提供自编的函数, 我们就能知道什么时候产生了信号,并按期望的方式处理它。</p>
<p>很多情况都会产生信号。终端键盘上有两种产生信号的方法,分别称为中断健( interrupt 通常是 Delete键或Ctl+C)和退出键( quit key,通常是Curl+4),它们被用于中断当前运行的进程。 另一种产生信号的方法是调用kill函数。在一个进程中调用此函数就可向另一个进程发送一个信 号。当然这样做也有些限制:当向一个进程发送信号时,我们必须是那个进程的所有者或者是超级 用户。</p>
<blockquote>
<p>能够处理终端的shell实例</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>	<span class="title">sig_int</span><span class="params">(<span class="keyword">int</span>)</span></span>;		<span class="comment">/* our signal-catching function */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span>	buf[MAXLINE];	<span class="comment">/* from apue.h */</span></div><div class="line">	<span class="keyword">pid_t</span>	pid;</div><div class="line">	<span class="keyword">int</span>		status;</div><div class="line"></div><div class="line">	<span class="comment">// 调用sinal函数，指定当产生SIGINT信号时，调用sig_int函数</span></div><div class="line">	<span class="keyword">if</span> (signal(SIGINT, sig_int) == SIG_ERR)</div><div class="line">		err_sys(<span class="string">"signal error"</span>);</div><div class="line"></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%% "</span>);	<span class="comment">/* print prompt (printf requires %% to print %) */</span></div><div class="line">	<span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</div><div class="line">		<span class="keyword">if</span> (buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">'\n'</span>)</div><div class="line">			buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">/* replace newline with null */</span></div><div class="line"></div><div class="line">		<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</div><div class="line">			err_sys(<span class="string">"fork error"</span>);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;		<span class="comment">/* child */</span></div><div class="line">			execlp(buf, buf, (<span class="keyword">char</span> *)<span class="number">0</span>);</div><div class="line">			err_ret(<span class="string">"couldn't execute: %s"</span>, buf);</div><div class="line">			<span class="built_in">exit</span>(<span class="number">127</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">/* parent */</span></div><div class="line">		<span class="keyword">if</span> ((pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span>)</div><div class="line">			err_sys(<span class="string">"waitpid error"</span>);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%% "</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">sig_int</span><span class="params">(<span class="keyword">int</span> signo)</span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"interrupt\n%% "</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="时间值"><a href="#时间值" class="headerlink" title="时间值"></a>时间值</h2><p>历史上,UNIX系统使用过两种不同的时间值。<br>(1)日历时间。该值是自协调世界时( Coordinated Universal Time, UTC)1970年1月1日 00\:00:00这个特定时间以来所经过的秒数累计值(早期的手册称UTC为格林尼治标准时间)。这 些时间值可用于记录文件最近一次的修改时间等。 系统基本数据类型 time_t用于保存这种时间值<br>(2)进程时间。也被称为CPU时间,用以度量进程使用的中央处理器资源。进程时间以时钟滴答计算。每秒钟曾经取为50、60或100个时钟滴答。 系统基本数据类型clock_t保存这种时间值。</p>
<p>当度量一个进程的执行时间时,UNIX系统为一个进程维护了3个进程时间值: </p>
<ul>
<li>时钟时间 ,时钟时间又称为墙上时钟时间( wall clock time),它是进程运行的时间总量,其值与系统 中同时运行的进程数有关。</li>
<li>用户CPU时间,用户CPU时间是执行用户指令所用的时间量。</li>
<li>系统CPU时间 ，系统CPU时间是为该进程执行内核程序所经 历的时间。</li>
</ul>
<p>例如,每当一个进程执行一个系统服务时,如read或wrte,在内核内执行该服务所花费的时间就计入该进程的系统CPU时间。用户CPU时间和系统CPU时间之和常被称为CPU 时间。</p>
<h2 id="系统调用和函数库"><a href="#系统调用和函数库" class="headerlink" title="系统调用和函数库"></a>系统调用和函数库</h2><p>所有的操作系统都有提供多种服务的入口点，这些入口点被称为系统调用（system call）</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_6_1517923519865.jpg" alt="enter description here"></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《计算机网络——自顶向下方法》 笔记]]></title>
      <url>/2018/02/05/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B-%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>阅读《计算机网络——自顶向下方法》过程中的笔记，持续更新中。</p>
<a id="more"></a>
<h1 id="计算机网络和因特网"><a href="#计算机网络和因特网" class="headerlink" title="计算机网络和因特网"></a>计算机网络和因特网</h1><h2 id="什么是因特网"><a href="#什么是因特网" class="headerlink" title="什么是因特网"></a>什么是因特网</h2><h3 id="具体构成描述"><a href="#具体构成描述" class="headerlink" title="具体构成描述"></a>具体构成描述</h3><p>端系统通过<strong>通信链路</strong>( communication link)和和<strong>分组交换机</strong>( packet switch)连接到一 起。</p>
<p>不同的链路能够以不同的速率传输 数据,链路的传输速率以<strong>比特/秒</strong>度量(bit/s,或bps)，当一台端系统要向另一台端系统 发送数据时,发送端系统将数据分段,并为每段加上首部字节。由此形成的信息包用计算 机网络的术语来说称为<strong>分组</strong>( packet)。</p>
<p>分组交换机从它的一条入通信链路接收到达的分组,并从它的一条出通信链路转发该分组。两种最著 名的类型是<strong>路由器</strong>( router)和<strong>链路层交换机</strong>(link- layer switch)。这两种类型的交换机朝 着最终目的地转发分组。链路层交换机通常用于接入网中,而路由器通常用于网络核心 中。</p>
<p>从发送端系统到接收端系统,一个分组所经历的一系列通信链路和分组交换机称为通 过该网络的<strong>路径</strong>( route或path)。</p>
<p>端系统通过<strong>因特网服务提供商</strong>( Internet Service Provider,SP)接人因特网,每个ISP是一个由多个分组交换机和多段通信 链路组成的网络。各ISP为端系统提供了各种不同类型的网络接入</p>
<p>端系统、分组交换机和其他因特网部件都要运行一系列协议( protocol),这些协议 控制因特网中信息的接收和发送。TCP( Transmission Control Protocol,传输控制协议) 和IP( Internet Protocol,网际协议)是因特网中两个最为重要的协议。</p>
<h3 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h3><blockquote>
<p>人类活动类比</p>
</blockquote>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517720029036.jpg" alt="enter description here"></p>
<blockquote>
<p>网络协议</p>
</blockquote>
<p>协议定义了在两个或多个通信实体之间交换的报文格式和次序,以及报文发送和/或接收一条报文或其他事件所采取的动作。</p>
<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p>通常把与因特网相连的计算机和其他设备称为端系 统。如图1-3所示,因为它们位于因特网的边缘,故而被称为端端系统。</p>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>网络核心,即由互联因特网端系统的<strong>分组交换机</strong>和<strong>链路</strong>构成的网状网络</p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>在各种网络应用中,端系统彼此交换<strong>报文</strong>( message)。为了从源端系统向目 的端系统发送一个报文,源将长报文划分为较小的数据块,称之为<strong>分组</strong>( packet)。在源和 目的之间,每个分组都通过<strong>通信链路和分组交换机</strong>( packet switch)(交换机主要有两类 路由器和链路层交换机)传送。</p>
<blockquote>
<p>存储转发传输</p>
</blockquote>
<p>多数分组交换机在链路的输入端使用<strong>存储转发传输</strong>( store-and- forward transmission ）机制。存储转发机制是指在交换机能够开始向输出链路传输该分组的第一个比特之前,必 须接收到整个分组。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517733216783.jpg" alt="enter description here"></p>
<blockquote>
<p>排队时延和分组丢失</p>
</blockquote>
<p>每个分组交换机有多条链路与之相连。对于每条相连的链路,该分组交换机具有一个 <strong>输出缓存</strong>( output buffer)(也称为输出队列 output queue),它用用于存储路由器准备发往那 条链路的分组。该输出缓存在分组交换中起着重要的作用。如果到达的分组需要传输到某 条链路,但发现该链路正忙于传输其他分组,该到达分组必须在该输出缓存中等待。</p>
<p>除了存储转发时延之外，分组还要承受输出缓存的<strong>排队时延</strong>（queue delay）</p>
<p>一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。在此情况下,将出现<strong>分组丢失(丢包)</strong>( packet lost),到达的分组或已经排队的分组之一将被丢弃。</p>
<blockquote>
<p>转发表和路由选择协议</p>
</blockquote>
<p>每台路由器具有一个<strong>转发表</strong> ( forwarding table),用于将目的地址(或目的地址的一部分)映射成为输出链路。</p>
<h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>在电路交换网络中,在端系统间通信会话期间,预留了端系统间通信沿路径所需要的 资源(缓存,链路传输速率)。在分组交换网络中,这些资源则不是预留的;会话的报文 按需使用这些资源,其后果可能是不得不等待(即    排队)接入通信线路。</p>
<blockquote>
<p>电路交换网络中的复用</p>
</blockquote>
<p>链路中的电路是通过<strong>频分复用</strong>( Frequency- Division Multiplexing,FDM)或<strong>时分复用</strong> (Time- Division Multiplexing,TDM)来实现的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517733959077.jpg" alt="enter description here"></p>
<h2 id="分组交换网中的时延、丢包和吞吐量"><a href="#分组交换网中的时延、丢包和吞吐量" class="headerlink" title="分组交换网中的时延、丢包和吞吐量"></a>分组交换网中的时延、丢包和吞吐量</h2><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><blockquote>
<p>时延类型</p>
</blockquote>
<p>处理时延+排队时延+传输时延+传播时延</p>
<h3 id="计算机网络中的吞吐量"><a href="#计算机网络中的吞吐量" class="headerlink" title="计算机网络中的吞吐量"></a>计算机网络中的吞吐量</h3><p>在任何时间瞬间 的<strong>瞬时吞吐量</strong>( instantaneous throughput)是主机B接收到该文件的速率(以bps计)。</p>
<p>如果该文件由F比特组成,主机B接收到所有F比特用去T秒,则 文件传送的<strong>平均吞吐量</strong>( average throughput)是F/Tbps。</p>
<h2 id="协议层次及其服务模型"><a href="#协议层次及其服务模型" class="headerlink" title="协议层次及其服务模型"></a>协议层次及其服务模型</h2><h3 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517734508197.jpg" alt="enter description here"></p>
<h2 id="面对攻击的网络"><a href="#面对攻击的网络" class="headerlink" title="面对攻击的网络"></a>面对攻击的网络</h2><h3 id="利用网络将有害程序放入你的计算机中"><a href="#利用网络将有害程序放入你的计算机中" class="headerlink" title="利用网络将有害程序放入你的计算机中"></a>利用网络将有害程序放入你的计算机中</h3><p>今天的多数恶意软件是<strong>自我复制</strong>(self- replicating)的:一旦它感染了一台主机,就会 从那台主机寻求进入更多的主机。</p>
<p><strong>病毒</strong>(virus)是一种需要某种形式的用户交 互来感染用户设备的恶意软件。</p>
<p><strong>蠕虫</strong>(worm)是一种无需任何明显用户交互就能进 入设备的恶意软件。</p>
<h3 id="攻击服务器和网络的基础设施"><a href="#攻击服务器和网络的基础设施" class="headerlink" title="攻击服务器和网络的基础设施"></a>攻击服务器和网络的基础设施</h3><p>另一种宽泛类型的安全性威胁称为<strong>拒绝服务攻击</strong>( Denial-of- Service(DoS) attack)。 顾名思义,DoS攻击使得网络、主机或其他基础设施部分不能由合法用户所使用。</p>
<p>大多数DOS攻击属于下列三种类型之一：</p>
<ul>
<li>弱点攻击</li>
<li>带宽洪泛</li>
<li>连接洪泛</li>
</ul>
<p>分布式DoS( Distributed Dos,DDoS)中,攻击者 控制多个源并让每个源向目标猛烈发送流量。使用这种方法,为了削弱或损坏服务器,遍 及所有受控源的聚合流量速率需要大约R的能力。</p>
<h3 id="嗅探分组"><a href="#嗅探分组" class="headerlink" title="嗅探分组"></a>嗅探分组</h3><p>记录每个流经的分组的副本的被动接收机成为<strong>分组嗅探器</strong>（packer sniffer）</p>
<hr>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><p>网络核心设备并不在应用层上 起作用,而仅在较低层起作用,特别是位于网络层及下面层次。这种基本设计,也即将应用软件限制在端系统的方法,促进了大量的网络应用程序的迅速研发和部署。</p>
<h3 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h3><p>应用程序体系结构( application architecture)由应用程序研发者设计, 规定了如何在各种端系统上组织该应用程序。在选择应用用程序体系结构时,应用程序研发 者很可能利用现代网络应用程序中所使用的两种主流体系结构之一:<strong>客户-服务器体系结 构</strong>或<strong>对等(P2P)体系结构</strong>。 </p>
<p>在客戶-服务器体系结构( client- server architecture)中,有一个总是打开的主机称为 服务器,它服务于来自许多其他称为客户的的主机的请求。一个经典的例子是Web应用程序。在一个客户-服务器应用中,常常会出现一台单独的服务器主机跟不上它所有客户请 求的情况。例如,一个流行的社交网络站点如果仅有一台服务器来处理所有请求,将很快 变得不堪重负。为此,配备大量主机的<strong>数据中心</strong>常被用于创建强大的虚拟服务器。</p>
<p>在一个P2P体系结构(P2 2 architecture)中,对位于数据中心的专用服务器有最小 的(或者没有)依赖。相反,应用程序在间断连接的主机对之间使用直接通信,这些 主机对被称为对等方。这些对等方并不为服务提供商所有,相反却为用户控制的桌面机 和膝上机所有,大多数对等方驻留在家庭、大学和办公室。P2P体系结构最引人入胜的特性之一就是他的自扩展性（self-scalability）。</p>
<p>未来P2P应用面临三个主要挑战：</p>
<ul>
<li>ISP友好。大多数住宅ISP(包括DSL和电缆ISP)已经受制于“非对称的”带宽 应用,也就是说,下载比上载要多得多。但是P2P视频流和文件分发应用改变了 从服务器到住宅ISP的上载流量,因而给ISP带来了巨大压力。</li>
<li>安全性。因为它们的高度分布和开放特性,P2P应用给安全带来挑战</li>
<li>激励。未来P2P应用的成功也取决于说服用户自愿向应用提供带宽、存储和计算 资源,这对激励设计带来挑战</li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>在操作系统的术语中,进行通信的实际上是进程( process)而不是程 序。一个进程可以被认为是运行在端系统中的一个程序。</p>
<p>在两个不同端系统上的进程,通过跨越计算机网络交换报文( message)而相互通信。 发送进程生成并向网络中发送报文;接收进程接收这些报文并可能通过将报文发送回去进 行响应。</p>
<blockquote>
<p>客户和服务器进程</p>
</blockquote>
<p>对每对通信进程, 我们通常将这两个进程之一标识为客户( cient),而另一个进程标识为服务器( server) 。</p>
<p>在P2P文件共享的某些应用中,一个进程能够既是客户又是服 务器。在P2P文件共享系统中,一个进程的确既能上载文件又能下载文件。</p>
<blockquote>
<p>进程与计算机网络之间的接口 </p>
</blockquote>
<p>多数应用程序是由通信进程对组成,每对中的两个进程互相发送报文。从 一个进程向另一个进程发送的报文必须通过下面的网络。进程通过一个称为套接字( socket) 的软件接口向网络发送报文和从网络接收报文。</p>
<p>由于该套接字是建立网络应用程序的可编程接口,因此套接字也 称为应用程序和网络之间的应用程序编程接口( Application Programming Interface,API)。</p>
<blockquote>
<p>进程寻址</p>
</blockquote>
<p>为了标识接受进程，需要两种信息：主机地址；定义在目的主机中的接收进程的标识符</p>
<p>在因特网中，主机由其IP地址标识，端口号用于标识后者。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517797198782.jpg" alt="enter description here"></p>
<h3 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h3><blockquote>
<p>可靠数据传输</p>
</blockquote>
<p>需要可靠数据传输的应用,必须做一些工作以确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端 ，如果一个协议提供了这样的确保数据交付服务,就认为提供了可靠数据传输( reliable data transfer)。</p>
<p> 当一个运输层协议不提供可靠数据传输时,由发送进程发送的某些数据可能不能够到 达接收进程。这可能能被容忍丢失的应用(los- tolerant application)所接受,最值得注意 的是多媒体应用,如交谈式音频/视频,它们能够承受一定量的数据丢失。</p>
<blockquote>
<p>吞吐量</p>
</blockquote>
<p>具有吞吐量要求的应用程序被称为 <strong>带宽敏感的应用</strong>( bandwidth- sensitive application)。许多当前的多媒体应用是带宽敏感的 尽管某些多媒体应用程序可能采用自适应编码技术对数字语音或视频以与当前可用带宽相 匹配的速率进行编码。</p>
<p>带宽敏感的应用具有特定的吞吐量要求,而而<strong>弹性应用</strong>( elastic application)能够根据 情况或多或少地利用可供使用的吞吐量。</p>
<blockquote>
<p>定时</p>
</blockquote>
<p>运输层协议能提供定时保证，</p>
<blockquote>
<p>安全性</p>
</blockquote>
<p>运输协议能够为应用程序提供一种或者多种安全性服务</p>
<h3 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h3><p>因特网(更一般的是TCP/P网络络)为应用程序 提供两个运输层协议,即UDP和TCP。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517797561137.jpg" alt="enter description here"></p>
<blockquote>
<p>TCP服务</p>
</blockquote>
<p>TCP服务模型包括面向连接服务和可靠数据传输服务：</p>
<ul>
<li>面向连接的服务:在应用层层数据报文开始流动之前,TCP让客户和服务器互相交 换运输层控制信息。这条连接是全双工的,即连接双方的进程可以在此连接 上同时进行报文收发。当应用程序结束报文发送时,必须拆除该连接。</li>
<li><p>可靠的数据传送服务:通信进程能够依靠TCP,<strong>无差错、按适当顺序交付</strong>所有发 送的数据。</p>
<p>TCP协议还具有拥塞控制机制,这种服务不一定能为通信进程带来直接好处,但能为 因特网带来整体好处。</p>
</li>
</ul>
<blockquote>
<p>TCP 安全</p>
</blockquote>
<p>无论TCP还是UDP都没有提供任何加密机制,这就是说发送进程传进其套接字的 数据,与经网络传送到目的进程的数据相同。</p>
<p>因特网界已经经研制了TCP的加强版 本,称称为安全套接字层( Secure Sockets Layer,SSL)。用SSL加强后的TCP不仅能够做 传统的TCP所能做的一切,而且提供了关键的进程到进程的安全性服务,包括加密、数 据完整性和端点鉴别。</p>
<blockquote>
<p>UDP 服务</p>
</blockquote>
<p>UDP是一种不提供不必要服务的轻量级运输协议,它仅提供最小服务。UDP是无连 接的,因此在两个进程通信前没有握手过程。UDP协议提供一种不可靠数据传送服务,也 就是说,当进程将一个报文发送进UDP套接字时,UDP协议并不保证该报文将到达接收 进程。不仅如此,到达接收进程的报文也可能是乱序到达的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517798026139.jpg" alt="enter description here"></p>
<h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p>应用层协议( application- layer protocol)定义了运行在不同 端系统上的应用程序进程如何相互传递报文。有些应用层协议是由RFC文档定义的,因此它们位于公共域中。例如,Web的应用</p>
<h2 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h2><p>Web是一个引起公众注意的因特网应用,它极大地改变了人们与工作环境内外交流的方式。它将因特网从只是很多数据网之一的地位提升为仅有的一个数据网。 也许对大多数用户来说,最具有吸引力的就是Web的按需操作。</p>
<h3 id="HTTP-概况"><a href="#HTTP-概况" class="headerlink" title="HTTP 概况"></a>HTTP 概况</h3><p>Web的应用层协议是超文本传输协议( Hypertext Transfer Protocol,HTTP),它是Web 的核心。HTTP由两个程序实现:一个客户程序和一个服务器程序。</p>
<p>HTTP使用TCP作为它的支撑运输协议 (而不是在UDP上运行)。HTTP客户首先发起 个与服务器的TCP连接。</p>
<p>因为HTP服务器并不保存关于客户的任何信息,所 以我们说HTTP是一个无状态协议议( stateless protocol)。</p>
<h3 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h3><p>每个请求/响应对是经一个单独的TCP连接发送,还是所有的请求及其响应经相同的TCP连接发送 ?采用前一种方法,该应用程序被称为使用<strong>非持续连接</strong>(non- persistent connection);采用后一种方法,该应用程序被称为使用<strong>持续连接</strong>( persistent connection)。</p>
<p>HTTP在其默认方式下使用持续连接，HTTP客户和服务器也能配置成使用非持续连接</p>
<p>非持续连接有一些缺点。首先,必须为每一个请求的对象建立和维护一个全新的对于每个这样的连接,在客户和服务器中都要分配TCP的缓冲区和保持TCP变量, 这给Web服务器带来了严重的负担,因为一台Web服务器可能同时服务于数以百计不同 的客户的请求。第二,每一个对象经受两倍RTT的交付时延, 即一个RTT用于创建TCP,另一个RTT用于请求和接收一个对象 </p>
<p>在采用持续连接的情况下,服务器在发送响应后保持该TCP连接打开。在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传送。</p>
<h3 id="HTTP-报文格式"><a href="#HTTP-报文格式" class="headerlink" title="HTTP 报文格式"></a>HTTP 报文格式</h3><blockquote>
<p>请求报文</p>
</blockquote>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517802240900.jpg" alt="enter description here"></p>
<blockquote>
<p>响应报文</p>
</blockquote>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517802525968.jpg" alt="enter description here"></p>
<h3 id="用户和服务器的交互：cookie"><a href="#用户和服务器的交互：cookie" class="headerlink" title="用户和服务器的交互：cookie"></a>用户和服务器的交互：cookie</h3><p>HTTP服务器是无状态的。这简化了服务器的设计,并且允许工程师 们去开发可以同时处理数以千计的TCP连接的高性能Web服务器。然而一个Web站点通 常希望能够识別用户,可能是因为服务器希望限制用户的访回,或者因为它希望把内容与 用户身份联系起来。为此,HTTP使用了 cookie。 它允许 站点对用户进行跟踪。目前大多数商务Web站点都使用了 cookie。</p>
<p> cookie技术有4个组件:<br> ①在HTTP响应报文中的一个 cookie首部 行;<br> ②在HTTP请求报文中的一个 cookie首部行;<br> ③在用户端系统中保留有一个 cookie文 件,并由用户的测览器进行管理;<br> ④位于Web站点的一个后端数据库。</p>
<p> <img src="https://data2.liuin.cn/story-writer/2018_2_5_1517802781498.jpg" alt="enter description here"></p>
<h3 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h3><p> Web缓存器( Web cache)也叫代理服务器( proxy server),它是能够代表 初始Web服务器来满足HTTP请求的网络实体。</p>
<p> <img src="https://data2.liuin.cn/story-writer/2018_2_5_1517802879780.jpg" alt="enter description here"></p>
<h3 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h3><p> HTTP协议有一种机制,允许缓存器证实它的对象是最新的。这种机制就是条件 GET( conditional GET)方法法。如果:①请求报文使用GET方法;并且(②请求报文中包 含一个“If- Modified- Since:”首部行。那么,这个HTTP请求报文就是一个条件GET请 求报文</p>
<h2 id="文件传输协议：FTP"><a href="#文件传输协议：FTP" class="headerlink" title="文件传输协议：FTP"></a>文件传输协议：FTP</h2><p>HTTP和FTP都是文件传输协议,并且有很多共同的特点,例如,它们都运行在TCP 上。然而,这两个应用层协议也有一些重要的区别。其中最显著的就是FTP使用了两个并行的TCP连接来传输文件,一个是<strong>控制连接</strong>( control connection),一个是<strong>数据连接</strong>(data connecton)。</p>
<p>控制连接用于在两主机之间传输控制信息,如用户标识、口令、改变远程目 录的命令以及“存放(put)”和和“获取(get)”文件的命令。数据据连接用于实际发送一个 文件。因为FTP协议使用一个独立的控制连接,所以我们也称FTP的控制信息是带外 (om-oand)传送的。</p>
<p>FTP服务器必须在整个会话期间保留用户的状态（state）</p>
<h2 id="因特网中的电子邮件"><a href="#因特网中的电子邮件" class="headerlink" title="因特网中的电子邮件"></a>因特网中的电子邮件</h2><p>因特网电子邮件系统由3个部分组成：用户代理、邮件服务器和简单邮件传输协议</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517826852365.jpg" alt="enter description here"></p>
<p>邮件服务器形成了电子邮件体系结构的核心。每个接收方(如Bob)在其中的某个邮 件服务器上有一个邮箱( mailbox)。</p>
<p>SMTP是因特网电子邮件中主要的应用层协议</p>
<h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>SMTP是因特网电子邮件应用的核心。如前所述, SMTP用于从发送方的邮件服务器发送报文到接收方的邮件服务器。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517827171046.jpg" alt="enter description here"></p>
<h3 id="与HTTP对比"><a href="#与HTTP对比" class="headerlink" title="与HTTP对比"></a>与HTTP对比</h3><p>这两个协议都用于从一台主机向另一台主机传 送文件:HTTP从Web服务器向Web客户(通常是一个测览器)传送文件(也称为对 象);SMTP从一个邮件服务器向另一个邮件服务器传送文件(即电子邮件报文)。当进行 文件传送时,持续的HTTP和SMTP都使用持续连接。因此,这两个协议有一些共同特征。 然而,两者之间也有一些重要的区别。</p>
<p>首先,<strong>HTTP主要是一个拉协议</strong>( pull protocol), 即在方便的时候,某些人在Web服务器上装载信息,用户使用HTTP从该服务器拉取这些 信息。特别是TCP连接是由想接收文件的机器发起的。另一方面,<strong>SMTP基本上是一个推 协议</strong>( push protocol),即发送邮件服务器把文件推向接收邮件服务器。特别是,这个TCP 连接是由要发送该文件的机器发起的。</p>
<p> 第二个区别就是我们前面间接地提到过的,<strong>SMTP要求每个报文(包括它们的体)使 用7比特ASC2码格式</strong>。如果某报文包含了非7比特ASCⅡ字符(如具有重音的法文 符)或二进制数据(如图形文件),则该报文必须按照7比特ASCⅡ码进行编码。HTP数 据则不受这种限制。 </p>
<p> 第三个重要区别是如何处理一个既包含文本又包含图形(也可能是其他媒体类型)的 文档。HTTP把每个对象封装到它自己的HTP响应报文中 而SMTP则把所有报文对象放在一个报文之中。</p>
<h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><p> 邮件访问使用了一种客户-服务器体系结构，即典型的用户通过在用户端系统上运行的客户程序来阅读电子邮件。</p>
<p> 目前有一些流行的的邮件访问协议,包括第三版的邮局协议( Post Offfice Protocol– Version3,POP3)、因特网邮件访问协议( Internet Mail Access Protocol,IMAP) 以及HTTP。</p>
<p> <img src="https://data2.liuin.cn/story-writer/2018_2_5_1517827622320.jpg" alt="enter description here"></p>
<h2 id="DNS：因特网的目录服务"><a href="#DNS：因特网的目录服务" class="headerlink" title="DNS：因特网的目录服务"></a>DNS：因特网的目录服务</h2><p> 因特网上的主机和人类一样,可以使用多种方式进行标识。主机的一种标识方法是用它 的<strong>主机名</strong>( hostname),这些名字便于记忆也乐于被人们接受。然而,主机名几平没有提供，况且,因为主机名可能由不定长的字母数字 组成,路由器难以处理。由于这些原因,主机也可以使用所谓<strong>IP地址</strong>( IP address)进行</p>
<h3 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h3><p>主机名到IP地址转换的目录服务——域名系统 ( Domain Name System,DNS)。</p>
<p>DNS是:</p>
<ul>
<li>①一个由分层的DNS服务器(DN server)实现的分布式数据库;</li>
<li><p>②一个使得主机能够査询分布式数据库的应用层协议。</p>
<p>DNS通常是由其他应用层协议所使用的,包括HTP、SMTP和FTP,将用户提供的主 机名解析为IP地址。</p>
<p>除了进行主机到IP地址的转换，DNS还提供了一些重要的服务：</p>
<ul>
<li>主机别名</li>
<li>邮件服务器别名</li>
<li>负载分配</li>
</ul>
</li>
</ul>
<h3 id="DNS工作原理概述"><a href="#DNS工作原理概述" class="headerlink" title="DNS工作原理概述"></a>DNS工作原理概述</h3><p>DNS的一种简单设计是在因特网上只使用一个DNS服务器,该服务器包含所有的映 射。在这种集中式设计中,客户直接将所有查询直接发往单一的DNS服务器,同时该 DNS服务器直接对所有的查询客户做出响应。尽管这种设计的简单性非常具有吸引力,但 它不适用于当今的因特网,因为因特网有着数量巨大(并持续增长)的主机这种集中式 设计的问题包括：</p>
<ul>
<li>单点故障( a single point of failure)，如果该DNS服务器崩溃,整个因特网随之 瘫痪! </li>
<li>通信容量( traffic volume)。单个DNS服务器不得不处理所有的DNS查询(用于为 上亿台主机产生的所有HTTP请求报文和电子邮件报文服务)</li>
<li>远距离的集中式数据库( distant centralized database)。单个DNS服务器不可能 “邻近”所有查询客户。如果我们将单台DNS服务器放在纽约市,那那么所有来自 澳大利亚的查询必须传播到地球的另一边边,中间也许还要经过低速和拥塞的链路。 这将导致严重的时延。</li>
<li>维护( maintenance)。单个DNS服务器将不得不为所有的因特网主机保留记录。</li>
</ul>
<p>在单一DNS服务器上运行集中式数据库完全没有可扩展能力。因此，DNS采用了分布式的设计方案：</p>
<ol>
<li>分布式，层次数据库</li>
</ol>
<p>为了处理扩展性问题,DNS使用了大量的DNS服务器,它们以层次方式组织,并且 分布在全世界范围内。没有一台DNS服务器拥有因特网上所有主机的映射。相反,该映射分布在所有的DNS服务器上。大致说来,有3种类型的DNS服务器:<strong>根DNS服务器、 顶级域DNS服务器和权威DNS服务器</strong>。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517829730009.jpg" alt="enter description here"></p>
<p>DNS查询有<strong>递归查询</strong>（recursive query）和<strong>迭代查询</strong>（iterative query）。</p>
<ol>
<li>DNS缓存</li>
</ol>
<p>为了改善时延性能并减 少在因特网上到处传输的DNS报文数量 DNS广泛使用了缓存技术。DNS缓存的原 理非常简单。在一个请求链中,当某DNS服务器接收一个DNS回答(例如,包含主 机名到IP地址的映射)时,它能将该回答 中的信息缓存在本地存储器中</p>
<p>由于主机和IP之间的映射并不是永久的，DNS服务器在一段时间将丢弃缓存信息。</p>
<h3 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h3><p>共同实现DNS分布式数据库的所有DNS服务器存储了<strong>资源记录</strong>( Resource Record, RR),RR提供了主机名到IP地址的映射。每个DNS回答报文包含了一条或多条资源记 录。</p>
<p>资源记录是一个包含了下列字段的4元组：<code>(Name, Value, Type, TTL)</code></p>
<p>TTL是该记录的生存时间,它决定了资源记录应当从缓存中删除的时间。</p>
<p>Name和 Value的值取决于Type: </p>
<ul>
<li>如果Type=A,则Name是主机名, Value是该主机名对应的P地址。因此,一条类型为A的资源记录提供了标准的主机名到IP地址的映射。</li>
<li>如果Type=NS,则Name是个域(如foo.com),而Vaue是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。</li>
<li>如果Type= CNAME,则 Value是别名为Name的主机对应的规范主机名。该记录 能够向查询的主机提供一个主机名对应的规范主机名</li>
<li>如果Type=MX,则 Value是个别名为Name的邮件服务器的规范主机名。</li>
</ul>
<blockquote>
<p>DNS 报文</p>
</blockquote>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517830574331.jpg" alt="enter description here"></p>
<h2 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h2><p>使用P2P体系结 构,对总是打开的基础设施服务器有最小的的(或者没有)依赖。与之相反,成对间歇连接 的主机(称为对等方)彼此直接通信。这些对等方并不为服务提供商所拥有,而是受用户 控制的桌面计算机和膝上计算机</p>
<h3 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h3><p>在客户-服务器文件分发中,该服务器必须向每个对等方发送该文件的一个副本,即服务 器承受了极大的负担,并且消消耗了大量的服务器带宽。在P2P文件分发中,每个对等方能 够重新分发它所有的该文件的任何部分,从而在分发过程程中协助该服务器。</p>
<p>到2012年止, 最为流行的P2P文件共享协议是 Bit Torrent。</p>
<blockquote>
<p>P2P体系结构的扩展性</p>
</blockquote>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517830919354.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517830933673.jpg" alt="enter description here"></p>
<blockquote>
<p>BitTorrent</p>
</blockquote>
<p>Bit Torrent是一种用于文件分发的流行P2P协议。用 Bittorrent的术语来 讲,参与一个特定文件分发的所有对等方的集合被称为一个<strong>洪流</strong>( torrent)。在一个洪流 中的对等方彼此下载等长度的<strong>文件块</strong>( chunk),典型的块长度为256KB。当一个对等方首次加入一个洪流时,它没有块。随着时间的流逝,它累积了越来越多的块。当它下载块 时,也为其他对等方上载了多个块。一旦某对等方获得了整个文件,它也许(自私地)离 开洪流,或(大公无私地)留在该洪流中并继续向其他对等方上载块。</p>
<p>每个洪流具有一个基础设施结点,称为<strong>追踪器</strong>( tracker)。当一个对等方加入 某洪流时,它向追踪器注册自己,并周期性地通知追踪器它仍在该洪流中。以这种方式, 追踪器跟踪正参与在洪流中的对等方。</p>
<p>对等方会周期性的询问每个邻近的对等方他们所具有的块列表。同时还要解决一些问题：第一,她应当从她的邻居请求哪些块呢?第二,她 应当向哪些向她请求块的邻居发送?</p>
<p>在决定请求哪些块的过程中,每一个对等方使用一种称为<strong>最稀缺优先</strong>( rarest first)的技术。这种技术的思路是,针对她没有的块在她的邻居中决定最 稀缺的块(最稀缺的块就是那些在她的邻居中副本数量最少的块),并首先请求那些最稀 缺的块。这样,最稀缺块得到更为迅速的重新分发,其目标是(大致地)均衡每个块在洪流中的副本数量。</p>
<h2 id="TCP-套接字编程"><a href="#TCP-套接字编程" class="headerlink" title="TCP 套接字编程"></a>TCP 套接字编程</h2><h3 id="UDP套接字编程"><a href="#UDP套接字编程" class="headerlink" title="UDP套接字编程"></a>UDP套接字编程</h3><p>发送进程为分组附上的目的地址是由目的主机的IP地址和目的套接字的端口号组成。</p>
<p>发送方的源地址也是由源主机的IP地址和源套接字的端口号组成</p>
<p>示例程序：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_7_1517978583354.jpg" alt="enter description here"></p>
<p>UDPclient.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 引入socket包，python网络通信的基础</span></div><div class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</div><div class="line"></div><div class="line"><span class="comment"># 提供IP地址（域名）和端口号</span></div><div class="line">serverName = <span class="string">'hostname'</span></div><div class="line">serverPort = <span class="number">12000</span></div><div class="line"></div><div class="line"><span class="comment"># 创建客户套接字，AF_INET表示底层网络使用IPv4，SOCK_DGRAM表示为UDP套接字</span></div><div class="line">clientSocket = socket(AF_INET, SOCK_DGRAM)</div><div class="line">message = raw_input(<span class="string">'Input lowercase sentence'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 向目的套接字发送</span></div><div class="line">clientSocket.sendto(message,(serverName,serverPort))</div><div class="line"></div><div class="line"><span class="comment"># 接收分组，取2048作为缓存输入</span></div><div class="line">modifiedMessage, serverAddress = clientSocket.recvform(<span class="number">2048</span>)</div><div class="line"></div><div class="line">print(modifiedMessage)</div><div class="line">clientSocket.close()</div></pre></td></tr></table></figure></p>
<p>UDPserver.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</div><div class="line"></div><div class="line">serverPort = <span class="number">12000</span></div><div class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</div><div class="line"></div><div class="line"><span class="comment"># 将服务器端口和套接字绑定在一起</span></div><div class="line">serverSocket.bind(<span class="string">''</span>, serverPort)</div><div class="line"></div><div class="line">print(<span class="string">"The server is ready to receive"</span>)</div><div class="line"><span class="keyword">while</span> ture:</div><div class="line">    message, clientAddress = serverSocket.recvform(<span class="number">2048</span>)</div><div class="line">    modifiedMessage = message.upper()</div><div class="line">    serverSocket.sendto(modifiedMessage, clientAddress)</div></pre></td></tr></table></figure></p>
<h3 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h3><p>与UDP不同，TCP是一个面向连接的协议。这意味着客户和服务器能够相互发送数据之前，他们要先握手创建一个TCP连接。</p>
<p>注意两点：<br>第一,与在UDP中的情况一样,TCP服务器在客户试图发起接触前必须作 为进程运行起来。<br>第二,服务器程序必须具有一扇特殊的门,更精确地说是一个特殊的套 接字,该门门欢迎来自运行在任意主机上的客户进程的某些初始接触。使用房子/门来比喻 进程/套接字,有时我们将客户的初始接触称为“敲欢迎之门”。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_7_1517979977215.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_7_1517980098223.jpg" alt="enter description here"></p>
<p>TCPclient.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</div><div class="line"></div><div class="line">serverName = <span class="string">'servername'</span></div><div class="line">serverPort = <span class="number">12000</span></div><div class="line"></div><div class="line">clientSocket = socket(AF_INET, SOCK_STREAM)</div><div class="line"><span class="comment"># 不同之处，传输数据之前要先进行连接</span></div><div class="line">clientSocket.connect((serverName, serverPort))</div><div class="line"></div><div class="line">sentence = raw_input(<span class="string">'Input lowercase sentence'</span>)</div><div class="line">clientSocket.send(sentence)</div><div class="line">modifiedSentence = clientSocket.recv(<span class="number">1024</span>)</div><div class="line"></div><div class="line">print(<span class="string">"From server:"</span>, modifiedSentence)</div><div class="line">clientSocket.close()</div></pre></td></tr></table></figure></p>
<p>TCPserver.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</div><div class="line"></div><div class="line">serverPort = <span class="number">12000</span></div><div class="line"><span class="comment"># 创建TCP套接字</span></div><div class="line">serverSocket = socket(AF_INET, SOCK_STREAM)</div><div class="line"></div><div class="line"><span class="comment"># serverSocket 是我们的欢迎套接字</span></div><div class="line">serverSocket.bind(<span class="string">''</span>, serverPort)</div><div class="line">serverSocket.lisetn(<span class="number">1</span>)</div><div class="line">print(<span class="string">"The server is ready to receive"</span>)</div><div class="line"></div><div class="line"><span class="keyword">while</span> ture:</div><div class="line">    <span class="comment"># 当客户端敲门时，创建一个服务的新套接字</span></div><div class="line">    connectionSocket ,addr = serverSocket.accept()</div><div class="line">    sentence = connectionSocket.recv(<span class="number">1024</span>)</div><div class="line">    capitalizedSentence = sentence.upper()</div><div class="line">    connectionSocket.sendto(capitalizedSentence)</div><div class="line">    connectionSocket.close()</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Network </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git 分支]]></title>
      <url>/2018/02/04/Git-%E5%88%86%E6%94%AF/</url>
      <content type="html"><![CDATA[<p>《Pro Git》读书笔记</p>
<p>接触Git这个工具已经很长一段时间了，用起来也是一直是半生不熟的状态，索性寒假有时间就系统的学习一下。选择的是《Pro Git》，讲解得非常详细的。</p>
<a id="more"></a>
<hr>
<p>几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。</p>
<p>Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。</p>
<h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><p>Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。</p>
<p>首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在Git 仓库中这些校验和保存为树对象。</p>
<p>Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。</p>
<p><strong>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。</strong></p>
<p>Git 又是怎么知道当前在哪一个分支上呢？也很简单，它有一个<strong>名为 HEAD 的特殊指针</strong>。请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 HEAD 概念完全不同。在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517735734642.jpg" alt="enter description here"></p>
<blockquote>
<p>分支切换会改变你工作目录中的文件</p>
</blockquote>
<p>在切换分支时，一定要注意你工作目录里的文件会被改变。如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。</p>
<p>由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。</p>
<h2 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h2><p>在切换分支的时候，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。最好的方法是，在你切换分支之前，保持好一个干净的状态。</p>
<p>请牢记：<strong>当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。</strong></p>
<p>在合并的时候，你应该注意到了”快进（fast-forward）”这个词。由于当前 master 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。</p>
<p>另外一种更加普遍的合并情况是：Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的工作祖先（C2），做一个简单的三方合并。</p>
<h3 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h3><p>如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。此时 Git 做了合并，但是没有自动地创建一个新的合并提交。Git 会暂停下来，等待你去解决合并产生的冲突。你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并</p>
<h2 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h2><h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p>在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517736327603.jpg" alt="enter description here"></p>
<h3 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517736357963.jpg" alt="enter description here"></p>
<h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p>在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517736500075.jpg" alt="enter description here"></p>
<p>如上图所示，提取在 C4 中引入的补丁和修改，然后在 C3 的基础上再应用一次。在 Git 中，这种操作就叫做 变基。</p>
<p>它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master）的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。</p>
<h3 id="更有趣的变基例子"><a href="#更有趣的变基例子" class="headerlink" title="更有趣的变基例子"></a>更有趣的变基例子</h3><p>在对两个分支进行变基时，所生成的“重演”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。就像 <strong>从一个特性分支里再分出一个特性分支</strong>的提交历史 中的例子这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rebase --onto master server client</div></pre></td></tr></table></figure>
<p>以上命令的意思是：“取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然后把它们在 master 分支上重演一遍”。这理解起来有一点复杂，不过效果非常酷。</p>
<p>使用 git rebase [basebranch] [topicbranch] 命令可以直接将特性分支（即本例中的 server）变基到目标分支（即 master）上。这样做能省去你先切换到server 分支，再对其执行变基命令的多个步骤。</p>
<h3 id="变基的风险"><a href="#变基的风险" class="headerlink" title="变基的风险"></a>变基的风险</h3><p>奇妙的变基也并非完美无缺，要用它得遵守一条准则：<strong>不要对在你的仓库外有副本的分支执行变基</strong>。</p>
<p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。</p>
<p>只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，你就不会有事。</p>
<h3 id="变基vs合并"><a href="#变基vs合并" class="headerlink" title="变基vs合并"></a>变基vs合并</h3><p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。它是针对历史的文档，本身就有价值，不能乱改。从这个角度看来，改变提交历史是一种亵渎，你使用<em>谎言</em>掩盖了实际发生过的事情。如果由合并产生的提交历史是一团糟怎么办？既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅</p>
<p>。另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的故事</strong>。没人会出版一本书的第一批草稿，软件维护手册也是需要反复修订才能方便使用。持这一观点的人会使用 rebase 及 filter-branch等工具来编写故事，怎么方便后来的读者就怎么写。</p>
<p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 并发编程]]></title>
      <url>/2018/02/03/CSAPP-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第12章笔记</p>
<a id="more"></a>
<p>如果逻辑流在时间上重叠，那么它们就是并发（concurrent）的。并发性不仅仅局限于内核，他也可以在应用中也扮演着重要的角色：</p>
<ul>
<li>在多处理器上进行并行计算</li>
<li>访问慢速I/O设备</li>
<li>与人交互</li>
<li>通过推迟工作以减少执行时间</li>
<li>服务多个网络客户端</li>
</ul>
<p>现代操作系统提供了三种基本的构造并发程序的方法：</p>
<ul>
<li>进程。用这种方法，每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显式的进程间通信(interprocess communication, IPC)机制。</li>
<li>I/O 多路复用。在这种形式的并发编程中，应用程序在一个进程的上下文中显式地调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一个状态。因为程序是一个单独的进程，所以所有的流都共享同一个地址空间。</li>
<li>线程。线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。你可以把线程看成是其他两种方式的混合体，像进程流一样由内核进行调度，而像 I/O 多路复用一样共享同一个虚拟地址空间。</li>
</ul>
<h2 id="基于线程的并发编程"><a href="#基于线程的并发编程" class="headerlink" title="基于线程的并发编程"></a>基于线程的并发编程</h2><p>构造并发程序最简单的方法就是用进程，使用那些大家都很熟悉的函数，像 fork, exec 和 waitpid。</p>
<p>对于在父、子进程间共享状态信息，进程有一个非常清晰的模型：<strong>共享文件表，但是不共享用户地址空间</strong>。进程有独立的地址空间既是优点也是缺点。这样一来，一个进程不可能不小心覆盖另一个进程的虚拟存储器，这就消除了许多令人迷惑的错误。</p>
<p>另一方面，<strong>独立的地址空间使得进程共享状态信息变得更加困难</strong>。为了共享信息，它们必须使用显式的 IPC 机制。基于进程的设计的另一个缺点是，它们往往比较慢，因为进程控制和 IPC 的开销很高。</p>
<h2 id="基于I-O多路复用的并发编程"><a href="#基于I-O多路复用的并发编程" class="headerlink" title="基于I/O多路复用的并发编程"></a>基于I/O多路复用的并发编程</h2><p>I/O 多路复用可以用作并发<strong>事件驱动</strong>(event-driven)程序的基础，在事件驱动程序中，流是因为某种事件而前进的。一般概念是将逻辑流模型化为<strong>状态机</strong>。不严格地说，一个状态机(state machine)就是一组状态(state)、输入事件(input event)和转移(transition)，其中转移就是将状态和输入事件映射到状态。每个状态都将一个(输入状态，输入事件)对映射到一个输出状态。自循环(self-loop)是同一组输入和输出状态之间的转移。通常把状态机花城有向图，其中节点表示状态，有向弧表示转移，而弧上的标号表示输入事件。一个状态机从某种初始状态开始执行。每个输入事件都会引发一个从当前状态到下一状态的转移。</p>
<p>事件驱动设计的一个优点是，它比基于进程的设计给了程序员更多的对程序行为的控制。另一个优点是在流之间共享数据变得很容易，而且事件驱动设计常常比基于进程的设计要高效得多，因为它们不需要进程上下文切换来调度新的流。</p>
<p>事件驱动设计的一个明显的缺点就是编码复杂，另一重大缺点时它们不能充分利用多核处理器。</p>
<h2 id="基于线程的并发编程-1"><a href="#基于线程的并发编程-1" class="headerlink" title="基于线程的并发编程"></a>基于线程的并发编程</h2><p>一个线程（thread）就是运行在一个进程上下文中的一个逻辑流。每个线程都有它自己的<strong>线程上下文</strong>(thread context)，包括一个唯一的整数线程ID(Thread ID, TID)、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。</p>
<p>基于线程的逻辑流结合了基于进程和基于I/O多路复用的流的特点</p>
<h3 id="线程执行模型"><a href="#线程执行模型" class="headerlink" title="线程执行模型"></a>线程执行模型</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517653797354.jpg" alt="enter description here"></p>
<h2 id="多线程程序中的共享变量"><a href="#多线程程序中的共享变量" class="headerlink" title="多线程程序中的共享变量"></a>多线程程序中的共享变量</h2><p>线程很有吸引力的一个方面就是多个线程很容易共享相同的程序变量</p>
<h3 id="线程存储器模型"><a href="#线程存储器模型" class="headerlink" title="线程存储器模型"></a>线程存储器模型</h3><p>一组并发线程运行在一个进程的上下文中。每个线程都有它自己独立的线程上下文，包括线程 ID、栈、栈指针、程序计数器、条件码和通用目的寄存器。每个线程和其他线程一个共享进程上下文的剩余部分。这包括整个用户虚拟地址空间，它是由只读文本(代码)、读/写数据、堆以及所有的共享库代码和数据区域组成的。</p>
<p>从实际操作的角度来说，让一个线程去读写另一个线程的寄存器是不可能的。寄存器不是共享的，而虚拟存储器是共享的。</p>
<h3 id="将变量映射到存储器"><a href="#将变量映射到存储器" class="headerlink" title="将变量映射到存储器"></a>将变量映射到存储器</h3><p>线程化的 C 程序中变量根据它们的存储类型被映射到虚拟存储器：</p>
<ul>
<li>全局变量：在运行时，虚拟存储器的读/写区域只包含每个全局变量的一个实例，任何线程都可以引用</li>
<li>本地自动变量：定义在函数内部但是没有 static 属性的变量。在运行时，每个线程的栈都包含它自己的所有本地自动变量的实例</li>
<li>本地静态变量：定义在函数内部并有 static 属性的变量，和全局变量一样</li>
</ul>
<h2 id="用信号量同步线程"><a href="#用信号量同步线程" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h2><p>共享变量十分方便，但是它们也引入了同步错误（synchronization error）的可能性。</p>
<h3 id="进度图"><a href="#进度图" class="headerlink" title="进度图"></a>进度图</h3><p>一个进度图( progress graph)将个并发线程的执行模型化为一条维笛卡儿空间中的轨线。 每条轴k对应于线程k的进度。每个点(1,2…,n)代表线程k(k=1,,n)已经完成了指令I(k)这一个状态</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517654269007.jpg" alt="enter description here"></p>
<p>一个进度图将指令执行模型化为一个从一种状态到另一种状态的转換( transition)。一个转换被 表示为一条从一点到相邻点的有向边。合法的转换是向右(线程1中的一条指令完成)或者向上(线 程2中的一条指令完成)的。两个指令不能在同一时刻完成一一对角线转換是不允许的。程序决不 会反向运行,所以向下或者向左移动的转换也是不合法的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517654474783.jpg" alt="enter description here"></p>
<p>环绕不安全区的轨线叫做<strong>安全轨线</strong>( safe trajectory)。相反,接触任何不安全区的轨线就叫做<strong>不安全轨线</strong>( unsafe trajectory)。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517654599444.jpg" alt="enter description here"></p>
<p>任何安全轨迹都将正确地更新共享计数器。</p>
<h3 id="利用信号量访问共享变量"><a href="#利用信号量访问共享变量" class="headerlink" title="利用信号量访问共享变量"></a>利用信号量访问共享变量</h3><p>一种经典的解决同步不同执行线程问题的方法：基于一种叫做信号量( semaphore)的特殊类型变量的。信号量s是具有非负整数值的全局变量,只能由两种特殊的操作来处理,这两种操作称为P和V。</p>
<ul>
<li>P(s):如果s是非零的,那么P将s减1,并且立即返回。如如果s为零,那么就挂起进程, 直到s变为非零,并且该进程被一个V操作重启。在重启之后,P操作将s减1,并将控制 返回给调用者。 </li>
<li>V(s):操作将s加1。如果有任何进程阻塞在P操作等待s变成非零,那么V操作会重启 这些进程中的一个,然后该进程将s减1,完成它的P操作</li>
</ul>
<p>P和和V的定义确保了一个运行程序绝不可能进入这样一种状态,也就是一个正确初始化了的信 号量有一个负值。这个属性称为信号量不变性( semaphore invariant),为控制并发程序的轨线而避 免不安全区提供了强有力的工具。 </p>
<p>基本的思想是将每个共享变量(或者相关共享变量集合)与一个信号量s(初始为1)联系起来, 然后用P(s)和W(s)操作将相应的临界区包围起来。以这种方式来保护共享变量的信号量叫做二进制 信号量( binary semaphore),因为它的值总是0或者1。</p>
<h3 id="利用信号量来调度共享资源"><a href="#利用信号量来调度共享资源" class="headerlink" title="利用信号量来调度共享资源"></a>利用信号量来调度共享资源</h3><p>信号量另一个重要的作用是调度对共享资源的访问，一个线程用信号量来通知另一个线程，程序状态中的某个量已经为真了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517654937600.jpg" alt="enter description here"></p>
<h2 id="其他并发性问题"><a href="#其他并发性问题" class="headerlink" title="其他并发性问题"></a>其他并发性问题</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>当我们用线程编写程序时,我们必须小心地编写那些具有称为线程安全性( thread safety)属性 的函数。一个函数被称为线程安全的( thread- safe),当且仅当被<strong>多个并发线程反复地调用时,它会 一直产生正确的结果</strong>。如果一个函数不是线程安全的,我们就说它是线程不安全的( thread-unsafe)。 我们能够定义出四类(有相交的)线程不安全函数:</p>
<ul>
<li>不保护共享变量的函数</li>
<li>保持跨越多个调用的状态的函数</li>
<li>返回指向静态变量的指针函数</li>
<li>调用线程不安全函数的函数</li>
</ul>
<h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>有一类重要的线程安全函数,叫做<strong>可重入函数</strong>( reentrant function),其特点在于它们具有这样 种属性:<strong>当它们被多个线程调用时,不会引用任何共享数据。</strong></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517655306363.jpg" alt="enter description here"></p>
<h3 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h3><p>当一个程序的正确性依赖于一个线程要在另一个线程到达y点之前到达它的控制流中的x点时, 就会发生<strong>竞争</strong>(race)。通常发生竟争是因为程序员假定线程将按照某种特殊的轨线穿过执行状态空 间,而忘记了另一条准则规定定:多线程程序必须对任何可行的轨线都正确工作。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>一组线程被阻塞了，等待一个永远也不会为真的条件</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517655428227.jpg" alt="enter description here"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>无论哪种并发机制，同步对于共享数据的并发访问都是一个困难的问题。提出对信号的 P 和 V 操作就是为了帮助解决这个问题。信号量操作可以用来提供对共享数据的互斥访问，也对诸如生产者-消费者程序中有限缓冲区和读者-写者系统中的共享对象这样的资源访问进行调度。</p>
<p>并发也引入了其他一些困难的问题。被线程调用的函数必须具有一种称为线程安全的属性。竞争和死锁是并发程序中出现的另一些困难的问题。当程序员错误地假设逻辑流该如何调度时，就会发生竞争。当一个流等待一个永远不会发生的事件时，就会产生死锁。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 网络编程]]></title>
      <url>/2018/02/02/CSAPP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第11章笔记</p>
<a id="more"></a>
<p>网络应用随处可见。有趣的是，所有的网络应用都是基于相同的基本编程模型，有着相似的整体逻辑结构，并且一来相同的编程接口。</p>
<p>网络应用依赖于很多在系统研究正已经学习过的概念，例如，进程、信号、字节顺序、存储器映射以及动态存储分配，都扮演着重要的角色。</p>
<h2 id="客户端-服务器编程模型"><a href="#客户端-服务器编程模型" class="headerlink" title="客户端-服务器编程模型"></a>客户端-服务器编程模型</h2><p>每一个网络应用都是基于<code>客户端-服务器模型</code>的，采用这个模型，一个应用是由一个服务器进程和一个或者多个客户端进程组成。服务器管理某种资源，并且通过操作这种资源来为它的客户端提供某种服务。</p>
<p>客户端-服务器模型中的基本操作时<strong>事务（ttansaction）</strong>。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540316932.jpg" alt="enter description here"></p>
<p>认识到客户端和服务器是进程，而不是机器或者主机，这一点很重要。</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>客户端和服务器通常运行在不同的主机上，并且通过<strong>计算机网络</strong>的硬件和软件资源来通信。对于一台主机而言，网络只是又一种 I/O 设备，作为数据源和数据接收方，如下图所示。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540421619.jpg" alt="enter description here"></p>
<p>物理上而言，网络是一个按照地理远近组成的层次系统。最底层是 LAN(Local Area Network, 局域网)，在一个建筑或者校园范围内。迄今为止，最流行的局域网技术是以太网(Ethernet)。</p>
<p>每个以太网适配器都有一个全球唯一的 48 位地址，一台主机可以发送一段位，称为帧(frame)，到这个网段内的其他任何主机。每个帧包括一些固定数量的头部(header)位，用来标识此帧的源和目的地址以及此帧的长度，伺候紧随的就是数据位的有效载荷。每个主机适配器都能看到这个帧，但是只有目的主机实际读取它。</p>
<p>使用一些电缆和叫做网桥(bridge)的小盒子，多个以太网段可以连接成较大的局域网，称为<strong>桥接以太网</strong>(bridged Ethernet)，如下图所示：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540470497.jpg" alt="enter description here"></p>
<p>在层次更高的级别中，多个不兼容的局域网可以通过叫做<strong>路由器</strong>(router)的忒书计算机连接起来，组成一个internet(互联网络)。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540536223.jpg" alt="enter description here"></p>
<p>internet（互联网络）至关重要的特性是，它能采用完全不同和不兼容技术的各种局域网和广域网组成。</p>
<p>在互联网中，数据是如何从一台主机传送到另一台主机的：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540792401.jpg" alt="enter description here"></p>
<h2 id="全球IP因特网"><a href="#全球IP因特网" class="headerlink" title="全球IP因特网"></a>全球IP因特网</h2><p>协议软件消除了不同网络之间的差异，必须具备两种基本能力：命名机制和传送机制。</p>
<p>每台因特网主机都运行实现 <strong>TCP/IP 协议</strong>(Transmission Control Protocol/Internet Protocol)的软件，几乎每个现代计算机系统都支持这个协议。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540858886.jpg" alt="enter description here"></p>
<p>TCP/IP 实际上是一个协议族，其中每一个都提供不同的功能。从程序员角度，我们可以把因特网看做一个世界范围的主机集合，满足以下特性：</p>
<ul>
<li>主机集合被映射为一组 32 位的 IP 地址</li>
<li>这组 IP 地址被映射为一组称为因特网域名(Internet domain name)的标识符</li>
<li>因特网主机上的进程能够通过连接(connection)和任何其他因特网主机上的进程通信</li>
</ul>
<h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p> 一个 IP 地址就是一个 32 位无符号整数。IP 地址通常是以一种称为点分十进制表示法来表示的，这里，每个字节由它的十进制值表示，并且用句点和其他字节间分开。</p>
<h3 id="因特网域名"><a href="#因特网域名" class="headerlink" title="因特网域名"></a>因特网域名</h3><p>域名集合形成了一个层次结构，每个域名编码了它在这个层次中的位置。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540938762.jpg" alt="enter description here"></p>
<p>因特网定义了域名集合和IP地址集合之间的映射，这个映射是通过分布世界范围内的数据库——DNS（域名系统）来维护的。</p>
<h3 id="因特网连接"><a href="#因特网连接" class="headerlink" title="因特网连接"></a>因特网连接</h3><p>因特网客户端和服务器通过在连接上发送和接收字节流来通信。从连接一对进程的意义上而言，连接是点对点的。从数据可以同时双向流动的角度来说，它是全双工的。并且由源进程发出的字节流最终被目的进程以它发出的顺序收到它的角度来说，它是可靠的。</p>
<p><strong>一个套接字是连接的一个端点</strong>。每个套接字都有相应的套接字地址，是由一个因特网地址和一个 16 位的整数端口组成的，用地址:端口来表示。当客户端发起一个连接请求时，客户端套接字地址中的端口是由内核自动分配的，称为临时端口(ephemeral port)。然而，服务器套接字地址中的端口通常是某个知名的端口，是和这个服务相对应的。例如，Web 服务器通常使用端口 80，而电子邮件服务器使用端口 25。在 Unix 机器上，文件 /etc/services 包含一张这台机器提供的服务以及它们的知名端口号的综合列表。</p>
<p>一个连接由它两端的套接字地址唯一确定。这对套接字地址叫做套接字对(socket pair)，由下列元组来表示：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517541075440.jpg" alt="enter description here"></p>
<h2 id="套接字接口"><a href="#套接字接口" class="headerlink" title="套接字接口"></a>套接字接口</h2><p><strong>套接字接口</strong>(socket interface)是一组函数，它们和 Unix I/O 函数结合起来，用以创建网络应用。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517541130564.jpg" alt="enter description here"></p>
<h2 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h2><h3 id="Web基础"><a href="#Web基础" class="headerlink" title="Web基础"></a>Web基础</h3><p>Web 客户端和服务器之间的交互用的是一个基于文本的应用级协议，叫做 HTTP(Hypertext Transfer Protocol)。HTTP 是一个简单的协议。一个 Web客户端打开一个到服务器的因特网连接，并且请求某些内容。服务器响应所请求的内容，然后关闭连接。浏览器读取这些内容，并把它显示在屏幕上。</p>
<h3 id="Web内容"><a href="#Web内容" class="headerlink" title="Web内容"></a>Web内容</h3><p>对于 Web 客户端和服务器而言，内容是一个与 MIME(Multipurpose Internet Mail Extensions)类型相关的字节序列。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517541249812.jpg" alt="enter description here"></p>
<p>Web 服务器以两种不同的方式向客户端提供内容：</p>
<ul>
<li>取一个磁盘文件，并将它的内容返回给客户端。磁盘文件称为静态内容(static content)，而返回文件给客户端的过程称为服务静态内容(serving static content)。</li>
<li>运行一个可执行文件，并将它的输出返回给客户端。运行时可执行文件产生的输出称为动态内容(dynamic content)，而运行程序并返回它的输出到客户端的过程称为服务动态内容(serving dynamic content)。</li>
</ul>
<p>每条由 Web 服务器返回的内容都是和它管理的某个文件相关联的。这些文件中的每一个都有一个唯一的名字，叫做 URL(Universal Resource Locator)。</p>
<p>关于服务器如何解释一个 URL 的后缀，以下几点需要理解：</p>
<ul>
<li>确定一个 URL 指向的是静态内容还是动态内容没有标准的规则。每个服务器对它所管理的文件都有自己的规则。一种常见方法是，确定一组目录，例如 cgi-bin，所有的可执行文件都必须存放这些目录中。</li>
<li>后缀中的最开始的那个 / 不表示 Unix 的根目录。相反，它表示的是被请求内容类型的主目录。例如，可以将一个服务器配置成这样：所有的静态内容存放在目录 /usr/httpd/html 下。</li>
<li>最小的 URL 后缀是 / 字符，所有服务器将其扩展为某个默认的主页，例如 /index.html。这解释了为什么在浏览器中键入一个域名就可以取出一个网站的主页。浏览器在 URL 后添加缺失的 /，之后服务器把 / 扩展到某个默认的文件名。</li>
</ul>
<h3 id="HTTP事务"><a href="#HTTP事务" class="headerlink" title="HTTP事务"></a>HTTP事务</h3><p>因为 HTTP 是基于在因特网连接上传送的文本行的，我们可以使用 Unix 的 TELNET 程序来和因特网上的任何 Web 服务器执行事务。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Web 服务器使用 HTTP 协议和它们的客户端彼此通信。浏览器向服务器请求静态或者动态内容。CGI 标准提供了一组规则，来管理客户端如何将程序参数传递给服务器，服务器如何将这些参数以及其他信息传递给子进程，以及子进程如何将它的输出发送会客户端</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 系统级I/O]]></title>
      <url>/2018/02/01/CSAPP-%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第10章笔记</p>
<a id="more"></a>
<p>输入/输出（I/O）是在主存（memory）和外部设备之间拷贝数据的过程。输入数据是从I/O设备拷贝数据到主存，输出数据是从主存拷贝数据到I/O设备。</p>
<h2 id="Unix-I-O"><a href="#Unix-I-O" class="headerlink" title="Unix I/O"></a>Unix I/O</h2><p>所有的的I/O设备都模型化为文件，而所有的输入和输出都当作相应文件的读和写来执行。</p>
<p>所有的输入输出都以一种统一且一致的方式来执行：</p>
<ul>
<li>打开文件</li>
<li>改变当前的文件位置</li>
<li>读写文件</li>
<li>关闭文件</li>
</ul>
<h2 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h2><p>open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符</p>
<h2 id="读和写文件"><a href="#读和写文件" class="headerlink" title="读和写文件"></a>读和写文件</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_1_1517479720893.jpg" alt="enter description here"></p>
<p><code>read</code>函数从描述符为fd的当前文件位置拷贝至多n个字节到存储器位置buf。</p>
<p><code>write</code> 函数从存储器位置拷贝至多n个字节到描述符fd的当前文件位置</p>
<p>通过调用<code>lseek</code>函数，应用程序能够显式地修改当前文件的位置</p>
<h2 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h2><p>可以用许多不同的方式来共享 Unix 文件。内核用三个相关的数据结构来表示打开的文件：</p>
<ul>
<li><strong>描述符表</strong>(descriptor table)。每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表指向文件表中的一个表项。</li>
<li><strong>文件表</strong>(file table)。打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项包括当前的文件位置、引用计数(reference count)，以及一个指向 v-node 表中对应表项的指针。</li>
<li><strong>v-node 表</strong>(v-node table)。同文件表一样，所有的进程共享这张表。每个表项包含 stat 结构中的大多数信息。</li>
</ul>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_1_1517479945102.jpg" alt="典型的打开文件的内核数据结构"></p>
<p>多个描述符也可以通过不同的文件表表项来引用同一个文件</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_1_1517480013346.jpg" alt="enter description here"></p>
<p>子进程继承父进程打开文件</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_1_1517480058326.jpg" alt="enter description here"></p>
<h2 id="I-O重定向"><a href="#I-O重定向" class="headerlink" title="I/O重定向"></a>I/O重定向</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_1_1517480099251.jpg" alt="enter description here"></p>
<h2 id="我们该使用哪些I-O函数"><a href="#我们该使用哪些I-O函数" class="headerlink" title="我们该使用哪些I/O函数"></a>我们该使用哪些I/O函数</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_1_1517480139110.jpg" alt="enter description here"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Unix 提供了少量的系统级函数，它们允许应用程序打开、关闭、读和写文件，提取文件的元数据，以及执行 I/O 重定向。 Unix 的读和写操作会出现不足值，应用程序必须能正确地预计和处理这种情况。应用程序不应直接调用 Unix I/O 函数，而应该使用 RIO 包，RIO 包通过反复执行读写操作，直到传送完所有的请求数据，自动处理不足值。</p>
<p>Unix 内核使用三个相关的数据结构来表示打开的文件。描述符表中的表项指向打开文件表中的表项，而打开文件表中的表项又指向 v-node 表中的表项。</p>
<p>标准 I/O 库是基于 Unix I/O 实现的，并提供了一组强大的高级 I/O 例程。对于大多数应用程序而言，标准 I/O 更简单，是优于 Unix I/O 的选择。然而，因为对标准 I/O 和网络文件的一些相互不兼容的限制，Unix I/O 比标准 I/O 更适用于网络应用程序。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 虚拟存储器]]></title>
      <url>/2018/01/31/CSAPP-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第9章笔记</p>
<a id="more"></a>
<p>一个系统中的进程是与其他进程共享 CPU 和主存资源的。然而，共享主存会形成一些特殊的挑战。随着对 CPU 需求的增长，进程以某种合理的平滑方式慢了下来。但是如果太多的进程需要太多的存储器，那么它们中的一些就根本无法运行。当一个程序没有空间可用时，那就是它运气不好了。存储器还很容易被破坏。如果某个进程不小心写了另一个进程使用的存储器，它就可能以某种完全和程序逻辑无关的令人迷惑的方式失败。</p>
<p>为了更加有效地管理存储器并且少出错，现代系统提供了一种对主存的抽象概念，叫做<strong>虚拟存储器</strong>(VM)。虚拟存储器是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟存储器提供了三个重要的能力：1）它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。2）它为每个进程提供了一致的地址空间，从而简化了存储器管理。3）它保护了每个进程的地址空间不被其他进程破坏。</p>
<p>虚拟存储器是计算机系统最重要的概念之一。它成功的一个主要原因就是因为它是沉默地、自动地工作的，不需要应用程序员的任何干涉。</p>
<h2 id="物理和虚拟寻址"><a href="#物理和虚拟寻址" class="headerlink" title="物理和虚拟寻址"></a>物理和虚拟寻址</h2><p>计算机系统的主存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的<strong>物理地址</strong>(Physical Address, PA)。第一个字节的地址为 0，接下来的字节地址为 1，再下一个为 2，以此类推。给定这种简单的结构，CPU 访问存储器的最自然的方式就是使用物理地址。我们把这种方式称为<strong>物理寻址</strong>(physical addressing)。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403129993.jpg" alt="enter description here"></p>
<p>现代处理器使用的是一种称为<strong>虚拟寻址</strong>(virtual addressing)的寻址形式</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403182759.jpg" alt="enter description here"></p>
<h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p><strong>地址空间</strong>(address space)是一个非负整数地址的有序集合：{0, 1, 2, …}。如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间(linear address space)。</p>
<p>地址空间的概念是很重要的，因为它清楚地区分了数据对象(字节)和它们的属性(地址)。</p>
<p>允许每个数据对象有多个独立的地址，其中每一个地址都选自一个不同的地址空间。这就是虚拟存储器的基本思想</p>
<h2 id="虚拟存储器作为缓存的工具"><a href="#虚拟存储器作为缓存的工具" class="headerlink" title="虚拟存储器作为缓存的工具"></a>虚拟存储器作为缓存的工具</h2><p>概念上而言，虚拟存储器(VM)被组织为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，这个唯一的虚拟地址是作为到数组的索引的。VM 系统通过将虚拟存储器分割为虚拟页(Virtual Page, VP)的大小固定的块来处理这个问题。每个虚拟页的大小为 P=2^p 字节。类似地，物理存储器被分割为物理页(Physical Page, PP)，大小也为 P 字节(物理页也称为页帧(page frame))。</p>
<p>在任意时刻，虚拟页面的集合部分都分为三个不相交的子集：</p>
<ul>
<li>未分配的：VM 系统还未分配(或者创建)的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。</li>
<li>缓存的：当前缓存在物理存储器中的已分配页。</li>
<li>未缓存的：没有缓存在物理存储器中的已分配页。</li>
</ul>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403393083.jpg" alt="enter description here"></p>
<h3 id="DRAM高速缓存的组织结构"><a href="#DRAM高速缓存的组织结构" class="headerlink" title="DRAM高速缓存的组织结构"></a>DRAM高速缓存的组织结构</h3><p>在存储层次结构中，DRAM缓存的位置对于他的组织结构有很大的影响。DRAM 缓存的组织结构完全是由巨大的不命中开销驱动的。因为大的不命中处罚和访问第一字节的开销，虚拟页往往很大，典型地是4KB-2MB。由于大的不命中处罚，DRAM 缓存是全相连的，也就是说，任何虚拟页都可以放置在任何的物理页中。不命中时的替换策略也很重要，因为替换错了虚拟页的出发也非常高。因此，与硬件对 SRAM 缓存相比，操作系统对 DRAM 缓存使用了更复杂精密的替换算法。最后，因为对磁盘的访问时间很长，DRAM 缓存总是使用写回(write back)，而不是直写。</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>同任何缓存一样，虚拟存储器系统必须有某种方法来判定一个虚拟页是否存放在 DRAM 中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理存储器中选择一个牺牲页，并将虚拟页从磁盘拷贝到 DRAM 中，替换这个牺牲页。</p>
<p>这些功能是由许多软硬件联合提供的，包括操作系统软、MMU(存储器管理单元)中的地址翻译硬件和一个存放在物理存储器中叫做<strong>页表</strong>(page table)的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时都会读取页表。操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。</p>
<p>下图展示了一个页表的基本组织结构。页表就是一个页表条目(Page Table Entry, PTE)的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403685361.jpg" alt="enter description here"></p>
<h3 id="页命中"><a href="#页命中" class="headerlink" title="页命中"></a>页命中</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403740507.jpg" alt="enter description here"></p>
<h3 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h3><p>在虚拟存储器的习惯说法中，DRAM不命中称为<strong>缺页</strong>（page fault）。缺页异常调用内核中缺页异常处理程序，该程序会选择一个牺牲页。在磁盘和存储器之间传送页的活动叫做<strong>交换</strong>(swapping)或者<strong>页面调度</strong>(paging)。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403893776.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403911509.jpg" alt="enter description here"></p>
<h3 id="分配页面"><a href="#分配页面" class="headerlink" title="分配页面"></a>分配页面</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403947855.jpg" alt="enter description here"></p>
<h3 id="局部性再次搭救"><a href="#局部性再次搭救" class="headerlink" title="局部性再次搭救"></a>局部性再次搭救</h3><p>尽管在整个运行过程中程序引用的不同页面的总数可能超出物理存储器总的大小，但是局部性原则保证了在任意时刻，程序往往在一个较小的活动页面(active page)集合上工作，这个集合叫做<strong>工作集</strong>(working set)或者<strong>常驻集</strong>(resident set)。</p>
<p>如果工作集的大小超出了物理存储器的大小，那么程序将产生一种不幸的状态，叫做颠簸（thrashing），这时页面将不断的换进换出。</p>
<h2 id="虚拟存储器作为存储管理的工具"><a href="#虚拟存储器作为存储管理的工具" class="headerlink" title="虚拟存储器作为存储管理的工具"></a>虚拟存储器作为存储管理的工具</h2><p>OS为每个进程提供一个独立的页表，就是一个独立的虚拟地址空间。多个虚拟页面可以映射到同一个共享物理页面上。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404196815.jpg" alt="enter description here"></p>
<h2 id="虚拟存储器作为存储器保护的工具"><a href="#虚拟存储器作为存储器保护的工具" class="headerlink" title="虚拟存储器作为存储器保护的工具"></a>虚拟存储器作为存储器保护的工具</h2><p>任何现代计算机系统都必须为操作系统提供手段来控制对存储器系统的访问。提供独立地址空间使得分离不同进程私有存储器变得容易。地址翻译机制可以以一种自然的方式扩展到提供更好的访问控制。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404420646.jpg" alt="enter description here"></p>
<h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>地址翻译的基础知识：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404559355.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404669578.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404692161.jpg" alt="enter description here"></p>
<h3 id="结合高速缓存和虚拟存储器"><a href="#结合高速缓存和虚拟存储器" class="headerlink" title="结合高速缓存和虚拟存储器"></a>结合高速缓存和虚拟存储器</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404781626.jpg" alt="enter description here"></p>
<h3 id="利用TLB加速地址翻译"><a href="#利用TLB加速地址翻译" class="headerlink" title="利用TLB加速地址翻译"></a>利用TLB加速地址翻译</h3><p>TLB是一个小的、虚拟地址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常有高度的相连性。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404914871.jpg" alt="enter description here"></p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404952385.jpg" alt="enter description here"></p>
<h2 id="存储器映射"><a href="#存储器映射" class="headerlink" title="存储器映射"></a>存储器映射</h2><p>Linux通过将一个 虚拟存储器区域与一个磁盘上的对象关联起来，以初始化这个虚拟存储器区域的内容，这个过程叫存储器映射（memory mapping）<br>虚拟存储器区域可以映射到两种类型的对象：</p>
<ol>
<li>Unix文件系统的普通文件</li>
<li>匿名文件</li>
</ol>
<h3 id="再看共享对象"><a href="#再看共享对象" class="headerlink" title="再看共享对象"></a>再看共享对象</h3><p>存储器映射的概念来源于一个聪明的发现：如果虚拟存储器系统可以集成到传统的文件系统中，那么就能提供一种简单而高效的把程序和数据加载到存储器中的方法。</p>
<p>一个对象可以被映射到虚拟存储器中的一个区域，要么作为共享对象，要么作为私有对象。另一个方面，对于一个映射到私有对象的区域所做的改变，对于其他进程来说是不可见的，而且进程对这个区域所做的任何写操作都不会反映在磁盘的对象中。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517405449818.jpg" alt="enter description here"></p>
<p>私有对象是使用一种写时拷贝（copy-on-write）的巧妙技巧被映射虚拟存储器中的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517405536089.jpg" alt="enter description here"></p>
<h2 id="动态存储器分配"><a href="#动态存储器分配" class="headerlink" title="动态存储器分配"></a>动态存储器分配</h2><p>一个动态存储器分配器维护着一个进程的虚拟存储器区域，称为堆（heap）。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517405624725.jpg" alt="enter description here"></p>
<p>显式分配器要求应用显式地释放任何已经分配的块</p>
<p>隐式分配器要求检测何时一个已分配块不再被使用，然后就释放这个块。隐式分配器也叫做垃圾收集器（garbage collector）</p>
<h3 id="为什么要使用动态存储器分配"><a href="#为什么要使用动态存储器分配" class="headerlink" title="为什么要使用动态存储器分配"></a>为什么要使用动态存储器分配</h3><p>经常直到程序运行时，才知道某些数据结构的大小</p>
<h3 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h3><p>造成堆利用率低的主要原因是碎片（fragmentation），当虽然有未使用的存储器但是不能用来满足分配请求时，就发生这种现象。有两种碎片形式：<strong>内部碎片</strong>（internal fragmentation）和<strong>外部碎片</strong>（external fragmentation）：</p>
<ul>
<li>内部碎片是在一个已分配块比有效载荷大时发生的。</li>
<li>外部碎片是当空闲存储器合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生的。</li>
</ul>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>垃圾收集器（garbage collector）是一种动态存储分配器，它自动释放程序不在需要的已分配块。</p>
<h3 id="垃圾收集器的基本要素"><a href="#垃圾收集器的基本要素" class="headerlink" title="垃圾收集器的基本要素"></a>垃圾收集器的基本要素</h3><p>垃圾收集器将存储器视为一张有向可达图（reachability graph）</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517406251592.jpg" alt="enter description here"></p>
<h2 id="C程序中常见的与存储器相关的错误"><a href="#C程序中常见的与存储器相关的错误" class="headerlink" title="C程序中常见的与存储器相关的错误"></a>C程序中常见的与存储器相关的错误</h2><ul>
<li>间接引用坏指针</li>
<li>读未初始化的存储器</li>
<li>允许栈缓冲区溢出</li>
<li>假设指针和他们指向的对象是相同大小的</li>
<li>造成错位错误</li>
<li>引用指针而不是他们指向的对象</li>
<li>误解指针运算</li>
<li>引用不存在的变量</li>
<li>引用空闲堆块中的数据</li>
<li>引起存储器泄露</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虚拟存储器是对主存的一个抽象，支持虚拟存储器的处理器通过一种叫做虚拟寻址的间接引用来引用主存</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 异常控制流]]></title>
      <url>/2018/01/30/CSAPP-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第8章笔记</p>
<a id="more"></a>
<p>处理器按照一定的序列的地址执行对应的指令，从这一个地址过渡到下一个地址成为控制转移，这样的控制转移序序列称为处理器的控制流（flow control）</p>
<p>系统必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。当子进程终止时，创造这些子进程的父进程必须得到通知。</p>
<p>线代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为<strong>异常控制流</strong>(Exceptional Control Flow, ECF)。异常控制流发生在计算机系统的各个层次。比如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文转换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送信号到另一个进程，而接受者会将控制突然转移到它的一个信号处理程序。一个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常是异常控制流的一种形式，它一部分是由硬件实现的，一部分是由操作系统实现的。因为它们有一部分是由硬件实现的，所以具体细节将随系统的不同而有所不同。然而，对于每个系统而言，基本的思想都是相同的。</p>
<p>异常(exception)就是控制流中的突变，用来响应处理器状态中的某些变化。如下图所示：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517298145936.jpg" alt="enter description here"></p>
<p>在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做<strong>异常表</strong>(exception table)的跳转表，进行一个间接过程调用(异常)，到一個专门设计用来处理这类事件的操作系统子程序(异常处理程序, exception handler)</p>
<p>当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下三种情况中的一种：</p>
<ul>
<li>处理程序将控制返回给当前指令 I(curr)，即当事件发生时正在执行的指令。</li>
<li>处理程序将控制返回给 I(next)，即如果没有发生异常将会执行的下一条指令。</li>
<li>处理程序被中断的程序</li>
</ul>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>系统中可能的每种类型的异常都分配了一个唯一的非负整数的<strong>异常号</strong>(exception number)。其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核的设计者分配的。前者的示例包括被零除、缺页、存储器访问违例以及算术溢出。后者的示例包括系统调用和来自外部 I/O 设备的信号。</p>
<p>在系统启动时，操作系统分配和初始化一张称为异常表的跳转表，使得条目 k 包含异常 k 的处理程序的地址。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517299098759.jpg" alt="enter description here"></p>
<p>异常号是到异常表中的索引，异常表的起始地址放在一个叫做<strong>异常表基址寄存器</strong>(exception table base register)的特殊 CPU 寄存器里。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517299181611.jpg" alt="enter description here"></p>
<h3 id="异常的类别"><a href="#异常的类别" class="headerlink" title="异常的类别"></a>异常的类别</h3><p>异常可以分为四类：中断（interrupt）、陷阱（trap）、故障（fault）和终止（abort）</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517299300222.jpg" alt="enter description here"></p>
<blockquote>
<p>中断</p>
</blockquote>
<p>中断是异步发生的，是来自处理器外部的 I/O 设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序通常称为中断处理程序(interrupt handler)</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517299374198.jpg" alt="enter description here"></p>
<p>剩下的异常类型(陷阱、故障和终止)是同步发生的，是执行当前指令的结果。我们把这类指令叫做故障指令(faulting instruction)。</p>
<blockquote>
<p>陷阱</p>
</blockquote>
<p>陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做<strong>系统调用</strong>。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517299528855.jpg" alt="enter description here"></p>
<blockquote>
<p>故障</p>
</blockquote>
<p>故障由错误情况引起，它可能被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的 abort 例程，abort 例程会终止引起故障的应用程序</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517299611720.jpg" alt="enter description here"></p>
<p>一个经典的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在存储器中，因此必须从磁盘中取出时，就会发生故障。就像我们将在第 9 章中看到的那样，一个页面就是虚拟存储器的一个连续的块。缺页处理程序从磁盘加载适当的页面，然后将控制返回给引起故障的指令。当指令再次执行时，相应的物理页面已经驻留在存储器中了，指令就可以没有故障地运行完成了。</p>
<blockquote>
<p>终止</p>
</blockquote>
<p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 DRAM 或者 SRAM 位被损坏时发生的奇偶错误。终止程序从不将控制返回给应用程序。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517299685578.jpg" alt="enter description here"></p>
<h3 id="Intel处理器中的异常"><a href="#Intel处理器中的异常" class="headerlink" title="Intel处理器中的异常"></a>Intel处理器中的异常</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517299747975.jpg" alt="enter description here"></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>异常是允许操作系统提供<strong>进程</strong>(process)的概念所需要的基本构造块，进程是计算机可续重最深刻最成功的概念之一。当我们在一个现代系统上运行一个程序时，会得到一个假象，就好像我们的程序是系统中当前运行着的唯一的程序。</p>
<p>进程的经典定义就是一个<strong>执行中的程序的实例</strong>。系统中的每个程序都是运行在某个进程的<strong>上下文</strong>(context)中的。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在存储器中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p>
<p>每次用户通过向外壳输入一个可执行目标文件的名字，并运行一个程序时，shell 就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，且在这个新进程的上下文中运行它们自己的代码或其他应用程序。</p>
<h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><p>即使在系统中通常有许多其他程序在运行，进程也可以向每个程序提供一种假象，好像它在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器(PC)的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或者是包含在运行时动态链接到程序的共享对象的指令。这个 PC 值的序列叫做<strong>逻辑控制流</strong>。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517299971390.jpg" alt="enter description here"></p>
<p>进程是轮流使用处理器的，每个进程执行它流中的一部分，然后被抢占（preempted）（暂时挂起），与此同时其他进程开始执行。</p>
<h3 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h3><p>一个逻辑流的执行在时间上与另一个流重叠，称为并发流(concurrent flow)，这两个流被称为并发地运行。更准确地说，流 X 和 Y 互相并发，当且仅当 X 在 Y 开始之后和 Y 结束之前开始，或者 Y 在 X 开始之后和 X 结束之前开始。</p>
<p>多个流并发地执行的一般现象称为<strong>并发</strong>(concurrency)。一个进程和其他进程轮流运行的概念称为<strong>多任务</strong>(multitasking)。一个进程执行它的控制流的一部分的每一时间段叫做<strong>时间片</strong>(time slice)。因此，多任务也叫做时间分片(time slicing)</p>
<p>注意，并发的思想与流运行的处理器核数或者计算机无关。如果两个流再时间上重叠，那么它们就是并发的，即使它们是运行在同一个处理器上的。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为并行流(parallel flow)。</p>
<h3 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h3><p>进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。尽管和每个私有地址空间相关联的存储器的内容一般是不同的，但是每个这样的空间都有相同的通用结构，如下图所示。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517300174690.jpg" alt="enter description here"></p>
<h3 id="用户模式和内核模式"><a href="#用户模式和内核模式" class="headerlink" title="用户模式和内核模式"></a>用户模式和内核模式</h3><p>为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。</p>
<p>处理器通常是用某个控制寄存器中的一个<strong>模式位</strong>(mode bit)来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了模式位，进程就运行在内核模式(超级用户模式)。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中任何存储器位置。</p>
<p>没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行<strong>特权指令</strong>(priviledged instruction)，比如停止处理器、改变位模式，或者发起一个 I/O 操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。</p>
<p>Linux 提供了一种聪明的机制，叫做 /proc 文件系统，它允许用户模式进程访问内核数据结构的内容。/proc文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构。</p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>操作系统内核使用一种称为<strong>上下文切换</strong>(context switch)的较高层形式的异常控制流来实现多任务。上下文切换机制是建立在8.1节中那些较低层异常机制之上的。</p>
<p>内核为每个进程维持一个<strong>上下文</strong>(context)。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描绘地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。</p>
<p>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程。这种决定就叫做<strong>调度</strong>(schedule)，是由内核中称为<strong>调度器</strong>(scheduler)的代码处理的。当内核选择一个新的进程运行时，我们就说内核调度了这个进程。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517300757505.jpg" alt="enter description here"></p>
<h2 id="系统调用和错误处理"><a href="#系统调用和错误处理" class="headerlink" title="系统调用和错误处理"></a>系统调用和错误处理</h2><p>Unix提供大量的系统调用，当应用程序想向内核请求服务时，可以使用这些系统调用。</p>
<p>标准C库提供一组针对最常用系统调用的方便的包装（wrapper）函数。</p>
<p>通过使用错误处理包装（error-handling wrapper）函数，我们可以进一步简化我们的代码。</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="获取进程"><a href="#获取进程" class="headerlink" title="获取进程"></a>获取进程</h3><p>每个进程都有一个唯一的正数进程 ID(PID)。<code>getpid</code> 函数返回调用进程的 PID。<code>getppid</code> 函数返回它的父进程的 PID。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>);</div><div class="line"><span class="keyword">pit_t</span> getppid(<span class="keyword">void</span>);</div></pre></td></tr></table></figure>
<h3 id="创建和终止进程"><a href="#创建和终止进程" class="headerlink" title="创建和终止进程"></a>创建和终止进程</h3><p>从程序员的角度，我们可以认为进程总是处于下面三种状态之一：</p>
<ul>
<li>运行。进程要么在 CPU 上执行，要么在等待被执行且最终会被内核调度。</li>
<li>停止。进程的执行被挂起(suspend)，且不会被调度。当收到 SIGSTOP、SIGTSTP、SIDTTIN 或者 SIGTTOU 信号时，进程就停止，并且保持停止直到它收到一个 SIGCONT 信号，在这个时刻，进程再次开始运行。</li>
<li>终止。进程永远地停止了。进程会因为三种原因终止：1）收到一个默认行为是终止进程的信号，2）从主程序返回，3）调用 exit 函数</li>
</ul>
<p>该程序无返回值，<code>exit</code> 函数以 status 退出来终止进程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</div></pre></td></tr></table></figure>
<p>父进程通过调用 <code>fork</code> 函数创建一个新的运行子进程，子进程返回0，父进程返回子进程的 PID，如果出错则为 -1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</div></pre></td></tr></table></figure>
<p>新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份拷贝，包括文本、数据和 bss 段、以及用户栈。子进程还获得与父进程任何打开文件描述符相同的拷贝。父进程和新创建的子进程最大的区别在于他们有不同的 PID。</p>
<p><code>fork</code> 函数只被调用一次，却会返回两次(父进程与子进程)。因为子进程的 PID 总是非零的，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。</p>
<p>使用<code>fork</code>创建一个新进程：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"csapp.h"</span></span></div><div class="line"><span class="number">2</span> </div><div class="line"><span class="number">3</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">4 &#123;</div><div class="line"><span class="number">5</span> <span class="keyword">pid_t</span> pid;</div><div class="line"><span class="number">6</span> <span class="keyword">int</span> x = <span class="number">1</span>;</div><div class="line"><span class="number">7</span> </div><div class="line"><span class="number">8</span> pid = Fork();</div><div class="line"><span class="number">9</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* Child */</span></div><div class="line"><span class="number">10</span> <span class="built_in">printf</span>(<span class="string">"child : x=%d\n"</span>, ++x);</div><div class="line"><span class="number">11</span> <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line"><span class="number">12</span> &#125;</div><div class="line"><span class="number">13</span></div><div class="line"><span class="number">14</span> <span class="comment">/* Parent */</span></div><div class="line"><span class="number">15</span> <span class="built_in">printf</span>(<span class="string">"parent: x=%d\n"</span>, --x);</div><div class="line"><span class="number">16</span> <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line"><span class="number">17</span> &#125;</div></pre></td></tr></table></figure></p>
<p>这个例子有一些微妙的方面：</p>
<ul>
<li>调用一次，返回两次</li>
<li>并发执行。顺序不能保证</li>
<li>相同但是独立的地址空间，所以变量是分别独立的</li>
<li>共享文件，输出是指向同一个地方</li>
</ul>
<h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一中已终止的状态中，直到被它的父进程回收(reap)。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个终止了但还未被回收的进程称为<strong>僵死进程</strong>(zombie)。</p>
<p>如果父进程没有回收它的僵死子进程就终止了，那么内核就会安排 init 进程来回收它们。init 进程的 PID 为 1，并且是在系统初始化时由内核创建的。长时间运行的程序，比如 shell 或者服务器，总是应该回收它们的僵死子进程。即使僵死子进程没有运行，它们仍然小号系统的存储器资源。</p>
<p>一个进程可以通过调用 <code>waitpid</code> 函数来等待它的子进程终止或者停止。如果成功，则返回子进程的 PID，如果 WHOHANG ，则为 0，如果其他错误，则为 -1。</p>
<h3 id="让进程休眠"><a href="#让进程休眠" class="headerlink" title="让进程休眠"></a>让进程休眠</h3><p><code>sleep</code> 函数让一个进程挂起一段指定的时间。返回还要休眠的秒数。</p>
<p>如果请求的时间量已经到了，<code>sleep</code>返回 0，否则返回还剩下要休眠的秒数。我们会发现很有用的另一个函数是 <code>pause</code> 函数，该函数让调用函数休眠，直到该进程收到一个信号。总是返回 -1。</p>
<h3 id="加载并运行程序"><a href="#加载并运行程序" class="headerlink" title="加载并运行程序"></a>加载并运行程序</h3><p><code>execve</code> 函数在当前进程的上下文中加载并运行一个新程序。如果成功则不返回，如果错误，则返回 -1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *argv[], <span class="keyword">const</span> <span class="keyword">char</span> *envp[])</span></span>;</div></pre></td></tr></table></figure>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517301875073.jpg" alt="enter description here"></p>
<h3 id="信号术语"><a href="#信号术语" class="headerlink" title="信号术语"></a>信号术语</h3><p>传送一个信号到目的进程是由两个不同步骤组成的：</p>
<ul>
<li><strong>发送信号</strong>。内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。发送信号可以用如下两个原因：1）内核检测到一个系统事件，比如被零除错误或者子进程终止。2）一个进程调用 kill 函数，显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。</li>
<li><strong>接收信号</strong>。当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序(signal handler)的用户层函数捕获这个信号。如下图所示</li>
</ul>
<p>一个只发出而没有被接收的信号叫做待处理信号(pending signal)。在任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为 k 的待处理信号，那么任何接下来发送到这个进程的类型为 k 的信号都不会排队等待，它们只是被简单地丢弃。一个进程可以有选择地阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。</p>
<p>一个待处理信号最多只能被接收一次。内核为每个进程在 pending 位向量中维护着待处理信号的集合，而在 blocked 位向量中维护着被阻塞的信号集合。只要传送了一个类型为 k 的信号，内核就会设置 pending 中的第 k 位，而只要接收了一个类型为 k 的信号，内核就会清除 pending 中的第 k 位。</p>
<h3 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h3><p>Unix 系统提供了大量向进程发送信号的机制。所有这些机制都是基于进程组(process group)这个概念的。</p>
<p>进程组：每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的。<code>getpgrp</code> 函数返回当前进程的进程组 ID。</p>
<p>默认的，一个子进程和它的父进程同属一个进程组。一个进程可以通过使用 <code>setpgid</code> 函数来改变自己或者其他进程的进程组，成功则返回 0，否则返回 -1。</p>
<p>用 /bin/kill 程序发送信号</p>
<p>从键盘发送信号</p>
<p>用 kill 函数发送信号</p>
<p>用 alarm 函数发送信号</p>
<h3 id="接受信号"><a href="#接受信号" class="headerlink" title="接受信号"></a>接受信号</h3><p>当内核从一个异常处理程序返回，准备将控制传递给进程 p 时，它会检查进程 p 的未被阻塞的待处理信号的集合(pending&amp;~blocked)。如果这个集合为空(通常情况下)，那么内核将控制传递到 p 的逻辑控制流中的下一条指令</p>
<h3 id="信号处理问题"><a href="#信号处理问题" class="headerlink" title="信号处理问题"></a>信号处理问题</h3><p>当一个程序要补货多个信号时，一些细微的问题就产生了：</p>
<ul>
<li>待处理信号被阻塞</li>
<li>待处理信号不会排队等待</li>
<li>系统调用可以被中断</li>
</ul>
<p>不可以用信号来对其他进程中发生的事件计数。</p>
<h3 id="可移植的信号处理"><a href="#可移植的信号处理" class="headerlink" title="可移植的信号处理"></a>可移植的信号处理</h3><p>不同系统之间，信号处理语义的差异是 Unix 信号处理的一个缺陷。为了处理这个问题，Posix 标准定义了<code>sigaction</code> 函数，它允许用户明确指定他们想要的信号处理语义。</p>
<h3 id="显式地阻塞信号"><a href="#显式地阻塞信号" class="headerlink" title="显式地阻塞信号"></a>显式地阻塞信号</h3><p>使用 <code>sigprocmask</code> 函数</p>
<h2 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h2><p>C 语言提供了一种用户级一场控制流形式，称为<strong>非本地跳转</strong>(nonlocal jump)，它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用——返回序列，通过 <code>setjmp</code> 和 <code>longjmp</code> 函数来提供的。</p>
<p>非本地跳转的另一个重要应用是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。</p>
<h2 id="操作进程的工具"><a href="#操作进程的工具" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h2><p>Linux 系统提供了大量的监控和操作进程的有用工具：</p>
<ul>
<li>STRACE：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。用 -static 编译你的程序，能得到一个更干净的、不带有大量与共享库相关的输出的 trace</li>
<li>PS：列出当前系统中的进程(包括僵死进程)</li>
<li>TOP：打印出关于当前进程资源使用的信息</li>
<li>PMAP：显示进程的存储器映射</li>
<li>/proc：一个虚拟文件系统，以 ASCII 文本格式输出大量内核数据结构的内容，用户可以读取这些内容</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>异常控制流(ECF)发生在计算机系统的各个层次，是计算机系统中提供并发的基本机制。</p>
<p>在硬件层，异常是由处理器中的事件触发的控制流中的突变。控制流传递给一个软件处理程序，该处理程序进行一些处理，然后返回控制给被中断的控制流。</p>
<p>有四种不同类型的异常：中断、故障、终止和陷阱。</p>
<p>在操作系统层，内核用 ECF 提供进程的基本概念。进程提供给应用两个重要的抽象：1）逻辑控制流，它提供给每个程序一个假象，好像它是在独占地使用处理器，2）私有地址空间，它提供给每个程序一个假象，好像它是在独占地使用主存。</p>
<p>在操作系统和应用程序之间的接口处，应用程序可以创建子进程，等待它们的子进程停止或者终止，运行新的程序，以及不活来自其他进程的信号。信号处理的语义是微妙的，并且随着系统不同而不同。然而，在与 Posix 兼容的系统上存在着一些机制，允许程序清楚地指定期望的信号处理语义。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 链接]]></title>
      <url>/2018/01/29/CSAPP-%E9%93%BE%E6%8E%A5/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第7章笔记</p>
<a id="more"></a>
<p>链接(linking)是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载到存储器并执行。链接可以执行于编译时(compile time)，也可以执行于加载时(load time)，甚至执行于运行时(run time)。</p>
<p>链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译(separate compilation)成为可能。</p>
<h2 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h2><p>大多数编译系统提供<strong>编译驱动程序</strong>（compiler driver），为用户根据需求调用语言预处理器、编译器、汇编器和链接器</p>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517214954215.jpg" alt="enter description here"></p>
<p>为了创建可执行文件，链接器必须完成两个主要任务：</p>
<ul>
<li>符号解析（symbol resolution），将一个符号引用和一个符号定义结合起来</li>
<li>重定位（relocation），编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把每个符号定义域一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而重定位这些节。</li>
</ul>
<p>目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包含指导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。</p>
<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><p>目标文件有三种形式：</p>
<ul>
<li>可重定位目标文件，包含二进制文件和代码，其形式在编译时和其他可重定位目标文件合并起来，创建一个可执行目标文件</li>
<li>可执行目标文件，其形式可被拷贝到存储器并执行</li>
<li>共享目标文件，一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载到存储器并链接。</li>
</ul>
<p>编译器和汇编器生成可重定位目标文件（包括共享目标文件），链接器生成可执行目标文件</p>
<h2 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h2><p>典型的 ELF 可重定位目标文件的格式。ELF 头(ELF header)以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517215240554.jpg" alt="enter description here"></p>
<h2 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h2><p>每个重定位的目标模块m都有一个符号表，包含m所定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：</p>
<ol>
<li>有m定义并能够被其他模块引用的全局符号</li>
<li>由其他模块定义并被m所引用的全局符号</li>
<li>只被m定义和引用的本地符号</li>
</ol>
<p>C 程序员使用 static 属性在模块内部隐藏变量和函数声明。</p>
<h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><p>链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义联系起来。</p>
<p>当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，它会假设符号是在其他模块中定义的，生成一个链接器符号表表目，并把它交给链接器处理。</p>
<h3 id="链接器如何解析多处定义的全局符号"><a href="#链接器如何解析多处定义的全局符号" class="headerlink" title="链接器如何解析多处定义的全局符号"></a>链接器如何解析多处定义的全局符号</h3><p>编译器输出每个全局符号给汇编器，或者是强（stong），或者是弱（week），而汇编器把这些信息隐含得编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。</p>
<p>根据强弱符号的定义，Unix使用一下规则来处理多处定义的符号：</p>
<ol>
<li>不允许有多个强符号</li>
<li>如果有一个强符号和多个弱符号，则选择强符号</li>
<li>如果有多个弱符号，则从中随机选择一个</li>
</ol>
<h3 id="与静态库链接"><a href="#与静态库链接" class="headerlink" title="与静态库链接"></a>与静态库链接</h3><p>所有编译系统都提供了一种机制，将所有相关的目标模块打包成一个单独的文件，成为静态库（static library），它也可以作为链接器的输入。</p>
<p>在Unix系统中，静态库以一种存档（archive）的特殊文件格式存储在磁盘中。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517216233165.jpg" alt="enter description here"></p>
<h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>一旦链接器完成符号解析这一步，就把代码中每一个符号的引用和确定的一个符号定义结合起来。链接器就知道他输入目标模块中的代码节和数据节的确定大小。后面就是重定位的步骤了，</p>
<p>重定位由两个部分组成：</p>
<ol>
<li>重定位节和符号定义</li>
<li>重定义节中的符号引用，链接器修改代码节和数据节中的每一个符号引用，使得他们指向正确的地址</li>
</ol>
<h3 id="重定向表目"><a href="#重定向表目" class="headerlink" title="重定向表目"></a>重定向表目</h3><p>无论何时汇编器遇到对最终位置未知的目标引用，他就会生成一个重定位表目（relocation entry），告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。</p>
<p>有两种最基本的重定位类型：</p>
<ul>
<li>R_386_PC32 ： 重定位一个使用32位PC相关的地址引用</li>
<li>R_386_32 ： 重定位一个使用32位绝对地址的引用</li>
</ul>
<h3 id="重定位符号表引用"><a href="#重定位符号表引用" class="headerlink" title="重定位符号表引用"></a>重定位符号表引用</h3><h2 id="可执行目标文件"><a href="#可执行目标文件" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h2><p>一个典型的ELF可执行文件中的各类信息：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517217108531.jpg" alt="enter description here"></p>
<h2 id="加载可执行文件"><a href="#加载可执行文件" class="headerlink" title="加载可执行文件"></a>加载可执行文件</h2><p>每个Unix程序都有一个运行时的存储器映像：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517217187444.jpg" alt="enter description here"></p>
<h2 id="动态链接共享库"><a href="#动态链接共享库" class="headerlink" title="动态链接共享库"></a>动态链接共享库</h2><p>共享库(shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行时，可以加载到任意的存储器地址，并和一个在存储器中的程序链接起来。这个过程称为动态链接(dynamic linking)，是由一个叫做动态链接器的程序来执行的。</p>
<p>共享库也称为共享目标(shared object)，在 Unix 系统中通常用 .so 后缀来表示。微软的操作系统大量地利用了共享库，它们称为 DLL。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517217296974.jpg" alt="使用共享库来动态链接"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>链接可以在编译时由静态编译器来完成，也可以在加载时和运行时由动态链接器来完成。链接器处理称为目标文件的二进制文件，它又三种不同的形式：可重定位的、可执行的和共享的。可重定位的目标文件由静态链接器合并成一个可执行的目标文件，它可以加载到存储器中并执行。共享目标文件(共享库)是在运行时由动态链接器链接和加载的，或者隐含地在调用程序被加载和开始执行时，或者根据需要在程序调用 dlopen 库的函数时。</p>
<p>链接器的两个主要任务是符号解析和重定位，符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义，而重定位确定每个符号的最终存储器地址，并修改对那些目标的引用。</p>
<p>静态链接器是由像 GCC 这样的编译驱动器调用的。它们将多个可重定位目标文件合并成一个单独的可执行目标文件。多个目标文件可以定义相同的符号，而链接器用来悄悄地解析这些多重定义的规则可能在用户程序中引入的微妙错误。</p>
<p>多个目标文件可以被连接到一个单独的静态库中。链接器用库来解析其他目标模块中的符号引用。许多链接器通过从左到右的顺序扫描来解析符号引用，这是另一个引起迷惑的链接时错误来源。</p>
<p>加载器将可执行文件的内容映射到存储器，并运行这个程序。链接器还可能生成部分链接的可执行目标文件，这样的文件中有对定义在共享库中的程序和数据的未解析的引用。在加载时，加载器将部分链接的可执行文件映射到存储器，然后调用动态链接器，它通过加载共享库和重定位程序中的引用来完成链接任务。</p>
<p>被编译为位置无关代码的共享库可以加载到任何地方，也可以在运行时被多个进程共享。为了加载、链接和访问共享库的函数和数据，应用程序还可以在运行时使用动态链接器。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 3Sum & 3Sum Closest 题解]]></title>
      <url>/2018/01/28/LeetCode-3Sum-3Sum-Closest-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>LeetCode 3Sum &amp; 3Sum Closest 题解</p>
<a id="more"></a>
<h2 id="3Sum"><a href="#3Sum" class="headerlink" title="3Sum"></a>3Sum</h2><p>给出一个数组，找出所有三个数的和为零的组合</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>最暴力的方法就是枚举所有的三个数的组合，这样的时间复杂度是O（n^3）</p>
<p>另外一种比较优化的方法就是，先排序，枚举第一个数，后面两个数通过双指针确定。因为已经排序好的，后面两个数从两边向中间靠近进行枚举，这一部分的时间复杂度是O（n）。所以整个的时间复杂度就到了O（n^2）</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        vector&lt;vector&lt;int&gt;&gt; res;</div><div class="line">        </div><div class="line">        sort(nums.begin(),nums.end());</div><div class="line">        </div><div class="line">        int len = nums.size();</div><div class="line">        </div><div class="line">        for(int i=0;i&lt;len;i++)</div><div class="line">        &#123;</div><div class="line">            if(i==0 || nums[i]!=nums[i-1]) // 去重</div><div class="line">            &#123;</div><div class="line">                for(int j=i+1,k=len-1;j&lt;k;)</div><div class="line">                &#123;</div><div class="line">                    if(nums[i]+nums[j]+nums[k] == 0)</div><div class="line">                    &#123;</div><div class="line">                        vector&lt;int&gt; tmp = &#123;nums[i],nums[j],nums[k]&#125;;</div><div class="line">                        res.push_back(tmp);</div><div class="line">                        j++;</div><div class="line">                        while(j&lt;k &amp;&amp; nums[j]==nums[j-1]) j++;</div><div class="line">                        k=len-1;</div><div class="line">                    &#125;</div><div class="line">                    else if(nums[j]+nums[k]+nums[i]&gt;0)</div><div class="line">                    &#123;</div><div class="line">                        k--;</div><div class="line">                        while(j&lt;k &amp;&amp; nums[k]==nums[k+1]) k--;</div><div class="line">                    &#125;</div><div class="line">                    else</div><div class="line">                    &#123;</div><div class="line">                        j++;</div><div class="line">                         while(j&lt;k &amp;&amp; nums[j]==nums[j-1]) j++;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="3Sum-Closest"><a href="#3Sum-Closest" class="headerlink" title="3Sum Closest"></a>3Sum Closest</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>方法和上面的题目一样，同样是通过双指针来降低时间复杂度</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class="line">        int res = nums[0]+nums[1]+nums[2],len = nums.size();</div><div class="line">        int minv = abs(res - target);</div><div class="line">        </div><div class="line">        sort(nums.begin(),nums.end());</div><div class="line">        </div><div class="line">        for(int i=0;i&lt;len;i++)</div><div class="line">        &#123;</div><div class="line">            for(int j=i+1,k=len -1;j&lt;k;)</div><div class="line">            &#123;</div><div class="line">                int tmp = abs(nums[i]+nums[j]+nums[k]-target);</div><div class="line">                if(tmp&lt;minv)</div><div class="line">                &#123;</div><div class="line">                    minv = tmp;</div><div class="line">                    res = nums[i]+ nums[j] + nums[k];</div><div class="line">                &#125;</div><div class="line">                if(nums[i]+nums[j]+nums[k]&gt;=target)</div><div class="line">                    k--;</div><div class="line">                else</div><div class="line">                    j++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 存储器层次结构]]></title>
      <url>/2018/01/28/CSAPP%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第6章笔记</p>
<a id="more"></a>
<p>存储器系统(memory system)是一个具有不同容量、成本和访问时间的存储设备的层次结构。CPU 寄存器保存着最常用的数据。靠近 CPU 的晓得、快速的高速缓存存储器(cache memory)作为一部分存储在相对慢速的主存储器(main memory)中的数据和指令的缓冲区域。主存暂时存放在容量较大的、慢速磁盘上的数据，而这些磁盘常常又作为存储在通过网络连接的其他机器的磁盘或磁带上的区域的缓冲区域。</p>
<p>具有良好局部性的程序倾向于一次又一次地访问相同的数据项集合，或者是倾向于访问邻近的数据项集合</p>
<h2 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h2><h3 id="随机访问存储器"><a href="#随机访问存储器" class="headerlink" title="随机访问存储器"></a>随机访问存储器</h3><p>随机访问存储器 (Random-Access Memory, RAM)分为两类：静态的和动态的。SRAM 比 DRAM 更快，但也贵得多。SRAM 用来作为高速缓存存储器，既可以在 CPU 芯片上，也可以在片下。DRAM 用来作为主存以及图形系统的帧缓冲区。</p>
<h3 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h3><p>磁盘构造</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517109327779.jpg" alt="enter description here"></p>
<p>磁盘容量：一个磁盘能够存储的最大位数，由以下因素决定：</p>
<ul>
<li>记录密度（recoding density），磁道一英寸的段可以放入的位数</li>
<li>磁道密度</li>
<li>面密度</li>
</ul>
<p>磁盘操作：用一个连接到传动臂的读写头来读写存储在磁性表面的位</p>
<p>对扇区的访问时间由三个部分组成：寻道时间（seek time）、旋转时间（rotational latency）、传送时间（transfer time）</p>
<h3 id="固态硬盘（Solid-State-Disks）"><a href="#固态硬盘（Solid-State-Disks）" class="headerlink" title="固态硬盘（Solid State Disks）"></a>固态硬盘（Solid State Disks）</h3><p>基于闪存（flash memory）的存储技术</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517110224118.jpg" alt="enter description here"></p>
<h3 id="存储技术趋势"><a href="#存储技术趋势" class="headerlink" title="存储技术趋势"></a>存储技术趋势</h3><ul>
<li>不同的存储技术有不同的价格和性能的折中</li>
<li>不同存储技术的价格和性能属性以截然不同的速率变化着</li>
<li>DRAM和磁盘访问的时间滞后于CPU时钟周期时间</li>
</ul>
<h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p>一个编写良好的计算机程序常常具有良好的局部性(locality)。也就是说，它们倾向于引用临近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。这种倾向性，被称为局部性原理(principle of locality)，是一个持久的概念，对硬件和软件系统的设计和性能都有着极大的影响。</p>
<p>局部性通常有两种不同的形式：时间局部性(temporal locality)和空间局部性(spatial locality)。有良好局部性的程序比局部性差的程序运行得更快。</p>
<ul>
<li>重复引用同一个变量的程序有良好的时间局部性</li>
<li>对于具有步长为 k 的引用模式的程序，步长越小，空间局部性越好</li>
<li>对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好</li>
</ul>
<h2 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h2><p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517110431384.jpg" alt="enter description here"></p>
<h3 id="在存储器层次结构中的缓存"><a href="#在存储器层次结构中的缓存" class="headerlink" title="在存储器层次结构中的缓存"></a>在存储器层次结构中的缓存</h3><p>一般而言，高速缓存(cache)是一个小而快速的存储设备。使用高速缓存的过程称为缓存(caching)。</p>
<p>存储器层次结构的中心思想是，对于每个 k，位于 k 层的更快更小的存储设备作为位于 k+1 层的更大更慢的存储设备的缓存。换句话说，层次结构中的每一次都缓存来自较低一层的数据对象。</p>
<p>数据总是以块大小为传送单元(transfer unit)在第 k 层和第 k+1 层之间来回拷贝的。虽然在层次结构中任何一对相邻的层次之间块大小是固定的，但是其他的层次对之间可以用不同的块大小。一般而言，层次结构较低的层(离 CPU 较远)的设备访问时间较长，因此为了补偿这些较长的访问时间，倾向于使用较大的块。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517110523087.jpg" alt="enter description here"></p>
<p>缓存命中： 当程序需要第 k+1 层的某个数据对象 d 时，它首先在当前存储的第 k 层的一个块中查找 d。如果 d 刚好缓存在第 k 层中，那么就是<strong>缓存命中</strong>(cache hit)。</p>
<p>缓存不命中：如果第 k 层中没有缓存数据对象 d，那么就是缓存不命中(cache miss)。当发生 cache miss 时，会从下一次取出包含 d 的那个块，如果第 k 层的缓存已经满了的话，可能就会覆盖现存的一个块。</p>
<p>覆盖一个现存的块的过程称为替换(replacing)或驱逐(evicting)。被驱逐的看这个块有时也称为牺牲块(victim block)。决定该替换那个块是由缓存的替换策略(replacement policy)来控制的。(LRU, LFU 等等替换策略在这里可以使用)</p>
<p>缓存不命中的种类： 一个空的缓存有时称为冷缓存(cold cache)，此类不命中称为compulsory miss 或 cold miss。</p>
<h3 id="存储器层次结构概念小结"><a href="#存储器层次结构概念小结" class="headerlink" title="存储器层次结构概念小结"></a>存储器层次结构概念小结</h3><p>存储器层次结构行之有效，因为较慢的设备比较快的设备更便宜，还因为程序偏向于展示局部性：</p>
<ul>
<li>利用时间局部性，同一数据对象可能会被多次使用</li>
<li>利用空间局部性，块通常包含有多个数据对象</li>
</ul>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517110831456.jpg" alt="enter description here"></p>
<h2 id="高速缓存存储器"><a href="#高速缓存存储器" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h2><p>早期计算机系统的存储器结构只有三层：CPU 寄存器、DRAM 主存储器和磁盘存储。不过，由于 CPU 和主存之间逐渐增大的差距，系统设计者被迫在 CPU 寄存器文件和主存之间插入了一个小的 SRAM 高速缓存存储器，称为 L1 高速缓存。之后又插入了一个更大的高速缓存，称为 L2 高速缓存，之后还有 L3 高速缓存。周期数：L1(2~4), L2(~10), L3(~30~40)</p>
<h3 id="通用的高速缓存存储结构"><a href="#通用的高速缓存存储结构" class="headerlink" title="通用的高速缓存存储结构"></a>通用的高速缓存存储结构</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517111205440.jpg" alt="enter description here"></p>
<h3 id="直接映射高速缓存"><a href="#直接映射高速缓存" class="headerlink" title="直接映射高速缓存"></a>直接映射高速缓存</h3><p>每个组只有一行（E=1）的高速缓存被称为直接映射高速缓存</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517111234451.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517111247641.jpg" alt="enter description here"></p>
<h3 id="组相联高速缓存"><a href="#组相联高速缓存" class="headerlink" title="组相联高速缓存"></a>组相联高速缓存</h3><p>直接映射高速缓存中冲突不命中造成的问题是源于每一个组只有一行，组相联高速缓存（set associative cache）放松了这条限制，所以每个组都保存了有多于一行的高速缓存</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517111425945.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517111461520.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517111477325.jpg" alt="enter description here"></p>
<h3 id="全相联高速缓存"><a href="#全相联高速缓存" class="headerlink" title="全相联高速缓存"></a>全相联高速缓存</h3><p>由一个包含所有高速缓存行的组（E =  C/B）组成</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517111577074.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517111592957.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517111605869.jpg" alt="enter description here"></p>
<h3 id="有关写的问题"><a href="#有关写的问题" class="headerlink" title="有关写的问题"></a>有关写的问题</h3><p>更新写命中的缓存的方法：</p>
<ol>
<li>直写（write-throuth），立即将w的高速缓存块写回到存储器中，优点是简单，缺点是每条存储指令都会引起总线上面的一个写事务</li>
<li>写回（write-back），尽可能推迟存储器的更新，只有当替换算法要驱逐已更新块时，才写入存储器中，优点是能够显著减少总线事务的数量，缺点是增加复杂性，需要额外维护一个修改位（dirty bit）</li>
</ol>
<p>处理写不命中的方法：</p>
<ol>
<li>写分配（write-allocate），加载相应的存储器块到高速缓存中，然后更新这个高速缓存块</li>
<li>非写分配（not-write-allocate），避开高速缓存，直接把字写到存储器中</li>
</ol>
<h3 id="指令高速缓存和统一高速缓存"><a href="#指令高速缓存和统一高速缓存" class="headerlink" title="指令高速缓存和统一高速缓存"></a>指令高速缓存和统一高速缓存</h3><p>只保存指令的高速缓存成为i-cache，只保存程序数据的高速缓存称为d-cache，即保存指令又保存程序数据的高速缓存称为统一的高速缓存（unified cache）</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517112120679.jpg" alt="enter description here"></p>
<h3 id="高速缓存参数的性能影响"><a href="#高速缓存参数的性能影响" class="headerlink" title="高速缓存参数的性能影响"></a>高速缓存参数的性能影响</h3><p>衡量性能的指标：</p>
<ul>
<li>不命中率</li>
<li>命中率</li>
<li>命中时间</li>
<li>不命中处罚</li>
</ul>
<p>影响：</p>
<ol>
<li>高速缓存大小</li>
<li>块大小</li>
<li>相联度</li>
<li>写策略</li>
</ol>
<h2 id="编写高速缓存友好的代码"><a href="#编写高速缓存友好的代码" class="headerlink" title="编写高速缓存友好的代码"></a>编写高速缓存友好的代码</h2><ol>
<li>让最常见的情况运行得快</li>
<li>在每个循环内部使缓存不命中数量小</li>
</ol>
<h2 id="综合：高速缓存对程序性能的影响"><a href="#综合：高速缓存对程序性能的影响" class="headerlink" title="综合：高速缓存对程序性能的影响"></a>综合：高速缓存对程序性能的影响</h2><p>存储器山（memory mountain）<br><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517112396218.jpg" alt="enter description here"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>程序员可以通过编写有良好空间和时间局部性的程序来显著地改进程序的运行时间。利用基于 SRAM 的高速缓存存储器特别重要。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 优化程序性能]]></title>
      <url>/2018/01/27/CSAPP-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第5章笔记</p>
<a id="more"></a>
<p>编写高效程序可以考虑两个方面：选择好的算法和数据结构；编写编译器能够有效优化以转换为高效可执行代码的源码。</p>
<p>程序员通常需要在实现和维护程序的简单性与他的运行速度之间做出权衡折中。</p>
<p>程序优化的第一步就是消除不必要的内容，让代码尽可能有效地执行它期望的工作。这包括消除不必要的函数调用、条件测试和存储器引用。这些优化不依赖于目标机器的任何具体属性。</p>
<p>研究程序的汇编代码表示，是理解编译器，以及产生的代码如何运行的最有效的手段之一。仔细研究内循环的代码是一个很好的开端。</p>
<h2 id="优化编译器的能力和局限性"><a href="#优化编译器的能力和局限性" class="headerlink" title="优化编译器的能力和局限性"></a>优化编译器的能力和局限性</h2><p>编译器优化程序的能力受到几个因素的制约：</p>
<ol>
<li>要求决不能改变正确程序的行为</li>
<li>对程序的行为、使用的环境有所了解</li>
<li>需要很快地完成编译工作</li>
</ol>
<p>阻碍优化的几个因素：</p>
<ul>
<li>存储器别名的使用，编译器必须假设不同的指针可能会指向存储器中的同一个位置</li>
<li>函数调用，函数可能会有副作用（改变全局程序状态的一部分）</li>
</ul>
<h2 id="表示程序性能"><a href="#表示程序性能" class="headerlink" title="表示程序性能"></a>表示程序性能</h2><p>我们引入度量标准每元素的周期数(Cycles Per Element, CPE)作为一种表示性能并指导我们改进代码的方法。处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用千兆赫兹(GHz)，即十亿周期每秒来表示。CPE 越小越好。</p>
<h2 id="消除循环的低效率"><a href="#消除循环的低效率" class="headerlink" title="消除循环的低效率"></a>消除循环的低效率</h2><p>优化前</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_27_1517062357118.jpg" alt="enter description here"></p>
<p>优化后</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_27_1517062333115.jpg" alt="enter description here"></p>
<p>以上的代码移动(code motion)是一种优化。这类优化包括识别要执行多次(例如在循环里)但是计算结果不会改变的计算。因而可以将计算移动到代码前面不会被多次求值的部分。</p>
<p>编程时一个常见的问题就是一个看上去无足轻重的代码片段有隐藏的渐进低效率(asymptotic inefficiency)</p>
<h2 id="减少过程调用"><a href="#减少过程调用" class="headerlink" title="减少过程调用"></a>减少过程调用</h2><p>过程调用会代码相当大的开销，而且妨碍大多数形式的程序优化。我们可以直接访问数组，而不是利用函数调用并加上边界检查：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_27_1517062508161.jpg" alt="enter description here"></p>
<p>对于性能至关重要的程序来说，为了速度，可能需要损害一些对象的模块性和抽象性</p>
<h2 id="消除不必要的存储器引用"><a href="#消除不必要的存储器引用" class="headerlink" title="消除不必要的存储器引用"></a>消除不必要的存储器引用</h2><p>累加过程中其实没有必要每次都把结果写入到 dest 中，可以使用一个临时变量，消除不必要的存储器引用：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_27_1517062838432.jpg" alt="enter description here"></p>
<h2 id="理解现代处理器"><a href="#理解现代处理器" class="headerlink" title="理解现代处理器"></a>理解现代处理器</h2><p>不依赖目标机器的优化，只能简单通过降低过程调用开销、以及消除一些重大的“妨碍优化因素”来实现。</p>
<p>要想获得充分提高的性能，需要仔细地分析程序，同时代码的生成也要针对目标处理器进行调整。在实际的处理器中，是同时对多条指令求值，这个现象称为指令级并行。现代微处理器取得的了不起的功绩之一是：它们采用复杂而奇异的微处理器结构，其中，多条指令可以并行地执行，同时又呈现一种简单地顺序执行指令的表象。</p>
<p>两种下界描述了程序的最大性能。当一系列操作必须按照严格顺序执行时，就会遇到延迟界限(latency bound)，因为在下一条指令开始之前，这条指令必须结束。当代码中的数据相关限制了处理器利用指令级并行的能力时，延迟界限能够限定程序性能。吞吐量界限(throughput bound)刻画了处理器功能单元的原始计算能力。这个界限是程序性能的终极限制。</p>
<h3 id="整数操作"><a href="#整数操作" class="headerlink" title="整数操作"></a>整数操作</h3><p>Nehalem 微体系结构是 20 世纪 90 年代以来，许多制造商生产的典型的高端处理器。在工业界称为超标量(superscalar)，意思是可以在每个时钟周期执行多个操作，而且是乱序的(out-of-order)，意思就是指令执行的顺序不一定要与它们在机器级程序中的顺序一致。整个设计有两个主要部分：指令控制单元(Instruction Control Unit, ICU)和执行单元(Execution Unit, EU)。前者负责从存储器中读出指令序列，并根据这些指令序列生成一组针对程序数据的基本操作；而后执行这些操作。</p>
<p>ICU 从指令高速缓存(instruction cache)中读取指令。指令高速缓存是一个特殊的高速缓存存储器，它包含最近访问的指令。通常，ICU 会在当前正在的指令很早之前取指，这样它才有足够的时间对指令译码，并把操作发送到 EU。不过，一个问题是党程序遇到分支时，程序有两个可能的前进方向。一种可能会选择分支，控制被传递到分支目标。另一种可能是，不选择分支，控制被传递到指令序列的下一条指令。现代处理器采用了一种称为<strong>分支预测(branch prediction)的技术，处理区会猜测是否会选择分支，同时还预测分支的目标地址</strong>。使用投机执行(speculative execution)的技术，处理器会开始取出位于它预测的分支会跳到的地方的指令，并对指令译码，甚至在它确定分支预测是否正确之前就开始执行这些操作。如果过后确定分支预测错误，会将状态重新设置到分支点的状态，并开始取出和执行另一个方向上的指令。</p>
<h3 id="功能单元的性能"><a href="#功能单元的性能" class="headerlink" title="功能单元的性能"></a>功能单元的性能</h3><p>每个运算都是由两个周期计数值来刻画的：一个是延迟(latency)，它表示完成运算所需要的总时间；另一个是发射时间(issue time)，它表示两个连续的同类型运算之间需要的最小时钟周期数。随着字长的增加，对于更复杂的数据类型，对于更复杂的运算，延迟也会增加。</p>
<h3 id="处理器操作的抽象模型"><a href="#处理器操作的抽象模型" class="headerlink" title="处理器操作的抽象模型"></a>处理器操作的抽象模型</h3><p>我们会使用程序的数据流(data-flow)表示，作为分析在现代处理器上执行的机器级程序性能的一个工具，这是一种图形化的表示方法，展现了不同操作之间的数据相关是如何限制它们的执行顺序的。这种限制形成了图中的<strong>关键路径</strong>(critical path)，这是执行一组机器指令所需时钟周期数的一个下界。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_27_1517063266274.jpg" alt="enter description here"></p>
<h2 id="循环展开（loop-unrolling）"><a href="#循环展开（loop-unrolling）" class="headerlink" title="循环展开（loop unrolling）"></a>循环展开（loop unrolling）</h2><p>循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。其思想是在一次迭代中访问数组并做乘法，这样得到的程序需要更少的迭代，从而降低循环的开销。</p>
<p>循环展开能够从两个方面改善程序的性能。首先，它减少了不直接有助于程序结果的操作的数量，例如循环索引计算和条件分支。其次，它提供了一些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。</p>
<h2 id="提高并行性"><a href="#提高并行性" class="headerlink" title="提高并行性"></a>提高并行性</h2><h3 id="循环分割（loop-splitting）"><a href="#循环分割（loop-splitting）" class="headerlink" title="循环分割（loop splitting）"></a>循环分割（loop splitting）</h3><p>对于一个可结合可交换的合并操作来说，比如说整数的乘法和加法，我们可以通过将一组数据合并分割成两个或者更多部分，并在最后合并结果来提高性能</p>
<h3 id="寄存器溢出（register-spilling）"><a href="#寄存器溢出（register-spilling）" class="headerlink" title="寄存器溢出（register spilling）"></a>寄存器溢出（register spilling）</h3><p>循环并行性的好处就是受描述计算的汇编代码的能力限制，如果我们有并行度p超过了可用的寄存器数量，这种情况性能就会急剧下降。</p>
<p>作为一条通用原则，无论何时当一个编译了的程序显示出来在某个频繁使用的内循环中有寄存器溢出的迹象时，都会偏向于重写代码，使之需要较少的临时值。</p>
<h2 id="确定和消除性能瓶颈"><a href="#确定和消除性能瓶颈" class="headerlink" title="确定和消除性能瓶颈"></a>确定和消除性能瓶颈</h2><p>Amdahl定律</p>
<p>当我们加快系统一部分的速度时，对系统整体性能的影响依赖于这个部分有多重要和速度提高了多少。</p>
<p>主要观点：想要大幅度提高整个系统的速度，我们必须提高系统很大一部分的速度。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>没有任何编译器能用一个好的算法或数据结构代替低效率的算法或数据结构，因此程序设计时的这些方面仍然应该是程序员主要关心的。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 处理器体系结构]]></title>
      <url>/2018/01/26/CSAPP-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第4章笔记</p>
<a id="more"></a>
<p>一个处理器支持的指令和指令字节编码称为它的ISA（Instruction-set Architecture）。这一章主要讲以Y86指令集体系结构为例讲了处理器中指令的执行流程以及流水的原理和实现。</p>
<h2 id="Y86指令集体系结构"><a href="#Y86指令集体系结构" class="headerlink" title="Y86指令集体系结构"></a>Y86指令集体系结构</h2><p>Y86 程序中的每条指令都会读取或修改处理器状态的某些部分，这称为程序员（用汇编代码写程序的人或机器级代码的编译器）可见状态：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_26_1516971186027.jpg" alt="enter description here"></p>
<p>Y86指令集</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_26_1516971281093.jpg" alt="enter description here"></p>
<p>指令编码：每条指令的第一个字节表示指令的类型，这个字节分为两个部分，每个部分四位：高四位是代码（code）部分，低四位是功能（function）部分。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_26_1516971475052.jpg" alt="enter description here"></p>
<p>CISC vs RISC</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_26_1516971547830.jpg" alt="enter description here"></p>
<h2 id="逻辑设计和硬件控制语言HCL"><a href="#逻辑设计和硬件控制语言HCL" class="headerlink" title="逻辑设计和硬件控制语言HCL"></a>逻辑设计和硬件控制语言HCL</h2><p>硬件设计中，电子电路是用来计算位的函数（function on bits），以及在各种存储器元素中存储位。实现一个数字系统主要有三个部分：计算位的函数的组合逻辑、存储位的存储元素，以及控制存储元素更新的时钟信号。</p>
<h3 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a>逻辑门</h3><p>逻辑门是数字电路的基本计算元素。它们产生的输出，等于它们输入位值的某个布尔函数</p>
<h3 id="组合电路和HCL布尔表达式"><a href="#组合电路和HCL布尔表达式" class="headerlink" title="组合电路和HCL布尔表达式"></a>组合电路和HCL布尔表达式</h3><p>很多的逻辑门组合成一个网，就能构建计算块(computational block)，称为组合电路(combinational circuits)。构建这些网有两条限制：</p>
<ul>
<li>两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障</li>
<li>这个网必须是无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，这样的回路会导致该网络计算的函数有歧义。</li>
</ul>
<h3 id="字级的组合电路和HCL整数表达式"><a href="#字级的组合电路和HCL整数表达式" class="headerlink" title="字级的组合电路和HCL整数表达式"></a>字级的组合电路和HCL整数表达式</h3><p>字级的组合电路： 对数据字（data word）进行操作的电路，在HCL中，将所有的字级的信号都声明为int，而不指定字的大小</p>
<h3 id="集合关系（set-membership）"><a href="#集合关系（set-membership）" class="headerlink" title="集合关系（set membership）"></a>集合关系（set membership）</h3><p>实现将一个信号和众多可能的信号做比较，判断正在处理的某些指令是否属于一类指令代码</p>
<h3 id="存储器和时钟控制"><a href="#存储器和时钟控制" class="headerlink" title="存储器和时钟控制"></a>存储器和时钟控制</h3><p>为了产生时序电路，必须引入按位存储信息的设备，考虑两种：</p>
<ul>
<li>时钟寄存器存储单个位或字</li>
<li>随机访问存储器存储多个字</li>
</ul>
<h2 id="Y86的顺序（sequential）实现"><a href="#Y86的顺序（sequential）实现" class="headerlink" title="Y86的顺序（sequential）实现"></a>Y86的顺序（sequential）实现</h2><h3 id="将处理组织成阶段"><a href="#将处理组织成阶段" class="headerlink" title="将处理组织成阶段"></a>将处理组织成阶段</h3><p>处理一条指令包含很多操作，我们把其组织成某些特殊的阶段序列，使得即使指令的动作差异很大，但是所有的指令都遵守统一的序列：</p>
<ul>
<li>取指（fetch），取指阶段，从存储器中读入指令，地址为程序计数器（PC）的值</li>
<li>解码（decode），解码阶段从寄存器中读入最多两个操作数，得到其值</li>
<li>执行（execute），算术逻辑单元（ALU）要么执行指令指明的操作，计算存储器引用的有效地址，要么增加或者减少栈指针。</li>
<li>访存（memory），可以将数据写入存储器，或者从存储器中读入数据</li>
<li>写回（write back），最多可以写两个结果到寄存器文件</li>
<li>更新PC（update PC），将PC设置为下一条PC的地址</li>
</ul>
<p>SEQ的硬件结构、时序、阶段实现 因为比较复杂，可以参考书上的内容</p>
<h2 id="流水线的通用原理"><a href="#流水线的通用原理" class="headerlink" title="流水线的通用原理"></a>流水线的通用原理</h2><p>流水线化的系统有一些通用的属性和原理，在流水线系统中，待执行的任务被划分成若干个相互独立的阶段。</p>
<h3 id="计算流水线"><a href="#计算流水线" class="headerlink" title="计算流水线"></a>计算流水线</h3><p>由一些执行计算的逻辑以及保存计算结果的寄存器组成。时钟信号控制在每个特定的时间间隔加载寄存器。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_26_1516973076361.jpg" alt="enter description here"></p>
<h3 id="流水线操作的详细说明"><a href="#流水线操作的详细说明" class="headerlink" title="流水线操作的详细说明"></a>流水线操作的详细说明</h3><p>三段流水线的时序</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_26_1516973204553.jpg" alt="enter description here"></p>
<p>流水线操作的一个时钟周期</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_26_1516973260280.jpg" alt="enter description here"></p>
<h3 id="流水线的局限性"><a href="#流水线的局限性" class="headerlink" title="流水线的局限性"></a>流水线的局限性</h3><ul>
<li>不一致的划分</li>
<li>流水线过深，收益反而下降（由寄存器延迟造成的）</li>
</ul>
<h3 id="带反馈的流水线系统"><a href="#带反馈的流水线系统" class="headerlink" title="带反馈的流水线系统"></a>带反馈的流水线系统</h3><p>可能产生的相关：数据相关（data dependency）、顺序相关（sequential dependency）、控制相关（control dependency）</p>
<h2 id="Y86的流水线实现"><a href="#Y86的流水线实现" class="headerlink" title="Y86的流水线实现"></a>Y86的流水线实现</h2><h3 id="插入流水线寄存器"><a href="#插入流水线寄存器" class="headerlink" title="插入流水线寄存器"></a>插入流水线寄存器</h3><p>在SEQ+的各个阶段之间插入流水线寄存器，并对信号重新做排列</p>
<h3 id="对信号做重新排列和标号"><a href="#对信号做重新排列和标号" class="headerlink" title="对信号做重新排列和标号"></a>对信号做重新排列和标号</h3><p>在流水线化的设计中，对应正在进过系统的各个指令，对指令中处理的值进行重新排列和标号</p>
<h3 id="预测下一个PC"><a href="#预测下一个PC" class="headerlink" title="预测下一个PC"></a>预测下一个PC</h3><h3 id="流水先冒险（hazard）"><a href="#流水先冒险（hazard）" class="headerlink" title="流水先冒险（hazard）"></a>流水先冒险（hazard）</h3><p>数据相关和控制相关导致的流水线产生的计算错误，成为冒险（hazard）。同样，冒险也分为数据冒险和控制冒险两大部分。</p>
<h3 id="用暂停（stalling）来避免数据冒险"><a href="#用暂停（stalling）来避免数据冒险" class="headerlink" title="用暂停（stalling）来避免数据冒险"></a>用暂停（stalling）来避免数据冒险</h3><p>暂停时，处理器会停止流水线中一条或多条指令，知道冒险不再满足</p>
<h3 id="用转发（forwarding）来避免数据冒险"><a href="#用转发（forwarding）来避免数据冒险" class="headerlink" title="用转发（forwarding）来避免数据冒险"></a>用转发（forwarding）来避免数据冒险</h3><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>指令集体系结构（ISA）在处理器行为（就指令集合以及其编码而言）和如何实现处理器之间提供了一层抽象。</p>
<p>流水线化通过让不同的阶段并行操作，改进系统的吞吐量性能。</p>
<p>处理器设计的几个重要经验：</p>
<ul>
<li>管理复杂性是首要问题</li>
<li>我们不需要直接实现ISA</li>
<li>硬件设计人员必须谨慎小心，一旦芯片被制造出来，就几乎不可能改正任何错误了。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode Merge k Sorted Lists 题解]]></title>
      <url>/2018/01/26/LeetCode%20Merge%20k%20Sorted%20Lists%20%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>LeetCode Merge k Sorted Lists 题解</p>
<a id="more"></a>
<h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p>使用之前合并两个lists的方法，重复调用k次</p>
<h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>从lists中找到前面一个元素最小的list，将这个list的首个node加入到要返回的list中的末尾中去，不断循环，直到lists中所有的node都取出来为止</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinIndex</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> minVal = <span class="number">2147483647</span> ,minIndex = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lists.size();i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(lists[i] != <span class="literal">NULL</span> &amp;&amp; minVal &gt; lists[i]-&gt;val)</div><div class="line">            &#123;</div><div class="line">                minVal = lists[i]-&gt;val;</div><div class="line">                minIndex = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minIndex;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</div><div class="line">        ListNode* res =<span class="literal">NULL</span>, *p =<span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">int</span> len = lists.size();</div><div class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> ind = getMinIndex(lists);</div><div class="line">        <span class="keyword">while</span>(ind != <span class="number">-1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// node 移植</span></div><div class="line">            <span class="keyword">if</span>(res ==<span class="literal">NULL</span>)</div><div class="line">            &#123;</div><div class="line">                res = p  = lists[ind];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                p-&gt;next = lists[ind];</div><div class="line">                p = p-&gt;next;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// 删除list中的node</span></div><div class="line">            </div><div class="line">            lists[ind] = lists[ind]-&gt;next;</div><div class="line">            </div><div class="line">            ind = getMinIndex(lists);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h2><p>将所有的node都加入到一个最小堆中，不断从这个最小堆中取出最小的一个node形成一个list</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</div><div class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</div><div class="line">        <span class="keyword">auto</span> *cur = &amp;dummy;</div><div class="line"></div><div class="line">        <span class="keyword">struct</span> Compare &#123;</div><div class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> ListNode *a, <span class="keyword">const</span> ListNode *b)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">// Use min heap to keep the smallest node of each list</span></div><div class="line">        priority_queue&lt;ListNode *, <span class="built_in">vector</span>&lt;ListNode *&gt;, Compare&gt; min_heap;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; n : lists) &#123;</div><div class="line">            <span class="keyword">if</span> (n) &#123;</div><div class="line">                min_heap.emplace(n);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!min_heap.empty()) &#123;</div><div class="line">            <span class="comment">// Get min of k lists.</span></div><div class="line">            <span class="keyword">auto</span> *node = min_heap.top();</div><div class="line">            min_heap.pop();</div><div class="line">            cur-&gt;next = node;</div><div class="line">            cur = cur-&gt;next;</div><div class="line">            <span class="keyword">if</span> (node-&gt;next) &#123;</div><div class="line">                min_heap.emplace(node-&gt;next);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="思路四"><a href="#思路四" class="headerlink" title="思路四"></a>思路四</h2><p>归并排序的思想，不断拆分成两个list的合并，最后合并的次数只有logk次，所以整体的时间复杂为O(n*logk)</p>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 程序的机器级表示]]></title>
      <url>/2018/01/25/CSAPP-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第3章笔记</p>
<a id="more"></a>
<p>高级语言通过编译变成汇编语言，汇编代码则与特定的机器密切相关。汇编代码中包含了管理存储器（memory）和执行计算的低级指令的一些细节（写高级程序的人员一般不需要考虑的）。编译器基于编程语言的原则、目标机器的指令集和操作系统遵循的规则，经过一系列的阶段产生机器代码。</p>
<h2 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h2><p>正如之前所说的，从源代码到机器可执行代码会经过以下几个过程：预处理-&gt; 编译器-&gt; 汇编器 -&gt; 链接器</p>
<h3 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h3><p>对于机器级代码来说，有两种抽象非常重要。第一种是机器级程序的格式和行为，定义为<strong>指令集体系结构</strong>(Instruction set architecture, ISA)，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。第二种抽象是，机器级程序使用的存储器地址是虚拟地址，提供的存储器模型看上去是一个非常大的字节数组。</p>
<p>汇编代码和原始的C代码相差比较大，一些通常对C语言程序员隐蔽的处理器状态是可见的：</p>
<ul>
<li>程序计数器(PC，用 %eip 表示)指示将要执行的下一条指令在存储器中的地址。</li>
<li>整数寄存器文件包含 8 个命名的位置，分别存储 32 位的值。这些寄存器可以存储地址(对应于 C 语言的指针)或证书数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器则用来保存临时数据。</li>
<li>条件码(codition code)寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化。</li>
<li>一组浮点寄存器存放浮点数据。</li>
</ul>
<p>C语言中的聚焦数据类型，例如数组和结构，在汇编中是用连续的字节表示的。汇编代码不区分有符号或无符号整数，不区分各种类型的指针，甚至不区分指针和整数。</p>
<p>程序存储器(program memory)包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的存储器块。同时OS负责管理虚拟地址空间，将虚拟地址转换为物理地址。</p>
<p>一条指令只执行一个非常基本的操作。例如，将存放在寄存器中的两个数字相加，在存储器和寄存器之间传送数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列，从而实现(像算术表达式求值、循环或过程调用和返回这样的)程序结构。</p>
<h3 id="关于格式的注解"><a href="#关于格式的注解" class="headerlink" title="关于格式的注解"></a>关于格式的注解</h3><p>所有以 . 开头的行都是指导汇编器和链接器的命令（对程序的解释），我们通常可以忽略这些行。</p>
<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516882675143.jpg" alt="enter description here"></p>
<h2 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h2><p>一个IA32的CPU中有8个32位的寄存器用来存储整数数据和指针，在过程（procedures）处理中，对前三个寄存器(%eax, %ecx, %edx)的保存和恢复惯例不同于接下来的三个寄存器(%ebx, %edi, %esi)。最后两个寄存器(%ebp, %esp)保存着指向程序栈中重要位置的指针。只有根据栈管理的标准惯例才能修改这两个寄存器中的值。</p>
<h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p>大多数指令有一个或多个操作数(operand)，指示出执行一个操作中要引用的源数据值，以及放置结果的目标位置。操作数可能被分为三种类型：</p>
<ul>
<li>立即数(immediate)，也就是常数值</li>
<li>寄存器(register)，表示某个寄存器的内容</li>
<li>存储器(memory)引用，它会根据计算出来的地址访问某个存储器位置</li>
</ul>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516883245706.jpg" alt="enter description here"></p>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516883311416.jpg" alt="enter description here"></p>
<h2 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h2><p>给出的每个指令类都有对字节、字和双字数据进行操作的指令。这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。</p>
<h3 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h3><p>加载有效地址(load effective address)指令 leal 实际上是 movl 指令的变形。它的指令形式是从存储器读数据到寄存器，但实际上它根本就没有引用存储器。它的第一个操作数看上去是一个存储器引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516883471796.jpg" alt="enter description here"></p>
<h3 id="一元和二元操作"><a href="#一元和二元操作" class="headerlink" title="一元和二元操作"></a>一元和二元操作</h3><p>一元操作：一个操作数既是源又是目的</p>
<p>二元操作：第二个操作数既是源又是目的</p>
<h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><p>先给出移位的量，然后是待移位的值</p>
<h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p>CPU 维护着一组单个 bit 的条件码(condition code) 寄存器，他们描述了最近的算术或逻辑操作的属性</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516883691695.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516883745587.jpg" alt="enter description here"></p>
<h3 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h3><p>两种最常见的访问条件码的方法不是直接读取，常用的使用方法有三种：</p>
<ul>
<li>可以根据条件码的某个组合，将一个字节设置为 0 或者 1</li>
<li>可以条件跳转到程序的某个其他的部分</li>
<li>可以有条件地传送数据</li>
</ul>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516883932824.jpg" alt="enter description here"></p>
<h3 id="跳转指令和他们的编码"><a href="#跳转指令和他们的编码" class="headerlink" title="跳转指令和他们的编码"></a>跳转指令和他们的编码</h3><p>跳转指令会导致执行切换到程序中的一个全新的位置</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516884044007.jpg" alt="enter description here"></p>
<h3 id="翻译条件分支"><a href="#翻译条件分支" class="headerlink" title="翻译条件分支"></a>翻译条件分支</h3><p>将条件表达式和语句从 C 语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516884153857.jpg" alt="enter description here"></p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>汇编中没有相应的循环指令，将条件测试和跳转组合起来可以实现循环的效果</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516884258395.jpg" alt="enter description here"></p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>通过一种称为跳转表（jump table）的数据结构使得实现更加高效，相比使用一组很长的if-else语句，使用跳转表的优点是执行开关语句的时间和开关情况（switch cases）的数量无关。</p>
<p>一般在开关情况数量比较多，并且值的范围跨度比较小的时候使用跳转表</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>一个过程调用包括将数据和控制从代码的一部分传递到另一部分。另外，它还必须在进入时为过程的局部变量分配空间，并在退出时释放这些空间。大多数机器，包括 IA32，只提供转移控制到过程和从过程转移出控制这种简单的指令。数据传递、局部变量的分配和释放通过操纵程序栈来实现。</p>
<h3 id="栈帧结构"><a href="#栈帧结构" class="headerlink" title="栈帧结构"></a>栈帧结构</h3><p>IA32 程序用程序栈来支持过程调用。机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后回复，以及本地存储。为单个过程分配的那部分栈称为<strong>栈帧</strong>(stack frame)。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516884747521.jpg" alt="enter description here"></p>
<h3 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516884832280.jpg" alt="enter description here"></p>
<h3 id="寄存器使用惯例"><a href="#寄存器使用惯例" class="headerlink" title="寄存器使用惯例"></a>寄存器使用惯例</h3><p>程序寄存器组是唯一能够被所有过程共享的资源。虽然在给定时刻只能有一个过程是活动的，但是我们必须保证当一个过程调用另一个过程时，被调用者不会覆盖某个调用者稍后会使用的寄存器的值。</p>
<p>根据惯例，寄存器 %eax、%edx、%ecx 被划分为<strong>调用者保存寄存器</strong>（caller save）。当过程 P 调用 Q 时，Q 可以覆盖这些寄存器，而不会破坏任何 P 所需要的数据。另一方面， 寄存器 %ebx、%esi、%edi 被划分为<strong>被调用者保存寄存器</strong>（callee save）。</p>
<h2 id="数组的分配和访问"><a href="#数组的分配和访问" class="headerlink" title="数组的分配和访问"></a>数组的分配和访问</h2><p>C 语言一个不同寻常的特点是可以产生指向数组中元素的指针，并对这些指针进行运算。在机器代码中，这些指针会被翻译成地址计算。</p>
<p>优化编译器非常善于简化数组索引所使用的地址计算。不过这使得 C 代码和它机器代码的翻译之间的对应关系有些难以理解。</p>
<h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><p>C 语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。也就是说，如果 p 是一个指向类型为 T 的数据的指针，p 的值为 xp，那么表达式 p+i 的值为 xp+L*i，这里 L 是数据类型 T 的大小。</p>
<h3 id="数组与循环"><a href="#数组与循环" class="headerlink" title="数组与循环"></a>数组与循环</h3><p>在循环代码中，对数组的引用通常有非常规则的模式，优化编译器会使用这些模式</p>
<h3 id="嵌套数组"><a href="#嵌套数组" class="headerlink" title="嵌套数组"></a>嵌套数组</h3><blockquote>
<p>int A[5][3];</p>
</blockquote>
<p>等价于下面的声明</p>
<blockquote>
<p>typedef int row3_t[3];<br>row3_t A[5];</p>
</blockquote>
<h3 id="固定大小的数组"><a href="#固定大小的数组" class="headerlink" title="固定大小的数组"></a>固定大小的数组</h3><h3 id="动态分配的数组"><a href="#动态分配的数组" class="headerlink" title="动态分配的数组"></a>动态分配的数组</h3><h2 id="异类的数据结构"><a href="#异类的数据结构" class="headerlink" title="异类的数据结构"></a>异类的数据结构</h2><h3 id="结构（structure）"><a href="#结构（structure）" class="headerlink" title="结构（structure）"></a>结构（structure）</h3><p>将可能不同类型的对象聚合到一个对象中。结构的各个组成部分用名字来引用。类似于数组的实现，结构的所有组成部分都存放在存储器中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段(field)的字节偏移。它以这些偏移作为存储器引用指令中的位移，从而产生对结构元素的引用。</p>
<h3 id="联合（union）"><a href="#联合（union）" class="headerlink" title="联合（union）"></a>联合（union）</h3><p>提供了一种方式，能够规避 C 语言的类型系统，允许以多种类型来引用一个对象。联合声明的语法与结构的语法一样，只不过语义相差比较大。它们是用不同的字段来引用相同的存储器块。</p>
<h2 id="对齐（alignment）"><a href="#对齐（alignment）" class="headerlink" title="对齐（alignment）"></a>对齐（alignment）</h2><p>许多计算机系统对基本数据类型合法地址做出了一些限制，要求某种类型对象的地址必须是某个值 K(通常是 2、4、8)。这种对齐限制简化了形成处理器和存储器系统之间接口的硬件设计</p>
<h2 id="综合：理解指针"><a href="#综合：理解指针" class="headerlink" title="综合：理解指针"></a>综合：理解指针</h2><p>指针是 C 语言的一个重要特征。它们以一种统一方式，对不同数据结构中的元素产生引用。这里介绍一些指针和它们映射到机器代码的关键原则：</p>
<ul>
<li>每个指针都对应一个类型。这个类型表明指针指向哪一类对象。</li>
<li>每个指针都有一个值。这个值是某个指定类型对象的地址。特殊的 NULL(0) 值表示该指针没有指向任何地方</li>
<li>指针用 &amp; 运算符创建。这个运算符可以应用到任何 lvalue 类的 C 表达式上。</li>
<li>操作符用于指针的间接引用。其结果是一个值，它的类型与该指针的类型相关。间接引用是通过存储器引用来实现的，要么是存储到一个指定的地址，要么是从指定的地址读取。</li>
<li>数组与指针紧密联系。一个数组的名字可以像一个指针变量一样引用(但是不能修改)。数组引用与指针运算和间接引用有一样的效果。数组引用和指针运算都需要用对象大小对偏移量进行伸缩。</li>
<li>将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。强制类型转换的一个效果是改变指针运算的伸缩。来看一个例子，如果 p 是一个 char* 类型的指针，那么表达式(int)p+7 计算为 p+28, 而(int)(p+7)计算为 p+7。</li>
<li>指针也可以指向函数。这提供了一个很强大的存储和向代码传递引用的功能，这些引用可以被程序的某个其他部分调用。</li>
</ul>
<h2 id="存储器的越界引用和缓冲区溢出"><a href="#存储器的越界引用和缓冲区溢出" class="headerlink" title="存储器的越界引用和缓冲区溢出"></a>存储器的越界引用和缓冲区溢出</h2><p>C 对于数组引用不进行任何边界检查，而局部变量和状态信息，都存放在栈中。这两种情况结合到一起就可能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行 ret 指令时，就会出现很严重的错误。</p>
<p>缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的通过计算机网络攻击系统安全的方法。通常，输入和程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为攻击代码(exploit code)，另外还有一些字节会用一个指向攻击代码的指针覆盖返回地址。那么执行 ret 指令的效果就是跳转到攻击代码。</p>
<p>一种攻击形式，攻击代码会使用系统调用启动一个外壳程序，给攻击者提供一组操作系统函数。另一种攻击形式是，攻击代码会执行一些未授权的任务，修复对栈的破坏，然后第二次执行 ret 指令，(表面上)正常返回给调用者。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>机器级程序和它们的汇编代码表示，与 C 程序的差别很大。在汇编语言程序中，各种数据类型之间的差别很小。程序是以指令序列来表示的，每条指令都完成一个单独的操作。部分程序状态，如寄存器和运行时栈，对程序员来说是直接可见的。</p>
<p>C 语言中缺乏边界检查，使得许多程序容易出现缓冲区溢出。虽然最近的运行时系统提供了安全保护，而且编译器帮助使得程序更加安全，但是这已经使许多系统容易收到入侵者的恶意攻击。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 信息的表示和处理]]></title>
      <url>/2018/01/24/CSAPP-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第2章笔记</p>
<a id="more"></a>
<h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><p>大部分计算机使用8位的块（或者字节）来作为最小的可寻址的存储器单元。机器级程序将存储器视为一个非常大的字节数组，称之为虚拟存储器。存储器中的每一个字节由唯一的一个地址（address）来标识，所有可能地址的集合称之为虚拟地址空间（virtual address space）</p>
<h3 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h3><p>一个字节有8位，用二进制表示就是 \00000000(2)-11111111(2) ，用十进制表示是0(10)-256(10)，用十六进制表示是00(16)-FF(16)</p>
<h3 id="字"><a href="#字" class="headerlink" title="字"></a>字</h3><p>每台计算机都有一个字长（word size），指明整数和指针数据的标称大小（nominal size），字长决定系统中最重要的参数就是虚拟地址空间的最大大小</p>
<h3 id="数据大小"><a href="#数据大小" class="headerlink" title="数据大小"></a>数据大小</h3><p>计算机和编译器使用不同的方式来编码数字，比如说不同长度的整数和浮点数，从而支持多种数据格式<br><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516797063776.jpg" alt="enter description here"></p>
<p>程序员应该力图使他们的程序在不同的计算机和编译器上可移植，可移植的其中一个方面就是<strong>使程序对不同的数据类型的确切大小不那么敏感</strong></p>
<h3 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h3><p>对于跨多个字节的程序对象，我们必须建立两个规则：这个对象的地址是什么；我们怎样在存储器中对这些字节进行排序</p>
<blockquote>
<p>小端法<br>从低有效字节到高有效字节的顺序存储对象</p>
<p>大端法<br>从高有效字节到低有效字节的顺序存储对象</p>
</blockquote>
<p>对于一个十六进制的数0x01234567：<br><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516797382468.jpg" alt="enter description here"></p>
<p>几种机器所使用的字节顺序会成为问题的情况：</p>
<ul>
<li>在不同类型的机器之间通过网络传送二进制数据。</li>
<li>当阅读表示整数数据的字节序列时，字节顺序也很重要。</li>
<li>当编写规避正常的类型的系统时。</li>
</ul>
<h3 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h3><p>C中的字符串被编码为一个以null（其值为0）字符结尾的字符数组</p>
<h3 id="表示代码"><a href="#表示代码" class="headerlink" title="表示代码"></a>表示代码</h3><p>不同的机器类型使用的是不同的并且不兼容的指令和编码方式，所以最后的二进制代码是有很强的平台依赖性的，其很少能够在不同的操作系统和机器之间进行移植</p>
<h3 id="C中的位级运算"><a href="#C中的位级运算" class="headerlink" title="C中的位级运算"></a>C中的位级运算</h3><p>包括按位与、按位或、异或运算，位运算的一个常见应用就是实现掩码运算（从一个字中选出一个组位）</p>
<h3 id="C中的逻辑运算"><a href="#C中的逻辑运算" class="headerlink" title="C中的逻辑运算"></a>C中的逻辑运算</h3><p>包括逻辑或、逻辑与、逻辑非<br>逻辑运算表达式中，第一个参数能够确定表达式的结果的时候，逻辑运算表达式就不会计算第二个参数的值</p>
<h3 id="C中的移位运算"><a href="#C中的移位运算" class="headerlink" title="C中的移位运算"></a>C中的移位运算</h3><p>向左移位运算右端补0<br>向右移位运算包含两种形式：逻辑移位（左端补0）和算数移位（左端补最高有效位）</p>
<h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2><h3 id="整型数据类型"><a href="#整型数据类型" class="headerlink" title="整型数据类型"></a>整型数据类型</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516799034435.jpg" alt="enter description here"></p>
<h3 id="无符号和二进制补码编码"><a href="#无符号和二进制补码编码" class="headerlink" title="无符号和二进制补码编码"></a>无符号和二进制补码编码</h3><p>假设一共有 w 位，每个介于 0 ~ 2^w -1 之间的数都有唯一一个 w 位的值编码，即这个函数映射是一个双射。</p>
<p>补码表示的是字的最高有效位解释为负权(negative weight)。</p>
<h3 id="有符号数和无符号数之间的转换"><a href="#有符号数和无符号数之间的转换" class="headerlink" title="有符号数和无符号数之间的转换"></a>有符号数和无符号数之间的转换</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516799175770.jpg" alt="enter description here"></p>
<h3 id="C中的有符号数和无符号数"><a href="#C中的有符号数和无符号数" class="headerlink" title="C中的有符号数和无符号数"></a>C中的有符号数和无符号数</h3><p>C 语言允许无符号数和有符号数之间的转换。转换的原则是底层的位表示保持不变。</p>
<h3 id="扩展一个数字的位表示"><a href="#扩展一个数字的位表示" class="headerlink" title="扩展一个数字的位表示"></a>扩展一个数字的位表示</h3><p>零扩展： 将一个无符号数转换为一个更大的数据类型，在开头加0<br>符号扩展： 将一个二进制补码转化为一个更大的数据类型，在开头加最高有效位</p>
<h3 id="截断数字"><a href="#截断数字" class="headerlink" title="截断数字"></a>截断数字</h3><p>截断一个数字可能会改变它的值——溢出的一种形式</p>
<h3 id="有关有符号数和无符号数的建议"><a href="#有关有符号数和无符号数的建议" class="headerlink" title="有关有符号数和无符号数的建议"></a>有关有符号数和无符号数的建议</h3><p>有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为。而这些非直观的特性经常导致程序错误，并且这种包含隐式强制类型转换细微差别的错误很难被发现。因为这种强制类型转换是在代码中没有明确指示的情况下发生的，程序员经常忽视了它的影响。</p>
<p>避免这类错误的一种方法就是绝<strong>不使用无符号数</strong>。实际上，除了 C 以外，很少有语言支持无符号整数。</p>
<h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><h3 id="无符号加法"><a href="#无符号加法" class="headerlink" title="无符号加法"></a>无符号加法</h3><p>每个数都能表示为 w 位无符号数字。如果计算它们的和，表示这个和可能需要 w + 1位。无符号运算可以被视为一种模运算形式。<br><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516800136471.jpg" alt="enter description here"></p>
<h3 id="二进制补码加法"><a href="#二进制补码加法" class="headerlink" title="二进制补码加法"></a>二进制补码加法</h3><p>必须确定当结果太大(为正)或者太小(为负)时，应该做些什么。<br><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516800211055.jpg" alt="enter description here"></p>
<h3 id="二进制补码的乘法"><a href="#二进制补码的乘法" class="headerlink" title="二进制补码的乘法"></a>二进制补码的乘法</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516800273052.jpg" alt="enter description here"></p>
<h3 id="乘以2的幂"><a href="#乘以2的幂" class="headerlink" title="乘以2的幂"></a>乘以2的幂</h3><p>在大多数机器上，整数乘法指令相当慢，需要 10 个或者更多的时钟周期，然而其他整数运算(例如加法、减法、位级运算和移位)只需要 1 个时钟周期。因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。</p>
<h3 id="除以2的幂"><a href="#除以2的幂" class="headerlink" title="除以2的幂"></a>除以2的幂</h3><p>在大多数机器上，整数除法要比整数乘法更慢——需要 30 个或者更多的周期。除以 2 的幂也可以用移位运算右移来实现，无符号和补码数分别使用逻辑移位和算术移位来达到目的。</p>
<h2 id="浮点"><a href="#浮点" class="headerlink" title="浮点"></a>浮点</h2><h3 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516800421224.jpg" alt="enter description here"></p>
<h3 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h3><p>用 V = (-1)^s <em> M </em> 2^E 的形式来表示一个数：</p>
<ul>
<li>符号(sign) s决定这个数是负数(s=1)还是正数(s=0)，对于数值 0 的符号位解释作为特殊情况处理。</li>
<li>尾数(significand) M 是一个二进制小数，它的范围是 1 ~ 2 - ε，或者是 0 ~ 1 - ε。</li>
<li>阶码(exponent) E 的作用是对浮点数加权，这个权重是 2 的 E 次幂(可能是负数)</li>
</ul>
<p>将浮点数的位表示划分为三个字段，分别对这些值进行编码：</p>
<ul>
<li>一个单独的符号位 s 直接编码符号 s。</li>
<li>k 位的阶码字段 exp = e(k-1)…e(1)e(0) 编码阶码 E。</li>
<li>n 位小数字段 frac = f(n-1)…f(1)f(0) 编码尾数 M，但是编码出来的值也依赖于阶码字段的值是否等于 0。</li>
</ul>
<h3 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h3><p>因为表示方法限制类浮点数的范围和精度，浮点运算只能近似地表示实数运算。因此，对于值 x，我们一般想用一种系统的方法，能够找到“最接近的”匹配值，这就是舍入运算的任务。</p>
<p>常见的舍入方式有：向偶数舍入、向零舍入、向下舍入、向上舍入<br><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516800599058.jpg" alt="enter description here"></p>
<h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>浮点加法不具有结合性。浮点乘法在加法上不具备分配性。对于科学计算程序员和编译器编写者来说，这是很严重的问题，即使为了在三维空间中确定两条线是否交叉而写代码这样看上去很简单的任务，也可能成为一个很大的挑战。</p>
<h3 id="C语言的浮点数"><a href="#C语言的浮点数" class="headerlink" title="C语言的浮点数"></a>C语言的浮点数</h3><p>float 和 double。在 int、float 和 double 格式之间进行强制类型转换时，程序改变数值和位模式的原则如下(假设 int 是 32 位的)：</p>
<ul>
<li>从 int 转换成 float，不会溢出，可能被舍入。</li>
<li>从 int 或 float 转换成 double，能够保留精确的数值。</li>
<li>从 double 转换成 float，可能溢出成为正无穷或负无穷，也可能被舍入。</li>
<li>从 float 或者 double 转换成 int，值会向零舍入。例如 1.999 将被转换成 1。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 计算机系统漫游]]></title>
      <url>/2018/01/23/CSAPP%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第1章笔记</p>
<a id="more"></a>
<h2 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位+上下文"></a>信息就是位+上下文</h2><p>整个计算机系统中的所有信息都可以用一串比特串的形式表示，区分不同的数据对象的唯一方法就是我们读到的这些对象时的上下文（context）</p>
<h2 id="程序被其他程序翻译成不同的格式"><a href="#程序被其他程序翻译成不同的格式" class="headerlink" title="程序被其他程序翻译成不同的格式"></a>程序被其他程序翻译成不同的格式</h2><p>一个高级语言写的程序（这里以C语言为例），从源代码到最终的机器中的可执行文件会经过一下几个阶段：</p>
<ol>
<li>预处理阶段，处理源码的中的预处理语句（比如说#include）</li>
<li>编译阶段，将c语言编译成汇编语言</li>
<li>汇编阶段，把汇编语言翻译成机器指令</li>
<li>链接阶段，把在程序中调用的库函数的相关文件引入</li>
</ol>
<h2 id="了解编译系统如何工作室大有益处的"><a href="#了解编译系统如何工作室大有益处的" class="headerlink" title="了解编译系统如何工作室大有益处的"></a>了解编译系统如何工作室大有益处的</h2><p>促使程序员要知道编译系统是如何工作的原因：</p>
<ol>
<li>优化程序性能，我们需要对汇编语言以及编译器如何将不同的C语句转化为汇编语言有基本的了解</li>
<li>理解链接时出现的错误</li>
<li>避免安全漏洞，其中一个比较典型的是缓冲区溢出错误</li>
</ol>
<h2 id="处理器读并解释存储在存储器中的指令"><a href="#处理器读并解释存储在存储器中的指令" class="headerlink" title="处理器读并解释存储在存储器中的指令"></a>处理器读并解释存储在存储器中的指令</h2><p>一个计算机系统的硬件主要由以下几个部分组成：</p>
<ol>
<li>总线，负责携带信息字节并在各个部件之间进行传输</li>
<li>I/O设备，负责系统和外界的联系</li>
<li>主存，运行程序时存放程序以及程序中含有的数据</li>
<li>处理器，解释（或执行）存储在主存中的指令</li>
</ol>
<p>执行一个hello程序的过程有一下几部：</p>
<ul>
<li>shell程序执行其指令，等待我们输入命令</li>
<li>我们输入完命令以后，shell执行一系列指令，将hello程序的代码以及其数据加载到主存中</li>
<li>处理器开始执行hello程序中的机器指令，将“hello world”输出到屏幕上</li>
</ul>
<h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><p>我们使用的存储设备通常是较大的存储设备比较小的存储设备运行地要慢，所以就使用一个较小的速度较快的存储设备作为CPU和Main Memory交换数据的桥梁，这个设备就是高速缓存（cache memories）</p>
<h2 id="形成层次结构的存储结构"><a href="#形成层次结构的存储结构" class="headerlink" title="形成层次结构的存储结构"></a>形成层次结构的存储结构</h2><p>在计算机系统的存储设备被组织成了一个金字塔形的存储层次模型，其中从上到下，设备速度越来越慢，空间越来越大，每字节的造价越来越便宜。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516786032387.jpg" alt="enter description here"></p>
<h2 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h2><p>操作系统可以看成是一个应用程序和硬件之间的一个软件，其有两个基本功能： 防止硬件被失控的程序滥用； 为应用程序提供控制硬件的简单一致的方法</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程可以看成是操作系统对正在运行的程序的一种抽象，在一个系统中可以运行多个进程，这些进程对外表现好像是独占硬件，实际上是通过不同进程之间进程的交互执行实现的，这个过程叫上下文切换（context switch）</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程可以由多个线程组成，运行在一个上下文环境中，共享代码以及全局数据。因为共享数据，使得其比一般的进程更加高效（花在context switch的时间少）。</p>
<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p>给进程提供的一个好像自己独占主存的假象，对于进程的所使用的虚拟存储器可以分成一下几个部分：</p>
<ul>
<li>程序代码和数据</li>
<li>堆，可以动态扩展或者收缩，供像malloc和free这样的C语言中的库进行调用</li>
<li>共享库</li>
<li>栈，可以动态扩展或者收缩，用于编译器的函数调用</li>
<li>内核虚拟存储器</li>
</ul>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516786535550.jpg" alt="enter description here"></p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件可以看成字节序列，每一个I/O设备从本质上来看都可以看成是文件</p>
<h2 id="利用网络系统和其他系统进行通信"><a href="#利用网络系统和其他系统进行通信" class="headerlink" title="利用网络系统和其他系统进行通信"></a>利用网络系统和其他系统进行通信</h2><h2 id="导图"><a href="#导图" class="headerlink" title="导图"></a>导图</h2><p><img src="https://data2.liuin.cn/story-writer/2018_1_24_A%20Tour%20of%20Computer%20System.png" alt="enter description here"></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode Reverse Integer & Palindrome Number 题解]]></title>
      <url>/2018/01/22/LeetCode-Reverse-Integer-Palindrome-Number-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>LeetCode 题解</p>
<a id="more"></a>
<h2 id="Reverse-Integer"><a href="#Reverse-Integer" class="headerlink" title="Reverse Integer"></a>Reverse Integer</h2><p>题目的意思就是翻转一个整数（其中可能是负数），一开始想到的方案是分正数和负数进行讨论：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int reverse(int x) &#123;</div><div class="line">        int cnt=0,negative_flag = 0;</div><div class="line">        long long res =0;</div><div class="line">        if(x&lt;0)</div><div class="line">        &#123;</div><div class="line">            x = -x;</div><div class="line">            negative_flag = 1;</div><div class="line">        &#125;</div><div class="line">        while(x&gt;0)</div><div class="line">        &#123;</div><div class="line">            res = res*10 + x%10;</div><div class="line">            x/=10;</div><div class="line">        &#125;</div><div class="line">        if(res&gt;INT_MAX) return 0;</div><div class="line">        if(negative_flag)</div><div class="line">            return -res;</div><div class="line">        else</div><div class="line">            return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>其实是可以不用处理负数的问题的，更加简洁的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int reverse(int x) &#123;</div><div class="line">        int res =0;</div><div class="line">        while(x)</div><div class="line">        &#123;</div><div class="line">            if(abs(res)&gt;INT_MAX/10) return 0;</div><div class="line">            res = res*10 + x%10;</div><div class="line">            x/=10;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>其中涉及到C++的负数的除法和取余问题，在后面会讲到</p>
<h2 id="Palindrome-Number"><a href="#Palindrome-Number" class="headerlink" title="Palindrome Number"></a>Palindrome Number</h2><p>判断一个数是不是回文数，不可以使用额外的空间</p>
<p>一开始考虑将数进行翻转然后确定是否相等进行判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isPalindrome(int x) &#123;</div><div class="line">        int y = x,res = 0;</div><div class="line">        if(x&lt;0) return false;</div><div class="line">        while(y)</div><div class="line">        &#123;</div><div class="line">            res = res *10 + y%10;</div><div class="line">            y/=10;</div><div class="line">        &#125;</div><div class="line">        if(res == x)</div><div class="line">            return true ;</div><div class="line">        else</div><div class="line">            return false ;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>结果：<br>Your runtime beats 22.66 % of cpp submissions</p>
<p>另外一种方案就是先计算出这个数的位数，然后从两边开始判断，但是好像也没有优化多少。<br>还有可以通过转化为String进行判断，一开始以为这种方案不满足题目的“不可以使用额外的空间”的要求，但是还是能够通过，只不过时间比前面两种方案多很多。</p>
<h2 id="C-负数的除法和取余问题"><a href="#C-负数的除法和取余问题" class="headerlink" title="C++负数的除法和取余问题"></a>C++负数的除法和取余问题</h2><p>C++ 的除法和取余问题：（C++11标准）</p>
<ul>
<li>商一律向0取整（即直接切除小数部分）</li>
<li>对于m/n，如果m和n的符号相同，则结果为正</li>
<li>m%n不等于0，则其结果的符号的m相同</li>
<li>(-m)/n = m/(-n) = -(m/n)  ； m%(-n) = m%n  ； (-m)%n = -(m%n)</li>
</ul>
<p>示例：</p>
<ul>
<li>(-21)%(-8) = (-21)%8 = - (21%8) = -5</li>
<li>-21/-8 = 21/8 = 2</li>
<li>21%(-5) = 21%5 = 1</li>
<li>21/(-5) = -(21/5) = -4</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法技巧 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java servlet 结合Bootstrap-table 展示表格数据]]></title>
      <url>/2018/01/16/Java-servlet-%E7%BB%93%E5%90%88Bootstrap-table-%E5%B1%95%E7%A4%BA%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<p>近期做数据库课设，用到的一个前端展示Table的工具——bootstrap-table，在这里记录一下其用法</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Bootstrap-Table是一个Boostrap的表格插件，能够将JSON数据直接显示在表格中。官方<a href="http://bootstrap-table.wenzhixin.net.cn/" target="_blank" rel="external">网址</a>。里面可以下载使用所需的JS和CSS文件，以及参考文档和例子。</p>
<p>Bootstrap-Table显示数据到表格的方式有两种，一种是客户端（client）模式，一种是服务器（server）模式。</p>
<p>所谓客户端模式，指的是在服务器中把要显示到表格的数据一次性加载出来，然后转换成JSON格式传到要显示的界面中，在JavaWeb中可以保存在request中，然后转发到指定界面，在界面初始化的时候使用EL表达式获取，然后调用相关初始化的函数，将JSON字符串传进去即可显示。客户端模式较为简单，它是把数据一次性加载出来放到界面上，然后根据你设置的每页记录数，自动生成分页。当点击第二页时，会自动加载出数据，不会再向服务器发送请求。同时用户可以使用其自带的搜索功能，可以实现全数据搜索。对于数据量较少的时候，可以使用这个方法。但是对于数据量大的系统，使用该方法会造成加载出一些很久之前的，用户不在关注的数据，使得加载速度变慢，增加了服务器的负担，浪费了资源。这时应该采用服务器模式。</p>
<p>所谓服务器模式，指的是根据设定的每页记录数和当前要显示的页码，发送数据到服务器进行查询，然后再显示到表格中。该方法可以根据用户的需要动态的加载数据，节省了服务器的资源，但是不能使用其自带的全数据搜索功能。因为你加载的数据只是一页的数据，所以全数据搜索的范围也只在一页之中。</p>
<p>这篇文章就以客户端模式为例，服务器模式在客户端模式的基础要多做一个后端分页的处理。</p>
<p>最终做到效果如下：<br>![enter description here][1]</p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>HTML文件中引入相关的JS和CSS，定义一个表格标签，配置相关的boostrap-table属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=utf-8"</span></span></div><div class="line">    <span class="attr">pageEncoding</span>=<span class="string">"utf-8"</span>%&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">%@taglib</span> <span class="attr">uri</span>=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> <span class="attr">prefix</span>=<span class="string">"c"</span>%&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>课程<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">	 <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/styleCourse.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/stylelittle.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></div><div class="line"> 	<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/bootstrap-table.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></div><div class="line"> 	<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/font-awesome.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>  <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"css/jquery-3.2.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>  <span class="attr">src</span>=<span class="string">"css/bootstrap.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"css/jquery.validate.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">script</span>  <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"css/bootstrap-table.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">" line-height:6em;"</span>&gt;</span> <span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></div><div class="line">	<span class="comment">&lt;!--网页中间内容--&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"panelBody"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel panel-default"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel-heading"</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">"panel-title"</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>课程<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel-body"</span>&gt;</span></div><div class="line"></div><div class="line">				<span class="comment">&lt;!--</span></div><div class="line">					here 第一块</div><div class="line">					search</div><div class="line">				--&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"searchArea"</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-4"</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input-group"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"input-group-addon"</span>&gt;</span></div><div class="line">                  Name</div><div class="line">                <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span>  <span class="attr">placeholder</span>=<span class="string">".."</span> <span class="attr">aria-label</span>=<span class="string">".."</span>&gt;</span></div><div class="line">              <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-4"</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input-group"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"input-group-addon"</span>&gt;</span></div><div class="line">                  ID</div><div class="line">                <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span>  <span class="attr">placeholder</span>=<span class="string">"null means all"</span> <span class="attr">aria-label</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">              <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">span</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-default btn-outline"</span>&gt;</span></div><div class="line">                  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"searchText"</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-search"</span> <span class="attr">id</span>=<span class="string">"searchBtn"</span>&gt;</span>  search<span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">                  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">              <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tableShow"</span> <span class="attr">id</span>=<span class="string">"courseTable"</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"table-hover"</span> <span class="attr">id</span>=<span class="string">"productTable"</span>&gt;</span></div><div class="line"></div><div class="line">          <span class="tag">&lt;/<span class="name">table</span>&gt;</span></div><div class="line">       	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在js代码中，使用bootstarpTable对id为productTable的表格进行初始化，其中url参数为请求发送的地址，method为请求发送的方法，dataField为返回的json数据中table要展示的数据在是哪个key对应的value，columns为Table的栏位的定义，也对应的返回的json数据中的各个栏位。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#productTable'</span>).bootstrapTable(&#123;</div><div class="line">    <span class="attr">striped</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">clickToSelect</span>: <span class="literal">true</span>, <span class="comment">//点击行就选中</span></div><div class="line">    silent: <span class="literal">true</span>,</div><div class="line">    <span class="attr">showPaginationSwitch</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">showToggle</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">showColumns</span>: <span class="literal">true</span>,  <span class="comment">//显示隐藏列</span></div><div class="line">    showRefresh: <span class="literal">true</span>,  <span class="comment">//显示刷新按钮</span></div><div class="line">    singleSelect: <span class="literal">true</span>, <span class="comment">//复选框只能选择一条记录</span></div><div class="line">    url: <span class="string">'/course/list'</span>, <span class="comment">//servlet地址</span></div><div class="line">    method: <span class="string">'get'</span>,</div><div class="line">    <span class="attr">dataField</span> : <span class="string">"data"</span>,</div><div class="line">    <span class="attr">queryParams</span>: queryParams, <span class="comment">//查询参数</span></div><div class="line">    locale:<span class="string">'zh-CN'</span>, <span class="comment">//国际化</span></div><div class="line">    pagination: <span class="literal">true</span>, <span class="comment">//开启分页</span></div><div class="line">    sidePagination: <span class="string">'client'</span>, <span class="comment">//服务端分页</span></div><div class="line">    pageSize: <span class="number">10</span>,    <span class="comment">//分页条数</span></div><div class="line">    pageList: [<span class="number">10</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">200</span>],</div><div class="line">    <span class="attr">search</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">idField</span>: <span class="string">'ID'</span>,</div><div class="line">    <span class="attr">columns</span>:[</div><div class="line">    &#123;<span class="attr">field</span>:<span class="string">''</span>,<span class="attr">title</span>:<span class="string">''</span>,<span class="attr">checkbox</span>:<span class="literal">true</span>&#125;, <span class="comment">//复选框</span></div><div class="line">    &#123;<span class="attr">field</span>:<span class="string">'id'</span>,<span class="attr">title</span>:<span class="string">'课程ID'</span>,<span class="attr">align</span> : <span class="string">'center'</span>&#125;,</div><div class="line">    &#123;<span class="attr">field</span>:<span class="string">'name'</span>,<span class="attr">title</span>:<span class="string">'课程名称'</span>,<span class="attr">align</span> : <span class="string">'center'</span>&#125;,</div><div class="line">    &#123;<span class="attr">field</span>:<span class="string">'type'</span>,<span class="attr">title</span>:<span class="string">'类型'</span>,<span class="attr">align</span> : <span class="string">'center'</span>&#125;,</div><div class="line">    &#123;<span class="attr">field</span>:<span class="string">'credit'</span>,<span class="attr">title</span>:<span class="string">'学分'</span>,<span class="attr">align</span> : <span class="string">'center'</span>&#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">title</span> : <span class="string">'操作'</span>,</div><div class="line">            <span class="attr">field</span> : <span class="string">'id'</span>,</div><div class="line">            <span class="attr">align</span> : <span class="string">'center'</span>,</div><div class="line">            <span class="attr">formatter</span> : <span class="function"><span class="keyword">function</span>(<span class="params">value, row, index</span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> e = <span class="string">'&lt;a href="#" mce_href="#" onclick="edit(\''</span></div><div class="line">                    + row.id + <span class="string">'\',\''</span>+row.name+<span class="string">'\')"&gt;编辑&lt;/a&gt; '</span>;</div><div class="line">                <span class="keyword">var</span> d = <span class="string">'&lt;a href="#" mce_href="#" onclick="del(\''</span></div><div class="line">                    + row.id + <span class="string">'\')"&gt;删除&lt;/a&gt; '</span>;</div><div class="line">                <span class="keyword">var</span> f = <span class="string">'&lt;a href=/course/detail?course_id='</span>+row.id+<span class="string">'&gt;详情&lt;/a&gt;'</span>;</div><div class="line">                <span class="keyword">return</span> e + d + f;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryParams</span>(<span class="params">params</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">NAME</span>:params.search, <span class="comment">//开启自带查询后输入的值</span></div><div class="line">        ISDEL:<span class="number">0</span>,</div><div class="line">        <span class="attr">pageSize</span>: params.limit, <span class="comment">//分页条数</span></div><div class="line">        pageNumber: params.pageNumber <span class="comment">//当前页数</span></div><div class="line">    &#125;;</div><div class="line">&#125; <span class="comment">//在这里你可以自己定义查询的参数</span></div></pre></td></tr></table></figure>
<p>json 数据实例：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"data"</span>:</div><div class="line">  [</div><div class="line">    &#123;</div><div class="line">    <span class="attr">"id"</span>:<span class="string">"XXXXXX"</span>,</div><div class="line">    <span class="attr">"name"</span>: <span class="string">"语文"</span>,</div><div class="line">    <span class="attr">"type"</span>: <span class="string">"必修"</span>,</div><div class="line">    <span class="attr">"credit"</span>: <span class="number">4.0</span></div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>后端要做的事情就是接受前端发来的请求，返回要展示的table数据就行了（按照相应的格式）</p>
<p>主要处理代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@WebServlet</span>(<span class="string">"/course/list"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetCourselistServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException,IOException </span>&#123;</div><div class="line"></div><div class="line">        response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</div><div class="line">        response.setContentType(<span class="string">"application/json; charset=utf-8"</span>);</div><div class="line"></div><div class="line">        CourseDaoImpl c = <span class="keyword">new</span> CourseDaoImpl();</div><div class="line">        List&lt;Course&gt; res = c.getAllCourse();</div><div class="line">        String jsonStr = Obj2Json.Course2Json(res);    <span class="comment">// 将获得Course List数据转化为json格式</span></div><div class="line"></div><div class="line">        PrintWriter out = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            out = response.getWriter();</div><div class="line">            out.write(jsonStr);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</div><div class="line">                out.close();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException,IOException</span>&#123;</div><div class="line">        doGet(request,response);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h2><p>首先就是要在前端加两个输入表单的table：（这里只放修改的div代码，增加表单的代码类似）<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal fade"</span> <span class="attr">id</span>=<span class="string">"updateModal"</span> <span class="attr">tabindex</span>=<span class="string">"-1"</span> <span class="attr">role</span>=<span class="string">"dialog"</span></span></div><div class="line">     <span class="attr">aria-labelledby</span>=<span class="string">"myModalLabel"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-dialog"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-content"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-header"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"close"</span> <span class="attr">data-dismiss</span>=<span class="string">"modal"</span></span></div><div class="line">                        <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;×<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"modal-title"</span> <span class="attr">id</span>=<span class="string">"myModalLabel"</span>&gt;</span>修改课程<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-body"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">form</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">label</span>&gt;</span>课程ID<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span></span></div><div class="line">                                                   <span class="attr">id</span>=<span class="string">"updateId"</span>&gt;</div><div class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">label</span>&gt;</span>课程名称<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span></span></div><div class="line">                                                   <span class="attr">id</span>=<span class="string">"updateName"</span>&gt;</div><div class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">label</span>&gt;</span>课程类型<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"updateType"</span> <span class="attr">class</span>=<span class="string">"form-control"</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">0</span>&gt;</span>必修<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">1</span>&gt;</span>选修<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">label</span>&gt;</span>学分<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">class</span>=<span class="string">"form-control"</span></span></div><div class="line">                                                 <span class="attr">id</span>=<span class="string">"updateCredit"</span>&gt;</div><div class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-footer"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span> <span class="attr">data-dismiss</span>=<span class="string">"modal"</span>&gt;</span>关闭</div><div class="line">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span> <span class="attr">id</span>=<span class="string">"updateConfirmBtn"</span>&gt;</span>提交更改<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- /.modal-content --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- /.modal-dialog --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后就是JavaScript对增删改的处理了，这个应该是这个里面最关键的东西：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 单独删除按键</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">del</span>(<span class="params">id</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (confirm(<span class="string">"是否删除?"</span>)) &#123;</div><div class="line">        $.ajax(&#123;</div><div class="line">            <span class="attr">url</span> : <span class="string">"/course/delete"</span>,</div><div class="line">            <span class="attr">method</span>: <span class="string">"post"</span>,</div><div class="line">            <span class="attr">data</span> : &#123;</div><div class="line">                <span class="string">"id"</span> : id</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">success</span> : <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">                alert(<span class="string">"删除成功！"</span>);</div><div class="line">                <span class="comment">//重新加载表格</span></div><div class="line">                $(<span class="string">"#table"</span>).bootstrapTable(<span class="string">"refresh"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//编辑按钮点击事件</span></div><div class="line"><span class="keyword">var</span> idGlobal = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">edit</span>(<span class="params">id,name</span>) </span>&#123;</div><div class="line">    $(<span class="string">"#updateModal"</span>).modal(<span class="string">'show'</span>);</div><div class="line">    idGlobal = id;</div><div class="line">    <span class="comment">//信息</span></div><div class="line">    $(<span class="string">"#updateId"</span>).val(id);</div><div class="line">    $(<span class="string">"#updateName"</span>).val(name);</div><div class="line">    $(<span class="string">"#updateType"</span>).val(<span class="number">0</span>);</div><div class="line">    $(<span class="string">"#updateCredit"</span>).val(<span class="string">""</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//编辑模态框下确认按钮的点击事件</span></div><div class="line">$(<span class="string">"#updateConfirmBtn"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $(<span class="string">"#updateModal"</span>).modal(<span class="string">'hide'</span>);</div><div class="line">    $.ajax(&#123;</div><div class="line">        <span class="attr">url</span> : <span class="string">"/course/update"</span>,</div><div class="line">        <span class="attr">method</span> : <span class="string">'post'</span>,</div><div class="line">        <span class="attr">data</span> : &#123;</div><div class="line">            <span class="attr">id</span> : idGlobal,</div><div class="line">            <span class="attr">name</span> : $(<span class="string">"#updateName"</span>).val(),</div><div class="line">            <span class="attr">type</span>: $(<span class="string">"#updateType"</span>).val(),</div><div class="line">            <span class="attr">credit</span>: $(<span class="string">"#updateCredit"</span>).val()</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">success</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            alert(<span class="string">"修改成功！"</span>);</div><div class="line">            <span class="comment">//重新加载表格</span></div><div class="line">            $(<span class="string">"#table"</span>).bootstrapTable(<span class="string">"refresh"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//添加按钮点击事件</span></div><div class="line">$(<span class="string">"#btn_save"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//借用修改的模态框</span></div><div class="line">    $(<span class="string">"#saveModal"</span>).modal(<span class="string">'show'</span>);</div><div class="line">    <span class="comment">//清楚输入框信息</span></div><div class="line">    $(<span class="string">"#saveId"</span>).val(<span class="string">""</span>);</div><div class="line">    $(<span class="string">"#saveName"</span>).val(<span class="string">""</span>);</div><div class="line">    $(<span class="string">"#saveType"</span>).val(<span class="number">0</span>);</div><div class="line">    $(<span class="string">"#saveCredit"</span>).val(<span class="string">""</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//添加用户模态框下的确认按钮点击事件</span></div><div class="line">$(<span class="string">"#saveConfirmBtn"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $(<span class="string">"#saveModal"</span>).modal(<span class="string">'hide'</span>);</div><div class="line">    $.ajax(&#123;</div><div class="line">        <span class="attr">url</span> : <span class="string">"/course/add"</span>,</div><div class="line">        <span class="attr">method</span> : <span class="string">'post'</span>,</div><div class="line">        <span class="attr">datatype</span>:<span class="string">'json'</span>,</div><div class="line">        <span class="attr">data</span> : &#123;</div><div class="line">            <span class="attr">id</span> : $(<span class="string">"#saveId"</span>).val(),</div><div class="line">            <span class="attr">name</span> : $(<span class="string">"#saveName"</span>).val(),</div><div class="line">            <span class="attr">type</span>: $(<span class="string">"#saveType"</span>).val(),</div><div class="line">            <span class="attr">credit</span>: $(<span class="string">"#saveCredit"</span>).val()</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">success</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            alert(<span class="string">"添加成功！"</span>);</div><div class="line">            <span class="comment">//重新加载表格</span></div><div class="line">            $(<span class="string">"#productTable"</span>).bootstrapTable(<span class="string">"refresh"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>后端代码就是常规的处理逻辑，根据get请求的参数实施对数据库的操作</p>
<hr>
<p><a href="http://blog.csdn.net/lzx_longyou/article/details/50563907" target="_blank" rel="external">参考1</a></p>
<p>  [1]: <a href="https://data2.liuin.cn/story-writer/2018_1_19_1516292440320.jpg" target="_blank" rel="external">https://data2.liuin.cn/story-writer/2018_1_19_1516292440320.jpg</a> “效果”</p>
]]></content>
      
        <categories>
            
            <category> Web开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[台湾交换总结]]></title>
      <url>/2018/01/15/%E5%8F%B0%E6%B9%BE%E4%BA%A4%E6%8D%A2%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>131天，在湾湾的这些时候一定会是我人生中最难忘的记忆。感受到的东西、收获到的东西实在是太多了。如果回到当初做决定的那个时刻，我还会选台湾！</p>
<a id="more"></a>
<h2 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴"></a>时间轴</h2><ul>
<li>2017.9.5 到达台湾第一天，等房东，打扫房间到很晚</li>
<li>2017.9.8 台科大召开说明会，正式开启交换生活</li>
<li>2017.9.9 第一次出游——淡水之行，红毛城、小白宫、渔人码头</li>
<li>2017.9.10 第一次逛三校（台大、台科大、台师大）</li>
<li>2017.9.12 上的第一堂课，资讯安全导论，但是老师不给加签</li>
<li>2017.9.14 第一堂台大的课，Compiler，成为我交换的这一个学期里面最有挑战的课</li>
<li>2017.9.16 总统府、中正纪念堂、国家图书馆、101夕阳与夜景、象山，这一天去的地方有点多，遇见了好哥们——祥哥</li>
<li>2017.9.23 十分、九份、看阿妹茶楼，买到了一个“十分幸福”的纪念品</li>
<li>2017.9.29 师大的第一堂游泳课</li>
<li>2017.10.4 独自一人跑去故宫博物馆、国父纪念馆，依然记得当时天气是小雨，我在故宫博物馆前拍了好久的延时摄影</li>
<li>2017.10.7 联假开始，到达花莲，游玩鲤鱼潭，一路风雨相伴，偶尔有点小太阳，遇见张阿姨，入住超赞的海景民宿</li>
<li>2017.10.8 一日太鲁阁包车游，清水断崖的美景依旧在我的脑海中，还有七星潭的浪和突如其来的大雨</li>
<li>2017.10.9 骑电动机车绕花莲耍，又到了一次七星潭，晚上在罗东夜市看了难忘的烟火表演</li>
<li>2017.10.10 兰阳博物馆，超赞的建筑</li>
<li>2017.10.19 第一次进台大图书馆，感觉是自己见过的最赞的图书馆，之后每个周末必来</li>
<li>2017.10.21 动物园+猫空缆车，门票超便宜</li>
<li>2017.10.26 Compiler期中考试，考得极差，在椰林大道坐了很久，考虑要不要放弃，最后还好坚持了下来</li>
<li>2017.10.28 祥哥陪我看午夜电影，在网吧玩了一个通宵，见识了凌晨四点的台北，迎来了我的第20岁生日，晚上的party很开心</li>
<li>2017.11.11 台湾社会变迁老师带领参观景美人权文化园区，学习许多台湾的历史</li>
<li>2017.11.18 在台北捷运上待了一天，集了44个台北捷运站纪念章，晚上累趴</li>
<li>2017.11.25 凌晨和祥哥爬剑潭山，走了一段伸手不见五指的山路，从不同的角度见识了台北的夜景。回家的时候为了省钱骑Ubike，半路雨越下越大，到家的时候已经是凌晨四点，全身湿透</li>
<li>2017.11.26 台湾科技馆，当了一回小朋友</li>
<li>2017.12.2 台中玩耍，高美湿地的风真心大，晚上第一次住上下铺的民宿，一起的马拉西亚小伙和湾湾国中老师讲了很多我不曾了解的事情</li>
<li>2017.12.3 打卡路思义教堂，台湾美术馆看了很美的但是看不懂的东西</li>
<li>2017.12.9 和台陆会的小伙伴一起骑行湾湾极东</li>
<li>2017.12.16 和小姐姐们一起去了阿里山看日出，冬季在台北待久了只要能看到太阳就美滋滋，晚上感受了演唱会的那种热情</li>
<li>2017.12.21 凌晨一点搭最后一班捷运去官渡大桥看日出</li>
<li>2017.12.23 和祥哥屁颠屁颠跑到日月潭，坐船绕日月潭玩了一圈</li>
<li>2017.12.24 看了一场美到爆的日出，环日月潭骑行</li>
<li>2017.12.30 台北2018世界新车大展（其实是去看车模的）</li>
<li>2018.1.1 两个大男生爬剑南山被两只流浪狗吓跑；四四南村，台北101的烟火带着我们一行四人走进2018的大门</li>
<li>2018.1.5 晚上爬金面山，最后看一眼台北夜景</li>
<li>2018.1.12 考完最后一门考试，舍不得离开</li>
<li>2018.1.13 填完自己挖的坑，又在台北捷运上待了半天，集齐想要的捷运纪念章</li>
<li>2018.1.14 再见了，湾湾</li>
</ul>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>从湾湾这边课程专业知识方面来说我还是学到很多的，个人觉得台湾的老师能够更多的结合实际的应用，课堂上老师能够带来当下最新的技术的一些介绍和讲解。台科大这边的有些专业课会有一个业界讲师演讲的部分，请到IT领域的从业者来从他们的角度讲我们学的东西以及行业中要用到的东西，这可能会使得我们更有参与感（感觉我们学的东西就是身边用的）。可能以上的这些差别跟湾湾这边更加注重产学结合有关吧，台科大和台大貌似每个系都有产学结合办公室负责这一块的东西。</p>
<p>还有一个原因我觉得是老师方面的，我在台科大和台大修的课有一半的老师的经历是在行业内的一些知名的公司就职了一段时间以后转到高校来任教的，所以自然课堂上的内容就会和实际业界使用的东西结合起来。</p>
<p>但是时间是有限的，如果花了很多的时间花在讲解介绍最新应用和技术上面，在课堂教学的时候花在专业知识的详细讲解上面的经历就会减少，所以想要学到东西很多时候就需要自学了，就像OS课一样，课堂上看起来很有趣，本身课程也非常有意义，要我们去trace一个操作系统的代码然后增加一些system call，但是这个是要我们课后花非常多的时间的，如果一开始没有做好的话后面就会妥协，最后做出来的东西的质量学到的东西的质量自然也会大打折扣。</p>
<p>这一点做得非常好的是我在台大所学的Compiler的老师，老师之前是美国HP里面的资深Compiler工程师，他能够把Compiler的基本知识讲清楚，又能够带来最新的一些资讯（比如台大和ARM公司合作的什么内容），通过有难度的作业让学生做一个基础的Compiler，感受Compiler从设计到细节实现的各方面的东西。之前看过一篇关于中美大学教育差异的文章，其中讲到一点是美国的课程少而精而中国的课程比较多，个人感觉这门Compiler课是和美国教育最像的一门课，每周上课3个学时，课外至少要花6个学时以上（可能也是我不太适应英文环境的原因吧），还有小班讨论、助教制度等等都和美国那边挺像的。</p>
<p>资料库的老师本身是软件公司的架构师转过来的，能够从数据库的角度更多得带来程序开发与服务架构方面的东西，这些可能就是台湾那边科技大学的特色吧。感觉老师能够用白话的形式把一些比较难的概念讲得比较清楚，或许这就是真正的大佬吧。</p>
<p>总之各个专业课的教授方式和我在大陆学校还是有蛮大的区别的，可以说各有各的优点吧。</p>
<h2 id="课外活动"><a href="#课外活动" class="headerlink" title="课外活动"></a>课外活动</h2><p>课外活动方面感觉差别不是很大，专业方面湾湾这边有各种专业社团的社课（有各种干货），大陆这边我所在学校好像实验室的大佬貌似也有这种分享活动。差不多是一种性质的吧。</p>
<p>能够感受到的一点差别就是湾湾这边公司和大师的讲座相对丰富一些，专业方面有很多知名企业和人物来办讲座（我了解到的有Intel的AI讲座、微软亚洲研究院院长的讲座等等），非专业方面的讲座一般是由学生组织请的比较有名的任务来演讲，每周在Facebook上有很多各个学校的这种类型讲座宣传，所以只要你想听，基本上周一到周五的晚上都能够排满。</p>
<h2 id="生活方式"><a href="#生活方式" class="headerlink" title="生活方式"></a>生活方式</h2><p>可以说在台北和在宣城完全是两种不同的生活方式，在宣城感觉更像是高三的时候在一个封闭刻苦的环境下钻研学习的那种模式，三点一线：学校、食堂、教室（实验室），唯一多了的就是能够使用网络。周末能够去市区玩一下，但是除了看电影吃饭感觉就没有什么东西能够玩的了。除了网络感觉没有什么能够点缀我们的生活的了。生活的便利性全部靠网购来维持。</p>
<p>而在台湾则是另外一种比较不同的生活方式，更像是一个上班族的一种生活方式或者是影视作品里面大学生的那种生活方式。早上起床，坐公交车去学校上课，上课的地点分布在不同的教学楼间（有的时候还要跨校上课），晚上想自习到几点都有地方能够给你待，公交车最晚能够到凌晨，不行还有Ubike可以骑。在学校的晚上会去健身房转一圈，每个星期安排两次游泳练习。周末感觉有永远玩不完的地方，放长一点的假期还能够去远一点的地方玩一下。因为是在一个比较大的城市里面，各种设施都非常全，不管几点只要你带钱了，你就饿不着（遍地的711和全家）。</p>
<p>当然以上的这些差别有很大一部分因素是主观意愿导致的，在大陆可能更加注重学习所以没有关注相关的活动，在台湾则希望能够多玩一会多体验一下湾湾的特色生活，所以会关注甚至发起一些活动。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>湾湾交换生涯带给我的除了这些东西，我想还有的就是人生路上这段难忘的经历吧。</p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从零开始配置Ubuntu基本开发环境]]></title>
      <url>/2018/01/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEUbuntu%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<p>最近要配置一个能够进行轻度开发的Ubuntu虚拟机，在这里记录一下从零开始配置的过程，持续更新</p>
<a id="more"></a>
<h2 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><h3 id="设置UTC"><a href="#设置UTC" class="headerlink" title="设置UTC"></a>设置UTC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/default/rcS</div></pre></td></tr></table></figure>
<p>将UTC=no改为UTC=yes</p>
<h3 id="生成公钥私钥"><a href="#生成公钥私钥" class="headerlink" title="生成公钥私钥"></a>生成公钥私钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygon</div></pre></td></tr></table></figure>
<p>然后可以将公钥加入到github、bitbucket、gitlab等代码托管平台中，方便将仓库中的代码克隆到本地</p>
<h2 id="必备软件配置"><a href="#必备软件配置" class="headerlink" title="必备软件配置"></a>必备软件配置</h2><h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><p>必备编辑器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install vim</div></pre></td></tr></table></figure></p>
<h3 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h3><p>必备浏览器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">13  sudo wget http://www.linuxidc.com/files/repo/google-chrome.list -P /etc/apt/sources.list.d/</div><div class="line">14  wget -q -O - https://dl.google.com/linux/linux_signing_key.pub  | sudo apt-key add -</div><div class="line">15  sudo apt-get update</div><div class="line">16  sudo apt-get install google-chrome-stable</div><div class="line">17  /usr/bin/google-chrome-stable</div></pre></td></tr></table></figure></p>
<p>安装完成以后锁定Chrome到Launcher就行了<br><a href="http://www.linuxidc.com/Linux/2016-05/131096.htm" target="_blank" rel="external">参考</a></p>
<h3 id="Shadowsocks-qt5"><a href="#Shadowsocks-qt5" class="headerlink" title="Shadowsocks-qt5"></a>Shadowsocks-qt5</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>查看<a href="https://appimage.org/" target="_blank" rel="external">Appimage</a>介绍<br>到<a href="https://github.com/shadowsocks/shadowsocks-qt5/releases" target="_blank" rel="external">这里</a>下载最新的发布版本<br>运行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod a+x Shadowsocks-Qt5-x86_64.AppImage</div><div class="line">./Shadowsocks-Qt5-x86_64.AppImage</div></pre></td></tr></table></figure></p>
<p>为了避免每次开ss的时候都要开一个终端，可以使用nohup让其在后台运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">echo &quot;nohup /home/sixzeroo/ss/Shadowsocks-Qt5-3.0.0-x86_64.AppImage &amp;&quot; &gt;&gt; ~/ss/start.sh</div><div class="line">sudo chmod +x start.sh</div><div class="line">sudo ln -s /home/sixzeroo/ss/start.sh /usr/local/bin/ss_start</div></pre></td></tr></table></figure></p>
<p>这样以后只要运行ss_start然后关掉terminal就能够运行了<br><a href="https://github.com/shadowsocks/shadowsocks-qt5/wiki/Installation" target="_blank" rel="external">参考</a></p>
<h4 id="Chrome-代理配置"><a href="#Chrome-代理配置" class="headerlink" title="Chrome 代理配置"></a>Chrome 代理配置</h4><p>除了安装ss，还需要配置下浏览器到指定到代理端口比如1080才可以正式上网。这里使用SwitchyOmega插件，下载<a href="https://github.com/FelisCatus/SwitchyOmega/releases/" target="_blank" rel="external">https://github.com/FelisCatus/SwitchyOmega/releases/</a> ，然后打开 chrome://extensions ,将下载的插件拖入浏览器中</p>
<p>配置一个代理到你ss设置的端口就完成了连接。</p>
<p><a href="https://www.sundabao.com/ubuntu%E4%BD%BF%E7%94%A8shadowsocks/" target="_blank" rel="external">参考</a></p>
<h3 id="Google-拼音输入法"><a href="#Google-拼音输入法" class="headerlink" title="Google 拼音输入法"></a>Google 拼音输入法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install fcitx fcitx-googlepinyin im-config</div><div class="line">im-config</div></pre></td></tr></table></figure>
<p>参照<a href="https://www.linuxdashen.com/ubuntu%E5%AE%89%E8%A3%85%E8%B0%B7%E6%AD%8C%E6%8B%BC%E9%9F%B3%E8%BE%93%E5%85%A5%E6%B3%95%EF%BC%88fcitx%E8%BE%93%E5%85%A5%E6%B3%95%E6%A1%86%E6%9E%B6%EF%BC%89" target="_blank" rel="external">这里</a>进行配置，需要注意的是Text Entry可能在System setting里面</p>
<h2 id="可选软件配置"><a href="#可选软件配置" class="headerlink" title="可选软件配置"></a>可选软件配置</h2><h3 id="Axel"><a href="#Axel" class="headerlink" title="Axel"></a>Axel</h3><p>Axel 命令行多线程下载工具，在命令行指定多个线程同时下载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install axel</div></pre></td></tr></table></figure></p>
<h3 id="thefuck"><a href="#thefuck" class="headerlink" title="thefuck"></a>thefuck</h3><p>命令行一件纠错软件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt update</div><div class="line">sudo apt install python3-dev python3-pip</div><div class="line">sudo pip3 install thefuck</div></pre></td></tr></table></figure></p>
<h2 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h2><h3 id="zsh配置"><a href="#zsh配置" class="headerlink" title="zsh配置"></a>zsh配置</h3><p>首先安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install zsh</div><div class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</div></pre></td></tr></table></figure></p>
<p>修改系统默认的shell：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chsh -s /bin/zsh</div></pre></td></tr></table></figure></p>
<p>主题配置：<br>安装bullet-train 主题：<br>下载<a href="https://raw.githubusercontent.com/caiogondim/bullet-train-oh-my-zsh-theme/master/bullet-train.zsh-theme" target="_blank" rel="external">配置文件</a>，放置到$ZSH_CUSTOM/themes/ 目录下<br>.zshrc 配置文件见github<br>可能会遇到的问题：提示没有node命令，安装nodejs npm，ls更改bullet-train 中的配置node为nodejs</p>
<p>安装主题相关字体：<br>因为主题中一些三角形的符号需要powerline字体，所以要进行安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install fonts-powerline</div></pre></td></tr></table></figure></p>
<h3 id="Vim配置"><a href="#Vim配置" class="headerlink" title="Vim配置"></a>Vim配置</h3><p>可以参考<a href="https://www.jianshu.com/p/a0b452f8f720" target="_blank" rel="external">这里</a></p>
<p>我是直接用原来电脑的.vimrc替换.vimrc文件然后通过vunble进行安装的</p>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用 Docker Compose 构建复杂应用]]></title>
      <url>/2018/01/07/%E7%94%A8-Docker-Compose-%E6%9E%84%E5%BB%BA%E5%A4%8D%E6%9D%82%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>本文介绍Docker三剑客之一的Compose的一些基本使用方法。</p>
<a id="more"></a>
<p>cker Compose</p>
<p>Compose 是运行多个Docker容器的工具，可以在一个文件中定义一个多容器的应用，然后使用一条命令来启动你的应用，然后所有相关的操作都会被自动完成。使用Compose的一个比较直观的好处就是在构建一个多个容器组成的应用的时候少打Docker的命令</p>
<p>Compose的特性有如下几个：</p>
<ul>
<li>在单个主机上建立多个独立的环境</li>
<li>创建容器的时候保护数据卷</li>
<li>只有在容器改变的时候才重新创建</li>
<li>将变量和环境结合</li>
</ul>
<p>在<code>docker-compose.yml</code>配置文件中，主要配置四个方面的东西：version、service、network、volumes</p>
<p>version 是表示Compose file的版本，与其对应的是Docker的发布版本，一般使用的version是3.0</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>service定义构建整个应用的每一个容器，相当于给出命令<code>docker container create</code>的参数，然后创建相关的容器。以下是一些常用的配置标签：</p>
<h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>指定构建容器的镜像名称或者镜像ID<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">image: redis</div><div class="line">image: ubuntu:14.04</div><div class="line">image: tutum/influxdb</div><div class="line">image: example-registry.com:4000/postgresql</div><div class="line">image: a4bc65fd</div></pre></td></tr></table></figure></p>
<h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>容器的构建参数配置，可以指定为一个构建上下文的路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">version: &apos;3&apos;</div><div class="line">services:</div><div class="line">  webapp:</div><div class="line">    build: ./dir</div></pre></td></tr></table></figure></p>
<h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><p>可以使用command重写容器启动后默认执行的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">command: bundle exec thin -p 3000</div><div class="line">或</div><div class="line">command: [&quot;bundle&quot;, &quot;exec&quot;, &quot;thin&quot;, &quot;-p&quot;, &quot;3000&quot;]</div></pre></td></tr></table></figure></p>
<h3 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h3><p>不使用默认生成的容器名称（默认是&lt;项目名称&gt;&lt;服务名称&gt;&lt;序号&gt;），自己定义名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">container_name: app</div></pre></td></tr></table></figure></p>
<h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h3><p>配置两个容器之间的依赖关系，也决定了构建顺序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">version: &apos;3&apos;</div><div class="line">services:</div><div class="line">  web:</div><div class="line">    build: .</div><div class="line">    depends_on:</div><div class="line">      - db</div><div class="line">      - redis</div><div class="line">  redis:</div><div class="line">    image: redis</div><div class="line">  db:</div><div class="line">    image: postgres</div></pre></td></tr></table></figure></p>
<h3 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h3><p>制定DNS服务器，可以是一个单一的值也可以是一个列表<br><figure class="highlight plain"><figcaption><span>8.8.8.8</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dns:</div><div class="line">  - 8.8.8.8</div><div class="line">  - 9.9.9.9</div></pre></td></tr></table></figure></p>
<h3 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h3><p>临时挂载目录到容器内<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tmpfs: /run</div><div class="line">tmpfs:</div><div class="line">  - /run</div><div class="line">  - /tmp</div></pre></td></tr></table></figure></p>
<h3 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h3><p>重写容器的进入点，可以是单一的值或者是list<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">entrypoint:</div><div class="line">    - php</div><div class="line">    - -d</div><div class="line">    - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so</div><div class="line">    - -d</div><div class="line">    - memory_limit=-1</div><div class="line">    - vendor/bin/phpunit</div><div class="line"> 或者</div><div class="line"> entrypoint: /code/entrypoint.sh</div></pre></td></tr></table></figure></p>
<h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>添加环境变量，可以用dict或者list，但是boolean值要使用单引号括起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">environment:</div><div class="line">  RACK_ENV: development</div><div class="line">  SHOW: &apos;true&apos;</div><div class="line">  SESSION_SECRET:</div><div class="line"></div><div class="line">environment:</div><div class="line">  - RACK_ENV=development</div><div class="line">  - SHOW=true</div><div class="line">  - SESSION_SECRET</div></pre></td></tr></table></figure></p>
<h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h3><p>用于暴露指定的端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">expose:</div><div class="line"> - &quot;3000&quot;</div><div class="line"> - &quot;8000&quot;</div></pre></td></tr></table></figure></p>
<h3 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h3><p>映射指定的端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ports:</div><div class="line"> - &quot;3000&quot;</div><div class="line"> - &quot;8000:8000&quot;</div><div class="line"> - &quot;49100:22&quot;</div><div class="line"> - &quot;127.0.0.1:8001:8001&quot;</div></pre></td></tr></table></figure></p>
<h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p>挂载主机目录或者命名卷到service的容器中，如果使用命名卷必须要在top-level中的volumes定义这个命名卷</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">version: &quot;3.2&quot;</div><div class="line">services:</div><div class="line">  web:</div><div class="line">    image: nginx:alpine</div><div class="line">    volumes:</div><div class="line">      - type: volume</div><div class="line">        source: mydata</div><div class="line">        target: /data</div><div class="line">        volume:</div><div class="line">          nocopy: true</div><div class="line">      - type: bind</div><div class="line">        source: ./static</div><div class="line">        target: /opt/app/static</div><div class="line"></div><div class="line">  db:</div><div class="line">    image: postgres:latest</div><div class="line">    volumes:</div><div class="line">      - &quot;/var/run/postgres/postgres.sock:/var/run/postgres/postgres.sock&quot;</div><div class="line">      - &quot;dbdata:/var/lib/postgresql/data&quot;</div><div class="line"></div><div class="line">volumes:</div><div class="line">  mydata:</div><div class="line">  dbdata:</div></pre></td></tr></table></figure>
<h3 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h3><p> 指定加入的网络，这个网络必须在top-level的Network中定义：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">services:</div><div class="line"> some-service:</div><div class="line">   networks:</div><div class="line">    - some-network</div><div class="line">    - other-network</div></pre></td></tr></table></figure></p>
<p> 也可以使用ALIASES来为这个容器在不同的网络中使用不同的名字，使得其在不同的网络中可以发挥不同的作用</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"> version: &apos;2&apos;</div><div class="line"></div><div class="line">services:</div><div class="line">  web:</div><div class="line">    build: ./web</div><div class="line">    networks:</div><div class="line">      - new</div><div class="line"></div><div class="line">  worker:</div><div class="line">    build: ./worker</div><div class="line">    networks:</div><div class="line">      - legacy</div><div class="line"></div><div class="line">  db:</div><div class="line">    image: mysql</div><div class="line">    networks:</div><div class="line">      new:</div><div class="line">        aliases:</div><div class="line">          - database</div><div class="line">      legacy:</div><div class="line">        aliases:</div><div class="line">          - mysql</div><div class="line"></div><div class="line">networks:</div><div class="line">  new:</div><div class="line">  legacy:</div></pre></td></tr></table></figure>
<h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><p>重启配置，默认值为“no”在任何环境下都不重启，<code>always</code>指定其在任何时候都进行重启，<code>on-failure</code>只有在返回值表明是error的时候才重启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">restart: &quot;no&quot;</div><div class="line">restart: always</div><div class="line">restart: on-failure</div><div class="line">restart: unless-stopped</div></pre></td></tr></table></figure></p>
<h2 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h2><p>volumes是Docker应用首选的一种机制，其具体的模式可以看<a href="https://docs.docker.com/engine/admin/volumes/volumes/" target="_blank" rel="external">这里</a>，下面这一张图表示了Volumes的三种模式的差异：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_21_1516522519598.jpg" alt="enter description here"></p>
<p>Compose的配置文件中使用<code>volumes</code>定义应用中用到的数据卷容器，使得各个容器之间能够共用数据。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">version: &quot;3&quot;</div><div class="line"></div><div class="line">services:</div><div class="line">  db:</div><div class="line">    image: db</div><div class="line">    volumes:</div><div class="line">      - data-volume:/var/lib/db</div><div class="line">  backup:</div><div class="line">    image: backup-service</div><div class="line">    volumes:</div><div class="line">      - data-volume:/var/lib/backup/data</div><div class="line"></div><div class="line">volumes:</div><div class="line">  data-volume:</div></pre></td></tr></table></figure></p>
<h3 id="external"><a href="#external" class="headerlink" title="external"></a>external</h3><p>如果定义为<code>true</code>，表示这个数据卷已经被外部应用创建过了，使用<code>docker-compose up</code>构建应用的时候将不会创建这个数据卷</p>
<h2 id="子命令"><a href="#子命令" class="headerlink" title="子命令"></a>子命令</h2><p>下面介绍一个常用的Compose子命令的用法，其中大部分命令的用法和docker的用法是一致的。</p>
<h3 id="up"><a href="#up" class="headerlink" title="up"></a>up</h3><p>构建（或者重新构建）<code>docker-compose.yml</code>中定义的相关服务。<br>用法：<code>up [options] [--scale SERVICE=NUM...] [SERVICE...]</code><br>常用启动命令：<code>docker-compose up -d</code> 让容器默认在后台运行</p>
<h3 id="build-1"><a href="#build-1" class="headerlink" title="build"></a>build</h3><p>单独构建一个services中的容器，常用在改变一个容器的Dockerfile或者build的内容的时候，使用这个命令重新构建<br>用法：<code>build [options] [--build-arg key=val...] [SERVICE...]</code></p>
<h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>查看Compose信息，可以指定services或者volumes</p>
<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p>单独创建services列表中的一个容器，常用用在需要事先进行配置的应用构造场景中</p>
<h3 id="down"><a href="#down" class="headerlink" title="down"></a>down</h3><p>停止并删除一个contains , networks 或者volumes</p>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>相当于<code>docker exec</code>，在指定的容器中运行命令<br>用法：<code>exec [options] SERVICE COMMAND [ARGS...]</code></p>
<h3 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h3><p>暂停正在运行的service，使用<code>docker-compose unpause</code>恢复</p>
<h3 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h3><p>展示service的输出日志</p>
<h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><p>拉取一个在<code>docker-compose.yml</code>中关联的镜像到本地，但是不运行</p>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>同<code>docker push</code>，只不过push的是一个servi的image</p>
<h3 id="restart-1"><a href="#restart-1" class="headerlink" title="restart"></a>restart</h3><p>重启所有停止的或者正在运行的service，如果你改变了你的<code>docker-compose.yml</code> 配置文件，使用这个命令之后配置将不会更新</p>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>删除已经停止的容器</p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[日月潭游记]]></title>
      <url>/2017/12/27/%E6%97%A5%E6%9C%88%E6%BD%AD%E6%B8%B8%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>湾湾交换期间最后一次南下浪。见识了有生以来见过的最美的曙光，骑了体验超赞的环湖自行车线路。日月潭，我还会再来的！</p>
<a id="more"></a>
<h2 id="乘船游湖"><a href="#乘船游湖" class="headerlink" title="乘船游湖"></a>乘船游湖</h2><p>来了日月潭想必都会坐这边的游艇在湖面上逛一逛。这里有很多家游船的公司，价格也不是很贵，每个人150TWD就能够拿下。乘船游湖主要就会游玩三个景点：水社码头、玄光寺、依达邵码头。那个玄光寺就是曾经供奉玄奘部分顶骨的地方。<br>湖面上的景色一般，主要还是游客比较多，湖面上的船非常多，显得很杂乱。坐船在这三个景点之间绕一圈应该两个小时能够搞定。会看到很多大陆来的旅行团。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_9_WechatIMG2.jpeg" alt="enter description here" title="打卡图片"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_9_WechatIMG1.jpeg" alt="enter description here" title="风景还不错"></p>
<h2 id="民宿"><a href="#民宿" class="headerlink" title="民宿"></a>民宿</h2><p>为了省钱，这次选的民宿离日月潭有点远，大概有20km距离的水里乡。第一天坐公交去坐了半个小时，接待我们的是一个和蔼的老爷爷，一整栋房子都只有这个老爷爷在照看（想想也觉得挺孤单的），而Airbnb上住宿信息的发布是他女儿弄的。水里乡这里应该真的是台湾这边乡下的代表了，街道上就火车站周围人比较多（火车站里面一天只通过五六趟火车），其他地方基本上很少有人。711便利店也只有一家，在火车站旁边。</p>
<p>因为我们来的这几天日月潭周围在举行祈安清醮祭典，除了711周围都吃不到荤的。晚上饿了出门逛了半天最后还是回到711吃泡面。</p>
<h2 id="日月潭日出"><a href="#日月潭日出" class="headerlink" title="日月潭日出"></a>日月潭日出</h2><p>为了看日出，早上4点半起床，老爷爷很辛苦那么早起来给我们做早餐，然后5点我们就出发去日月潭了。</p>
<p>到日月潭的时候天还没亮，天上的星星还是非常亮。因为没有一点云，所以看到整个星空还是很震撼的。看日出的点我们选在朝暮码头，到达那里的时候早就已经有人架好三脚架了。</p>
<p>随着天一点一点变亮，我敢说这是我有生以来见过的最好看的曙光了。太阳没出来，但是太阳带来的光从山的后面发出，然后被大山挡住展示出整个山的轮廓，加上湖面作用，呈现的就是一个非常美的水平对称的画面。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_9_WechatIMG3.jpeg" alt="enter description here" title="太阳还未出来1"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_9_WechatIMG4.jpeg" alt="enter description here" title="太阳还未出来2"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_9_WechatIMG5.jpeg" alt="enter description here" title="太阳还未出来"></p>
<p>然后还看到了出来冬泳的大爷大妈，还有带着狗和鸭子划赛艇的老人。生活在这里的人太幸福了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_9_WechatIMG6.jpeg" alt="enter description here" title="溜了溜了"></p>
<h2 id="环湖骑行"><a href="#环湖骑行" class="headerlink" title="环湖骑行"></a>环湖骑行</h2><p>等太阳出来以后船和人就逐渐多了起来，打破了一开始的平静。我们前往了水社码头，准备租个小自行车骑车环湖。</p>
<p>不得不说因为环境实在是太美了，在这里骑车真的是一种享受。一开始骑的是自行车专用道，相比旁边的公路更加接近湖面人比较少，有些时候能够看见一些观湖非常好的角度。后面一段因为没有自行车专用道转到公路上，能够加速奔驰也是挺爽的。</p>
<p>中间一段路要爬一座比较少的山，上坡会比较累，到达最顶端的有一个“玄奘寺”的地方能够买点东西补给一下，然后就是几公里的下坡了，下坡的速度基本上能够达到30码以上。</p>
<p>总体来说是我骑过体验最好的自行车线路，就是车子还不是很好，以后希望能够换一个更好的装备再来一次。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_9_WechatIMG7.jpeg" alt="enter description here" title="环湖骑行"></p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker容器操作]]></title>
      <url>/2017/12/22/Docker%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>前面两篇文章整理了Docker创建时候的一些配置，这篇文章整理了Docker容器操作的一些常用命令</p>
<a id="more"></a>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>Docker容器太轻量级了，使得我们可以随时创建和新建容器，启动容器可以分成两种：基于image新建一个容器并启动；启动在终止状态的容器</p>
<h3 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h3><p>命令格式：<code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p>
<p>常用选项：</p>
<ul>
<li><code>-it</code> -i 打开容器的标准输入  -t 分配一个pseudo-TTY</li>
<li><code>-e</code> 设置环境变量</li>
<li><code>-d</code> 守护态运行容器</li>
<li><code>-p</code> 指定开放端口</li>
<li><code>--name</code> 为容器命名</li>
</ul>
<p>如果使用了 -d 参数运行容器，容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 docker logs 查看)。</p>
<p>Docker在后台运行的标准操作包括:</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<h3 id="启动已经终止的容器"><a href="#启动已经终止的容器" class="headerlink" title="启动已经终止的容器"></a>启动已经终止的容器</h3><p>命令格式： <code>docker contain start</code></p>
<p>将一个已经终止运行的容器重新启动</p>
<p><code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>命令格式：<code>docker container stop</code></p>
<p>对于只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。</p>
<p>容器状态（包括正在运行的和终止的）可以用 <code>docker container ls -a</code> 命令看到。</p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>进入容器可以使用两个命令： <code>docker attach</code> 和 <code>docker exec</code></p>
<p>前者不需要加参数（自动分配伪终端），但是退出以后便终止容器；后者需要加<code>-it</code>选项以及指定shell类似<code>docker exec -it 69d1 bash</code></p>
<h2 id="导入导出容器"><a href="#导入导出容器" class="headerlink" title="导入导出容器"></a>导入导出容器</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p>导出容器到本地容器</p>
<p>命令格式： <code>docker export [OPTIONS] CONTAINER</code></p>
<p>实例：<code>docker export 7691a814370e &gt; ubuntu.tar</code></p>
<h3 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h3><p>可以使用<code>docker import</code>从快照文件中导入为镜像</p>
<blockquote>
<p>用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
</blockquote>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>删除一个处于终止状态的容器:<br><code>docker container rm</code><br>可以添加<code>-f</code>选项来发送SIGNKILL信号给容器关闭正在运行的容器</p>
<p>清理所有处于终止状态的容器<br><code>docker container prune</code></p>
<hr>
<p>参考：<br><a href="https://www.gitbook.com/book/yeasy/docker_practice/details?spm=5176.100239.blogcont40494.64.FKbhBf" target="_blank" rel="external">Docker — 从入门到实践</a></p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[阿里山游记]]></title>
      <url>/2017/12/17/%E9%98%BF%E9%87%8C%E5%B1%B1%E6%B8%B8%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>老一辈想到台湾马上就会想到阿里山，都说是这是宝岛台湾必去的景点。这周末就造访了阿里山森林公园，这应该也是台湾倒数第二次出游了吧。</p>
<a id="more"></a>
<h2 id="交通方式"><a href="#交通方式" class="headerlink" title="交通方式"></a>交通方式</h2><p>因为阿里山的住宿偏贵（大概三百RMB每人每晚），所以我们选择的交通方式是客运，这样一晚上加一天就可以玩完。第一天晚上从台北出发坐6个小时的客运到阿里山，然后第二天中午再做客运回台北。</p>
<p>从台北到阿里山的路总共应该有320km左右，前面一大段是高速，后面一小段（大约一个小时）时盘山公路，后面一段山路各种180度的湾，所以有晕车的要提前准备好措施。中间会休息两个地方，一个是嘉义转运站，另一个是天长地久桥景区。车子到达阿里山的时间大概是凌晨两三点左右，休息一会就可以准备上山看日出了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_20_1513699348982.jpg" alt="enter description here" title="路程"></p>
<p>总体来说客运的这种交通方式比较经济而且节省时间，缺点就是会有点辛苦，毕竟凌晨三点多到阿里山的半山腰而且还要坐6个小时的车。</p>
<h2 id="祝山日出"><a href="#祝山日出" class="headerlink" title="祝山日出"></a>祝山日出</h2><p>看日出有两种方式，一种是搭阿里山游乐区里面的红色小火车去祝山观日平台看日出，另外一种是在阿里山游乐区门口有私人的接你上山看日出的巴士，去的是一个更高的平台。我们选择的是第一种，这个要在四点多的时候就到阿里山火车站买票，人很多但是只要不是去太晚应该都能够买到票。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_20_WechatIMG1.jpeg" alt="enter description here" title="阿里山小火车"></p>
<p>坐小火车到达山顶以后，就能够见到一个非常大的观日平台。日出差不多是7点，我们6点到达的山顶，见证了天空由黑变蓝再变红的过程。日出很快，马上太阳就全部出来了，想拍一个延时摄影但是苦于没有架三脚架的地方。</p>
<p>山上确实很冷，比山下温度应该是低个十度左右，冷风吹来冻得人直打哆嗦。不过不一会太阳出来以后感觉就暖起来了，可能是在台北没见过什么太阳，见到太阳就兴奋吧。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_20_WechatIMG2.jpeg" alt="enter description here" title="阿里山日出"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_20_WechatIMG3.jpeg" alt="enter description here" title="山上的云"></p>
<h2 id="漫步森林"><a href="#漫步森林" class="headerlink" title="漫步森林"></a>漫步森林</h2><p>看完日出以后，坐火车到沼平车站，开始漫步森林。看到太阳打在对面的山上，那景色就像电脑壁纸里面的一样。</p>
<p>阿里山游乐园里面真的是很有意境，树都是笔直的而且非常高，几乎看不到人工作用的痕迹，走在里面就像进到原始森林里面一样，非常赞。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_20_WechatIMG4.jpeg" alt="enter description here" title="漫步森林中"></p>
<p>准备回去的时候，拍了一个对面山的延时摄影。可以看到山间的“仙气”慢慢升上去，升到空中变成一朵云，非常赞。</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/8eSMokATgSA" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe>


]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[台湾大学联盟自习环境排行榜]]></title>
      <url>/2017/12/13/%E5%8F%B0%E6%B9%BE%E5%A4%A7%E5%AD%A6%E8%81%94%E7%9B%9F%E8%87%AA%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%8E%92%E8%A1%8C%E6%A6%9C/</url>
      <content type="html"><![CDATA[<p>台湾大学联盟指台湾大学、台湾科技大学、台湾师范大学组成的大学系统，允许各校学生跨校选课，共用图书馆等资源。作为一个经常去台大、台师大蹭课自习的台科大学生，今天就来总结一下我心目中台湾大学联盟的自习环境排行榜。</p>
<a id="more"></a>
<h2 id="No-4-台科大图书馆"><a href="#No-4-台科大图书馆" class="headerlink" title="No.4 台科大图书馆"></a>No.4 台科大图书馆</h2><blockquote>
<p>环境：三星<br>便利性：四星</p>
</blockquote>
<p>台科大图书馆应该是我自习来过最多的地方了，来自习的主要也是台科大的学生。自习的桌子不是很大，阅览区的自习位没有插座，图书馆里面的自习位一般是两个自习位共用一个插座。<br>一楼有一个休闲的杂志阅览区，旁边有一台自动咖啡机，学累了可以来这里坐一会喝杯咖啡提提神，超赞。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20180111_092603.jpg" alt="enter description here" title="图书馆大门"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20180111_092857.jpg" alt="enter description here" title="书架"></p>
<p>  <img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171225_224156.jpg" alt="enter description here" title="阅览区自习位"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20180111_092637.jpg" alt="enter description here" title="休闲杂志区"></p>
<h2 id="No-3-台师大图书馆"><a href="#No-3-台师大图书馆" class="headerlink" title="No.3 台师大图书馆"></a>No.3 台师大图书馆</h2><blockquote>
<p>环境：四星<br>便利性：三星</p>
</blockquote>
<p>师大图书馆在师大的图书馆校区，距离台科大比较远，所以去得也不多，一般是在游泳课前有时间的时候就去那里自习一会儿。师大图书馆还是很有特色的，建筑整体是一个半圆形的，在图书馆里面看会感觉非常特别。<br>自习区域也很赞，有讨论区开放给团队讨论，就是校园网有的时候使用不了漫游账号。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171229_095420.jpg" alt="enter description here" title="师大图书馆大门"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171229_095635.jpg" alt="enter description here" title="自习区"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171229_095753.jpg" alt="enter description here" title="半圆形建筑"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171229_095822.jpg" alt="enter description here" title="讨论区"></p>
<h2 id="No-2-台大图书馆总馆"><a href="#No-2-台大图书馆总馆" class="headerlink" title="No.2 台大图书馆总馆"></a>No.2 台大图书馆总馆</h2><blockquote>
<p>环境：五星<br>便利性：三星</p>
</blockquote>
<p>台大图书馆总馆应该是我在台湾交换去的第二多的图书馆了，周四下午又台大的课，上午一般就在台大图书馆待着，周末如果学习的话也会选择这里。在这里正很有学习的氛围。加上也是台大的标志性建筑，也是台大的几何中心，算得上是台大的一个标志了。</p>
<p>因为图书馆里面大部分区域是地毯，所以里面非常安静，每层楼的中间和最边上是自习区域，另外的地方是藏书的书架。不过有一点便利性的不足就是没有插座，有的时候电脑没电了就很头疼。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171205_133521.jpg" alt="enter description here" title="台大地标——图书总馆"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171205_133217.jpg" alt="enter description here" title="自习位"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171205_133149.jpg" alt="enter description here" title="自习区域"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171019_180724.jpg" alt="enter description here" title="多媒体借阅区"></p>
<h2 id="No-1-台大社科院图书馆"><a href="#No-1-台大社科院图书馆" class="headerlink" title="No.1 台大社科院图书馆"></a>No.1 台大社科院图书馆</h2><blockquote>
<p>环境：五星<br>便利性：五星</p>
</blockquote>
<p>台大社科院图书馆是有个非常有名的建筑作品，由伊东丰雄设计。相关的介绍可以看<a href="http://www.archcollege.com/archcollege/2016/04/25481.html" target="_blank" rel="external">这里</a>。很喜欢对这个图书馆的一个评价：</p>
<blockquote>
<p>树干般的柱子，是借由具备自我衍生规则的设计算法配置而成。看起来如植物般的双重螺旋，在保持彼此距离的同时也长出复数的节点，而两个螺旋的交汇之处变成了柱子的基点。然后再将基点间做柏洛诺伊分割，进一步决定出个别的屋顶板材的形状。柱子的形状则随着跨距的不同，以大、中、小三个模式加以重复排列</p>
</blockquote>
<p>社科院里面的环境可以说是超级棒，每一个自习位上面也有台灯和插座，真的是进去能够待上一整天。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171205_091823.jpg" alt="enter description here" title="社科院图书馆门口"></p>
<p>  <img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171205_091910.jpg" alt="enter description here" title="辜振甫先生像"></p>
<p>  <img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171205_092008.jpg" alt="enter description here" title="自习环境1"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171205_092129.jpg" alt="enter description here" title="自习环境2"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171205_092201.jpg" alt="enter description here" title="自习位"></p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 排行榜 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Dockerfile定制Docker镜像]]></title>
      <url>/2017/12/10/%E4%BD%BF%E7%94%A8Dockerfile%E5%AE%9A%E5%88%B6Docker%E9%95%9C%E5%83%8F/</url>
      <content type="html"><![CDATA[<p>本文讲解了使用Dockerfile 构建Docker镜像的一些常用指令和注意事项</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么很多无法重复的问题、镜像构建透明性的问题、体积的问题就能够轻松得到解决。</p>
<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>构建镜像命令的格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</div></pre></td></tr></table></figure></p>
<h3 id="上下文概念"><a href="#上下文概念" class="headerlink" title="上下文概念"></a>上下文概念</h3><p>Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p>
<p>当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<h3 id="规范做法"><a href="#规范做法" class="headerlink" title="规范做法"></a>规范做法</h3><p>一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p>
<p>在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。</p>
<p>这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。</p>
<p>当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>Dockerfile 中每一个指令都会建立一层，因此尽量将指令融合在一起（特别注意的是RUN指令）</p>
<h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h3><p>以一个镜像为基础，在其之上进行定制。</p>
<p>语法格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FROM &lt;image&gt;:&lt;tag&gt; 或者</div><div class="line">FROM &lt;image&gt;@&lt;digest&gt;</div></pre></td></tr></table></figure></p>
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><p>用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<ul>
<li><code>shell</code>格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。</li>
<li><code>exec</code>格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li>
</ul>
<h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><p>CMD 指令就是用于指定默认的容器主进程的启动命令的。也是两种格式：</p>
<ul>
<li>shell 格式：CMD &lt;命令&gt;</li>
<li>exec 格式：CMD [“可执行文件”, “参数1”, “参数2”…]</li>
<li>参数列表格式：CMD [“参数1”, “参数2”…]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。</li>
</ul>
<p>在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 “，而不要使用单引号。如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。</p>
<p>提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。<br>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。所以<code>systemctl</code>和<code>service</code> 这些命令就不起作用了。<br>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p>ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。</p>
<p>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 –entrypoint 来指定。</p>
<p>当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令</p>
<h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>两种格式：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>对于如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的，比如说<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ENV VERSION=1.0 DEBUG=on \</div><div class="line">    NAME=&quot;Happy Feet&quot;</div></pre></td></tr></table></figure></p>
<h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><p>格式： <code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>
<p>构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。</p>
<h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>格式：</p>
<ul>
<li><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>
</ul>
<p>&lt;源路径&gt; 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match" target="_blank" rel="external">filepath.Match</a> 规则</p>
<p>&lt;目标路径&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p>
<h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。给出的源路径可以是一个URL地址Docker 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去。</p>
<p>另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>
<p>因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。</p>
<h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>两种格式：</p>
<ul>
<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
<h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h3><p>格式：<code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p>
<p>声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</p>
<h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式： <code>WORKDIR &lt;工作目录路径&gt;</code></p>
<p>使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</p>
<h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h3><p>格式： <code>USER &lt;用户名&gt;</code></p>
<p>USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。</p>
<p>当然，和 WORKDIR 一样，USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<h3 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h3><p>两种格式：</p>
<ul>
<li>HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</li>
<li>HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li>
</ul>
<p>HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。</p>
<p>具体使用可参考<a href="https://docs.docker.com/engine/reference/builder/#healthcheck" target="_blank" rel="external">这里</a></p>
<h3 id="ONBUILD-定义触发器"><a href="#ONBUILD-定义触发器" class="headerlink" title="ONBUILD 定义触发器"></a>ONBUILD 定义触发器</h3><p>格式：<code>ONBUILD &lt;其它指令&gt;</code></p>
<p>ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
<h3 id="MAINTAINER-提供信息"><a href="#MAINTAINER-提供信息" class="headerlink" title="MAINTAINER 提供信息"></a>MAINTAINER 提供信息</h3><p>格式：<code>MAINTAINER &lt;author&#39;s detail&gt;</code></p>
<p>用于提供信息的指令，用于让作者提供本人的信息；不限制其出现的位置，但建议跟在FROM之后。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">FROM ubuntu</div><div class="line">MAINTAINER Kimbro Staken</div><div class="line"></div><div class="line">RUN apt-get install -y software-properties-common python</div><div class="line">RUN add-apt-repository ppa:chris-lea/node.js</div><div class="line">RUN echo &quot;deb http://us.archive.ubuntu.com/ubuntu/ precise universe&quot; &gt;&gt; /etc/apt/sources.list</div><div class="line">RUN apt-get update</div><div class="line">RUN apt-get install -y nodejs</div><div class="line">#RUN apt-get install -y nodejs=0.6.12~dfsg1-1ubuntu1</div><div class="line">RUN mkdir /var/www</div><div class="line"></div><div class="line">ADD app.js /var/www/app.js</div><div class="line"></div><div class="line">CMD [&quot;/usr/bin/node&quot;, &quot;/var/www/app.js&quot;]</div></pre></td></tr></table></figure>
<h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><h3 id="从rootfs文件导入镜像"><a href="#从rootfs文件导入镜像" class="headerlink" title="从rootfs文件导入镜像"></a>从rootfs文件导入镜像</h3><p>格式：<code>docker import [选项] &lt;文件&gt;|&lt;URL&gt;|- [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></p>
<p>压缩包可以是本地文件、远程 Web 文件，甚至是从标准输入中得到。压缩包将会在镜像 / 目录展开，并直接作为镜像第一层提交。</p>
<h3 id="保存和加载镜像"><a href="#保存和加载镜像" class="headerlink" title="保存和加载镜像"></a>保存和加载镜像</h3><p>Docker 还提供了 docker load 和 docker save 命令，用以将镜像保存为一个 tar 文件，然后传输到另一个位置上，再加载进来。这是在没有 Docker Registry 时的做法，现在已经不推荐，镜像迁移应该直接使用 Docker Registry，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以。</p>
<p>如果我们结合这两个命令以及 ssh 甚至 pv 的话，利用 Linux 强大的管道，我们可以写一个命令完成从一个机器将镜像迁移到另一个机器，并且带进度条的功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker save &lt;镜像名&gt; | bzip2 | pv | ssh &lt;用户名&gt;@&lt;主机名&gt; &apos;cat | docker load&apos;</div></pre></td></tr></table></figure></p>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>格式：<code>$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</code></p>
<p>Untagged</p>
<p>有些时候我们删除一个镜像的时候，可能会出现Untagged。这是因为镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变动非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 docker pull 看到的层数不一样的源。</p>
<p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p>
<p>参考：<br><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="external">https://docs.docker.com/engine/reference/builder/</a><br><a href="https://www.gitbook.com/book/yeasy/docker_practice/details?spm=5176.100239.blogcont40494.64.FKbhBf" target="_blank" rel="external">电子书</a></p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识Docker]]></title>
      <url>/2017/12/10/%E5%88%9D%E8%AF%86Docker/</url>
      <content type="html"><![CDATA[<p>本文是我初步了解Docker技术的笔记<br><img src="https://data2.liuin.cn/story-writer/2017_12_10_2333.png" alt=""></p>
<a id="more"></a>
<h2 id="什么是Docker？"><a href="#什么是Docker？" class="headerlink" title="什么是Docker？"></a>什么是Docker？</h2><p>Docker 是能够对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_10_1512908235159.jpg" alt="enter description here" title="传统虚拟机"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_10_1512908269821.jpg" alt="enter description here" title="Docker"></p>
<p>相比传统的虚拟化技术Docker有许多的优点：更高效的利用系统资源；更快速的启动时间；一致的运行环境；持续交付和部署；更轻松的迁移；更轻松的维护和扩展</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="镜像-Image"><a href="#镜像-Image" class="headerlink" title="镜像(Image)"></a>镜像(Image)</h3><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</p>
<p>镜像是分层存储的，构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。这样使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<h3 id="容器-Container"><a href="#容器-Container" class="headerlink" title="容器(Container)"></a>容器(Container)</h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p>
<p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。</p>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<h3 id="仓库-Repository"><a href="#仓库-Repository" class="headerlink" title="仓库(Repository)"></a>仓库(Repository)</h3><p>和GitHub中的仓库类似，Docker中的仓库也是展现不同版本的镜像的地方。一个仓库包含一个软件（或者开发环境）的不同版本的镜像，标签就是对应着这些镜像的版本号。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。</p>
<p>与Github这种代码托管平台一样，仓库我们可以放在公共的Docker Registry中（最常用的是 Docker Hub，国内有许多高质量的镜像服务），也可以放在私有的Docker Registry中。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官方安装指南在<a href="https://docs.docker.com/engine/installation/#prior-releases" target="_blank" rel="external">这里</a></p>
<h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><h4 id="加载可选模块"><a href="#加载可选模块" class="headerlink" title="加载可选模块"></a>加载可选模块</h4><p>从 Ubuntu 14.04 开始，一部分内核模块移到了可选内核模块包。AUFS 内核驱动属于可选内核模块的一部分，作为推荐的 Docker 存储层驱动，一般建议安装可选内核模块包以使用 AUFS。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line"></div><div class="line">sudo apt-get install \</div><div class="line">    linux-image-extra-$(uname -r) \</div><div class="line">    linux-image-extra-virtual</div></pre></td></tr></table></figure>
<h4 id="向APT中添加源"><a href="#向APT中添加源" class="headerlink" title="向APT中添加源"></a>向APT中添加源</h4><p>添加使用 HTTPS 传输的软件包以及 CA 证书:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install \</div><div class="line">    apt-transport-https \</div><div class="line">    ca-certificates \</div><div class="line">    curl \</div><div class="line">    software-properties-common</div></pre></td></tr></table></figure></p>
<p>添加软件源的 GPG 密钥（因为国内的网络问题，可以使用国内的源）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</div><div class="line"></div><div class="line"># 官方源</div><div class="line"># curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</div></pre></td></tr></table></figure></p>
<p>向<code>source.list</code>中加入Docker软件源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ sudo add-apt-repository \</div><div class="line">    &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \</div><div class="line">    $(lsb_release -cs) \</div><div class="line">    stable&quot;</div><div class="line"></div><div class="line"></div><div class="line"># 官方源</div><div class="line"># $ sudo add-apt-repository \</div><div class="line">#    &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</div><div class="line">#    $(lsb_release -cs) \</div><div class="line">#    stable&quot;</div></pre></td></tr></table></figure>
<h4 id="安装Docker-CE"><a href="#安装Docker-CE" class="headerlink" title="安装Docker CE"></a>安装Docker CE</h4><p>更新apt，并安装`Docker CE’:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get update</div><div class="line"></div><div class="line">$ sudo apt-get install docker-ce</div></pre></td></tr></table></figure>
<h3 id="使用脚本自动安装"><a href="#使用脚本自动安装" class="headerlink" title="使用脚本自动安装"></a>使用脚本自动安装</h3><p>官方版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -sSL https://get.docker.com/ | sh</div></pre></td></tr></table></figure></p>
<p>阿里云安装脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</div></pre></td></tr></table></figure></p>
<p>DaoCloud安装脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -sSL https://get.daocloud.io/docker | sh</div></pre></td></tr></table></figure></p>
<h3 id="镜像加速器"><a href="#镜像加速器" class="headerlink" title="镜像加速器"></a>镜像加速器</h3><p><a href="https://cloud.tencent.com/document/product/457/9113?!preview=true&amp;lang=zh" target="_blank" rel="external">腾讯云</a>官方给出的配置方法：<br>修改 Docker 配置文件 <code>/etc/default/docker</code>，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DOCKER_OPTS=&quot;--registry-mirror=https://mirror.ccs.tencentyun.com&quot;</div></pre></td></tr></table></figure></p>
<p>更高效的配置：</p>
<p>通过修改daemon配置文件<code>/etc/docker/daemon.json</code>来使用加速器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sudo mkdir -p /etc/docker</div><div class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;</div><div class="line">&#123;</div><div class="line">  &quot;registry-mirrors&quot;: [&quot;https://mirror.ccs.tencentyun.com&quot;]</div><div class="line">&#125;</div><div class="line">EOF</div><div class="line">sudo systemctl daemon-reload</div><div class="line">sudo systemctl restart docker</div></pre></td></tr></table></figure></p>
<p>用<code>docker info</code>测试是否配置好，查看是否有以下的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Registry Mirrors:</div><div class="line"> https://mirror.ccs.tencentyun.com</div></pre></td></tr></table></figure></p>
<h3 id="Docker-compose-安装"><a href="#Docker-compose-安装" class="headerlink" title="Docker-compose 安装"></a>Docker-compose 安装</h3><p>可以参考<a href="https://docs.docker.com/compose/install/" target="_blank" rel="external">官方文档</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo curl -L https://github.com/docker/compose/releases/download/1.18.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</div><div class="line">sudo chmod +x /usr/local/bin/docker-compose</div></pre></td></tr></table></figure>
<p>但是我在操作上面的命令的时候会出现下载不了的错误，所以我就从<a href="https://github.com/docker/compose/releases" target="_blank" rel="external">官方的Github</a>下载了最新的realease，然后复制到<code>/usr/local/bin/</code>中</p>
<h3 id="创建docker用户组"><a href="#创建docker用户组" class="headerlink" title="创建docker用户组"></a>创建docker用户组</h3><p>Docker守候进程绑定的是一个unix socket，而不是TCP端口。这个套接字默认的属主是root，其他是用户可以使用sudo命令来访问这个套接字文件。因为这个原因，docker服务进程都是以root帐号的身份运行的。</p>
<p>为了避免每次运行docker命令的时候都需要输入sudo，可以创建一个docker用户组，并把相应的用户添加到这个分组里面。当docker进程启动的时候，会设置该套接字可以被docker这个分组的用户读写。这样只要是在docker这个组里面的用户就可以直接执行docker命令了。</p>
<p>警告：该dockergroup等同于root帐号，具体的详情可以参考这篇文章：<a href="https://docs.docker.com/engine/security/" target="_blank" rel="external">Docker Daemon Attack Surface</a></p>
<p><code>sudo usermod -aG docker your_username</code></p>
<h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>获取镜像的格式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</div></pre></td></tr></table></figure></p>
<p>具体的帮助文档可以通过<code>docker pull --help</code>查看<br>参数解释：</p>
<ul>
<li>Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。</li>
<li>仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。</li>
</ul>
<p>运行测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run -it --rm ubuntu:16.04 bash</div></pre></td></tr></table></figure></p>
<p>参数解释：</p>
<ul>
<li>-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li>–rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。</li>
<li>ubuntu:16.04：这是指用 ubuntu:16.04 镜像为基础来启动容器。</li>
<li>bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。</li>
</ul>
<h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><p>一般使用的使用的是<code>docker image ls</code>或者<code>docker images</code> 指令<br>可以使用相应的<code>--help</code>查看帮助</p>
<h3 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h3><p>当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 docker commit 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p>
<p><code>docker commit</code>语法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</div><div class="line"></div><div class="line"># 例子</div><div class="line">$ docker commit \</div><div class="line">    --author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; \</div><div class="line">    --message &quot;修改了默认网页&quot; \</div><div class="line">    webserver \</div><div class="line">    nginx:v2</div></pre></td></tr></table></figure></p>
<p>可以搭配<code>docker diff</code>查看容器当前的修改和<code>docker history</code>查看镜像的相关历史记录</p>
<p>注意：慎用<code>docker commit</code>操作：</p>
<blockquote>
<p>使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 docker diff 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。</p>
</blockquote>
<h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><p>当你需要把本地制作的镜像推送到远端仓库中，你就可以使用<code>docker push</code>命令，这个命令默认推送到的是Docker的官方镜像仓库：Docker Hub。</p>
<p>在推送之前，你需要在Docker Hub中创建好相应的image并登录：<code>docker login [OPTIONS] [SERVER]</code></p>
<p>然后使用<code>push</code>命令推送：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker push [OPTIONS] NAME[:TAG]</div></pre></td></tr></table></figure></p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ docker commit c16378f943fe rhel-httpd</div><div class="line"></div><div class="line">$ docker tag rhel-httpd registry-host:5000/myadmin/rhel-httpd</div><div class="line"></div><div class="line">$ docker push registry-host:5000/myadmin/rhel-httpd</div></pre></td></tr></table></figure></p>
<p>参考：<br><a href="http://aleonchen.com/2017/02/07/qcloud-docker/" target="_blank" rel="external">博客1</a></p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[湾湾极东之行]]></title>
      <url>/2017/12/09/%E6%B9%BE%E6%B9%BE%E6%9E%81%E4%B8%9C%E4%B9%8B%E8%A1%8C/</url>
      <content type="html"><![CDATA[<p>这个周末台科大台陆会说了一个月的活动终于举办了，福隆骑行，打卡台湾极东点，过一把骑行的瘾。</p>
<a id="more"></a>
<h2 id="线路"><a href="#线路" class="headerlink" title="线路"></a>线路</h2><p>台北出发，坐一个半小时的区间车到福隆车站，买便当、借车，沿着小路骑到旧草岭隧道，然后骑过旧草岭隧道。过了旧草岭隧道就能远眺龟山岛了，然后沿着环岛一号线骑行到台湾极东点——三貂角灯塔，最后再沿着环岛一号线骑行回到福隆车站，还车坐区间车回台北。</p>
<p>区间车来回150TWD，福隆便当60TWD，借车100TWD，共计花费才310TWD。超赞的物美价廉的周末出游路线！</p>
<h2 id="旧草岭隧道"><a href="#旧草岭隧道" class="headerlink" title="旧草岭隧道"></a>旧草岭隧道</h2><p>旧草岭隧道在日治大正10~13年建造（西元1921~1924年），工程费时三年，是当时台湾最长的隧道。隧道的工程质量不得不说还是蛮好的，差不多有百年历史，隧道里面还是没有漏水什么的。因为是单线铁路，后面在旁边建了一个新的双线铁路这条隧道就废弃了，改成一个供观光客骑行的景点。<br>一排路灯照着不是很黑，地下铺了铁轨形状的瓷砖。路上碰到大妈团让我们带路😂</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_9_IMG_20171209_171226.jpg" alt=" " title="旧草岭隧道 入口"></p>
<h2 id="三貂角灯塔"><a href="#三貂角灯塔" class="headerlink" title="三貂角灯塔"></a>三貂角灯塔</h2><p>三貂角灯塔就是台湾的极东点了，经度东经120度，刚好是太平洋和东海分界的地方。公元1929年及1931年，日本船舶抚顺丸及华南丸，先后于三貂角附近海域遭遇海难沉没，台湾总督府因此于此地筹建此灯塔。</p>
<p>向东眺望就是广袤的太平洋了，美不胜收！</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_9_IMG_20171209_203930.jpg" alt=" " title="三貂角灯塔"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_9_IMG_20171209_204012.jpg" alt=" " title="台湾极东点观景台"></p>
<h2 id="骑行感受"><a href="#骑行感受" class="headerlink" title="骑行感受"></a>骑行感受</h2><p>今天一共骑行应该是20公里左右，因为团队里面有小伙伴体能不是很好，所以骑行的速度不是很快，平均速度大概在10km/h。这条线路的总体感受应该是非常好的，依山傍水，左边高山，右边太平洋。</p>
<p>环岛一号线上大部分道路都是有自行车专用道，不用太担心安全的问题。周末没事花个一天半天的时间来玩玩挺好的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_9_Screenshot_2017-12-09-16-57-48-223_com.xiaomi.hm.health.png" alt=" " title="骑行轨迹"></p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从台大Compiler的学习中看自己在台湾学习的局限性]]></title>
      <url>/2017/12/09/%E4%BB%8E%E5%8F%B0%E5%A4%A7Compiler%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9C%8B%E8%87%AA%E5%B7%B1%E5%9C%A8%E5%8F%B0%E6%B9%BE%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7/</url>
      <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>
function doDecrypt(pwd, onError) {
	console.log("in doDecrypt");
	var txt = document.getElementById("enc_content").innerHTML;
	var plantext;
	try {
	  	var bytes = CryptoJS.AES.decrypt(txt, pwd);
		plaintext = bytes.toString(CryptoJS.enc.Utf8);
	} catch(err) {
		if(onError) {onError(err);}
		return;
	}
	document.getElementById("enc_content").innerHTML = plaintext;
	document.getElementById("enc_content").style.display = "block";
   document.getElementById("enc_passwd").style.display = "none";
}
</script>
<div id="enc_content" style="display:none">U2FsdGVkX19pkLX0xJhrd6NjGFzF7T/qI/XRC3CrcvLQ3rFwuSFBgCydgqjI1k589GU0r8sLADLWAJ8nAsqT0ATrk5lxrHDZ48d23hN2F+C8P8P6F2nw0NxTsxR1MGkUnylfMkXRHmpxonXud6IhWICBjj5eqasAoQpyOeXw8gYoM8rc/LbON7LTzSo+bPXG98FnenbRf2lfOXU6klsgLMmQ9UOgDzE6Fw8rTJmzCKpM0f5D4ydfpTJIT+staRA0gMr+ht1+4G1z75O8H/63nOhoC4A6Jz3SGoDGVAT88D48TB+xhyyNY9g9WqhAXjvXSxtIqk6P+zynwslk7rfcGiTARKNjQ19N4PSOAR0OzksYHDz4VrQwYGhw9HeRfVLmg1TWDFhNgVfN1thgQ+E6Oqr3Q48AyIxZxVLJeSglqZ6+HoLL+L8UeNg9XzGB+9yqKdAgX/RYNzrygr0c2Pfd1aHop6reJKgItnUJunO3UxSaMLEnKMDssv8bDVz9R3NhbPC+6P7cHsIWxtw9+ec12WYofl6Cfe9OtBq3nlITwzuaZHVP0yaLjkUpcDqAKin7Gi9dtGqZfbOzJNIgfII/MMspY2sy4q0sPV2AqwxvtO4fjoUapERccDPV+ISlBvgqhf4uwNw56tPpSrhps4l2DqMD02iuSXNlplz79GWE6UlUT2ckZDsy/ZtYNkjaqKsmJStorfEFgyqj9SXinW1DD14PsyDKaw+rpddcMvLZ5ePwlAmUgDhQCFIq5hxL7AX7h4P9uQyR6O+x47KpTU48t2nyySxuvHBkubzCIZzlbpRXwCq1KqzEzH+Kr2KxIiR5KcXpolOUjkz2OcLNR+UqTBNg73A1sPrlldcX2BHkJmVLGEa8WjRRM1cIcY9vOc4QUnj09VEyC8QRmEctaQW9VfSPTAhnBe0gRg4642/ynDOgkt/A96zrVZN6LGg6gmMV3VkE9tJh7/By8ZeP2wWFU1OqsfZDVKO9tdn9M4X8V9XXei05kcjW2hQkw/bAevwcc9wCv6aOQ4ImN0F3PzIeu83m57prMaZY5hm6W4ghSYHBPjm69e2Hn5ZYYvyWX2fJnpnefdp0Lr5yn8nQjHNolVF8gZrbKOXbq4M675ZFBx3NlmqeVYOjnO2ppUDj1MbbVwXUlvSgGFOORAJ5qgE8Bp9ii3dnBXN5VBKpwei/CkntMBoOCvKnTTKSw9SHibD7D7fdMT3vd3WxJbsoRoQ4Oy8vVqexcHhjRUDWTFhn0+HydUXnK972cxRVIi/URwuK5mnIwif1APRWwWyy+W82JChQy6NlaQpvwLc7F7YISP31kNKX3Rw26sKQ82yT0KHzt6Arpj/cAHf624QEB3f7GW84HCL1O9FxwuyRlJYBBtrZqgtATYaJMufm6zRvoxloTtczELYvzASYcqGog+SMZsheVUqOlblignJijm/sPStUWhIefcTLTH41Ci+nJZ7lLr1yKzikfTyqiWBIPO+PmkwwyNEn/b0xkhylP2GBgY3q8pbj9TD/3DoMd7mHOsyNT/4spvr1QbLoohkw99Ha3kDFdEo0M9SgwTZzdPZ2zwo+l+k+oF6GJWNAaBZLSlhekVFSKHxpO6vYv3/KXvlu+lnflIEz8bqGEtnrTJc3tI8kF+a08eSiAJkY1+nhGjW6i1fq0n6Q1elrC/HwzCXS4Sg9Qra6b/7u+H4sCbf3ONJ4nf2cDeWki4Dth/kjL2S+INQz0kRK3RgB7lF8+MOREsoKzWxvHlrcIwecI0ITJWITRvn4nKSE2JaaN5qj824vqGyrl/2yOLi/f/BIHeSqStHJJUd77dUpNFyP1KMfmPcB/IU0xATiCHYoP177A+SPaO0dGGrXw9wEeaeCN70TPA96Bc2vUb8PNlpH37ASK7Oxea7Sevdq7W/FMiIawS0vubqYHkOXWDP0ff5AuhojFYEdFkHgS8OrxSu1DFqC1zNpc3NB51Oz+IT9q4Ho/yPV7M+kaOuYpWhQs2v3uNSJ5smJGvmzLhkOzvSuBVjwXHz+fdvJi10qWdo16IpmPKAdUaiqucxoV0qlzWJs66zBh4w5fGMRo/Dw+XcEFe+oGFXu3jDZVn/XTuZ15os981zNdGSMZeoXjetG57oYqrTkJtcMcu8IVdy3Xc8JNk+2SYEWNCWRa7NQlCklUfggGwTKkXbL5uE+XBs5JLr0XJCryyRuoynww7COhUkn32yfRJlzQ0C90upbU31rkf8+0BMN9awM8Ce5F5PKrGwE0XoeGZHLdSzVErLMUthDlpfTIa2vh+WTp46AlhVx9VSzBXKv+bX1BYF+/65G3G6WEsbODcEyvJCxazKh1L7N82CoFLwGsRPO9gkixfWx2MSQt+wmP8xr9a1S9tN87Ze1eb6yvBLfSCqmnX6PdpPhHAmyiVqaZsJf562IiiM1f+7p2SNp8MACaya0Pa3NWpPA+SaBc0nKfJXJWMm5yceGkeydNekliAcrNn3QGuOzyjxpWORKash6qTiJ2wPz4bchMtuNBZuASqwRFJi095ytFA5PY7VEfiHJ4T7oPzL0k/66e6yoTr6gTHOeJnIjPMTR2MuoY7Y0zdf4GGKeYYJGP3ms30wVnwlABu6KSD7MA9UUNP16TGSq9Q34nyd20tauKyyxsUvSY1K1fbVc6i2mK2QsKfWkvnIkQ1zsB4ct4WABNs8y57gQqRBY4/UJ1zxJaGSbW7bcXZzw7DUvAG4tIVOYTQFfLM01I/l2qs2ZDPsuC6g0A91O5frJnYPh6j33k0a7HAYwCfR9QjwcU9HmsSYYb/7OXXozNWSn0kz0F6TT/ZZRksDSxC844QsnRrN80XYAu1rZy4RWYZLaLKTqXQViiPCtH3nMgqhQFLqYn96lC7SPuFTzSw5SLr5Y5pZnU+YIctUpAKo2foVkepIS3VQSSxPiRCjRwmDDD/kB5cMsi3YQBXtw5gF3oRpaF5vlemDiyaWwLZ8+32qpSQuwjhf+EAee1DozGPg/mbl4kfL/XfA+iybmavg24mPy08q5ei6GNgdpibLpYO0NBnxjg7fUscG3/K5OGYUxuvBOZO6ksHudFJsj/fdOZMXEK2XZ4AR76WjpXQE46rm1kPoxuzRvNwxONxgjCxRfGVxBJ22Da3T5r6b0sA4H5L/j8+wJLrzIQhhUyla6TUDy9HN6QPWJcbB1+COjXALDg0Fq3RVJw4yK3Ky+VYReZH2TWbthPo6wRm3vUMgnyl6yzyQLq1iFccKrFRtZeGpDeqi+QQ/TuiAVtKah0a36OGqmapEEwwy199BHRa2oz0dkqKrPtjwtKj1i902NqBNk3uYDO4D1P9jslZwyGh2Kf1DmR9ET/syULCgQ7Ilc1vqTUbJai1KJmrK2BMJzJFRO2sM8qpnGVlcPl4xtJaTLkq1Y0FHpI/HNpTjhaCuroSvxIfjHZF4Gqt7nQqo178mzKNH6ICuN1ccW7G0pn5EYkNruQ7dOwdX9Ytx3PIdavRRwlBiREy+gssQicO0jCRZi7N/mZHUiRUndC0qUzEfSykpwrycBNfUe8mLvT7IEohQ4yQXcwclo9sQ7srZ6yYi605IM/ee99OZ3XxipzmWWrzXHFyWqXCNP3vPD+ZYuC/+0E+6csWMAdUYhbJjeGt3K/IUb9l62n18fux473Xd1wwpY0kRUa2Xr1Y7ehYXddVT8jfeIB5TtkAcV1TzWqngfvjgAxvzCnssFpYnm4TjzKsQn0pStNVRsDU5boOHgXimfRIaFZmP8KJkDWMBb3dMVWtDik6gp+lNjqm52HJCgy0uSzkU85+G04zL8FdpW/Sgy+5GYD7u9NSCInmSygURG5ginWvos7G4fknAacsM6NEJ4KQ/xItpe6S7sPi8Kitheh8SPraFT39GuyJKLjtQ/KBEehRu8Y8aLyA9zt6+1a/+xq44Bzcd4xQWyl1d2Hbv5yb+TnlvfWLXDDHlMRpTXOd/t3kdPjrsDLG8sJDo8nlPUzN6kLyev7ly6exUOOO9BIUNDC6BBk4JqEgu5KB+/N1JfKu3z69ZoFuYm5tv64G/OcU3sMMPNAl1eoZuGN2SKb5cbwnvWyv7PEIURmqi5mCzlIl66c8fNsQPcwC6nDNKi4MmXYkwscR9eLLMJqn+V2b6Gs7U/91fQv9AREGBFsJPSNojv9X6xhH41a8GgsGHpuEVETE4kz5mB54+ZndnxqBiviGCZNAbAR3jzR7r+1hhMiW9OdFojj3OXYA8+4hI8b2RFiW/HKs5AeHf/mOtjOX9wr4UjLOISzm+otRiDDEMy36FYc+ndJCGVKxdjveyaDIiJtnV5pxbrXFCoMzgWswjKIry39bF58Wlrk484kB9/b3Lf//iFMn37QgqFChvBB0micLRoh7Bi2DsnVrI1LoG/lvYe+Ts6aifjFo4yb032moco1vcc6IH6R2JOL+yC9q/b01bu70/ci7y5IsXP5f8NeuNJdKtpdEPQhnekDkzpCVoNVqlfFiT3TB32tE23z9sz5LlusIXxtrQayz6M0QB9xH7reN/uscNRJGiy/l24WblbOGCu3jersdQPc8nLCTguiRr62q12ipijsfAe/sARFNraMxyXSprgKfdhLPPWtcARICMYM9B90XKBDS3Zso/MluHi9boBf7ePtXwRXeeaCKUFA4De0xb6uy7B7FpMSirfnP9yyXgFyIR81T1OnP+WKxTAXK20XLJDTzvoOC/ZhiQeYXX5rO5RK4V+cXAKhwvP2jIqtYSPd7Fow+/GzQ98TflTYqXq/WtbKPiI/S5/dllxfZGm/2YAh71nCyYOSXAK7poNAgcSgoiZKDv03r5NKGOGvP4W/vqXWdYXSltONS63fpefaSLpizSNNeny8iaWLRstOvu8blJPz4ZHrD70gP5bUu27C5C7FkSTKL5rdeoiFxaeEc9PUj9ohtnLZLkMudUmm2Mo4bIEzcxfToEuz/OjHaybeCQcddQGQqstf0rnwwTPaZZbzMqdLk6Wny5LckMoTtO3eI3Cw6uWvsvkfLIDQIz5xTs4srv7ZLe7aWGfgE59/kbRPmzAhxwueUms0IFZhOY02ldM/8wc73mnqWQkvv9MbWsg3Ck0OHwAV0V0fCpRjt8ZV9CBTIzFPCVDRNuoQvuIMYM2+d/0t+0wVzAEmVLmsMIkEhSFh8ZGrxe+cmAA2bPbzwmciEcVZbE5ZZSyQESFxHUNtQHBNT5sosyVuhnxD0KRJNz2mEDFsU0Ylloc63iSoodUGaRYSmUIeuY95MMzo1I3fhRMSOHmAYVtgDaB0iGKlu5h3WODj3VR6MSarp4bmGB58gpCGXH+WdkvYTPY8nuiKWfaS8zOkyyvoob+6YTs5SdTEi/0Riz7IYP/l6DsjmqjK58f2IWjVg8IZj2mpv2xCUh2rZdw5SHr4R1kWxrLuy2j66LgMag4qUugaxfE8K2xr4Y2zh0FkxurRZHHM6UqkE8uPxfRa/iDA7Ov0itMx4uZ0bi7msHEOCHkN7M9M8ead9BoiAXXbwBfw4xVhDSlYzO1MV0c1z3j25UDskK0q44O9vUuKgBxjGT1r86D5Agz6F+mweNQZwUV2MB3lDQRbHB3I9cJJeg+8V0G0DDV6+AFcXPshXRtqUYieDLy4xgTZjM0CCCz70UWtKsAKXahbCQScBRCBGnojz3ZaNyYUCU/T5jjHozYYbIsa6i/UCh9zX25oXtfekC4/+ltK2bdntGC3wAD9tqTA6Wj7hXZfiL+oia0Vk4pkFjrmLkDCPW3FyvRF6Ci4B43cSPm5H6TO0Kwm4rsE0kpgnbxdy5P7iHdTXAUX1PNHoc72CEtafX2594GXDjF4XWBJA+yv/duo6ye5zUBPlOw3KBO4TU4VI24yDJE4g0cV2P97H72h/gdI/iVx6m0mMmkCtMXaetjw4X9Q5YREpjI8tUl5uu2KVgC7X0Cb2Rh1CTS1M+d+b4nn6MY/Q93LD8yWxp+0kbZvoZrUnx9pcHeuOi+RpkAEl33H5VhScpZ7uHhh74tbhYFHYQc6TxoA34cNqlfKW/4I7KdJTvQNyD//FWkaTPOekvzV0/QIQau+LSdUC1h/MJPzXIQpKUBRnO8Zn+kkDR8IDQY/qXmhTMewoF/LBID9njetskzSB+oO+VJZ/OO15mbOJACXs5O3YQCYuhTtTlRLzF3fG5clfWAH9vxT4dRAJp2cunnk2HSXnHrx+jqcLKrmTB6AxXo/kglwbH3DXXEjTU+1XvI4GidcgBgarvxwBHu0LYCA1n8YTLZUAnYuGWEkHX144UxD6VTzQmNGTBKqdZ4DEdZooUmcUUEuR6gaaEOgnSnb4w2cXy5lVqAgdQkfzM47rkNXWiMU3AkWud2dzp3kXn04Zp/DQWSOFajcq6LhhGGoONtSMNowN+0ymmBzXJBuAUZzWosvICoG+hwO/JhJy2jOWZmJX5CJSmS4Fcw6vF7K72h2vcTF7byEH4g+ToYhzdsv5aBLvZG3YVcanbZVI1tkdd6xW46HB9XVq8tdRWiaGFB7HppX0Ze3/UKfLR0tFaR6w7jpjMBaKftldsIvbdRUd3L37J0YjGfLiKDOekJDrI76l+kJia4gH1gszyUhmAcInzxXYHnkyax4MxnWoJ+v4MuQmDmRhfKOGIaxVj6Ty3dwJ8OYiixp3QdqoYteAzHTArzJjWBiWcyQ/YAv+wRqP/x/maw23CSvHKrkCVrNsQtrEZPDYDqFqGQD/j72yqSl1MUBHSVrhVD3ugRMO5i0uPUYKvyi1Bapo7FN/yEflUhLLB5GTa9Xp/FozmVjABHcjFpwIKiRuNCvuKmMJeehyuNq2p5vPJjVMnD4t18MoZd8h4tUR5Fa4SqYYLm/IxxC2sk1+a1d3xm1pVoJZi4FmqXsVxEy40aBUK0vLC1cxS+yMtNnM5s4F3JxJCmLeMsiRpnXoRY19n7EUQj96onTMv/UthER/P7Z8IzsQLudLqQxMp1soPd2a8jbyia7mTbLRSMjqvykOTmLkOhHrSioLQBfvVukA25rhcugoYViU9AjT7bEu8cNlPrY7MxDkD5Ilh5pH7SHoiDxIVIWtr2W0Umnsu/bIRW58h75JhlnOyM7e16TLhtsW8hiCsTL980znKX5VpCuk3NaN6ccuJddONHTiyQC9VmzU9E6Tzp5DEvsTIUbAXqxi6dZAD+jhHv8IMMNR28sDNohCIZJ0FnzdYo/JeM1JhSjyTAR2Pz9eAgwA3VZlTigaGlrg8B6gvk3LfhNJgwOCWtqwWZq0JJbNYm11QkKDij46gqMcG199JoCmGybjJetDU4SoqrTYnSgiwuh8j5BcOvwU5pFN1ppwGcSUsOPjtoL+W45JQs9oW+vlxLCtQ/4LORYZeJ5Moeu1m++5vblFqzfZ5WTlTOk+4NFg1mzpRCHajtu8u/Bq5ECjReYAgf1OpAJBisNYSy5ODtoqE//2GkLsCH72XfPlG70SB1kwZNXoBTR0zSAworGYcR+9qEUs5rGkJ0nEOOXj9AIBdR6AMghjWHmOhMU1SR59Hk+XOmr75IW1Nfu0mbwFcyo5Loz5wru7bAeIXDl5YAR5JXFmnJBJqzrlcDNWdeexX/qqXJtrI3505sZtDDN/CWyHKplwl/eIV7otc5KR6AyXODAem46Xe6QM1Cq4E0w0UbWbeQofVEhgDt8vPUcMDO7gktWGs58xa9Ax/k9gWiAhxSsk82BUY9pmbSxXWlCNeZdx1F1qcAfMQ2JumrTKxj8yOmY1Yax8oG9KP7Cng7VPctuxAlonzorCAJH9rPmJ25Z3zDe074udmMmGlNh/IN66+WcougSJimrtkbeEBvNyOPAqV8HII4Y3U0EIFAOAzdjbq7WWiUVzK/ElU6NNGsQ7aXXZ2freI3xsmbV6hV3oyXPrQ+g4DGn1ZBWo4QQqwHjBzMuBG2vQSCB74Km3rdIpSM+L3y/dn07vg4q2NhZxl0oaxcWusmNUx0C860o33eFlN8i5IEhL5JM/a05npE/H9hzkes4UboJrPfv32Fh9l1Vsnjk+ESAFt9ZokwwpFBnxdkSheLi+oJRQ9NnR+uRIJFgMT6i2/XekbHMS7RLtAhSvlp0QV9vTRkeZtbkfLkP4bHVgp6TtnQh7IB4oXtRiGdHfIk+Pnp/g4pVBDW9sH5tKg514dqmFQPNBCjL4CSN8U96jWJZpGpsT9r4lsLPT5dxd1ZqQiXz1BDq90Rgc+UQqNdigeTZOuI+sq4AGjBqeapmNkO3pm4HW7vwsL5QRLoefb/GxzeY45hsv0BI2rhQh/lcXfHwgT3C8Tu1e6RrriLpY+aQPvrUdba7B9T36CmcAh2ux7NNMfehjch2fN5Jdr9uYhnAkieDywNXfdPynkA/NphMytznAjoX9TV56uGHOpGsZDoEddx8KVv+EFt01VQWiMZV3oVd0PitOePrIEYPv/mxipoZjblYXEbzqvb1fyoMyLIhY0/av+94uV//PYq1FZP76dg/FuDuBk1Djv5NtAjB/SQwh8aDn2W0F1Hz2P7aQ1A7b3SSQmqMoWM2BBioXV1yk7XhFf9MeltoT9++SG4u44zu3F7YSugGJzJvBsjBuYLnZ6IVASli5pWJEoRH+watURXOWlZ5ApG/sDYR4hCzpHfu/drUNs1qxsvBHUXEmK4Ee6JL02wWdpHPTEmpQHYoPssDRJLCRGUaME9N/AKv+Ph9bMwymMyX0ERhhfrJICBu7CYApb8s/i+HQ567PlmCk9yKQ4ADoHTyD4SQdbhT7BnykTzqZi0R+XXtY1RtcPIx7BDvcTRB8kKMTZ4sznk5zv8/OLeebdZnAYYj14fSTM/aIsWdQ8NOqYZBJv8ERgmjS0R+tM3eL+/0/Kk8DP1zml6jWNUE9QRP2hhvh+2jAN7ZnYX9fjAuFZ+6+dSvt28UU2jd0qyHa8g/mrNKEtaLf7CTIa+x0vqlkSxabF6fNdDNs2AY+wiTPbScGdz+97kaR4aOuQTz9otNyTOl8Izhwpuj0BW9/mvb2ABAyI1L4YpZ8CWR/UrWn6OUwP3NlIkh3M354Xm1cVBzMZYW6IIKfzoT4/t8yVLzTW6Mz97DjhKtkfm1+L2B1iXISZT8FPNaxX+4wwhBa+Oo7th7seyJ2WM0NPv+zuD+OeBtKIBme/joIUgWUKsqJmemwJGBpZq3M6WaiGDDT5bQZcFb5wc/VRcAEcODgoqVPFNcWU8nThdBy0vhPCkqaaP0vAm6HwIeluCurAjTvVvmeeJort9S759ucHP4PfPvyVdAmn+2Z6SXuDZE4trRvqfXNfpjU8m8ZXcz06cYLEjEG/BqkmVo2HoJqM9O0loymr0e00u2nnsuKmhenzzzWL8YaPU8Rz7hF8eG4RXfgEQ5SQM3+UYcF60p7uvh1r9ZjHSdKv3bPDTaMRT53ANrjDPAkj9oFVPh7vnWqgd0vsnVeq4SRXk/4GJe8qzvEc/4IE8FIAUutneslaDahY1wW+nKb8rw1cNUGWnOH33TzRYeTwqHm4KKFnTuhQ3FepFeNN2Z6VlZYq0iJNUXnLHAMQxUNWCxfYcKfDZPDIRnqJa1cg6aQBwrytnZw1h5r76TVdYOBK/5Fbi9kj7rjWNx67xJPugnmFY1Lfhk4lo</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div>
<script>
var onError = function(error) {
	document.getElementById("enc_error").innerHTML = "password error!"
};
function decrypt() {
var passwd = document.getElementById("enc_pwd_input").value;
console.log(passwd);
doDecrypt(passwd, onError);
}
</script>
</div>]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 文章加密方案]]></title>
      <url>/2017/12/07/Hexo-%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<p>使用Hexo搭建静态博客有时候有些想给文章加上一些权限，只有指定的人才可以看，这里提供一种通过<code>hexo-encrypt</code>插件实现的Hexo文章的加密方案</p>
<a id="more"></a>
<h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><p><code>hexo-encrypt</code>的详细介绍在<a href="https://github.com/edolphin-ydf/hexo-encrypt" target="_blank" rel="external">这里</a></p>
<p>本地安装插件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-encrypt --save</div></pre></td></tr></table></figure></p>
<p>配置：<br>全站文章默认不加密，只有指定的文章加密</p>
<p>修改站点配置文件<code>_config.yml</code>，在末尾添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">encrypt:</div><div class="line">    enable: true</div><div class="line">	password: 2333</div></pre></td></tr></table></figure></p>
<p>其中2333为默认密码，如果在文章中没有使用新密码，默认使用这个密码</p>
<p>文章头部的添加说明说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">encrypt: true</div><div class="line">enc_pwd: 123456</div></pre></td></tr></table></figure></p>
<p>这篇文章使用新的指定的密码</p>
<h2 id="进阶优化"><a href="#进阶优化" class="headerlink" title="进阶优化"></a>进阶优化</h2><h3 id="替换文本框为密码框"><a href="#替换文本框为密码框" class="headerlink" title="替换文本框为密码框"></a>替换文本框为密码框</h3><p>输入密码默认是明文显示的，把源码中的文本框改为密码框即可：</p>
<p>编辑文件<code>node_modules\hexo-encrypt\lib\conf_post.js</code>，找到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.template = &apos; &lt;input id=&quot;enc_pwd_input&quot; type=&quot;text&quot; style=&quot;&apos; +</div></pre></td></tr></table></figure></p>
<p>替换成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.template = &apos; &lt;input id=&quot;enc_pwd_input&quot; type=&quot;password&quot; style=&quot;&apos; +</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识iptables]]></title>
      <url>/2017/12/04/%E5%88%9D%E8%AF%86iptables/</url>
      <content type="html"><![CDATA[<p><a href="https://www.wikiwand.com/zh-cn/Iptables" target="_blank" rel="external">iptables</a> 可以简单理解为 Linux 系统内核级防火墙 netfilter 的用户态客户端。<br>Linux 管理员通过调用 iptables 命令，配置 Linux 内核 netfilter 模块规则，对网络数据包的流动进行管理。</p>
<a id="more"></a>
<h4 id="iptables-基本命令"><a href="#iptables-基本命令" class="headerlink" title="iptables 基本命令"></a>iptables 基本命令</h4><h5 id="iptables-语法帮助"><a href="#iptables-语法帮助" class="headerlink" title="iptables 语法帮助"></a>iptables 语法帮助</h5><p>可以使用<code>iptables</code>查看iptables的帮助文档</p>
<h5 id="查看-iptables-表的规则"><a href="#查看-iptables-表的规则" class="headerlink" title="查看 iptables 表的规则"></a>查看 iptables 表的规则</h5><p>iptables 有[表 (tables)] 的概念，每张表又包含不同[链 (chains)]，大部分情况下我们仅需要使用 filter 和 nat 两张表的链就可以完成功能。</p>
<p>使用以下命令可以查看 filter 表中的规则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo iptables -L -n</div></pre></td></tr></table></figure></p>
<p>参数解析 -L 列出规则， -n 不显示域名，命令默认显示的是 filter 表，可以通过 -t 参数来指定其他表</p>
<p>可以看到目前 filter 表中有 3 条链: INPUT, FORWARD, OUTPUT。 3 条链都没有任何规则存在，因此通过网卡的网络数据包不会受到任何影响。</p>
<blockquote>
<p>iptables 包含 5 张表（tables）：<br> raw 用于配置数据包，raw 中的数据包不会被系统跟踪。<br> filter 是用于存放所有与防火墙相关操作的默认表。<br> nat 用于网络地址转换（例如：端口转发）。<br> mangle 用于对特定数据包的修改。<br> security 用于强制访问控制网络规则。</p>
<p>链可以看作是一系列规则集合，默认的链被用于不同的场景，用户也可以创建自定义的链。例如：<br>filter 表的 INPUT 链用于进入网卡的数据包过滤<br>filter 表的 OUTPUT 链用于过滤网卡对外发送的数据包过滤 一条链中的规则从上自下顺序执行。<br>实验</p>
</blockquote>
<h4 id="禁止访问目的地址"><a href="#禁止访问目的地址" class="headerlink" title="禁止访问目的地址"></a>禁止访问目的地址</h4><h5 id="添加一条规则到-Filter-表"><a href="#添加一条规则到-Filter-表" class="headerlink" title="添加一条规则到 Filter 表"></a>添加一条规则到 Filter 表</h5><p>在没有任何防火墙规则时，尝试 ping 百度的服务器，ping 是可以正常返回的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ping -c 4 www.baidu.com</div><div class="line">PING qcloud.com (119.29.47.192) 56(84) bytes of data.</div><div class="line">64 bytes from 119.29.47.192: icmp_seq=1 ttl=58 time=3.11 ms</div><div class="line">64 bytes from 119.29.47.192: icmp_seq=2 ttl=58 time=3.10 ms</div><div class="line">64 bytes from 119.29.47.192: icmp_seq=3 ttl=58 time=3.17 ms</div></pre></td></tr></table></figure></p>
<p>假设我们作为 Linux 管理员，不希望有人从本机 ping 百度的服务器，那么就可以用到如下的 iptables 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo iptables -I OUTPUT -p icmp -d www.baidu.com -j DROP</div></pre></td></tr></table></figure></p>
<p>参数解析 -I 添加规则到链的最前面， -p 匹配协议， -d 匹配目的地址， -j DROP 将匹配的数据包实施丢掉动作</p>
<blockquote>
<p>重要:<br>因为在 iptables 一个链中的规则是从上到下依次执行的，因此一条规则在链中的位置十分重要。<br>例如一条拒绝全部连接的规则 -j REJECT 一定要放在链的最后，而允许通行的规则要放在这条规则之前。<br>否则所有网络数据包进入链后直接匹配到这条规则，将导致所有连接被拒绝。</p>
</blockquote>
<p>现在我们可以用 <code>sudo iptables -L -n</code> 命令看到 filter 表的 OUTPUT 链中新增了两条记录，其中 destination 地址是 DNS 返回的百度服务器 IP 地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Chain OUTPUT (policy ACCEPT)</div><div class="line">target     prot opt source               destination</div><div class="line">DROP       icmp --  0.0.0.0/0            220.181.112.244</div><div class="line">DROP       icmp --  0.0.0.0/0            220.181.111.188</div></pre></td></tr></table></figure></p>
<p>这时再 ping 百度服务器会发现无法 ping 通了，因为访问百度服务器 IP 地址的数据包已经被防火墙过滤丢掉了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ping -c 4 www.baidu.com</div><div class="line">PING www.a.shifen.com (220.181.111.188) 56(84) bytes of data.</div><div class="line">ping: sendmsg: Operation not permitted</div><div class="line">ping: sendmsg: Operation not permitted</div></pre></td></tr></table></figure></p>
<h4 id="导出、编辑、导入规则"><a href="#导出、编辑、导入规则" class="headerlink" title="导出、编辑、导入规则"></a>导出、编辑、导入规则</h4><p>在进行一系列复杂的防火墙配置时，大多数时候不建议直接调用 iptables 做规则修改。 因为任何一条错误的配置或者一个 typo （输入错误）都有可能导致严重的网络问题。</p>
<p>一个最佳实践是导出现有规则到文本文件，对该文本文件进行编辑，进行检查无误后再将其导入。</p>
<h5 id="导出规则"><a href="#导出规则" class="headerlink" title="导出规则"></a>导出规则</h5><p>通过如下命令导出所有规则到文本文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo iptables-save &gt; /home/ubuntu/iptables_rules</div></pre></td></tr></table></figure></p>
<h5 id="编辑规则"><a href="#编辑规则" class="headerlink" title="编辑规则"></a>编辑规则</h5><p>在新标签页打开 iptables_rules，在 filter 表的 :OUTPUT ACCEPT 链下面添加一条规则的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-A OUTPUT -p icmp -d 114.114.114.114 -j DROP</div></pre></td></tr></table></figure></p>
<h5 id="导入规则"><a href="#导入规则" class="headerlink" title="导入规则"></a>导入规则</h5><p>使用命令将编辑过的规则重新导入 iptables<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo iptables-restore /home/ubuntu/iptables_rules</div></pre></td></tr></table></figure></p>
<p>使用 sudo iptables -L -n 查看是否有禁止 ping 114.114.114.114 的新增规则</p>
<h5 id="清除全部规则"><a href="#清除全部规则" class="headerlink" title="清除全部规则"></a>清除全部规则</h5><p>现在我们清除上一小节中增加的规则，还原到没有任何规则的初始状态。</p>
<p>Note：当你因为错误的配置 iptables 导致自己无法远程访问的时候，从 console 执行这条命令可以快速修复状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo iptables -F</div></pre></td></tr></table></figure>
<p>iptables 还提供 -X 参数清除[自定义链]， -Z 参数重置计数器</p>
<h4 id="黑-白名单"><a href="#黑-白名单" class="headerlink" title="黑/白名单"></a>黑/白名单</h4><p>某公司禁止特定的 PC 设备访问和工作无关的网站，而其他设备则不受限制。</p>
<p>分析：</p>
<p>1.首先明确是对外访问限制，所以应该编辑 iptables OUTPUT 链进行限制</p>
<p>2.其次，由于目的地址可能是数百个网站，针对每一台PC配置数百条规则是不可接受的，因此我们选择使用自建一条链来实现。</p>
<p>3.公司只限制部分 PC 访问，因此对 PC 的匹配最好使用 IP 地址匹配，不匹配的设备则不受限制。</p>
<p>Note: 对于进入 INPUT 链的入站规则还可以采用 mac 匹配。</p>
<h5 id="查看本机-IP-地址。"><a href="#查看本机-IP-地址。" class="headerlink" title="查看本机 IP 地址。"></a>查看本机 IP 地址。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ip a show eth0</div></pre></td></tr></table></figure>
<p>在 inet 之后的就是本机网口的 IP 地址，例如 10.135.166.86</p>
<p>查看公网IP也可以使用一些IP工具进行查看</p>
<h5 id="编辑-iptables-规则："><a href="#编辑-iptables-规则：" class="headerlink" title="编辑 iptables 规则："></a>编辑 iptables 规则：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//清除已有规则</div><div class="line"></div><div class="line">sudo iptables -F</div><div class="line">//清除自建链</div><div class="line"></div><div class="line">sudo iptables -X</div><div class="line">//新建一个叫做 BLACKLIST 的链</div><div class="line"></div><div class="line">sudo iptables -N BLACKLIST</div><div class="line">//当访问的源 IP 地址是本机的时候进入 BLACKLIST 链</div><div class="line"></div><div class="line">sudo iptables -A OUTPUT -s 10.135.166.86 -j BLACKLIST</div><div class="line">//向 BLACKLIST 链添加 2 条规则</div><div class="line"></div><div class="line">sudo iptables -A BLACKLIST -d 114.114.114.114 -j DROP</div><div class="line">sudo iptables -A BLACKLIST -d 220.181.111.188 -j DROP</div></pre></td></tr></table></figure>
<p>如上配置后，会发现本机已经无法 ping BLACKLIST 中的目的地址了。</p>
<p>如果后续要增加新的禁止访问的目的地址，则只需向 BLACKLIST 链添加新规则。<br>如果需要限制另一台 PC 通过本网关转发访问外网，则只需添加一条 OUTPUT 链的源 IP 匹配规则并指向 -j BLACKLIST。</p>
<h4 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h4><p>分析： 通常来讲应该首先考虑程序本身能否配置监听多个端口，或者使用负载均衡器作为代理程序。 但在本次实验中我们将使用 iptables 监听 8080 端口并将网络数据包转发给本地80端口</p>
<p>首先测试 <code>telnet 0 80</code> 和 <code>telnet 0 8080</code> 可以看到 80 和 8080 端口都是不通的。</p>
<p>接下来我们用 netcat 监听 80 端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nc -k -l 80 &amp;</div></pre></td></tr></table></figure></p>
<p>这时候 telnet 0 80 发现 80 端口可以工作了。</p>
<p>下面我们用 iptables 做一个端口映射<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo iptables -t nat -A OUTPUT -p tcp -d 127.0.0.1 --dport 8080 -j DNAT --to 127.0.0.1:80</div></pre></td></tr></table></figure></p>
<p>这里我们用到了 -t nat 参数，表示我们使用了 netfilter 的 nat 表。在 nat 表的 OUTPUT 链上做了一个 -j DNAT 转发，将访问内网 8080 端口的数据包转向了 80 端口。</p>
<p>这时候 telnet 0 8080 发现 8080 端口也可以工作了。</p>
<p>如果是监听外网的 8080 端口转发到 80 端口，则需要执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo iptables -t nat -A PREROUTING -p tcp --dport 8080 -j REDIRECT --to-ports 80</div></pre></td></tr></table></figure></p>
<p>通过使用 PREROUTING 链直接将访问 8080 端口的数据包转发到 80 端口</p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iptables </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[台中两日游]]></title>
      <url>/2017/12/04/%E5%8F%B0%E4%B8%AD%E4%B8%A4%E6%97%A5%E6%B8%B8/</url>
      <content type="html"><![CDATA[<p>又到周末，看天气预报台北这个周末还是下雨，这次下定决心要南下避雨。早上做的决定，然后查火车时间、定民宿九点才从家里出发，也算是一个说走就走的旅行吧。</p>
<a id="more"></a>
<h2 id="台铁网络"><a href="#台铁网络" class="headerlink" title="台铁网络"></a>台铁网络</h2><p>早上在家查火车时间的时候已经没有对号列车，想要有座位只能做区间车，还好从台北车站上车的时候还有一些座位。</p>
<p>到台中已经是下午一点了，然后继续坐区间车到清水车站，转一次公交车到高美湿地，中间换乘公交的时候等了很久。最后到高美湿地的时候已经是下午四点了。</p>
<p>其中区间车从台中到清水事实上是北上的，按理说如果北上的话我在从台北到台中的车上到清水停下来就行了。之前我一直以为台湾的铁路网络就是绕着台湾转一个圈圈，其实除了台铁在这个圆圈中生出一些短的分支以外，还有一段是两条线平行的。具体可以看台铁的<a href="https://www.railway.gov.tw/Upload/UserFiles/tr_line.pdf" target="_blank" rel="external">线路图</a>。这一段大致就是从新竹到台中一段，分成了山线和海线两条平行线，台中在山线的一段，清水在海线的一段，所以才要坐区间车绕到海线然后北上。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-160347.png" alt="台中车站"></p>
<h2 id="高美湿地"><a href="#高美湿地" class="headerlink" title="高美湿地"></a>高美湿地</h2><p>高美湿地之前其实不是湿地是对外开放的<a href="https://www.wikiwand.com/zh-cn/%E6%B5%B7%E6%B0%B4%E6%B5%B4%E5%A0%B4" target="_blank" rel="external">海水浴场</a>，湿地也是这几十年形成的。主要的原因是旁边建了一个台中港导致泥沙淤积。后面又建了一组风力发电站，才有了今天照片中的这番景色。</p>
<p>到了高美湿地以后第一个感受就是风大，到桥的边上感觉都能够被吹起来。第二感觉就是这“风扇叶子”好大啊，站在发电机组旁边想着这玩意要是砸下来不就GG了。高美湿地一直是以夕阳的美景著称，但是我去的那天天上全都是云，偶尔有几个“窟窿”还不是在海的那一边，可能是我来得太早了吧。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_1512374762267.jpg" alt="别人拍的高美湿地"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-160712.png" alt="我拍的高美湿地"></p>
<h2 id="台中公共交通"><a href="#台中公共交通" class="headerlink" title="台中公共交通"></a>台中公共交通</h2><p>台中的公交交通一个比较有特点的地方就是前十公里免费，这种优惠政策在台湾只有台中有，在世界上应该也是蛮罕见的。至于为什么台中会实施这种优惠政策，看网上说的好像是市长选举的时候为了拉选票推出的。另外台中的iUbike前30分钟也是免费的，这福利真是太好了，我在台中的这两天我坐公交一共只花了10+TWD。</p>
<p>不过还是要吐槽一下台中的公交车，发车间隔太长了。除了由之前的快速公交改过来的300路，其他公交线路发车间隔时间都在20分钟以上。去高美湿地的时候来回差不多都等了半个小时的公交，还是台北的公交系统发达啊。</p>
<h2 id="逢甲夜市"><a href="#逢甲夜市" class="headerlink" title="逢甲夜市"></a>逢甲夜市</h2><p>逢甲夜市号称是台湾最大的夜市，这个看他们的牌子就看得出来，别的夜市一般都只加上“观光夜市”的字样，逢甲霸气的加上了“国际观光夜市”。</p>
<p>东西的确挺多的，占了两条街，我选了两个队排得比较长的吃了一下，感觉还行。</p>
<p>旁边隔着的就是逢甲大学了，外面人潮涌动，逢甲大学里面却只有稀稀疏疏几个人。学校旁边是台湾最大的夜市，一定能够换着花样吃。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-160837.png" alt="逢甲夜市"></p>
<h2 id="民宿体验"><a href="#民宿体验" class="headerlink" title="民宿体验"></a>民宿体验</h2><p>民宿因为是当天才找的，所以能够选择的余地并不过。不过总体的体验还好，民宿小姐姐特意来新光三越接我。我住的是8人混住房实际住的只有4个人，高中之后第一次睡上下铺。地点在台中市的市中心，旁边就是新光三越和市政府。卫生情况也还可以，比较特别的就是认识两个小伙伴，一个是在世新大学读传媒的马来西亚交换生；另一个是台湾这边的一个老师。</p>
<p>和他们聊的时候也收获到了蛮多的东西，比如说为什么马拉西亚人的中文那么好、台北冬天为什么一直下雨。其实想想，一个人出来玩有一个人出来玩的好处吧，如果结伴出行可能就不一定会认识到这些人有这些收获。</p>
<h2 id="东海大学"><a href="#东海大学" class="headerlink" title="东海大学"></a>东海大学</h2><p>东海大学是台中的一个有基督教背景的私立大学，台中非常有名的路思义教堂就在东海大学里面。有人评价路思义教堂是中华文化与西方相遇而产生的最佳作品。对建筑风格没什么了解，不过觉得还是挺有特色的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-160942.png" alt="东海大学"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-160940.png" alt="路思义教堂"></p>
<h2 id="台中歌剧院"><a href="#台中歌剧院" class="headerlink" title="台中歌剧院"></a>台中歌剧院</h2><p>台中歌剧院的建筑非常有特色，位于台湾市中心。歌剧院由钢筋混沙土构造，部分为钢构造；建筑师伊东丰雄的设计，以人类最原始的“树屋”、“洞窟”的概念设计出美声国栋（Sexy guy），内部墙面均为曲面。共有58面曲墙，兴建难度极高。</p>
<p>比较感兴趣的时候楼顶的空中花园，但是因为修养关闭没能够上去，可惜了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-162744.png" alt="台中歌剧院"></p>
<h2 id="台湾美术馆"><a href="#台湾美术馆" class="headerlink" title="台湾美术馆"></a>台湾美术馆</h2><p>前面的歌剧院因为11：30才开馆，所以也没能够进去参观，台湾美术馆应该是这次台中之行在室内看的最受震撼的地方吧。里面各种艺术展品都挺震撼的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-163955.png" alt="enter description here" title="美术馆外景-1"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-164107.png" alt="enter description here" title="美术馆外景-2"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-163957.png" alt="enter description here" title="美术馆内景-1"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-163959.png" alt="enter description here" title="美术馆内景-2"></p>
<h2 id="静宜大学"><a href="#静宜大学" class="headerlink" title="静宜大学"></a>静宜大学</h2><p>前面的东海大学是基督教大学，而静宜大学是一所天主教大学。之前一直是一所女子大学，从1993年开始才开始招收男生。校园里面环境挺好的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-164806.png" alt="enter description here" title="静宜大学校门"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-164735.png" alt="enter description here" title="静宜大学图书馆"></p>
<h2 id="宫原眼科"><a href="#宫原眼科" class="headerlink" title="宫原眼科"></a>宫原眼科</h2><p>当我第一次看到这个景点名的时候，我一直以为是一个医院，看他的<a href="http://www.miyahara.com.tw/" target="_blank" rel="external">官网</a>也不知道具体是干啥的。</p>
<p>后来才知道是一个甜品店，建造於西元1927年，是由日本眼科博士宫原武熊所兴建，也是日治时代台中规模最大的眼科诊所。后来成了危楼，被「日出」团队重新复原成现在颇具特色的宫原眼科。</p>
<p>听说里面的冰淇淋和凤梨酥比较有名，尝了一下冰淇淋，还不错。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-165730.png" alt="enter description here" title="宫原眼科"></p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[士林半日游]]></title>
      <url>/2017/11/28/%E5%A3%AB%E6%9E%97%E5%8D%8A%E6%97%A5%E6%B8%B8/</url>
      <content type="html"><![CDATA[<p>周末在家瘫了一天，另一天不想浪费了。刚好最近看了一个体验东京科技馆的视频，就想看看台湾科技馆里面有什么有趣的东西。</p>
<a id="more"></a>
<h2 id="台湾科教馆"><a href="#台湾科教馆" class="headerlink" title="台湾科教馆"></a>台湾科教馆</h2><p>台湾科教馆在台北捷运红线士林站附近，不过离捷运站还是有一点距离，推荐骑Ubike过去。旁边是台北天文馆和台北新儿童乐园。这一带还是挺适合亲子周末游玩了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_2_001.jpg" alt="外景（我去的时候装修，没拍到）"></p>
<p>科教馆里面3楼到7楼是常设展厅，需要购票。价格是100TWD，学生优惠价70TWD。另外还有一些项目，立体剧院、地震剧场啥的，我也花了20TWD体验了一把地震剧场。</p>
<p>3楼到7楼的常设展厅还是挺有意思的，有许多学习互动的设备。涉及的知识差不多就是初中高中所学的生物、物理、化学和数学的相关知识（哈哈，感觉回到了高中课堂）。正常速度走走看看能够看两三个小时。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_2_WechatIMG2.jpeg" alt="模型"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_2_WechatIMG3.jpeg" alt="馆内的科普讲座"></p>
<p>参观完常设展厅，我也体验了一下地震剧场。就是一个比较大的圆盘里面坐十个人左右，然后模拟4-5级的地震，然后屏幕上播放<a href="https://www.wikiwand.com/zh-hans/921%E5%A4%A7%E5%9C%B0%E9%9C%87" target="_blank" rel="external">921地震</a>的纪录片。地震体验效果一般，但是屏幕上播放的纪录片挺震撼的。</p>
<h2 id="士林夜市"><a href="#士林夜市" class="headerlink" title="士林夜市"></a>士林夜市</h2><p>到了士林，自然要来这里有名的士林夜市逛一逛了。因为来得太早了，之前得到的逛夜市经验（哪里排队多哪里好吃）也派不上用场。于是就在网上找了推荐比较多的两家店平吃了一下。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_2_WechatIMG4.jpeg" alt="士林市场大门"></p>
<p>1972年就开业的忠诚号蚵仔煎应该是士林夜市最具代表性的小吃了，上次吃蚵仔煎还是在花莲的东门夜市，不过上次因为是带回民宿吃的，所以最后吃到的东西是凉的。这次的蚵仔煎感觉就跟上次的大不一样了，非常好吃。<br>注意台湾这边蚵仔煎的叫法是从闽南话音译过来的，叫（ǒu ā jīan）</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_2_WechatIMG1.jpeg" alt="忠诚号"></p>
<p>士林夜市大门旁边的十全排骨也不错，份量很足，吃起来很带劲。</p>
<p>十全排骨 照片</p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[夜登剑潭山]]></title>
      <url>/2017/11/26/%E5%A4%9C%E7%99%BB%E5%89%91%E6%BD%AD%E5%B1%B1/</url>
      <content type="html"><![CDATA[<p>看台北夜景一般的选择都是象山，那边有台北的地标建筑——101大楼。除了象山，剑潭山也是看台北夜景的一个不错的选择，人少而且能够换一个角度看台北。</p>
<a id="more"></a>
<h2 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h2><p>剑潭山在士林夜市旁边，能够在士林夜市吃饱喝足再上山。不过我最近迷恋金拱门，这次是吃了两包大暑才上山的。</p>
<p>我们上山的线路大致是<a href="https://www.google.com/maps/dir/%E6%8D%B7%E9%81%8B%E5%8A%8D%E6%BD%AD%E7%AB%99+111%E5%8F%B0%E5%8C%97%E5%B8%82%E5%A3%AB%E6%9E%97%E5%8D%80/104%E5%8F%B0%E5%8C%97%E5%B8%82%E4%B8%AD%E5%B1%B1%E5%8C%BA%E8%80%81%E5%9C%B0%E6%96%B9%E8%A7%82%E6%99%AF%E5%B9%B3%E5%8F%B0/@25.0834816,121.5280835,15.63z/data=!4m24!4m23!1m15!1m1!1s0x3442aeb1dc51736b:0xba7e1559c66ed90f!2m2!1d121.525077!2d25.084873!3m4!1m2!1d121.5249269!2d25.0796471!3s0x3442aeb29b137353:0xc81fe0fdb900019a!3m4!1m2!1d121.5297702!2d25.0831486!3s0x3442aeae847cf9f3:0x8ad42cd31d0e8b6a!1m5!1m1!1s0x3442aea758724e3b:0x6f606638fbaff219!2m2!1d121.536965!2d25.0904047!3e2" target="_blank" rel="external">这样</a>的：</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_2_1512191397180.jpg" alt="登山路线"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_2_WechatIMG5.jpeg" alt="登山，出发！"></p>
<h2 id="爬山"><a href="#爬山" class="headerlink" title="爬山"></a>爬山</h2><p>我们上山的时候刚好是晚上十二点，山上几乎是一个人都没有，遇到的唯一一对外国情侣还是我们刚上去他们从山上下来的时候遇到了。</p>
<p>想想半夜如果你爬山爬着爬着发现后面有两个人其实也蛮恐怖的。</p>
<p>上山道路的前一半是有路灯的，而且这些路灯是通宵开着的，所以前面一段路还是不用怕的。途中也能够遇到一些寺庙、亭子，甚至还有羽毛球场（在山上打羽毛球就不怕球掉书上吗）。下雨的时候还能够遇到一些动物，大型的蜗牛啥的。</p>
<p>不过有路灯的登山道到的观景平台能够看到的景色就有限了，在剑潭山看台北夜景最好的地方就是老地方观景平台了。</p>
<p>晚上想要到老地方观景平台就必须要走一段没有路灯的山路，就是上面的路线图中的标出来比较大的路。一开始我们以为是公路，结果就是比前面的登山道大一点点。凌晨一点，两个大老爷们纠结了十多分钟走不走这个没有路灯的路，各种想象什么土狗、浪、蛇什么的。最后还是鼓起勇气走了，一开始走的时候有点害怕，一篇漆黑，但是走到后面习惯了也就不那么怕了。</p>
<p>没有路灯的路走个半个小时应该就到了剑潭山看夜景最好的位置——老地方观景平台了，能够望见远处的101大楼和松山机场，晚上的景色十分美丽。</p>
<p>由于晚上手机照相的质量实在是太差了，照片可以参考<a href="http://hx271.pixnet.net/blog/post/61096888-%E3%80%90%E5%8F%B0%E5%8C%97%E5%8D%81%E5%A4%A7%E5%A4%9C%E6%99%AF%E3%80%91%E9%98%BF%E5%AE%8F%E9%81%94%E4%BA%BA%E7%B2%BE%E9%81%B8~%E5%A4%9C%E6%99%9A%E5%BF%85%E7%9C%8B%E7%9A%84" target="_blank" rel="external">这里</a></p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[台湾延时摄影集合]]></title>
      <url>/2017/11/21/%E5%8F%B0%E6%B9%BE%E5%BB%B6%E6%97%B6%E6%91%84%E5%BD%B1%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<p>我在台湾交换期间拍摄的延时摄影的集合，没有专业设备，大家看看就好</p>
<a id="more"></a>
<h2 id="捷运文湖线"><a href="#捷运文湖线" class="headerlink" title="捷运文湖线"></a>捷运文湖线</h2><p>因为文湖线的列车都是自动驾驶的，所以才能够有机会拍出这些片子</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/OYMoRU74TuA" frameborder="0" gesture="media" allowfullscreen></iframe>

<h2 id="高美湿地"><a href="#高美湿地" class="headerlink" title="高美湿地"></a>高美湿地</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/w2I4JOnycek" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe>

<h2 id="阿里山"><a href="#阿里山" class="headerlink" title="阿里山"></a>阿里山</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/8eSMokATgSA" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe>

<iframe width="560" height="315" src="https://www.youtube.com/embed/A_Kyl8niz6k" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe>

<h2 id="台北-官渡大桥"><a href="#台北-官渡大桥" class="headerlink" title="台北 官渡大桥"></a>台北 官渡大桥</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/lyk9iq5TAnc" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[台北捷运集章第一弹]]></title>
      <url>/2017/11/19/%E5%8F%B0%E5%8C%97%E6%8D%B7%E8%BF%90%E9%9B%86%E7%AB%A0%E7%AC%AC%E4%B8%80%E5%BC%B9/</url>
      <content type="html"><![CDATA[<p>这是我完成集齐捷运纪念章章计划第一天。</p>
<a id="more"></a>
<h2 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h2><p>先放一张台北整体的捷运图吧。<br><img src="https://data2.liuin.cn/story-writer/2017_11_12_1510496480309.jpg" alt="enter description here" title="台北捷运路线图"><br>计划一天完成线路：<br>永安市场（黄线）–&gt; 南势角（黄线）–&gt; 忠孝新生 –&gt; 顶埔（蓝线） –&gt; 南港展览馆 –&gt;  动物园（棕线） –&gt; 南京复兴 –&gt; 松山（绿线）–&gt; 新店（绿线） –&gt; 公馆（绿线）–&gt; 回家<br>将蓝线、棕线和绿线的所有捷运站的纪念章都集齐</p>
<p>实际完成的情况是这样的：<br>永安市场（黄线）–&gt; 南势角（黄线）–&gt; 忠孝新生 –&gt; 顶埔（蓝线） –&gt; 南港展览馆 –&gt; 南京复兴 –&gt; 松山（路线） –&gt; 大安森林公园（红线）–&gt; 回家<br>只完成了蓝线的集章任务</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG4.jpeg" alt="enter description here" title="出发"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG1-1.jpeg" alt="enter description here" title="捷运一日票"></p>
<h2 id="台北捷运“观光线”——棕线"><a href="#台北捷运“观光线”——棕线" class="headerlink" title="台北捷运“观光线”——棕线"></a>台北捷运“观光线”——棕线</h2><h2 id="大湖公园"><a href="#大湖公园" class="headerlink" title="大湖公园"></a>大湖公园</h2><p>今天一天中比较好玩的景点差不多都在棕线上，大湖公园本来不是计划游玩的景点，但是却花了一个小时在里面逛。主要是捷运一转弯就看到了这个非常美丽的湖，忍不住下去看两眼。<br> “大湖”旧名十四份埤（陂），因白鹭成群又称白鹭湖，采用中国园林式设计。其实这个湖的名气不是很大，只是台北的一个区域性公园。但是风景是相当的好，公园里面的小动物也挺多的，是一个踏青的好地方。</p>
<p> <img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG9.jpeg" alt="enter description here" title="大湖湖面"></p>
<p> <img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG11.jpeg" alt="enter description here" title="大湖风景"></p>
<h2 id="松山机场"><a href="#松山机场" class="headerlink" title="松山机场"></a>松山机场</h2><p>松山机场应该是台湾的第三大机场，仅次于桃园机场和高雄机场。是一个军民合用机场，民用部分为台北国际航空站，主要负责的是台晚本地的航线以及两岸航线，最远的也只是到韩国；军用部分为空军松山基地。<br>松山机场开放了一个观景平台供游客参观，在第一航厦和第二航厦之间。机场里面有明显的指示牌，非常容易找到。装饰非常棒，就是今天一直是阴雨天气，看到的是灰蒙蒙的一片，或许以后天气好的时候可以再来一次。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG10.jpeg" alt="enter description here" title="观景台指引"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG3.jpeg" alt="enter description here" title="台北国际航空站"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG5.jpeg" alt="enter description here" title="观景平台"></p>
<h2 id="饶河夜市"><a href="#饶河夜市" class="headerlink" title="饶河夜市"></a>饶河夜市</h2><p>来之前听说松山捷运站有一个花一千五百万新台币修建的叫“河流彎曲之處”的捷运艺术还不错，趁今天买了捷运一日票特地去看看。到了现场感受没有图片中那么好看，可能是图片修过吧。<br>饶河夜市就在松山捷运站的出口处，是台北一个比较有名的观光夜市。逛夜市就要找人多的地方，这次花了半个小时在两个地方吃了点东西，都非常好吃，一个是爆浆鸡翅另一个是进夜市口能够看到的福州世祖胡椒饼</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG7.jpeg" alt="enter description here" title="松山捷运站艺术"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG2.jpeg" alt="enter description here" title="饶河观光夜市"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG6.jpeg" alt="enter description here" title="福州世祖胡椒饼"></p>
<h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>这一天一共集章44块，台北的捷运站一共有117个。现在的进度是44/117，看来还要两次才能够完成台北捷运全制霸的计划。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG12.jpeg" alt="enter description here" title="成果"></p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git 停止追踪文件]]></title>
      <url>/2017/11/16/Git-%E5%81%9C%E6%AD%A2%E8%BF%BD%E8%B8%AA%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>平时在使用Git的时候，大多会有这种情况：因为在初始化git的时候没有考虑周全导致有些不需要的文件已经被被追踪，或者想不让在某次提交以后一些文件不被追踪（比如说一些涉及隐私的配置文件）。这里提供一些解决方案</p>
<a id="more"></a>
<h2 id="Git中忽略某些文件"><a href="#Git中忽略某些文件" class="headerlink" title="Git中忽略某些文件"></a>Git中忽略某些文件</h2><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p>在一开始git进行初始化的时候我们可以通过修改配置文件.gitignore来指定哪些文件是不需要被追踪的。<br>文件 .gitignore 的格式规范如下：</p>
<ul>
<li>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。(glob 模式是指 shell 所使用的简化了的正则表达式)</li>
<li>匹配模式最后跟反斜杠（/）说明要忽略的是目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li>
</ul>
<h3 id="快捷设置-gitignore"><a href="#快捷设置-gitignore" class="headerlink" title="快捷设置.gitignore"></a>快捷设置.gitignore</h3><p>一般我们在项目中会有超多不需要放到git上面的东西，但是一个一个加入到.gitignore中是非常麻烦的。可以使用gitignore.io提供的API快速创建<br>设置别名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global alias.ignore &apos;!gi() &#123; curl -L -s https://www.gitignore.io/api/$@ ; &#125;; gi&apos;</div></pre></td></tr></table></figure></p>
<p>这样以后创建项目的时候只需要结合你的开发环境通过关键进行快捷创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git ignore macOS &gt;&gt; .gitignore</div></pre></td></tr></table></figure></p>
<h2 id="忽略未追踪文件"><a href="#忽略未追踪文件" class="headerlink" title="忽略未追踪文件"></a>忽略未追踪文件</h2><p>在项目开发中可能会有一些新的不想追踪的文件生成，这个时候有两种处理方法：</p>
<ol>
<li>更新.gitignore 文件，这种操作能够使得其他人也忽略对这些文件的追踪</li>
<li>将忽略的文件加到项目文件夹中的 .git/Info/exclude文件中，这种操作只对本地起作用。</li>
</ol>
<h2 id="停止追踪某些文件"><a href="#停止追踪某些文件" class="headerlink" title="停止追踪某些文件"></a>停止追踪某些文件</h2><p>如果文件已经被git追踪，不想在后面的开发中提交这些文件的修改，这里有两个方案：</p>
<ol>
<li>删除文件以后再加到.gitignore 中，这种方案会使得原来那个可能有用的文件就丢失了。</li>
<li>使用<code>git update-index --assume-unchanged [filename]</code> 来忽略某些文件的修改, 这种修改只能再本地起作用，当别人使用这个项目的时候并不会起作用。</li>
<li>使用<code>git rm --cached filename</code>把文件从暂存里移除掉，之后的修改就不会追踪这些文件了。这种方案能够同步到远程，但是别人在拉取你的更新时也要消除对这些文件的追踪。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux中搭建FTP文件服务器]]></title>
      <url>/2017/11/12/Linux%E4%B8%AD%E6%90%AD%E5%BB%BAFTP%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>这篇文章对在Linux中使用VSFTPD部署FTP文件服务器做了一个简单的介绍。<br>使用的是VSFTPD，vsftpd 是“very secure FTP damon”的缩写，vsftpd的一个最大的特点是它的安全性。</p>
<a id="more"></a>
<h2 id="安装并启动FTP服务器"><a href="#安装并启动FTP服务器" class="headerlink" title="安装并启动FTP服务器"></a>安装并启动FTP服务器</h2><h3 id="安装VSFTPD"><a href="#安装VSFTPD" class="headerlink" title="安装VSFTPD"></a>安装VSFTPD</h3><p>使用 <code>apt-get</code> 安装 vsftpd：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install vsftpd -y</div></pre></td></tr></table></figure></p>
<p><code>-y</code> 参数表示对所有问题用yes来回答</p>
<h3 id="启动VSFTPD"><a href="#启动VSFTPD" class="headerlink" title="启动VSFTPD"></a>启动VSFTPD</h3><p>安装完成后 VSFTPD 会自动启动，通过 netstat 命令可以看到系统已经监听了 21 端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo netstat -nltp | grep 21</div></pre></td></tr></table></figure></p>
<p>如果没有启动，可以手动开启 VSFTPD 服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl start vsftpd.service</div></pre></td></tr></table></figure></p>
<h2 id="配置用户访问目录"><a href="#配置用户访问目录" class="headerlink" title="配置用户访问目录"></a>配置用户访问目录</h2><h3 id="新建用户主目录"><a href="#新建用户主目录" class="headerlink" title="新建用户主目录"></a>新建用户主目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo mkdir /home/uftp</div></pre></td></tr></table></figure>
<p>创建登录欢迎文件用来测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo touch /home/uftp/welcome.txt</div></pre></td></tr></table></figure></p>
<h3 id="新建用户-uftp-并设置密码"><a href="#新建用户-uftp-并设置密码" class="headerlink" title="新建用户 uftp 并设置密码"></a>新建用户 uftp 并设置密码</h3><p>创建一个用户 uftp :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo useradd -d /home/uftp -s /bin/bash uftp</div></pre></td></tr></table></figure></p>
<p>为用户 uftp 设置密码 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo passwd uftp</div></pre></td></tr></table></figure></p>
<p>删除掉 pam.d 中 vsftpd，因为该配置文件会导致使用用户名登录 ftp 失败：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo rm /etc/pam.d/vsftpd</div></pre></td></tr></table></figure></p>
<h3 id="限制该用户仅能通过-FTP-访问"><a href="#限制该用户仅能通过-FTP-访问" class="headerlink" title="限制该用户仅能通过 FTP 访问"></a>限制该用户仅能通过 FTP 访问</h3><p>限制用户 uftp 只能通过 FTP 访问服务器，而不能直接登录服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo usermod -s /sbin/nologin uftp</div></pre></td></tr></table></figure></p>
<h3 id="修改-vsftpd-配置"><a href="#修改-vsftpd-配置" class="headerlink" title="修改 vsftpd 配置"></a>修改 vsftpd 配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chmod a+w /etc/vsftpd.conf</div></pre></td></tr></table></figure>
<p>修改 /etc/vsftpd.conf 文件中的配置（直接将如下配置添加到配置文件最下方）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># 限制用户对主目录以外目录访问</div><div class="line">chroot_local_user=YES</div><div class="line"></div><div class="line"># 指定一个 userlist 存放允许访问 ftp 的用户列表</div><div class="line">userlist_deny=NO</div><div class="line">userlist_enable=YES</div><div class="line"></div><div class="line"># 记录允许访问 ftp 用户列表</div><div class="line">userlist_file=/etc/vsftpd.user_list</div><div class="line"></div><div class="line"># 不配置可能导致莫名的530问题</div><div class="line">seccomp_sandbox=NO</div><div class="line"></div><div class="line"># 允许文件上传</div><div class="line">write_enable=YES</div><div class="line"></div><div class="line"># 使用utf8编码</div><div class="line">utf8_filesystem=YES</div></pre></td></tr></table></figure></p>
<p>新建文件 /etc/vsftpd.user_list，用于存放允许访问 ftp 的用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo touch /etc/vsftpd.user_list</div><div class="line">sudo chmod a+w /etc/vsftpd.user_list</div></pre></td></tr></table></figure></p>
<p>修改 /etc/vsftpd.user_list ，加入刚刚创建的用户：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uftp</div></pre></td></tr></table></figure>
<h3 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a>设置访问权限</h3><p>设置主目录访问权限（只读）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chmod a-w /home/uftp</div></pre></td></tr></table></figure></p>
<p>新建公共目录，并设置权限（读写）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo mkdir /home/uftp/public &amp;&amp; sudo chmod 777 -R /home/uftp/public</div></pre></td></tr></table></figure></p>
<p>重启vsftpd 服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl restart vsftpd.service</div></pre></td></tr></table></figure></p>
<p>也可以多创建几个用户来实现对主目录的不同读写权限的管理</p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 结构解析]]></title>
      <url>/2017/11/09/Hexo-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>对Hexo 的配置文件夹进行分析。</p>
<a id="more"></a>
<h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><p>在hexo的主目录下有一下文件和文件夹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">├── _config.yml	    #站点配置文件</div><div class="line">├── db.json            #缓存文件</div><div class="line">├── debug.log       #hexo s --debug 产生的日志文件</div><div class="line">├── node_modules    #nodejs 本地包</div><div class="line">├── package.json    #nodejs 本地配置信息</div><div class="line">├── public               #生成的静态文件所在的文件夹</div><div class="line">├── scaffolds          #新生成page的模板</div><div class="line">├── source             #文章所在文件夹</div><div class="line">└── themes           #主题所在文件夹</div><div class="line"></div><div class="line">5 directories, 4 files</div></pre></td></tr></table></figure></p>
<h2 id="主题文件结构"><a href="#主题文件结构" class="headerlink" title="主题文件结构"></a>主题文件结构</h2><p>一个主题的大致结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── _config.yml   # 主题配置文件</div><div class="line">├── languages     #语言文件夹</div><div class="line">├── layout            # 布局文件夹。用于存放主题的模板文件，决定了网站内容的呈现方式</div><div class="line">├── scripts        # 脚本文件夹</div><div class="line">└── source       # 资源文件夹，除了模板以外的 Asset，例如 CSS、JavaScript 文件等，都应该放在这个文件夹中。</div></pre></td></tr></table></figure></p>
<h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><p>布局文件夹。用于存放主题的模板文件，决定了网站内容的呈现方式。Hexo 默认使用的Swig模板引擎。使用语法和Jinja2、Django模板引擎类似。</p>
<p>文件或文件夹开头名称为 _（下划线线）或隐藏的文件会被忽略。</p>
<p>每个模板都默认使用 layout 布局，实际对应的文件是_layout.swig 文件。下面是各个页面所对应的模板的名称：</p>
<table>
<thead>
<tr>
<th>模板</th>
<th>用途</th>
<th>回调</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>首页</td>
</tr>
<tr>
<td>post</td>
<td>文章</td>
<td>index</td>
</tr>
<tr>
<td>page</td>
<td>分页</td>
<td>index</td>
</tr>
<tr>
<td>archive</td>
<td>归档</td>
<td>index</td>
</tr>
<tr>
<td>category</td>
<td>分类归档</td>
<td>archive</td>
</tr>
<tr>
<td>tag</td>
<td>标签归档</td>
<td>archive</td>
</tr>
</tbody>
</table>
<p>局部模版（Partial）<br>局部模板让您在不同模板之间共享相同的组件，例如页首（Header）、页脚（Footer）或侧边栏（Sidebar）等，可利用局部模板功能分割为个别文件，让维护更加便利。</p>
<h3 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h3><p>只需要把 JavaScript 文件放到 scripts 文件夹，在启动时就会自动载入。</p>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux cd后追加ls]]></title>
      <url>/2017/11/04/Linux-cd%E5%90%8E%E8%BF%BD%E5%8A%A0ls/</url>
      <content type="html"><![CDATA[<p>不知道你们在使用命令行的时候有没有这种体验：就是每次到一个新的目录下就会追加一个命令ls看看该目录下面有什么。这里提供一个在cd后自动追加ls的解决方案。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>查看了一下经常使用的电脑的输入指令统计：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1	740  33.3634%    ls</div><div class="line">2	372  16.7719%    cd</div><div class="line">3	273  12.3084%    git</div><div class="line">4	177  7.98016%    vim</div></pre></td></tr></table></figure></p>
<p>发现排在前两位的是ls和cd，而且每次cd以后必然会ls一次。所以何必不把这两个东西合在一起呢。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在环境变量的配置文件（.zshrc或者.bashrc）中加入一小段脚本即可:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">cdl</span></span>()</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> [ -n <span class="variable">$1</span> ] ; <span class="keyword">then</span></div><div class="line">		<span class="built_in">cd</span> <span class="variable">$1</span></div><div class="line">		ls</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="built_in">cd</span></div><div class="line">		ls</div><div class="line">	<span class="keyword">fi</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">alias</span> <span class="built_in">cd</span>=cdl</div></pre></td></tr></table></figure></p>
<p>这段脚本应该都看得懂吧。</p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Bandit 通关题解]]></title>
      <url>/2017/11/01/Bandit-%E9%80%9A%E5%85%B3%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>Bandit 是一个适合学习Linux指令的游戏吧，规则是每一关利用提供的hostname:port和上一关的password（第一关提供password）通过ssh进入到给定的环境中，按照题目要求拿到指定的Key作为下一关的password。挺好玩的，目前尚未通关，在此挖个坑</p>
<a id="more"></a>
<p>网址：<a href="http://overthewire.org/wargames/bandit/" target="_blank" rel="external">http://overthewire.org/wargames/bandit/</a></p>
<p>通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh bandit0@bandit.labs.overthewire.org -p 2220</div></pre></td></tr></table></figure></p>
<p>开玩吧！</p>
<h2 id="Level-0-→-Level-1"><a href="#Level-0-→-Level-1" class="headerlink" title="Level 0 → Level 1"></a>Level 0 → Level 1</h2><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat readme</div></pre></td></tr></table></figure>
<h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><p>boJ9jbbUNNfktd78OOpsqOltutMc3MY1</p>
<h2 id="Level-1-→-Level-2"><a href="#Level-1-→-Level-2" class="headerlink" title="Level 1 → Level 2"></a>Level 1 → Level 2</h2><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>在Linux中含有特殊字符的文件名可能和shell的一些语法向冲突，比如这一道题目中的“-”，shell就认定其之后的内容为参数。所以我们要通过./-表示文件来消除这种歧义。</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat ./-</div></pre></td></tr></table></figure>
<h3 id="Key-1"><a href="#Key-1" class="headerlink" title="Key"></a>Key</h3><p>CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9</p>
<h2 id="Level-2-→-Level-3"><a href="#Level-2-→-Level-3" class="headerlink" title="Level 2 → Level 3"></a>Level 2 → Level 3</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>文件名中含有空格可以用反斜杠+空格表示</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat spaces\ in\ this\ filename</div></pre></td></tr></table></figure>
<h3 id="Key-2"><a href="#Key-2" class="headerlink" title="Key"></a>Key</h3><p>UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK</p>
<h2 id="Level-3-→-Level-4"><a href="#Level-3-→-Level-4" class="headerlink" title="Level 3 → Level 4"></a>Level 3 → Level 4</h2><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat inhere/.inhere</div></pre></td></tr></table></figure>
<h3 id="Key-3"><a href="#Key-3" class="headerlink" title="Key"></a>Key</h3><p>pIwrPrtPN36QITSp3EQaw936yaFoFgAB</p>
<h2 id="Level-4-→-Level-5"><a href="#Level-4-→-Level-5" class="headerlink" title="Level 4 → Level 5"></a>Level 4 → Level 5</h2><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>通过file 列出文件属性来查看那些文件是ASCII编码（人类可读的）</p>
<h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">cd inhere/</div><div class="line">file ./*</div><div class="line"></div><div class="line">./-file00: data</div><div class="line">./-file01: data</div><div class="line">./-file02: data</div><div class="line">./-file03: data</div><div class="line">./-file04: data</div><div class="line">./-file05: data</div><div class="line">./-file06: data</div><div class="line">./-file07: ASCII text</div><div class="line">./-file08: data</div><div class="line">./-file09: data</div><div class="line"></div><div class="line">cat ./-file07</div></pre></td></tr></table></figure>
<h3 id="Key-4"><a href="#Key-4" class="headerlink" title="Key"></a>Key</h3><p>koReBOKuIDDepwhWk7jZC0RTdopnAYKh</p>
<h2 id="Level-5-→-Level-6"><a href="#Level-5-→-Level-6" class="headerlink" title="Level 5 → Level 6"></a>Level 5 → Level 6</h2><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>和上一题一样通过文件属性进行查找，用到find指令，只需要通过文件大小就能够确定文件位置了</p>
<h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cd inhere/</div><div class="line">find . -size 1033c</div><div class="line"></div><div class="line">./maybehere07/.file2</div><div class="line"></div><div class="line">cat ./maybehere07/.file2</div></pre></td></tr></table></figure>
<h3 id="Key-5"><a href="#Key-5" class="headerlink" title="Key"></a>Key</h3><p>DXjZPULLxYr17uwoI01bNLQbtFemEgo7</p>
<h2 id="Level-6-→-Level-7"><a href="#Level-6-→-Level-7" class="headerlink" title="Level 6 → Level 7"></a>Level 6 → Level 7</h2><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>考察使用find指令查找文件，用到了-user、-group、-size参数。同时使用 /dev/null 来过滤多余的错误信息</p>
<h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">find / -user bandit7 -group bandit6 -size 33c 2&gt;/dev/null</div><div class="line"></div><div class="line">cat /var/lib/dpkg/info/bandit7.password</div></pre></td></tr></table></figure>
<h3 id="Key-6"><a href="#Key-6" class="headerlink" title="Key"></a>Key</h3><p>HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs</p>
<h2 id="Level-7-→-Level-8"><a href="#Level-7-→-Level-8" class="headerlink" title="Level 7 → Level 8"></a>Level 7 → Level 8</h2><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>使用grep指令在文件中查找指定字符串</p>
<h3 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep millionth ./data.txt</div></pre></td></tr></table></figure>
<h3 id="Key-7"><a href="#Key-7" class="headerlink" title="Key"></a>Key</h3><p>cvX2JJa4CFALtqS87jk27qwqGhBM9plV</p>
<h2 id="Level-8-→-Level-9"><a href="#Level-8-→-Level-9" class="headerlink" title="Level 8 → Level 9"></a>Level 8 → Level 9</h2><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><p>uniq 指令能够找出文件中相邻的重复的或者不重复的行，key是所给的文件中只出现一次的行，所以要先进行排序，然后再用uniq找出不重复的行</p>
<h3 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sort data.txt | uniq -u</div></pre></td></tr></table></figure>
<h3 id="Key-8"><a href="#Key-8" class="headerlink" title="Key"></a>Key</h3><p>UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR</p>
<h2 id="Level-9-→-Level-10"><a href="#Level-9-→-Level-10" class="headerlink" title="Level 9 → Level 10"></a>Level 9 → Level 10</h2><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><p>strings 指令能够找出所给文件中可以打印的字符串，然后再使用grep查找key所在的位置</p>
<h3 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strings data.txt | grep ==</div></pre></td></tr></table></figure>
<h3 id="Key-9"><a href="#Key-9" class="headerlink" title="Key"></a>Key</h3><p>truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk</p>
<h2 id="Level-10-→-Level-11"><a href="#Level-10-→-Level-11" class="headerlink" title="Level 10 → Level 11"></a>Level 10 → Level 11</h2><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><p>使用base64指令对以base64编码的文本进行解码</p>
<h3 id="Code-10"><a href="#Code-10" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat data.txt | base64 --decode</div></pre></td></tr></table></figure>
<h3 id="Key-10"><a href="#Key-10" class="headerlink" title="Key"></a>Key</h3><p>IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR</p>
<h2 id="Level-11-→-Level-12"><a href="#Level-11-→-Level-12" class="headerlink" title="Level 11 → Level 12"></a>Level 11 → Level 12</h2><h3 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h3><p>所给的文本中的字符都被旋转了13个位置，所以我们使用tr命令将这些字符全部旋转回来</p>
<h3 id="Code-11"><a href="#Code-11" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat data.txt | tr &apos;A-Za-z&apos; &apos;N-ZA-Mn-za-m&apos;</div></pre></td></tr></table></figure>
<h3 id="Key-11"><a href="#Key-11" class="headerlink" title="Key"></a>Key</h3><p>5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu</p>
<h2 id="Level-12-→-Level-13"><a href="#Level-12-→-Level-13" class="headerlink" title="Level 12 → Level 13"></a>Level 12 → Level 13</h2><h3 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h3><p>所给的文件是一个经过多重压缩以后的二进制文件，首先使用xxd指令将二进制文件进行反转。然后不断使用file指令得到文件信息再调用相应的解压缩指令进行解压缩。其中用到的压缩指令有：gzip、bzip2、tar </p>
<h3 id="Code-12"><a href="#Code-12" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">xxd -r data.txt data2</div><div class="line">file data2</div><div class="line">data2: gzip compressed data, was &quot;data2.bin&quot;, from Unix, last modified: Thu Jun 6 13:59:44 2013, max compression</div><div class="line">mv data2 data.gz</div><div class="line">gzip -d data.gz</div><div class="line">file data</div><div class="line">data: bzip2 compressed data, block size = 900k</div><div class="line">bzip2 -d data</div><div class="line">bzip2: Can&apos;t guess original name for data -- using data.out</div><div class="line">file data.out</div><div class="line">data.out: gzip compressed data, was &quot;data4.bin&quot;, from Unix, last modified: Thu Jun 6 13:59:43 2013, max compression</div><div class="line">zcat data.out &gt; data3</div><div class="line">file data3</div><div class="line">data3: POSIX tar archive (GNU)</div><div class="line">tar -xvf data3</div><div class="line">data5.bin</div><div class="line">file data5.bin</div><div class="line">data5.bin: POSIX tar archive (GNU)</div><div class="line">tar -xvf data5.bin</div><div class="line">data6.bin</div><div class="line">file data6.bin</div><div class="line">bzip2 -d data6.bin</div><div class="line">bzip2: Can&apos;t guess original name for data6.bin -- using data6.bin.out</div><div class="line">file data6.bin.out</div><div class="line">data6.bin.out: POSIX tar archive (GNU)</div><div class="line">tar -xvf data6.bin.out</div><div class="line">data8.bin</div><div class="line">file data8.bin</div><div class="line">data8.bin: gzip compressed data, was &quot;data9.bin&quot;, from Unix, last modified: Thu Jun  6 13:59:43 2013, max compression</div><div class="line">zcat data8.bin &gt; data9.bin</div><div class="line">file data9.bin</div><div class="line">data9.bin: ASCII text</div><div class="line">cat data9.bin</div><div class="line">8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL</div></pre></td></tr></table></figure>
<h3 id="Key-12"><a href="#Key-12" class="headerlink" title="Key"></a>Key</h3><p>8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL</p>
<h2 id="Level-13-→-Level-14"><a href="#Level-13-→-Level-14" class="headerlink" title="Level 13 → Level 14"></a>Level 13 → Level 14</h2><h3 id="Solution-11"><a href="#Solution-11" class="headerlink" title="Solution"></a>Solution</h3><p>给出的是bandit14的私钥，要求使用这个私钥登录bandit14获取Key，这里用到了ssh -i 指令</p>
<h3 id="Code-13"><a href="#Code-13" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /etc/bandit_pass/bandit14</div><div class="line">ssh -i sshkey.private bandit14@localhost</div><div class="line">cat /etc/bandit_pass/bandit14</div></pre></td></tr></table></figure>
<h3 id="Key-13"><a href="#Key-13" class="headerlink" title="Key"></a>Key</h3><p>4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e</p>
<p>#Bandit Level 14 → Level 15</p>
<h3 id="Solution-12"><a href="#Solution-12" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Code-14"><a href="#Code-14" class="headerlink" title="Code"></a>Code</h3><h3 id="Key-14"><a href="#Key-14" class="headerlink" title="Key"></a>Key</h3>]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux中 ps 配合 kill 的操作]]></title>
      <url>/2017/10/25/Linux%E4%B8%AD-ps-%E9%85%8D%E5%90%88-kill-%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>有的时候我们想要关掉一些程序的一系列进程，又不想一个一个通过ps找到pid，再一个一个kill这些进程，这个时候用ps配合kill就是最好的选择了。</p>
<a id="more"></a>
<h2 id="使用到的命令"><a href="#使用到的命令" class="headerlink" title="使用到的命令"></a>使用到的命令</h2><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>ps(process status)命令用来列出系统中当前运行的那些进程。常常使用的形式有：</p>
<ul>
<li>ps aux 列出目前所有的正在内存当中的程序</li>
<li>ps -ef 显示所有进程信息，连同命令行<br><a href="http://www.cnblogs.com/peida/archive/2012/12/19/2824418.html" target="_blank" rel="external">更多参考</a>]</li>
</ul>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>kill 命令能够发送指定的信号到相应进程。</p>
<p>命令参数如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-l</td>
<td>信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称</td>
</tr>
<tr>
<td style="text-align:center">-a</td>
<td>当处理当前进程时，不限制命令名和进程号的对应关系</td>
</tr>
<tr>
<td style="text-align:center">-p</td>
<td>指定kill 命令只打印相关进程的进程号，而不发送任何信号</td>
</tr>
<tr>
<td style="text-align:center">-s</td>
<td>指定发送信号</td>
</tr>
<tr>
<td style="text-align:center">-u</td>
<td>指定用户</td>
</tr>
</tbody>
</table>
<p>使用参数-s 指定发送信号。如果要无条件终止进程，就要发送第九种信号SIGKILL。以下是常用的信号：</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>表示</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>HUP</td>
<td>1</td>
<td>终端断线</td>
</tr>
<tr>
<td>INT</td>
<td>2</td>
<td>中断（同 Ctrl + C）</td>
</tr>
<tr>
<td>QUIT</td>
<td>3</td>
<td>退出（同 Ctrl + \）</td>
</tr>
<tr>
<td>TERM</td>
<td>15</td>
<td>终止</td>
</tr>
<tr>
<td>KILL</td>
<td>9</td>
<td>强制终止</td>
</tr>
<tr>
<td>CONT</td>
<td>18</td>
<td>继续（与STOP相反， fg/bg命令）</td>
</tr>
<tr>
<td>STOP</td>
<td>19</td>
<td>暂停（同 Ctrl + Z）</td>
</tr>
</tbody>
</table>
<p><a href="http://www.cnblogs.com/peida/archive/2012/12/20/2825837.html" target="_blank" rel="external">更多参考</a></p>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>grep 是一种强大的文本搜索工具。grep 也是一个管道命令，接受standard output 作为查找的文本。不作为管道命令的时候后面接文件名作为参数。</p>
<h3 id="pgrep"><a href="#pgrep" class="headerlink" title="pgrep"></a>pgrep</h3><p>pgrep程序检查在系统的中活动进程，报告进程属性匹配命令行上指定条件的进程的ID。相当于命令 ps aux | grep XXX<br><a href="http://www.ha97.com/2523.html" target="_blank" rel="external">更多参考</a></p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -ef | grep chrome | grep -v grep | cut -c 10-14 | xargs kill -s 9</div></pre></td></tr></table></figure>
<ul>
<li>” grep chrome “输出所有含有关键字“chrome”的进程信息</li>
<li>” grep -v grep “ 除去含有关键字”grep“的进程信息，因为grep会产生一个进程里面含有 chrome 关键字</li>
<li>” cut -c 10-14 “ 截取输入行的第9个字符到第15个字符，而这正好是进程号PID</li>
<li>” xargs kill -s 9 “ 终止相关进程</li>
</ul>
<h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -ef | grep chrome | awk &apos;&#123;print $2&#125;&apos; | xargs kill -9</div></pre></td></tr></table></figure>
<ul>
<li>“awk ‘awk{ print $2 }’ “使用awk 代替cut ，不用一个一个数PID在什么位置</li>
</ul>
<h3 id="方案3"><a href="#方案3" class="headerlink" title="方案3"></a>方案3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pgrep chrome | xargs kill -s 9</div></pre></td></tr></table></figure>
<ul>
<li>” pgrep chrome “列出含有关键字”chrome“的相关进程</li>
<li>” xargs kill -s 9 “ 终止相关进程</li>
</ul>
<h3 id="方案4"><a href="#方案4" class="headerlink" title="方案4"></a>方案4</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">killall -9 chrome</div></pre></td></tr></table></figure>
<ul>
<li>终止进程名为chrome的进程，注意要给进程的全名</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[花莲之旅]]></title>
      <url>/2017/10/20/%E8%8A%B1%E8%8E%B2%E4%B9%8B%E6%97%85/</url>
      <content type="html"><![CDATA[<p>距离从花莲回来差不多有一个星期了，心态也逐渐调整过来了，现在也能够静下心来记录这一路的所见所想。花莲的确是一座非常美的城市，一座有故事的城市。<br><a id="more"></a></p>
<h2 id="行程规划"><a href="#行程规划" class="headerlink" title="行程规划"></a>行程规划</h2><p>我们行程是安排在台湾这边的联假（就是台湾这边的国庆），所以火车票和民宿都非常紧张。我们没有买到火车坐票，最后只能够采用买客运和铁路的联票到花莲（坐客运到罗东，再坐区间车到花莲）。车程还算比较长，总共四天假可能我们花在路上的时间就占了大半天吧。到花莲基本上是订民宿，这边的民宿做得口碑都比较好，大部分民宿都是来了以后都会推荐给朋友来的那种（事实证明我们住的民宿也是）。<br>我们大致的行程安排是第一天在花东纵谷线上玩鲤鱼潭和复兴糖厂，第二天清水断崖-太鲁阁-七星潭，第三天滑翔-几米公园，第四天兰阳博物馆+礁溪温泉公园。因为花莲这一带的景点都是分布在比较狭长的区域内，所以最好的交通工具就是包车出游。我们也是吃了这个亏，第一天下午在交通上面花了非常多的时间导致只玩了一个景点。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_WechatIMG13.jpeg" alt="enter description here" title="花连狭长的景点分布"></p>
<h2 id="鲤鱼潭"><a href="#鲤鱼潭" class="headerlink" title="鲤鱼潭"></a>鲤鱼潭</h2><p>从花莲火车站到鲤鱼潭大概二十多分钟的车程，我们去的时候天下着小雨，计程车行驶在盘旋的山路上别有一番意境。<br>“鲤鱼潭”的得名说法有二：一是因为侧边山岳形似鲤鱼，故山与湖同齐名为鲤鱼，有“鲤鱼山上有鲤鱼，鲤鱼潭里水中游。”俚语的称呼。另一种说法源于最早活动于此处的台湾原住民太鲁阁族，因为登至山顶往下看，潭的形状就像是一只刚捕获的鲤鱼在跳跃，所以以此名之。<br>鲤鱼潭周围的风光的确还不错，挺适合骑自行车慢慢玩的，但是天杀的我们去的那天下雨，没办法我们只能够等中间雨停的时候租条脚踏船玩完。<br>鲤鱼潭风光还是不错的，同行的一直在华北平原的小伙伴对这样的山还是蛮有好感的。但是对于我这种在雪峰山脉长大的孩子来说我还是觉得没有什么特色，不怎么推荐。<br>后面因为我们没有赶上公交车，多等了一个小时，到达复兴糖厂的时候差不多商家都打烊了，唯一一个能够玩的文物馆也已经关门了。不过在复兴糖厂吃到感觉有生以来最好吃的烤肠，烤肠里面有些许的酒味，还是挺满足的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_WechatIMG10.jpeg" alt="enter description here" title="鲤鱼潭"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_WechatIMG9.jpeg" alt="enter description here" title="鲤鱼潭潭面"></p>
<h2 id="超赞的民宿"><a href="#超赞的民宿" class="headerlink" title="超赞的民宿"></a>超赞的民宿</h2><p>在复兴糖厂完了一小会，我们就急忙赶到到复兴车站坐区间车去民宿了。其实之前对这个民宿有很大的期待的，因为介绍里说地址在海边而且有一间房是海景房。<br>来到民宿以后老板张阿姨很热情地接待我们，民宿老板之前是幼儿园的园长现在退休了。她给我们讲了他的民宿名字——花莲你来 的来历还有她同学为她的民宿写的歌。这个民宿其实是张阿姨为了能让她父亲更好地看海而建的，为了方便她父亲能够去顶楼看海还特别修建了电梯（整个房子只有7楼）。<br>进到房间以后感觉真的是超赞，装修非常精致，特别是阳台的装扮。整个阳台是面朝大海的，面积比较大，铺了草坪种了树，布置得很好。特别是阳台旁边的透明玻璃栏杆，刚看的时候给人的视觉冲击非常大。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_WechatIMG7.jpeg" alt="enter description here" title="从民宿看到的海边"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_WechatIMG8.jpeg" alt="enter description here" title="为民宿写的歌"></p>
<h2 id="清水断崖-太鲁阁-七星潭"><a href="#清水断崖-太鲁阁-七星潭" class="headerlink" title="清水断崖-太鲁阁-七星潭"></a>清水断崖-太鲁阁-七星潭</h2><p>第二天我们是包车前往太鲁阁那一片景点的，司机是一个叫阿靖的小伙，一路为我们讲解各个景点以及他们背后的故事。<br>清水断崖是来花莲必去的景点，台湾八景之一。一边是几近垂直、陡峭壁立的山壁，一遍是蓝蓝的大海，景色不要太美。不说了，上图吧。。。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_WechatIMG6.jpeg" alt="enter description here" title="清水断崖"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_WechatIMG5.jpeg" alt="enter description here" title="石头和狗"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_WechatIMG3.jpeg" alt="enter description here" title="太鲁阁"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_WechatIMG4.jpeg" alt="enter description here" title="七星潭的海-1"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_WechatIMG2.jpeg" alt="enter description here" title="七星潭的海-2"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_%E6%9C%80%E5%90%8E%E6%9D%A5%E4%B8%80%E5%BC%A0%E8%83%8C%E5%BD%B1.jpeg" alt="enter description here" title="最后来一张背影"></p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[十分九份一日游]]></title>
      <url>/2017/09/25/%E5%8D%81%E5%88%86%E4%B9%9D%E4%BB%BD%E4%B8%80%E6%97%A5%E6%B8%B8/</url>
      <content type="html"><![CDATA[<p>还记得《那些年，我们一起追的女孩》里面柯景腾和沈佳宜一起走铁道，放天灯的场景吗？那里面的场景就是在十分附近拍摄的，第二周我选择来这里浪，顺便拜访旁边传说《千与千寻》的取景地——九份</p>
<a id="more"></a>
<h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><p>我们大致的行程是从台北车站随便坐一辆区间车能够到瑞芳，然后转平溪线到十分。在十分玩完十分瀑布和十分老街之后，坐平溪线回到瑞芳，然后再坐公交车去九份。<br>这也是我第一次体验台湾的火车，感受到这边的铁路跟大陆那边还是一些不同的： 这边有一种区间车，运营就像国内的地铁（车内长得也像地铁）。买票的时候只要选择起点站和终点站，然后进站以后可以随便上一辆区间车到达目的地。普通车的站票也是这样。<br>顺便吐槽一句：铁路订票系统做得太烂了，页面UI差就算了，还查不了余票，必须要把所有的信息输进去验证以后才能够得到订票失败的提示。。。</p>
<p>车内长得像地铁的区间车：</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_25_QQ20170925-0.jpg" alt="enter description here"></p>
<h2 id="十分老街"><a href="#十分老街" class="headerlink" title="十分老街"></a>十分老街</h2><p>从十分车站出来以后就是十分老街了，整个十分老街是在火车铁轨两旁，算是有一点特色。两边的店铺主要经营的是小吃、纪念品还有天灯。旁边有个静安吊桥，也有许多人在那拍照。铁轨上许多人在放天灯，不过大多数都是韩国人日本人。</p>
<p>十分车站</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_25_QQ20170925-0-3.jpg" alt="enter description here"></p>
<p>放天灯的游客</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_25_QQ20170925-0-1.jpg" alt="enter description here"></p>
<h2 id="十分瀑布"><a href="#十分瀑布" class="headerlink" title="十分瀑布"></a>十分瀑布</h2><p>十分老街不是很长，如果不吃什么东西的话，一会就逛完了。走到老街的尽头就可以看到有很多租电动车的店铺，主要提供给去十分瀑布的游客。价格不算贵，一般是一个小时一百新台币。<br>我们两人小分队也租了一辆小电动，说实话骑着电动在山间穿梭还是蛮爽的，就是距离能够再长一点就好了。从老街到瀑布只用了十分钟左右。<br>十分瀑布景色还行，旁边有一道彩虹。</p>
<p>十分瀑布</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_25_QQ20170925-0-2.jpg" alt="enter description here"></p>
<h2 id="九份"><a href="#九份" class="headerlink" title="九份"></a>九份</h2><p>九份是一座坐落在台湾东北部的小城，三面环山，一面临海。整个小镇座落于山坡地上，也因此形成了独特的山坡和阶梯式建筑景观。早期因为开采金矿而闻名，后面慢慢没落。1990年代后，因电影《悲情城市》于九份取景，九份的独特旧式建筑、坡地及风情透过此片吸引国内外的注目，使得来九份的人越来越多。</p>
<p>依山而建的九份小城</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_25_QQ20170925-0-4.jpg" alt="enter description here"></p>
<p>阿妹茶楼</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_25_QQ20170925-0-5.jpg" alt="enter description here"></p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[打卡台北101]]></title>
      <url>/2017/09/17/%E6%89%93%E5%8D%A1%E5%8F%B0%E5%8C%97101/</url>
      <content type="html"><![CDATA[<p>台北101是台湾的第一高楼，也曾经有五年多的时间是世界第一高楼，旁边紧邻着台北市政府。现在是世界第十高楼（七年时间从第一变成第十），也是很多有名的跨国公司（比如说Google）的在台湾地区的办公地。</p>
<a id="more"></a>
<h2 id="交通与门票"><a href="#交通与门票" class="headerlink" title="交通与门票"></a>交通与门票</h2><p>台北101大楼位于台北市信义区，紧邻台北市政府大楼，是台北市的新地标。离101比较近的捷运站有市政府站和101站，坐捷运到这两个捷运站去101都可以。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_17_1505628281374.jpg" alt="enter description here"></p>
<p>我的话因为是游玩完上一个景点才去的，远处看起来比较近，所以我和我的小伙伴就选择了脚踏车作为交通工具。因为101实在是太高了，看着不远，但是实际骑起来还真是有点距离的。</p>
<p>到达101脚下</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_17_QQ20170917-0.jpg" alt="到达101脚下"></p>
<p>上观景台参观的门票在5F卖，有两种：一种是全票600NTD；另外一种是优惠票540NTD，学生还有台湾地区的军警能够购买。我们买的是优惠票，使用支付宝支付，差不多花了120人民币。</p>
<h2 id="夕阳"><a href="#夕阳" class="headerlink" title="夕阳"></a>夕阳</h2><p>上面供游客玩的地方就三层：88F、89F和91F。88F展示的是全球第二大的开放游客观赏的巨型阻尼器；89F是一个环形的带玻璃的观景平台，还想着能够有那种伸出空中全是玻璃的刺激的地方，结果没有；91F是一个露天的观景平台，只不过只开放一小部分区域，还有特别高的栅栏。比较欣慰的是，栅栏的间隙不是很小，手可以伸出去拍照。</p>
<p>我们上去的时间是下午五点到五点半的场次，刚好是黄昏的时候，从观景平台俯瞰下面，有种玩天际线（模拟城市类的游戏）的既视感。感觉特别爽。</p>
<p>从101俯瞰台北</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_17_WechatIMG11.jpeg" alt="从101俯瞰台北"></p>
<p>101上的黄昏</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_17_WechatIMG12.jpeg" alt="101上的黄昏"></p>
<h2 id="夜景"><a href="#夜景" class="headerlink" title="夜景"></a>夜景</h2><p>本着不浪费这120门票的原则，我们硬是在上面待到了晚上。其实上面还是有很多东西可以逛的，纪念品商店有很多东西可以看看；有邮箱可以寄明信片。随便逛逛天就黑了。</p>
<p>晚上在101看到的又是另一番景色了，很赞。</p>
<p>俯瞰夜景（手机拍出来的效果实在是太差了，还是用同学的图吧）</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_17_WechatIMG2.jpeg" alt="enter description here"></p>
<h2 id="象山上看到的101"><a href="#象山上看到的101" class="headerlink" title="象山上看到的101"></a>象山上看到的101</h2><p>下来以后差不多是8点，感觉还早，就跑到旁边的象山区浪了，因为那里可以看到晚上的101外景。一开始一位晚上没什么人，结果上登山道的时候有点吃惊，原来这么多人都在晚上爬象山。</p>
<p>其实象山蛮大的，我们没有爬到山顶，只爬到了半山腰的一个摄影平台（一天奔波实在是有点累了）。</p>
<p>101外景（同学的图）</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_17_WechatIMG9.jpeg" alt="101外景"></p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[淡水 一日游]]></title>
      <url>/2017/09/11/%E6%B7%A1%E6%B0%B4-%E4%B8%80%E6%97%A5%E6%B8%B8/</url>
      <content type="html"><![CDATA[<p>淡水是台湾北部比较有名的一个景点，被称为<a href="https://zh.wikipedia.org/wiki/%E5%8F%B0%E7%81%A3%E5%85%AB%E6%99%AF" target="_blank" rel="external">台湾八景</a>。在历史上曾经是台湾第一大港，也是西方文明在台湾北部散播的起点。</p>
<a id="more"></a>
<h2 id="淡水老街"><a href="#淡水老街" class="headerlink" title="淡水老街"></a>淡水老街</h2><p>从淡水捷运站出来以后走不久就是淡水老街了，这里集美食、小吃、老街为一身，近年来更因不少古董店及民艺品店进驻，营造出更浓郁的民俗色彩与怀旧风味。邻近淡水捷运站，应该是游客到这里来必游的景点，人比较多。</p>
<p>在淡水老街上尝了一些小吃：鐵蛋、酸梅湯，鐵蛋很硬，酸梅汤很正宗</p>
<p>淡水街头</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_11_QQ20170911-0.jpg" alt=""></p>
<h2 id="阿给"><a href="#阿给" class="headerlink" title="阿给"></a>阿给</h2><p>阿给可以说是淡水最有名的小吃了。为什么叫“阿给”呢？其实它是日本语“油炸豆腐皮”的音译简称。阿给的做法是将油豆腐的中间挖空，然后填充炒过的冬粉（有些店家使用的是没有炒过的冬粉）、浸泡过卤汁，以鱼浆封口，加以蒸熟，食用前淋上甜辣酱或其他特殊酱汁。</p>
<p>我们逛到阿给的小吃店的时候刚好是中午午餐的时候，还是蛮好吃的，唯一不足的地方就是中午的气温有点高吃起来非常热。</p>
<p>网上的阿给图片</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_11_1024px-Agei.JPG" alt=""></p>
<h2 id="淡江中学"><a href="#淡江中学" class="headerlink" title="淡江中学"></a>淡江中学</h2><p>淡水中学中学是周杰伦还有前台湾地区领导人李登辉的母校，也因为周杰伦的《不能说的秘密》，而被众人所知（怪不得同行的女生听到淡水中学这么兴奋）。这所学校全名私立淡江高级中学，是台湾省比较著名的中学，已经有近100年的历史了。台湾这边公立的中学叫国民高中（国中），旁边的淡水国中就是的。门口贴着不允许参观的标志，但是可能是我们来的时候是周末，门卫放我们进去了。进去以后看到台湾这边的高三学生也补课（按理说他们读大学的压力比大陆小很多），看来高三逃脱不了补课的命运。</p>
<p>淡水中学历史比较久，所以里面的建筑还是很有特色的。</p>
<p>淡江高级中学埔顶钟声</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_11_QQ20170911-0-1.jpg" alt=""></p>
<h2 id="真理大学"><a href="#真理大学" class="headerlink" title="真理大学"></a>真理大学</h2><p>真理大学为北部台湾基督长老教会所创办之大学，是一所历史渊远的私立大学。以“追求真理、爱与服务”为校务发展宗旨。源自1872年3月9日加拿大基督长老教会宣教师马偕登陆淡水，选定现址（今真理大学淡水校区）兴建校舍以作传道、教育及医疗之用。</p>
<p>校园里面游客比较多，建筑比较有特色的就是旁边的大礼拜堂。校园风景非常优美，建筑物主要以红色为主。刚进去的时候能够看到许多的鸽子，它们不怎么怕游客，可能是习惯了吧。也有很多游客给一些事物给他们吃。</p>
<p>真理大学大门</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_11_QQ20170911-0-2.jpg" alt=""></p>
<h2 id="红毛城"><a href="#红毛城" class="headerlink" title="红毛城"></a>红毛城</h2><p>红毛城，西班牙人1692年建造，荷兰人打败西班牙人占领此城。为啥叫红毛城呢，以前咱管俄国人叫“老毛子、白毛”，称荷兰人为“红毛”，因此得名。里面的东西感觉也没什么特点就是一些那个时候办公用的东西。</p>
<p>不过这里要说的是台湾在景点上面对学生的优惠力度还是很大的，一般的景点只要你凭学生证就不要门票，在淡水两个景点要收费，小白宫和这个红毛城，一个地方80新台币，想想赚了160新台币心里还是美滋滋的。</p>
<p>红毛城照片</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_11_QQ20170911-0-3.jpg" alt=""></p>
<h2 id="渔人码头-情人桥"><a href="#渔人码头-情人桥" class="headerlink" title="渔人码头/情人桥"></a>渔人码头/情人桥</h2><p>淡水的最后一个景点就是渔人码头了，位于淡水河出海口右岸。《命中注定我爱你》陈欣怡和纪存希生日那天，纪存希陪陈欣怡买船回姜母岛吃姜军包，纪念品号停靠那个码头哦，就是渔人码头，后面就是情人桥。</p>
<p>传说情人桥暗藏“玄机”，恋人来此，如果没有走过情人桥，可能很快就会分手，如果只走过了奇数，而不是偶数，也会分手。由于那天太阳比较大，所以情人桥也没有待太久，不然真的会被热化的。</p>
<p>情人桥（同学的照片）：</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_11_QQ20170911-0-4.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>淡水还是一个景色优美，有好吃的好玩的，能看海的好去处。趁手里还在台湾而且有学生证，赶紧多玩几个景点。</p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[台湾，我来了]]></title>
      <url>/2017/09/07/%E5%8F%B0%E6%B9%BE%EF%BC%8C%E6%88%91%E6%9D%A5%E4%BA%86/</url>
      <content type="html"><![CDATA[<p>期待了许久，终于等到了去台湾的日子。9.5从上海出发，乘坐吉祥航空飞台北。正式开始我131天的台湾交换之旅。</p>
<a id="more"></a>
<h2 id="台湾初感受"><a href="#台湾初感受" class="headerlink" title="台湾初感受"></a>台湾初感受</h2><p>飞机刚降落，开了数据流量以后马上用Google 随便搜了点东西，直连谷歌，哈哈，肉身翻墙就是爽。<br>抵达桃园机场后，找到了台科大接机的同学把我们送到了台科大。然后我们就去找我们租房子的地方了，我们租房子的地方位于新北市，但是学校是在台北市，中间隔着一条河，坐公交应该是20分钟左右。看来在宣区从寝室到教室5分钟搞定的事情成了一种奢望。<br>在找租房子的地址的时候，感觉台湾各种小巷子太多了、红路灯太多了、机车太多了、便利店太多了。</p>
<p>从地图可以出道路基本上都是这种小巷子:</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_7_1504772211813.jpg" alt="从地图可以出道路基本上都是这种小巷子"></p>
<p>之前一直听说台湾这边的人非常热情，来到这里以后真的是深刻体会到了。在路上问路他们一定会说得非常详细，居委会的阿姨看到我们来了以后跟我们说了一大堆东西，这种感觉真好。</p>
<p>大陆和台湾的一些用词习惯是不一样的，比如我们的网络他们叫网路，计算机专业他们一般叫资讯工程。有几次去便利店买东西，店员听了我说的东西以后都是一脸懵逼，要我详细解释这个东西是用来干什么的，他们才清楚。看来还得慢慢适应。</p>
<h2 id="机车"><a href="#机车" class="headerlink" title="机车"></a>机车</h2><p>台湾这边的机车就是一般大陆说的摩托车，说真的这边的机车真的不要太多。过红绿灯的时候，机车引擎的声音那叫一个大呀，特别是在刚刚转绿灯的时候堪比赛车比赛开始的场面。</p>
<p>台湾的机车为什么这么多呢？原因应该是多方面的，人口多、道路窄是一个方面的原因。在台北，骑机车的大多是在市区周围上班族（就像我住的地方一样），把机车作为一种通勤工具，相比地铁公交的拥挤，开车要找车位开销大，骑机车成为了这些人的首选。当然还有一个更重要的原因就是台湾这边不禁摩，如果北上广深也不禁摩，可能机车的规模比台北还要多。</p>
<p>台湾街头的机车大军:</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_7_1504773955984.jpg" alt="台湾街头的机车大军"></p>
<h2 id="next"><a href="#next" class="headerlink" title="next"></a>next</h2><p>接下来希望自己能够好好把握好台湾交换的时间，博客中的台湾游记系列也要定时进行更新。加油吧！</p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PyCharm 使用技巧汇总]]></title>
      <url>/2017/09/03/PyCharm-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<p>俗话说的好，磨刀不误砍柴工，写代码也一样，在工具上面花的时间是非常值得的。对于Python语言的编程而言，Pycharm是一个非常好用的集成开发环境，虽然Vim能够做到轻巧，但是功能始终是做不到IDE那么强大，所以对于Python代码的编程后期还是主要以Pycharm为工具，今天在这里收集一些Pycharm的使用技巧，有一些来源于网上，有一些也来源本身Pycharm的教程。（以下技巧适用于macOS系统）</p>
<a id="more"></a>
<h2 id="教程中的快捷键"><a href="#教程中的快捷键" class="headerlink" title="教程中的快捷键"></a>教程中的快捷键</h2><ul>
<li>“⇧⌘O ”能够快速查找相关文件和类</li>
<li>Command+B 跳转到原码，看到里面的类和方法</li>
<li>Command+Option+L  一键实现PEP8规范</li>
<li>Command + Shift + O  查找文件、类和方法</li>
<li>Command + Option + Shift + [     光标放在函数的前面快速选中这个函数中的所有内容</li>
<li>Command + J   快速插入常用代码</li>
<li>Command + Shift + -    展开收缩你的代码块</li>
<li>Command+P  显示当前函数需要的参数</li>
<li>F1     可以调出光标处函数文档</li>
</ul>
<h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><ul>
<li>能够在下面的状态栏中看到当前使用换行符情况（是”\r\n”  “\n”  还是”\r”），多选文件在File | Line Separators 中选择适当的换行符就可以切换了</li>
<li>在Preference -&gt; Editor -&gt; File and Code Template 中设置代码模板</li>
</ul>
<h2 id="分屏操作"><a href="#分屏操作" class="headerlink" title="分屏操作"></a>分屏操作</h2><p>鼠标放到当前导航处的文件名，然后右键 Split Vertically 或者 Split Horizontally 就可以啦<br><img src="https://data2.liuin.cn/story-writer/2017_11_28_11%E6%9C%88-28-2017%2003-26-43.gif" alt="enter description here" title="分屏操作"></p>
<h2 id="添加Vim插件"><a href="#添加Vim插件" class="headerlink" title="添加Vim插件"></a>添加Vim插件</h2><p>在偏好设置里面Plugins中添加新的Plugin插件，搜索IdeaVIm添加就可以了</p>
]]></content>
      
        <categories>
            
            <category> 软件使用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SQLAchemy 学习(2)]]></title>
      <url>/2017/08/30/SQLAchemy-%E5%AD%A6%E4%B9%A0-2/</url>
      <content type="html"><![CDATA[<p>接着上一篇SQLAlchemy学习<br><a id="more"></a></p>
<h2 id="relationship"><a href="#relationship" class="headerlink" title="relationship"></a>relationship</h2><p>relationship函数是sqlalchemy对关系之间提供的一种便利的调用方式, backref参数则对关系提供反向引用的声明<br>通过relationship我们可以轻松在实现嵌套将一个实例的属性转换成另一个类的实例。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_addresses_from_user</span><span class="params">(user_name)</span>:</span></div><div class="line">    user = session.query(User).filter_by(name=user_name).first()</div><div class="line">    <span class="keyword">return</span> user.addresses   <span class="comment">#返回的是Adresses的一个对象</span></div></pre></td></tr></table></figure></p>
<p>back_populates参数和backref参数功能类似，只是前者提供单向的关系引用，且必须成对存在，但是完成的功能和backref是一样的</p>
<h2 id="定义1-1-1-n-m-n-关系"><a href="#定义1-1-1-n-m-n-关系" class="headerlink" title="定义1:1 1:n m:n 关系"></a>定义1:1 1:n m:n 关系</h2><h3 id="1-n"><a href="#1-n" class="headerlink" title="1:n"></a>1:n</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'parent'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    children = relationship(<span class="string">"Child"</span>, back_populates=<span class="string">"parent"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'child'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    parent_id = Column(Integer, ForeignKey(<span class="string">'parent.id'</span>))</div><div class="line">    parent = relationship(<span class="string">"Parent"</span>, back_populates=<span class="string">"children"</span>)</div><div class="line">    <span class="comment"># 子表类中附加一个 relationship() 方法</span></div><div class="line">    <span class="comment"># 并且在(父)子表类的 relationship() 方法中使用 relationship.back_populates 参数</span></div></pre></td></tr></table></figure>
<h3 id="1-1"><a href="#1-1" class="headerlink" title="1:1"></a>1:1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'parent'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    child = relationship(<span class="string">"Child"</span>, uselist=<span class="keyword">False</span>, back_populates=<span class="string">"parent"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'child'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    parent_id = Column(Integer, ForeignKey(<span class="string">'parent.id'</span>))</div><div class="line">    parent = relationship(<span class="string">"Parent"</span>, back_populates=<span class="string">"child"</span>)</div></pre></td></tr></table></figure>
<p>和1:n的不同在于，在父表上用uselist参数进行了限定</p>
<h3 id="m-n"><a href="#m-n" class="headerlink" title="m:n"></a>m:n</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">association_table = Table(<span class="string">'association'</span>, Base.metadata,</div><div class="line">    Column(<span class="string">'left_id'</span>, Integer, ForeignKey(<span class="string">'left.id'</span>)),</div><div class="line">    Column(<span class="string">'right_id'</span>, Integer, ForeignKey(<span class="string">'right.id'</span>))</div><div class="line">)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'left'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    children = relationship(</div><div class="line">        <span class="string">"Child"</span>,</div><div class="line">        secondary=association_table,</div><div class="line">        back_populates=<span class="string">"parents"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'right'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    parents = relationship(</div><div class="line">        <span class="string">"Parent"</span>,</div><div class="line">        secondary=association_table,</div><div class="line">        back_populates=<span class="string">"children"</span>)</div></pre></td></tr></table></figure>
<h2 id="SQLAlchemy-数据表结构改变（数据迁移）方法"><a href="#SQLAlchemy-数据表结构改变（数据迁移）方法" class="headerlink" title="SQLAlchemy 数据表结构改变（数据迁移）方法"></a>SQLAlchemy 数据表结构改变（数据迁移）方法</h2><p>在使用Django的ORM的时候我们可以轻易地通过<strong>python manage.py makemigration </strong> 和 <strong> python manage.py migrate </strong>实现数据表结构的改变<br>但是在SQLAlchemy这个工具中似乎不支持数据迁移，所以在这里使用到一个另外一个库：SQLAlchemy-migrate<br>使用这个库我们可以分别写两个文件表示创建数据库的时候和修改数据库的时候：</p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> migrate.versioning <span class="keyword">import</span> api</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="keyword">from</span> model <span class="keyword">import</span> Base</div><div class="line"><span class="keyword">from</span> parse <span class="keyword">import</span> engine</div><div class="line"><span class="keyword">from</span> config <span class="keyword">import</span> *</div><div class="line"></div><div class="line">Base.metadata.create_all(bind=engine)</div><div class="line"></div><div class="line"><span class="comment"># 创建表结构</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> (os.path.exists(sqlachemy_migrate_repo)):</div><div class="line">    api.create(sqlachemy_migrate_repo,<span class="string">'database repository'</span>)</div><div class="line">    api.version_control(postgresql_url,sqlachemy_migrate_repo)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    api.version_control(postgresql_url,sqlachemy_migrate_repo)</div></pre></td></tr></table></figure>
<h3 id="修改数据表的结构"><a href="#修改数据表的结构" class="headerlink" title="修改数据表的结构"></a>修改数据表的结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> migrate.versioning <span class="keyword">import</span> api</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> imp</div><div class="line"></div><div class="line"><span class="keyword">from</span> model <span class="keyword">import</span> Base</div><div class="line"><span class="keyword">from</span> parse <span class="keyword">import</span> engine</div><div class="line"><span class="keyword">from</span> config <span class="keyword">import</span> *</div><div class="line"></div><div class="line">Base.metadata.create_all(bind=engine)</div><div class="line"></div><div class="line"><span class="comment"># 迁移表结构</span></div><div class="line">migration = sqlachemy_migrate_repo + <span class="string">'/versions/%03d_migration.py'</span> % (api.db_version(postgresql_url, sqlachemy_migrate_repo) + <span class="number">1</span>)</div><div class="line">tmp_module = imp.new_module(<span class="string">'old_model'</span>)</div><div class="line">old_model = api.create_model(postgresql_url, sqlachemy_migrate_repo)</div><div class="line">exec(old_model, tmp_module.__dict__)</div><div class="line">script = api.make_update_script_for_model(postgresql_url, sqlachemy_migrate_repo, tmp_module.meta, Base.metadata)</div><div class="line">open(migration, <span class="string">'wt'</span>).write(script)</div><div class="line">api.upgrade(postgresql_url, sqlachemy_migrate_repo)</div><div class="line"></div><div class="line">print(<span class="string">'New migration saved as '</span> + migration)</div><div class="line">print(<span class="string">'Current database version: '</span> + str(api.db_version(postgresql_url, sqlachemy_migrate_repo)))</div></pre></td></tr></table></figure>
<p>但是当修改的东西过多的时候，这个时候会报错</p>
<h2 id="Django-中get-or-create-方法的实现"><a href="#Django-中get-or-create-方法的实现" class="headerlink" title="Django 中get_or_create 方法的实现"></a>Django 中get_or_create 方法的实现</h2><p>和上面一样在SQLAlchemy中也不存在非常方便的get_or_create的方法，用的比较多的时候，应该有必要重新写一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_or_create</span><span class="params">(session, model, defaults=None, **kwargs)</span>:</span></div><div class="line">    instance = session.query(model).filter_by(**kwargs).first()</div><div class="line">    <span class="keyword">if</span> instance:</div><div class="line">        <span class="keyword">return</span> instance, <span class="keyword">False</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        params = dict((k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.iteritems() <span class="keyword">if</span> <span class="keyword">not</span> isinstance(v, ClauseElement))</div><div class="line">        params.update(defaults <span class="keyword">or</span> &#123;&#125;)</div><div class="line">        instance = model(**params)</div><div class="line">        session.add(instance)</div><div class="line">        <span class="keyword">return</span> instance, <span class="keyword">True</span></div></pre></td></tr></table></figure></p>
<p>参考：<a href="https://codeday.me/bug/20170612/24948.html" target="_blank" rel="external">https://codeday.me/bug/20170612/24948.html</a></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SQLAchemy 学习(1)]]></title>
      <url>/2017/08/17/SQLAchemy-%E5%AD%A6%E4%B9%A0-1/</url>
      <content type="html"><![CDATA[<p>SQLAchemy 是Python操纵数据库的一个常用的第三方ORM框架，我将通过几篇文章总结一下对SQLAlchemy的学习。</p>
<a id="more"></a>
<h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>ORM全称是Object-relational mapping，他将关系数据库中表中的记录映射成为对象，以对象的形式展现，程序员可以把对数据库的操作转化为对对象的操作。<br>它的作用是在关系型数据库和业务实体对象之间作一个映射，这样，我们在具体的操作业务对象的时候，就不需要再去和复杂的SQL语句打交道，只要像平时操作对象一样操作它就可以了。<br>因此ORM的目的是为了方便开发人员以面向对象的思想来实现对数据库的操作。</p>
<p>python中最流行的ORM库就是SQLAlchemy</p>
<h2 id="SQLAchemy-架构"><a href="#SQLAchemy-架构" class="headerlink" title="SQLAchemy 架构"></a>SQLAchemy 架构</h2><p>SQLAcheemy两个层次的关系图<br><img src="https://data2.liuin.cn/story-writer/2017_7_27_1501156105658.jpg" alt=""><br>SQLAchemy方言系统核心类的关系图<br><img src="https://data2.liuin.cn/story-writer/2017_7_27_1501156198516.jpg" alt=""></p>
<h2 id="Connecting"><a href="#Connecting" class="headerlink" title="Connecting"></a>Connecting</h2><p>通过create_engine()方法创建一个Engine对象实现连接：<code>engine = create_engine(&quot;mysql://scott:tiger@hostname/dbname&quot;,encoding=&#39;latin1&#39;, echo=True)</code><br>数据库URL的格式为：dialect[+driver]://user:password@host/dbname[?key=value..]，其中dialect为使用的数据库名字，driver为驱动器（比如说mysql的pymysql或者psycopg2）</p>
<h2 id="Declare-a-Mapping（声明映射）"><a href="#Declare-a-Mapping（声明映射）" class="headerlink" title="Declare a Mapping（声明映射）"></a>Declare a Mapping（声明映射）</h2><p>我们要定义关系类的时候要依据一个基类，这个基类是维系类和数据表关系的目录，我们使用<strong>declarative_base()</strong>函数创建基类，<br>如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Base = declarative_base()</div></pre></td></tr></table></figure></p>
<p>后面所有定义的映射的类将继承这个类进行创建</p>
<h2 id="Create-a-Schema（创建模式）"><a href="#Create-a-Schema（创建模式）" class="headerlink" title="Create a Schema（创建模式）"></a>Create a Schema（创建模式）</h2><p>我们可以通过定义映射类类来创建相关的模式（ORM的特点），比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'users'</span></div><div class="line">    id = Column(Integer, Sequence(<span class="string">'user_id_seq'</span>), primary_key=<span class="keyword">True</span>)</div><div class="line">    name = Column(String(<span class="number">50</span>))</div><div class="line">    fullname = Column(String(<span class="number">50</span>))</div><div class="line">    password = Column(String(<span class="number">12</span>))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"&lt;User(name='%s', fullname='%s', password='%s')&gt;"</span> % (</div><div class="line">                                self.name, self.fullname, self.password)</div></pre></td></tr></table></figure></p>
<h2 id="Create-an-Instance-of-the-Mapped-Class"><a href="#Create-an-Instance-of-the-Mapped-Class" class="headerlink" title="Create an Instance of the Mapped Class"></a>Create an Instance of the Mapped Class</h2><p>实例化一个映射类，同样也支持使用<strong><strong>init</strong>()</strong>方法进行构造<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>ed_user = User(name=<span class="string">'ed'</span>, fullname=<span class="string">'Ed Jones'</span>, password=<span class="string">'edspassword'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ed_user.name</div><div class="line"><span class="string">'ed'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ed_user.password</div><div class="line"><span class="string">'edspassword'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str(ed_user.id)</div><div class="line"><span class="string">'None'</span></div></pre></td></tr></table></figure></p>
<h2 id="Adding-and-Updating-Objects"><a href="#Adding-and-Updating-Objects" class="headerlink" title="Adding and Updating Objects"></a>Adding and Updating Objects</h2><p>通过Session和数据库进行对话，通过<strong>sessionmaker()</strong> 利用之前创建的Engine上创建一个会话类，每次进行修改的时候都要由这个类生成一个实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Session = sessionmaker(bind=engine)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>session = Session()</div></pre></td></tr></table></figure></p>
<p>我们对对象进行修改以后，通过创建的这个session实例对象来进行提交<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>ed_user = User(name=<span class="string">'ed'</span>, fullname=<span class="string">'Ed Jones'</span>, password=<span class="string">'edspassword'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>session.add(ed_user)</div></pre></td></tr></table></figure></p>
<h2 id="Querying"><a href="#Querying" class="headerlink" title="Querying"></a>Querying</h2><p>Query通过Session中的query()方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> instance <span class="keyword">in</span> session.query(User).order_by(User.id):</div><div class="line"><span class="meta">... </span>    print(instance.name, instance.fullname)</div><div class="line">ed Ed Jones</div><div class="line">wendy Wendy Williams</div><div class="line">mary Mary Contrary</div><div class="line">fred Fred Flinstone</div></pre></td></tr></table></figure></p>
<p>Query提供多种筛选filter操作，在数据库中的相关基本运算</p>
<h2 id="常用的一些方法"><a href="#常用的一些方法" class="headerlink" title="常用的一些方法"></a>常用的一些方法</h2><ul>
<li>Base.metadata.create_all(engine) 常用于正常使用的时候创建表，自动建立表结构。优点是省时；缺点是风险高，只有在内测环境且数据量已经备份的前提下方可使用。是一种修改表结构的方法，但是风险比较高。还可以使用其他的库（如openstack/sqlalchemy-migrate)</li>
</ul>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识Scrapy 爬虫框架]]></title>
      <url>/2017/08/08/%E5%88%9D%E8%AF%86Scrapy-%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<p>之前写的爬虫差不多都是用requests发出请求然后通过BeautifulSoup进行解析获取数据，最近接触到了一个python的爬虫框架Scrapy。前后者的区别有点组装机和品牌机之间的区别。</p>
<a id="more"></a>
<h2 id="为什么要爬虫框架"><a href="#为什么要爬虫框架" class="headerlink" title="为什么要爬虫框架"></a>为什么要爬虫框架</h2><ul>
<li>将精力更多放在提取数据上，很多其他的模块（比如下载模块）不需要自己写</li>
<li>使用异步模式，提高速度，不要自己去实现异步框架</li>
<li>使用已有的轮子，大量减少代码量</li>
</ul>
<h2 id="框架架构"><a href="#框架架构" class="headerlink" title="框架架构"></a>框架架构</h2><p><img src="http://ot40h275y.bkt.clouddn.com/story-writer/2017_7_25_1500991351462.jpg" alt="架构图"><br>Scrapy Engine: 这是引擎，负责Spiders、ItemPipeline、Downloader、Scheduler中间的通讯，信号、数据传递等等！</p>
<p>Scheduler(调度器): 它负责接受引擎发送过来的requests请求，并按照一定的方式进行整理排列，入队、并等待Scrapy Engine(引擎)来请求时，交给引擎</p>
<p>Downloader（下载器）：负责下载Scrapy Engine(引擎)发送的所有Requests请求，并将其获取到的Responses交还给Scrapy Engine(引擎)，由引擎交给Spiders来处理</p>
<p>Spiders：它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给引擎，再次进入Scheduler(调度器)，业务逻辑的主要部分</p>
<p>Item Pipeline：它负责处理Spiders中获取到的Item，并进行处理，比如去重，持久化存储（存数据库，写入文件，总之就是保存数据用的）</p>
<p>Downloader Middlewares（下载中间件）：你可以当作是一个可以自定义扩展下载功能的组件</p>
<p>Spider Middlewares（Spider中间件）：你可以理解为是一个可以自定扩展和操作引擎和Spiders中间‘通信‘的功能组件（比如进入Spiders的Responses;和从Spiders出去的Requests）</p>
<h2 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>通过以下命令创建一个tutorial项目<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy startproject tutorial</div></pre></td></tr></table></figure></p>
<p>运行以后，将产生一个tutorial文件夹，含有以下的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">tutorial/</div><div class="line">    scrapy.cfg            # deploy configuration file</div><div class="line"></div><div class="line">    tutorial/             # project&apos;s Python module, you&apos;ll import your code from here</div><div class="line">        __init__.py</div><div class="line"></div><div class="line">        items.py          # project items definition file</div><div class="line"></div><div class="line">        pipelines.py      # project pipelines file</div><div class="line"></div><div class="line">        settings.py       # project settings file</div><div class="line"></div><div class="line">        spiders/          # a directory where you&apos;ll later put your spiders</div><div class="line">            __init__.py</div></pre></td></tr></table></figure></p>
<h3 id="创建第一个Spider"><a href="#创建第一个Spider" class="headerlink" title="创建第一个Spider"></a>创建第一个Spider</h3><ul>
<li>通过一个继承scrapy.Spider的类实现主要的功能，名字通过name定义</li>
<li>定义一个start_requests函数（返回iterable of Requests），提供给Spider爬取的URL</li>
<li>以上的start_request有一个快捷方式：直接指出start_urls需要爬取的URL lists</li>
<li>response是通过下载器在所给的URL中下载的内容</li>
<li>定义一个parse 函数对响应（response）进行处理解析</li>
<li>通过response.urljoin方法找到下一个URL链接，通过response.follow 方法使用快捷方式直接发出新的请求</li>
<li>在parse方法中返回数据，或者在启动爬虫的时候加上参数，使得数据得到保存</li>
</ul>
<h3 id="Selectors"><a href="#Selectors" class="headerlink" title="Selectors"></a>Selectors</h3><p>取出response中的内容</p>
<ul>
<li>通过css方法找到指定的标签或者模块</li>
<li>extract()取出response中的内容</li>
<li>也可以使用xpath方法找到想要找的模块</li>
<li>通过scrapy shell + 网址 可以在shell中对response进行处理（常用于测试）</li>
</ul>
<h3 id="Item类"><a href="#Item类" class="headerlink" title="Item类"></a>Item类</h3><p>在Scrapy爬虫框架中，Item类的作用是帮助我们把爬取的数据结构化表示<br>向前承接爬虫爬取的数据，向后为后面的数据持久化做准备<br>在project目录下默认创建的item.py文件可能无法引入到我们的爬虫文件中来，我们可以将这个item.py文件移动到项目根目录下</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python实现进度条显示]]></title>
      <url>/2017/08/02/Python%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%98%BE%E7%A4%BA/</url>
      <content type="html"><![CDATA[<p>运行程序的时候，即不想看那些快速飘过的日志信息，又不想只让光标在那闪，怎么办呢？加个进度条吧</p>
<a id="more"></a>
<h2 id="tqdm"><a href="#tqdm" class="headerlink" title="tqdm"></a>tqdm</h2><p>tqdm是Python的一个进度条库，使用起来非常方便，上手十分容易</p>
<p><img src="http://ot40h275y.bkt.clouddn.com/story-writer/2017_7_31_1501480765636.jpg" alt="运行效果"></p>
<p>最简单的方式是使用tqdm包裹一个迭代器，迭代器现在所处的进度就是后面显示的进度。</p>
<h2 id="基于迭代的使用"><a href="#基于迭代的使用" class="headerlink" title="基于迭代的使用"></a>基于迭代的使用</h2><p>tqdm可以包裹任何迭代器，显示的进度就是当前迭代的进度<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">text = <span class="string">""</span></div><div class="line"><span class="keyword">for</span> char <span class="keyword">in</span> tqdm([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]):</div><div class="line">    text = text + char</div></pre></td></tr></table></figure></p>
<h2 id="手动操作"><a href="#手动操作" class="headerlink" title="手动操作"></a>手动操作</h2><p>通过with来控制tqdm()的更新：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> tqdm(total=<span class="number">100</span>) <span class="keyword">as</span> pbar:</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">        pbar.update(<span class="number">10</span>)</div></pre></td></tr></table></figure></p>
<p>或者不使用with，使用一个变量来表示，但是最后不要忘了撤销close()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pbar = tqdm(total=<span class="number">100</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    pbar.update(<span class="number">10</span>)</div><div class="line">pbar.close()</div></pre></td></tr></table></figure></p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>tqdm还可以使用在shell的管道命令中，在标准输入和标准输出中添加<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ time find . -name <span class="string">'*.py'</span> -exec cat \&#123;&#125; \; | wc <span class="_">-l</span></div><div class="line">857365</div><div class="line"></div><div class="line">real    0m3.458s</div><div class="line">user    0m0.274s</div><div class="line">sys     0m3.325s</div><div class="line"></div><div class="line">$ time find . -name <span class="string">'*.py'</span> -exec cat \&#123;&#125; \; | tqdm | wc <span class="_">-l</span></div><div class="line">857366it [00:03, 246471.31it/s]</div><div class="line">857365</div><div class="line"></div><div class="line">real    0m3.585s</div><div class="line">user    0m0.862s</div><div class="line">sys     0m3.358s</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux中查找目录下的文件是否含有某个字符串]]></title>
      <url>/2017/07/28/Linux%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%90%AB%E6%9C%89%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<p>在日常开发中，我们常常有这样的需求：想要在一个都是文本文件的文件夹中查找文件中含有某些字符串的文件。这篇文章给出了一种解决方案：通过find、xargs和grep三个命令实现。</p>
<a id="more"></a>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>查找目录下的所有文件中是否含有某个字符串”Ali”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find .|xargs grep -ri &quot;Ali&quot;</div></pre></td></tr></table></figure></p>
<p>查找目录下的所有文件中是否含有某个字符串,并且只打印出文件名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find .|xargs grep -ri &quot;Ali&quot; -l</div></pre></td></tr></table></figure></p>
<p>如果是在一个Git 项目中进行查找，可以使用git的grep命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git grep -n hello_world</div></pre></td></tr></table></figure></p>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find 是一个利用正则表达式查找当前目录下的文件及子目录中文件的命令，查找的根据可以是文件名，也可以是文件从属关系等等<br>同时结合-exec选项和其他命令结合使用<br>在这里find的作用是将查找范围定在当前的目录下的所有文本展现出来通过xargs 提供给grep 作为参数</p>
<p>参考：<a href="http://man.linuxde.net/find" target="_blank" rel="external">http://man.linuxde.net/find</a></p>
<h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>xargs 是一个给其他命令传递参数的一个过滤器，它擅长将标准输入数据转换成命令行参数，xargs能够处理管道或者stdin并将其转换成特定命令的命令参数。<br>在这里xargs 为后面的grep 提供查找的内容</p>
<p>参考：<a href="http://man.linuxde.net/xargs" target="_blank" rel="external">http://man.linuxde.net/xargs</a></p>
<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep 是一种强大的文本搜索工具。grep 也是一个管道命令，接受standard output 作为查找的文本。不作为管道命令的时候后面接文件名作为参数。<br>这里使用到了三个选项：-r 递归搜索   -i 忽略大小写   -l  仅显示文件名</p>
<p>参考：<a href="http://man.linuxde.net/grep" target="_blank" rel="external">http://man.linuxde.net/grep</a></p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 中的语言设置问题]]></title>
      <url>/2017/07/21/Linux-%E4%B8%AD%E7%9A%84%E8%AF%AD%E8%A8%80%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>语言问题是在Linux系统中经常遇到的问题，有的时候在使用数据库的时候，会出现编码不支持导致无法进行中文操作的情况。这篇文章是我在整理了一些Linux的编码相关的资料和查看了相关的博客以后，对Linux语言设置做的一个总结。</p>
<a id="more"></a>
<h2 id="locale-查看当前系统编码设置情况"><a href="#locale-查看当前系统编码设置情况" class="headerlink" title="locale 查看当前系统编码设置情况"></a>locale 查看当前系统编码设置情况</h2><p>使用locale命令以后，我们可以看到当前语言环境的一些配置，出现字段的含义分别是：<br>1、 语言符号及其分类(LC_CTYPE)<br>2、 数字(LC_NUMERIC)<br>3、 比较和排序习惯(LC_COLLATE)<br>4、 时间显示格式(LC_TIME)<br>5、 货币单位(LC_MONETARY)<br>6、 信息主要是提示信息,错误信息, 状态信息, 标题, 标签, 按钮和菜单等(LC_MESSAGES)<br>7、 姓名书写方式(LC_NAME)<br>8、 地址书写方式(LC_ADDRESS)<br>9、 电话号码书写方式(LC_TELEPHONE)<br>10、度量衡表达方式(LC_MEASUREMENT)<br>11、默认纸张尺寸大小(LC_PAPER)<br>12、对locale自身包含信息的概述(LC_IDENTIFICATION)。</p>
<p>设定locale就是设定12大类的locale分类属性，即 12个LC_*。除了这12个变量可以设定以外，为了简便起见，还有两个变量：LC_ALL和LANG。<br>它们之间有一个优先级的关系：LC<em>ALL &gt; LC\</em>* &gt; LANG<br>可以这么说，LC_ALL是最上级设定或者强制设定，而LANG是默认设定值。</p>
<p><strong>LANG和LANGUAGE的区别</strong>：<br>LANGUAGE是设置应用程序的界面语言。而LANG是优先级很低的一个变量，它指定所有与locale有关的变量的默认值</p>
<h2 id="安装相应的语言包"><a href="#安装相应的语言包" class="headerlink" title="安装相应的语言包"></a>安装相应的语言包</h2><p>有些系统一开始是不带有中文的语言包的，需要自己进行安装。<br>在Ubuntu系统中，安装中文语言包：<br><code>sudo apt-get install language-pack-zh-hans</code><br>再使用locale -a 查看是否有zh_CN.*这样的语言环境</p>
<h2 id="修改系统locale-设置"><a href="#修改系统locale-设置" class="headerlink" title="修改系统locale 设置"></a>修改系统locale 设置</h2><p>可以通过修改LC<em>ALL、LC\</em>*、LANG这三种变量的值来更改使用的语言（修改前，必须确定已经安装好相应的语言包，通过 <code>locale -a</code>命令进行查看已经安装的语言包）</p>
<ol>
<li>如果需要一个纯中文的系统的话，设定LC_ALL= zh_CN.XXXX，或者LANG=zh_CN.XXXX都可以</li>
<li>如果只想要一个可以输入中文的环境，而保持菜单、标题，系统信息等等为英文界面，那么只需要设定 LC_CTYPE＝zh_CN.XXXX，LANG=en_US.XXXX就可以</li>
</ol>
<p>具体方法：<br>在系统中修改 <strong>/etc/default/local</strong> 中的LANG和LANGUAGE(如果需要修改其他语言设置变量的值，列出即可) 的设置以后进行重启即可</p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Leetcode] Longest Substring Without Repeating Characters 题解]]></title>
      <url>/2017/07/15/Leetcode-Longest-Substring-Without-Repeating-Characters-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>题目链接:<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/#/description" target="_blank" rel="external">https://leetcode.com/problems/longest-substring-without-repeating-characters/#/description</a></p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个字符串，求出其中最长的不重复字符串的长度</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul>
<li>用一个数组记录每个字符出现的索引值，没有出现的为零</li>
<li>设定一个开始指针表示计算字符开始的地方（初始值为0），这样每次扫描到一个字符的时候，先更新这个指针。然后计算开始指针到扫描的地方的字符串长度更新结果值。</li>
<li>最后更新字符出现的索引值</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> a[<span class="number">256</span>];</div><div class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</div><div class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,num=<span class="number">0</span>,start=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.size();i++)</div><div class="line">        &#123;</div><div class="line">            start=start&gt;a[s[i<span class="number">-1</span>]]?start:a[s[i<span class="number">-1</span>]];</div><div class="line">            num=i-start;</div><div class="line">            ans=ans&gt;num?ans:num;</div><div class="line">            a[s[i<span class="number">-1</span>]]=i;</div><div class="line">        &#125;</div><div class="line">        ans=ans&gt;num?ans:num;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识 Git hook钩子]]></title>
      <url>/2017/06/12/%E5%88%9D%E8%AF%86-Git-hook%E9%92%A9%E5%AD%90/</url>
      <content type="html"><![CDATA[<p>之前使用git一直停留在比较浅的层面，最近涉及部署的相关东西的时候接触到了Git的hook，感觉这个东西非常有趣，下面总结一下我对Git中hook的认识以及分享一下我使用git的hook部署hexo博客到服务器上的过程。</p>
<a id="more"></a>
<h2 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Git钩子是仓库中特定事件发生时Git自动运行的普通脚本。每当我们创建一个仓库的时候，我们仓库的.git/hooks目录中有一些示例脚本。<br>这些脚本可以是任何脚本语言编写的，只要它们最后能编译到可执行文件。每次脚本中的#!/bin/sh定义了你的文件将被如何解释。</p>
<h3 id="pre-receive"><a href="#pre-receive" class="headerlink" title="pre-receive"></a>pre-receive</h3><p>git有非常多的本地钩子和服务端钩子，因为这次我使用的主要是pre-receive来部署博客，所以介绍一下pre-receive钩子,更多的钩子信息可以在文章最后的参考信息中查看<br>pre-receive钩子在有人用git push向仓库推送代码时被执行。它只存在于远端仓库中，而不是原来的仓库中。<br>所以我们可以用来在hexo提交更新的时候对服务器上的相关资源进行更新</p>
<h2 id="使用-Git-hook-自动部署-Hexo博客"><a href="#使用-Git-hook-自动部署-Hexo博客" class="headerlink" title="使用 Git hook 自动部署 Hexo博客"></a>使用 Git hook 自动部署 Hexo博客</h2><h3 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h3><p>首先我们要在服务器器创建一个管理内容的仓库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo mkdir /var/repo</div><div class="line"><span class="built_in">cd</span> /var/repo</div><div class="line">sudo git init --bare blog.git</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这里使用了 –bare 参数，是为了创建一个裸仓库，没有工作区。我们不会在裸仓库上进行操作，它只为共享而存在。<br>后面在hook的设置中会讲到工作区的设置</p>
</blockquote>
<h3 id="配置hook"><a href="#配置hook" class="headerlink" title="配置hook"></a>配置hook</h3><p>因为是在push操作时才发生的事件所以使用post-receive钩子，钩子将在git操作完以后运行<br>在blog.git/hooks 目录下新建一个post-receive文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /var/repo/blog.git/hooks</div><div class="line">vim post-reveive</div></pre></td></tr></table></figure></p>
<p>在post-receive中写入以下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line">git --work-tree=/var/www/hexo --git-dir=/var/repo/blog.git checkout <span class="_">-f</span></div></pre></td></tr></table></figure>
<p>注意，/var/www/hexo 要换成你自己的部署目录，一般可能都是 /var/www/html。上面那句 git 命令可以在我们每次 push 完之后，把部署目录更新到博客的最新生成状态。这样便可以完成达到自动部署的目的了。<br>同时加上可执行权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x post-receive</div></pre></td></tr></table></figure></p>
<h3 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h3><p>修改 hexo 目录下的 _config.yml 文件 ，使得hexo博客可以自动deploy到服务器上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  <span class="built_in">type</span>: git</div><div class="line">  repo: git@www.example.com:/var/repo/blog.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p>
<p>切换服务器地址和目录为你自己的服务器的地址和目录</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>此时你创建新的文章的时候就可以通过git hook来进行自动部署了，而不需要使用GitHub page的相关服务了</p>
<hr>
<p>参考：<br><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.4-Git%E9%92%A9%E5%AD%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81" target="_blank" rel="external">https://github.com/geeeeeeeeek/git-recipes/wiki/5.4-Git%E9%92%A9%E5%AD%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDU 3092 Least common multiple 素数打表+ 完全背包]]></title>
      <url>/2017/05/18/HDU-3092-Least-common-multiple-%E7%B4%A0%E6%95%B0%E6%89%93%E8%A1%A8-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3092" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=3092</a></p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出两个数S和M，让你将S分解成多个整数的和，使得这些整数的最小公倍数最大，输出这个最小公倍数（对M取模以后）</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul>
<li>首先在S的范围内进行素数打表，这样就可以看成取出这么多个素数进行相加的完全背包问题（因为同一个可以取多次，相乘以后照样和其他素数互质）</li>
<li>与我们平常见到的完全背包不同的是，如果一个素数取多次，他的代价和收益都是相乘的，而不是相加，所以写法应该在01背包的基础上进行改进，枚举可能相乘的个数</li>
<li>因为相乘一定会溢出，同时取模会影响到比较大小，所以采取取对数的方法来对dp数组进行操作，同时另外开一个数组ans[]来记录答案</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">3005</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">10005</span>; </div><div class="line"></div><div class="line"><span class="keyword">bool</span> is_prime[maxn];</div><div class="line"><span class="keyword">int</span> prime[maxn],num;</div><div class="line"><span class="keyword">double</span> dp[maxn];</div><div class="line">ll ans[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime_init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	num=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(is_prime,<span class="literal">true</span>,<span class="keyword">sizeof</span>(is_prime));</div><div class="line">	is_prime[<span class="number">0</span>]=is_prime[<span class="number">1</span>]=<span class="literal">false</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(is_prime[i])prime[num++]=i;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num &amp;&amp; i*prime[j]&lt;maxn;j++)</div><div class="line">		&#123;</div><div class="line">			is_prime[i*prime[j]]=<span class="literal">false</span>;</div><div class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;  <span class="comment">//保证每一个合数都被他的最小质因数排除</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> S,M;</div><div class="line">	prime_init();</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;S,&amp;M)!=EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">		fill(ans,ans+num,<span class="number">1</span>);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num &amp;&amp; prime[i]&lt;S ;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">double</span> tmp=<span class="built_in">log</span>(prime[i]*<span class="number">1.0</span>);</div><div class="line">			<span class="keyword">for</span>(ll j=S;j&gt;=prime[i];j--)</div><div class="line">				<span class="keyword">for</span>(ll k=prime[i],q=<span class="number">1</span>;k&lt;=j;k*=prime[i],q++)  <span class="comment">//可以重复，q表示重复次数</span></div><div class="line">					<span class="keyword">if</span>(dp[j-k]+q*tmp&gt;dp[j])</div><div class="line">					&#123;</div><div class="line">						dp[j]=dp[j-k]+q*tmp;</div><div class="line">						ans[j]=ans[j-k]*k%M;</div><div class="line">					&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[S]);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">	solve();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Educational Codeforces Round 21 题解]]></title>
      <url>/2017/05/17/Educational-Codeforces-Round-21-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>比赛链接：<a href="http://codeforces.com/contest/808" target="_blank" rel="external">http://codeforces.com/contest/808</a></p>
<a id="more"></a>
<h2 id="A-Lucky-Year"><a href="#A-Lucky-Year" class="headerlink" title="A Lucky Year"></a>A Lucky Year</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>定义一个幸运数字：有且只含有一个非零数字。给出一个数n，求这个增加多少个数以后才能够成为一个幸运数字</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>数据范围比较小，求出位数，得到最高位大1后面全是0的数，拿这个数去减原来的数就行了</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n,i;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;n/(i*<span class="number">10</span>);i*=<span class="number">10</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,n/i*i+i-n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="B-Average-Sleep-Time"><a href="#B-Average-Sleep-Time" class="headerlink" title="B Average Sleep Time"></a>B Average Sleep Time</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出一个包含n个元素的序列，表示每天的睡眠时间，同时给出一个k，表示相邻k天是一个周期，总共有n-k+1个周期，求周期平均睡眠时间</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>根据公式直接进行求解，输出的时候多输出几位，保证精度</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n,k,r;</div><div class="line">	<span class="keyword">double</span> ans;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">double</span> tmp=<span class="number">0</span>;</div><div class="line">		ans=<span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> weeks=n-k+<span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cin</span>&gt;&gt;a[i];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</div><div class="line">			tmp+=a[i];</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&lt;n;i++)</div><div class="line">		&#123;</div><div class="line">			ans+=tmp/weeks;</div><div class="line">			tmp+=a[i+<span class="number">1</span>];</div><div class="line">			tmp-=a[i-k+<span class="number">1</span>];</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%.12lf\n"</span>,ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="C-Tea-Party"><a href="#C-Tea-Party" class="headerlink" title="C Tea Party"></a>C Tea Party</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出n个人的杯子的容量，以及你所含有的水的量，要求给n个人倒茶，必须满足以下条件：1.每个人的杯子必须至少倒一半的茶  2.每个人的杯子中含有的茶的量是一个整数  3.所有的茶都要倒完  4.所有人都要满意（不存在有的人杯子大但是茶少的情况）<br>判断是否存在满足上述条件的倒茶方法</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><ul>
<li>首先判断能够给每个人至少倒一半的茶</li>
<li>根据总量推算出倒茶的比例，再按照杯子的容量进行排序，按照比例向下取整进倒茶，多出来的部分分给杯子容量最大的人，以此类推</li>
<li>注意取整操作，以及满足至少倒一半的操作</li>
</ul>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">100005</span>; </div><div class="line"><span class="keyword">int</span> ans[maxn];</div><div class="line"></div><div class="line"><span class="keyword">struct</span> node</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> v,u,id;</div><div class="line">&#125;a[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Cmp1</span><span class="params">(<span class="keyword">const</span> node &amp;a,<span class="keyword">const</span> node &amp;b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> a.v&lt;b.v;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Cmp2</span><span class="params">(<span class="keyword">const</span> node &amp;a,<span class="keyword">const</span> node &amp;b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> a.id&lt;b.id;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n,w;</div><div class="line">	<span class="keyword">int</span> sum;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;w)</div><div class="line">	&#123;</div><div class="line">		sum=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cin</span>&gt;&gt;a[i].v;</div><div class="line">			a[i].id=i;</div><div class="line">			sum+=a[i].v;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">double</span> rate=<span class="number">1.0</span>*w/sum;</div><div class="line">		<span class="keyword">if</span>(rate&lt;<span class="number">0.5</span>) </div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> last=w,tmp;</div><div class="line">		<span class="keyword">bool</span> endflag=<span class="number">0</span>;</div><div class="line">		sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,Cmp1);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">		&#123;</div><div class="line">			tmp=<span class="built_in">floor</span>(a[i].v*rate);</div><div class="line">			<span class="keyword">if</span>(<span class="number">2</span>*tmp&lt;a[i].v) tmp++; <span class="comment">//防止在一半以下</span></div><div class="line">            a[i].u=tmp;</div><div class="line">			last-=a[i].u;</div><div class="line">			<span class="keyword">if</span>(last&lt;<span class="number">0</span>) endflag=<span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(endflag)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n;last&gt;<span class="number">0</span>;i--)</div><div class="line">		&#123;</div><div class="line">			tmp=a[i].v-a[i].u;</div><div class="line">			<span class="keyword">if</span>(last&gt;=tmp) </div><div class="line">			&#123;</div><div class="line">				last-=tmp;</div><div class="line">				a[i].u=a[i].v;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span></div><div class="line">			&#123;</div><div class="line">                a[i].u+=last;</div><div class="line">				last=<span class="number">0</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,Cmp2);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;a[i].u&lt;&lt;<span class="string">" "</span>;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="D-Array-Division"><a href="#D-Array-Division" class="headerlink" title="D Array Division"></a>D Array Division</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出一个序列，允许将两个数相互交换一次或者不交换，问是否能够将两个数分成相等的两个部分</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>先求出前缀和，再用Set维护两个集合，前面的集合/后面的集合，从1开始将序列分成两半，判断两者差的一半是否在集合中能够找到</p>
<h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>使用二分，求出前缀和，从前向后枚举交换的元素，用二分向前向后查找是否能够找到交换以后形成总数的一半的部分</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><h4 id="思路一-1"><a href="#思路一-1" class="headerlink" title="思路一"></a>思路一</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">100005</span>; </div><div class="line"><span class="keyword">int</span> a[maxn],n;</div><div class="line">ll s[maxn],tot;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</div><div class="line">	&#123;</div><div class="line">		tot=<span class="number">0</span>;</div><div class="line">		s[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line">		<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s1,s2;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">			s2.insert(a[i]);</div><div class="line">			tot+=a[i];</div><div class="line">			s[i]=s[i<span class="number">-1</span>]+a[i];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(tot&amp;<span class="number">1</span>) </div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		ll A,B,tmp;</div><div class="line">		<span class="keyword">bool</span> endflag=<span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">		&#123;</div><div class="line">			A=s[i],B=s[n]-s[i];</div><div class="line">			<span class="keyword">if</span>(A==B)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">				endflag=<span class="number">0</span>;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			tmp=A-B;</div><div class="line">			s2.erase(s2.find(a[i]));</div><div class="line">			s1.insert(a[i]);</div><div class="line">			<span class="keyword">if</span>(tmp&gt;<span class="number">0</span> &amp;&amp; tmp%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; tmp&lt;=MAXX)  <span class="comment">//差值为偶数</span></div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span>(s1.find(tmp/<span class="number">2</span>)!=s1.end())</div><div class="line">				&#123;</div><div class="line">					<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">					endflag=<span class="number">0</span>;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span>(tmp&lt;<span class="number">0</span> &amp;&amp; tmp%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; tmp&gt;=-MAXX)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span>(s2.find(-tmp/<span class="number">2</span>)!=s2.end())</div><div class="line">				&#123;</div><div class="line">					<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">					endflag=<span class="number">0</span>;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(endflag) <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="思路二-1"><a href="#思路二-1" class="headerlink" title="思路二"></a>思路二</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">100005</span>; </div><div class="line"></div><div class="line"><span class="keyword">int</span> a[maxn];</div><div class="line">ll s[maxn];</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    ll tot=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</div><div class="line">        tot += a[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(tot%<span class="number">2</span>!=<span class="number">0</span> || n==<span class="number">1</span>)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    tot/=<span class="number">2</span>;</div><div class="line">    s[<span class="number">0</span>]=a[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)&#123;</div><div class="line">        s[i]=s[i<span class="number">-1</span>]+a[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</div><div class="line">        <span class="keyword">if</span>(a[i]==tot)&#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//正二分</span></div><div class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=i<span class="number">-1</span>;</div><div class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</div><div class="line">            <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">            ll temp=s[mid]+a[i];</div><div class="line">            <span class="keyword">if</span>(temp==tot)&#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(temp&lt;tot)  l=mid+<span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        l=i+<span class="number">1</span>,r=n;</div><div class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</div><div class="line">            <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">            ll temp=s[n]-s[mid]+a[i];</div><div class="line">            <span class="keyword">if</span>(temp==tot)&#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(temp&lt;tot) r=mid<span class="number">-1</span>;</div><div class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDU 1868 Consecutive sum 数学+枚举]]></title>
      <url>/2017/05/16/HDU-1868-Consecutive-sum-%E6%95%B0%E5%AD%A6-%E6%9E%9A%E4%B8%BE/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1868" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=1868</a></p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个数n，求出这个数被分解成连续多个数之和的方案数</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>连续多个数之和可以看成等差数列，得到公式：x(i+i+x-1)/2=n。这样我们可以枚举x，在根号n的复杂度下将问题求解</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">100005</span>; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ll x;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x)!=EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=<span class="number">2</span>*x;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>((<span class="number">2</span>*x)%i) <span class="keyword">continue</span>;</div><div class="line">			<span class="keyword">int</span> tmp=<span class="number">2</span>*x/i+<span class="number">1</span>-i;</div><div class="line">			<span class="keyword">if</span>(tmp%<span class="number">2</span>) <span class="keyword">continue</span>;</div><div class="line">			ans++;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">	solve();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDU 1083 Courses 匈牙利算法模板题]]></title>
      <url>/2017/05/15/HDU-1083-Courses-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1083" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=1083</a></p>
<a id="more"></a>
<h2 id="题意-amp-题解"><a href="#题意-amp-题解" class="headerlink" title="题意&amp;题解"></a>题意&amp;题解</h2><p>给出一个二分图求最大匹配个数，判断时候和一边的数相等，以此题当做匈牙利算法模板</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">100005</span>; </div><div class="line">  </div><div class="line"><span class="comment">/* ************************************************************************** </span></div><div class="line">//二分图匹配（匈牙利算法的DFS实现） </div><div class="line">//初始化：g[][]两边顶点的划分情况 </div><div class="line">//建立g[i][j]表示i-&gt;j的有向边就可以了，是左边向右边的匹配 </div><div class="line">//g没有边相连则初始化为0 </div><div class="line">//L是匹配左边的顶点数，R是匹配右边的顶点数 </div><div class="line">//调用：res=hungary();输出最大匹配数 </div><div class="line">//优点：适用于稠密图，DFS找增广路，实现简洁易于理解 </div><div class="line">//时间复杂度:O(VE) </div><div class="line">// ***************************************************************************/  </div><div class="line"><span class="comment">//顶点编号从1开始的  </span></div><div class="line"><span class="keyword">int</span> LN,RN;<span class="comment">//L,R数目  </span></div><div class="line"><span class="keyword">int</span> g[maxn][maxn], linker[maxn];    <span class="comment">//所连得边直接从做到右</span></div><div class="line"><span class="keyword">bool</span> used[maxn];  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> L)</span><span class="comment">//从左边开始找增广路径  </span></span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> R;  </div><div class="line">    <span class="keyword">for</span>(R = <span class="number">1</span>; R &lt;= RN; R++)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">if</span>(g[L][R]!=<span class="number">0</span> &amp;&amp; !used[R])  </div><div class="line">        &#123;  </div><div class="line">            <span class="comment">//找增广路，反向  </span></div><div class="line">            used[R]=<span class="literal">true</span>;  </div><div class="line">            <span class="keyword">if</span>(linker[R] == <span class="number">-1</span> || dfs(linker[R]))  </div><div class="line">            &#123;  </div><div class="line">                linker[R]=L;  </div><div class="line">                <span class="keyword">return</span> <span class="number">1</span>;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//这个不要忘了，经常忘记这句  </span></div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span> ;  </div><div class="line">    <span class="keyword">int</span> L;  </div><div class="line">    <span class="built_in">memset</span>(linker,<span class="number">-1</span>,<span class="keyword">sizeof</span>(linker));  </div><div class="line">    <span class="keyword">for</span>( L = <span class="number">1</span>; L &lt;= LN; L++)  </div><div class="line">    &#123;  </div><div class="line">        <span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span>(used));  </div><div class="line">        <span class="keyword">if</span>(dfs(L) != <span class="number">0</span>)  </div><div class="line">            res++;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> res;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> t;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</div><div class="line">	<span class="keyword">while</span>(t--)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;LN,&amp;RN);</div><div class="line">		<span class="keyword">int</span> num,tmp;</div><div class="line">		<span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span>(g));</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=LN;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num;j++)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tmp);</div><div class="line">                g[i][tmp]=<span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> ans=hungary();</div><div class="line">		<span class="keyword">if</span>(ans==LN) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">	solve();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论-二分图 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDU 1162 Eddy's picture 最小生成树 Prim模板]]></title>
      <url>/2017/05/15/HDU-1162-Eddy-s-picture-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-Prim%E6%A8%A1%E6%9D%BF/</url>
      <content type="html"><![CDATA[<p>算法链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1162" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=1162</a></p>
<a id="more"></a>
<h2 id="题意-amp-题解"><a href="#题意-amp-题解" class="headerlink" title="题意&amp;题解"></a>题意&amp;题解</h2><p>裸的最小生成树，先计算出各个点的距离，跑一遍Prime。以此题记录Prime算法模板</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">205</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">2005</span>;</div><div class="line"></div><div class="line"><span class="keyword">double</span> cost[maxn][maxn];</div><div class="line"><span class="keyword">double</span> mincost[maxn];  <span class="comment">//到已经确定的点的最短距离</span></div><div class="line"><span class="keyword">bool</span> used[maxn];</div><div class="line"><span class="keyword">int</span> V;</div><div class="line"><span class="keyword">double</span> xx[maxn],yy[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_dist</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((xx[a]-xx[b])*(xx[a]-xx[b])+(yy[a]-yy[b])*(yy[a]-yy[b]));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++)</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;xx[i],&amp;yy[i]);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++)</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=V;j++)</div><div class="line">		&#123;</div><div class="line">			cost[i][j]=cost[j][i]=get_dist(i,j);</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">prim</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    fill(mincost,mincost+V+<span class="number">1</span>,INF);  <span class="comment">//注意建图方式</span></div><div class="line">    fill(used,used+V+<span class="number">1</span>,<span class="literal">false</span>);   <span class="comment">//注意建图方式</span></div><div class="line">    mincost[<span class="number">1</span>]=<span class="number">0</span>;        <span class="comment">//注意建图方式</span></div><div class="line">    <span class="comment">//used[0]=true;     不在这里初始初始化</span></div><div class="line"></div><div class="line">    <span class="keyword">double</span> res=<span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> v=<span class="number">-1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++) <span class="comment">//注意建图组织方式</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">//在这里对收录一号元素，因为要遍历一号元素的相邻结点</span></div><div class="line">            <span class="keyword">if</span>(!used[i]&amp;&amp;((v==<span class="number">-1</span>)||mincost[i]&lt;mincost[v]))v=i;   </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(v==<span class="number">-1</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        used[v]=<span class="literal">true</span>;</div><div class="line">        res+=mincost[v];</div><div class="line">		<span class="comment">//cout&lt;&lt;v&lt;&lt;" "&lt;&lt;res&lt;&lt;endl;</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++)    <span class="comment">//注意建图方式</span></div><div class="line">            mincost[i]=min(mincost[i],cost[v][i]);  <span class="comment">//不判断是否相邻</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;V)!=EOF)</div><div class="line">	&#123;</div><div class="line">		build();</div><div class="line">		<span class="keyword">double</span> ans=prim();</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">	solve();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论-最小生成树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2017 CCPC 中南地区邀请赛 E Strange Optimization]]></title>
      <url>/2017/05/15/2017-CCPC-%E4%B8%AD%E5%8D%97%E5%9C%B0%E5%8C%BA%E9%82%80%E8%AF%B7%E8%B5%9B-E-Strange-Optimization/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://202.197.224.59/OnlineJudge2/index.php/Contest/read_problem/cid/43/pid/1268" target="_blank" rel="external">http://202.197.224.59/OnlineJudge2/index.php/Contest/read_problem/cid/43/pid/1268</a></p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>定义一个函数：f(t)=min(i,j∈ℤ)|i/n−j/m+t|，给出n和m，求使得f(t)最大的t的取值。（式子可以查看原网页中的式子）</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>因为i,j都是可以取任意整数的，所以进行式子中的前两个部分进行通分以后就是(im-jn)/mn。<br>观察我们可以得到要得到最大值<strong>t的值就是上述式子的最小精度的一半</strong>，求最小精度就是要求分子(im-jn)能表示的数的间隔<br>这个间隔我用一个比较巧妙的方法求得，用一个优先队列来存放这两个数，不断从优先队列中取出两个最小的数做差，然后再放入优先队列中，直到取出的这两个最小的数是相同的。<br>最后对得到的分数进行化简就是最后的答案了</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">15</span>;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">llc</span><span class="params">(ll a,ll b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> a*b/gcd(a,b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ll n,m;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</div><div class="line">	&#123;</div><div class="line">		priority_queue&lt;ll,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; Q;</div><div class="line">		Q.push(n);</div><div class="line">		Q.push(m);</div><div class="line">		ll s1,s2,tmp;</div><div class="line">		s1=Q.top(),Q.pop(),s2=Q.top(),Q.pop();</div><div class="line">		<span class="keyword">while</span>(s1!=s2)</div><div class="line">		&#123;</div><div class="line">			<span class="comment">//cout&lt;&lt;s1&lt;&lt;s2&lt;&lt;endl;</span></div><div class="line">			tmp=<span class="built_in">abs</span>(s1-s2);</div><div class="line">			Q.push(s1),Q.push(s2),Q.push(tmp);</div><div class="line">            s1=Q.top(),Q.pop(),s2=Q.top(),Q.pop();</div><div class="line">		&#125;</div><div class="line">		ll p=s1,q=<span class="number">2</span>*m*n;</div><div class="line">		tmp=gcd(p,q);</div><div class="line">		<span class="keyword">while</span>(tmp!=<span class="number">1</span>)</div><div class="line">		&#123;</div><div class="line">			p/=tmp,q/=tmp;</div><div class="line">			tmp=gcd(p,q);</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">"/"</span>&lt;&lt;q&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">	solve();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>做出这道题的时候还是有些激动的，因为在现场赛上两题如果罚时不多的话就是铜牌。哈哈，如果我去打这场比赛就能够拿一个铜牌。<br>好好努力，提升实力，以后在区域赛上拿牌就美滋滋了。</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDU 1874 畅通工程续 最短路Dijkstra模板题]]></title>
      <url>/2017/05/15/HDU-1874-%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E7%BB%AD-%E6%9C%80%E7%9F%AD%E8%B7%AFDijkstra%E6%A8%A1%E6%9D%BF%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1874" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=1874</a></p>
<a id="more"></a>
<h2 id="题意-amp-题解"><a href="#题意-amp-题解" class="headerlink" title="题意&amp;题解"></a>题意&amp;题解</h2><p>裸的最短路，注意重边问题。以此题来代表Dijkstra模板（邻接矩阵）</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">205</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">2005</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> cost[maxn][maxn];  <span class="comment">//邻接矩阵建图</span></div><div class="line"><span class="keyword">int</span> d[maxn];</div><div class="line"><span class="keyword">bool</span> used[maxn];  <span class="comment">//表示是否被收录</span></div><div class="line"><span class="keyword">int</span> V,E;</div><div class="line"></div><div class="line"><span class="comment">//建图</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">memset</span>(d,INF,<span class="keyword">sizeof</span>(d));</div><div class="line">	<span class="built_in">memset</span>(cost,INF,<span class="keyword">sizeof</span>(cost));    <span class="comment">//初始化邻接矩阵</span></div><div class="line">	<span class="keyword">int</span> u,v,w;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;E;i++)</div><div class="line">	&#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;w);</div><div class="line">        cost[u][v]=cost[v][u]=min(cost[v][u],w);  <span class="comment">//去重边操作</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></div><div class="line">&#123;</div><div class="line">    fill(d,d+V,INF);</div><div class="line">    fill(used,used+V,<span class="literal">false</span>);</div><div class="line">    d[s]=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> v=<span class="number">-1</span>;</div><div class="line">        <span class="comment">//从未被收录的点中找出一个距离最小的点</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;V;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(!used[j]&amp;&amp;(v==<span class="number">-1</span>||d[j]&lt;d[v]))v=j;  <span class="comment">//v==-1设置哨兵，确定有没有没被收录的点</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(v==<span class="number">-1</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        used[v]=<span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;i++)</div><div class="line">            d[i]=min(d[i],d[v]+cost[v][i]);  <span class="comment">//松弛操作</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> S,T;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;V,&amp;E)!=EOF)</div><div class="line">	&#123;</div><div class="line">		build();</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;S,&amp;T);</div><div class="line">		dijkstra(S);</div><div class="line">		<span class="keyword">int</span> ans=d[T];</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans==INF?<span class="number">-1</span>:ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">	solve();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论-最短路 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDU 2544 最短路 SPFA模板题]]></title>
      <url>/2017/05/14/HDU-2544-%E6%9C%80%E7%9F%AD%E8%B7%AF-SPFA%E6%A8%A1%E6%9D%BF%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2544" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=2544</a></p>
<a id="more"></a>
<h2 id="题意-amp-题解"><a href="#题意-amp-题解" class="headerlink" title="题意&amp;题解"></a>题意&amp;题解</h2><p>最短路模板题，以此题记录SPFA模板</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">10005</span>;</div><div class="line"><span class="keyword">int</span> visit[maxn],dist[maxn];</div><div class="line"><span class="keyword">int</span> n,m,id;</div><div class="line"></div><div class="line"><span class="comment">//链式前向星建图</span></div><div class="line"><span class="keyword">struct</span> Node</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> v,w,next;</div><div class="line">&#125;edges[maxm];</div><div class="line"><span class="keyword">int</span> head[maxn]; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span>   <span class="comment">//u到v的权值为w的边</span></span></div><div class="line">&#123;</div><div class="line">	edges[id].v=v;</div><div class="line">	edges[id].w=w;</div><div class="line">	edges[id].next=head[u];    <span class="comment">//把之前的第一条边作为当前边的最后一条边</span></div><div class="line">	head[u]=id++;              <span class="comment">//id为从0开始的标号</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//建图</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</div><div class="line">	<span class="keyword">int</span> u,v,w;</div><div class="line">	id=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;w);</div><div class="line">		addedge(u,v,w);</div><div class="line">		addedge(v,u,w);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> st)</span></span></div><div class="line">&#123;</div><div class="line">    fill(visit,visit+maxn,<span class="number">0</span>);   <span class="comment">//标记所有节点未被访问</span></div><div class="line">    fill(dist,dist+maxn,INF);   <span class="comment">//求最短路，初始化最大值</span></div><div class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</div><div class="line">    visit[st]=<span class="number">1</span>;</div><div class="line">    dist[st]=<span class="number">0</span>;</div><div class="line">    Q.push(st);</div><div class="line">    <span class="keyword">while</span> (!Q.empty())</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> now=Q.front();</div><div class="line">        Q.pop();</div><div class="line">        visit[now]=<span class="number">0</span>;           <span class="comment">//注意此处将该点标记为未访问</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i!=<span class="number">-1</span>;i=edges[i].next)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> v=edges[i].v;</div><div class="line">            <span class="keyword">int</span> w=edges[i].w;</div><div class="line">            <span class="keyword">if</span>(dist[v]&gt;dist[now]+w)   <span class="comment">//最短路松弛</span></div><div class="line">            &#123;</div><div class="line">                dist[v]=dist[now]+w;</div><div class="line">                <span class="keyword">if</span>(!visit[v])</div><div class="line">                &#123;</div><div class="line">                    Q.push(v);</div><div class="line">                    visit[v]=<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m)!=EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(n==<span class="number">0</span> &amp;&amp;m==<span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">		init();</div><div class="line">		spfa(<span class="number">1</span>);</div><div class="line">		<span class="keyword">int</span> ans=dist[n];</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">	solve();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论-最短路 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Codeforces 391 题解]]></title>
      <url>/2017/05/14/Codeforce-391-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>非常常规的一套Codeforces题解<br><a id="more"></a></p>
<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个字符串，求出其中最多能够组成单词“Bulbasaur”的个数（可以将字符串中的字母拆散）</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>用一个数组记录单词中各个字母的出现次数，出现次数最小的值就是能够组成的单词数</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span> s)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(s==<span class="string">'B'</span>)con[<span class="number">0</span>]++;</div><div class="line">    <span class="keyword">if</span>(s==<span class="string">'u'</span>)con[<span class="number">1</span>]++;</div><div class="line">    <span class="keyword">if</span>(s==<span class="string">'l'</span>)con[<span class="number">2</span>]++;</div><div class="line">    <span class="keyword">if</span>(s==<span class="string">'b'</span>)con[<span class="number">3</span>]++;</div><div class="line">    <span class="keyword">if</span>(s==<span class="string">'a'</span>)con[<span class="number">4</span>]++;</div><div class="line">    <span class="keyword">if</span>(s==<span class="string">'s'</span>)con[<span class="number">5</span>]++;</div><div class="line">    <span class="keyword">if</span>(s==<span class="string">'r'</span>)con[<span class="number">6</span>]++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">string</span> s;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s)</div><div class="line">    &#123;</div><div class="line">        fill(con,con+<span class="number">7</span>,<span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</div><div class="line">            judge(s[i]);</div><div class="line">        <span class="keyword">int</span> res=INF;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>||i==<span class="number">4</span>)</div><div class="line">                res=min(res,con[i]/<span class="number">2</span>);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                res=min(res,con[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出n个数，从这n个数中取出一个组合，使得这个组合中的最大公因子不为1，同时要组合中的数的个数要最大，输出这个组合中的数的个数</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><ul>
<li>首先求出范围内的素数集，然后把每一个素数当成组合中的最大公因子，看这个组合能够有大（看给出的这些数中有多少能够整除当前素数），最后取所有组合的模的最大值</li>
<li>对每一个数进行判断他是否是当前这个素数的倍数这样会造成时间超限，因此采用空间换时间的策略，为数据范围内的每一个数记录其出现次数，然后再将所有能够整除当前素数的值的出现次数进行相加（类似与埃式素数筛选法）</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> con[MAX];</div><div class="line"><span class="keyword">bool</span> is_prime[MAX];</div><div class="line"><span class="keyword">int</span> prime[MAX];</div><div class="line"><span class="keyword">int</span> num;</div><div class="line"></div><div class="line"><span class="comment">//素数筛选</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_pri</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    num=<span class="number">0</span>;</div><div class="line">    <span class="built_in">memset</span>(is_prime,<span class="number">1</span>,<span class="keyword">sizeof</span>(is_prime));</div><div class="line">    is_prime[<span class="number">0</span>]=is_prime[<span class="number">1</span>]=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAX;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(is_prime[i])</div><div class="line">        &#123;</div><div class="line">            prime[num++]=i;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;MAX;j+=i)</div><div class="line">                is_prime[j]=<span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    init_pri();</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">memset</span>(con,<span class="number">0</span>,<span class="keyword">sizeof</span>(con));</div><div class="line">        <span class="keyword">int</span> x;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;x;</div><div class="line">            con[x]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> tem=<span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=prime[i];j&lt;MAX;j+=prime[i])</div><div class="line">                tem+=con[j];     <span class="comment">//求出当前组合的模</span></div><div class="line">            res=max(res,tem);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ACM中常用的STL（二）]]></title>
      <url>/2017/05/13/ACM%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84STL%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>上一篇文章讲了STL里面常用容器的用法，这一篇文章将主要讲一场常用函数的用法以及后期补充的一些注意事项</p>
<a id="more"></a>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="next-permutation-prev-permutation-first-last"><a href="#next-permutation-prev-permutation-first-last" class="headerlink" title="next_permutation/prev_permutation(first,last)"></a>next_permutation/prev_permutation(first,last)</h3><p>转换所给区间内的元素到下一个字典序，成功返回TRUE，不成功返回FALSE（不存在下一个字典序）</p>
<h3 id="sort-stable-sort-first-last"><a href="#sort-stable-sort-first-last" class="headerlink" title="sort/stable_sort(first,last)"></a>sort/stable_sort(first,last)</h3><p>对区间内的进行排序，前者为稳定排序，后者为不稳定排序</p>
<h4 id="重载operate-lt-更改排序规则"><a href="#重载operate-lt-更改排序规则" class="headerlink" title="重载operate\&lt;更改排序规则"></a>重载operate\&lt;更改排序规则</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> node</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a,b;</div><div class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp; nodeb) <span class="keyword">const</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(a==nodeb.a)         <span class="comment">//确定优先级a比bda</span></div><div class="line">			<span class="keyword">return</span> b&lt;nodeb.b;</div><div class="line">		<span class="keyword">return</span> a&lt;nodeb.a;     <span class="comment">//优先最小值</span></div><div class="line">	&#125;</div><div class="line">&#125;s[maxn];</div></pre></td></tr></table></figure>
<h4 id="自定义排序函数更改排序规则"><a href="#自定义排序函数更改排序规则" class="headerlink" title="自定义排序函数更改排序规则"></a>自定义排序函数更改排序规则</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Cmp</span><span class="params">(<span class="keyword">const</span> node &amp;x,<span class="keyword">const</span> node &amp;y)</span>   <span class="comment">//自定义比较函数</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(x.a==y.a)                       <span class="comment">//a的优先级大于b</span></div><div class="line">		<span class="keyword">return</span> x.b&lt;y.b;</div><div class="line">	<span class="keyword">return</span> x.a&lt;y.a;                   <span class="comment">//最小值优先</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="partial-sort-first-middle-last"><a href="#partial-sort-first-middle-last" class="headerlink" title="partial_sort(first,middle,last)"></a>partial_sort(first,middle,last)</h3><p>对中间部分元素进行排序，缺省比较函数，可以用于求出最大（或者最小）的k个元素<br>类似的partial_sort_copy(first,last,d_first,d_last) 对部分元素（根据新的容器的范围）进行排序以后复制值新的容器内</p>
<h3 id="lower-bound-upper-bound-first-last-value"><a href="#lower-bound-upper-bound-first-last-value" class="headerlink" title="lower_bound/upper_bound(first,last,value)"></a>lower_bound/upper_bound(first,last,value)</h3><p>前者返回大于等于value的第一个数的迭代器，<br>后者返回大于value的第一个数的迭代器</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> STL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ACM中常用的STL （一）]]></title>
      <url>/2017/05/13/ACM%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84STL-%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>近期在在刷题的时候发现很多的STL的容器还有函数都用得不是很熟练。总所周知，在刷题的时候一些基本的STL的容器和函数的用法是必不可少的。<br>我将用两篇文章来整理一些常用的STL容器和函数的用法，这一篇主要讲容器</p>
<a id="more"></a>
<h2 id="共通能力"><a href="#共通能力" class="headerlink" title="共通能力"></a>共通能力</h2><p>所有容器中存放的都是值而非引用，即容器进行安插操作时内部实施的是拷贝操作。因此容器的每个元素必须能够被拷贝。如果希望存放的不是副本，容器元素只能是指针。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue 队列"></a>queue 队列</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>queue的定义需要两个参数，一个是元素类型，一个容器类型，元素类型是必要的，容器类型是可选的，默认为deque类型</p>
<h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><ul>
<li>push(x) 入队，将x接到队列的末端</li>
<li>pop() 出队，弹出队列的第一个元素，注意，并不会返回被弹出元素的值</li>
<li>front() 访问队首元素</li>
<li>back() 访问队尾元素</li>
<li>empty() 判断队列是否为空</li>
<li>size()  访问队列中的元素个数</li>
</ul>
<h3 id="priority-queue-优先队列"><a href="#priority-queue-优先队列" class="headerlink" title="priority_queue 优先队列"></a>priority_queue 优先队列</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>需要三个参数，一个是元素类型，一个是保存数据的容器类型（默认为vector），一个是比较方式（默认为less()方法，即最大值优先），后两个参数可以省去</p>
<h4 id="自定义比较方式"><a href="#自定义比较方式" class="headerlink" title="自定义比较方式"></a>自定义比较方式</h4><h5 id="改变第三个参数比较类"><a href="#改变第三个参数比较类" class="headerlink" title="改变第三个参数比较类"></a>改变第三个参数比较类</h5><p>使用greater比较类即为最小值优先，此时对容器类型不能够省略<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;que3;<span class="comment">//注意“&gt;&gt;”会被认为错误，    </span></div><div class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;que4;<span class="comment">////最大值优先</span></div></pre></td></tr></table></figure></p>
<h5 id="自定义比较类（结构体）"><a href="#自定义比较类（结构体）" class="headerlink" title="自定义比较类（结构体）"></a>自定义比较类（结构体）</h5><p>可以自定义一个规定对比方式的结构最为第三个参数进行传入，同上容器类型不能够省略<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义比较结构</span></div><div class="line"><span class="keyword">struct</span> cmp1&#123;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> a&gt;b;<span class="comment">//最小值优先</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> cmp2&#123;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> a&lt;b;<span class="comment">//最大值优先</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,cmp1&gt;que1;<span class="comment">//最小值优先</span></div><div class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,cmp2&gt;que2;<span class="comment">//最大值优先</span></div></pre></td></tr></table></figure></p>
<h5 id="重载operate-lt"><a href="#重载operate-lt" class="headerlink" title="重载operate&lt;"></a>重载operate&lt;</h5><p>我们也可以对数据结构中的operate&lt;进行重载，从而使用其默认的比较类。<br>这种方法也可以定义结构体中各个变量比较的一个优先级<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//自定义数据结构</span></div><div class="line"><span class="keyword">struct</span> number1&#123;</div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> number1 &amp;a) <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">return</span> x&gt;a.x;<span class="comment">//最小值优先</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> number2&#123;</div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> number2 &amp;a) <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">return</span> x&lt;a.x;<span class="comment">//最大值优先</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">    priority_queue&lt;number1&gt;que5; <span class="comment">//最小优先级队列</span></div><div class="line">    priority_queue&lt;number2&gt;que6;  <span class="comment">//最大优先级队列</span></div></pre></td></tr></table></figure></p>
<h4 id="基本方法-1"><a href="#基本方法-1" class="headerlink" title="基本方法"></a>基本方法</h4><ul>
<li>push(x) 插入元素并在容器中进行排序</li>
<li>pop() 移除堆顶元素</li>
<li>top() 获取堆顶元素</li>
<li>empty() 判断队列是否为空</li>
<li>size()  访问队列中的元素个数</li>
<li><h3 id="vector-动态数组"><a href="#vector-动态数组" class="headerlink" title="vector 动态数组"></a>vector 动态数组</h3></li>
</ul>
<h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>一般只使用到一个参数，数据类型参数</p>
<h4 id="基本方法-2"><a href="#基本方法-2" class="headerlink" title="基本方法"></a>基本方法</h4><ul>
<li>重载[]  可以通过下边获取元素</li>
<li>front() 返回第一个元素的值</li>
<li>end()  返回最后一个元素的值</li>
<li>begin()  返回第一个迭代器</li>
<li>end()  返回最后一个迭代器</li>
<li>empty() 判断是否为空</li>
<li>size()  获取元素个数</li>
<li>reserve()  反转数组</li>
<li>clear()  清楚所有元素</li>
<li>push_back(x)  在最后加入元素x</li>
<li>pop_back()</li>
</ul>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>可以看成是集合，容器内不含有重复元素<br>针对集合操作的算法函数见函数部分<br>multiset 与set相似，不同就是前者支持重复对象</p>
<h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>第一个参数是数据类型，第二个参数是比较类（默认为less\<key\>,最大值优先）</key\></p>
<h4 id="基本方法-3"><a href="#基本方法-3" class="headerlink" title="基本方法"></a>基本方法</h4><ul>
<li>begin()     　　 返回set容器的第一个元素的迭代器</li>
<li>end() 　　　　 ,返回set容器的最后一个元素的迭代器</li>
<li>clear()   　　     ,删除set容器中的所有的元素</li>
<li>empty() 　　　,判断set容器是否为空</li>
<li>size() 　　　　 ,返回当前set容器中的元素个数</li>
<li>count()              用来查找set中某个某个键值出现的次数。这个函数在set并不是很实用，因为一个键值在set只可能出现0或1次，这样就变成了判断某一键值是否在set出现过了。</li>
<li>erase(key_value)    ,  删除键值key_value的值</li>
<li>find()  ，       返回给定值值得定位器，如果没找到则返回end()。</li>
<li>insert(key_value);       将key_value插入到set中 ，返回值是pair\<set\<int\>::iterator,bool>，bool标志着插入是否成功，而iterator代表插入的位置，若key_value已经在set中，则iterator表示的key_value在set中的位置。</set\<int\></li>
<li>lower_bound(key_value) ，   返回第一个大于等于key_value的定位器</li>
<li>upper_bound(key_value)，   返回最后一个大于等于key_value的定位器</li>
</ul>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>自动建立Key － value的对应，可以根据key值快速查找记录。<br>multimap 用法与map用法相似，区别在于允许出现重复的key值</p>
<h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>第一个参数key类型，第二个参数value类型，第三个参数比较类（默认less\<key\>)</key\></p>
<h4 id="基本方法-4"><a href="#基本方法-4" class="headerlink" title="基本方法"></a>基本方法</h4><ul>
<li>重载[]  可以通过下标来修改/插入key-value</li>
<li>insert(key-value)   插入键值对，可以是pair\<key,value\>对，返回一个map的迭代器</key,value\></li>
<li>find(key)     根据key来查找键值对，返回一个map的迭代器</li>
<li>count(key)     返回键为key的键值对个数</li>
<li>lower_bound(key)    返回大于等于key的一个元素的迭代器</li>
<li>upper_bound(key)   返回大于key的第一个元素的迭代器</li>
</ul>
<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>添加头文件utility<br>提供存储将两种数据合在一起的数据类型一个数据类型。</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> STL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Codeforces 390 题解]]></title>
      <url>/2017/05/13/Codeforces%20390%20%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>这次Codeforces的A和B都是比较简单的，A就是贪心算法（我一开始在理解题意的时候出了一点问题），B就是蛮力枚举。<br>看懂题目的话我觉得每道题在20分钟之内将把代码写出来是没有问题的，可是英语还是硬伤，努力学英语中。。。</p>
<a id="more"></a>
<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你一个数组要求将他们进行划分成连续的几个部分，要求每个部分部分不为0</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul>
<li>无法划分的情况：数组中的各个都为0</li>
<li>对于剩下的情况，我一开始就只是统一处理：分成两组，第一组从1到最后一个不为0的前面一位，剩下的部分组成第二组。但是后来发现这样做是对于数组总和为0的时候可以，对于数组总和不为0时就是不对的，因为可能有第一组都是0的情况，所以还是要分两种情况讨论</li>
<li>数组总和不为0时，就分成一组</li>
<li>数组总和为0是，分成两组：第一组从1到最后一个不为0的数的前面一位，剩下的组成第二组</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>,tag=<span class="number">1</span>,u;</div><div class="line">		<span class="keyword">int</span> a[<span class="number">101</span>];</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cin</span>&gt;&gt;a[i];</div><div class="line">			sum+=a[i];</div><div class="line">			<span class="keyword">if</span>(a[i])  <span class="comment">//记录最后一个不为0的数字</span></div><div class="line">			&#123;</div><div class="line">				u=i+<span class="number">1</span>;</div><div class="line">				tag=<span class="number">0</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(tag)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">			<span class="keyword">return</span> ;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(sum)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"1"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"1"</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">			<span class="keyword">return</span> ;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span></div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"2"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"1"</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;u<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;u&lt;&lt;<span class="string">" "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>题目以小时候玩的井字旗为背景，给出残局，让你求出其中一方是否可以走一步就获得胜利（棋盘大小4*4）</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><ul>
<li>依次考虑每个空格，胜利有两种情况</li>
<li>中间和两边中的一个棋子是自己的，另一个是空格</li>
<li>两个自己的棋子夹一个空格</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> a[<span class="number">6</span>][<span class="number">6</span>];</div><div class="line"><span class="keyword">char</span> tl[<span class="number">2</span>]=&#123;<span class="string">'x'</span>,<span class="string">'o'</span>&#125;;</div><div class="line"><span class="keyword">int</span> dx[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</div><div class="line"><span class="keyword">int</span> dy[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> nu)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> xx=x+dx[i];</div><div class="line">        <span class="keyword">int</span> yy=y+dy[i];</div><div class="line">        <span class="keyword">if</span>(a[xx][yy]==tl[nu])</div><div class="line">        &#123;</div><div class="line">            xx=x-dx[i];</div><div class="line">            yy=y-dy[i];</div><div class="line">            <span class="keyword">if</span>(a[xx][yy]==<span class="string">'.'</span>)</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(a[xx][yy]==<span class="string">'.'</span>)</div><div class="line">        &#123;</div><div class="line">            xx=xx+dx[i];</div><div class="line">            yy=yy+dy[i];</div><div class="line">            <span class="keyword">if</span>(a[xx][yy]==tl[nu])</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> num1=<span class="number">0</span>,num2=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;a[i][j];</div><div class="line">            <span class="keyword">if</span>(a[i][j]==<span class="string">'x'</span>)</div><div class="line">                num1++;</div><div class="line">            <span class="keyword">if</span>(a[i][j]==<span class="string">'o'</span>)</div><div class="line">                num2++;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</div><div class="line">        a[i][<span class="number">0</span>]=a[<span class="number">0</span>][i]=a[<span class="number">6</span>][i]=a[i][<span class="number">6</span>]=<span class="string">'*'</span>;</div><div class="line">    <span class="keyword">int</span> be=<span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(num2&lt;num1)</div><div class="line">        be=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(a[i][j]==tl[be]&amp;&amp;judge(i,j,be))</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="简洁的代码"><a href="#简洁的代码" class="headerlink" title="简洁的代码"></a>简洁的代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</div><div class="line"><span class="keyword">int</span> dy[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</div><div class="line"><span class="keyword">char</span> s[<span class="number">10</span>][<span class="number">10</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">8</span>;k++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(s[i+dx[k]][j+dy[k]]==<span class="string">'x'</span>&amp;&amp;s[i+dx[k]*<span class="number">2</span>][j+dy[k]*<span class="number">2</span>]==<span class="string">'x'</span>)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">puts</span>(<span class="string">"YES"</span>);</div><div class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(s[i+dx[k]][j+dy[k]]==<span class="string">'x'</span>&amp;&amp;s[i-dx[k]][j-dy[k]]==<span class="string">'x'</span>)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">puts</span>(<span class="string">"YES"</span>);</div><div class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">5</span>;i++)<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i]+<span class="number">2</span>);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">5</span>;i++)<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=<span class="number">5</span>;j++)<span class="keyword">if</span>(s[i][j]==<span class="string">'.'</span>)check(i,j);</div><div class="line">	<span class="built_in">puts</span>(<span class="string">"NO"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>还是要多练，切水题的时间比较长，不能死在水题上面</li>
<li>看题目不能靠翻译，要锻炼自己的英语水平</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 3273 Monthly Expense 二分]]></title>
      <url>/2017/05/10/POJ-3273-Monthly-Expense-%E4%BA%8C%E5%88%86/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=3273" target="_blank" rel="external">http://poj.org/problem?id=3273</a></p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出包含n个元素的数组，将这n个元素分成最多m段，问各种分法中每段和的最大值得最小值是多少</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最小化最大值问题，使用二分进行求解，需要注意的是，在不断二分的时候边界更新的时候，当中间值不满足条件的时候，新的区间应该是[mid+1,r]，满足条件的时候新的区间应该是[l,mic].即要排除掉不满足条件的数</p>
<h2 id="代码-ing-namespace-std"><a href="#代码-ing-namespace-std" class="headerlink" title="代码                                                                            ing namespace std;"></a>代码                                                                            ing namespace std;</h2><p>#define INF 0x3f3f3f3f<br>typedef long long ll;<br>const int maxn=100010;<br>int n,m;<br>int d[maxn];</p>
<p>bool judge(int s)<br>{<br>    int num=0,tmp=0;<br>    for(int i=0;i&lt;n;i++)<br>    {<br>        if(tmp+d[i]&lt;=s) tmp+=d[i];<br>        else<br>        {<br>            //cout&lt;&lt;tmp&lt;&lt;” “;<br>            tmp=d[i];<br>            num++;<br>        }<br>    }<br>    if(tmp) num++;<br>    //cout&lt;&lt;num&lt;&lt;endl;<br>    return num&lt;=m;<br>}</p>
<p>int fun(int maxv,int sum)<br>{<br>    int l=maxv,r=sum,mid;<br>    while(l<r) {="" mid="l+((r-l)">&gt;1);<br>        mid=(l+r)/2;<br>        //cout&lt;&lt;l&lt;&lt;” “&lt;&lt;r&lt;&lt;” “&lt;&lt;mid&lt;&lt;endl;<br>        if(judge(mid)) r=mid;<br>        else l=mid+1;<br>    }<br>    return l;<br>}</r)></p>
<p>void solve()<br>{<br>    while(scanf(“%d %d”,&amp;n,&amp;m)!=EOF)<br>    {<br>        int sum=0,maxv=0;<br>        for(int i=0;i&lt;n;i++)<br>        {<br>            scanf(“%d”,&amp;d[i]);<br>            sum+=d[i];<br>            maxv=max(maxv,d[i]);<br>        }<br>        printf(“%d\n”,fun(maxv,sum));<br>    }<br>}</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 其他-二分 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 3258 River Hopscotch 二分]]></title>
      <url>/2017/05/09/POJ-3258-River-Hopscotch-%E4%BA%8C%E5%88%86/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=3258" target="_blank" rel="external">http://poj.org/problem?id=3258</a></p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一条河对岸中n个石子的坐标（加上起点和终点），现在移走m个石子，要求两个石子间的最小值最大，这个最大的最小值</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这个一道经典的二分题目，最大化最小值问题。在查找过程中判断一个数是否满足条件的时候，我们可以转化成判断满足这个最小值需要移走的石子数，通过跟给定的石子数进行比较来判断这个数是否满足条件。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50005</span>;</div><div class="line"><span class="keyword">int</span> l,n,m;</div><div class="line"><span class="keyword">int</span> d[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> s)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> j=<span class="number">0</span>,num=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(d[i]-d[j]&lt;s) num++;</div><div class="line">		<span class="keyword">else</span> j=i;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//cout&lt;&lt;"s:"&lt;&lt;s&lt;&lt;"num:"&lt;&lt;num&lt;&lt;"m:"&lt;&lt;m&lt;&lt;endl;</span></div><div class="line">	<span class="keyword">return</span> num&lt;=m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> ll=<span class="number">0</span>,rr=l+<span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span> mid;</div><div class="line">	<span class="keyword">while</span>(ll+<span class="number">1</span>&lt;rr)</div><div class="line">	&#123;</div><div class="line">		mid=(ll+rr)&gt;&gt;<span class="number">1</span>;</div><div class="line">		<span class="comment">//cout&lt;&lt;ll&lt;&lt;" "&lt;&lt;rr&lt;&lt;" "&lt;&lt;mid&lt;&lt;endl;</span></div><div class="line">		<span class="keyword">if</span>(judge(mid))</div><div class="line">			ll=mid;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			rr=mid;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ll;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;l,&amp;n,&amp;m)!=EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;d[i]);</div><div class="line">        d[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line">		d[n+<span class="number">1</span>]=l;</div><div class="line">		n+=<span class="number">2</span>;</div><div class="line">		sort(d,d+n);</div><div class="line">		<span class="keyword">int</span> ans=fun();</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 其他-二分 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Codeforces Round #412 Div 2 题解]]></title>
      <url>/2017/05/08/Codeforces-Round-412-Div-2-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>比赛链接：<a href="http://codeforces.com/contest/807" target="_blank" rel="external">http://codeforces.com/contest/807</a></p>
<a id="more"></a>
<h2 id="A-Is-it-rated"><a href="#A-Is-it-rated" class="headerlink" title="A Is it rated?"></a>A Is it rated?</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定多个比赛参与者比赛前后的积分，判断这场比赛有没有rated，对rated的定义：至少一个选手的积分发生变化，unrated定义：积分没有变化但是排名发生变化;maybe定义：分数没有变化，排名没变（非递增）</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先判断积分是否发生变化，然后判断是否非递减</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a[maxn],b[maxn];</div><div class="line">	<span class="keyword">int</span> t;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;t)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">bool</span> flag=<span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</div><div class="line">			<span class="built_in">cin</span>&gt;&gt;a[i]&gt;&gt;b[i];</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(a[i]!=b[i])</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"rated"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">				flag=<span class="number">0</span>;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(!flag)</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;a[i]&gt;a[i<span class="number">-1</span>])</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"unrated"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">				flag=<span class="number">0</span>;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(flag)</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"maybe"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="B-T-Shirt-Hunt"><a href="#B-T-Shirt-Hunt" class="headerlink" title="B T-Shirt Hunt"></a>B T-Shirt Hunt</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出一个选手这场比赛的排名和当前成绩和这场比赛可能的最差成绩，同时给出一个程序：<br>i := (s div 50) mod 475<br>repeat 25 times:<br>    i := (i * 96 + 42) mod 475<br>        print (26 + i)<br>程序输入一个积分，有25个输出每个输入表示可能的排名，问经过hacks以后达到能够输出当前排名的积分所需要进行成功的hacks次数是多少？</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>读懂题目这道题非常水，只要以50为单位不断在原来的基础进行加减直到达到符合要求的值，最后输出需要成功的hacks次数就行了</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> p)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i=(s/<span class="number">50</span>)%<span class="number">475</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">25</span>;j++)</div><div class="line">	&#123;</div><div class="line">		i=(i*<span class="number">96</span>+<span class="number">42</span>)%<span class="number">475</span>;</div><div class="line">		<span class="keyword">if</span>(<span class="number">26</span>+i==p)</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> p,x,y;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;p&gt;&gt;x&gt;&gt;y)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(fun(x,p))</div><div class="line">		&#123;</div><div class="line">			<span class="comment">//cout&lt;&lt;x&lt;&lt;endl;</span></div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">bool</span> flag=<span class="number">1</span>;</div><div class="line">		<span class="keyword">int</span> tmp=x<span class="number">-50</span>;</div><div class="line">		<span class="keyword">while</span>(tmp&gt;=y)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(fun(tmp,p))</div><div class="line">			&#123;</div><div class="line">				<span class="comment">//cout&lt;&lt;tmp&lt;&lt;endl;</span></div><div class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">                flag=<span class="number">0</span>;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			tmp-=<span class="number">50</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(!flag)</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		tmp=x+<span class="number">50</span>;</div><div class="line">		<span class="keyword">while</span>(tmp)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(fun(tmp,p))</div><div class="line">			&#123;</div><div class="line">				<span class="comment">//cout&lt;&lt;tmp&lt;&lt;endl;</span></div><div class="line">                <span class="keyword">int</span> ans=(tmp-x)/<span class="number">100</span>;</div><div class="line">				<span class="keyword">if</span>((tmp-x)%<span class="number">100</span>!=<span class="number">0</span>) ans++;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			tmp+=<span class="number">50</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="C-Success-Rate"><a href="#C-Success-Rate" class="headerlink" title="C Success Rate"></a>C Success Rate</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出两个分数：x/y p/q，定义两种操作：分子分母同时加上1；分母加上1。问要将前面的分数变成后面的分数要进行的操作数</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>前面的分数操作到后面的分数y是一定会变成q的倍数的，这样就相当于选择最小的倍数，写一个判断当前倍数是否符合条件的函数，然后再用二分法跑一边就行了，注意特判！</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judg</span><span class="params">(ll x,ll y,ll p,ll q,ll rate)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(rate*p&gt;=x &amp;&amp; rate*q-y&gt;=rate*p-x)</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(ll x,ll y,ll p,ll q,ll l,ll r)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> r;</div><div class="line">	<span class="keyword">if</span>(r==l+<span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(judg(x,y,p,q,l)) <span class="keyword">return</span> l;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(judg(x,y,p,q,r)) <span class="keyword">return</span> r;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;endl;</span></div><div class="line">	ll rate=y/q;</div><div class="line">	ll m=(l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span>(judg(x,y,p,q,m)) <span class="keyword">return</span> fun(x,y,p,q,l,m);</div><div class="line">	<span class="keyword">else</span> <span class="keyword">return</span> fun(x,y,p,q,m,r);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> t;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;t)</div><div class="line">	&#123;</div><div class="line">		ll x,y,p,q;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> id=<span class="number">0</span>;id&lt;t;id++)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;p&gt;&gt;q;</div><div class="line">			<span class="keyword">if</span>(x*q==p*y)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span>(p==q || (p==<span class="number">0</span> &amp;&amp; x!=<span class="number">0</span>)) </div><div class="line">			&#123;</div><div class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">			ll rate=fun(x,y,p,q,y/q,<span class="number">1e18</span>/q);</div><div class="line">			<span class="keyword">if</span>(rate==<span class="number">-1</span>)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;rate*q-y&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 1284 Primitive Roots 欧拉函数]]></title>
      <url>/2017/05/06/POJ-1284-Primitive-Roots-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=1284" target="_blank" rel="external">http://poj.org/problem?id=1284</a><br><a id="more"></a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>定义一个数原根x：{x^i(mod p) =1,2,…,p-1}，先给出素数p，要求p得原根个数</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这里用到了一个定理：<br>如果p有原根，则p的原根个数为Euler[Euler[p]]</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"></div><div class="line"><span class="built_in">map</span>&lt;ll,ll&gt; prime_factor(ll t)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">map</span>&lt;ll,ll&gt; ret;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=t;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">while</span>(t%i==<span class="number">0</span>) &#123; ++ret[i];t/=i; &#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(t!=<span class="number">1</span>) ret[t]=<span class="number">1</span>;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">Euler</span> <span class="params">(ll t)</span></span></div><div class="line">&#123;</div><div class="line">	ll ret=t;</div><div class="line">	<span class="built_in">map</span>&lt;ll,ll&gt; fac=prime_factor(t);</div><div class="line">	<span class="keyword">for</span>(<span class="built_in">map</span>&lt;ll,ll&gt;::iterator i=fac.begin();i!=fac.end();i++)</div><div class="line">		ret=ret*(i-&gt;first<span class="number">-1</span>)/i-&gt;first;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ll n;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n)!=EOF &amp;&amp; n)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Euler(Euler(n)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 2407 Relatives 欧拉函数]]></title>
      <url>/2017/05/06/POJ-2407-Relatives-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2407" target="_blank" rel="external">http://poj.org/problem?id=2407</a></p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个数n，求出有多少个数小于n并且与n互质，n的范围为1e9</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>裸的欧拉函数，具体的内容：<br>小于n且与n互质的数的个数=n*(1-1/P1)*(1-1/P2)….*(1-1/Pn)，其中Pn为不同的质因数<br>注意特判1的时候ans=0，不过本题没有卡这个东西</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"></div><div class="line"><span class="built_in">map</span>&lt;ll,ll&gt; prime_factor(ll t)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">map</span>&lt;ll,ll&gt; ret;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=t;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">while</span>(t%i==<span class="number">0</span>) &#123; ++ret[i];t/=i; &#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(t!=<span class="number">1</span>) ret[t]=<span class="number">1</span>;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">Euler</span> <span class="params">(ll t)</span></span></div><div class="line">&#123;</div><div class="line">	ll ret=t;</div><div class="line">	<span class="built_in">map</span>&lt;ll,ll&gt; fac=prime_factor(t);</div><div class="line">	<span class="keyword">for</span>(<span class="built_in">map</span>&lt;ll,ll&gt;::iterator i=fac.begin();i!=fac.end();i++)</div><div class="line">		ret=ret*(i-&gt;first<span class="number">-1</span>)/i-&gt;first;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ll n;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n)!=EOF &amp;&amp; n)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Euler(n));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Codeforces Round #411 (Div. 2) 题解]]></title>
      <url>/2017/05/05/Codeforces-Round-411-Div-2-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>比赛链接：<a href="http://codeforces.com/contest/805" target="_blank" rel="external">http://codeforces.com/contest/805</a></p>
<a id="more"></a>
<h2 id="A-Fake-NP"><a href="#A-Fake-NP" class="headerlink" title="A Fake NP"></a>A Fake NP</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个范围[l,r]，对于所有的从l到r的数的因子数中出现最多的因子数</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>可以发现除了范围内只有一个数，其他情况2都是出现次数最多的因子数</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> l,r;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(l==r)</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"2"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="B-3-palindrome"><a href="#B-3-palindrome" class="headerlink" title="B 3-palindrome"></a>B 3-palindrome</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>要求你创建一个仅含有a、b、c三个字符的长度为n的序列，要求序列中不含有长度为3的回文串,，并且要求含有c字符的数目尽可能少。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>“aabb”这样的字符创不断循环就不会含有长度为3的回文串</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">olve()</div><div class="line">&#123;</div><div class="line">	<span class="built_in">string</span> st=<span class="string">"aabb"</span>;</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> d=n/<span class="number">4</span>;</div><div class="line">		n%=<span class="number">4</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;d;i++)</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;st;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;st[i];</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="C-Find-Amir"><a href="#C-Find-Amir" class="headerlink" title="C Find Amir"></a>C Find Amir</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出编号为1到n的n个点，规定两点(i,j)之间的权值为(i+j)mod(n+1)，求将所有点连接起来的最小代价</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><ul>
<li>最小生成树问题，用贪心思想，发现将第1小的点和第1大的点配对，第2小的点和第2大的点配对，。。。（以此类推可以配对n/2条边）,这样的每次配对的代价都是0</li>
<li>这样两两结对以后（奇数情况下会多出一个点），再将第i大点和第i+1小的点配对，这种配对的每次代价为1。这样就可以生成一棵最小生成树，总体的代价就是后面的配对产生的代价：偶数时候为(n/2-1)，奇数的时候是n/2</li>
</ul>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(n%<span class="number">2</span>)</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;n/<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="built_in">cout</span>&lt;&lt;n/<span class="number">2</span><span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="D-Minimum-number-of-steps"><a href="#D-Minimum-number-of-steps" class="headerlink" title="D Minimum number of steps"></a>D Minimum number of steps</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出一个只含有字符a、b的字符串，规定一次操作为将原字符串的一个’ab’子串转换成’bba’，求转换成最终无法转换的状态要进行的操作次数（对10^9+7取模）</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><ul>
<li>操作完的最终状态应该是所有的字符a都换到了字符串的最后，同时每次操作我们可以看成a向后移动一位的过程，这样的话我们可以计算每个字符a到字符串最后全是a的部分的距离来对于这个a要进行的操作次数。</li>
<li>但是每次a向后移动一位对前面的a是有影响的————每向后移动一位对于前面的a相当于增加了一个b，也就是增加了前面的a到字符串最后的距离。这样我们可以从后往前进行考虑来统一这种影响。</li>
<li>从后往前扫描，用tmp记录中间b的个数，遇到a时累加到ans中同时对tmp加倍（相当于已经将当前的a转移到了最后，这样对于前面的a来说就是增加了tmp个b）。最后的答案就是所有操作的代价ans</li>
</ul>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">string</span> a;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a)</div><div class="line">	&#123;</div><div class="line">		ll tmp=<span class="number">0</span>,ans=<span class="number">0</span>,num=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=a.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(a[i]==<span class="string">'a'</span>)</div><div class="line">			&#123;</div><div class="line">				ans=(ans+tmp)%MOD;</div><div class="line">				tmp=(<span class="number">2</span>*tmp)%MOD;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span></div><div class="line">				tmp++;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>看清题意再敲代码，B题就是因为误以为是长度&gt;=3的回文子串而导致错了两发</li>
<li>提高debug水平，D题思路一直对但是因为else分支里面的一个错误导致迟迟没有AC</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDU 5686 斐波那契数+大数]]></title>
      <url>/2017/05/04/HDU-5686-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0-%E5%A4%A7%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5686" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5686</a></p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一个全部是1组成的序列，可以合并相邻的两个1，变成一个新的序列。问总共可以构成多少种不同的序列。序列长度范围为200</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题其实列出前几个数的答案可以观察得到是一个斐波那契数，当然也可以按照下面这种方式进行理解：<br>一个序列的组合方式可以分成两种情况：第一种情况是最后一个数不考虑那么相当于前面的n-1个数的排列种树；第二种情况将最后两个数合并这样就相当于前面n-2个数的排列情况<br>斐波那契数到达200个数，要使用大数模板，套上用就行了。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> BigInt</div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> nlen=<span class="number">4</span>;  <span class="comment">//控制数组中的每一个数字的长度，为了乘法运算不溢出设定为4</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> mod=<span class="number">10000</span>;    <span class="comment">//每个数字大小设定</span></div><div class="line">    <span class="keyword">short</span> n[<span class="number">1000</span>],len;  <span class="comment">//存放数字的数组以及数组的长度</span></div><div class="line">    BigInt()<span class="comment">//没有赋值时初始化为0</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">memset</span>(n,<span class="number">0</span>,<span class="keyword">sizeof</span>(n));</div><div class="line">        len=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    BigInt(<span class="keyword">int</span> num)<span class="comment">//数字为其赋值时，将数字4位4位存放在数组当中</span></div><div class="line">    &#123;</div><div class="line">        len=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            n[len++]=num%mod;</div><div class="line">            num/=mod;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    BigInt(<span class="keyword">const</span> <span class="keyword">char</span> *s)  <span class="comment">//字符串赋值时</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> l=<span class="built_in">strlen</span>(s);</div><div class="line">        len=l%nlen==<span class="number">0</span>?l/nlen:l/nlen+<span class="number">1</span>;<span class="comment">//确定数组长度</span></div><div class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-=nlen)<span class="comment">//每次处理数组中的一位</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> tmp=<span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> j=i-nlen+<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>(j&lt;<span class="number">0</span>) j=<span class="number">0</span>;<span class="comment">//最后面数字的处理</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;=i;k++)</div><div class="line">                tmp=tmp*<span class="number">10</span>+s[k]-<span class="string">'0'</span>;</div><div class="line">            n[index++]=tmp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    BigInt <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInt &amp;b)<span class="keyword">const</span> <span class="comment">//加法操作</span></div><div class="line">    &#123;</div><div class="line">        BigInt res;</div><div class="line">        res.len=max(len,b.len);  <span class="comment">//确定位数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++)</div><div class="line">        &#123;</div><div class="line">            res.n[i]+=(i&lt;len?n[i]:<span class="number">0</span>)+(i&lt;b.len?b.n[i]:<span class="number">0</span>); <span class="comment">//对象位置相加</span></div><div class="line">            res.n[i+<span class="number">1</span>]+=res.n[i]/mod; <span class="comment">//进位处理</span></div><div class="line">            res.n[i]=res.n[i]%mod;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(res.n[res.len]&gt;<span class="number">0</span>)res.len++;  <span class="comment">//最后的结果多出一位时</span></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    BigInt <span class="keyword">operator</span>*(<span class="keyword">const</span> BigInt &amp;b)<span class="keyword">const</span>  <span class="comment">//乘法操作</span></div><div class="line">    &#123;</div><div class="line">        BigInt res;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)  <span class="comment">//模拟过程</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> up=<span class="number">0</span>;  <span class="comment">//进位存储</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b.len;j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> tmp=n[i]*b.n[i]+up+res.n[i+j];</div><div class="line">                res.n[i+j]=tmp%mod;</div><div class="line">                up=tmp/mod;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(up!=<span class="number">0</span>)  <span class="comment">//处理一遍以后还有进位</span></div><div class="line">                res.n[i+b.len]=up;</div><div class="line">        &#125;</div><div class="line">        res.len=len+b.len;  <span class="comment">//先取到位数可能最大的值</span></div><div class="line">        <span class="keyword">while</span>(res.n[res.len<span class="number">-1</span>]==<span class="number">0</span>&amp;&amp;res.len&gt;<span class="number">1</span>)res.len--;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span>  <span class="comment">//输出时的逆序输出</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,n[len<span class="number">-1</span>]);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%04d"</span>,n[i]);   <span class="comment">//注意一定要加04,确保输出四位</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    BigInt a[<span class="number">210</span>];</div><div class="line">    a[<span class="number">1</span>]=<span class="number">1</span>;</div><div class="line">    a[<span class="number">2</span>]=<span class="number">2</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;<span class="number">201</span>;i++)</div><div class="line">        a[i]=a[i<span class="number">-1</span>]+a[i<span class="number">-2</span>];</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</div><div class="line">        a[n].show();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 2429 GCD & LCM Inverse 大素数分解]]></title>
      <url>/2017/05/01/POJ-2429-GCD-LCM-Inverse-%E5%A4%A7%E7%B4%A0%E6%95%B0%E5%88%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2429" target="_blank" rel="external">http://poj.org/problem?id=2429</a></p>
<a id="more"></a>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出两个数的最大公因数和最小公倍数（数据范围2^64），求这两个数（存在多组数时输出和最小的一组数）</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我们很容易得到以下方程： (a/gcd)*(b/gcd)=(lcm/gcd)。因为(a/gcd)和(b/gcd)一定是互质的（如果不互质，gcd就要改变），这样我们就可以看成是将(lcm/gcd)分解成互质的两个数。<br>使用Pollard-Rho算法算出大整数的素因子表，为了保证分解成的两个数是互质的，将素质因子表中相同的数进行相乘，可以证明这样得到的数组内的元素之间还是互质的。<br>最后只需要对表中的元素分成两组就行了，用一个简单的DFS就可以搞定。</p>
<h3 id="代码-处于Runtime-error"><a href="#代码-处于Runtime-error" class="headerlink" title="代码(处于Runtime error )"></a>代码(处于Runtime error )</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"></div><div class="line"><span class="comment">//Miller_Rabin 算法进行素数测试</span></div><div class="line"><span class="comment">//速度快，而且可以判断 &lt;2^63的数</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> S=<span class="number">20</span>; <span class="comment">//随机算法判定次数</span></div><div class="line"></div><div class="line"><span class="comment">//计算 (a*b)%c  加法快速幂</span></div><div class="line"><span class="function">ll <span class="title">mul_mod</span><span class="params">(ll a,ll b,ll c)</span></span></div><div class="line">&#123;</div><div class="line">	a%=c;</div><div class="line">	b%=c;</div><div class="line">	ll ret=<span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(b)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)</div><div class="line">			ret+=a,ret%=c;</div><div class="line">		a&lt;&lt;=<span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span>(a&gt;=c)a%=c;</div><div class="line">		b&gt;&gt;=<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 计算x^n %c</span></div><div class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll x,ll n,ll mod)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> x%mod;</div><div class="line">	x%=mod;</div><div class="line">	ll tmp=x;</div><div class="line">	ll ret=<span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(n)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) ret=mul_mod(ret,tmp,mod);</div><div class="line">		tmp=mul_mod(tmp,tmp,mod);</div><div class="line">		n&gt;&gt;=<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//以a为基,n-1=x*2^t      a^(n-1)=1(mod n)  验证n是不是合数</span></div><div class="line"><span class="comment">//一定是合数返回true,不一定返回false</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll a,ll n,ll x,ll t)</span></span></div><div class="line">&#123;</div><div class="line">	ll ret=pow_mod(a,x,n);</div><div class="line">	ll last=ret;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</div><div class="line">	&#123;</div><div class="line">		ret=mul_mod(ret,ret,n);</div><div class="line">		<span class="keyword">if</span>(ret==<span class="number">1</span> &amp;&amp; last!=<span class="number">1</span> &amp;&amp; last!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		last=ret;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(ret!=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Miller_Rabin()算法素数判定</span></div><div class="line"><span class="comment">//是素数返回true.(可能是伪素数，但概率极小)</span></div><div class="line"><span class="comment">//合数返回false;</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(ll n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//偶数</span></div><div class="line">	ll x=n<span class="number">-1</span>,t=<span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(!(x&amp;<span class="number">1</span>)) </div><div class="line">	&#123;</div><div class="line">		x&gt;&gt;=<span class="number">1</span>;</div><div class="line">		t++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S;i++)</div><div class="line">	&#123;</div><div class="line">		ll a=rand()%(n<span class="number">-1</span>)+<span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span>(check(a,n,x,t))</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// pollard_rho 算法进行质因数分解</span></div><div class="line">ll factor[<span class="number">10000</span>];   <span class="comment">//分解结果</span></div><div class="line"><span class="keyword">int</span> tol;    <span class="comment">//分解个数</span></div><div class="line"></div><div class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(a==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span>(a&lt;<span class="number">0</span>) <span class="keyword">return</span> gcd(-a,b);</div><div class="line">	<span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">Pollard_rho</span><span class="params">(ll x,ll c)</span></span></div><div class="line">&#123;</div><div class="line">	ll i=<span class="number">1</span>,k=<span class="number">2</span>;</div><div class="line">	ll x0=rand()%x;</div><div class="line">	ll y=x0;</div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		i++;</div><div class="line">        x0=(mul_mod(x0,x0,x)+c)%x;</div><div class="line">        ll d=gcd(y-x0,x);</div><div class="line">        <span class="keyword">if</span>(d!=<span class="number">1</span>&amp;&amp;d!=x) <span class="keyword">return</span> d;</div><div class="line">        <span class="keyword">if</span>(y==x0) <span class="keyword">return</span> x;</div><div class="line">        <span class="keyword">if</span>(i==k)&#123;y=x0;k+=k;&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//对n进行素因子分解</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">findfac</span><span class="params">(ll n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(Miller_Rabin(n))</div><div class="line">	&#123;</div><div class="line">		factor[tol++]=n;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	ll p=n;</div><div class="line">    <span class="keyword">while</span>(p&gt;=n)p=Pollard_rho(p,rand()%(n<span class="number">-1</span>)+<span class="number">1</span>);</div><div class="line">    findfac(p);</div><div class="line">    findfac(n/p);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//DFS 求数</span></div><div class="line">ll min_sum;   <span class="comment">//和的最小值设置为全局变量</span></div><div class="line">ll ansa,ansb;</div><div class="line">ll factor_new[<span class="number">10000</span>],num1;  <span class="comment">//将重复素因子相乘以后的表</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll tmpa,ll tmpb,ll pos,<span class="keyword">const</span> ll len)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(pos==len)</div><div class="line">	&#123;</div><div class="line">        <span class="keyword">if</span>(tmpa+tmpb&lt;=min_sum)</div><div class="line">		    ansa=tmpa,ansb=tmpb;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		dfs(tmpa*factor_new[pos],tmpb,pos+<span class="number">1</span>,len);</div><div class="line">		dfs(tmpa,tmpb*factor_new[pos],pos+<span class="number">1</span>,len);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ll a,b;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;a,&amp;b)!=EOF)</div><div class="line">	&#123;</div><div class="line">		num1=<span class="number">0</span>;</div><div class="line">		b/=a;</div><div class="line">		findfac(b);</div><div class="line">		sort(factor,factor+tol);    </div><div class="line">		factor_new[<span class="number">0</span>]=factor[<span class="number">0</span>];</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;tol;i++)                    <span class="comment">//除去重复素因子</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(factor[i]==factor[i<span class="number">-1</span>])</div><div class="line">				factor_new[num1]*=factor[i];</div><div class="line">			<span class="keyword">else</span></div><div class="line">				factor_new[++num1]=factor[i];</div><div class="line">		&#125;</div><div class="line">		min_sum=factor_new[<span class="number">0</span>]+b/factor_new[<span class="number">0</span>];</div><div class="line">		dfs(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,num1+<span class="number">1</span>);    <span class="comment">//dfs 枚举结果</span></div><div class="line">		<span class="keyword">if</span>(ansa&gt;ansb) swap(ansa,ansb);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>,ansa*a,ansb*a);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line"></div><div class="line">    <span class="comment">//test();</span></div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 1811 Prime Test /Miller-Rabin素数测试+Pollard Rho 大整数分解]]></title>
      <url>/2017/05/01/POJ-1811-Prime-Test-Miller-Rabin%E7%B4%A0%E6%95%B0%E6%B5%8B%E8%AF%95-Pollard-Rho-%E5%A4%A7%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>题目连接：<a href="http://poj.org/problem?id=1811" target="_blank" rel="external">http://poj.org/problem?id=1811</a></p>
<a id="more"></a>
<h3 id="Miller-Rabin素数测试"><a href="#Miller-Rabin素数测试" class="headerlink" title="Miller-Rabin素数测试"></a>Miller-Rabin素数测试</h3><p>该算法是随机算法，可以用来检测一个很大的数字（2^64范围)是不是素数。主要基于两个定理：费马小定理和二次探测定理<br>学习链接：<br><a href="https://www.cnblogs.com/jianglangcaijin/p/3446859.html" target="_blank" rel="external">Miller-Rabin素数测试学习小计</a><br><a href="https://www.cnblogs.com/vongang/archive/2012/03/15/2398626.html" target="_blank" rel="external">Miller-Rabin素数测试学习笔记</a><br><a href="https://www.cnblogs.com/kuangbin/archive/2012/08/19/2646404.html" target="_blank" rel="external">kuangbin 模板</a></p>
<h3 id="Pollard-Rho-大整数分解"><a href="#Pollard-Rho-大整数分解" class="headerlink" title="Pollard Rho 大整数分解"></a>Pollard Rho 大整数分解</h3><p>该算法是试除法和筛选法之外对比较大的整数的分解算法<br>学习链接：<br><a href="http://www.voidcn.com/blog/fsqfang/article/p-3803935.html" target="_blank" rel="external">Pollard Rho 大整数分解</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个非常大的数（2^54范围），如果这个数是素数，则输出Prime ，否则输出其最小的素因子</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>套用Miller-Rabin算法和Pollard-rho算法的模板题</p>
<h3 id="代码（模板）"><a href="#代码（模板）" class="headerlink" title="代码（模板）"></a>代码（模板）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Miller_Rabin 算法进行素数测试</span></div><div class="line"><span class="comment">//速度快，而且可以判断 &lt;2^63的数</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> S=<span class="number">20</span>; <span class="comment">//随机算法判定次数</span></div><div class="line"></div><div class="line"><span class="comment">//计算 (a*b)%c  加法快速幂</span></div><div class="line"><span class="function">ll <span class="title">mul_mod</span><span class="params">(ll a,ll b,ll c)</span></span></div><div class="line">&#123;</div><div class="line">	a%=c;</div><div class="line">	b%=c;</div><div class="line">	ll ret=<span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(b)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)</div><div class="line">			ret+=a,ret%=c;</div><div class="line">		a&lt;&lt;=<span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span>(a&gt;=c)a%=c;</div><div class="line">		b&gt;&gt;=<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 计算x^n %c</span></div><div class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll x,ll n,ll mod)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> x%mod;</div><div class="line">	x%=mod;</div><div class="line">	ll tmp=x;</div><div class="line">	ll ret=<span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(n)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) ret=mul_mod(ret,tmp,mod);</div><div class="line">		tmp=mul_mod(tmp,tmp,mod);</div><div class="line">		n&gt;&gt;=<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//以a为基,n-1=x*2^t      a^(n-1)=1(mod n)  验证n是不是合数</span></div><div class="line"><span class="comment">//一定是合数返回true,不一定返回false</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll a,ll n,ll x,ll t)</span></span></div><div class="line">&#123;</div><div class="line">	ll ret=pow_mod(a,x,n);</div><div class="line">	ll last=ret;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</div><div class="line">	&#123;</div><div class="line">		ret=mul_mod(ret,ret,n);</div><div class="line">		<span class="keyword">if</span>(ret==<span class="number">1</span> &amp;&amp; last!=<span class="number">1</span> &amp;&amp; last!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		last=ret;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(ret!=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Miller_Rabin()算法素数判定</span></div><div class="line"><span class="comment">//是素数返回true.(可能是伪素数，但概率极小)</span></div><div class="line"><span class="comment">//合数返回false;</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(ll n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//偶数</span></div><div class="line">	ll x=n<span class="number">-1</span>,t=<span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(!(x&amp;<span class="number">1</span>)) </div><div class="line">	&#123;</div><div class="line">		x&gt;&gt;=<span class="number">1</span>;</div><div class="line">		t++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S;i++)</div><div class="line">	&#123;</div><div class="line">		ll a=rand()%(n<span class="number">-1</span>)+<span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span>(check(a,n,x,t))</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// pollard_rho 算法进行质因数分解</span></div><div class="line">ll factor[<span class="number">100</span>];   <span class="comment">//分解结果</span></div><div class="line"><span class="keyword">int</span> tol;    <span class="comment">//分解个数</span></div><div class="line"></div><div class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(a==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span>(a&lt;<span class="number">0</span>) <span class="keyword">return</span> gcd(-a,b);</div><div class="line">	<span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">Pollard_rho</span><span class="params">(ll x,ll c)</span></span></div><div class="line">&#123;</div><div class="line">	ll i=<span class="number">1</span>,k=<span class="number">2</span>;</div><div class="line">	ll x0=rand()%x;</div><div class="line">	ll y=x0;</div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		i++;</div><div class="line">        x0=(mul_mod(x0,x0,x)+c)%x;</div><div class="line">        ll d=gcd(y-x0,x);</div><div class="line">        <span class="keyword">if</span>(d!=<span class="number">1</span>&amp;&amp;d!=x) <span class="keyword">return</span> d;</div><div class="line">        <span class="keyword">if</span>(y==x0) <span class="keyword">return</span> x;</div><div class="line">        <span class="keyword">if</span>(i==k)&#123;y=x0;k+=k;&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//对n进行素因子分解</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">findfac</span><span class="params">(ll n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(Miller_Rabin(n))</div><div class="line">	&#123;</div><div class="line">		factor[tol++]=n;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	ll p=n;</div><div class="line">    <span class="keyword">while</span>(p&gt;=n)p=Pollard_rho(p,rand()%(n<span class="number">-1</span>)+<span class="number">1</span>);</div><div class="line">    findfac(p);</div><div class="line">    findfac(n/p);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> t;</div><div class="line">	ll n;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</div><div class="line">	<span class="keyword">while</span>(t--)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</div><div class="line">		<span class="keyword">if</span>(Miller_Rabin(n))</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"Prime\n"</span>);</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		tol=<span class="number">0</span>;</div><div class="line">		findfac(n);</div><div class="line">		ll ans=factor[<span class="number">0</span>];</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;tol;i++)</div><div class="line">			ans=min(ans,factor[i]);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 2689 Prime Distance 埃拉托色尼筛法]]></title>
      <url>/2017/04/30/POJ-2689-Prime-Distance-%E5%9F%83%E6%8B%89%E6%89%98%E8%89%B2%E5%B0%BC%E7%AD%9B%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2689" target="_blank" rel="external">http://poj.org/problem?id=2689</a></p>
<a id="more"></a>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个区间[L,R],求这个区间内的连续两个素数之间的差最大和最小的两个素数，范围限制为1&lt;=L&lt; U&lt;=2,147,483,647。但是所给的区间长度不会超过1000000。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对于这个范围，全部筛选打表是不现实的，想到了只对区间内的素数进行筛选。这里用到了一个埃拉托色尼筛法的定理：<strong>如果n是一个合数，那么n一定有一个不超过sqrt(n)的素因子</strong>。这样我们只需要对前面5万个数的素数进行打表就行了。<br>枚举前面的素数，将对应区间内的合数进行删除，达到筛选的目的。同时计算素数对应到区间的倍数避免一个一个枚举，实现加速。<br>要注意新素数表中一些细节的处理，比如说排除值为1的情况。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000003</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxp=<span class="number">50050</span>;</div><div class="line"><span class="keyword">bool</span> is_prime[maxp];</div><div class="line"><span class="keyword">int</span> prime[maxp],num;</div><div class="line"><span class="keyword">bool</span> is_prime2[maxn];</div><div class="line">ll prime2[maxn],num2;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime_init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	num=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(is_prime,<span class="literal">true</span>,<span class="keyword">sizeof</span>(is_prime));</div><div class="line">	is_prime[<span class="number">0</span>]=is_prime[<span class="number">1</span>]=<span class="literal">false</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxp;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(is_prime[i]) prime[num++]=i;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num &amp;&amp; i*prime[j]&lt;maxp;j++)</div><div class="line">		&#123;</div><div class="line">			is_prime[i*prime[j]]=<span class="literal">false</span>;</div><div class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bigger_prime</span><span class="params">(ll L,ll R)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">memset</span>(is_prime2,<span class="number">1</span>,<span class="keyword">sizeof</span>(is_prime2));</div><div class="line">    ll mul;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num &amp;&amp; prime[i]&lt;=R;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(prime[i]&lt;=L)</div><div class="line">            mul=(L-prime[i])/prime[i];           <span class="comment">//获得相差的倍数</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            mul=<span class="number">2</span>;</div><div class="line">		<span class="keyword">while</span>(mul*prime[i]&lt;L || mul&lt;=<span class="number">1</span>) mul++;     <span class="comment">//修正倍数值,不能够等于一</span></div><div class="line">		<span class="keyword">for</span>(ll j=mul*prime[i];j&lt;=R;j+=prime[i])</div><div class="line">			<span class="keyword">if</span>(j&gt;=L)</div><div class="line">                is_prime2[j-L]=<span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">    num2=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=R-L;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(is_prime2[i])</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i+L==<span class="number">1</span>) <span class="keyword">continue</span>;   <span class="comment">//注意要排除1这个不是素数的数</span></div><div class="line">            prime2[num2++]=i+L;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ll L,R;</div><div class="line">	prime_init();</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;L,&amp;R)!=EOF)</div><div class="line">	&#123;</div><div class="line">		bigger_prime(L,R);</div><div class="line">		ll maxv=<span class="number">0</span>,minv=INF,maxid,minid;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num2<span class="number">-1</span>;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(maxv&lt;prime2[i+<span class="number">1</span>]-prime2[i])</div><div class="line">                maxv=prime2[i+<span class="number">1</span>]-prime2[i],maxid=i;</div><div class="line">            <span class="keyword">if</span>(minv&gt;prime2[i+<span class="number">1</span>]-prime2[i])</div><div class="line">                minv=prime2[i+<span class="number">1</span>]-prime2[i],minid=i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(num2&lt;<span class="number">2</span>)</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"There are no adjacent primes.\n"</span>);</div><div class="line">		<span class="keyword">else</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%lld,%lld are closest, %lld,%lld are most distant.\n"</span>,prime2[minid],prime2[minid+<span class="number">1</span>],prime2[maxid],prime2[maxid+<span class="number">1</span>]);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 1730 Perfect Pth Powers 素数分解]]></title>
      <url>/2017/04/30/POJ-1730-Perfect-Pth-Powers-%E7%B4%A0%E6%95%B0%E5%88%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>题目链接： <a href="http://poj.org/problem?id=1730" target="_blank" rel="external">http://poj.org/problem?id=1730</a></p>
<a id="more"></a>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如果一个数x能够被表示成b^p这样的形式，称x为完美p次方数，现在给出x求最大的p使得其为一个完美p次方树</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>利用素数分解，如果x为正数的话，最大的p就是这个数的素因子幂级数的最大公因数。<br>如果x为奇数的话，先转化为正数进行计算，最后将结果不断除2直到变成奇数。因为偶次方是不可能得到一个正数的。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">t ll maxp=<span class="number">100003</span>;</div><div class="line"><span class="keyword">bool</span> is_prime[maxp];</div><div class="line"><span class="keyword">int</span> prime[maxp],num;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime_init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	num=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(is_prime,<span class="literal">true</span>,<span class="keyword">sizeof</span>(is_prime));</div><div class="line">	is_prime[<span class="number">0</span>]=is_prime[<span class="number">1</span>]=<span class="literal">false</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxp;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(is_prime[i]) prime[num++]=i;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num &amp;&amp; i*prime[j]&lt;maxp;j++)</div><div class="line">		&#123;</div><div class="line">			is_prime[i*prime[j]]=<span class="literal">false</span>;</div><div class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ll x;</div><div class="line">	prime_init();</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x)!=EOF &amp;&amp; x)</div><div class="line">	&#123;</div><div class="line">		ll ans=<span class="number">-1</span>,i=<span class="number">0</span>,tmp;</div><div class="line">		<span class="keyword">bool</span> flag=<span class="number">0</span>;</div><div class="line">		<span class="keyword">if</span>(x&lt;<span class="number">0</span>)</div><div class="line">			x=-x,flag=<span class="number">1</span>;</div><div class="line">		<span class="keyword">while</span>(x!=<span class="number">1</span> &amp;&amp; i&lt;num<span class="number">-1</span>)</div><div class="line">		&#123;</div><div class="line">			tmp=<span class="number">0</span>;</div><div class="line">			<span class="keyword">while</span>(x%prime[i]==<span class="number">0</span>)</div><div class="line">			&#123;</div><div class="line">				tmp++;</div><div class="line">				x/=prime[i];</div><div class="line">			&#125;</div><div class="line">			i++;</div><div class="line">			ans=ans==<span class="number">-1</span>?tmp:gcd(ans,tmp);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(x!=<span class="number">1</span>) ans=<span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span>(flag)      <span class="comment">//如果是负数的话将ans变为奇数</span></div><div class="line">			<span class="keyword">while</span>(ans%<span class="number">2</span>==<span class="number">0</span>)</div><div class="line">				ans/=<span class="number">2</span>;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Codeforces Educational Round 20 题解]]></title>
      <url>/2017/04/30/Codeforces-Educational-Round-20-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>比赛链接：<a href="http://codeforces.com/contest/803" target="_blank" rel="external">http://codeforces.com/contest/803</a></p>
<a id="more"></a>
<h2 id="A-Maximal-Binary-Matrix"><a href="#A-Maximal-Binary-Matrix" class="headerlink" title="A Maximal Binary Matrix"></a>A Maximal Binary Matrix</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个n*n的全0矩阵，用k个1进行填充，使得填充后的矩阵是对称的并且还是字典序最大的（第一矩阵的字典序大于另一个矩阵定义：从上往下的第一个不同行的第一个不同数字前者大于后者）。最后要求输出这个矩阵</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>模拟填充过程，从上往下、从左往右依次进行填充。一次填充填充对称位置的两个点。<br>无解情况：填充数大于矩阵中点的个数</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i][j]);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;             </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n,k;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</div><div class="line">		<span class="keyword">if</span>(k&gt;n*n)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"-1\n"</span>); </div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span>(i==j &amp;&amp; k&gt;<span class="number">0</span>)</div><div class="line">				&#123;</div><div class="line">					a[i][i]=<span class="number">1</span>;</div><div class="line">					k--;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span>(i!=j &amp;&amp; !a[i][j] &amp;&amp; k&gt;<span class="number">1</span>)</div><div class="line">				&#123;</div><div class="line">					a[i][j]=a[j][i]=<span class="number">1</span>;</div><div class="line">					k-=<span class="number">2</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		out(n);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="B-Distances-to-Zero"><a href="#B-Distances-to-Zero" class="headerlink" title="B Distances to Zero"></a>B Distances to Zero</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出一个序列，求序列中各个元素的值到最近的元素值为0的元素的距离</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>我想到的方法是从序列中的元素值为0的位置出发，不断更新周围元素到0的距离，直到出界或者找到新的0为止<br>看到一个大牛的方法是，从左到右进行一次遍历，通过元素与左边的0的最小距离来更新距离值，再从右向左遍历一次，通过元素与右边的0的最小距离再更新一次距离值。<br>虽然两者的时间复杂度都是O(n)，但是明显后者的代码量和简介程度都比前者更优</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</div><div class="line">	&#123;</div><div class="line">        fill(b,b+n,n);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">			<span class="built_in">cin</span>&gt;&gt;a[i];</div><div class="line">		<span class="keyword">int</span> lst=-n;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(a[i]==<span class="number">0</span>)</div><div class="line">				lst=i;</div><div class="line">			b[i]=min(b[i],i-lst);</div><div class="line">		&#125;</div><div class="line">		lst=<span class="number">2</span>*n;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(a[i]==<span class="number">0</span>)</div><div class="line">				lst=i;</div><div class="line">			b[i]=min(b[i],lst-i);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,b[i]);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="C-Maximal-GCD"><a href="#C-Maximal-GCD" class="headerlink" title="C Maximal GCD"></a>C Maximal GCD</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出一个正整数n和k，要求将n分解成一个严格递增的序列，并且使得这个序列的最大公因数尽可能大</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><ul>
<li>先给出最大公因数一个范围，再枚举范围内的值，考虑合法性，选取最优解</li>
<li>求最大公因数的范围用到了一个贪心思想，因为序列是严格递增的，最大只所对应的序列就应该是1到k倍公因数的值进行排列</li>
<li>枚举的值是否合法无非就是判断是否能够整除n</li>
<li>!!防止越界，对于超过int范围的题目，所有的变量声明都用long long !! </li>
</ul>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ll n,k;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(k&gt;(ll)<span class="number">1e8</span>)     <span class="comment">//分割的段数过大不存在解</span></div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);	</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		ll b=n/(k*(k+<span class="number">1</span>)/<span class="number">2</span>);</div><div class="line">		<span class="keyword">if</span>(b==<span class="number">0</span>)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		ll r=<span class="number">1</span>;       <span class="comment">//最大公因数</span></div><div class="line">		<span class="keyword">for</span>(ll x=<span class="number">1</span>;x*x&lt;=n;x++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(n%x!=<span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">			<span class="keyword">if</span>(x&lt;=b &amp;&amp; x&gt;r) r=x;</div><div class="line">			<span class="keyword">if</span>(n/x&lt;=b &amp;&amp; n/x&gt;r) r=n/x;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;k;i++)</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;i*r&lt;&lt;<span class="string">" "</span>;</div><div class="line">		ll tmp=n-(k*(k<span class="number">-1</span>)/<span class="number">2</span>)*r;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;tmp&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[月亮湾 游记]]></title>
      <url>/2017/04/29/%E6%9C%88%E4%BA%AE%E6%B9%BE-%E6%B8%B8%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>挺过学校变态的一周三场考试，终于迎来了五一假，出去浪的心油然而生。加上最近前段时间换了一辆山地车，所以就有了这波游玩。拉上两个同学来了一场短途骑行。</p>
<a id="more"></a>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>这次我们去的是月亮湾风景区，一个普通的看山山水水的地方。离学校直线距离26km，导航距离32km。贴吧上看学长骑过这条路线，觉得风景不错，就准备了这次骑行。路程的一大半是在省道上，一半是在那种山间小路上，我们主要享受的山间小路上的风景。</p>
<h3 id="出发"><a href="#出发" class="headerlink" title="出发"></a>出发</h3><p>因为一些原因，原计划早上出发的变成了下午3点出发。那时刚好是太阳比较大的时候，但是气温不是很高，所以整体上不是很热。因为一个同学是第一次骑这么长的距离，加上车子存在一些问题（很久没有上油了），我们在去的路上走走停停花了三个多小时。我因为一开始买的都是水，没有买什么补充能量的东西，骑到后面一段距离的时候就有点吃力了。<br>印象比较深的是，靠近目的地有一段非常大而且坡度也比较大的斜坡，一不小心车速就达到了50km/h创下了我骑车的最快速度。那个感觉不要太爽。<br><img src="http://oeziv5rwi.bkt.clouddn.com/2017/4/29/001.png" alt=""></p>
<h3 id="游玩"><a href="#游玩" class="headerlink" title="游玩"></a>游玩</h3><p>因为我们骑到月亮湾的时候已经下午六点多了，天马上就要黑了，所以只有先休息一晚，第二天再考虑玩的事情。我们找了一个当地的小旅馆，价格不错，老板人不错。<br>解决晚餐问题之后我们在镇子的周围逛了逛。比较尴尬的是我们骑出去一公里的时候一个同学的车坏了，后轮根本动不了。没有办法只有两个人抬一辆车，另一个人推两辆车回到镇子上修。到了镇子上又发现那些摩托车维修的店子都关门了，看来要我们自己动手了。幸好旅店的老板来帮了一下我们提供了我们很多工具。最好没有解决根本问题，但是车子可以骑了，所以决定回去以后再说。<br>第二天一早，我们就开始骑向所谓的风景区。其实就是一条沿河而行的风景比较优美的公路。风景比路上的风景好一点点。<br><img src="http://oeziv5rwi.bkt.clouddn.com/2017/4/29/003.jpg" alt=""><br><img src="http://oeziv5rwi.bkt.clouddn.com/2017/4/29/004.jpg" alt=""><br><img src="http://oeziv5rwi.bkt.clouddn.com/2017/4/29/005.jpg" alt=""></p>
<h3 id="返程"><a href="#返程" class="headerlink" title="返程"></a>返程</h3><p>大概在风景区里面逛了一下（走了10km左右），我们就准备返程了。主要是因为下午比较热，而且这次旅行的主要目的就是享受骑行沿途的风景。吸取来的时候的教训，我准备了一些补充能量的巧克力和运动饮料。返程的整体车速比较快，在s322省道基本上车速能够保持在25km/h左右，下坡的时候在40km/h左右。除此之外我们在返程的途中只休息了一次，所以回来用了不到两个小时的时间。看来在去的时候路上休息的时间太长了。<br><img src="http://oeziv5rwi.bkt.clouddn.com/2017/4/29/002.png" alt=""></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>骑车出游车要修好，保证不要在路上出问题</li>
<li>出发前准备好补充水分和能量的东西</li>
<li>风景很美，心情很好，下次再来！</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 杂记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 3126 Prime Path 素数打表+BFS]]></title>
      <url>/2017/04/26/POJ-3126-Prime-Path-%E7%B4%A0%E6%95%B0%E6%89%93%E8%A1%A8-BFS/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=3126" target="_blank" rel="external">http://poj.org/problem?id=3126</a></p>
<a id="more"></a>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一次操作的定义，将一个四位数的一位转换成另外一位数字（不含前导0）。同时给出两位素数，求中间需要进过多少次这样的操作才能够从开始的哪一位素数达到后面的那一位素数，而且必须满足中间进过的数都是素数.</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul>
<li>使用BFS搜索路径，同时记录搜索路径的长度</li>
<li>用结构体将一个数和搜索到这个数是已经走过的步数绑定起来</li>
<li>数字用string表示，便于进行操作，只需对对应的字符进行操作即可</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10005</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxp=<span class="number">10005</span>;</div><div class="line"><span class="keyword">bool</span> is_prime[maxp];</div><div class="line"><span class="keyword">int</span> prime[maxp],num;</div><div class="line"><span class="keyword">int</span> visit[maxn];</div><div class="line"><span class="keyword">struct</span> poin</div><div class="line">&#123;</div><div class="line">	<span class="built_in">string</span> num;</div><div class="line">	<span class="keyword">int</span> step;</div><div class="line">	poin(<span class="built_in">string</span> num,<span class="keyword">int</span> step):num(num),step(step) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>    <span class="comment">//欧拉筛选素数打表</span></span></div><div class="line">&#123;</div><div class="line">	num=<span class="number">0</span>;</div><div class="line">    <span class="built_in">memset</span>(is_prime,<span class="literal">true</span>,<span class="keyword">sizeof</span>(is_prime));</div><div class="line">	is_prime[<span class="number">0</span>]=is_prime[<span class="number">1</span>]=<span class="literal">false</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxp;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(is_prime[i]) prime[num++]=i;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num &amp;&amp; i*prime[j]&lt;maxp;j++)</div><div class="line">		&#123;</div><div class="line">			is_prime[i*prime[j]]=<span class="literal">false</span>;</div><div class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> t;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;t;</div><div class="line">	<span class="built_in">string</span> a,b;</div><div class="line">	<span class="keyword">while</span>(t--)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</div><div class="line">		<span class="keyword">int</span> ans=<span class="number">-1</span>;</div><div class="line">		init();</div><div class="line">		<span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</div><div class="line">		<span class="built_in">queue</span>&lt;poin&gt; que;</div><div class="line">		que.push(poin(a,<span class="number">0</span>));</div><div class="line">		<span class="keyword">while</span>(!que.empty())</div><div class="line">		&#123;</div><div class="line">			poin p=que.front();</div><div class="line">			que.pop();</div><div class="line">			<span class="keyword">if</span>(p.num==b)</div><div class="line">			&#123;</div><div class="line">				ans=p.step;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">int</span> be= (i==<span class="number">0</span>)?<span class="number">1</span>:<span class="number">0</span>;</div><div class="line">				<span class="built_in">string</span> c=p.num;</div><div class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=be;j&lt;<span class="number">10</span>;j++)</div><div class="line">				&#123;</div><div class="line">					c[i]=j+<span class="string">'0'</span>;</div><div class="line">					<span class="keyword">int</span> next=atoi(c.c_str());</div><div class="line">					<span class="keyword">if</span>(!visit[next] &amp;&amp; is_prime[next] &amp;&amp;c!=p.num)  <span class="comment">//防止出不来了</span></div><div class="line">					&#123;</div><div class="line">						<span class="comment">//cout&lt;&lt;c&lt;&lt;endl;</span></div><div class="line">						visit[next]=<span class="number">1</span>;</div><div class="line">						que.push(poin(c,p.step+<span class="number">1</span>));</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 2739 素数打表+暴力枚举]]></title>
      <url>/2017/04/24/POJ-2739-%E7%B4%A0%E6%95%B0%E6%89%93%E8%A1%A8-%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/</url>
      <content type="html"><![CDATA[<p>题目连接：<a href="http://poj.org/problem?id=2739" target="_blank" rel="external">http://poj.org/problem?id=2739</a></p>
<a id="more"></a>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个数，问其有多少种方案能够分解成连续多个素数的和</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>因为这道题的数据规模只有10000所以完全可以暴力解决，首先使用欧拉筛选得到素数表，枚举所有在数据范围内的连续素数和，打表。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxp=<span class="number">10005</span>;</div><div class="line"><span class="keyword">bool</span> is_prime[maxp];</div><div class="line"><span class="keyword">int</span> prime[maxp],num;</div><div class="line"><span class="keyword">int</span> a[maxp];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>    <span class="comment">//欧拉筛选素数打表</span></span></div><div class="line">&#123;</div><div class="line">	num=<span class="number">0</span>;</div><div class="line">    <span class="built_in">memset</span>(is_prime,<span class="literal">true</span>,<span class="keyword">sizeof</span>(is_prime));</div><div class="line">	is_prime[<span class="number">0</span>]=is_prime[<span class="number">1</span>]=<span class="literal">false</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxp;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(is_prime[i]) prime[num++]=i;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num &amp;&amp; i*prime[j]&lt;maxp;j++)</div><div class="line">		&#123;</div><div class="line">			is_prime[i*prime[j]]=<span class="literal">false</span>;</div><div class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span>  <span class="comment">//枚举所有的连续素数和，打表</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</div><div class="line">	<span class="keyword">int</span> tmp;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;num;j++)</div><div class="line">		&#123;</div><div class="line">			tmp=<span class="number">0</span>;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j;k++)</div><div class="line">				tmp+=prime[k];</div><div class="line">			<span class="keyword">if</span>(tmp&lt;maxp)</div><div class="line">				a[tmp]++;</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> t;</div><div class="line">	init();</div><div class="line">	fun();</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t)!=EOF &amp;&amp; t)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[t]);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 2034 Anti-prime Sequences 素数+DFS回溯]]></title>
      <url>/2017/04/23/POJ-2034-Anti-prime-Sequences-%E7%B4%A0%E6%95%B0-DFS%E5%9B%9E%E6%BA%AF/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2034" target="_blank" rel="external">http://poj.org/problem?id=2034</a></p>
<a id="more"></a>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个序列: {n,n+1,n+2,…,m} 现在对这个序列进行重新排序，使得每相邻2、3、。。。、d个数都是合数</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑使用回溯法，从第一个开始往后排。判断一个数num是否能够排在pos位置的方法（pos前面的数已经确定好了）是从这个数开始不断向前加一个数，只要这个和是素数就可以得到这个位置不能排这个数。<br>回溯法套用的就是生成全排列的那种方法。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">ol is_prime[maxp];</div><div class="line"><span class="keyword">int</span> prime[maxp],num;</div><div class="line"><span class="keyword">int</span> n,m,d;</div><div class="line"><span class="keyword">bool</span> visit[maxn];</div><div class="line"><span class="keyword">int</span> ans[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	num=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(is_prime,<span class="literal">true</span>,<span class="keyword">sizeof</span>(is_prime));</div><div class="line">	is_prime[<span class="number">0</span>]=is_prime[<span class="number">1</span>]=<span class="literal">false</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxp;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(is_prime[i]) prime[num++]=i;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num &amp;&amp; i*prime[j]&lt;maxp;j++)</div><div class="line">		&#123;</div><div class="line">			is_prime[i*prime[j]]=<span class="literal">false</span>;</div><div class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> nu)</span>  <span class="comment">//判断pos位置放置num值是否可行</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(pos==<span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">int</span> l=pos-d+<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(l&lt;<span class="number">0</span>)</div><div class="line">        l=<span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> sum=nu;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=pos<span class="number">-1</span>;i&gt;=l;i--)</div><div class="line">	&#123;</div><div class="line">		sum+=ans[i];</div><div class="line">		<span class="keyword">if</span>(is_prime[sum])</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(u==m-n+<span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;=m;i++)  <span class="comment">//枚举每个可以插入的数</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(!visit[i] &amp;&amp; judge(u,i))</div><div class="line">		&#123;</div><div class="line">			ans[u]=i;    <span class="comment">//记录下来为考虑后面的数做准备</span></div><div class="line">			visit[i]=<span class="literal">true</span>;</div><div class="line">			<span class="keyword">if</span>(dfs(u+<span class="number">1</span>))</div><div class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">			visit[i]=<span class="literal">false</span>; <span class="comment">// 回溯</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	init();</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;d)!=EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>&amp;&amp;d==<span class="number">0</span>)</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="built_in">memset</span>(visit,<span class="literal">false</span>,<span class="keyword">sizeof</span>(visit));</div><div class="line">		<span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</div><div class="line">		<span class="keyword">if</span>(dfs(<span class="number">0</span>))</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m-n+<span class="number">1</span>;i++)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans[i]);</div><div class="line">				<span class="keyword">if</span>(i!=m-n)</div><div class="line">					<span class="built_in">printf</span>(<span class="string">","</span>);</div><div class="line">			&#125;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="built_in">printf</span>(<span class="string">"No anti-prime sequence exists.\n"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Codeforces #410 题解]]></title>
      <url>/2017/04/22/Codeforces-410-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>比赛题目链接：<a href="http://codeforces.com/contest/798" target="_blank" rel="external">http://codeforces.com/contest/798</a></p>
<a id="more"></a>
<h2 id="798A-Mike-and-palindrome"><a href="#798A-Mike-and-palindrome" class="headerlink" title="798A - Mike and palindrome"></a>798A - Mike and palindrome</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个字符串，判断是否能够只改变一个字符使得这个字符串变成一个回文串</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目要求必须改变一个字符串（一开始被这个坑了），所以把整体分成三种情况，改变一处成为回文串输出YES；已经是回文串并且串的长度是奇数输出YES（因为改变最中间那个字符，这个字符串还是回文串）；其他情况输出NO。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">string</span> s;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> n=s.size();</div><div class="line">		<span class="keyword">int</span> u=<span class="number">0</span>;</div><div class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">			<span class="keyword">return</span> ;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(s[i]!=s[n<span class="number">-1</span>-i])</div><div class="line">				u++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(u==<span class="number">2</span>)</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(u==<span class="number">0</span> &amp;&amp; n%<span class="number">2</span>==<span class="number">1</span>)</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="798B-Mike-and-strings"><a href="#798B-Mike-and-strings" class="headerlink" title="798B - Mike and strings"></a>798B - Mike and strings</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>定义对字符串的一个操作：将首字符移到最后。给出n个字符串，问最少进行多少次这样的操作能够使得给出的所有字符串都相同。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><h4 id="模拟法"><a href="#模拟法" class="headerlink" title="模拟法"></a>模拟法</h4><p>首先将每一个字符串都复制一遍放到最后，这样左移k位就可以看成是从第k个字符开始长度为len的字符串了。遍历每一个字符串,将其当做目标字符串，计算其他的字符串变成这个字符串的最小开销，求出一个最小值就行了。加上检查是否相等的O(len)的时间复杂度，整体的时间复杂度为O(n^2*len^2)。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> n,len;</div><div class="line"><span class="keyword">char</span> s[<span class="number">51</span>][<span class="number">101</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">char</span> *b)</span> <span class="comment">//判断以a b两个字符串是否相等</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</div><div class="line">		<span class="keyword">if</span>(a[i]!=b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">bool</span> flag=<span class="literal">false</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i]);</div><div class="line">		len=<span class="built_in">strlen</span>(s[<span class="number">0</span>]);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)</div><div class="line">				s[i][j+len]=s[i][j];     <span class="comment">//在原来的字符串后面加上相同的字符串</span></div><div class="line">		<span class="keyword">int</span> res=<span class="number">0</span>,ans=INF;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)      <span class="comment">//作为基准字符串</span></div><div class="line">		&#123;</div><div class="line">			res=<span class="number">0</span>;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span>(i==j)</div><div class="line">					<span class="keyword">continue</span>;</div><div class="line">				<span class="keyword">int</span> k;</div><div class="line">				<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;len;k++)</div><div class="line">					<span class="keyword">if</span>(s[i][<span class="number">0</span>]==s[j][k] &amp;&amp; judge(s[i],s[j]+k))   <span class="comment">//j串循环左移k位</span></div><div class="line">					&#123;</div><div class="line">						res+=k;</div><div class="line">						<span class="keyword">break</span>;</div><div class="line">					&#125;</div><div class="line">				<span class="keyword">if</span>(k==len)</div><div class="line">				&#123;</div><div class="line">					<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</div><div class="line">					flag=<span class="number">1</span>;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span>(flag)</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			ans=min(ans,res);</div><div class="line">		&#125;</div><div class="line">        <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="798C-Mike-and-gcd-problem"><a href="#798C-Mike-and-gcd-problem" class="headerlink" title="798C - Mike and gcd problem"></a>798C - Mike and gcd problem</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>首先定义对于序列的一个操作：将an 和 an+1的值分别替换为（an-an+1）和（an+an+1）。给出一个序列，问要进行多少步如上的操作才能使得这个序列的最大公因数大于1。</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>如果两个操作数都是奇数的话，进行一次操作就全部变成偶数；如果两个数是一奇一偶的话，进行一次操作后变成两个都是奇数，再进行一次操作就得到两个偶数。如果一个序列全是偶数的话，他们的最大公因数至少是2，比1大。所以不管序列怎样，一定是有解的。<br>一个序列如果gcd是1的话那么这个序列中一定存在奇数，并且至少有两个数互质。所以采取将所有的奇数通过操作变换成偶数的方案。我们知道如果是两个奇数要进行一次操作，一奇一偶进行两次操作。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> b?gcd(b,a%b):a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> a[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">		<span class="keyword">int</span> g=gcd(a[<span class="number">0</span>],a[<span class="number">1</span>]);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)</div><div class="line">			g=gcd(g,a[i]);</div><div class="line">		<span class="keyword">if</span>(g&gt;<span class="number">1</span>)</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"0\n"</span>);</div><div class="line">		<span class="keyword">else</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span>(!(a[i]&amp;<span class="number">1</span>))   <span class="comment">//对奇数进行操作</span></div><div class="line">					<span class="keyword">continue</span>;</div><div class="line">				<span class="keyword">if</span>(i==n<span class="number">-1</span>)</div><div class="line">					ans+=<span class="number">2</span>;</div><div class="line">				<span class="keyword">else</span></div><div class="line">				&#123;</div><div class="line">					<span class="keyword">int</span> tmp=a[i];</div><div class="line">					a[i]=a[i]-a[i+<span class="number">1</span>];</div><div class="line">					a[i+<span class="number">1</span>]=tmp+a[i+<span class="number">1</span>];</div><div class="line">					ans++;</div><div class="line">					<span class="keyword">if</span>(a[i]&amp;<span class="number">1</span>)   <span class="comment">//进行两步操作</span></div><div class="line">					&#123;</div><div class="line">						tmp=a[i];</div><div class="line">						a[i]=a[i]-a[i+<span class="number">1</span>];</div><div class="line">						a[i+<span class="number">1</span>]=tmp+a[i+<span class="number">1</span>];</div><div class="line">						ans++;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UVA-1471 Defense Lines 扫描+二分]]></title>
      <url>/2017/04/21/UVA-1471-Defense-Lines-%E6%89%AB%E6%8F%8F-%E4%BA%8C%E5%88%86/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://vjudge.net/problem/UVA-1471" target="_blank" rel="external">https://vjudge.net/problem/UVA-1471</a></p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个序列，要求删除一子序列以后，能够得到一个最长的连续递增子序列，输出这个连续递增子序列的长度</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="前期处理"><a href="#前期处理" class="headerlink" title="前期处理"></a>前期处理</h3><p>我们可以将问题分成两个部分：求以j开头的最长递增子序列的长度g[j];求以i结尾的最长递增子序列的长度f[i],这样的话问题就转化成了求i和j满足条件：A[i]&lt; A[j] 并且 f[i]+g[j] 最大</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>我们还可以在上面的O(n^2)算法的基础上继续改进，首先我们开一个数组Min，其中元素Min[i]表示长度为i的递增序列中的结尾元素值最小的值。<br>可见Min一定是递增的，因为长度为的n的最后一个元素的值一定比长度为n-1的序列的最后一个元素值大。这样的话我们已知A[i]的值就可以通过二分查找（lower_bound）来判断其在Min中的位置，从而得出能够取到的最长的序列长度。这样二分查找的时间复杂度为O(logn)，这个算法的时间复杂度为O(nlogn)。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200005</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> t,n,a[maxn],Left[maxn],Right[maxn],Min[maxn];</div><div class="line"></div><div class="line"><span class="comment">// 初始化确定左右两边的值</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    Left[<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">    Right[n<span class="number">-1</span>]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">        <span class="keyword">if</span>(i)</div><div class="line">        &#123;</div><div class="line">            Left[i]=<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>(a[i]&gt;a[i<span class="number">-1</span>]) Left[i]+=Left[i<span class="number">-1</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</div><div class="line">    &#123;</div><div class="line">        Right[i]=<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(a[i]&lt;a[i+<span class="number">1</span>]) Right[i]+=Right[i+<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">    <span class="built_in">memset</span>(Min,INF,<span class="keyword">sizeof</span>(Min));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> len=lower_bound(Min+<span class="number">1</span>,Min+<span class="number">1</span>+n,a[i])-Min;  <span class="comment">//根据元素值得到最小延伸值</span></div><div class="line">        ans=max(ans,Right[i]+len<span class="number">-1</span>);</div><div class="line">        Min[Left[i]]=min(Min[Left[i]],a[i]);   <span class="comment">//更新延伸值对应的元素值 </span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> t;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</div><div class="line">    <span class="keyword">while</span>(t--)</div><div class="line">    &#123;</div><div class="line">        init();</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,fun());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"></div><div class="line">&#123;</div><div class="line">    freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 其他-二分 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[凸包问题]]></title>
      <url>/2017/04/17/%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>首先是凸包的定义，假设平面内有一些点，这些点中的一部分组成一个多边形，将其他的点都包含起来，当这个多边形是凸多边形的时候，我们就把他当成是一个凸包。<br>解决凸包问题有很多种算法，比较常见的有O(n^3)的暴力穷举算法以及O(nlogn)d的分治算法，这里讲的是一个时间复杂度为O(nlogn)的Graham扫描法。</p>
<a id="more"></a>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="图中点的编号排序"><a href="#图中点的编号排序" class="headerlink" title="图中点的编号排序"></a>图中点的编号排序</h3><p>首先建立一个极坐标系，选取所有点中最左下的点作为极点，将所有的点按照逆时针方向进行排序，角度相同的点，距离极点小的点排在前面。</p>
<h3 id="依次寻找凸包上面的点"><a href="#依次寻找凸包上面的点" class="headerlink" title="依次寻找凸包上面的点"></a>依次寻找凸包上面的点</h3><p>用栈来存储凸包的点（因为我们要读取栈顶的两个点，所以不用STL中的queue，而是用数组建栈)，依次考察排序好的点,判断是否弹出栈顶元素。考察规则：从栈中取出栈顶的两个点，两点连接成一条直线，然后判断当前考虑的点在再这条直线的左边还是右边（利用叉乘进行判断），在左边表示这个点在凸包上，入栈；在右边表示当前栈顶元素不是凸包上的点，将这个点出栈，然后继续取出栈顶的两个点进行考虑，直到可以将这个点加入栈中。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> point</div><div class="line">&#123;</div><div class="line">	<span class="keyword">double</span> x,y;</div><div class="line">&#125;p[maxn],t[maxn];</div><div class="line"><span class="keyword">int</span> n;    <span class="comment">//点的个数</span></div><div class="line"></div><div class="line"><span class="comment">//得到相应的叉乘</span></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_X</span><span class="params">(point a,point b,point c)</span>        <span class="comment">//ab到ac的叉乘计算</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">(point a,point b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(point &amp;a,point &amp;b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">double</span> pp=get_X(p[<span class="number">0</span>],a,b);</div><div class="line">	<span class="keyword">if</span>(pp&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">if</span>(pp&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	<span class="keyword">return</span> len(p[<span class="number">0</span>],a)&lt;len(p[<span class="number">0</span>],b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Graham</span><span class="params">()</span>     <span class="comment">//返回凸包所含有的点的个数</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)     <span class="comment">//找到起始点</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(p[i].x&lt;p[<span class="number">0</span>].x) swap(p[i],p[<span class="number">0</span>]);</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(p[i].x==p[<span class="number">0</span>].x &amp;&amp; p[i].y&lt;p[<span class="number">0</span>].y) swap(p[i],p[<span class="number">0</span>]);</div><div class="line">		&#125;</div><div class="line">		sort(p+<span class="number">1</span>,p+n,cmp);</div><div class="line">		t[<span class="number">0</span>]=p[<span class="number">0</span>];</div><div class="line">		t[<span class="number">1</span>]=p[<span class="number">1</span>];</div><div class="line">		<span class="keyword">int</span> top=<span class="number">1</span>;    <span class="comment">//栈顶位置</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">while</span>(t&gt;<span class="number">0</span> &amp;&amp; get_X(t[top<span class="number">-1</span>],t[top],p[i])&lt;=<span class="number">0</span>) top--;    <span class="comment">//考虑的点在右侧的时候将栈顶的点弹出</span></div><div class="line">			top++;</div><div class="line">			t[top]=p[i];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> top;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[最大团问题]]></title>
      <url>/2017/04/15/%E6%9C%80%E5%A4%A7%E5%9B%A2%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>最大团问题（Maximum Clique Problem, MCP）是图论中一个经典的组合优化问题，也是一类NP完全问题。看到前面的描述可能会觉得很复杂，但是最大团的定义其实很简单，通俗点讲最大团问题就是一个最大的完全子图的问题。<br>因为是NP完全问题，自然没有多项式时间复杂度求解的算法，解决这个问题有很多有效的算法：遗传算法、模拟退火算法、禁忌算法等等，但是这些算法比较高级，这里讲一种比较简单的搜索算法。<br><a id="more"></a></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>总体上来讲，这个算法就是通过DFS进行搜索，通过剪枝来优化的方法。DFS搜索的本质就是维护一个已经是完全图的子图，并在搜索过程中不断扩大这个子图，直到所有的点都被考虑进去。</p>
<h3 id="DFS过程"><a href="#DFS过程" class="headerlink" title="DFS过程"></a>DFS过程</h3><blockquote>
<p>　　　　初始化：</p>
<p>　　　　　从一个点 u 开始，把这个点加入集合 U 中。将编号比它大的且和它相连的点加入集合 S1 中，为了方便，将集合 S1 中的点有序，让他们从小到大排列，进行第一遍 DFS</p>
<p>　　　第一遍 DFS ：</p>
<p>　　　　　从 S1 中选择一个点 u1，遍历 S1 中，所有编号比 u1 大且和 u1 相连的点，其实也就是排在 u1 后面，并且和 u1 相连的点，将它们加入集合 S2 中。同理，让 S2 中的点也按照编号也从小到大排列。将 u1 加入集合 U 中，进行第二遍 DFS</p>
<p>　　　第二遍 DFS ：</p>
<p>　　　　　从 S2 中选择一个点 u2，遍历 S2 中，所有排在 u2 后面且和 u2 相连的点，并把它们加入集合 S3 中，让 S3 中的点按照编号从小到大排列，将 u2 加入集合 U 中进行第三遍 DFS</p>
<p>　　　第三遍 DFS ：</p>
<p>　　　　　从 S3 中选择一个点 u3，遍历 S3 中，所有排在 u3 后面且和 u3 相连的点，并把它们加入集合 S4 中，让 S4 中的点按照编号从小到大排列，将 u3 加入集合 U 中进行第四遍 DFS</p>
<p>　　　……</p>
<p>　　　最底层的 DFS ：</p>
<p>　　　　　当某个 S 集合为空时，DFS 过程结束，得到一个只用后面几个点构成的完全子图，并用它去更新只用后面几个点构成的最大团。退出当前 DFS，返回上层 DFS，接着找下一个完全子图，直到找完所有的完全子图</p>
</blockquote>
<h3 id="辅助集合"><a href="#辅助集合" class="headerlink" title="辅助集合"></a>辅助集合</h3><p>为每一层的DFS遍历开一个集合Sn，用来表示在这一层DFS中，考虑加入完全图中的点。从这个集合Sn中取一个点准备加入完全图，同时将和这个点相连的Sn中的其他点加入下一层DFS的辅助集合S(n+1)中去。</p>
<h3 id="剪枝1"><a href="#剪枝1" class="headerlink" title="剪枝1"></a>剪枝1</h3><p>已经在完全图U中的点的数量 + 辅助集合Sn中的点的数量 &lt; 已经产生的最优解，则不再进行后面的DFS</p>
<h3 id="剪枝2"><a href="#剪枝2" class="headerlink" title="剪枝2"></a>剪枝2</h3><p>已经在完全图U中的点的数量 + 后面集合能够构成的最大完全子图的顶点数量 &lt; 已经产生的最优解，则不再进行后面的DFS。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">bool</span> G[maxn][maxn];</div><div class="line"><span class="keyword">int</span> Max[maxn],Alt[maxn][maxn],ans,n;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> tot)</span>     <span class="comment">//cur 当前层次集合大小  tot 所在的层次</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(cur==<span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(tot&gt;ans)</div><div class="line">		&#123;</div><div class="line">			ans=tot;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(cur-i+tot&lt;=ans) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">//剪枝1</span></div><div class="line">		<span class="keyword">int</span> u=Alt[tot][i];    <span class="comment">//选取当前考虑的点</span></div><div class="line">		<span class="keyword">if</span>(Max[u]+tot&lt;=ans) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> next=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;cur;j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(G[u][Alt[tot][j]])  Alt[tot+<span class="number">1</span>][next++]=Alt[tot][j];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(dfs(next,tot+<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>  <span class="title">MaxClique</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ans=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(Max,<span class="number">0</span>,<span class="keyword">sizeof</span>(Max));</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)    <span class="comment">//逆向构建Max</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> cur=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++) </div><div class="line">			<span class="keyword">if</span>(G[i][j]) Alt[<span class="number">1</span>][cur++]=j;</div><div class="line">		dfs(cur,<span class="number">1</span>);</div><div class="line">		Max[i]=ans;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ZOJ-1492"><a href="#ZOJ-1492" class="headerlink" title="ZOJ 1492"></a>ZOJ 1492</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>裸的最大团模板题</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">nclude &lt;iostream&gt;</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">55</span>;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> G[maxn][maxn];</div><div class="line"><span class="keyword">int</span> Max[maxn],Alt[maxn][maxn],ans,n;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> tot)</span>     <span class="comment">//cur 当前层次集合大小  tot 所在的层次</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(cur==<span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(tot&gt;ans)</div><div class="line">		&#123;</div><div class="line">			ans=tot;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(cur-i+tot&lt;=ans) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">//剪枝1</span></div><div class="line">		<span class="keyword">int</span> u=Alt[tot][i];    <span class="comment">//选取当前考虑的点</span></div><div class="line">		<span class="keyword">if</span>(Max[u]+tot&lt;=ans) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> next=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;cur;j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(G[u][Alt[tot][j]])  Alt[tot+<span class="number">1</span>][next++]=Alt[tot][j];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(dfs(next,tot+<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>  <span class="title">MaxClique</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ans=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(Max,<span class="number">0</span>,<span class="keyword">sizeof</span>(Max));</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)    <span class="comment">//逆向构建Max</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> cur=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++) </div><div class="line">			<span class="keyword">if</span>(G[i][j]) Alt[<span class="number">1</span>][cur++]=j;</div><div class="line">		dfs(cur,<span class="number">1</span>);</div><div class="line">		Max[i]=ans;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> a;</div><div class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</div><div class="line">                <span class="keyword">if</span>(a==<span class="number">1</span>)G[i][j]=<span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span> G[i][j]=<span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">		MaxClique();</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[KM算法]]></title>
      <url>/2017/04/10/KM%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>之前讲到了匈牙利算法，今天讲一个在匈牙利算法的基础上的解决最大全的完美二分匹配的问题的KM算法，这个算法在理解上面可能有一点难度，不过有一句话说得好：组合数学靠运气，计算几何瞎暴力，图论一顿套模板，数论只会gcd。23333.。。<br><a id="more"></a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h4 id="完备匹配"><a href="#完备匹配" class="headerlink" title="完备匹配"></a>完备匹配</h4><p>二分图中，含有较少点集合中的所有点都有匹配的点的时候，我们称这样的匹配叫完备匹配</p>
<h4 id="完美匹配"><a href="#完美匹配" class="headerlink" title="完美匹配"></a>完美匹配</h4><p>在完备匹配的基础上，二分图中两个点的集合中点的个数相同。如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。完美匹配一定是最大匹配。</p>
<h4 id="相关问题变形"><a href="#相关问题变形" class="headerlink" title="相关问题变形"></a>相关问题变形</h4><p>完备匹配变完美匹配：添加无用顶点和权值为0的边</p>
<h4 id="顶点顶标"><a href="#顶点顶标" class="headerlink" title="顶点顶标"></a>顶点顶标</h4><p>为每个点设定一个顶标，设顶点Xi的顶标为A[ i ]，顶点Yj的顶标为B[ j ]，顶点Xi与Yj之间的边权为w[i,j]。在算法执行过程中的任一时刻，对于任一条边(i,j)，A[i]+B[j] &gt;= w[i,j] 始终成立。</p>
<h4 id="相等子图"><a href="#相等子图" class="headerlink" title="相等子图"></a>相等子图</h4><p>G中满足A[i]+B[j]=w[i,j] 的边生成的子图<br>KM算法在G的相等子图中求一个完备匹配</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>初始化：令A[ i ]为所有与顶点Xi关联的边的最大权，B[ j ]=0<br>如果当前的相等子图没有完备匹配，就需要修改顶标以扩大相等子图<br>重复第二步，直到相等子图有完备匹配为止</p>
<h4 id="修改顶标（关键）"><a href="#修改顶标（关键）" class="headerlink" title="修改顶标（关键）"></a>修改顶标（关键）</h4><p>KM算法的关键为如何修改顶标，以使顶标维持其性质的同时使相等子图得到扩展。<br>考虑到，如果当前相等子图不存在完备匹配，是因为存在某个不被匹配的x结点，在当前相等子图中不存在其的增广路。这样由这个点出发我们可得到一棵交错树，并且该树的所有叶子结点都在X集合中<br>这时如果我们把交错树中所有X集合结点的顶标减去d，所有Y集合结点的顶标加上d。则会发现：</p>
<ol>
<li>两端都在交错树中的边(i, j)，A[ i ]+B[ j ]的值没有变化。也就是说，它原来属于相等子图，现在仍属于相等子图。</li>
<li>两端都不在交错树中的边(i, j)，A[ i ]和B[ j ]都没有变化。也就是说，它原来属于（或不属于）相等子图，现在仍属于（或不属于）相等子图。</li>
<li>X端不在交错树中，Y端在交错树中的边(i, j)，它的A[ i ]+B[ j ]的值有所增大。它原来不属于相等子图，现在仍不属于相等子图。</li>
<li>X端在交错树中，Y端不在交错树中的边(i, j)，它的A[ i ]+B[ j ]的值有所减小。也就说，它原来不属于相等子图，现在可能进入了相等子图，因而使相等子图得到了扩大。<br>确定d的值：（以确保每次修该顶标既能保持顶标性质，又能使至少一条边加入到相等子图中来，使其得到扩展。）<br>d=Min{A[ i ]+B[ j ]-w[i , j] | Xi在交错树中，Yj不在交错树中}</li>
</ol>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>按照刚才的算法来的时间复杂度是O(n^4)，需要找O(n)次增广路，每次增广最多需要修改O(n)次顶标，每次修改顶标时由于要枚举边来求d值，复杂度为O(n2)。<br>可以看出，通过枚举边来求d的值是有改进空间的 。实际上我们给每个Y顶点一个“松弛量”函数slack，每次开始找增广路时初始化为无穷大。在寻找增广路的过程中，检查边(i,j)时，如果它不在相等子图中， 则让slack[j]变成原值与A[ i ]+B[j]-w[i,j]的较小值。这样，在修改顶标时，取所有不在交错树中的Y顶点的slack值中的最小值作为d值即可。但还要注意一点：修改顶标后，要把所有的slack值都减去d。<br>这样求d的复杂度降为O(n)级，使得总时间复杂度为O(n3)</p>
<h2 id="模板（代码实现）"><a href="#模板（代码实现）" class="headerlink" title="模板（代码实现）"></a>模板（代码实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> nx,ny;  <span class="comment">//两边的点数</span></div><div class="line"><span class="keyword">int</span> g[maxn][maxn];   <span class="comment">//建图</span></div><div class="line"><span class="keyword">int</span> linker[maxn],lx[maxn],ly[maxn];     <span class="comment">//y中欧各个点的匹配状态,x y 中各个点的标号</span></div><div class="line"><span class="keyword">int</span> slack[maxn];        <span class="comment">//松弛量数组</span></div><div class="line"><span class="keyword">bool</span> visx[maxn],visy[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line">&#123;</div><div class="line">	visx[x]=<span class="literal">true</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;ny;y++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(visy[y]) <span class="keyword">continue</span>;</div><div class="line">		<span class="keyword">int</span> tmp=lx[x]+ly[y]-g[x][y];</div><div class="line">		<span class="keyword">if</span>(tmp==<span class="number">0</span>)    <span class="comment">//顶标符合要求，匈牙利算法寻找完备匹配</span></div><div class="line">		&#123;</div><div class="line">			visy[y]=<span class="literal">true</span>;</div><div class="line">			<span class="keyword">if</span>(linker[y]==<span class="number">-1</span> || dfs(linker[y]))</div><div class="line">			&#123;</div><div class="line">				linker[y]=x;</div><div class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(slack[y]&gt;tmp)</div><div class="line">			slack[y] =tmp;        <span class="comment">//更新松弛量</span></div><div class="line">	&#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">KM</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">memset</span>(linker,<span class="number">-1</span>,<span class="keyword">sizeof</span>(linker));     <span class="comment">//初始化一开始匹配的点</span></div><div class="line">	<span class="built_in">memset</span>(ly,<span class="number">0</span>,<span class="keyword">sizeof</span>(ly));      <span class="comment">//y的顶标先全部变成0</span></div><div class="line">	<span class="comment">//初始化顶标</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nx;i++)</div><div class="line">	&#123;</div><div class="line">		lx[i]= -INF;            <span class="comment">//求最大值，首先初始化为最小值</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ny;j++)</div><div class="line">			<span class="keyword">if</span>(g[i][j]&gt;lx[i]) lx[i]=g[i][j];</div><div class="line">	&#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;nx;x++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ny;i++)</div><div class="line">			slack[i]=INF;</div><div class="line">		<span class="comment">//算法核心部分</span></div><div class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">memset</span>(visx,<span class="literal">false</span>,<span class="keyword">sizeof</span>(visx));</div><div class="line">            <span class="built_in">memset</span>(visy,<span class="literal">false</span>,<span class="keyword">sizeof</span>(visy));</div><div class="line">			<span class="keyword">if</span>(dfs(x)) <span class="keyword">break</span>;        <span class="comment">//找到完备匹配，退出</span></div><div class="line">			<span class="comment">//没有找到完备匹配，在交错树中更改相关节点的顶标值</span></div><div class="line">			<span class="keyword">int</span> d= INF;</div><div class="line">			<span class="comment">//修改顶标，增加相等子图中的边</span></div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ny;i++)</div><div class="line">				<span class="keyword">if</span>(!visy[i] &amp;&amp; d&gt;slack[i])</div><div class="line">					d=slack[i];          <span class="comment">//求出最小一个slack值</span></div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nx;i++)     <span class="comment">//在交错树中的x的节点减少d</span></div><div class="line">				<span class="keyword">if</span>(visx[i])</div><div class="line">					lx[i]-=d;    </div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ny;i++)        <span class="comment">//不在交错树中的y的节点增加d</span></div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span>(visy[i]) ly[i]+=d;     </div><div class="line">				<span class="keyword">else</span></div><div class="line">					slack[i] -=d;          <span class="comment">//x值减小，则相对的slack的值就会增大</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ny;i++)</div><div class="line">		<span class="keyword">if</span>(linker[i]!=<span class="number">-1</span>)</div><div class="line">			res+=g[linker[i]][i];</div><div class="line">	<span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 3276 (开关问题)]]></title>
      <url>/2017/04/09/POJ-3276-%E5%BC%80%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>这道题本来是挑战上面一道经典的例题，这次在Google 的<a href="https://code.google.com/codejam/" target="_blank" rel="external">code jam</a>的资格赛里面也出现了。可气的是我忘记怎么做了，只好重新看一遍挑战的书，下面讲一讲我对这道题的理解吧。</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出了N头牛的朝向（朝前或者朝后），现有一台机器，可以一次性反转连续的k头牛的朝向，最终要使得所有的牛的朝向都是朝前的，现在问使得反转次数最少的k的取值和最小的反转次数。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一个区间的反转会导致区间内的所有牛的朝向都改变，反转区间的顺序对最后的结果是没有影响的。同时对于一个区间要么就不反转，要么就只反转一次,不可能有两次或者以上的反转。一头牛是否需要反转是由这头牛一开始的状态以及其他区间的反转对这头牛的影响决定的。所以我们每次都考虑区间中最左边的牛，根据初始的朝向以及其他区间反转对这头牛的影响决定这头牛是否要反转，后面我们就不需要考虑这头牛，只要区间是否反转给后面的牛考虑带来的影响。这样每次每次问题的规模就减少了1。<br>我们设f[i]: 区间[i,i+K-1]是否进行反转，是为1，否则为0<br>这样我们考虑到第i头牛的时候，就是考虑f[i-K+1]-f[i-1]对它的影响，将这些值相加，然后再加上牛本身的状态，为奇数时改变朝向，为偶数时不需要改变，这样我们就可以得到f[i]的值了，f[i]继续影响后面的牛的决策。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5006</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> dir[maxn],f[maxn];    <span class="comment">//存放初始状态和反转情况</span></div><div class="line"><span class="keyword">int</span> N;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> k)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</div><div class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;        <span class="comment">//最后反转的次数</span></div><div class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;        <span class="comment">//之前区间的反转对当前节点的影响数</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+k&lt;=N;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>((dir[i]+sum)%<span class="number">2</span>)    <span class="comment">//需要进行反转</span></div><div class="line">		&#123;</div><div class="line">			res++;</div><div class="line">			f[i]=<span class="number">1</span>;         <span class="comment">//会对后面的产生影响</span></div><div class="line">		&#125;</div><div class="line">		sum+=f[i];</div><div class="line">		<span class="keyword">if</span>(i-k+<span class="number">1</span>&gt;=<span class="number">0</span>)</div><div class="line">			sum-=f[i-k+<span class="number">1</span>];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=N-k+<span class="number">1</span>;i&lt;N;i++)  <span class="comment">//无法进行反转的阶段</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>((dir[i]+sum)%<span class="number">2</span>)</div><div class="line">			<span class="keyword">return</span> <span class="number">-1</span>;    <span class="comment">//无解</span></div><div class="line">		<span class="keyword">if</span>(i-k+<span class="number">1</span>&gt;=<span class="number">0</span>)</div><div class="line">			sum-=f[i-k+<span class="number">1</span>];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> res;	</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> ch[<span class="number">2</span>];</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N)!=EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;ch);</div><div class="line">			<span class="keyword">if</span>(ch[<span class="number">0</span>]==<span class="string">'F'</span>)</div><div class="line">				dir[i]=<span class="number">0</span>;</div><div class="line">			<span class="keyword">else</span></div><div class="line">				dir[i]=<span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> minid=<span class="number">1</span>,minva=N;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=N;k++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">int</span> tmp=calc(k);</div><div class="line">			<span class="keyword">if</span>(tmp&gt;=<span class="number">0</span> &amp;&amp; tmp&lt;minva)</div><div class="line">			&#123;</div><div class="line">				minva=tmp;</div><div class="line">				minid=k;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,minid,minva);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法技巧 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[匈牙利算法]]></title>
      <url>/2017/04/08/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>今天实验室的“周末算法讲堂”轮到我啦，今天主要讲的是匈牙利算法，主要用来解决最大的二分匹配问题（当然还可以用最大流来解决）。下面把握准备过程的资料整理总结出来吧。（感觉这么点东西讲的东西比较少，实验室的大佬们别介意啊）<br>后面会讲到在这个的基础上解决最大权完美匹配问题的KM算法</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><p>如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。每一条边的两个端点都分别在两个组当中<br><img src="http://oeziv5rwi.bkt.clouddn.com/2017/4/8/001.jpg" alt="二分图"></p>
<h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><p>在图论中，一个「匹配」（matching）是原图边的一个子集，其中任意两条边都没有公共顶点。图中的点要么有一条边相连，要么没有边相连，不可能一个点和多条边相连。</p>
<h3 id="最大匹配"><a href="#最大匹配" class="headerlink" title="最大匹配"></a>最大匹配</h3><p>一个图中含有匹配数最多的匹配</p>
<h3 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h3><p>求出所有的匹配方案，从中选取覆盖顶点数最大的匹配方案。</p>
<h3 id="最大流算法"><a href="#最大流算法" class="headerlink" title="最大流算法"></a>最大流算法</h3><p>在两边各加一个源点和一个汇点，同时为两边的每一个点都添加一条指向源点/汇点的边，如图所示。同时从源点到汇点给每一条边都指定方向。这样问题就转换成最大流问题，通过最大流的相关算法就可以求解。</p>
<p><img src="http://oeziv5rwi.bkt.clouddn.com/2017/4/8/002.jpg" alt="最大流求解二分匹配问题"></p>
<hr>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>匈牙利算法提供一种找图中的最大匹配的算法</p>
<h3 id="增广路径"><a href="#增广路径" class="headerlink" title="增广路径"></a>增广路径</h3><p>从未匹配点出发，交替通过未匹配边和已匹配边，最后到达另一个未匹配点的路径。<br><img src="http://oeziv5rwi.bkt.clouddn.com/2017/4/8/003.jpg" alt="增广路径"><br>性质</p>
<ol>
<li>增广路的长度一定是奇数，并且第一条边和最后一条边一定不是匹配边。</li>
<li>增广路径中未匹配边的数量始终比已匹配边的数量多一位。<br>这样通过反转（已匹配边变成未匹配边，未匹配边变成已匹配边）就可以增加一天匹配边。反转不改变匹配的性质。<br>可以证明，找到最大的匹配当且仅当找不到新的增广路：<br>最大匹配是一定不存在增广路，性质2容易证明<br>找不到增广路一定是最大匹配，证明比较麻烦，忽略<br>每找到一条增广路就可以增加一条匹配边。匈牙利算法实际上就是不断从未匹配点开始找增广路的算法。一个点找到匹配的边以后，以后寻找增广路的过程中这个点始终都会有匹配的边</li>
</ol>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>1、设置匹配为空<br>2、遍历每一个未匹配点，从这个点出发，找增广路。通常情况下我们只需要遍历一边的点就可以了，因为匹配边连接的两个点一定分别处在两个集合中，一边的点达到最大的匹配，另外一遍的点也必定会达到最大的匹配<br>3、记录匹配的边数，进行输出</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>空间复杂度：空间复杂度主要来源于图的复杂度，使用链式前向星来存储图，空间复杂度为O(e)</li>
<li>时间复杂度：枚举一边的点的时间复杂度为O(v)，在最坏的情况下每次寻找增广路的时间复杂度为O(e)，所以总的时间复杂度为O(v*e)</li>
</ul>
<h3 id="实现模板"><a href="#实现模板" class="headerlink" title="实现模板"></a>实现模板</h3><p>DFS实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> matching[maxn],head[maxn];</div><div class="line"><span class="keyword">bool</span> visit[maxn];</div><div class="line"><span class="keyword">int</span> cnt,P,N;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Edge</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> to;</div><div class="line">	<span class="keyword">int</span> next;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Edge edge[maxn*maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	cnt=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></div><div class="line">&#123;</div><div class="line">	edge[cnt].to=v;</div><div class="line">	edge[cnt].next=head[u];</div><div class="line">	head[u]=cnt++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=edge[i].next)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> v=edge[i].to;</div><div class="line">		<span class="keyword">if</span>(!visit[v])</div><div class="line">		&#123;</div><div class="line">			visit[v]=<span class="number">1</span>;</div><div class="line">			<span class="keyword">if</span>(matching[v]==<span class="number">-1</span>|| dfs(matching[v]))</div><div class="line">			&#123;</div><div class="line">				matching[v]=u;</div><div class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">huangay</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(matching,<span class="number">-1</span>,<span class="keyword">sizeof</span>(matching));</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=P;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</div><div class="line">		<span class="keyword">if</span>(dfs(i)) ans++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="POJ-1469"><a href="#POJ-1469" class="headerlink" title="POJ 1469"></a>POJ 1469</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出N个学生和P堂课，以及每堂课报名的学生名单，存在以下对于课代表的规则：每个学生当一门课的课代表，每门课都有课代表。问是否存在满足上述条件的课代表组合。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>裸的匈牙利算法，只要将最后算法出来的匹配数和课堂树进行比对，相等的话就满足条件，否则不满足条件。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">305</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> matching[maxn],head[maxn];</div><div class="line"><span class="keyword">bool</span> visit[maxn];</div><div class="line"><span class="keyword">int</span> cnt,P,N;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Edge</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> to;</div><div class="line">	<span class="keyword">int</span> next;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Edge edge[maxn*maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	cnt=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></div><div class="line">&#123;</div><div class="line">	edge[cnt].to=v;</div><div class="line">	edge[cnt].next=head[u];</div><div class="line">	head[u]=cnt++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=edge[i].next)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> v=edge[i].to;</div><div class="line">		<span class="keyword">if</span>(!visit[v])</div><div class="line">		&#123;</div><div class="line">			visit[v]=<span class="number">1</span>;</div><div class="line">			<span class="keyword">if</span>(matching[v]==<span class="number">-1</span>|| dfs(matching[v]))</div><div class="line">			&#123;</div><div class="line">				matching[v]=u;</div><div class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">huangay</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(matching,<span class="number">-1</span>,<span class="keyword">sizeof</span>(matching));</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=P;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</div><div class="line">		<span class="keyword">if</span>(dfs(i)) ans++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> t;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</div><div class="line">    <span class="keyword">while</span>(t--)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;P,&amp;N);</div><div class="line">        Init();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=P;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> tmp,a;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tmp);</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tmp;j++)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</div><div class="line">                add(i,a);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> ans=huangay();</div><div class="line">        <span class="keyword">if</span>(ans==P)</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//freopen("input.txt","r",stdin);</span></div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识 朱刘算法]]></title>
      <url>/2017/03/25/%E5%88%9D%E8%AF%86-%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>又到了每周一次的实验室算法专题分享，这次讲的是的是朱刘算法（好奇葩的算法名字），朱刘算法主要用来解决的是最小树型图的问题，算法整体的理解不是很难结合模板代码比较容易理解。接下来讲讲我的理解吧，当做自己学习的一个总结吧！</p>
<a id="more"></a>
<h2 id="最小树型图"><a href="#最小树型图" class="headerlink" title="最小树型图"></a>最小树型图</h2><p>我们知道最小生成树是一个加权无向图，有n-1条边，能够连接图中所有的点的边集。这里的最小树型图就是最小生成树的有向图版本。除了根节点之外所有的节点都有一条入边指向它。</p>
<h2 id="朱刘算法"><a href="#朱刘算法" class="headerlink" title="朱刘算法"></a>朱刘算法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>首先我们可以利用贪心思想，像Kruscal算法的选边原则一样，我们可以先找到每个节点的入边中最小的一条边，如果选出来的这些边中不能构成环，这样选出来的边就组成了一个最小树型图。但很多时候我们选出来的边是含有环的，对于环的处理，朱刘算法采取的不是直接换边，而是用一个点来代替原来的那个环（这个操作叫做缩点操作），并且修改跟这个环里的点有关的边的权值 ， 为什么要修改权值呢？因为我们是换边 ， 不是增加边 ， <strong>当我们每更换一个点的入边的时候我们就要去掉原来那个入边  ， 于是我们把这个点所有可能的入边全部减小原来我们枚举的那个边的权值 ， 这样每增加一条入边无形中就删去了原来那条边</strong>(此处想通再继续)。 当我们把所有的环都缩点并且修改权值之后 ， 相当于就重新建图了。</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>算法用到必要数组有inw[]用来计算每个点的最小入边权值，id[]用来记录重新构图以后对应的点的编号，pre[]数组记录最小入边的上一个点</p>
<ul>
<li>初始化inw数组和pre数组，找到每个点的最小入边</li>
<li>寻找图中的环，通过一个辅助的数组v数组来实现</li>
<li>进行缩点操作，将一个环中的点当做一个点</li>
<li>重新构图</li>
</ul>
<h2 id="POJ-3164"><a href="#POJ-3164" class="headerlink" title="POJ 3164"></a>POJ 3164</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出N个点、这N个点的坐标信息和这N个点的M条关联关系，求最小树型图的权值代价和</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>裸的朱刘算法，模板题</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> in(a) scanf(<span class="meta-string">"%d"</span>,&amp;a)</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">110</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> edge</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> u,v;</div><div class="line">    <span class="keyword">double</span>  w;</div><div class="line">    edge(<span class="keyword">int</span> uu,<span class="keyword">int</span> vv, <span class="keyword">double</span> ww):u(uu),v(vv),w(ww)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;edge&gt; g;</div><div class="line"></div><div class="line"><span class="keyword">int</span> id[maxn],pre[maxn],v[maxn];</div><div class="line"><span class="keyword">double</span> inw[maxn],ans;</div><div class="line"><span class="keyword">int</span> n,m;</div><div class="line"><span class="keyword">int</span> xx[maxn],yy[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">double</span> ret= <span class="built_in">sqrt</span>(<span class="keyword">double</span>((yy[b]-yy[a])*(yy[b]-yy[a])+(xx[b]-xx[a])*(xx[b]-xx[a])));</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> s)</span>      <span class="comment">//存在最小树型图时，返回TRUE，ans；不存在的时候，返回FALSE</span></span></div><div class="line">&#123;</div><div class="line">    ans=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            inw[i]=INF;</div><div class="line">            id[i]=<span class="number">-1</span>;</div><div class="line">            v[i]=<span class="number">-1</span>;</div><div class="line">            pre[i]=<span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//找到每个点的最小入边</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g.size();i++)</div><div class="line">            <span class="keyword">if</span>(g[i].w &lt;=inw[g[i].v] &amp;&amp; g[i].v!=g[i].u)</div><div class="line">            &#123;</div><div class="line">                inw[g[i].v]=g[i].w;</div><div class="line">                pre[g[i].v]=g[i].u;</div><div class="line">            &#125;</div><div class="line">        pre[s]=s;</div><div class="line">        inw[s]=<span class="number">0</span>;       <span class="comment">//根节点没有入边</span></div><div class="line">        <span class="comment">//计算总的权重和</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(inw[i]==INF)</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">//没有找到最小的入边的时候，返回错误</span></div><div class="line">            ans+=inw[i];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//判断有没有环</span></div><div class="line">        <span class="keyword">int</span> idx=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(v[i]==<span class="number">-1</span>)     <span class="comment">//v[]作用是判断有没有环</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> t=i;</div><div class="line">                <span class="keyword">while</span> (v[t]==<span class="number">-1</span>)</div><div class="line">                &#123;</div><div class="line">                    v[t]=i;</div><div class="line">                    t=pre[t];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(v[t]!=i || t==s)</div><div class="line">                    <span class="keyword">continue</span>;      <span class="comment">//没有环的时候</span></div><div class="line">                id[t]=idx++;      <span class="comment">//重构图中新的点</span></div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=pre[t];j!=t;j=pre[j])id[j]=idx<span class="number">-1</span>;     <span class="comment">//缩点操作，确定前后点的关系</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(idx==<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="comment">//为不在环中的点建立图之间点的关系</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">            <span class="keyword">if</span>(id[i]==<span class="number">-1</span>)id[i]=idx++;</div><div class="line">        <span class="comment">//重新构图,改变边连接的两个点的关系</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g.size();i++)</div><div class="line">        &#123;</div><div class="line">            g[i].w-=inw[g[i].v];</div><div class="line">            g[i].u=id[g[i].u];</div><div class="line">            g[i].v=id[g[i].v];</div><div class="line">        &#125;</div><div class="line">        n=idx<span class="number">-1</span>;</div><div class="line">        s=id[s];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m)!=EOF)</div><div class="line">    &#123;</div><div class="line">        g.clear();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;xx[i],&amp;yy[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> a,b;</div><div class="line">        <span class="keyword">double</span> we;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b);</div><div class="line">            we=getdis(a,b);</div><div class="line">            g.push_back(edge(a,b,we));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(fun(<span class="number">1</span>))</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,ans);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"poor snoopy\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈 差分约束]]></title>
      <url>/2017/03/18/%E6%B5%85%E8%B0%88%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/</url>
      <content type="html"><![CDATA[<p>近期实验室专题学习讲到了差分约束系统，就写点东西来总结一下自己学到的东西吧。首先是一种的比较方便的图的存储方式——链式前向星，然后是在Dijkstra、Bellman-Ford之后的一种非常快的能够求出负环的最短路算法——SPFA，最后是一个最短路的变式——差分约束系统。</p>
<a id="more"></a>
<h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><p>存储图我们通常有两种方法：一种是邻接矩阵法，这个是最基本的东西；另外一种是邻接链表法，通常使用vector的数组表示（相当于一个二维数组）。<br>首先我们要知道什么是前向星，前向星就是一个边的数组，用起点进行排序，起点相同的情况下用终点进行排序。这样我们就可以找到点所连得所有边了<br>链式前向星在以上的基础上避免了排序，用一个head数组来存储每个节点的第一条边，后面的边想要加入进来通过边的结构体中的next来实现，新加入进来的边成为第一条边，这样我们取出边的顺序与插入的顺序是相反的，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">strut Node</div><div class="line">&#123;</div><div class="line">	int v,w,next;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void addedge(int u,int v,int w)</div><div class="line">&#123;</div><div class="line">	edges[id].v=v;</div><div class="line">	edges[id].w=w;</div><div class="line">	edges[id].next=head[u];    //把之前的第一条边作为当前边的最后一条边</div><div class="line">	head[u]=id++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>SPFA就是在Bellman-Ford算法的基础上加一个队列优化，减少冗余的松弛操作。把进行完松弛操作的点加入队列中，同时在判断负边方面，SPFA也具有比较大的优势。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">void spfa(int st)</div><div class="line">&#123;</div><div class="line">    fill(visit,visit+maxn,0);</div><div class="line">    fill(dist,dist+maxn,-INF);</div><div class="line"></div><div class="line">    queue&lt;int&gt; Q;</div><div class="line">    visit[st]=1;</div><div class="line">    dist[st]=0;</div><div class="line">    Q.push(st);</div><div class="line">    while (!Q.empty())</div><div class="line">    &#123;</div><div class="line">        int now=Q.front();</div><div class="line">        Q.pop();</div><div class="line"></div><div class="line">        visit[now]=0;</div><div class="line">        for(int i=head[now];i!=-1;i=edges[i].next)</div><div class="line">        &#123;</div><div class="line">            int v=edges[i].v;</div><div class="line">            int w=edges[i].w;</div><div class="line">            if(dist[v]&lt;dist[now]+w)</div><div class="line">            &#123;</div><div class="line">                dist[v]=dist[now]+w;</div><div class="line">                if(!visit[v])</div><div class="line">                &#123;</div><div class="line">                    Q.push(v);</div><div class="line">                    visit[v]=1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h2><p>我们把一个类似于 d[u]-d[v]&lt;=w  的不等式组放到图中来，看成两个点u、v之间的的距离小于等于w，这样每一个方程组就可以看成图中的一条边，我们构建一个图。这样求(d[0]-d[n])的最大值这样的问题我们就可以放到图中用最短路来解决。</p>
<h2 id="POJ-1201"><a href="#POJ-1201" class="headerlink" title="POJ 1201"></a>POJ 1201</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在一个区间0-50000内，给出n组约束条件，每一个条件表示在一个区间[a,b]内至少有c个点，让你求整个区间里面至少有的点数。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul>
<li>用一个数组d[i]表示从0到i的点数，这样区间[a,b]中至少含有的点数就可以表示为d[b]-d[a-1]，因为要减一处理，所以要多加一个数，不然0作为起点就不好表示。这样根据所给的条件就能够很多不等式组</li>
<li>题目中还隐含一个条件，就是每个点最后只能最多含有一个点，即 1&gt;=d[i+1]-d[i]&gt;=0</li>
<li>转化为最长路问题，通过SPFA来进行求解</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">#define INF 0x3f3f3ff</div><div class="line">const int maxn=500005;</div><div class="line"></div><div class="line">struct Node</div><div class="line">&#123;</div><div class="line">    int v,w,next;     //体现链式</div><div class="line">&#125;edges[maxn];</div><div class="line"></div><div class="line">int id,head[maxn],visit[maxn],dist[maxn];</div><div class="line"></div><div class="line">void init()</div><div class="line">&#123;</div><div class="line">    fill(head,head+maxn,-1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void addedge(int u,int v,int w)</div><div class="line">&#123;</div><div class="line">    edges[id].v=v;</div><div class="line">    edges[id].w=w;</div><div class="line">    edges[id].next=head[u];     //指向u节点的第一条边</div><div class="line">    head[u]=id++;    //替换这个第一条边</div><div class="line">&#125;</div><div class="line"></div><div class="line">void spfa(int st)</div><div class="line">&#123;</div><div class="line">    fill(visit,visit+maxn,0);</div><div class="line">    fill(dist,dist+maxn,-INF);</div><div class="line"></div><div class="line">    queue&lt;int&gt; Q;</div><div class="line">    visit[st]=1;</div><div class="line">    dist[st]=0;</div><div class="line">    Q.push(st);</div><div class="line">    while (!Q.empty())</div><div class="line">    &#123;</div><div class="line">        int now=Q.front();</div><div class="line">        Q.pop();</div><div class="line"></div><div class="line">        visit[now]=0;</div><div class="line">        for(int i=head[now];i!=-1;i=edges[i].next)</div><div class="line">        &#123;</div><div class="line">            int v=edges[i].v;</div><div class="line">            int w=edges[i].w;</div><div class="line">            if(dist[v]&lt;dist[now]+w)</div><div class="line">            &#123;</div><div class="line">                dist[v]=dist[now]+w;</div><div class="line">                if(!visit[v])</div><div class="line">                &#123;</div><div class="line">                    Q.push(v);</div><div class="line">                    visit[v]=1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void solve()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    while (scanf(&quot;%d&quot;,&amp;n)!=EOF)</div><div class="line">    &#123;</div><div class="line">        init();</div><div class="line">        id=0;</div><div class="line">        int maxnum=0,minnum=INF;</div><div class="line">        int u,v,w;</div><div class="line">        for(int i=0;i&lt;n;i++)</div><div class="line">        &#123;</div><div class="line">            scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w);</div><div class="line">            maxnum=max(maxnum,v+1);</div><div class="line">            minnum=min(minnum,u);</div><div class="line">            addedge(u,v+1,w);    //坐标向后面移一位</div><div class="line">        &#125;</div><div class="line">        for(int i=minnum;i&lt;maxnum;i++)</div><div class="line">        &#123;</div><div class="line">            addedge(i,i+1,0);</div><div class="line">            addedge(i+1,i,-1);   //隐含信息，每一个节点只有最多只能存放一个点</div><div class="line">        &#125;</div><div class="line">        spfa(minnum);</div><div class="line">        printf(&quot;%d\n&quot;,dist[maxnum]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</div><div class="line">    solve();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈可持续化线段树]]></title>
      <url>/2017/03/02/%E6%B5%85%E8%B0%88%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>可持续化线段树（又叫主席树、函数式线段树），顾名思义就是保存线段树的所有历史版本，并且利用他们共同的数据来减少时间和空间的消耗<br>相比普通的线段树维护当前节点对应的区间的信息，可持续化线段树能够记录每次修改后的线段树，可以解决区间第k个数大小的问题。</p>
<a id="more"></a>
<p>主席树能够保存线段树的所有历史版本，这肯定不会是每一个线段树都存储下来（这样一定会MLE的），而是在每次修改的时候只记录修改的结点，没有修改的结点还用原来的线段树里面的结点，这样在线段树中修改某一个值得时候，只需要新增logn个结点来记录这修改了的logn个结点，其他的结点都是不变的，充分利用其中的共有数据。主席树中的每一个结点保存的是一个线段树，维护的区间相同，    结构相同，只有保存的信息不同，这样主席树中的结点就具备了加减性。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>原始的树可以看成是一课空树tree[0]，树中的任何结点的左右结点都是这个空结点，载入原始数据的过程可以看成是第一个历史版本，其他的过程和普通的线段树相同，临界判断，向下更新。</p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>在原来的线段树上进行更改，所修改的每一个结点都是充分分配空间的新结点，同时将父节点指向当前的结点，再用root数组存储当前线段树的根节点。这里很巧妙地用到了引用操作（&amp;），例如update(tree[id].l,l,r,v)，同时update函数的变量表为update(int &amp;id,int l,int r,int v)，函数体的开头就是tree[++cnt]=tree[id];id=cnt; 这样巧妙地操作顺便将父节点的左右孩子结点指针也指向了该结点，这样就跟普通的线段树相差无几了</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询的操作基本上跟普通的线段树一样，就是我们可以随便在哪一个历史版本中查询，比如query(root[k],l,r)  表示在第k个历史版本中查询</p>
<h2 id="POJ-2104-区间第k大问题"><a href="#POJ-2104-区间第k大问题" class="headerlink" title="POJ 2104  区间第k大问题"></a>POJ 2104  区间第k大问题</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出n个数，查询区间[l,r]中第k大的数是多少</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul>
<li>首先数据范围比较大，考虑进行离散化，即对所给的数列进行排序，利用每个数在排序后的数组中的下标进行处理</li>
<li>使用可持续化线段树，建立n个线段树，从第一个线段树开始，后面每一个线段树多一个数的信息</li>
<li>实现查询，因为所建立的这n个线段树维护的区间相同，结构相同，将查询区间两个端点的线段树相减就可以得到[l,r]中的信息，再使用二分法递归找到查询的数在整个数组中的排位</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span>  <span class="keyword">int</span> MAX=<span class="number">100005</span>;</div><div class="line"><span class="keyword">int</span> nums[MAX],sorted[MAX],root[MAX];</div><div class="line"><span class="keyword">int</span> cnt;  <span class="comment">//记录主席树节点编号</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> segment</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> sum,l,r;</div><div class="line">&#125;tree[MAX&lt;&lt;<span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">creatnode</span><span class="params">(<span class="keyword">int</span> sum,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> ro=++cnt;</div><div class="line">    tree[ro].sum=sum;</div><div class="line">    tree[ro].l=l;</div><div class="line">    tree[ro].r=r;</div><div class="line">    <span class="keyword">return</span> ro;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> &amp;ro,<span class="keyword">int</span> pre,<span class="keyword">int</span> pos,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></div><div class="line">&#123;</div><div class="line">    ro=creatnode(tree[pre].sum+<span class="number">1</span>,tree[pre].l,tree[pre].r);    <span class="comment">//创建结点，更改区间所维护值</span></div><div class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(pos&lt;=m)</div><div class="line">        Insert(tree[ro].l,tree[pre].l,pos,l,m);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        Insert(tree[ro].r,tree[pre].r,pos,m+<span class="number">1</span>,r);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> S,<span class="keyword">int</span> E,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> l;</div><div class="line">    <span class="keyword">int</span> sum_l=tree[tree[E].l].sum-tree[tree[S].l].sum;   <span class="comment">//表示区间[l,r]的左子区间的个数和</span></div><div class="line">    <span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(k&lt;=sum_l)</div><div class="line">        <span class="keyword">return</span> query(tree[S].l,tree[E].l,l,m,k);      <span class="comment">//二分递归查找</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> query(tree[S].r,tree[E].r,m+<span class="number">1</span>,r,k-sum_l);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,m,num,pos;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m)!=EOF)</div><div class="line">    &#123;</div><div class="line">        cnt=<span class="number">0</span>;</div><div class="line">        root[<span class="number">0</span>]=<span class="number">0</span>;    <span class="comment">//一开始的线段树是一个空的线段树</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nums[i]);</div><div class="line">            sorted[i]=nums[i];</div><div class="line">        &#125;</div><div class="line">        sort(sorted+<span class="number">1</span>,sorted+<span class="number">1</span>+n);</div><div class="line">        num=unique(sorted+<span class="number">1</span>,sorted+<span class="number">1</span>+n)-(sorted+<span class="number">1</span>);  <span class="comment">//离散化，数组中的数用排序后的下表表示</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            pos=lower_bound(sorted+<span class="number">1</span>,sorted+<span class="number">1</span>+num,nums[i])-sorted;</div><div class="line">            Insert(root[i],root[i<span class="number">-1</span>],pos,<span class="number">1</span>,num);    <span class="comment">//创建主席树中的一个又一个结点</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> l,r,k;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;l,&amp;r,&amp;k);</div><div class="line">            pos=query(root[l<span class="number">-1</span>],root[r],<span class="number">1</span>,num,k);</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sorted[pos]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="HDU-4348-区间增加-可持续化"><a href="#HDU-4348-区间增加-可持续化" class="headerlink" title="HDU 4348 区间增加+可持续化"></a>HDU 4348 区间增加+可持续化</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出一个序列，并为每次插入操作添加时间点，进行一下操作：查询区间[l,r]的和；查询时间点k下的[l,r]区间和；更改时间点；为区间[l,r]添加数</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><ul>
<li>为每一个历史版本创建一颗线段树，同时充分利用共有数据，只增加有改变的结点</li>
<li>root数组记录每一个历史版本线段树的根节点信息</li>
<li>lazy思想，在查询的时候再进行向下的更改</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> segnode</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> lt,rt,lv,rv;     <span class="comment">//左右孩子结点的位置，维护的区间值</span></div><div class="line">    ll sum,lazy;      <span class="comment">//lazy思想，在查询的时候再进行修改</span></div><div class="line">&#125;tree[maxn&lt;&lt;<span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="keyword">int</span> cnt,now,a[maxn],root[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;id,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></div><div class="line">&#123;</div><div class="line">    tree[++cnt]=tree[id];</div><div class="line">    id=cnt;</div><div class="line">    tree[id].lv=l;</div><div class="line">    tree[id].rv=r;</div><div class="line">    <span class="keyword">if</span>(l==r)</div><div class="line">    &#123;</div><div class="line">        tree[id].sum=a[l];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">    build(tree[id].lt,l,mid);   <span class="comment">//引用的妙处</span></div><div class="line">    build(tree[id].rt,mid+<span class="number">1</span>,r);</div><div class="line">    tree[id].sum=tree[tree[id].lt].sum+tree[tree[id].rt].sum;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;id,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span></div><div class="line">&#123;</div><div class="line">    tree[++cnt]=tree[id];</div><div class="line">    id=cnt;</div><div class="line">    tree[id].sum+=(min(r,tree[id].rv)-max(l,tree[id].lv)+<span class="number">1</span>)*v;</div><div class="line">    <span class="keyword">if</span>(l&lt;=tree[id].lv &amp;&amp; tree[id].rv&lt;=r)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(tree[id].lv!=tree[id].rv)</div><div class="line">            tree[id].lazy+=v;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> mid=(tree[id].lv+tree[id].rv)&gt;&gt;<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(r&lt;=mid)</div><div class="line">        update(tree[id].lt,l,r,v);    <span class="comment">//引用的妙用</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid)</div><div class="line">        update(tree[id].rt,l,r,v);</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        update(tree[id].lt,l,r,v);</div><div class="line">        update(tree[id].rt,l,r,v);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(l&lt;=tree[id].lv &amp;&amp; tree[id].rv&lt;=r)</div><div class="line">        <span class="keyword">return</span> tree[id].sum;</div><div class="line">    ll ret=(min(r,tree[id].rv)-max(l,tree[id].lv)+<span class="number">1</span>)*tree[id].lazy;</div><div class="line">    <span class="keyword">int</span> mid=(tree[id].lv+tree[id].rv)&gt;&gt;<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(r&lt;=mid)</div><div class="line">        ret+=query(tree[id].lt,l,r);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid)</div><div class="line">        ret+=query(tree[id].rt,l,r);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        ret+=query(tree[id].lt,l,r)+query(tree[id].rt,l,r);</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,m,l,r,t,d;</div><div class="line">    <span class="keyword">char</span> op;</div><div class="line">    <span class="keyword">bool</span> hh=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m)!=EOF)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(hh)</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            hh=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">        now=cnt=<span class="number">0</span>;</div><div class="line">        build(root[<span class="number">0</span>],<span class="number">1</span>,n);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">" %c"</span>,&amp;op);    <span class="comment">//注意前面要加一个空格</span></div><div class="line">            <span class="keyword">if</span>(op==<span class="string">'C'</span>)</div><div class="line">            &#123;</div><div class="line">                now++; <span class="comment">//时间增加</span></div><div class="line">                <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;l,&amp;r,&amp;d);</div><div class="line">                update(root[now]=root[now<span class="number">-1</span>],l,r,d);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(op==<span class="string">'Q'</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;l,&amp;r);</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(root[now],l,r));</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(op==<span class="string">'H'</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;l,&amp;r,&amp;t);</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(root[t],l,r));</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(op==<span class="string">'B'</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;now);</div><div class="line">                cnt=root[now+<span class="number">1</span>]<span class="number">-1</span>;   <span class="comment">//释放结点</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.cnblogs.com/wujiechao/p/6419877.html" target="_blank" rel="external">博客1</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Codeforces Good Bye 2016 题解]]></title>
      <url>/2016/12/31/Codeforces-Good-Bye-2016-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>  2016的最后一场CF，很遗憾昨天没能打这场比赛。只能在今天——2016年的最后一天补上这套题。话说这场比赛是我开始接触CF以来看到报名的人最多的一场比赛，意义特殊。。<br>  从道题通过的人数来看八道题应该分成两个层次（这个跟平常的div1和div2差不多吧），前面四道题应该就是我这个水平做的，后面四道题做出来的人不超过200人，最后一道题做出来的人只有个位数。。。<br>  下面就是前面四道题的题解啦<br>  <a id="more"></a></p>
<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>大水题，数列求和，注意上限</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n,k,i;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</div><div class="line">	k=<span class="number">240</span>-k;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;k&gt;=<span class="number">5</span>*i&amp;&amp;i&lt;=n;++i)k-=<span class="number">5</span>*i;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,i<span class="number">-1</span>);![enter description here][<span class="number">1</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>将地球想象成一个均匀的球体，一个人从北极出发进行一次旅行，给出n个指令，每个指令包含行走的距离和行走的方向，判断旅行的旅行是否符合以下规则：1.在北极只能向南边走；2.在南极只能向北边走；3.最后要回到北极</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>以北极为坐标原点模拟旅行过程，设置标记变量标记是否在南北极，在南北极的时候就不能向东西方向走，同时判断行走的坐标点是否会超过20000或者小于0</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> o;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;o;</div><div class="line">	<span class="keyword">int</span> k,l,t=<span class="number">0</span>;</div><div class="line">	<span class="built_in">string</span> s;</div><div class="line">	l=<span class="number">1</span>;  <span class="comment">//标记在不在南北两级</span></div><div class="line">	<span class="keyword">while</span>(o--)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;k&gt;&gt;s;</div><div class="line">		<span class="keyword">if</span>(l)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(s==<span class="string">"East"</span>||s==<span class="string">"West"</span>)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(s==<span class="string">"North"</span>)</div><div class="line">		&#123;</div><div class="line">			t-=k;</div><div class="line">			<span class="keyword">if</span>(t&lt;<span class="number">0</span>)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(s==<span class="string">"South"</span>)</div><div class="line">		&#123;</div><div class="line">			t+=k;</div><div class="line">			<span class="keyword">if</span>(t&gt;<span class="number">20000</span>)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(t==<span class="number">0</span>||t==<span class="number">20000</span>)</div><div class="line">			l=<span class="number">1</span>;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			l=<span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(t==<span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="同思路但十分简化的代码"><a href="#同思路但十分简化的代码" class="headerlink" title="同思路但十分简化的代码"></a>同思路但十分简化的代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n,p=<span class="number">0</span>,x;<span class="keyword">char</span> s[<span class="number">10</span>];</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">	<span class="keyword">while</span>(n--)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%s"</span>,&amp;x,s);</div><div class="line">		<span class="keyword">if</span>(!p&amp;&amp;s[<span class="number">0</span>]!=<span class="string">'S'</span>)<span class="keyword">return</span> <span class="number">0</span>*<span class="built_in">puts</span>(<span class="string">"NO"</span>);</div><div class="line">		<span class="keyword">if</span>(p==<span class="number">20000</span>&amp;&amp;s[<span class="number">0</span>]!=<span class="string">'N'</span>)<span class="keyword">return</span> <span class="number">0</span>*<span class="built_in">puts</span>(<span class="string">"NO"</span>);</div><div class="line">		<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'S'</span>)p+=x;</div><div class="line">		<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'N'</span>)p-=x;</div><div class="line">		<span class="keyword">if</span>(p&lt;<span class="number">0</span>||p&gt;<span class="number">20000</span>)<span class="keyword">return</span> <span class="number">0</span>*<span class="built_in">puts</span>(<span class="string">"NO"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">puts</span>(p?<span class="string">"NO"</span>:<span class="string">"YES"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><ul>
<li>对于英文题目，一开始理解的时候可能存在一些问题，在看懂样例之后一定要回去看原文，根据原文中的信息去写代码</li>
</ul>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题目以Codeforce的rating制度为背景，根据积分将用户的段位分成两个div1和div2，给出一个人2016年以来每次打比赛之前的所处的段位和比赛后的分数变化，根据这些来判断这个人最后可能最高的分数，可能的答案有：无穷大，不可能的情况，具体的数字</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><ul>
<li>模拟题，设置一个最大值和最小值的范围，根据每一句比赛所给的条件来更新这个范围，在div1则最小值一定在1900以上，在div2则最大值一定在1899以下，更新范围以后再模拟变化再一次更新范围</li>
<li>如果整个过程中出现一次div2，则永远都不会是无穷大</li>
<li>不可能情况的确定，最大值和最小值不符合实际</li>
</ul>
<h4 id="代码1（范围判断为最后结果的范围）"><a href="#代码1（范围判断为最后结果的范围）" class="headerlink" title="代码1（范围判断为最后结果的范围）"></a>代码1（范围判断为最后结果的范围）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> t,maxi=<span class="number">1</span>&lt;&lt;<span class="number">30</span>,mini=<span class="number">-1</span>&lt;&lt;<span class="number">30</span>,flag=<span class="number">1</span>;  <span class="comment">//是否可能是最大值</span></div><div class="line">	<span class="built_in">cin</span>&gt;&gt;t;</div><div class="line">	<span class="keyword">while</span>(t--)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> x,y;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</div><div class="line">		<span class="keyword">if</span>(y==<span class="number">1</span>&amp;&amp;mini&lt;<span class="number">1900</span>)mini=<span class="number">1900</span>;</div><div class="line">		<span class="keyword">if</span>(y==<span class="number">2</span>&amp;&amp;maxi&gt;<span class="number">1899</span>)maxi=<span class="number">1899</span>,flag=<span class="number">0</span>;</div><div class="line">		mini+=x,maxi+=x;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(flag)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Infinity"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(mini&gt;maxi)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Impossible"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;maxi&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="代码2（范围判断为一开始的范围）"><a href="#代码2（范围判断为一开始的范围）" class="headerlink" title="代码2（范围判断为一开始的范围）"></a>代码2（范围判断为一开始的范围）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = (<span class="keyword">int</span>) <span class="number">1e9</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> n;</div><div class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line">  <span class="keyword">int</span> from = -inf, to = inf;</div><div class="line">  <span class="keyword">int</span> delta = <span class="number">0</span>;    <span class="comment">//变化的值</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">    <span class="keyword">int</span> d, cur;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;cur, &amp;d);</div><div class="line">    <span class="keyword">if</span> (d == <span class="number">1</span>) &#123;</div><div class="line">      from = max(from, <span class="number">1900</span> - delta);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      to = min(to, <span class="number">1899</span> - delta);</div><div class="line">    &#125;</div><div class="line">    delta += cur;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (from &gt; to) &#123;</div><div class="line">    <span class="built_in">puts</span>(<span class="string">"Impossible"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (to == inf) &#123;</div><div class="line">    <span class="built_in">puts</span>(<span class="string">"Infinity"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, to + delta);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>以烟花爆炸为背景，相当与在由单位正方形组成的一个平面里面生成一颗树，在分岔点一定会一分为二，从跟到分支给出的是”树“的每一段的长度，求占用的点数（一个单位正方形代表一个点，可以重复占用一个点）</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><ul>
<li>模拟这个平面，使用dfs进行递归，计算占用的正方形的数量</li>
<li>dfs递归函数传入四个参数：位置坐标，当前递归层数，树枝伸展方向</li>
<li>去除重复操作：使用数组标记递归函数的执行情况，四个参数对应四维数组</li>
<li>貌似还可以用dp等方法做出来</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> dy[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,dx[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> used[<span class="number">400</span>][<span class="number">400</span>][<span class="number">31</span>][<span class="number">8</span>];    <span class="comment">//去除重复操作的标记数组</span></div><div class="line"><span class="keyword">bool</span> a[<span class="number">400</span>][<span class="number">400</span>];</div><div class="line"></div><div class="line"><span class="keyword">int</span> t,f[<span class="number">31</span>],h;  <span class="comment">//记录总数</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> d,<span class="keyword">int</span> l)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(used[x][y][d][l])<span class="keyword">return</span>;</div><div class="line">    used[x][y][d][l]=<span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span>(d==h)</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> ix=x,iy=y;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=f[d];i++)</div><div class="line">	&#123;</div><div class="line">	    ix+=dx[l];</div><div class="line">	    iy+=dy[l];</div><div class="line">	    <span class="keyword">if</span>(!a[ix][iy])</div><div class="line">			t++;</div><div class="line">		a[ix][iy]=<span class="literal">true</span>;</div><div class="line">	&#125;</div><div class="line">	dfs(ix,iy,d+<span class="number">1</span>,(l+<span class="number">1</span>)%<span class="number">8</span>);</div><div class="line">	dfs(ix,iy,d+<span class="number">1</span>,(l+<span class="number">7</span>)%<span class="number">8</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;h;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;h;i++)</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;f[i];</div><div class="line">	t=<span class="number">0</span>;</div><div class="line">	dfs(<span class="number">200</span>,<span class="number">200</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;t&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用uWSGI和nginx来搭建Django应用]]></title>
      <url>/2016/11/30/%E4%BD%BF%E7%94%A8uWSGI%E5%92%8Cnginx%E6%9D%A5%E6%90%AD%E5%BB%BADjango%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>近期用python的Django写了一个小程序，想部署到服务器上面。网上搜了一下，发现所有使用nginx的解决方案基本上都是来源于这篇文章。所以就把这篇文章翻译了一下，加深自己的理解。<br><a id="more"></a></p>
<p><a href="http://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html" target="_blank" rel="external">原文地址</a></p>
<p>这篇教程适用于想在生产服务器上搭建应用的Django使用者。只需要几部就可以让你用nginx和uWSGI搭建一个Django应用。它涵盖所有三个组件，提供一个完整的Web应用程序和服务器软件搭建方案。（It covers all three components, providing a complete stack of web application and server software.）</p>
<p>DJango是一个高质量的Web开发框架，鼓励快速、简介、务实的设计（pragmatic design）</p>
<p>nginx是一款免费、开源、高并发访问的HTTP服务器和反向代理以及IMAP/POP3 代理服务器</p>
<h3 id="这篇教程的一些笔记"><a href="#这篇教程的一些笔记" class="headerlink" title="这篇教程的一些笔记"></a>这篇教程的一些笔记</h3><blockquote>
<p>这只是一篇入门教程，它的目的不是提供一个全面的参考指南，不会为开发者提供一个详细的开发指南<br><br><br>nginx和uWSGI是DJango开发者的好选择，但不是唯一的或者说“官方”的选择。每一种方案都有优点，值得你去尝试。<br><br><br>这种方法也许是一种好的方法，但不是唯一的方法，从某些方面来说他甚至不是最好的方法<br><br><br>然而，这是一个可靠和简单的方法，这里涵盖的材料将向您介绍概念和程序，您将需要熟悉用于部署Django的任何软件。<br><br><br>在熟悉了这些配置和这些步骤之后，如果你能够探索其他的方法也能达到相同的目的</p>
</blockquote>
<hr>
<blockquote>
<p>这篇教程假定你的系统已经完成了一些配置<br><br><br>假定你使用的是进行可以进行包管理的Unix系列的系统。然而如果你有类似“Mac OS系统该怎样配置”这样的问题，你会很容易找到这类问题的答案。<br><br><br>这篇教程使用的是Django1.4或者更新版本，它能够在你新建的项目中创建一个wsgi模块。如果你使用的是更早期的版本的话，你需要自己去创建一个wsgi模块</p>
</blockquote>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>一个Web服务面向世界。它能够直接从系统提供一些文件（比如说HTML、图像、CSS等等）。然而，他不能直接从Django中获取，这需要一些东西来运行这些应用，比如来自客户端的请求和响应。</p>
<p><br><br>一个Web服务网关接口==WSGI，就是干这件事情的。WSGI是一个python的标准。<br><br></p>
<p>uWSGI是WSGI的一个实现工具，在这篇教程中我们将设置uWSGI从而创建一个Unix socket服务。服务响应通过WSGi协议来对传给web应用。最后，我们完成的主要原理图如下：</p>
<blockquote>
<p>the web client &lt;-&gt; the web server &lt;-&gt; the socket &lt;-&gt; uwsgi &lt;-&gt; Django</p>
</blockquote>
<h3 id="在开始设置uWSGI之前需要做的准备"><a href="#在开始设置uWSGI之前需要做的准备" class="headerlink" title="在开始设置uWSGI之前需要做的准备"></a>在开始设置uWSGI之前需要做的准备</h3><h5 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h5><p>确保你在虚拟环境下安装软件（稍后我们将介绍在原生系统中安装uWSGI）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">virtualenv uwsgi-tutorial</div><div class="line"><span class="built_in">cd</span> uwsgi-tutorial</div><div class="line"><span class="built_in">source</span> bin/activate</div></pre></td></tr></table></figure>
<h5 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h5><p> 在虚拟环境下安装Django,创建一个项目，并且通过<em>cd</em>来进入这个项目</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> pip install Django</div><div class="line">django-admin.py startproject mysite</div><div class="line"><span class="built_in">cd</span> mysite</div></pre></td></tr></table></figure>
<h5 id="关于域名和端口"><a href="#关于域名和端口" class="headerlink" title="关于域名和端口"></a>关于域名和端口</h5><p>教程中默认你的域名为：example.com  你可以替换成你的域名或者Ip地址<br><br><br>跟Django默认使用的端口一样，在这里我们将始终使用8000端口作为服务的对外端口。当然你也可以使用其他的你想用的端口，但是我使用这个端口并没有和之前的配置发生任何冲突。</p>
<hr>
<h3 id="基本uWSGI安装和配置"><a href="#基本uWSGI安装和配置" class="headerlink" title="基本uWSGI安装和配置"></a>基本uWSGI安装和配置</h3><h5 id="在你的虚拟环境中安装uWSGI"><a href="#在你的虚拟环境中安装uWSGI" class="headerlink" title="在你的虚拟环境中安装uWSGI"></a>在你的虚拟环境中安装uWSGI</h5><blockquote>
<p>pip install uwsgi</p>
</blockquote>
<p>当然还有其他的方式安装，不过这种方法是最好的一种。注意你必须要安装好相关的依赖包。例如在Debain或者像Ubuntu这样与Debain类似的系统中，你就需要安装pythonX.Y-dev（X.Y是你的python版本号）</p>
<h5 id="基础测试"><a href="#基础测试" class="headerlink" title="基础测试"></a>基础测试</h5><p>创建一个叫test.py的文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># test.py</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(env, start_response)</span>:</span></div><div class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>,<span class="string">'text/html'</span>)])</div><div class="line">    <span class="keyword">return</span> [<span class="string">b"Hello World"</span>] <span class="comment"># python3</span></div><div class="line">    <span class="comment">#return ["Hello World"] # python2</span></div></pre></td></tr></table></figure></p>
<hr>
<blockquote>
<p>笔记<br>注意python3需要使用bytes()</p>
</blockquote>
<p>运行uWSGI：</p>
<blockquote>
<p>uwsgi –http :8000 –wsgi-file test.py</p>
</blockquote>
<p>选项的意思：</p>
<blockquote>
<p>http :8000  使用http的8000端口<br>wsgi-file test.py  加载指定文件</p>
</blockquote>
<p>当你使用浏览器访问8000端口的时候应该会看到“Hello，World”的字样</p>
<blockquote>
<p><a href="http://example.com:8000" target="_blank" rel="external">http://example.com:8000</a></p>
</blockquote>
<p>检查如果是这样的话，说明一下这些部分没有问题了；</p>
<blockquote>
<p>the web client &lt;-&gt; uWSGI &lt;-&gt; Python</p>
</blockquote>
<h5 id="测试你的Django应用"><a href="#测试你的Django应用" class="headerlink" title="测试你的Django应用"></a>测试你的Django应用</h5><p>现在uWSGI做着同样的事情，只不过运行的是Django应用而不是test.py模块<br>如果你还没有做到这里，确保你的mysite项目能够工作：</p>
<blockquote>
<p>python manage.py runserver 0.0.0.0:8000</p>
</blockquote>
<p>如果他能够正常工作，就用uWSGI运行它：</p>
<blockquote>
<p>uwsgi –http :8000 –module mysite.wsgi</p>
</blockquote>
<ul>
<li>module mysite.wsgi 加载指定的uWSGI模块</li>
</ul>
<p>在你的浏览器中查看，如果服务能够正常运行，就意味着uWSGI能够从虚拟环境中运行Django应用，现在就到了这一步：</p>
<blockquote>
<p>the web client &lt;-&gt; uWSGI &lt;-&gt; Django</p>
</blockquote>
<p>我们一般不让客户端直接和uWSGI联系。这是Web服务器的工作，在其中扮演者中间人的角色。</p>
<h3 id="Nginx基本配置"><a href="#Nginx基本配置" class="headerlink" title="Nginx基本配置"></a>Nginx基本配置</h3><h5 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install nginx</div><div class="line">sudo /etc/init.d/nginx start    <span class="comment"># start nginx</span></div></pre></td></tr></table></figure>
<p>现在通过浏览器访问网站的80端口，你应该会看到nginx的一条信息：Welcome to nginx!。这就说明一下环节是打通的：</p>
<blockquote>
<p>the web client &lt;-&gt; the web server</p>
</blockquote>
<p>如果其他应用已经占据了80端口，但是你还是想使用nginx服务，你就要更改nginx监听另外的端口。在这篇教程中，我们将使用8000端口。</p>
<h5 id="在你的网站中配置nginx"><a href="#在你的网站中配置nginx" class="headerlink" title="在你的网站中配置nginx"></a>在你的网站中配置nginx</h5><p>你需要uwsgi_params 文件，它能够然nginx又uWSGI支配，你可以从这里<a href="https://github.com/nginx/nginx/blob/master/conf/uwsgi_params" target="_blank" rel="external">下载</a></p>
<p>将它复制到你的项目目录下，接下来nginx将会使用到它。<br>现在创建一个mysite_nginx.conf文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"># mysite_nginx.conf</div><div class="line"></div><div class="line"># the upstream component nginx needs to connect to</div><div class="line">upstream django &#123;</div><div class="line">    # server unix:///path/to/your/mysite/mysite.sock; # for a file socket</div><div class="line">    server 127.0.0.1:8001; # for a web port socket (we&apos;ll use this first)</div><div class="line">&#125;</div><div class="line"></div><div class="line"># configuration of the server</div><div class="line">server &#123;</div><div class="line">    # the port your site will be served on</div><div class="line">    listen      8000;</div><div class="line">    # the domain name it will serve for</div><div class="line">    server_name .example.com; # substitute your machine&apos;s IP address or FQDN</div><div class="line">    charset     utf-8;</div><div class="line"></div><div class="line">    # max upload size</div><div class="line">    client_max_body_size 75M;   # adjust to taste</div><div class="line"></div><div class="line">    # Django media</div><div class="line">    location /media  &#123;</div><div class="line">        alias /path/to/your/mysite/media;  # your Django project&apos;s media files - amend as required</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location /static &#123;</div><div class="line">        alias /path/to/your/mysite/static; # your Django project&apos;s static files - amend as required</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    # Finally, send all non-media requests to the Django server.</div><div class="line">    location / &#123;</div><div class="line">        uwsgi_pass  django;</div><div class="line">        include     /path/to/your/mysite/uwsgi_params; # the uwsgi_params file you installed</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个配置文件告诉nginx服务文件系统中那些媒体和静态文件，并且处理来自Django的请求。为你长远打算你也可以让一个服务处理media/static，另外一个服务处理Django请求，但在这里，这样刚刚好。</p>
<p>创建一个链接到/etc/nginx/sites-enabled让nginx能够识别它：</p>
<blockquote>
<p>sudo ln -s ~/path/to/your/mysite/mysite_nginx.conf /etc/nginx/sites-enabled/</p>
<h5 id="部署静态文件"><a href="#部署静态文件" class="headerlink" title="部署静态文件"></a>部署静态文件</h5></blockquote>
<p>在运行nginx之前，你要在static目录下收集Django用到的静态文件，首先你要在mysite/settings.py中加上：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">STATIC_ROOT = os.path.join(BASE_DIR, <span class="string">"static/"</span>)</div></pre></td></tr></table></figure></p>
<p>然后运行</p>
<blockquote>
<p>python manage.py collectstatic</p>
<h5 id="基本nginx测试"><a href="#基本nginx测试" class="headerlink" title="基本nginx测试"></a>基本nginx测试</h5></blockquote>
<p>重启nginx服务</p>
<blockquote>
<p> sudo /etc/init.d/nginx restart<br>为了检查media文件是否正确，在/path/to/your/project/project/media directory添加一张图片media.png ，然后访问<a href="http://example.com:8000/media/media.png" target="_blank" rel="external">http://example.com:8000/media/media.png</a>  。如果起作用，至少说明nginx能够提供服务。<br>你可以不重启nginx服务，而是先关掉他，然后再重新打开，这样你就会发现一些问题。</p>
</blockquote>
<h3 id="nginx、uWSGI和test-py"><a href="#nginx、uWSGI和test-py" class="headerlink" title="nginx、uWSGI和test.py"></a>nginx、uWSGI和test.py</h3><p>让我们将nginx与‘hello word’的test.py应用连接起来</p>
<blockquote>
<p>uwsgi –socket :8001 –uwsgi-file test.py     #刚才nginx对内的端口是8001</p>
</blockquote>
<p>除了这个部分，这次跟前面一样：</p>
<blockquote>
<p>socket :8001   #使用uwsgi协议，8001端口</p>
</blockquote>
<p>nginx同时也配置成在那个端口与uWSGI相连接，外网连接的端口是8000端口</p>
<p><em><a href="http://example.com:8000/" target="_blank" rel="external">http://example.com:8000/</a></em></p>
<p>点击一下，说明我们现在所处的阶段是：</p>
<blockquote>
<p>the web client &lt;-&gt; the web server &lt;-&gt; the socket &lt;-&gt; uWSGI &lt;-&gt; Python</p>
</blockquote>
<p>于此同时你也可以访问uWSGI的对外端口：8000，但是有非常大的可能他是不会工作的因为你的浏览器使用的是http而不是uWSGI，虽然你能够在你的终端上看到来自uWSGI的输出</p>
<h3 id="使用Unix-sockets来代替端口"><a href="#使用Unix-sockets来代替端口" class="headerlink" title="使用Unix sockets来代替端口"></a>使用Unix sockets来代替端口</h3><p>现在为止我们已经使用了TCP端口（因为它很简单），但是事实上用Unix sockets比端口更好——他会减少很多麻烦（here’s less overhead）</p>
<p>编辑文件 <em>mysite_nginx.conf</em> ，把它改成这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">server unix:///path/to/your/mysite/mysite.sock; <span class="comment"># for a file socket</span></div><div class="line"><span class="comment"># server 127.0.0.1:8001; # for a web port socket (we'll use this first)</span></div></pre></td></tr></table></figure>
<p>然后重启nginx服务</p>
<p>重新运行uWSGI：</p>
<blockquote>
<p>uwsgi –socket mysite.sock –wsgi-file test.py</p>
</blockquote>
<p>这个时候socket告诉uWSGI他要用哪个文件</p>
<p>在浏览器里面再次打开连接<a href="http://example.com:8000/" target="_blank" rel="external">http://example.com:8000/</a> 吧</p>
<h5 id="如果不起作用"><a href="#如果不起作用" class="headerlink" title="如果不起作用"></a>如果不起作用</h5><p>检查你的nginx日志文件（/var/log/nginx/error.log），如果你看到下面的错误：</p>
<blockquote>
<p> connect() to unix:///path/to/your/mysite/mysite.sock failed (13: Permissiondenied)</p>
</blockquote>
<p>也许你需要管理权限允许nginx使用socket</p>
<p>尝试：</p>
<blockquote>
<p>uwsgi –socket mysite.sock –wsgi-file test.py –chmod-socket=666 # (very permissive)</p>
</blockquote>
<p>或者：</p>
<blockquote>
<p>uwsgi –socket mysite.sock –wsgi-file test.py –chmod-socket=664 # (more sensible)</p>
</blockquote>
<p>你可能还需要添加你的用户到nginx的用户群中去（可能是类似www-data这样的），这样nginx就可以读写你的socket了</p>
<p>nginx的日志文件值得你在终端一直打开，这样你就可以很容易排除错误</p>
<h3 id="使用uWSGI和nginx来运行Django应用"><a href="#使用uWSGI和nginx来运行Django应用" class="headerlink" title="使用uWSGI和nginx来运行Django应用"></a>使用uWSGI和nginx来运行Django应用</h3><p>让我们来运行我们的Django 应用：</p>
<blockquote>
<p>uwsgi –socket mysite.sock –module mysite.wsgi –chmod-socket=664</p>
</blockquote>
<p>现在uWSGI和nginx应该不只是显示‘hello，world’了，而是你的Django应用。</p>
<h3 id="配置一个-ini文件来让你的uWSGI运行"><a href="#配置一个-ini文件来让你的uWSGI运行" class="headerlink" title="配置一个.ini文件来让你的uWSGI运行"></a>配置一个.ini文件来让你的uWSGI运行</h3><p>我们可以将一些我们常用的uWSGI选项加入一个文件中，然后让uWSGI去运行这个文件，这能够让我们更好得管理我们的配置</p>
<p>创建一个文件mysite_uwsgi.ini</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># mysite_uwsgi.ini file</div><div class="line">[uwsgi]</div><div class="line"></div><div class="line"># Django-related settings</div><div class="line"># the base directory (full path)</div><div class="line">chdir           = /path/to/your/project</div><div class="line"># Django&apos;s wsgi file</div><div class="line">module          = project.wsgi</div><div class="line"># the virtualenv (full path)</div><div class="line">home            = /path/to/virtualenv</div><div class="line"></div><div class="line"># process-related settings</div><div class="line"># master</div><div class="line">master          = true</div><div class="line"># maximum number of worker processes</div><div class="line">processes       = 10</div><div class="line"># the socket (use the full path to be safe</div><div class="line">socket          = /path/to/your/project/mysite.sock</div><div class="line"># ... with appropriate permissions - may be needed</div><div class="line"># chmod-socket    = 664</div><div class="line"># clear environment on exit</div><div class="line">vacuum          = true</div></pre></td></tr></table></figure>
<p>然后用这个文件运行uWSGI：</p>
<blockquote>
<p>uwsgi –ini mysite_uwsgi.ini # the –ini option is used to specify a file<br>（注意这里同时也要给socket加权限才可以）</p>
</blockquote>
<p>测试Django应用是否运行成功</p>
<h3 id="在本地系统中运行uWSGI"><a href="#在本地系统中运行uWSGI" class="headerlink" title="在本地系统中运行uWSGI"></a>在本地系统中运行uWSGI</h3><p>到目前为止，uWSGI只能够在我们的虚拟环境下运行，为了开发我们要将他放在本地系统中</p>
<p>退出虚拟环境：</p>
<blockquote>
<p>deactivate</p>
</blockquote>
<p>在本地系统安装uWSGI：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo pip install uwsgi</div><div class="line"></div><div class="line"><span class="comment"># Or install LTS (long term support).</span></div><div class="line">pip install http://projects.unbit.it/downloads/uwsgi-lts.tar.gz</div></pre></td></tr></table></figure>
<p>uWSGI的Wiki中有一个<a href="http://projects.unbit.it/uwsgi/wiki/Install" target="_blank" rel="external">安装说明</a>，在安装之前，值得你去考虑使用哪个版本并且使用最合适的方式去安装它</p>
<p>再一次检查你能够跟之前一样运行uWSGI：</p>
<blockquote>
<p>uwsgi –ini mysite_uwsgi.ini # the –ini option is used to specify a file</p>
</blockquote>
<h3 id="Emperor-模式"><a href="#Emperor-模式" class="headerlink" title="Emperor 模式"></a>Emperor 模式</h3><p>uWSGI能够运行emperor模式。再这个模式下，能够监视uWSGI的配置文件，并且为每种情况产生样例（will spawn instances (‘vassals’) for each one it finds.）</p>
<p>每次只要配置文件修改了，emperor就会自动重启服务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># create a directory for the vassals</span></div><div class="line">sudo mkdir /etc/uwsgi</div><div class="line">sudo mkdir /etc/uwsgi/vassals</div><div class="line"><span class="comment"># symlink from the default config directory to your config file</span></div><div class="line">sudo ln <span class="_">-s</span> /path/to/your/mysite/mysite_uwsgi.ini /etc/uwsgi/vassals/</div><div class="line"><span class="comment"># run the emperor</span></div><div class="line">uwsgi --emperor /etc/uwsgi/vassals --uid www-data --gid www-data</div></pre></td></tr></table></figure></p>
<p>你可能要用到超级用户的权限来运行：</p>
<blockquote>
<p>sudo uwsgi –emperor /etc/uwsgi/vassals –uid www-data –gid www-data</p>
</blockquote>
<p>选项的含义：</p>
<ul>
<li>emperor ： 去哪里找到服务</li>
<li>uid: 启动的用户id</li>
<li>gid：启动的群id</li>
</ul>
<p>检查一下站点服务，它应该能够成功运行</p>
<h3 id="让uWSGI自启动"><a href="#让uWSGI自启动" class="headerlink" title="让uWSGI自启动"></a>让uWSGI自启动</h3><p>最后一步就是让以上这些在开机的时候能够自启动</p>
<p>你只需要编辑/etc/rc.local 并添加：</p>
<blockquote>
<p>/usr/local/bin/uwsgi –emperor /etc/uwsgi/vassals –uid www-data –gid www-data –daemonize /var/log/uwsgi-emperor.log</p>
</blockquote>
<p>更加全面的ini配置文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">[uwsgi]</div><div class="line">uid = www                                        <span class="comment"># 设置启动的用户组</span></div><div class="line">gid = www</div><div class="line"> </div><div class="line"><span class="built_in">chdir</span> = /alidata/www/fdcode/devops               <span class="comment"># 指定项目目录</span></div><div class="line"> </div><div class="line">module = wsgi                                    <span class="comment"># 加载wsgi.py模块</span></div><div class="line"> </div><div class="line">master = <span class="literal">true</span>                                    <span class="comment"># 启动主进程，一般设置true或 1</span></div><div class="line"> </div><div class="line">processes = 2                                    <span class="comment"># 设置启动的进程数</span></div><div class="line"> </div><div class="line">listen = 100                                     <span class="comment"># 设置socket监听队列大小，超出队列的请求将会被拒绝</span></div><div class="line"> </div><div class="line">;socket = /var/run/uwsgi/uwsgi.sock              <span class="comment"># 设置socket监听</span></div><div class="line"> </div><div class="line">socket = :9090                                   <span class="comment"># 设置端口监听</span></div><div class="line"> </div><div class="line">pidfile = /var/run/uwsgi/uwsgi.pid               <span class="comment"># 指定pid文件</span></div><div class="line"> </div><div class="line">vacuum = <span class="literal">true</span>                                    <span class="comment"># 当服务器退出的时候自动删除unixsocket文件和pid文件。</span></div><div class="line"> </div><div class="line"><span class="built_in">enable</span>-threads = <span class="literal">true</span>                            <span class="comment"># 允许用内嵌的语言启动线程。这将允许你在app程序中产生一个子线程</span></div><div class="line"> </div><div class="line">buffer-size = 32768                              <span class="comment"># 设置用于uwsgi包解析的内部缓存区大小为64k。默认是4k。</span></div><div class="line"> </div><div class="line">reload-mercy = 8                                 <span class="comment"># 设置在平滑的重启（直到接收到的请求处理完才重启）一个工作子进程中，等待这个工作结束的最长秒数。这个配置会使在平滑地重启工作子进程中，如果工作进程结束时间超过了8秒就会被强行结束（忽略之前已经接收到的请求而直接结束）</span></div><div class="line"> </div><div class="line">max-requests = 5000                              <span class="comment"># 为每个工作进程设置请求数的上限。当一个工作进程处理的请求数达到这个值，那么该工作进程就会被回收重用（重启）。你可以使用这个选项来默默地对抗内存泄漏</span></div><div class="line"> </div><div class="line"><span class="built_in">limit</span>-as = 512                                   <span class="comment"># 通过使用POSIX/UNIX的setrlimit()函数来限制每个uWSGI进程的虚拟内存使用数。这个配置会限制uWSGI的进程占用虚拟内存不超过256M。如果虚拟内存已经达到256M，并继续申请虚拟内存则会使程序报内存错误，本次的http请求将返回500错误。</span></div><div class="line"> </div><div class="line">harakiri = 60                                    <span class="comment"># 一个请求花费的时间超过了这个harakiri超时时间，那么这个请求都会被丢弃，并且当前处理这个请求的工作进程会被回收再利用（即重启）</span></div><div class="line"> </div><div class="line">daemonize = /alidata/<span class="built_in">log</span>/uwsgi/uwsgi_server.log  <span class="comment"># 使进程在后台运行，并将日志打到指定的日志文件或者udp服务器</span></div></pre></td></tr></table></figure></p>
<h2 id="总结一波"><a href="#总结一波" class="headerlink" title="总结一波"></a>总结一波</h2><p>在一开始的流程图中各段的实现：</p>
<ul>
<li><p>the web client &lt;-&gt; the web server<br>通过nginx服务器，监听的是8000端口。配置文件：mysite_nginx.conf</p>
</li>
<li><p>the web server &lt;-&gt; the socket<br>nginx配置文件指定socket,  在配置文件中添加sock路径  我这里是htmltest/htmltest.sock   配置文件：mysite_nginx.conf</p>
</li>
<li><p>the socket &lt;-&gt; uwsgi<br>通过指定socket（给出socket的路径） 配置文件：mysite_uwsgi.ini  （注意要在配置中给uWSGI权限）</p>
</li>
<li><p>uwsgi &lt;-&gt; Django<br>通过指定服务模块  配置文件：mysite_uwsgi.ini</p>
</li>
</ul>
<p>第一次翻译文章，如果有什么恰当的地方望指正。</p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[技术的正宗与野路子（转）]]></title>
      <url>/2016/11/25/%E6%8A%80%E6%9C%AF%E7%9A%84%E6%AD%A3%E5%AE%97%E4%B8%8E%E9%87%8E%E8%B7%AF%E5%AD%90/</url>
      <content type="html"><![CDATA[<blockquote>
<p>黄衫女子的武功似乎与周芷若乃是一路，飘忽灵动，变幻无方，但举手抬足之间却是正而不邪，如说周芷若形似鬼魅，那黄衫女子便是态拟神仙。</p>
</blockquote>
<p>这段描写出自《倚天屠龙记》第三十八回。<br>“九阴神抓”本是《九阴真经》中的上乘武功，但当初梅超风夫妇由于拿到的《九阴真经》不完整，学不到里面的内功心法，硬是把这门上乘武功练到了邪路上，于是就成了“九阴白骨爪”。周芷若为求速成，也练就了这门邪功。<br>但黄衫女子乃出身武林名门（相传是杨过和小龙女的后人），自然修炼的是正宗的《九阴真经》。虽然武功路数与周芷若本同属一脉，但更加“醇真深厚”，自然也更胜一筹。这是金庸武侠中“正宗”武功胜过“野路子”的一个典型案例。<br>那么，这是否能够说明，“正宗”一定强于“野路子”呢？<br><a id="more"></a><br>且慢！<br>喜欢金庸武侠的朋友，可还记得《越女剑》中的阿青？<br>阿青本是一名牧羊女，却在牧羊时巧遇一头会使竹棒的白猿。在与白猿的玩耍嬉闹中，她硬是悟得了高超的剑法，竟能以一人之力敌两千越甲！<br>就是这样一个从野路子练出来的柔弱女子，即使按广大金庸迷的保守估计，她也能在整个金庸武侠图谱中至少排名前五！<br>做技术，犹如修习一门武功。<br>历数我周围的技术牛人（牛不到一定程度的先不算），他们中既有名牌大学计算机科班毕业的，也有半路出家转行过来的。<br>但他们都有一个共同特点：他们在遇到问题后，思考片刻，总是能一下子切中要害，在表达上也往往一语中的。这也包括那些平常不善言辞的程序员。反观那些“更一般”的程序员（其中不乏科班毕业的），他们经常很难抓住问题的本质，表达起来也总是说不到点子上。<br>可见，“正宗”还是“野路子”，并不在出身。<br>写到这里，我终于自己长出了一口气。我出身一个极普通的农民家庭，既不是书香门第，也不是技匠世家。记得在大学一年级的上机编程课上，我才发现自己原来根本不会用键盘打字。相比那些初中高中就把计算机玩得很溜的同学，我算野路子吗？<br>好了，那“正宗”还是“野路子”，不在出身在什么呢？<br>在于学习和思考的方法。<br>据我观察，技术牛人的学习方法和思考方式，大体类似。<br>思考方式，是个很难说清的东西。所以，本文我们重点来讨论讨论学习的方法。<br>面对一项新技术的时候，我们怎样去学习才能循序渐进，最终理解得深刻？<br>让我们先把可供自学的资料列出来，分析一下：</p>
<ul>
<li>Tutorial（入门教程）。由该项技术的官网提供。通常是英文的。这份资料是给初次接触该项技术的人看的，一般是一步一步地教你完成某些例子。当我们说某项技术对于新手不太友好的时候，一般也是因为这项技术的Tutorial部分做得不够好。</li>
<li>Specification，简称Spec。这是集中体现该项技术的设计思想的东西，是高度抽象的描述。这个一般也是一份完备的、系统的描述，包含该项技术涉及到的方方面面。这部分资料在不同的地方叫法不同，在相对简单的技术项目中，也可能没有；在另一些情况下，这部分资料混杂在其它文档资料之中；它还可能以论文（paper）的形式出现。</li>
<li>API Reference。大而全的API索引和文档，针对不同的语言接口可能提供多份。当我们使用这项技术进行编程的时候，API Reference自然是个离不开的、总是要不停去查询的一份资料。</li>
<li>别人写的技术博客。质量良莠不齐，到底有没有价值，我们要学会去分辨。</li>
<li>技术书籍。跟技术博客类似，质量有好有坏。稍后我们和技术博客放在一起来分析。</li>
<li>Source Code。如果我们要学习的技术是开源的，那么很幸运，我们能得到源代码。这是一份终极资料。</li>
</ul>
<p>为了让这些概念表达无误，我接下来多举一些例子。</p>
<h2 id="Java语言"><a href="#Java语言" class="headerlink" title="Java语言"></a>Java语言</h2><p>从来没有接触过Java语言的人，要想开始自学Java，从哪里开始呢？可以从Oracle官方提供的Tutorial入手：</p>
<ul>
<li><a href="http://docs.oracle.com/javase/tutorial/" target="_blank" rel="external">http://docs.oracle.com/javase/tutorial/</a></li>
</ul>
<p>这份资料《The Java™ Tutorials 》，集中体现了Tutorial类型的资料的特点。它从最开始的编译和运行环境搭建说起，教你写出第一个Hello World，再用介绍的方式将Java各种语言特性（变量、类、泛型、Lambda表达式、JavaBeans，等等）进行讲解，同时还有对于JDK里常用API（集合类、多线程、IO等等）的介绍。<br>对初学者而言，需要的就是这样一份资料。即使你手头没有任何Java的入门书籍，读完这样的一份资料之后，一个新手基本就可以开始使用Java来编程了。<br>再看Spec：</p>
<ul>
<li><a href="http://docs.oracle.com/javase/specs/jls/se8/html/index.html" target="_blank" rel="external">http://docs.oracle.com/javase/specs/jls/se8/html/index.html</a></li>
</ul>
<p>这份文档，叫做《The Java® Language Specification》。是一份很典型的Spec，完备而规范。<br>任何讲Java语法的资料，包括各种书籍和前面提到的Tutorial，都只能涉及部分。而这份Spec，如果你能读通的话，那么与Java语言特性有关的所有一切，你就再也不用求人了。<br>JDK 8的API Reference:</p>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="external">http://docs.oracle.com/javase/8/docs/api/index.html</a></li>
</ul>
<p>用Java语言编程的时候，我们需要不断查阅的就是这份API Reference。我们平常一般是通过IDE来快速查看某个接口的文档说明。</p>
<h2 id="Android开发"><a href="#Android开发" class="headerlink" title="Android开发"></a>Android开发</h2><p>Android针对新手的Tutorial类型的资料，官网上称为Training：</p>
<ul>
<li><a href="https://developer.android.com/training/index.html" target="_blank" rel="external">https://developer.android.com/training/index.html</a></li>
</ul>
<p><img src="http://oeziv5rwi.bkt.clouddn.com/2016/11/25/003.jpg" alt=""></p>
<p>这份资料是典型的Tutorial。它教你制作第一个Android App，并针对若干个主题进行一步一步的教学。<br>下面这份资料在Android官网上被称为：API Guides。</p>
<ul>
<li><a href="https://developer.android.com/guide/index.html" target="_blank" rel="external">https://developer.android.com/guide/index.html</a><br><img src="http://oeziv5rwi.bkt.clouddn.com/2016/11/25/004.jpg" alt=""></li>
</ul>
<p>它实际上是一份介于Tutorial和Spec之间的文档。它有很多Spec的特点，比如它介绍Android中的抽象的四大组件的概念，介绍资源尺寸的抽象（dp），介绍View层原理，等等。但是，跟前面看到的Java Spec相比，它没有那么规范和正式，描述也更随意一些，估计也算不上完备（但涉及到了Android技术的绝大部分）。<br>当我们对Android中某项具体技术存疑，或是有争论的时候，我们就需要来翻翻这份文档。因此，它基本可以归入Spec类型。<br>然后是Android SDK的API Reference：</p>
<ul>
<li><a href="https://developer.android.com/reference/packages.html" target="_blank" rel="external">https://developer.android.com/reference/packages.html</a></li>
</ul>
<p>这份API Reference的质量并不高，描述上过于简略，甚至模糊不清，其可读性跟前面提到的JDK 8的API Reference完全不在一个水平上。这也是一些开源项目的通病，不重视接口文档。</p>
<h2 id="iOS开发"><a href="#iOS开发" class="headerlink" title="iOS开发"></a>iOS开发</h2><p>苹果在iOS开发方面给出的文档是相当丰富的，这也是一个闭源系统做得好的地方。<br>iOS开发的文档，很难区分出Tutorial和Spec这两个层面。它由很多文档组成，每个文档描述系统的某一方面。通常是在一个文档中，既有教学的部分，又有完备描述的部分。<br>针对完全的新手入门的话，下面这个文档，算是真正的一个Tutorial：</p>
<ul>
<li>Start Developing iOS Apps (Swift)(<a href="https://developer.apple.com/library/ios/referencelibrary/GettingStarted/DevelopiOSAppsSwift/index.html" target="_blank" rel="external">https://developer.apple.com/library/ios/referencelibrary/GettingStarted/DevelopiOSAppsSwift/index.html</a>)</li>
</ul>
<p>其它各个文档也是介于Tutorial和Spec之间，更偏向Spec。比如：</p>
<ul>
<li>App Programming Guide for iOS(<a href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html</a>)</li>
<li>View Controller Programming Guide for iOS(<a href="https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/index.html" target="_blank" rel="external">https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/index.html</a>)</li>
<li>View Programming Guide for iOS(<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html</a>)</li>
<li>Core Animation Programming Guide(<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html" target="_blank" rel="external">https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html</a>)</li>
<li>Concurrency Programming Guide(<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html</a>)</li>
</ul>
<p>然后是iOS的API Reference：</p>
<ul>
<li><a href="https://developer.apple.com/reference/" target="_blank" rel="external">https://developer.apple.com/reference/</a></li>
</ul>
<p>如前所述，这份API Reference的可读性非常高，比Android SDK的要强多了。很多前后相关的概念，在这份API Reference的描述中，都有体现。<br>当然，除了developer.apple.com之外，iOS的文档也都可以通过XCode取到。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis的Tutorial是我见过的最好的Tutorial，它对初学者非常友好，不仅能读，还能执行。</p>
<ul>
<li><a href="http://try.redis.io/" target="_blank" rel="external">http://try.redis.io/</a></li>
</ul>
<p><img src="http://oeziv5rwi.bkt.clouddn.com/2016/11/25/005.jpg" alt=""></p>
<p>Redis的Spec举例:</p>
<ul>
<li>Redis Protocol specification (<a href="http://redis.io/topics/protocol" target="_blank" rel="external">http://redis.io/topics/protocol</a>)</li>
<li>Redis Cluster Specification (<a href="http://redis.io/topics/cluster-spec" target="_blank" rel="external">http://redis.io/topics/cluster-spec</a>)</li>
<li>Redis RDB Dump File Format (<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format" target="_blank" rel="external">https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format</a>)</li>
</ul>
<p>Redis的Commands Reference:</p>
<ul>
<li><a href="http://redis.io/commands" target="_blank" rel="external">http://redis.io/commands</a></li>
</ul>
<h2 id="TCP-HTTP网络协议"><a href="#TCP-HTTP网络协议" class="headerlink" title="TCP/HTTP网络协议"></a>TCP/HTTP网络协议</h2><p>与前面的都不同，它不是一个实现，而是一种标准。<br>网络协议的Spec文档很明显，就是它们对应的RFC。如果你的工作经常涉及到使用某个网络协议，恐怕就需要找来RFC通读一遍了。<br>再来说一下技术博客和技术书籍。<br>现在网上的技术文章空前繁荣，想读都读不过来。胡峰同学在他的微信公众号“瞬息之间”上，发过一篇文章《技术干货的选择性问题》，讨论的就是技术人员在当前技术文章爆炸的情况下如何取舍的问题。<br>在这里，我们从另一个角度来讨论一下这个问题。如果一篇技术文章，仅仅是对于所涉及技术的官方文档（Tutorial或Spec）的复述，甚至只是个翻译，那么就价值不高。换句话说，如果我们能通过阅读官方文档学到同样的知识，那为什么要看你写的技术文章呢？官方文档自然更权威，直接阅读它能确保不会遗漏重要的东西。<br>那什么样的技术文章才有价值呢？大概可以说（未必那么准确），那些包涵了实践经验的，能将各个技术点综合起来产生思考，从而给人以启迪的。简单来说，就是有深度的。<br>当然，技术书籍也大体如此。<br>我们回过头来再看一下，各个学习资料之间的层次结构。</p>
<p><img src="http://oeziv5rwi.bkt.clouddn.com/2016/11/25/006.jpg" alt=""></p>
<p>每当我们接触一项新的技术的时候，我们都要把手头的资料按照类似的这样一个金字塔结构进行分类。如果我们阅读了一些技术博客和技术书籍，那么也要清楚地知道它们涉及到的是金字塔中的哪些部分。<br>最开始，一般读完Tutorial之后，就基本能上手做一些开发工作了。然后一边开发，一边查阅API Reference。注意，从这时候起，你的老板就开始向你付工资了，因为你的工作已经能够产出成果了。<br>但是，工作一段时间之后，我们发现，似乎身边的技术牛人学东西都比较快，而且在很短的时间内就能对某项新技术达到很深的理解。这是为什么呢？<br>这并不是因为技术牛人阅读技术资料阅读得快，而是他们知道阅读正确的资料，从而很快能达到知识金字塔更高的一层。<br>我见过的很多技术牛人，他们如果不是把一项技术至少理解到Spec那个层次，他们是不敢随便写代码的。相反另一些人则从网上随意拷贝代码，并在自己不能完全理解的情况下用到项目中去。技术牛人们当然也参考网上的代码，但他们通常会确保它的每一部分都能安放在知识金字塔的某一部分，他们不容许那种不属于任何体系的知识孤岛的出现。<br>我们现在可以这样总结，技术的“野路子”，其实是知识结构的不完整和不系统造成的一种状态。只有当你冲破知识金字塔层层的障碍，迈向更高层次的时候，老板才开始向你付高价。<br>我们的大脑好比内存。<br>既然是内存，就装不下所有的知识。但应该能装下对于知识的索引，否则我们便没法工作了。<br>那么，这里就有一个选择性的问题：我们选择哪部分知识加载到“内存”里呢？<br>显然，应该优先选择重要的，对我们最有用的信息。<br>对于那些最核心的技术，我们应该做到：</p>
<ul>
<li>通读Spec。读完就不再困惑。</li>
<li>重要部分的API Reference要通读。里面包含了很多跟实现有关的信息。</li>
<li>如果工作需要，还可能需要读到Source Code。特别是对于平常一直在使用的SDK，不一定从头到尾把源码读通，这样工作量太大且效率不高，但一定要把你的开发环境设置成一点击某个调用的方法就能跳转进源码实现。只有这样，你才能把平常开发的时间利用起来，随时随刻都点过去看源码。</li>
</ul>
<p>对于剩下的知识里80%的部分，应该至少理解到Spec层次。只有这样，我们才能游刃有余地去使用它。<br>通读重要的Spec，在很多情况下，其实还是很有难度的。这需要毅力，和一点点英语基础。<br>按本文前面提到的例子，做Java的人有谁读过Java Spec？做Android的人有谁把developer.android.com上的API Guides都能通读下来？而做iOS的人，developer.apple.com上的各个Programming Guide又完整地读过几个？对于经常调用的SDK，你会有计划地去通读其中重要部分的API Reference吗？<br>能够把这一套做下来的，有可能不成为技术牛人吗？<br>到了文章最后了，总感觉还有些意犹未尽，脑海中似乎有些东西还是没有表达出来，也不确定本文描述的学习方式是不是适用于每位读者。仔细想想也难怪，学习本来就是一个复杂的问题，每个人并不是完全一样的套路。<br>但是，不管本文介绍的方法是“正宗”的路子，还是属于“野路子”，我在这里想要强调的一点是很明确的，那就是：要把知识梳理成系统的结构，要让头脑中的知识层次清楚，为此，我们需要阅读恰当的东西，需要不断地练习，需要克服种种困难。<br>成长没有捷径可走。需要的是一个一个坚实的突破。</p>
<p>文章转自 <a href="http://zhangtielei.com/posts/blog-programmer-learn.html" target="_blank" rel="external">张铁蕾</a></p>
]]></content>
      
        <categories>
            
            <category> 杂记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Codeforces #381（Div.2）题解]]></title>
      <url>/2016/11/25/Codeforces-381%EF%BC%88Div-2%EF%BC%89%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>第二次打CF，一开始的读题速度是快了一点但是在英语环境下对题目中的一些细节和关键部分的理解还是有待加强。<br>这次想玩玩hack结果锁定题目太早了，导致A马上就被hack了，改都不能改，哎，好气啊。。。</p>
<a id="more"></a>
<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>Alynoa去买书，1、2、3本书套装的售价分别为a、b、c，已知Alynoa手中有n本书，假设他买了k本书后总共拥有的书的数量能够被4整除，求他购买这k本书的最小花费。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul>
<li>一开始想到的就是模拟，分四种情况（需要0/1/2/3本书）进行讨论，需要注意的是除0外的每种情况下都有三种选择，要从这些方案中找到一个最小消耗方案（一开始被hack了）</li>
<li>后面发现可以用DP做（感觉有点大财小用），状态转移方程为 <em>dp[i]=min(dp[i-1]+a,dp[i-2]+b,dp[i-3]+c)</em></li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>模拟做法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span>  n,a,b,c,p,res;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</div><div class="line">        p=n%<span class="number">4</span>;</div><div class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        p=<span class="number">4</span>-p;</div><div class="line">        <span class="keyword">if</span>(p==<span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            res=min(a,min(<span class="number">3</span>*c,b+c));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(p==<span class="number">2</span>)</div><div class="line">            res=min(<span class="number">2</span>*a,min(b,<span class="number">2</span>*c));</div><div class="line">        <span class="keyword">if</span>(p==<span class="number">3</span>)</div><div class="line">            res=min(<span class="number">3</span>*a,min(c,a+b));</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>DP 做法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span>  n,a,b,c,res;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> co[<span class="number">10</span>];</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</div><div class="line">    &#123;</div><div class="line">        res=<span class="number">1e18</span>;</div><div class="line">        fill(co,co+<span class="number">9</span>,<span class="number">1e18</span>);</div><div class="line">        co[<span class="number">0</span>]=<span class="number">0</span>;  <span class="comment">//没买书的花费为0</span></div><div class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</div><div class="line">        <span class="keyword">if</span>(n%<span class="number">4</span>==<span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)   <span class="comment">//最多买9本书</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">1</span>)co[i]=min(co[i],co[i<span class="number">-1</span>]+a);</div><div class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">2</span>)co[i]=min(co[i],co[i<span class="number">-2</span>]+b);</div><div class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">3</span>)co[i]=min(co[i],co[i<span class="number">-3</span>]+c);</div><div class="line">            <span class="keyword">if</span>((n+i)%<span class="number">4</span>==<span class="number">0</span>)res=min(res,co[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><h4 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h4><p>给出一些花的魅力值和花的一些组合（给出花魅力值的几个区间），求从这些组合中取出某几个中的花的魅力总数最大。</p>
<blockquote>
<p>The first line contains two integers n and m (1 ≤ n, m ≤ 100) — the number of flowers and the number of subarrays suggested by the mother.</p>
<p>The second line contains the flowers moods — n integers a1, a2, …, an ( - 100 ≤ ai ≤ 100).</p>
<p>The next m lines contain the description of the subarrays suggested by the mother. The i-th of these lines contain two integers li and ri (1 ≤ li ≤ ri ≤ n) denoting the subarray a[li], a[li + 1], …, a[ri].</p>
<p>Each subarray can encounter more than once.</p>
</blockquote>
<hr>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul>
<li>将给出的每个区间的花的魅力值相加，如果和为负就舍弃，和为正加入，算出最后的总和</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,m,a[<span class="number">101</span>],s[<span class="number">101</span>],res,i,j,x,y;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</div><div class="line">    &#123;</div><div class="line">        res=s[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</div><div class="line">            s[i]=s[i<span class="number">-1</span>]+a[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(m--)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</div><div class="line">            j=s[y]-s[x<span class="number">-1</span>];</div><div class="line">            <span class="keyword">if</span>(j&gt;<span class="number">0</span>)      <span class="comment">//只取和为正的区间</span></div><div class="line">                res+=j;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><h4 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h4><p>首先给出mex的定义：在数组中不存在的最小正整数。然后给出一个数组的长度n，和m个子数组区间（起止点），求依据这个信息能够构造的一个数组，使得所有的mex的最小值最大。并输出这个数组。</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul>
<li>mex不难求，整体的mex最小值也很容易找到（就是所有给出区间长度的最小值+1）。关键是后面数组的构造。</li>
<li>构造数组的方法，假设我们找到的最大的mex最小值为mexi，从数组开始0-mexi不停的循环赋值，因为求得的mexi是最小的并且构造是连续的，凡事数组长度大于mexi的区间都会有0-mex的所有数，这样这个区间就不会出现其mex值比发现的mexi值小的情况。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"></div><div class="line">ll a[<span class="number">100005</span>],b[<span class="number">100005</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,m;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</div><div class="line">    &#123;</div><div class="line">        ll res=<span class="number">1e10</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;a[i]&gt;&gt;b[i];</div><div class="line">            res=min(res,b[i]-a[i]+<span class="number">1</span>);     <span class="comment">//取最小的mex值</span></div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">int</span> tem=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(n--)     <span class="comment">//重复不断地从0-mexi赋值</span></div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;tem&lt;&lt;<span class="string">" "</span>;</div><div class="line">            tem++;</div><div class="line">            <span class="keyword">if</span>(tem==res)</div><div class="line">                tem=<span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>在理解题意、解题速度方面，英语还是一个很大的障碍。这次比赛就是因为英语，在很多地方对题目的理解都存在偏差。要学好英语</li>
<li>因为好奇hack是什么，所以A题一过样例就锁定了，结果被hack了还不能改。呜呜呜。。。hack是高手玩的东西，以后不要一过了就锁定题目，要hack也要等快结束了再玩（不过话说那个时候能hack的就已经被hack得差不多了。。。）</li>
<li>练水题速度、练水题速度、练水题速度。重要的事情说三遍！</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初次打codeforces]]></title>
      <url>/2016/11/16/%E5%88%9D%E6%AC%A1%E6%89%93codeforces/</url>
      <content type="html"><![CDATA[<p>今天凌晨开始了的第一把CF（并不是TC的CF），第一次做全英文的题目，第一次在国外的的平台上比赛，还是有一些鸡冻的。昨天大致的看了看codeforces，感觉确实比国内的一些平台做得好（在比赛中的体验也确实是这样），特别是看到传说中的tourist大神，看到他的rating曲线，感觉好牛逼啊。。。。。。<br><a id="more"></a><br><img src="http://oeziv5rwi.bkt.clouddn.com/2016/11/16/001.PNG" alt=""><br>看了看题目，前面两道题的确是大水题，注意数据范围基本上可以一次性AC。<br><img src="http://oeziv5rwi.bkt.clouddn.com/2016/11/16/002.PNG" alt=""><br>因为是全英文的理解题意还是需要一段时间的（原谅我这个英语渣渣），前面两道题花了40分钟，感觉应该再快一点的（第一次打这个比赛总是小心翼翼的）。<br>到了第三题，光看懂题目的意思我就花了二十多分钟差不多半个小时，看懂题目以后觉得是一个贪心题，然后找各种优化，但是总是超时，然后继续找办法优化，然后就一直一直卡在这里了（当我意识可以看看后面有没有题可以的时候，就只有十分钟左右了），就这样我的第一次CF就这样结束了。。。。。</p>
<hr>
<p>只A了两题，第一次比赛以后我的状态是这样的<br><img src="http://oeziv5rwi.bkt.clouddn.com/2016/11/16/003.PNG" alt=""><br>今天早上起来看了看官方的题解，发现昨天的C题我的思路是对的，但是我忽视了一个两个单词：<strong>not decreasing</strong> 他还特别设置为粗体，但是我就是没看到，求英语不好的我心理阴影面积有多大。。。<br>下面贴上我C题的题解吧：</p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>安东正在玩一个非常有趣的电脑游戏，但现在他被困在一个级别。要传递到下一个级别，他必须准备n药水。</p>
<p>安东有一个特殊的水壶，可以在x秒内准备一瓶药水。此外，他知道两种类型的法术，可以更快的准备药水的过程。</p>
<ul>
<li>这种类型的法术加速了一个药水的准备时间。有这种类型的m个咒语，其中的第i个成本bi manapoints和改变每个药水的准备时间为ai而不是x。</li>
<li>这种类型的法术会立即准备一些魔药。有这样的法术，第i个成本di manapoints和立即创建ci药剂。</li>
</ul>
<p>安东可以使用不超过一个第一类型的法术，不超过一个第二类型的法术，并且使用的manapoint的总数不应超过s。考虑到所有的法术都在瞬间使用，在安东开始准备魔药之前。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>输入的第一行包含三个整数n，m，k（1≤n≤2·109，1≤m，k≤2·105） -  Anton必须生成的药剂数量，第一类型和第二类型的法术的数量。</p>
<p>输入的第二行包含两个整数x和s（2≤x≤2·109,1≤s≤2·109） - 准备一个部分所需的初始秒数和Anton可以使用的manapoint数。</p>
<p>第三行包含m个整数ai（1≤ai&lt;x） - 如果使用第一类型的第i个法术，则准备一个药剂所需的秒数。</p>
<p>第四行包含m个整数bi（1≤bi≤2·109） - 使用第一类型第i个咒语的manapoints数量。</p>
<p>在第五行中有k个整数ci（1≤ci≤n） - 如果使用第二类型的第i个咒语，将立即创建的药剂数。保证ci不减小，即如果i &lt;j，则ci≤cj。</p>
<p>第六行包含k个整数di（1≤di≤2·109） - 使用第二个类型的第i个咒语所需的manapoint数量。保证di不减小，即如果i &lt;j，则di≤dj。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>打印一个整数 - 为了准备n个药水，花费的最少时间。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>因为后面给的第二种类型的法术是递增的（包括获得的药水数量和消耗的体力），这样我们就可以使用二分查找（upper_bound函数）找到，进行第一种类型的法术选择以后的第二种的最优策略，这样时间复杂度就是O(m*logk)了</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 200005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> in(a) scanf(<span class="meta-string">"%d"</span>,&amp;a)</span></div><div class="line"></div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m,k,x,s;</div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAXSIZE],b[MAXSIZE],c[MAXSIZE],d[MAXSIZE];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> i;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;s;  <span class="comment">//数据输入</span></div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;b[i];</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;c[i];</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;d[i];</div><div class="line"></div><div class="line">        a[m]=x;</div><div class="line">        b[m]=<span class="number">0</span>;</div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> imin,o,e;</div><div class="line">        imin=n*x;</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=m;i++)</div><div class="line">        &#123;</div><div class="line">            o=s-b[i];</div><div class="line">            <span class="keyword">if</span>(o&lt;<span class="number">0</span>)</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            e=upper_bound(d,d+k,o)-d;</div><div class="line">            <span class="keyword">if</span>(e)</div><div class="line">                imin=min(a[i]*(n-c[e<span class="number">-1</span>]),imin);    </div><div class="line">            <span class="keyword">else</span>     <span class="comment">//注意不进行第二次选择的情况</span></div><div class="line">                imin=min(a[i]*n,imin);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;imin&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><ul>
<li>在cf的比赛中，比赛时提交的程序只进行一部分测试点的测试，比赛结束以后重新验证测试点会多好多</li>
<li>初始rating积分是1500，我竟然少了几十分。。。。听说这个积分的计算用到的是一个叫<em>Elo rating system</em>的东西，看起来好高大上的样子。（<a href="https://en.wikipedia.org/wiki/Elo_rating_system" target="_blank" rel="external">维基的解释</a>）</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 点滴 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 3253 Fence Repair 题解]]></title>
      <url>/2016/11/09/POJ-3253-Fence-Repair-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>Fence Repair</p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Farmer John wants to repair a small length of the fence around the pasture. He measures the fence and finds that he needs N (1 ≤ N ≤ 20,000) planks of wood, each having some integer length Li (1 ≤ Li ≤ 50,000) units. He then purchases a single long board just long enough to saw into the N planks (i.e., whose length is the sum of the lengths Li). FJ is ignoring the “kerf”, the extra length lost to sawdust when a sawcut is made; you should ignore it, too.FJ sadly realizes that he doesn’t own a saw with which to cut the wood, so he mosies over to Farmer Don’s Farm with this long board and politely asks if he may borrow a saw.Farmer Don, a closet capitalist, doesn’t lend FJ a saw but instead offers to charge Farmer John for each of the N-1 cuts in the plank. The charge to cut a piece of wood is exactly equal to its length. Cutting a plank of length 21 costs 21 cents.Farmer Don then lets Farmer John decide the order and locations to cut the plank. Help Farmer John determine the minimum amount of money he can spend to create the N planks. FJ knows that he can cut the board in various different orders which will result in different charges since the resulting intermediate planks are of different lengths.<br><a id="more"></a></p>
<hr>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>Line 1: One integer N, the number of planks<br>Lines 2..N+1: Each line contains a single integer describing the length of a needed plank</p>
<hr>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>Line 1: One integer: the minimum amount of money he must spend to make N-1 cuts</p>
<hr>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><p>3<br>8<br>5<br>8</p>
<hr>
<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><p>34</p>
<hr>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>将一块很长的木板切成N快，给出处理以后的的木板长度，求切割的成本。其中切割成本计算方法：将一块木板切割成两份的成本为切割前的木板长度。</p>
<hr>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol>
<li>逆向推导，使用贪心算法，每次都只取长度最小的两块木板，计算这次切割的成本以后，将其当做新的未被切割的木板进行下一步操作</li>
<li>就是哈夫曼编码中构造哈夫曼树的过程</li>
</ol>
<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;   <span class="comment">//用int提交时数据会溢出</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    ans=<span class="number">0</span>;</div><div class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; p;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">    <span class="keyword">int</span> i,x;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cin</span>&gt;&gt;x;</div><div class="line">        p.push(x);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(p.size()!=<span class="number">1</span>)   <span class="comment">//每次取两个木板合并</span></div><div class="line">    &#123;</div><div class="line">        x=<span class="number">0</span>;</div><div class="line">        x+=p.top();</div><div class="line">        p.pop();</div><div class="line">        x+=p.top();</div><div class="line">        p.pop();</div><div class="line">        p.push(x);</div><div class="line">        ans+=x;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</div><div class="line">    <span class="comment">//freopen("input.txt","r",stdin);</span></div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 哈夫曼编码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[poj 2386 Laking Counting]]></title>
      <url>/2016/11/08/poj-2386-Laking-Counting/</url>
      <content type="html"><![CDATA[<p>Lake Counting</p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’).  Farmer John would like to figure out how many ponds have formed in his field.  A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors.</p>
<p>Given a diagram of Farmer John’s field, determine how many ponds he has.<br><a id="more"></a></p>
<hr>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><ul>
<li><p>Line 1: Two space-separated integers: N and M</p>
</li>
<li><p>Lines 2..N+1: M characters per line representing one row of Farmer John’s field.  Each character is either ‘W’ or ‘.’.  The characters do not have spaces between them.</p>
</li>
</ul>
<hr>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><ul>
<li>Line 1: The number of ponds in Farmer John’s field.</li>
</ul>
<hr>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><p>10 12<br>W……..WW.<br>.WWW…..WWW<br>….WW…WW.<br>………WW.<br>………W..<br>..W……W..<br>.W.W…..WW.<br>W.W.W…..W.<br>.W.W……W.<br>..W…….W.</p>
<hr>
<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><p>3</p>
<hr>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给出N*M的矩形土地以及土地中的积水位置（用W表示），要求整块矩形土地中的连续积水的区域数量</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><blockquote>
<p>1.采用深度优先搜索，对于一块连续的积水区域用一次深度优先搜索就可以将所有的W区域置为.<br>2.记录总共要进行几次这样的深度优先搜索，就是矩形区域内的连续积水区域的数量</p>
</blockquote>
<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mm(a) memset(a,1,sizeof(a))</span></div><div class="line"><span class="keyword">char</span> b[<span class="number">101</span>][<span class="number">101</span>];</div><div class="line"><span class="keyword">int</span> n,m;</div><div class="line"><span class="keyword">int</span> ans;  <span class="comment">//进行深度优先搜索的次数</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> d)</span>  <span class="comment">//深度优先搜索算法实现</span></span></div><div class="line">&#123;</div><div class="line">    b[a][d]=<span class="string">'.'</span>;</div><div class="line">    <span class="keyword">int</span> x,y,dx,dy;</div><div class="line">    <span class="keyword">for</span>(dx=<span class="number">-1</span>;dx&lt;<span class="number">2</span>;dx++)</div><div class="line">        <span class="keyword">for</span>(dy=<span class="number">-1</span>;dy&lt;<span class="number">2</span>;dy++)</div><div class="line">        &#123;</div><div class="line">            x=a+dx;</div><div class="line">            y=d+dy;</div><div class="line">            <span class="keyword">if</span>(x&gt;<span class="number">0</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;<span class="number">0</span>&amp;&amp;y&lt;=m&amp;&amp;b[x][y]==<span class="string">'W'</span>)</div><div class="line">                dfs(x,y);</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    ans=<span class="number">0</span>;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;b[i][j];</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(b[i][j]==<span class="string">'W'</span>)</div><div class="line">            &#123;</div><div class="line">                dfs(i,j);</div><div class="line">                ans++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[心安就是归处]]></title>
      <url>/2016/11/03/%E5%BF%83%E5%AE%89%E5%B0%B1%E6%98%AF%E5%BD%92%E5%A4%84/</url>
      <content type="html"><![CDATA[<p>既然选择了编程，只管风雨兼程<br>一次会议记录是不会有人感兴趣的，做标题党也是不道德的。所以，走了个折衷的路线，标题不叫会议记录， 内容不纯总结，技术加吐槽，经验加总结。</p>
<p>对于一个程序员的成长，学习似乎是永恒的事情。为什么网友爱用“苦逼”来形容程序员，因为他们整天伏案写代码，学不完的新技术。其实仔细想想，又何止是程序员要不断的保持学习，做什么都是一样的。党员为了保持先进性，要不停的学资料，开会议，然后再学资料，再开会；干理发的要紧跟潮流趋势，赶上时代步伐，不然现在男生统一的平头，女生统一的扎俩辫子；而现在，连扫地的大妈都危险了，一群为了有编制的高学历人才要去争这个饭碗，所以，作为程序员这样高端职业的我们来说，保持学习真的还是很有必需的。<br><a id="more"></a></p>
<h2 id="心安即是归处"><a href="#心安即是归处" class="headerlink" title="心安即是归处"></a>心安即是归处</h2><p>学习是解惑的，所以学习过程中要遇到困惑。因为有困惑，所以才需要不断的学习来解决。那到底是为了解决困惑学习还是为了学习解决困惑，这个，不重要。</p>
<p>一路走来，觉得最大的困惑莫过于无法静下心来学习。任何能耐得住寂寞坐得了板凳的人都成功了，比如周杰伦他以前耐得住寂寞把自己关小黑屋才写出了这么多传世之作，现在浮躁了静不下来好好写歌跑去拍些个烂电影受到了来自众多影评人的广泛差评。</p>
<p>心安即是归处，流浪的人啊，你究竟在追寻什么。一切问题除了是时间问题，更是一个人心态的问题。静不下心来往往是妨碍自己学习前进的主要原因。这个世界如此浮躁如何做到众人皆醉我独醒，确实有点难。事实往往是这样：道理大家都懂，但真正做到的没几个。就比如大家作为长辈教育小同学要好好学习道理说得头头是道，完了发现没有一条应用到了自己身上。</p>
<p>所以有明白人指出，那些凡是书名带了教你如何如何提升，一个人的自我修维，成功之道，杰出的品格应该是这样的，通往成功捷径……的书，完全是坑爹而没有必需看的。如果我们不带自己的思维盲目的接受，你还真以为《十万个为什么》真的有十万条问答记录在目，《钢铁是怎样炼成的》真的是一本工业书籍教你怎样炼钢！那些出书的人根本就没想要你成功，他们只是想要你想成功，然后再去拜读这些烂作。最明显的例子就是《我的成功可以复制》，撕掉作者的伪善有人在他演讲后向他提问：哥，你西太平洋大学的毕业证书也可以复制！</p>
<p>一颗能够沉淀下来的心是绝对不会找借口说没时间而推掉自己对于学习的计划的。对于上班的我们，很多时候都会冠冕堂皇的用上这个借口。并且由于工作没时间还被用在很多其他地方，比如不陪家人。电影《教父》中的老大哥都觉得：一个不花时间陪家人的男人算不得一个好男人。繁花似锦，岁月青葱，人生不过25亿秒，过一秒，少一秒，时间正滴答滴答地蚕食我们，我们唯一需要做的，就是让这些秒钟过得有意思：高效工作，不断的学习充实，陪陪家人联络亲友，爱惜身体养养花草。</p>
<p>年轻难免气盛，好高骛远是这我们这群热血一带少年的通病，久困牢笼稚气未脱的新人们总是从刚踏出校门那一刻起就觉得自己天之骄子我最大。但其实谁又不是在刚踏入大学门槛时都信誓旦旦要披星戴月学到天荒地老。结果都是玩得死去活来爱到花开鸟儿飞。</p>
<p>现实总比理想更生猛一些，他用上有老将来会下有小的压力要求一个人快速成长，而不像理想让一个人自我陶醉然后成天独守空房。当发现自己真的缺少很多实践的时候，如果还感到气盛的话，那真的该抓住青春的尾巴把这些力气用到自我完善当中。如果还活在自我的世界以为振作起来就是从明天开始劈柴煮饭面朝大海笑一笑，那真的是文艺到了极点，现实生活与你无关。</p>
<p>停下脚步，安下心来。起点就是归处。</p>
<h2 id="既然选择了编程，只管风雨兼程"><a href="#既然选择了编程，只管风雨兼程" class="headerlink" title="既然选择了编程，只管风雨兼程"></a>既然选择了编程，只管风雨兼程</h2><p>学习需要有目标，往远了说就是职业规划。</p>
<p>我一开始也不知道自己要干什么，什么我能干。好干的已经有很多人在干了，不好干的只有那么几个人一直干干到白发苍苍最后拿个诺奖终了一生。</p>
<p>任何时候只要你找不到方向感觉生活无望像是末日来临，请想想伟大的党伟大的毛主席。</p>
<p>毛主席说这个世界是我们的，也是你们的，但终究是你们的。</p>
<p>但我觉得这事儿还能说细一点，信息时代是我们的，也是人类的，但终究是IT人的。于是乎，作为码农，还是很有前景的。光是每天翻看英文技术文档修修电脑就看着很有技术很有品，更不用说没事的时候写写小软件自娱自乐。靠敲键盘度日的，还有作家，但如你所知，在当前国情下，呵呵。但写代码不用通过广电总局中宣部文化部审批。唯一影响你生活的无非就是开着车的时候骂骂发改委[此处文字已替换]喊你回家下调油价。</p>
<p>同学有问：做什么啊在？</p>
<p>搞开发啊当码农啊。</p>
<p>一听都觉得牛逼高端加技术，形象顿时伟岸起来。自己也会觉得有范儿够面子。<br>当然，苦逼就源于技术二字。一个技术宅不是一天练就的。正如技术宅这个词，首先他必需是经常宅的，而且不是宅着吃薯条看AV，而是钻研技术，最后还是跟上面说的一样要耐得住寂寞坐得住板凳，最后方可修炼成为技术宅。</p>
<p>关键是新技术层出不穷，就像赶朝流一样，你永远都只是路边的一个路人，而朝流就像飞驰而过的地铁，呼啦一下你就被甩开了。以至于今天搞安卓的人很吃香，同行间一交流，咦，你是.NET程序员啊，然后心里鄙夷地呵呵一下，第二天WIN8火了，咦，你是搞手机开发的啊，呵呵。</p>
<p>其次，作为一名码农，总是有解决不完的bug和改了又改的需求，似乎整天都在忙于应付这些令人费脑细胞的问题，有的时候完全没有任何方案，真的想关屏幕砸键盘最后来一句：phuck! 但出于一个高端人才的内在修养与自我约束，这样的事情还是很少发生的。大不了转行卖电脑。但一般我们认为不堪技术压力而选择放弃的程序员不是一个好的码农。谁也丢不起那个脸。想想就知道有多恐怖了。</p>
<p>同学又问：干啥啊最近？</p>
<p>微软平板只要三千九，是的，你绝对没有听错没有听错！</p>
<p>同学：……</p>
<p>可见一个技术人员成长过程确实是比较苦逼的。一个技术人员的生涯也是需要坚强意志的。<br>但作为一个IT人来说，既然选择了编程，就只管风雨兼程，任何bug都是纸老虎经不起你打断点调试几下就Over了。再强大一点的问题拉几个同事组队也是三下五除二就可以解决了。并且这些解决问题的过程是对自己技术的验证，解决成功之后也是一种非常有成就感的体验，那感觉比开挂打死一只精英BOSS还要爽。</p>
<h2 id="一路走下去，何方是彼岸。"><a href="#一路走下去，何方是彼岸。" class="headerlink" title="一路走下去，何方是彼岸。"></a>一路走下去，何方是彼岸。</h2><p>或者继续技术下去，当个专家，大家都相信IT行业的专家绝对要比其他行业的砖家靠谱，因为你看，乔布斯，一个杰出的无领黑色棉彬穿着家，一个IT行业时代的创造者，他每次在产品发布会上讲解着新产品新功能的时候，都能吸引全球的眼光，并且你买回产品来看，还真的是那样绝不是盖的。但你打开电视一看，张教授说美国不会对伊开战的，结果第二天战争就打起来了，他又说利比亚局势会好转的，结果卡扎菲被活捉了；司马北一边把自己的妻儿送到太平洋的对岸，一边又树立着一个坚定的反美斗士的形象。</p>
<p>并且当一个IT业的资深专家并不会有秃顶的烦恼，一般透顶的都是科研搞学术的专家教授，IT人需要双手敲键盘，而学术人一只手握笔还空了只手会在想问题时抓头皮。</p>
<p>还可以转型当管理，带领一个开发团队管理几个项目。每天喝着茶唱着小曲检查一下代码，生活就是如此多娇，风景IT这边独好。这时你会觉得，以前所有苦逼的日子是值得的。</p>
<h2 id="你错过了夏花绚烂，必将走进秋叶静羌"><a href="#你错过了夏花绚烂，必将走进秋叶静羌" class="headerlink" title="你错过了夏花绚烂，必将走进秋叶静羌"></a>你错过了夏花绚烂，必将走进秋叶静羌</h2><p>人越长大，就越觉得孤单。这话真的不假。一直都是听到任然的《那年》比较有感，真的有种怀念不如活好当下的感触。</p>
<p>人生会错失太多没把握好的东西，试想当年孔子站在河边上指着湍急的河水发出的感叹：看，时间就像这家伙！后面肯定还说了我年轻时怎么没做什么什么等的话只是没有被记录下来，但可以肯定的是他当时是何时的沧桑与无奈。人到中年，做事情将会是心有余而力不足。家庭，工作，各种羁绊，各种黯然神伤。</p>
<p>这就提醒我们，有想法就要付诸行动。张爱怜也说：出名要趁早。</p>
<p>而这点，对于一个程序员来说，尤为重要。选择你热爱的方向，整理下装备满状态出发，死心踏地走下去。</p>
<p>当计划好要学习某种技术后，应该矢志不渝，不应被其他花样繁多的技术所分心，一会儿学这个，一会儿学那个，如此不忠节操何在先不谈，往往是开始信心满满干劲十足，什么都想学结果什么都学不好精力已尽。于是进行一个迷茫的阶段，无法找到自己的定位。这时候，我觉得需要重新确定一下目标再上路，或者能从同行前辈的经验之谈中补充到一些正能量。</p>
<p>一个程序员的定位，也是最开始所选择的方向。越到后面，转型的代价越大。在这一点上，是应该思考成熟再行动的，而不是现在什么火，学什么。</p>
<p>作为程序员，往往还带有拖延症。在学习上，就表现在一个技术学习时间跨度太大，以至于从这个技术的兴起到它已经淡出舞台，你都还没真正掌握而用于项目实践。不得不说这样低效的学习多么的低效，这样懒散的人生是多么的懒散。而且，对于一个知识点，学久了会忘，拖太久会让人无法把所有知识点系统地连贯起来，这感觉，你能想象一个便秘的人是用何种眼光望着天花板然后听着旁边一位后进来的人脱裤解决冲水走人毫不拖泥带水半分钟完事么，我有个高中同学就是。</p>
<p>在工作上，无法就是大家都熟知的代码不够完善便进行下一功能的开发，自测也不够全面就甩旁边然后大舒一口气。总是在内心对自己说呆会再来写注释，等有时间了再来完善。但工作经验告诉我们由于这样的一时疏忽而导致的返工是屡见不鲜的，我们仍然像重启的电脑把日事日毕忘得一干二净。</p>
<p>及时当勉励。或许，我也曾常常幻想过牛逼的那一天，身后是放射状的光芒。但一直安慰自己：现在还在牛逼的路上。</p>
<p>但其实就是拖延症，大多数人败给了拖延症而安于现状，得过且过。</p>
<p>而现在秋天已过冬意渐浓，如果我们已经错过了夏花绚烂，那只待来年花开了，如果还够年轻的话，如果现在还积极准备的话</p>
<h2 id="有感"><a href="#有感" class="headerlink" title="有感"></a>有感</h2><p>在这个比较浮躁的社会，在这个比较浮躁的行业，有的时候我们是要静下心来思考，来学一些东西。在各种环境下我们更应该秉承一种工匠精神，把手中的每一件事情做好，耐得住寂寞，坐的了冷板凳。</p>
<p><img src="http://oeziv5rwi.bkt.clouddn.com/2016/11/03/001.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 杂记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[锐雯上单不给就送——题解]]></title>
      <url>/2016/11/03/%E9%94%90%E9%9B%AF%E4%B8%8A%E5%8D%95%E4%B8%8D%E7%BB%99%E5%B0%B1%E9%80%81-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>15安徽省赛D题</p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>《英雄联盟》（简称LOL）是由美国Riot Games开发，腾讯游戏运营的英雄对战网游。《英雄联盟》除了即时战略、团队作战外，还拥有特色的英雄、自动匹配的战网平台，包括天赋树、召唤师系统、符文等元素。简单来说，LOL是一个10人组的对战游戏，一个队伍(5个人)对抗另一个队伍(5个人)，主要目的是拆掉对面的建筑物，一个每个队伍的英雄都扮演着不同的角色，分别为“上单”，“打野”，“中单”，“辅助”，“ADC”，通常的情况是各自队伍的“上单”VS“上单”，“打野”VS“打野”，“中单”VS“中单”，“辅助”VS“辅助”，“ADC”VS“ADC”。上单在LOL中一直是一个很吃香的角色，一般小学生进入匹配以后都会强调一句“锐雯上单不给就送”作为联络暗号。zz_1215和devtang经常玩这个游戏，zz_1215是devtang的宿敌，devtang很想知道zz_1215玩的什么角色，然后他就选同样的角色和zz_1215决斗(solo)。经过观察devtang发现zz_1215选择什么角色是有规律的，那就是取决于他上一次玩的什么角色。现用一个5*5的矩阵来表示，表示上一次如果zz_1215玩的是第j个角色，那么他这一次玩第i个角色的概率为，另外有。现在知道zz_1215第一次玩的是什么角色，devtang想知道在第n次游戏中，zz_1215最有可能玩的是什么角色。<br><a id="more"></a></p>
<hr>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>首先是一个正整数T，表示有T组数据<br>每组数据包括<br>第一行是一个数字n，表示devtang想知道第n次游戏中zz_1215最可能玩的角色<br>接下来会给出5*5的矩阵表示概率关系<br>最后一行给出整数m()表示zz_1215第一次游戏玩的角色，角色表示方法见注意事项</p>
<hr>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出第n次游戏中，zz_1215最有可能玩的角色，角色表示方法见注意事项，每个输出单独占一行</p>
<hr>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><p>2<br>1<br>0 0.1 0.2 0.3 0.4<br>0.4 0 0.1 0.2 0.3<br>0.3 0.4 0 0.1 0.2<br>0.2 0.3 0.4 0 0.1<br>0.1 0.2 0.3 0.4 0<br>3<br>2<br>0 0.1 0.2 0.3 0.4<br>0.4 0 0.1 0.2 0.3<br>0.3 0.4 0 0.1 0.2<br>0.2 0.3 0.4 0 0.1<br>0.1 0.2 0.3 0.4 0<br>3</p>
<hr>
<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><p>3<br>4</p>
<hr>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>通过对矩阵的“运算”，相当于给出起点和路径概率得所到达的终点的概率，此题中得出从一个角色开始玩到最后玩的角色的概率</li>
<li>使用快速幂运算进行n次幂“运算”，快速幂运算就是将n次方运算转化为多个2的k次方运算之积</li>
<li>有一点坑的就是最后的要求是概率相同取编号小的角色，因为概率运算是实数运算，结果是不准确的，最后要同过<em>abs(ans.g[s-1][j]-maxi)&lt;1e-6</em>来消除整数运算所带来的不准确性</li>
</ul>
<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iterator&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> statu</div><div class="line">&#123;</div><div class="line">    <span class="keyword">double</span> g[<span class="number">5</span>][<span class="number">5</span>];</div><div class="line">&#125;sta;</div><div class="line"></div><div class="line"><span class="function">sta <span class="title">mul</span><span class="params">(sta a,sta b)</span></span></div><div class="line">&#123;</div><div class="line">    sta c;</div><div class="line">    <span class="keyword">int</span> i,j,k;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)</div><div class="line">        &#123;</div><div class="line">            c.g[i][j]=<span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">5</span>;k++)</div><div class="line">                c.g[i][j]+=a.g[i][k]*b.g[k][j];    <span class="comment">//i到j有多条线路</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> c;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">sta <span class="title">pow</span><span class="params">(sta a,<span class="keyword">int</span> d)</span>   <span class="comment">//利用二进制数的特点</span></span></div><div class="line">&#123;</div><div class="line">    sta b,c;</div><div class="line">    b=a;</div><div class="line">    <span class="built_in">memset</span>(c.g,<span class="number">0</span>,<span class="keyword">sizeof</span>(c.g));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</div><div class="line">        c.g[i][i]=<span class="number">1</span>;     <span class="comment">//累加位初始化</span></div><div class="line">    <span class="keyword">while</span>(d)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(d&amp;<span class="number">1</span>)c=mul(c,b);   <span class="comment">//累加位</span></div><div class="line">        b=mul(b,b);    <span class="comment">//二进制增长位</span></div><div class="line">        d/=<span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> c;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,s,maxj;</div><div class="line">    <span class="keyword">double</span> maxi=<span class="number">0</span>;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    sta a,ans;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</div><div class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;a.g[j][i];     <span class="comment">//j在前使其与前面的运算对应</span></div><div class="line">    <span class="built_in">cin</span>&gt;&gt;s;</div><div class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    ans=<span class="built_in">pow</span>(a,n<span class="number">-1</span>);</div><div class="line">    <span class="comment">//for(i=0;i&lt;5;i++)    //已经确定起点</span></div><div class="line">        <span class="keyword">for</span>(j=<span class="number">4</span>;j&gt;=<span class="number">0</span>;j--)    <span class="comment">//不能使用for(j=0;j&lt;5;j++),原因：概率相同要选最小的，多次乘法运算时不精确的，通过1e-6来获得近似精确的解</span></div><div class="line">            <span class="keyword">if</span>(ans.g[s<span class="number">-1</span>][j]&gt;maxi||<span class="built_in">abs</span>(ans.g[s<span class="number">-1</span>][j]-maxi)&lt;<span class="number">1e-6</span>)</div><div class="line">            &#123;</div><div class="line">                maxi=ans.g[s<span class="number">-1</span>][j];</div><div class="line">                maxj=j;</div><div class="line">            &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;maxj+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</div><div class="line">    <span class="keyword">int</span> t;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;t;</div><div class="line">    <span class="keyword">while</span>(t--)</div><div class="line">    &#123;</div><div class="line">        solve();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 快速幂运算 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WOX 快捷启动器]]></title>
      <url>/2016/10/31/WOX-%E5%BF%AB%E6%8D%B7%E5%90%AF%E5%8A%A8%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>介绍：WOX是国人开发的一款比较好用的开源快捷启动器，在一定程度上能够让我们暂时对鼠标说拜拜。这几天使用的体验还不错，所以就写一篇博文来推荐一下。希望大家能够喜欢。</p>
<a id="more"></a>
<h4 id="系统插件"><a href="#系统插件" class="headerlink" title="系统插件"></a>系统插件</h4><h5 id="程序插件"><a href="#程序插件" class="headerlink" title="程序插件"></a>程序插件</h5><p>程序搜索列表主要在开始菜单和用户自定义目录中的程序（定义：     Setting=&gt;Plugin=&gt;Programs ）。还支持汉字的拼音输入</p>
<h5 id="颜色插件"><a href="#颜色插件" class="headerlink" title="颜色插件"></a>颜色插件</h5><p>输入颜色代码会显示出具体的颜色值</p>
<h5 id="控制面板插件"><a href="#控制面板插件" class="headerlink" title="控制面板插件"></a>控制面板插件</h5><p>可以直接在搜索框中输入控制面板中的选项</p>
<h5 id="计算机插件"><a href="#计算机插件" class="headerlink" title="计算机插件"></a>计算机插件</h5><p>这个不用说就知道怎么用了吧</p>
<h5 id="网址插件"><a href="#网址插件" class="headerlink" title="网址插件"></a>网址插件</h5><p>直接拷贝的网址在这里面就可以打开了（使用默认浏览器）</p>
<h5 id="Web搜索框"><a href="#Web搜索框" class="headerlink" title="Web搜索框"></a>Web搜索框</h5><p>Wox还提供了名为Web搜索的系统插件。所谓Web搜索，就是Wox允许用户设置一个URL，然后替换其中搜索关键字部分，从而达到快速搜索的目的。最常见的莫过于谷歌，百度搜索了。Wox内置了谷歌的Web搜索。关键字是 g 。另外在添加自定的Web搜索的时候记得把需要替换的地方换成 {q} 占位符，此占位符会在正常搜索的时候替换为你的输入。<br><img src="http://oeziv5rwi.bkt.clouddn.com/2016/10/31/001.jpg" alt=""><br>非常不错的一个功能</p>
<h5 id="命令行插件"><a href="#命令行插件" class="headerlink" title="命令行插件"></a>命令行插件</h5><p>通过 <strong>Win + R</strong>启动命令行，或者输入<strong>&gt; + 命令</strong></p>
<h5 id="第三方提示插件"><a href="#第三方提示插件" class="headerlink" title="第三方提示插件"></a>第三方提示插件</h5><p>提示触发第三方插件的关键字</p>
<h4 id="第三方插件"><a href="#第三方插件" class="headerlink" title="第三方插件"></a>第三方插件</h4><p>需要关键字出发</p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>使用<strong>wpm</strong> 命令进行安装</p>
<ol>
<li>安装插件：  <em>wpm install &lt;插件名字&gt;</em></li>
<li>删除插件：<em>wpm uninstall &lt;插件名字&gt;</em></li>
<li>插件列表： <em>wpm list</em></li>
</ol>
<p>手动安装，下载.wox结尾的安装包    ，将插件拖拽到搜索框中即可安装</p>
<p>所有第三方插件列表在<a href="http://www.getwox.com/plugin" target="_blank" rel="external">这里</a></p>
<p>希望这款小应用能够给你的在工作或学习的效率得到提升</p>
]]></content>
      
        <categories>
            
            <category> 软件使用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 效率提升 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python Requests库 基本用法]]></title>
      <url>/2016/10/29/python-Requests%E5%BA%93-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>Requests 是一个比较常用的python HTTP 库，是爬虫必备的第三方扩展库。下面是Requests库的一些基本的用法</p>
<a id="more"></a>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><p>导入requests库，通过get（或者其他请求类型）得到一个requests对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line">r=requests.get(<span class="string">"https://www.baidu.com/"</span>)</div><div class="line">r=requests.post(<span class="string">"https://www.baidu.com/"</span>)</div></pre></td></tr></table></figure></p>
<h4 id="传递URL参数"><a href="#传递URL参数" class="headerlink" title="传递URL参数"></a>传递URL参数</h4><p>手工构建的URL（如abc.com/get?key=value）转化为params参数，以一个字典的形式来提供这些参数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import requests</div><div class="line"></div><div class="line">payload=&#123;'kay1':'value1','key2':'value2'&#125;</div><div class="line">r=requests.get("https://www.baidu.com",params=payload)</div><div class="line">print(r.url)</div><div class="line"></div><div class="line">&gt;&gt;https://www.baidu.com/?kay1=value1&amp;key2=value2</div><div class="line">``` </div><div class="line"></div><div class="line">## 响应内容</div><div class="line"></div><div class="line">我们可以通过text属性来获得响应内容</div><div class="line">``` python</div><div class="line"></div><div class="line">import requests</div><div class="line"></div><div class="line">r=requests.get("https://github.com/timeline.json")</div><div class="line">print(r.text)</div><div class="line"></div><div class="line">&gt;&gt;&#123;"message":"Hello there, wayfaring stranger. If you’re reading this then you probably didn’t see ...</div></pre></td></tr></table></figure>
<p>Requests 会自动解码获取的内容（通过HTTP的头部对编码进行推测），当然你也可以用encoding属性来改变它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> r.encoding</div><div class="line"><span class="string">'utf-8'</span></div><div class="line"> r.encoding = <span class="string">'ISO-8859-1'</span></div></pre></td></tr></table></figure>
<h4 id="二进制响应内容"><a href="#二进制响应内容" class="headerlink" title="二进制响应内容"></a>二进制响应内容</h4><p>对于非文本请求（如二进制内容请求）,Requests 会自动为你解码gzip和deflate传输编码的响应数据，对受到请求以后进行处理就行了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</div><div class="line"></div><div class="line">i = Image.open(BytesIO(r.content))</div></pre></td></tr></table></figure></p>
<h4 id="JSON-响应内容"><a href="#JSON-响应内容" class="headerlink" title="JSON 响应内容"></a>JSON 响应内容</h4><p>Requests内置json解码器，对返回对象调用json()方法即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div><div class="line">r=requests.get(<span class="string">'https://github.com/timeline.json'</span>)</div><div class="line">r.json()</div></pre></td></tr></table></figure>
<h4 id="原始响应内容"><a href="#原始响应内容" class="headerlink" title="原始响应内容"></a>原始响应内容</h4><p>获取服务器的原始套接字响应，可以访问r.raw（这样就要在请求中设置参数stream=True）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'https://github.com/timeline.json'</span>, stream=<span class="keyword">True</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.raw</div><div class="line">&lt;requests.packages.urllib3.response.HTTPResponse object at <span class="number">0x101194810</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.raw.read(<span class="number">10</span>)</div><div class="line"><span class="string">'\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\x03'</span></div></pre></td></tr></table></figure></p>
<p>获取原始内容以后，你可以使用这种方法将文本流保存到文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(filename, <span class="string">'wb'</span>) <span class="keyword">as</span> fd:</div><div class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(chunk_size):</div><div class="line">        fd.write(chunk)</div></pre></td></tr></table></figure></p>
<p>使用 Response.iter_content 将会处理大量你直接使用 Response.raw 不得不处理的。 当流下载时，上面是优先推荐的获取内容方式。</p>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>添加HTTP头部信息，只要传递一个dict给headers参数就可以了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'https://api.github.com/some/endpoint'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>headers = &#123;<span class="string">'user-agent'</span>: <span class="string">'my-app/0.0.1'</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(url, headers=headers)</div></pre></td></tr></table></figure></p>
<p>注意：<br>Requests 不会基于定制 header 的具体情况改变自己的行为。只不过在最后的请求中，所有的 header 信息都会被传递进去。</p>
<h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><p>可以通过传递一个dict给data参数来发送像表单内容一样的数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(<span class="string">"http://httpbin.org/post"</span>, data=payload)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(r.text)</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  <span class="string">"form"</span>: &#123;</div><div class="line">    <span class="string">"key2"</span>: <span class="string">"value2"</span>,</div><div class="line">    <span class="string">"key1"</span>: <span class="string">"value1"</span></div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="状态响应码"><a href="#状态响应码" class="headerlink" title="状态响应码"></a>状态响应码</h3><p>通过status_code来获得状态信息<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'http://httpbin.org/get'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</div><div class="line"><span class="number">200</span></div></pre></td></tr></table></figure></p>
<h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>通过headers属性来获得服务器的响应头：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers</div><div class="line">&#123;</div><div class="line">    <span class="string">'content-encoding'</span>: <span class="string">'gzip'</span>,</div><div class="line">    <span class="string">'transfer-encoding'</span>: <span class="string">'chunked'</span>,</div><div class="line">    <span class="string">'connection'</span>: <span class="string">'close'</span>,</div><div class="line">    <span class="string">'server'</span>: <span class="string">'nginx/1.0.4'</span>,</div><div class="line">    <span class="string">'x-runtime'</span>: <span class="string">'148ms'</span>,</div><div class="line">    <span class="string">'etag'</span>: <span class="string">'"e1ca502697e5c9317743dc078f67693f"'</span>,</div><div class="line">    <span class="string">'content-type'</span>: <span class="string">'application/json'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>HTTP 头部对大小写不敏感</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>获得cookie，使用cookies属性；发送你的cookie到服务器，使用cookie参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://example.com/some/cookie/setting/url'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(url)</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.cookies[<span class="string">'example_cookie_name'</span>]</div><div class="line"><span class="string">'example_cookie_value'</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/cookies'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>cookies = dict(cookies_are=<span class="string">'working'</span>)</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(url, cookies=cookies)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</div><div class="line"><span class="string">'&#123;"cookies": &#123;"cookies_are": "working"&#125;&#125;'</span></div></pre></td></tr></table></figure></p>
<h3 id="重定向和请求历史"><a href="#重定向和请求历史" class="headerlink" title="重定向和请求历史"></a>重定向和请求历史</h3><p>使用对象的history属性返回Response对象列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'http://github.com'</span>)</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.url</div><div class="line"><span class="string">'https://github.com/'</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</div><div class="line"><span class="number">200</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.history</div><div class="line">[&lt;Response [<span class="number">301</span>]&gt;]</div></pre></td></tr></table></figure></p>
<p>使用allow_redirects参数来禁用重定向处理：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'http://github.com'</span>, allow_redirects=<span class="keyword">False</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</div><div class="line"><span class="number">301</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.history</div><div class="line">[]</div></pre></td></tr></table></figure></p>
<p><a href="http://cn.python-requests.org/zh_CN/latest/index.html" target="_blank" rel="external">中文官方文档</a></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[开启ACM之路]]></title>
      <url>/2016/10/22/%E5%BC%80%E5%90%AFACM%E4%B9%8B%E8%B7%AF/</url>
      <content type="html"><![CDATA[<p>今天参加了学校的程序设计竞赛，一直以来都是对这次比赛抱有很大的期望。从暑假开始到现在也一直在看相关算法的资料书籍，转专业过来以后花在这方面的时间和精力也非常多，学习从简单的动态规划问题到图论中的各种算法，在学校的OJ上面也刷了一些题。<br>但是这次比赛自己的结果并不理想，为什么我会在第三题因为break这个错误（本来应该是return的）卡了这么久，提交了十次才发现这个错误，最后变成了做出四道题目中的倒数第二。。。<br><a id="more"></a><br><img src="http://oeziv5rwi.bkt.clouddn.com/2016/10/22/001.jpg" alt=""></p>
<p>幸好还做出了四道题目，因此也算是进入了ACM实验室吧。从今天起我也算真正踏上了ACM之路，之前的努力和辛苦还是会有回报的。 还是应了那句话：</p>
<blockquote>
<p>机会总是留给有准备的人的！<br>未来的路走得肯定不会那么轻松，也会给我带来很多挑战、很多考验。但是我相信这条路是我自己选的，我一定会坚持下去的！<br>希望在以后在ACM成长的道路上，我能够牢记这次机会的来之不易，真正在这条路上坚持下去。<br><img src="http://oeziv5rwi.bkt.clouddn.com/2016/10/22/002.jpg" alt=""></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 杂记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 点滴 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机的启动[转]]]></title>
      <url>/2016/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%90%AF%E5%8A%A8-%E8%BD%AC/</url>
      <content type="html"><![CDATA[<p>最近在给工作室的电脑重装系统，也了解了一些计算机启动的相关知识，在网上觉得这篇<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="external">博客</a>写得不错。虽然自己现在只是大二，有些地方看起来还是有一些吃力，但是还是收获到了很多的知识。</p>
<a id="more"></a>
<h2 id="零、boot的含义"><a href="#零、boot的含义" class="headerlink" title="零、boot的含义"></a>零、boot的含义</h2><p>先问一个问题，”启动”用英语怎么说？</p>
<p>回答是boot。可是，boot原来的意思是靴子，”启动”与靴子有什么关系呢？ 原来，这里的boot是bootstrap（鞋带）的缩写，它来自一句谚语：</p>
<blockquote>
<p>“pull oneself up by one’s bootstraps”</p>
</blockquote>
<p>字面意思是”拽着鞋带把自己拉起来”，这当然是不可能的事情。最早的时候，工程师们用它来比喻，计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序！</p>
<p>早期真的是这样，必须想尽各种办法，把一小段程序装进内存，然后计算机才能正常运行。所以，工程师们把这个过程叫做”拉鞋带”，久而久之就简称为boot了。</p>
<p>计算机的整个启动过程分成四个阶段。</p>
<h2 id="第一阶段：BIOS"><a href="#第一阶段：BIOS" class="headerlink" title="第一阶段：BIOS"></a>第一阶段：BIOS</h2><p>上个世纪70年代初，”只读内存”（read-only memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。</p>
<p><img src="http://oeziv5rwi.bkt.clouddn.com/2016/10/19/001.png" alt=""></p>
<p>这块芯片里的程序叫做”基本輸出輸入系統”（Basic Input/Output System），简称为BIOS。</p>
<h3 id="硬件自检"><a href="#硬件自检" class="headerlink" title="硬件自检"></a>硬件自检</h3><p>BIOS中主要存放的程序包括：自诊断程序（通过读取CMOS RAM中的内容识别硬件配置，并对其进行自检和初始化）、CMOS设置程序（引导过程中，通过特殊热键启动，进行设置后，存入CMOS RAM中）、系统自动装载程序（在系统自检成功后，将磁盘相对0道0扇区上的引导程序装入内存使其运行）和主要I/O驱动程序和中断服务（BIOS和硬件直接打交道，需要加载I/O驱动程序）。</p>
<p>BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做”硬件自检”（Power-On Self-Test），缩写为POST。</p>
<p>如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</p>
<h3 id="启动顺序"><a href="#启动顺序" class="headerlink" title="启动顺序"></a>启动顺序</h3><p>硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。</p>
<p>这时，BIOS需要知道，”下一阶段的启动程序”具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做”启动顺序”（Boot Sequence）。</p>
<p>打开BIOS的操作界面，里面有一项就是”设定启动顺序”。</p>
<p>BIOS Sequence</p>
<p><img src="http://oeziv5rwi.bkt.clouddn.com/2016/10/19/002.jpg" alt=""></p>
<p>常见项有：</p>
<ul>
<li>Floppy 软盘</li>
<li>HDD－0 硬盘（第一块硬盘）</li>
<li>CDROM 光驱</li>
<li>USB－CDROM USB光驱</li>
<li>USB－HDD 移动硬盘</li>
<li>LAN 网络启动</li>
</ul>
<h2 id="第二阶段：主引导记录"><a href="#第二阶段：主引导记录" class="headerlink" title="第二阶段：主引导记录"></a>第二阶段：主引导记录</h2><p>BIOS按照”启动顺序”，把控制权转交给排在第一位的储存设备。即根据用户指定的引导顺序从软盘、硬盘或是可移动设备中读取启动设备的MBR，并放入指定的位置（0x7c000）内存中。</p>
<p>这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。</p>
<p>这最前面的512个字节，就叫做”主引导记录”（Master boot record，缩写为MBR）。</p>
<h3 id="主引导记录的结构"><a href="#主引导记录的结构" class="headerlink" title="主引导记录的结构"></a>主引导记录的结构</h3><p>“主引导记录”只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。</p>
<p>主引导记录由三个部分组成：</p>
<p>（1） 第1-446字节：调用操作系统的机器码。<br>（2） 第447-510字节：分区表（Partition table）。<br>（3） 第511-512字节：主引导记录签名（0x55和0xAA）。<br>其中，第二部分”分区表”的作用，是将硬盘分成若干个区。</p>
<h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><p>硬盘分区有很多好处。考虑到每个区可以安装不同的操作系统，”主引导记录”因此必须知道将控制权转交给哪个区。</p>
<p>分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做”主分区”。</p>
<p>每个主分区的16个字节，由6个部分组成：</p>
<p>（1） 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。<br>（2） 第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。<br>（3） 第5个字节：主分区类型。<br>（4） 第6-8个字节：主分区最后一个扇区的物理位置。<br>（5） 第9-12字节：该主分区第一个扇区的逻辑地址。<br>（6） 第13-16字节：主分区的扇区总数。<br>最后的四个字节（”主分区的扇区总数”），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。</p>
<p>如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。</p>
<h2 id="第三阶段：硬盘启动"><a href="#第三阶段：硬盘启动" class="headerlink" title="第三阶段：硬盘启动"></a>第三阶段：硬盘启动</h2><p>这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。</p>
<h3 id="情况A：卷引导记录"><a href="#情况A：卷引导记录" class="headerlink" title="情况A：卷引导记录"></a>情况A：卷引导记录</h3><p>上一节提到，四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做”卷引导记录”（Volume boot record，缩写为VBR）。</p>
<p>“卷引导记录”的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。</p>
<h3 id="情况B：扩展分区和逻辑分区"><a href="#情况B：扩展分区和逻辑分区" class="headerlink" title="情况B：扩展分区和逻辑分区"></a>情况B：扩展分区和逻辑分区</h3><p>随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成”扩展分区”（Extended partition）。</p>
<p>所谓”扩展分区”，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做”逻辑分区”（logical partition）。</p>
<p>计算机先读取扩展分区的第一个扇区，叫做”扩展引导记录”（Extended boot record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。</p>
<p>计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。</p>
<p>但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。</p>
<h3 id="情况C：启动管理器"><a href="#情况C：启动管理器" class="headerlink" title="情况C：启动管理器"></a>情况C：启动管理器</h3><p>在这种情况下，计算机读取”主引导记录”前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot loader），由用户选择启动哪一个操作系统。</p>
<p>Linux环境中，目前最流行的启动管理器是Grub。</p>
<p><img src="http://oeziv5rwi.bkt.clouddn.com/2016/10/19/003.png" alt=""></p>
<p>Grub</p>
<p>对于grub而言，在MBR中的446字节的引导程序属于GRUB的开始执行程序，通过这段程序，进一步执行stage1.5或是stage2的执行程序，将在下面详细介绍执行过程。</p>
<p>其中stage1.5或是stage2便属于阶段2引导的过程了，stage2过程也是作为GRUB kernel的核心代码出现。Stage1.5过程（对于GRUB而言存在stage1.5，GRUB2则不存在）的功能很单一，主要就是为了引导stage2过程服务。由于stage2过程的代码存放在文件系统下的boot分区目录中，因此stage1.5过程就是需要提供一个文件系统的环境，而该文件系统环境需要保证系统可以找到stage2过程的文件，那么stage1.5阶段提供的文件系统需要是boot文件系统所对应的，这个在执行grub install过程中就已经确定了。stage2过程中，主要会把系统切换到保护模式，设置好C运行时环境，找到config文件（事实上就是menulist文件），如果没有找到就执行一个shell，等待用户的执行。然后的工作就变成了输入命令-&gt;解析命令-&gt;执行命令的循环中。当然该阶段引导的最终状态就是执行boot命令，将内核和initrd镜像加载进入内存中，进而将控制权转交给内核。</p>
<h2 id="第四阶段：操作系统"><a href="#第四阶段：操作系统" class="headerlink" title="第四阶段：操作系统"></a>第四阶段：操作系统</h2><p>控制权转交给操作系统后，操作系统的内核首先被载入内存。</p>
<p>以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。</p>
<p>然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。</p>
<p>至此，全部启动过程完成。</p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[重装系统]]></title>
      <url>/2016/10/13/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>近日作死地点下了win10系统的更新，然后辛辛苦苦等着电脑更新了一个小时，本以为更新完以后就可以快乐地敲代码了。但是更新完以后电脑就是开不了机，电脑更本就进不了桌面。想起我很多东西都放在C盘还有数据库也是存放在C盘，我整个人都不好了。坑爹的微软爸爸……<br><img src="http://oeziv5rwi.bkt.clouddn.com/2016/10/13/001.png" alt=""><br>无奈之下，只好重装系统……</p>
<a id="more"></a>
<h3 id="一些软件-开发环境备忘"><a href="#一些软件-开发环境备忘" class="headerlink" title="一些软件/开发环境备忘"></a>一些软件/开发环境备忘</h3><h4 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h4><p>若之前的MySQL安装在C盘之外的盘，就不需要重装，直接添加环境变量就行如：如：d:/mysql/bin若之前安装在C盘，如果有备份还好，没有备份的话就里面的数据都没有了，我就是这样，呜呜呜。。。。。</p>
<h5 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h5><p>MySQL的安装包分为两种：一种是msi安装包自动配置设置，另外一种是zip安装包需要解压以后手动配置设置。我选的是msi安装包。</p>
<h5 id="MySQL系列应用和服务"><a href="#MySQL系列应用和服务" class="headerlink" title="MySQL系列应用和服务"></a>MySQL系列应用和服务</h5><p>双击安装包点击自定义安装，会看到选择要安装的服务和应用窗口：<br><img src="http://oeziv5rwi.bkt.clouddn.com/2016/10/13/002.png" alt=""><br>解释一些这些应用：</p>
<ul>
<li>MySQL Sever表示MySQL基础服务</li>
<li>Workbench 表示MySQL的工作台</li>
<li>Notilifier  是一个常驻任务通知栏的快捷通知和更改服务器状态的工具</li>
<li>MySQL for Excel 是和Excel关联的应用 可以将数据库中的文件和Excel表中的文件相互转换</li>
<li>Utilities 是一组命令行工具用于维护和管理 MySQL 服务器，包括管理、复制和一般工具</li>
<li>Connectors 是和为各种语言提供接口的工具（自己认为的） 准备安装完python  再来装这个工具</li>
<li>Document 就是相关的文档了</li>
</ul>
<p>之后就一直确认就可以了完成安装了</p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>安装结束以后会出现配置窗口：<br><img src="http://oeziv5rwi.bkt.clouddn.com/2016/10/13/003.png" alt=""></p>
<p>上面的选项是服务类型选择，分别是开发服务器、Web服务器和全职服务器，所占用的内存依次增多，正常情况下第一个就够用了</p>
<p>后面的配置使用默认设置就行了</p>
<p>最后将MySQL添加到环境变量中</p>
<h4 id="Git-Github"><a href="#Git-Github" class="headerlink" title="Git/Github"></a>Git/Github</h4><p><strong>平时一定要养成备份的好习惯，这样妈妈就再也不用担心我重装系统了！</strong></p>
]]></content>
      
        <categories>
            
            <category> 杂记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[木条染色_题解]]></title>
      <url>/2016/10/13/%E6%9C%A8%E6%9D%A1%E6%9F%93%E8%89%B2%E8%89%B2-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><blockquote>
<p>小明是一个非常浪漫的画家，他喜欢画各种奇奇怪怪的画，虽然没人理解他画的究竟是什么东西。 有一天，他突发奇想，对于一根木条，他每次从木条中选取一个区间[l,r]进行染色，经过多次染色后，他想知道在[a,b]区间中有几个未被染色的子区间？ 可惜小明虽然画画非常厉害，但是并不擅长解决这类问题，于是，他拿着这根木条来找你，希望你能够给他帮助。 假设木条无限长，所有查询都在木条长度范围内，未被染色的子区间是指，木条上染过色的区间的间断部分。</p>
</blockquote>
<a id="more"></a>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote>
<p>第一行一个整数T，代表数据组数。 对于每组数据，第一行给出两个整数n，q，分别代表染色的区间个数，以及查询个数。 之后n行，每行两个整数l，r，表示将l到r的区间进行染色，包含l，r两个节点。 之后q行，每行两个整数a，b，表示询问a到b总共有多少未被染色的子区间。 两组数据之间用一个空行隔开。 T &lt; 20<br>n &lt; 10000<br>q &lt; 100000<br>0 &lt; = l &lt; r &lt; 1000000<br>0 &lt; = a &lt; = b &lt; 1000000</p>
</blockquote>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote>
<p>对于每次询问，输出一个整数，表示查询结果。 每组数据之后，请输出一个空行。</p>
</blockquote>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><blockquote>
<p>对于第一组数据，[0,1)，(2,3)，(4,+ )是未染色的子区间，因此查询[1,3]可以找到(2,3)这个子区间，而对于[3,4]不能找到，对于[5,5]可以找到[5,5]。<br>对于第二组数据，[0,1)和(8,+ )是未染色的子区间，因此对于[0,5]只有子区间[0,1)，对于查询[0,9]，有子区间[0,1)和（8,9]，对于查询[9,9]，有[9,9]这个子区间。</p>
</blockquote>
<hr>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>使用标记法，首先就是区分染色的和未染色的区间，通过染色起点++染色终点–后每一个点的标记值加上前一个点的标记值形成新的标记值，这样标记为0的就是空区间中的点，非0的就是非空区间中的点。然后通过大区间标号（即一个空区间和他右边的一个非空区间进行合并形成大区间然后给每个区间从小到大标号），这样两个点之间的空区间标记数之差就是两点间的空区间数了。注意处理最前面的空区间和最后面的空区间，最前面的空区间是直接判断点在不在空区间中，如果在的话答案++。为大区间标号的时候，向染色设计的最大范围后面多标一个，以应对查询范围在染色范围右端的情况。</strong></p>
<hr>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 1000005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mm(a,b) memset(a,b,sizeof(a))</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> a[SIZE],b[SIZE],anse[SIZE/<span class="number">10</span>+<span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,q,i,d,t,ml=<span class="number">0</span>;</div><div class="line">    mm(a,<span class="number">0</span>);</div><div class="line">    mm(b,<span class="number">0</span>);</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</div><div class="line">    <span class="comment">//cin&gt;&gt;n&gt;&gt;q;</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;d,&amp;t);</div><div class="line">        <span class="comment">//cin&gt;&gt;d&gt;&gt;t;</span></div><div class="line">        a[d]++;</div><div class="line">        a[t]--;</div><div class="line">        ml=max(ml,t);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> num=<span class="number">1</span>,ans;</div><div class="line">    b[<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=ml+<span class="number">1</span>;i++)  <span class="comment">//+1确保从空区间开始空区间结束</span></div><div class="line">    &#123;</div><div class="line">        a[i]+=a[i<span class="number">-1</span>];</div><div class="line">        b[i]=num;</div><div class="line">        <span class="keyword">if</span>(a[i]==<span class="number">0</span>&amp;&amp;a[i<span class="number">-1</span>]!=<span class="number">0</span>)num++; <span class="comment">//下一个在空区间内的点归入下一个大区间</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;q;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;d,&amp;t);</div><div class="line">        <span class="comment">//cin&gt;&gt;d&gt;&gt;t;</span></div><div class="line">        <span class="keyword">if</span>(t&gt;ml)t=ml+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(d&gt;ml)d=ml+<span class="number">1</span>;</div><div class="line">        ans=b[t]-b[d];</div><div class="line">        <span class="keyword">if</span>((d&gt;<span class="number">0</span>&amp;&amp;a[d]==<span class="number">0</span>&amp;&amp;a[d<span class="number">-1</span>]==<span class="number">0</span>)||(d==<span class="number">0</span>&amp;&amp;a[d]==<span class="number">0</span>))  <span class="comment">//对开始为空区间的情况进行讨论</span></div><div class="line">            ans++;</div><div class="line">        anse[i]=ans;</div><div class="line">        <span class="comment">//cout&lt;&lt;ans&lt;&lt;endl;</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;q;i++)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,anse[i]);</div><div class="line">        <span class="comment">//cout&lt;&lt;anse[i]&lt;&lt;endl;</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> t;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</div><div class="line">    <span class="comment">//cin&gt;&gt;t;</span></div><div class="line">    <span class="keyword">while</span>(t--)solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 区间覆盖 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[背包九讲（转）]]></title>
      <url>/2016/10/09/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2%EF%BC%88%E8%BD%AC%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>背包问题是常见的动态规划算法题,背包问题中又包含了许多细分的问题，我觉得dd大牛总结的比较好！</p>
<a id="more"></a>
<h3 id="P01-01背包问题"><a href="#P01-01背包问题" class="headerlink" title="P01: 01背包问题"></a>P01: 01背包问题</h3><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p>
<h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><p>这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 </p>
<p>用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}。</p>
<p>这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-c[i]的背包中”，此时能获得的最大价值就是f [i-1][v-c[i]]再加上通过放入第i件物品获得的价值w[i]。</p>
<p>注意f[i][v]有意义当且仅当存在一个前i件物品的子集，其费用总和为v。所以按照这个方程递推完毕后，最终的答案并不一定是f[N] [V]，而是f[N][0..V]的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项f[i][v-1]，这样就可以保证f[N] [V]就是最后的答案。至于为什么这样就可以，由你自己来体会了。 </p>
<h5 id="优化空间复杂度"><a href="#优化空间复杂度" class="headerlink" title="优化空间复杂度"></a>优化空间复杂度</h5><p>以上方法的时间和空间复杂度均为O(N*V)，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到O(V)。</p>
<p>先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组f[i][0..V]的所有值。那么，如果只用一个数组f [0..V]，能不能保证第i次循环结束后f[v]中表示的就是我们定义的状态f[i][v]呢？f[i][v]是由f[i-1][v]和f[i-1] [v-c[i]]两个子问题递推而来，能否保证在推f[i][v]时（也即在第i次主循环中推f[v]时）能够得到f[i-1][v]和f[i-1][v -c[i]]的值呢？事实上，这要求在每次主循环中我们以v=V..0的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态f[i -1][v-c[i]]的值。伪代码如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</div><div class="line"><span class="keyword">for</span> v=V.<span class="number">.0</span></div><div class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</div></pre></td></tr></table></figure>
<p> 其中的f[v]=max{f[v],f[v-c[i]]}一句恰就相当于我们的转移方程f[i][v]=max{f[i-1][v],f[i- 1][v-c[i]]}，因为现在的f[v-c[i]]就相当于原来的f[i-1][v-c[i]]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-c[i]]推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。 </p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。 </p>
<hr>
<h4 id="P02-完全背包问题"><a href="#P02-完全背包问题" class="headerlink" title="P02: 完全背包问题"></a>P02: 完全背包问题</h4><h5 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h5><p>有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p>
<h5 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h5><p>这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：f[i][v]=max{f[i-1][v-k<em>c[i]]+k</em>w[i]|0&lt;=k<em>c[i]&lt;= v}。这跟01背包问题一样有O(N</em>V)个状态需要求解，但求解每个状态的时间则不是常数了，求解状态f[i][v]的时间是O(v/c[i])，总的复杂度是超过O(VN)的。 </p>
<p>将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。 </p>
<h5 id="一个简单有效的优化"><a href="#一个简单有效的优化" class="headerlink" title="一个简单有效的优化"></a>一个简单有效的优化</h5><p>完全背包问题有一个很简单有效的优化，是这样的：若两件物品i、j满足c[i]&lt;=c[j]且w[i]&gt;=w[j]，则将物品j去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高得j换成物美价廉的i，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。 </p>
<p>转化为01背包问题求解<br>既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选V/c [i]件，于是可以把第i种物品转化为V/c[i]件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。 </p>
<p>更高效的转化方法是：把第i种物品拆成费用为c[i]<em>2^k、价值为w[i]</em>2^k的若干件物品，其中k满足c[i]<em>2^k&lt;V。这是二进制的思想，因为不管最优策略选几件第i种物品，总可以表示成若干个2^k件物品的和。这样把每种物品拆成O(log(V/c[i]))件物品，是一个很大的改进。但我们有更优的O(VN)的算法。</em> O(VN)的算法这个算法使用一维数组，先看伪代码： <pre class"example"=""> for i=1..N for v=0..V f[v]=max{f[v],f[v-c[i]]+w[i]};</pre></p>
<p> 你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照v=V..0的逆序来循环。这是因为要保证第i次循环中的状态f[i][v]是由状态f[i-1][v-c[i]]递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[i-1][v-c[i]]。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v= 0..V的顺序循环。这就是这个简单的程序为何成立的道理。</p>
<p>这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}，将这个方程用一维数组实现，便得到了上面的伪代码。 </p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在“基本思路”以及“O(VN)的算法“的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。 </p>
<hr>
<h4 id="P03-多重背包问题"><a href="#P03-多重背包问题" class="headerlink" title="P03: 多重背包问题"></a>P03: 多重背包问题</h4><h5 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h5><p>有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p>
<h5 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h5><p>这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有n[i]+1种策略：取0件，取1件……取n[i]件。令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值，则：f[i][v]=max{f[i-1][v-k<em>c[i]]+ k</em>w[i]|0&lt;=k&lt;=n[i]}。复杂度是O(V*∑n[i])。</p>
<p>转化为01背包问题<br>另一种好想好写的基本方法是转化为01背包求解：把第i种物品换成n[i]件01背包中的物品，则得到了物品数为∑n[i]的01背包问题，直接求解，复杂度仍然是O(V*∑n[i])。 </p>
<p>但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n[i]件——均能等价于取若干件代换以后的物品。另外，取超过n[i]件的策略必不能出现。 </p>
<p>方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为 1,2,4,…,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1&gt;0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。 </p>
<p>分成的这几件物品的系数和为n[i]，表明不可能取多于n[i]件的第i种物品。另外这种方法也能保证对于0..n[i]间的每一个整数，均可以用若干个系数的和表示，这个证明可以分0..2^k-1和2^k..n[i]两段来分别讨论得出，并不难，希望你自己思考尝试一下。 </p>
<p>这样就将第i种物品分成了O(log n[i])种物品，将原问题转化为了复杂度为O(V*∑log n[i])的01背包问题，是很大的改进。 </p>
<p>O(VN)的算法<br>多重背包问题同样有O(VN)的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。 </p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>这里我们看到了将一个算法的复杂度由O(V<em>∑n[i])改进到O(V</em>∑log n[i])的过程，还知道了存在应用超出NOIP范围的知识的O(VN)算法。希望你特别注意“拆分物品”的思想和方法，自己证明一下它的正确性，并用尽量简洁的程序来实现。</p>
<hr>
<h4 id="P04-混合三种背包问题"><a href="#P04-混合三种背包问题" class="headerlink" title="P04: 混合三种背包问题"></a>P04: 混合三种背包问题</h4><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>如果将P01、P02、P03混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？ </p>
<h5 id="01背包与完全背包的混合"><a href="#01背包与完全背包的混合" class="headerlink" title="01背包与完全背包的混合"></a>01背包与完全背包的混合</h5><p>考虑到在P01和P02中最后给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是O(VN)。伪代码如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</div><div class="line"><span class="keyword">if</span> 第i件物品是<span class="number">01</span>背包</div><div class="line"><span class="keyword">for</span> v=V.<span class="number">.0</span></div><div class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> 第i件物品是完全背包 </div><div class="line"><span class="keyword">for</span> v=<span class="number">0.</span>.V</div><div class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</div></pre></td></tr></table></figure>
<h5 id="再加上多重背包"><a href="#再加上多重背包" class="headerlink" title="再加上多重背包"></a>再加上多重背包</h5><p>如果再加上有的物品最多可以取有限次，那么原则上也可以给出O(VN)的解法：遇到多重背包类型的物品用单调队列解即可。但如果不考虑超过NOIP范围的算法的话，用P03中将每个这类物品分成O(log n[i])个01背包的物品的方法也已经很优了。 </p>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>有人说，困难的题目都是由简单的题目叠加而来的。这句话是否公理暂且存之不论，但它在本讲中已经得到了充分的体现。本来01背包、完全背包、多重背包都不是什么难题，但将它们简单地组合起来以后就得到了这样一道一定能吓倒不少人的题目。但只要基础扎实，领会三种基本背包问题的思想，就可以做到把困难的题目拆分成简单的题目来解决。 </p>
<hr>
<h4 id="P05-二维费用的背包问题"><a href="#P05-二维费用的背包问题" class="headerlink" title="P05: 二维费用的背包问题"></a>P05: 二维费用的背包问题</h4><h5 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h5><p>二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为w[i]。</p>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><p>费用加了一维，只需状态也加一维即可。设f[i][v][u]表示前i件物品付出两种代价分别为v和u时可获得的最大价值。状态转移方程就是：f [i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}。如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量v和u采用顺序的循环，当物品有如完全背包问题时采用逆序的循环。当物品有如多重背包问题时拆分物品。 </p>
<p>物品总个数的限制<br>有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取M件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为1，可以付出的最大件数费用为M。换句话说，设f[v][m]表示付出费用v、最多选m件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在f[0..V][0..M]范围内寻找答案。 </p>
<p>另外，如果要求“恰取M件物品”，则在f[0..V][M]范围内寻找答案。 </p>
<h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><p>事实上，当发现由熟悉的动态规划题目变形得来的题目时，在原来的状态中加一纬以满足新的限制是一种比较通用的方法。希望你能从本讲中初步体会到这种方法。 </p>
<hr>
<h4 id="P06-分组的背包问题"><a href="#P06-分组的背包问题" class="headerlink" title="P06: 分组的背包问题"></a>P06: 分组的背包问题</h4><h5 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h5><p>有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p>
<h5 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h5><p>这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设f[k][v]表示前k组物品花费费用v能取得的最大权值，则有f[k][v]=max{f[k-1][v],f[k-1][v-c[i]]+w[i]|物品i属于第k组}。</p>
<p>使用一维数组的伪代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> 所有的组k</div><div class="line"><span class="keyword">for</span> 所有的i属于组k</div><div class="line"><span class="keyword">for</span> v=V.<span class="number">.0</span></div><div class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;</div></pre></td></tr></table></figure></p>
<p> 另外，显然可以对每组中的物品应用P02中“一个简单有效的优化”。</p>
<h5 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h5><p>分组的背包问题将彼此互斥的若干物品称为一个组，这建立了一个很好的模型。不少背包问题的变形都可以转化为分组的背包问题（例如P07），由分组的背包问题进一步可定义“泛化物品”的概念，十分有利于解题。 </p>
<hr>
<h4 id="P07-有依赖的背包问题"><a href="#P07-有依赖的背包问题" class="headerlink" title="P07: 有依赖的背包问题"></a>P07: 有依赖的背包问题</h4><h5 id="简化的问题"><a href="#简化的问题" class="headerlink" title="简化的问题"></a>简化的问题</h5><p>这种背包问题的物品间存在某种“依赖”的关系。也就是说，i依赖于j，表示若选物品i，则必须选物品j。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。 </p>
<h5 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h5><p>这个问题由NOIP2006金明的预算方案一题扩展而来。遵从该题的提法，将不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。 </p>
<p>按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……无法用状态转移方程来表示如此多的策略。（事实上，设有n个附件，则策略有2^n+1个，为指数级。） </p>
<p>考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于P06中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。 </p>
<p>再考虑P06中的一句话：可以对每组中的物品应用P02中“一个简单有效的优化”。这提示我们，对于一个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，我们可以对主件i的“附件集合”先进行一次01背包，得到费用依次为0..V-c[i]所有这些值时相应的最大价值f’[0..V-c[i]]。那么这个主件及它的附件集合相当于V-c[i]+1个物品的物品组，其中费用为c[i]+k的物品的价值为f’[k]+w[i]。也就是说原来指数级的策略中有很多策略都是冗余的，通过一次01背包后，将主件i转化为 V-c[i]+1个物品的物品组，就可以直接应用P06的算法解决问题了。 </p>
<p>更一般的问题<br>更一般的问题是：依赖关系以图论中“森林”的形式给出（森林即多叉树的集合），也就是说，主件的附件仍然可以具有自己的附件集合，限制只是每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。 </p>
<p>解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的01 背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。 </p>
<p>事实上，这是一种树形DP，其特点是每个父节点都需要对它的各个儿子的属性进行一次DP以求得自己的相关属性。这已经触及到了“泛化物品”的思想。看完P08后，你会发现这个“依赖关系树”每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。 </p>
<h5 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h5><p>NOIP2006的那道背包问题我做得很失败，写了上百行的代码，却一分未得。后来我通过思考发现通过引入“物品组”和“依赖”的概念可以加深对这题的理解，还可以解决它的推广问题。用物品组的思想考虑那题中极其特殊的依赖关系：物品不能既作主件又作附件，每个主件最多有两个附件，可以发现一个主件和它的两个附件等价于一个由四个物品组成的物品组，这便揭示了问题的某种本质。 </p>
<p>我想说：失败不是什么丢人的事情，从失败中全无收获才是。 </p>
<hr>
<h4 id="P08-泛化物品"><a href="#P08-泛化物品" class="headerlink" title="P08: 泛化物品"></a>P08: 泛化物品</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的费用而变化。这就是泛化物品的概念。 </p>
<p>更严格的定义之。在背包容量为V的背包问题中，泛化物品是一个定义域为0..V中的整数的函数h，当分配给它的费用为v时，能得到的价值就是h(v)。</p>
<p>这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组h[0..V]，给它费用v，可得到价值h[V]。</p>
<p>一个费用为c价值为w的物品，如果它是01背包中的物品，那么把它看成泛化物品，它就是除了h(c)=w其它函数值都为0的一个函数。如果它是完全背包中的物品，那么它可以看成这样一个函数，仅当v被c整除时有h(v)=v/c<em>w，其它函数值均为0。如果它是多重背包中重复次数最多为n的物品，那么它对应的泛化物品的函数有h(v)=v/c</em>w仅当v被c整除且v/c&lt;=n，其它情况函数值均为0。 </p>
<p>一个物品组可以看作一个泛化物品h。对于一个0..V中的v，若物品组中不存在费用为v的的物品，则h(v)=0，否则h(v)为所有费用为v的物品的最大价值。P07中每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。</p>
<h5 id="泛化物品的和"><a href="#泛化物品的和" class="headerlink" title="泛化物品的和"></a>泛化物品的和</h5><p>如果面对两个泛化物品h和l，要用给定的费用从这两个泛化物品中得到最大的价值，怎么求呢？事实上，对于一个给定的费用v，只需枚举将这个费用如何分配给两个泛化物品就可以了。同样的，对于0..V的每一个整数v，可以求得费用v分配到h和l中的最大价值f(v)。也即f(v)=max{h(k) +l(v-k)|0&lt;=k&lt;=v}。可以看到，f也是一个由泛化物品h和l决定的定义域为0..V的函数，也就是说，f是一个由泛化物品h和 l决定的泛化物品。 </p>
<p>由此可以定义泛化物品的和：h、l都是泛化物品，若泛化物品f满足f(v)=max{h(k)+l(v-k)|0&lt;=k&lt;=v}，则称f是h与l的和，即f=h+l。这个运算的时间复杂度是O(V^2)。 </p>
<p>泛化物品的定义表明：在一个背包问题中，若将两个泛化物品代以它们的和，不影响问题的答案。事实上，对于其中的物品都是泛化物品的背包问题，求它的答案的过程也就是求所有这些泛化物品之和的过程。设此和为s，则答案就是s[0..V]中的最大值。</p>
<p>背包问题的泛化物品<br>一个背包问题中，可能会给出很多条件，包括每种物品的费用、价值等属性，物品之间的分组、依赖等关系等。但肯定能将问题对应于某个泛化物品。也就是说，给定了所有条件以后，就可以对每个非负整数v求得：若背包容量为v，将物品装入背包可得到的最大价值是多少，这可以认为是定义在非负整数集上的一件泛化物品。这个泛化物品——或者说问题所对应的一个定义域为非负整数的函数——包含了关于问题本身的高度浓缩的信息。一般而言，求得这个泛化物品的一个子域（例如0..V）的值之后，就可以根据这个函数的取值得到背包问题的最终答案。</p>
<p>综上所述，一般而言，求解背包问题，即求解这个问题所对应的一个函数，即该问题的泛化物品。而求解某个泛化物品的一种方法就是将它表示为若干泛化物品的和然后求之。 </p>
<h5 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h5><p>本讲可以说都是我自己的原创思想。具体来说，是我在学习函数式编程的 Scheme 语言时，用函数编程的眼光审视各类背包问题得出的理论。这一讲真的很抽象，也许在“模型的抽象程度”这一方面已经超出了NOIP的要求，所以暂且看不懂也没关系。相信随着你的OI之路逐渐延伸，有一天你会理解的。 </p>
<p>我想说：“思考”是一个OIer最重要的品质。简单的问题，深入思考以后，也能发现更多。 </p>
<hr>
<h4 id="P09-背包问题问法的变化"><a href="#P09-背包问题问法的变化" class="headerlink" title="P09: 背包问题问法的变化"></a>P09: 背包问题问法的变化</h4><p>以上涉及的各种背包问题都是要求在背包容量（费用）的限制下求可以取到的最大价值，但背包问题还有很多种灵活的问法，在这里值得提一下。但是我认为，只要深入理解了求背包问题最大价值的方法，即使问法变化了，也是不难想出算法的。 </p>
<p>例如，求解最多可以放多少件物品或者最多可以装满多少背包的空间。这都可以根据具体问题利用前面的方程求出所有状态的值（f数组）之后得到。 </p>
<p>还有，如果要求的是“总价值最小”“总件数最小”，只需简单的将上面的状态转移方程中的max改成min即可。</p>
<p>下面说一些变化更大的问法。 </p>
<p>输出方案<br>一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由状态转移方程的哪一项推出来的，换句话说，记录下它是由哪一个策略推出来的。便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。 </p>
<p>还是以01背包为例，方程为f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}。再用一个数组g[i] [v]，设g[i][v]=0表示推出f[i][v]的值时是采用了方程的前一项（也即f[i][v]=f[i-1][v]），g[i][v]表示采用了方程的后一项。注意这两项分别表示了两种策略：未选第i个物品及选了第i个物品。那么输出方案的伪代码可以这样写（设最终状态为f[N][V]）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">i=N</div><div class="line">v=V</div><div class="line"><span class="keyword">while</span>(i&gt;<span class="number">0</span>)</div><div class="line"><span class="keyword">if</span>(g[i][v]==<span class="number">0</span>)</div><div class="line">print <span class="string">"未选第i项物品"</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g[i][v]==<span class="number">1</span>)</div><div class="line">print <span class="string">"选了第i项物品"</span></div><div class="line">v=v-c[i]</div></pre></td></tr></table></figure></p>
<p> 另外，采用方程的前一项或后一项也可以在输出方案的过程中根据f[i][v]的值实时地求出来，也即不须纪录g数组，将上述代码中的g[i] [v]==0改成f[i][v]==f[i-1][v]，g[i][v]==1改成f[i][v]==f[i-1][v-c[i]]+w[i]也可。</p>
<p>输出字典序最小的最优方案<br>这里“字典序最小”的意思是1..N号物品的选择方案排列出来以后字典序最小。以输出01背包最小字典序的方案为例。 </p>
<p>一般而言，求一个字典序最小的最优方案，只需要在转移时注意策略。首先，子问题的定义要略改一些。我们注意到，如果存在一个选了物品1的最优方案，那么答案一定包含物品1，原问题转化为一个背包容量为v-c[1]，物品为2..N的子问题。反之，如果答案不包含物品1，则转化成背包容量仍为V，物品为2..N的子问题。不管答案怎样，子问题的物品都是以i..N而非前所述的1..i的形式来定义的，所以状态的定义和转移方程都需要改一下。但也许更简易的方法是先把物品逆序排列一下，以下按物品已被逆序排列来叙述。 </p>
<p>在这种情况下，可以按照前面经典的状态转移方程来求值，只是输出方案的时候要注意：从N到1输入时，如果f[i][v]==f[i-v]及f[i][v]==f[i-1][f-c[i]]+w[i]同时成立，应该按照后者（即选择了物品i）来输出方案。 </p>
<p>求方案总数<br>对于一个给定了背包容量、物品费用、物品间相互关系（分组、依赖等）的背包问题，除了再给定每个物品的价值后求可得到的最大价值外，还可以得到装满背包或将背包装至某一指定容量的方案总数。 </p>
<p>对于这类改变问法的问题，一般只需将状态转移方程中的max改成sum即可。例如若每件物品均是01背包中的物品，转移方程即为f[i][v]=sum{f[i-1][v],f[i-1][v-c[i]]+w[i]}，初始条件f[0][0]=1。</p>
<p>事实上，这样做可行的原因在于状态转移方程已经考察了所有可能的背包组成方案。 </p>
<p>最优方案的总数<br>这里的最优方案是指物品总价值最大的方案。还是以01背包为例。 </p>
<p>结合求最大总价值和方案总数两个问题的思路，最优方案的总数可以这样求：f[i][v]意义同前述，g[i][v]表示这个子问题的最优方案的总数，则在求f[i][v]的同时求g[i][v]的伪代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</div><div class="line"><span class="keyword">for</span> v=<span class="number">0.</span>.V</div><div class="line">f[i][v]=max&#123;f[i<span class="number">-1</span>][v],f[i<span class="number">-1</span>][v-c[i]]+w[i]&#125;</div><div class="line">g[i][v]=<span class="number">0</span></div><div class="line"><span class="keyword">if</span>(f[i][v]==f[i<span class="number">-1</span>][v])</div><div class="line">inc(g[i][v],g[i<span class="number">-1</span>][v]</div><div class="line"><span class="keyword">if</span>(f[i][v]==f[i<span class="number">-1</span>][v-c[i]]+w[i])</div><div class="line">inc(g[i][v],g[i<span class="number">-1</span>][v-c[i]])</div></pre></td></tr></table></figure></p>
<p> 如果你是第一次看到这样的问题，请仔细体会上面的伪代码。 </p>
<h5 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h5><p>显然，这里不可能穷尽背包类动态规划问题所有的问法。甚至还存在一类将背包类动态规划问题与其它领域（例如数论、图论）结合起来的问题，在这篇论背包问题的专文中也不会论及。但只要深刻领会前述所有类别的背包问题的思路和状态转移方程，遇到其它的变形问法，只要题目难度还属于NOIP，应该也不难想出算法。 </p>
<p>触类旁通、举一反三，应该也是一个OIer应有的品质吧。</p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>转自dd大牛，膜拜大神</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[极客精神]]></title>
      <url>/2016/10/01/%E6%9E%81%E5%AE%A2%E7%B2%BE%E7%A5%9E/</url>
      <content type="html"><![CDATA[<p>讲到极客，大家可能会联想到很多的代名词：科技、钻研、较真…… 很长的一段时间里面我都希望自己是一个极客，但在很多人的心目中极客的定义各不相同，最近看了ZEALER创始人王自如的一个视频，我比较认可他对于极客的理解。</p>
<a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>讲到极客，大家可能会联想到很多的代名词：科技、钻研、较真…… 很长的一段时间里面我都希望自己是一个极客，但在很多人的心目中极客的定义各不相同，最近看了ZEALER创始人王自如的一个视频，我比较认可他对于极客的理解。</p>
<h3 id="极客精神"><a href="#极客精神" class="headerlink" title="极客精神"></a>极客精神</h3><p>下面就来讲一讲极我认同的极客所具备的品质：</p>
<h5 id="技术控"><a href="#技术控" class="headerlink" title="技术控"></a>技术控</h5><p>极客是对技术有着很强的的理解和学习能力的人，不仅知道当今的流行技术是什么，还能知道这些技术具体的工作原理。懂技术的不一定能够懂产品，但是懂产品的人是不可能不懂技术的。</p>
<h5 id="动手能力"><a href="#动手能力" class="headerlink" title="动手能力"></a>动手能力</h5><p>不仅脑袋里面有知识懂得科技的工作原理，还能够将他们应用于实践，像什么装个系统、写个软件等等是必须的。这种动手能力就应该是将所学的东西应用起来或者说要做出个什么东西而去学具体的知识技术所锻炼出来的。当然对技术的热爱，也是锻炼出这种动手能力所必须的。我想每一个极客都有自己动手丰衣足食的经历吧、</p>
<h5 id="偏执、较真"><a href="#偏执、较真" class="headerlink" title="偏执、较真"></a>偏执、较真</h5><p>一件事，干不到我想要的样，它就是不行。有一丁点的不满意，极客推导重来都可以！极客能够克服技术学习和实践当中的各种枯燥。做不到自己定的目标，就是不甘心，就是不放弃。</p>
<h5 id="探索精神"><a href="#探索精神" class="headerlink" title="探索精神"></a>探索精神</h5><p>当人咧的始祖第一次对日月更替、下雨打雷产生好奇的时候；当他们第一次抬头看都漫天繁星的时候，人类的科技就已经开始进步了。极客就是具备这样不停发问、不停求知的一些人。他们都是利用自己对技术的痴迷和执拗的方式身体力行去实践。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>极客可以是一群被未知点燃的生物。不管怎样，没有对事物的热爱、对技术的痴迷，是不能够成为极客的。</p>
<p>由此可见，在极客养成的道路上我还有很长的路要走，不过对于科技的热爱我想我是真心的，希望在这条路上我能够越走越远。</p>
<p>最后附上视频的<a href="http://www.zealer.com/post/242.html" target="_blank" rel="external">链接</a></p>
]]></content>
      
        <categories>
            
            <category> 杂记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 极客 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux学习——在线帮助和档案属性]]></title>
      <url>/2016/09/30/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9C%A8%E7%BA%BF%E5%B8%AE%E5%8A%A9%E5%92%8C%E6%A1%A3%E6%A1%88%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>因为有些应用和项目要部署到Linux服务器上，而且作为一个计算机专业的人怎么能不会用Linux呢！所以我要开始深入学习Linux了。通过博客我会将对一些常用、重要的命令进行总结。</p>
<a id="more"></a>
<h2 id="在线求助"><a href="#在线求助" class="headerlink" title="在线求助"></a>在线求助</h2><h3 id="man-要查询的内容"><a href="#man-要查询的内容" class="headerlink" title="man + 要查询的内容"></a>man + 要查询的内容</h3><h4 id="命令的种类"><a href="#命令的种类" class="headerlink" title="命令的种类"></a>命令的种类</h4><p>返回的文本中第一行中以括号的形式显示查询内容所属的类，大致分成一下几种</p>
<ol>
<li>使用者可以操作的指令或可执行文件</li>
<li>系统核心可呼叫的函数与工具等</li>
<li>一些常用的函数(function)与函式库(library)</li>
<li>装置档案的说明</li>
<li>设定档或者是某些档案的格式</li>
<li>游戏(games)</li>
<li>惯例与协议等，例如 Linux 标准档案系统、 网络协议、ASCII code 等等的说明内容</li>
<li>系统管理员可用的管理指令</li>
<li>跟 kernel 有关的文件</li>
</ol>
<h4 id="返回文本的内容"><a href="#返回文本的内容" class="headerlink" title="返回文本的内容"></a>返回文本的内容</h4><ul>
<li>NAME 简短的指令、数据名称说明</li>
<li>SYNOPSIS 简短的指令下达语法(syntax)简介</li>
<li>DESCRIPTION 较为完整的说明，这部分最好仔细看看！</li>
<li>OPTIONS 针对 SYNOPSIS 部分中，有列举的所有可用的参数说明</li>
<li>COMMANDS 当这个程序(软件)在执行的时候，可以在此程序(软件)中下达的指令</li>
<li>FILES 这个程序或数据所使用或参考或连结到的某些档案</li>
<li>SEE ALSO 可以参考的，跟这个指令或数据有相关的其它说明！</li>
<li>EXAMPLE 一些可以参考的范例</li>
<li>BUGS 是否有相关的臭虫</li>
</ul>
<h4 id="搜索关键字"><a href="#搜索关键字" class="headerlink" title="搜索关键字"></a>搜索关键字</h4><p>输入/+word 系统将会搜索输入的关键字，并且将光标指向相应的位置</p>
<h3 id="info-查询内容"><a href="#info-查询内容" class="headerlink" title="info + 查询内容"></a>info + 查询内容</h3><p>与man相似的查询相关指令或者档案的方法就是info，不用的是info以info的形式保存在文件中</p>
<h2 id="档案属性"><a href="#档案属性" class="headerlink" title="档案属性"></a>档案属性</h2><h3 id="使用者与群组"><a href="#使用者与群组" class="headerlink" title="使用者与群组"></a>使用者与群组</h3><p>因为Linux系统是一个多用户多任务的系统，所以文件档案的操作使用权限对不同的用户是不同的。主要区分一下这几种用户：</p>
<ul>
<li>档案拥有者</li>
<li>群组</li>
<li>其他人</li>
</ul>
<p>通过设置对这几种用户的权限来实现对文件安全的管理</p>
<p>以上的信息都保存在一些文件当中，root 的相关信息，都是记录在 /etc/passwd 这个档案内的，至于密码则是记录在 /etc/shadow 这个档案下，Linux 所有的群组名称都纪录在 /etc/group 内</p>
<h3 id="档案权限"><a href="#档案权限" class="headerlink" title="档案权限"></a>档案权限</h3><p>区分了用户，自然就会对不同的用户有不同的权限方案。利用 ls -al 命令查询文件档案的属性，显示的形式如下：</p>
<blockquote>
<p>drwxr–r– 3 root root 4096 Jun 25 08:35 .ssh</p>
</blockquote>
<p>第一个字符代表该档案的类型，主要有一下几种：</p>
<ul>
<li>当为[ d ]则是目录，例如上表的第 11 行；</li>
<li>当为[ - ]则是档案，例如上表的第 5 行；</li>
<li>若是[ l ]则表示为连结档(link file)；</li>
<li>若是[ b ]则表示为装置文件里面的可供储存的接口设备；</li>
<li>若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标。</li>
</ul>
<p>接下来的3*3分三组表示对三种用户的权限情况</p>
<ul>
<li>第一组为『拥有人的权限』</li>
<li>第二组为『同群组的权限』</li>
<li>第三组为『其它非本群组的权限』</li>
</ul>
<p>每组中有单个字符r,w,x 分别表示可读，可写，可执行</p>
<blockquote>
<p>想要进入该目录就必须给相应用户这个目录x权限</p>
</blockquote>
<h3 id="改变档案权限"><a href="#改变档案权限" class="headerlink" title="改变档案权限"></a>改变档案权限</h3><h4 id="chgrp-改变群组"><a href="#chgrp-改变群组" class="headerlink" title="chgrp 改变群组"></a>chgrp 改变群组</h4><blockquote>
<p>chgrp [-R] dirname/filename</p>
</blockquote>
<p>其中-R : 进行递归( recursive )的持续变更，亦即连同次目录下的所有档案、目录<br>都更新成为这个群组之意。常常用在变更某一目录的情况</p>
<h4 id="chown-改变档案拥有者"><a href="#chown-改变档案拥有者" class="headerlink" title="chown 改变档案拥有者"></a>chown 改变档案拥有者</h4><blockquote>
<p>chown [-R] 账号名称 档案或目录</p>
</blockquote>
<h4 id="chmod-改变九个属性"><a href="#chmod-改变九个属性" class="headerlink" title="chmod 改变九个属性"></a>chmod 改变九个属性</h4><blockquote>
<p>chmod [-R] xyz 档案或目录</p>
</blockquote>
<p>用数字4，2，1分别表示权限中的 r，w，x   三个权限相加以后就是对应用户对该档案的权限情况。有三种用户自然就会有三种权限</p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[开启我的博客之旅]]></title>
      <url>/2016/09/25/%E5%BC%80%E5%90%AF%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/</url>
      <content type="html"><![CDATA[<p>很久以来都想做一个自己的博客，但是由于各种原因一直没能做出来。这个学期开学也有一段时间了，我也成功地转到了计算机专业。最近就花了一些时间把博客做出来，当然刚开始很多地方都有不足有漏洞，希望未来真正能够把这个博客做起来！下面讲一讲我为什么要把这个博客给做起来吧。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  很久以来都想做一个自己的博客，但是由于各种原因一直没能做出来。这个学期开学也有一段时间了，我也成功地转到了计算机专业。最近就花了一些时间把博客做出来，当然刚开始很多地方都有不足有漏洞，希望未来真正能够把这个博客做起来！下面讲一讲我为什么要把这个博客给做起来吧。</p>
<h2 id="希望发挥的作用"><a href="#希望发挥的作用" class="headerlink" title="希望发挥的作用"></a>希望发挥的作用</h2><ul>
<li><p>希望能够通过这个博客来督促我对所学的知识进行定期的总结，我觉得这对于身为计算机的学生所必要的。</p>
</li>
<li><p>希望通过写博客来对我语言表达能力进行一定的锻炼，促使我将各个事物各个知识点之间的关系连接起来。让我的文章的逻辑更加清晰。</p>
</li>
<li><p>希望通过这个平台对我总结的东西进行一个审视同时与各种各样的大牛进行交流，相互学习共同进步</p>
</li>
</ul>
<blockquote>
<p>不忘初心，放得始终。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 杂记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 点滴 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
