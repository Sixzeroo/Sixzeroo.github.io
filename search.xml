<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Redis 实践中的问题与优化]]></title>
      <url>/2018/08/16/Redis-%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>总结在常见的在Redis实践中遇到的问题和优化方法</p>
<a id="more"></a>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>缓存中存储的是数据库中命中的数据，如果没有命中，则会去数据库中去取然后回溯到缓存中。这个时候如果一直访问一个数据库中也没有的数据，就可能造成大量请求直接访问数据库。</p>
<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><ol>
<li>如果从数据库中查询的结果也为空，那么将这个空结果也放到缓存中。这样可能会造成数据不一致的情况（具体取决数据库和缓存的一致性策略），所以要设置一个比较短的过期时间。</li>
<li>查询数据库的时候使用互斥锁，查询前首先要得到锁再去查询，没有得到锁的要先等待直到锁可用。但是这种方案可能减低其查询的性能，因为只能够有一个查询存在，所以对于不属于缓存穿透的场景的查询性能会收到影响。</li>
<li>知道key的规则或者合法性，可以在业务层就进行一个过滤（通过规则或者布隆过滤器）</li>
</ol>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>缓存中设置了失效时间，如果大量缓存在短时间内一起失效，这样访问的压力就都移到数据库中去了。就像发生雪崩一样。</p>
<h3 id="优化方案-1"><a href="#优化方案-1" class="headerlink" title="优化方案"></a>优化方案</h3><ul>
<li>采用加锁或消息队列，采用单线程的方式，防止失效时大量线程请求数据库。</li>
<li>在设置缓存时间的时候，在原来缓存时间的技术上加一个比较小的随机值，避免大量缓存在同一时间失效</li>
</ul>
<h2 id="热key问题"><a href="#热key问题" class="headerlink" title="热key问题"></a>热key问题</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>业务层可能因为一些新闻或者热点事件对一个相同的key在短时间内发出大量请求。如果此时没有命中缓存，就需要构建缓存，但是构建缓存需要时间，在这个时间里面所有对key的请求还是会打到下面的数据库上，造成后端和数据库的压力过大。同时热key本身对缓存系统也会带来非常大的压力。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>还是可以用互斥锁进行解决，确保同一时间只有一个线程查询数据库</li>
<li>对于大量请求打到Redis上的解决可以采用在本地构建local cache的方法</li>
</ul>
<h2 id="大key问题"><a href="#大key问题" class="headerlink" title="大key问题"></a>大key问题</h2><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><p>Redis作为缓存通常是以接口为单位进行存储，也就是说Redis中存储的数据就是接口中返回的东西。</p>
<p>这样能够使得每次请求只有一个原子操作，但是带来的问题就是key会非常大，造成了大key存储的问题。这会导致用这个Redis作为缓存的服务非常不稳定，因为单次请求这个key的读写时间过长数据过多导致后面redis的原子操作可能发生I/O超时，从而导致redis实例命中率波动较大。当缓存命中率比较低的时候，瞬间大量数据请求就会打到数据库，导致带宽不足、数据库压力过大、数据库慢查询过多和平均查询时间变长。</p>
<p>因为我们服务的时间=redis超时时间+数据库慢查询时间+接口逻辑时间，所以大key可能大致整个服务的恶性循环。</p>
<h3 id="优化方案-2"><a href="#优化方案-2" class="headerlink" title="优化方案"></a>优化方案</h3><p>可以采用将存储单位从接口数据变为原子数据。每个接口数据都是由原子数据拼接而成，这个拼接可以在业务层完成。从而减小Redis请求超时的情况。</p>
<h2 id="批量请求问题"><a href="#批量请求问题" class="headerlink" title="批量请求问题"></a>批量请求问题</h2><h3 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h3><p>接着上面的问题，当把存储单位从接口数据变成了原子数据以后，势必会造成每个接口的请求数据变多。如果这些请求都通过单个连接去处理，就会造成总体的处理事件过长的问题</p>
<h3 id="优化方案-3"><a href="#优化方案-3" class="headerlink" title="优化方案"></a>优化方案</h3><p>这个时候可以使用到批量请求的相关接口：批量存取字符串类型的方式分别为mget、mset、pipeline。三者都会将多次操作合并到一次，也就是进行以此连接返回所有数据。但是之间的差异还是比较明显的，比如：</p>
<ul>
<li>pipeline：可以支持多个不同类型的操作在一次请求中，但是使用pipeline需要客户端和服务端都支持。当某个命令的执行需要依赖前一个命令的返回结果时，无法使用pipeline。</li>
<li>mget：只支持get请求，megt过大的时候会导致内存暴涨，然后一直持有不释放</li>
<li>mset：只支持set请求，且不支持设置过期时间</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/mayfla/article/details/80112241" target="_blank" rel="external">https://blog.csdn.net/mayfla/article/details/80112241</a></li>
<li><a href="https://www.cnblogs.com/rjzheng/p/9096228.html" target="_blank" rel="external">https://www.cnblogs.com/rjzheng/p/9096228.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git 闯关游戏——githug]]></title>
      <url>/2018/08/08/Git-%E9%97%AF%E5%85%B3%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94githug/</url>
      <content type="html"><![CDATA[<p>学习Git过程中缺乏实践？不如来玩一玩这款Git闯关游戏，通过git命令来闯关。玩着玩着就学会了Git，美滋滋！</p>
<a id="more"></a>
<h2 id="githug"><a href="#githug" class="headerlink" title="githug"></a>githug</h2><p>githug 是用Ruby开发为了帮助学习使用git的一个闯关游戏。和我之前推荐的学习Linux命令的<a href="https://www.liuin.cn/2017/11/01/Bandit-%E9%80%9A%E5%85%B3%E9%A2%98%E8%A7%A3/">Bandit</a>游戏有点像。</p>
<p>其Github地址：<a href="https://github.com/Gazler/githug" target="_blank" rel="external">https://github.com/Gazler/githug</a></p>
<p>安装过程也比较简单，首先安装好基本的Ruby环境（1.8.7）以上</p>
<p>因为国内可能会遇到用gem安装相关包因为https网络问题报错的情况，如果出现<code>Unable to download data from https://rubygems.org/</code>这样的报错信息</p>
<p>可以通过如下方式解决<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo gem sources -r https://rubygems.org</div><div class="line">sudo gem sources <span class="_">-a</span> http://rubygems.org</div></pre></td></tr></table></figure></p>
<p>当然安装完以后也别忘了设置回来<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo gem sources -r http://rubygems.org</div><div class="line">sudo gem sources <span class="_">-a</span> https://rubygems.org</div></pre></td></tr></table></figure></p>
<p>然后进行安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install githug</div></pre></td></tr></table></figure></p>
<p>安装完成以后运行<code>githug</code>会提示创建相关的文件夹，回复<code>y</code>就行了。</p>
<p>githug有4个基本命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">play - 默认命令，查看当前状态和题目</div><div class="line">hint - 给你当前level的一些提示</div><div class="line">reset - 重新开始当前关卡</div><div class="line">levels - 列出所有关卡</div></pre></td></tr></table></figure></p>
<h2 id="通过题解"><a href="#通过题解" class="headerlink" title="通过题解"></a>通过题解</h2><p>有一些关卡比较简单，选取一些我觉得有点意思的关卡给出题解吧。</p>
<h3 id="20-commit-in-futue"><a href="#20-commit-in-futue" class="headerlink" title="20 commit_in_futue"></a>20 commit_in_futue</h3><p>使用一个未来的时间作为提交，提交的时候指定–date选项，能够自定义提交的时间</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git commit -m <span class="string">"future commit"</span> --date=12.12.2018T22:00:00</div><div class="line"></div><div class="line">[master (root-commit) 2f27bee] future commit</div><div class="line"> Date: Wed Dec 12 22:00:00 2018 +0800</div><div class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</div><div class="line"> create mode 100644 README</div></pre></td></tr></table></figure>
<h3 id="21-reset"><a href="#21-reset" class="headerlink" title="21 reset"></a>21 reset</h3><p>git reset 常用来进行版本回推。要了解<code>reset</code>命令首先要了解git中的三棵树：<br><code>HEAD</code>：是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。<br><code>暂存区（Index）</code>：预期的下一次提交<br><code>工作区</code>：git 实际管理的文件的目录</p>
<p><img src="http://data3.liuin.cn/2018-09-16-15371061297360.jpg" alt=""></p>
<p><code>reset</code> 命令以一种简单可预见的方式直接操纵三棵树，它做了三个基本操作：移动 HAED，重置索引，重置工作目录。实际上 reset 是以特定的顺序来重写三棵树，并在指定相应选项时停止：</p>
<ol>
<li>移动 HEAD 分支的指向 （若指定了 –soft，则到此停止）</li>
<li>使索引看起来像 HEAD （–mixed，默认到此停止）</li>
<li>使工作目录看起来像索引 （若指定了 –hard，则进行这一步）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset to_commit_second.rb</div></pre></td></tr></table></figure>
<h3 id="22-reset-soft"><a href="#22-reset-soft" class="headerlink" title="22 reset_soft"></a>22 reset_soft</h3><p>使用 reset 命令的 –soft 选项</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --soft HEAD~</div></pre></td></tr></table></figure>
<h3 id="23-checkout-file"><a href="#23-checkout-file" class="headerlink" title="23 checkout_file"></a>23 checkout_file</h3><p>checkout 作用于文件的时候，会将文件从当前HEAD中检出，即让当前工作区的文件变成HEAD中的样子，命令格式为<code>git checkout [-q] [&lt;commit&gt;] [--] &lt;paths&gt;...</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout config.rb</div></pre></td></tr></table></figure>
<h3 id="30-blame"><a href="#30-blame" class="headerlink" title="30 blame"></a>30 blame</h3><p>可以通过 <code>git blame</code> 命令查看项目中具体哪一行代码是谁写的，什么时候引入的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git blame config.rb</div></pre></td></tr></table></figure>
<h3 id="33-checkout-tag"><a href="#33-checkout-tag" class="headerlink" title="33 checkout_tag"></a>33 checkout_tag</h3><p>检出到指定标签，通过<code>checkout</code>命令实现，能够创建一个临时分支指向tag所在的提交</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout v1.2</div></pre></td></tr></table></figure>
<h3 id="34-checkout-tag-over-branch"><a href="#34-checkout-tag-over-branch" class="headerlink" title="34 checkout_tag_over_branch"></a>34 checkout_tag_over_branch</h3><p>有的时候会遇到标签和分支的名字一样的情况，通过在前面添加前缀<code>tags/</code>来指定是tag的名字</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout tags/v1.2</div></pre></td></tr></table></figure>
<h3 id="35-branch-at"><a href="#35-branch-at" class="headerlink" title="35 branch_at"></a>35 branch_at</h3><p>检出指定提交到一个新的命名分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b test_branch HEAD~</div></pre></td></tr></table></figure>
<h3 id="40-rebase"><a href="#40-rebase" class="headerlink" title="40 rebase"></a>40 rebase</h3><p>rebase命令可以用来整合来自不同分支</p>
<p><img src="http://data3.liuin.cn/2018-09-17-15371452668045.jpg" alt=""></p>
<p>如上图所示，提取在 C4 中引入的补丁和修改，然后在 C3 的基础上再应用一次。在 Git 中，这种操作就叫做 变基</p>
<p><code>git rebase [&lt;upstream&gt; [&lt;branch&gt;]</code> 命令将upstream的修改在branch上再应用一次</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout feature</div><div class="line">git rebase master</div></pre></td></tr></table></figure>
<h3 id="41-rebase-onto"><a href="#41-rebase-onto" class="headerlink" title="41 rebase-onto"></a>41 rebase-onto</h3><p>在对两个分支进行变基时，所生成的“重演”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。就像 从一个特性分支里再分出一个特性分支的提交历史 中的例子这样。</p>
<p><code>$ git rebase --onto master server client</code></p>
<p>以上命令的意思是：“取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然后把它们在 master 分支上重演一遍”。</p>
<p>当master 和server 一致的时候，只需要写一个</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rebase --onto master wrong_branch</div></pre></td></tr></table></figure>
<h3 id="42-repack"><a href="#42-repack" class="headerlink" title="42 repack"></a>42 repack</h3><p>git repack 对松散对象进行打包，凡是有引用关联的对象都被打在包里，未被关联的对象仍旧以松散对象的形式保存</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git repack</div></pre></td></tr></table></figure>
<h3 id="43-cherry-pick"><a href="#43-cherry-pick" class="headerlink" title="43 cherry-pick"></a>43 cherry-pick</h3><p>应用某一个提交的修改到当前分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git checkout new-feature</div><div class="line">git <span class="built_in">log</span></div><div class="line">git cherry-pick ca32a6dac7b6f97975edbe19a4296c2ee7682f68</div></pre></td></tr></table></figure>
<h3 id="45-rename-commit"><a href="#45-rename-commit" class="headerlink" title="45 rename commit"></a>45 rename commit</h3><p>当涉及提交修改时，应该想到 <code>git rebase -i</code> 命令，它接受可以一个参数（提交的哈希值），它将罗列出此提交之后的所有提交，将此提交作为一个root commit。用途为修改提交历史，其后跟一个某一条提交日志的哈希值，表示要修改这条日志之前的提交历史。</p>
<p>输入命令以后，会将提交从前到后显示。每一行的前面有一个命令词，表示对此次更新执行什么操作。</p>
<p>类似下面这种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pick 06973a3 First coommit</div><div class="line">pick 771b71d Second commit</div></pre></td></tr></table></figure>
<p>前面的命令有以下几种：</p>
<ul>
<li>“pick”，表示执行此次提交；</li>
<li>“reword”，表示执行此次提交，但要修改备注内容；</li>
<li>“edit”，表示可以修改此次提交，比如再追加文件或修改文件；</li>
<li>“squash”，表示把此次提交的内容合并到上次提交中，备注内容也合并到上次提交中；</li>
<li>“fixup”，和 “squash” 类似，但会丢弃掉此次备注内容；</li>
<li>“exec”，执行命令行下的命令；</li>
<li>“drop”，删除此次提交。</li>
</ul>
<p>这一关是需要把第2次提交错误额comment修改过来，所以对第二次提交执行reword并修改备注就行了</p>
<h3 id="46-squash"><a href="#46-squash" class="headerlink" title="46 squash"></a>46 squash</h3><p>把多次修改合并成一次，这里用到的还是上面的<code>git rebase -i</code>的命令，只不过是将后面动作命令都变成<code>squash</code></p>
<h3 id="47-merge-squash"><a href="#47-merge-squash" class="headerlink" title="47 merge_squash"></a>47 merge_squash</h3><p>为了把分支的多次提交合并为主干上的一次提交，可以在merge命令后面加一个 squash 参数</p>
<p><code>git merge branch-name --squash</code></p>
<p>过关命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git merge long-feature-branch --squash</div><div class="line">git commit -m <span class="string">"comment"</span></div></pre></td></tr></table></figure></p>
<h3 id="48-reorder"><a href="#48-reorder" class="headerlink" title="48 reorder"></a>48 reorder</h3><p>你提交了几次但是提交顺序多了，想把顺序换一下，这里用到的还是<code>git rebase -i</code>命令。需要把几次提交的顺序更换一下即可。</p>
<h3 id="49-bisect"><a href="#49-bisect" class="headerlink" title="49 bisect"></a>49 bisect</h3><p>在程序持续迭代的过程中不免会引入 bug，除了定位 bug 的代码片断，我们还想知道 bug 是在什么时间被引入的，这时就可以<strong>借助 Git 提供的 bisect 工具来查找是哪次提交引入了 bug</strong>。bisect 是用二分法来查找的，就像用二分查找法查找数组元素那样。</p>
<p>其查找流程也比较简单，首先确定查找的commit范围，然后在每一次二分查找时给出程序执行是否正确的判断。这个时候bisect就会自动进行二分查找。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git bisect start</div><div class="line">$ git bisect good f608824888b</div><div class="line">$ git bisect bad 12628f463f4</div><div class="line">$ make <span class="built_in">test</span></div><div class="line">$ git bisect good</div><div class="line">...</div></pre></td></tr></table></figure>
<h3 id="50-stage-lines"><a href="#50-stage-lines" class="headerlink" title="50 stage_lines"></a>50 stage_lines</h3><p>用 <code>git add</code> 命令可以把文件添加到暂存区，但如果你不想把文件中的全部修改都提交到暂存区，或者说你只想把文件中的部分修改提交到缓存区，那么你需要加上<code>edit</code>参数</p>
<p>这时 Git 会自动打开文本编辑器，编辑的内容就是 <code>git diff</code> 命令的结果，这时你就可以编辑2个文件之间的差异，只保留要提交到暂存区的差异，而删除不需要提交到暂存区的差异，然后保存退出，Git 就会按你编辑过的差异把相应的内容提交到暂存区。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add file-name --edit</div></pre></td></tr></table></figure>
<h3 id="51-find-old-branch"><a href="#51-find-old-branch" class="headerlink" title="51 find_old_branch"></a>51 find_old_branch</h3><p>使用<code>git reflog</code> 可以查看历史所在的分支和提交在哪里</p>
<h3 id="52-revert"><a href="#52-revert" class="headerlink" title="52 revert"></a>52 revert</h3><p><code>git revert</code> 命令能够对某一次提交执行逆操作，这适用于某次提交出现问题的情况，添加<code>--no-edit</code>能够让系统自动生成备注</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">log</span></div><div class="line">git revert 3873913 --no-edit</div></pre></td></tr></table></figure>
<h3 id="55-submodule"><a href="#55-submodule" class="headerlink" title="55 submodule"></a>55 submodule</h3><p>如果你想把别人的仓库代码作为自己项目一个库来使用，可以采用模块化的思路，把这个库作为模块进行管理。Git 专门提供了相应的工具，用如下命令把第三方仓库作为模块引入：</p>
<p><code>git submodule add module-url</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git submodule add https://github.com/jackmaney/githug-include-me</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/githug-walkthrough/</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 软件使用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法总结——二分法]]></title>
      <url>/2018/08/05/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>汇集二分法常见的题目</p>
<a id="more"></a>
<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>二分法是一个非常常用的算法技巧，用于在多条排序记录中快速找到待查找的记录。相比遍历需要O(n)将时间复杂度优化到了O(logn)，但是需要一组序列本身是有序的。</p>
<p>写二分代码的关键在于<strong>处理好其边界情况</strong></p>
<p>下面是一个标准的二分代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> n, <span class="keyword">int</span> v)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> left, right, middle;</div><div class="line">    <span class="comment">// 赋初值，判断是左闭右闭还是左闭右开</span></div><div class="line">    left = <span class="number">0</span>, right = n - <span class="number">1</span>;</div><div class="line">    <span class="comment">// 退出条件，有小于和小于等于两种写法</span></div><div class="line">    <span class="keyword">while</span> (left &lt;= right)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 中值计算，有向下取整和向上取整</span></div><div class="line">        middle = (left + right) / <span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[middle] &gt; v)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 边界值更新，判断是否需要加一</span></div><div class="line">            right = middle;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[middle] &lt; v)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 边界值更新，判断是否需要加一</span></div><div class="line">            left = middle;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> middle;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正如上面的注释中所示，写好一个二分算法只需要注意这4个地方：</p>
<ol>
<li>赋初值，判断是左闭右闭还是左闭右开</li>
<li>退出条件，有小于和小于等于两种写法，小于等于对应的是上面“右闭”的情况，因为最后一个可能是要查找的值</li>
<li>中值计算，有向下取整和向上取整两种方案</li>
<li>边界值更新，加一或者不变，根据实际情况进行判断（一般是判断是否需要舍弃这一个值）</li>
</ol>
<h3 id="左右边界的开闭"><a href="#左右边界的开闭" class="headerlink" title="左右边界的开闭"></a>左右边界的开闭</h3><p>左闭右闭还是左闭右开应该对应不同的写法，主要的区别在于最后一个值的舍弃问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 左闭右闭 [0, n-1] 写法</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">search2</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> n, <span class="keyword">int</span> v)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> left, right, middle;</div><div class="line"></div><div class="line">    left = <span class="number">0</span>, right = n - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (left &lt;= right)</div><div class="line">    &#123;</div><div class="line">        middle = (left + right) / <span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[middle] &gt; v)</div><div class="line">        &#123;</div><div class="line">            right = middle - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[middle] &lt; v)</div><div class="line">        &#123;</div><div class="line">            left = middle + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> middle;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 左闭右开 [0, n) 写法</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">search3</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> n, <span class="keyword">int</span> v)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> left, right, middle;</div><div class="line"></div><div class="line">    left = <span class="number">0</span>, right = n;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (left &lt; right)</div><div class="line">    &#123;</div><div class="line">        middle = (left + right) / <span class="number">2</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[middle] &gt; v)</div><div class="line">        &#123;</div><div class="line">            right = middle;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[middle] &lt; v)</div><div class="line">        &#123;</div><div class="line">            left = middle + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> middle;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h3><p>一般如果向下取整和左边界更新不加一组合就可能造成死循环，同理向上取整和右边界不减一组合也可能造成死循环</p>
<h3 id="溢出问题"><a href="#溢出问题" class="headerlink" title="溢出问题"></a>溢出问题</h3><p>在一些比较特殊的情况下<code>middle = (left + right) / 2</code>这种写法可能造成溢出问题，更加保险的写法是<code>middle = left + (right - left) / 2;</code></p>
<h3 id="比较完善的写法"><a href="#比较完善的写法" class="headerlink" title="比较完善的写法"></a>比较完善的写法</h3><p>《编程珠玑》中提供了一个给出了比较完成的二分法代码写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">search4</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> n, <span class="keyword">int</span> v)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> left, right, middle;</div><div class="line">    left = <span class="number">-1</span>, right = n;</div><div class="line">    <span class="keyword">while</span> (left + <span class="number">1</span> != right)</div><div class="line">    &#123;</div><div class="line">        middle = left + （right － left) / <span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[middle] &lt; v)</div><div class="line">        &#123;</div><div class="line">            left = middle;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            right = middle;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (right &gt;= n || <span class="built_in">array</span>[right] != v)</div><div class="line">        right = <span class="number">-1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> right;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2018春招腾讯笔试题"><a href="#2018春招腾讯笔试题" class="headerlink" title="2018春招腾讯笔试题"></a>2018春招腾讯笔试题</h2><p><a href="https://www.nowcoder.com/questionTerminal/d732267e73ce4918b61d9e3d0ddd9182" target="_blank" rel="external">试题地址</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>小Q的父母要出差N天，走之前给小Q留下了M块巧克力。小Q决定每天吃的巧克力数量不少于前一天吃的一半，但是他又不想在父母回来之前的某一天没有巧克力吃，请问他第一天最多能吃多少块巧克力 </p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>可以构造出理想的情况应该是：前面是一个数开始，然后不断除2（向上取整），直到变为1，最后一直持续1。这样把这个序列分为两段：前面类似等比序列，后面都是1</p>
<p>这样我们知道序列的第一个数就知道了以这个数开头的序列总和最少是多少（按照上面的规则计算），这样我们可以从<code>m-n+1</code>开始一直往<code>1</code>当做第一个数遍历，找到第一个满足最小总和少于m的数。便能够得到答案。</p>
<p>这种情况和二分法的常见题型是不是很像，找到第一个满足某种情况的数，而且这个序列还是一个单调序列。用一个二分法加速</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> p)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(p--)</div><div class="line">    &#123;</div><div class="line">        sum += n;</div><div class="line">        n = (n+<span class="number">1</span>)/<span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n, m;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</div><div class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = m-n+<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(l&lt;r)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> tem = (l+r+<span class="number">1</span>)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(sum(tem, n) &lt;= m)</div><div class="line">            l = tem;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            r = tem - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="POJ-3258"><a href="#POJ-3258" class="headerlink" title="POJ 3258"></a>POJ 3258</h2><p><a href="http://poj.org/problem?id=3258" target="_blank" rel="external">River Hopscotch</a></p>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出一条河对岸中n个石子的坐标（加上起点和终点），现在移走m个石子，要求两个石子间的最小值最大，这个最大的最小值</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这个一道经典的二分题目，最大化最小值问题。在查找过程中判断一个数是否满足条件的时候，我们可以转化成判断满足这个最小值需要移走的石子数，通过跟给定的石子数进行比较来判断这个数是否满足条件，最后通过二分找到这个最大的值。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50005</span>;</div><div class="line"><span class="keyword">int</span> l,n,m;</div><div class="line"><span class="keyword">int</span> d[maxn];</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> s)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> j=<span class="number">0</span>,num=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(d[i]-d[j]&lt;s) num++;</div><div class="line">		<span class="keyword">else</span> j=i;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//cout&lt;&lt;"s:"&lt;&lt;s&lt;&lt;"num:"&lt;&lt;num&lt;&lt;"m:"&lt;&lt;m&lt;&lt;endl;</span></div><div class="line">	<span class="keyword">return</span> num&lt;=m;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> ll=<span class="number">0</span>,rr=l+<span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span> mid;</div><div class="line">	<span class="keyword">while</span>(ll+<span class="number">1</span>&lt;rr)</div><div class="line">	&#123;</div><div class="line">		mid=(ll+rr)&gt;&gt;<span class="number">1</span>;</div><div class="line">		<span class="comment">//cout&lt;&lt;ll&lt;&lt;" "&lt;&lt;rr&lt;&lt;" "&lt;&lt;mid&lt;&lt;endl;</span></div><div class="line">		<span class="keyword">if</span>(judge(mid))</div><div class="line">			ll=mid;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			rr=mid;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ll;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;l,&amp;n,&amp;m)!=EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;d[i]);</div><div class="line">        d[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line">		d[n+<span class="number">1</span>]=l;</div><div class="line">		n+=<span class="number">2</span>;</div><div class="line">		sort(d,d+n);</div><div class="line">		<span class="keyword">int</span> ans=fun();</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="POJ-3273"><a href="#POJ-3273" class="headerlink" title="POJ 3273"></a>POJ 3273</h2><p><a href="http://poj.org/problem?id=3273" target="_blank" rel="external">Monthly Expense</a></p>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出包含n个元素的数组，将这n个元素分成最多m段，问各种分法中每段和的最大值得最小值是多少</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>最小化最大值问题，使用二分进行求解，需要注意的是，在不断二分的时候边界更新的时候，当中间值不满足条件的时候，新的区间应该是[mid+1,r]，满足条件的时候新的区间应该是[l,mic].即要排除掉不满足条件的数</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</div><div class="line"><span class="keyword">int</span> n,m;</div><div class="line"><span class="keyword">int</span> d[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> s)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> num=<span class="number">0</span>,tmp=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(tmp+d[i]&lt;=s) tmp+=d[i];</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            tmp=d[i];</div><div class="line">            num++;</div><div class="line">        &#125;   </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(tmp) num++;</div><div class="line">    <span class="keyword">return</span> num&lt;=m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> maxv,<span class="keyword">int</span> sum)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> l=maxv,r=sum,mid;</div><div class="line">    <span class="keyword">while</span>(l&lt;r)</div><div class="line">    &#123;</div><div class="line">        mid=(l+r)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(judge(mid)) r=mid;</div><div class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> l;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(“%d %d”,&amp;n,&amp;m)!=EOF)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>,maxv=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(“%d”,&amp;d[i]);</div><div class="line">            sum+=d[i];</div><div class="line">            maxv=max(maxv,d[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(“%d\n”,fun(maxv,sum));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 算法总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode——单调数据结构]]></title>
      <url>/2018/07/27/LeetCode%E2%80%94%E2%80%94%E5%8D%95%E8%B0%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>总结在LeetCode中遇到的单调栈的一系列题目</p>
<a id="more"></a>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>单调栈是这样的一种数据结构：栈中从栈底到栈顶的数都是递减的，为了维护这种结构在插入比当前栈顶大的数的时候都需要先将栈顶的数弹出，这样我们就能够知道弹出的这个数两边比它大的数了。在某些题目中，单调栈的这种特定能够给我们提供很大的帮助。</p>
<h3 id="LeetCode-84"><a href="#LeetCode-84" class="headerlink" title="LeetCode 84"></a>LeetCode 84</h3><p><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/description/" target="_blank" rel="external">Largest Rectangle in Histogram</a></p>
<p>题意：<br>给出一个直方图，求直方图中所能够围成矩形的最大面积<br><img src="http://data3.liuin.cn/2018-09-08-15364073032884.jpg" alt=""></p>
<p>题解：<br>维护一个递增的单调栈，如果需要将栈顶数据弹出则表示形成了山峰的形状，这样我们就可以计算出这个山峰里能够围成的矩形的面积，因为弹出的这一个数能够知道其左右比它小的数。当遍历完以后还有一些矩形需要计算，再将这个栈依次弹出，这个时候右边没有比它小的数了，他左边比它小的数就是栈顶的数。每弹出一个数就能够计算出一个矩形的面积。</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// 维护单调栈</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = heights.size();</div><div class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; heights[s.top()] &gt; heights[i])</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> tem = s.top();</div><div class="line">                s.pop();</div><div class="line">                <span class="comment">// 计算面积</span></div><div class="line">                <span class="keyword">int</span> curArea = s.empty() ? i*heights[tem] : (i - s.top() - <span class="number">1</span>)*heights[tem];</div><div class="line">                res = max(res, curArea);</div><div class="line">            &#125;</div><div class="line">            s.push(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(!s.empty())</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> tem = s.top();</div><div class="line">            s.pop();</div><div class="line">            <span class="keyword">int</span> curArea = s.empty() ? len*heights[tem] : (len - s.top() - <span class="number">1</span>) * heights[tem];</div><div class="line">            res = max(res, curArea);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="LeetCode-85"><a href="#LeetCode-85" class="headerlink" title="LeetCode 85"></a>LeetCode 85</h3><p><a href="https://leetcode.com/problems/maximal-rectangle/description/" target="_blank" rel="external">Maximal Rectangle</a></p>
<p>题意：<br>给出一个只包含0和1的二维矩阵，求出其中1围成的矩形的最大面积</p>
<p>题解：<br>这道题可以说是上面那道题的变形，因为把这个n*m的矩阵转换成m个直方图就是上面的那道题，计算m次即可</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getSlice(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> h)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</div><div class="line">        <span class="keyword">int</span> len = matrix[<span class="number">0</span>].size();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> tem = h, count = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span>(tem &gt;= <span class="number">0</span> &amp;&amp; matrix[tem][i] == <span class="string">'1'</span>)</div><div class="line">            &#123;</div><div class="line">                tem --;</div><div class="line">                count ++;</div><div class="line">            &#125;</div><div class="line">            ret.push_back(count);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len1 = matrix.size();</div><div class="line">        <span class="keyword">if</span>(len1 == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> len2 = matrix[<span class="number">0</span>].size();</div><div class="line">        <span class="keyword">if</span>(len2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; len1; t++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heights = getSlice(matrix, t);</div><div class="line">            <span class="keyword">int</span> len3 = heights.size();</div><div class="line">            <span class="comment">// 使用栈来保存一个递增的序列</span></div><div class="line">            <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</div><div class="line">            <span class="keyword">int</span> tem_res = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len3; i++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">while</span>(!s.empty() &amp;&amp; heights[s.top()] &gt; heights[i])</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">int</span> tem = s.top();</div><div class="line">                    s.pop();</div><div class="line">                    <span class="comment">// 计算不在序列内的区块的面积</span></div><div class="line">                    <span class="keyword">int</span> curArea = s.empty() ? i*heights[tem] : (i - s.top() - <span class="number">1</span>)*heights[tem];</div><div class="line">                    tem_res = max(tem_res, curArea);</div><div class="line">                    <span class="comment">// cout&lt;&lt;i&lt;&lt;" "&lt;&lt;tem_res&lt;&lt;endl;</span></div><div class="line">                &#125;</div><div class="line">                s.push(i);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 对递增序列中的序列面积进行计算</span></div><div class="line">            <span class="keyword">while</span>(!s.empty())</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> tem = s.top();</div><div class="line">                s.pop();</div><div class="line">                <span class="keyword">int</span> curArea = s.empty() ? len3*heights[tem] : (len3 - s.top() - <span class="number">1</span>) * heights[tem];</div><div class="line">                tem_res = max(tem_res, curArea);</div><div class="line">                <span class="comment">// cout&lt;&lt;tem&lt;&lt;" "&lt;&lt;tem_res&lt;&lt;endl;</span></div><div class="line">            &#125;</div><div class="line">            res = max(res, tem_res);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="LeetCode-456"><a href="#LeetCode-456" class="headerlink" title="LeetCode 456"></a>LeetCode 456</h3><p><a href="https://leetcode.com/problems/132-pattern/description/" target="_blank" rel="external">132 Pattern</a></p>
<p>题意：</p>
<p>给出一个数组，判断是否存在这样的三个数：i &lt; j &lt; k，同时a[i] &lt; a[k] &lt; a[j] 类似于132的组合</p>
<p>题解：<br>从后往前去维护一个递减的单调栈，同时记录淘汰掉的数的最大值s3（这里相当于a[k]），从后往前遍历的过程中如果有数比s3要小，则表明存在上述的结构</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// 单调栈结构巧妙解法</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</div><div class="line">        <span class="keyword">int</span> len = nums.size();</div><div class="line">        <span class="keyword">if</span> (len &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">int</span> s3 = INT_MIN;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(nums[i] &lt; s3) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; nums[i] &gt; s.top())</div><div class="line">            &#123;</div><div class="line">                s3 = max(s3, s.top());</div><div class="line">                s.pop();</div><div class="line">            &#125;</div><div class="line">            s.push(nums[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>单调队列能够维护一个滑动窗口的最大值或者最小值</p>
<p>一般队列中存放的是数组中的index。以最大值为例，队列加数时：判断最后一个数是不是小于等于当前数，如果如果是就弹出最后这个数，不断重复直到无法弹出最后那个数后加当前数加入队尾，使得这个队列中是单调的。队列减数：通过index的差值判断在不在窗口内，通过差值计算是否值是否过期。</p>
<h3 id="LeetCode-239"><a href="#LeetCode-239" class="headerlink" title="LeetCode 239"></a>LeetCode 239</h3><p><a href="https://leetcode.com/problems/sliding-window-maximum/description/" target="_blank" rel="external">题目链接</a></p>
<p>典型的滑动窗口内的最大值问题，这里要求每一个滑动窗口的最大值并加入到一个动态数组中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// 单调队列数据结构</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</div><div class="line">        <span class="keyword">int</span> len = nums.size(), l = <span class="number">0</span>, r = <span class="number">0</span>;</div><div class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; de;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        <span class="keyword">for</span>(; r &lt; len; r++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">while</span>(!de.empty() &amp;&amp; nums[r] &gt;= nums[de.back()])</div><div class="line">                de.pop_back();</div><div class="line">            de.push_back(r);</div><div class="line">            <span class="keyword">if</span>(r &gt;= k<span class="number">-1</span>)</div><div class="line">            &#123;</div><div class="line">                res.push_back(nums[de.front()]);</div><div class="line">                <span class="keyword">if</span>(de.front() &lt;= l)</div><div class="line">                    de.pop_front();</div><div class="line">                l++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis 代理方案 Twemproxy]]></title>
      <url>/2018/07/20/Redis-%E4%BB%A3%E7%90%86%E6%96%B9%E6%A1%88-Twemproxy/</url>
      <content type="html"><![CDATA[<p>谈谈在各大公司广泛使用的Redis代理方案——Twemproxy</p>
<a id="more"></a>
<p>Redis现在使用得非常广泛，但是Redis单例比较大的局限——单例使用到的内存一般最多10~20GB。这无法支撑大型线上业务系统的需求。而且也会造成资源的利用率过低——现在企业使用的内存肯定是Redis单例使用到内存的好几倍。</p>
<p>为了解决单机承载能力不足的问题，就必然会使用到多个Redis构成的集群。</p>
<h2 id="Redis-集群技术"><a href="#Redis-集群技术" class="headerlink" title="Redis 集群技术"></a>Redis 集群技术</h2><h3 id="客户端分片"><a href="#客户端分片" class="headerlink" title="客户端分片"></a>客户端分片</h3><p>客户端分片将分片工作放到了业务层，程序代码根据预先设置的路由规则，直接对多个Redis实例进行分布式访问。</p>
<p>这样的好处是，不依赖于第三方分布式中间件，实现方法和代码都自己掌控，可随时调整，不用担心踩到坑；同时，这种分片机制的性能比代理式更好（少了一个中间分发环节）。</p>
<p>但是缺点也比较多：首先这是一种静态分片技术。Redis实例的增减，都得手工调整分片程序，其次，虽然少了中间分发环节，但是导致升级麻烦，对研发人员的个人依赖性强——需要有较强的程序开发能力做后盾。</p>
<p>所以，这种方式下，可运维性较差。出现故障，定位和解决都得研发和运维配合着解决，故障时间变长。</p>
<h3 id="代理分片"><a href="#代理分片" class="headerlink" title="代理分片"></a>代理分片</h3><p>代理分片将分片工作交给专门的代理程序来做。代理程序接收到来自业务程序的数据请求，根据路由规则，将这些请求分发给正确的Redis实例并返回给业务程序。因此<strong>整个代理对业务层是透明的</strong>，业务层只需要把这个一个单纯的Redis实例使用即可。同时因为Redis请求都打到了代理上，我们很容易在代理的基础上进行进一步的分析工作。</p>
<p>虽然会因此带来些性能损耗，但对于Redis这种内存读写型应用，相对而言是能容忍的。</p>
<p>基于该机制的开源产品Twemproxy，便是其中代表之一，应用非常广泛。</p>
<p><img src="http://data3.liuin.cn/2018-09-08-15363953307171.jpg" alt=""></p>
<h3 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h3><p>在这种机制下，没有中心节点（和代理模式的重要不同之处）。</p>
<p>这样的好处是，Redis Cluster将所有Key映射到16384个Slot中，集群中每个Redis实例负责一部分，业务程序通过集成的Redis Cluster客户端进行操作。客户端可以向任一实例发出请求，如果所需数据不在该实例中，则该实例引导客户端自动去对应实例读写数据。</p>
<p>但是缺点也是同样存在，这是一个非常重的方案，Redis Cluster的成员管理（节点名称、IP、端口、状态、角色）等，都通过节点之间两两通讯，定期交换并更新。缺少了Redis单例的“简单、可依赖”的特点</p>
<h2 id="Twemproxy"><a href="#Twemproxy" class="headerlink" title="Twemproxy"></a>Twemproxy</h2><p>Twemproxy是上面代理分片构造Redis集群的一个开源解决方案。</p>
<p>TwemProxy采用中间层代理的方式，在不改动服务器端程序的情况下，使得集群管理更简单、轻量和有效。Twemproxy 通过引入一个代理层，将其后端的多台 Redis实例进行统一管理与分配，使应用程序只需要在Twemproxy 上进行操作，而不用关心后面具体有多少个真实的 Redis实例。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>单线程工作，用C语言开发</li>
<li>直接支持大部分Redis指令，所以对于业务层可以透明使用</li>
<li>路由策略多样，支持HashTag, 通过HashTag可以自己设定将同一类型的key映射到同一个实例上去</li>
<li>减少与redis的直接连接数，保持与redis的长连接，可设置代理与后台每个redis连接的数目</li>
<li>自带一致性hash算法，能够将数据自动分片到后端多个redis实例上</li>
<li>支持redis pipelining request，将多个连接请求，组成reids pipelining统一向redis请求。</li>
<li>高效；对连接的管理采用epoll机制，内部数据传输采用“Zero Copy”技术，以提高运行效率</li>
</ul>
<h3 id="高可用方案"><a href="#高可用方案" class="headerlink" title="高可用方案"></a>高可用方案</h3><p>因为Twemproxy本身是单点，所以需要用Keepalived做高可用方案。</p>
<p>Keepalived是一种实现高可用的方案，它的功能主要包括两方面：<br>1）通过IP漂移，实现服务的高可用：服务器集群共享一个虚拟IP，同一时间只有一个服务器占有虚拟IP并对外提供服务，若该服务器不可用，则虚拟IP漂移至另一台服务器并对外提供服务；<br>2）对LVS应用服务层的应用服务器集群进行状态监控：若应用服务器不可用，则keepalived将其从集群中摘除，若应用服务器恢复，则keepalived将其重新加入集群中。</p>
<p><img src="http://data3.liuin.cn/2018-09-08-15363965065269.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode总结——和为定值]]></title>
      <url>/2018/07/16/LeetCode%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%92%8C%E4%B8%BA%E5%AE%9A%E5%80%BC/</url>
      <content type="html"><![CDATA[<p>总结在LeetCode中遇到的和为定值的一系列题目</p>
<a id="more"></a>
<p>在数组中碰到数组和为定值的大致可以分为这两类，一类是这些数不连续，从两个数和为定值到多个数和为定值，最后升级到动态规划的多重部分和问题；另一类是数必须是连续的子数组问题</p>
<h2 id="两个数和为定值"><a href="#两个数和为定值" class="headerlink" title="两个数和为定值"></a>两个数和为定值</h2><p>这类题应该是最常见的题型了，常见的有两种方法：</p>
<ol>
<li>Hash，对每个a[i]，通过hash表快速判断出target-a[i]是否在数列中，这种方法不管数组是有序的还是无序的时间复杂度都是O(n)</li>
<li>双指针，用两个指针i，j分别指向数组的两端，依次判断<code>a[i] + a[j]</code>与target的大小情况，大于target则j–，小于target则i++，如果数组是有序时间复杂度为O(n)，如果数组不是有序的时间复杂度为O(nlogn)</li>
</ol>
<h3 id="LeetCode-1"><a href="#LeetCode-1" class="headerlink" title="LeetCode 1"></a>LeetCode 1</h3><p>题意</p>
<p>给定有序的一个数组，求其中两个数的和刚好为定值target，返回这两个数的索引值</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (m.count(target - nums[i])) &#123;</div><div class="line">                <span class="keyword">return</span> &#123;i, m[target - nums[i]]&#125;;</div><div class="line">            &#125;</div><div class="line">            m[nums[i]] = i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> &#123;&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="多个数和为定值"><a href="#多个数和为定值" class="headerlink" title="多个数和为定值"></a>多个数和为定值</h2><p>对于求解数组中m个数的和为定值的问题，枚举最开始的一个数都可以转换为m-1个数和为定值的问题，其最优的时间复杂度为O(n^m)。因为m如果大于2，排序的开销就不算在里面了，所以采用双指针的方法更加简单</p>
<h3 id="LeetCode-3"><a href="#LeetCode-3" class="headerlink" title="LeetCode 3"></a>LeetCode 3</h3><p>题意：</p>
<p>求数组中3个数的和为定值的这个3个数的索引值</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</div><div class="line">        </div><div class="line">        sort(nums.begin(),nums.end());</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> len = nums.size();</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i==<span class="number">0</span> || nums[i]!=nums[i<span class="number">-1</span>]) <span class="comment">// 去重</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>,k=len<span class="number">-1</span>;j&lt;k;)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(nums[i]+nums[j]+nums[k] == <span class="number">0</span>)</div><div class="line">                    &#123;</div><div class="line">                        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = &#123;nums[i],nums[j],nums[k]&#125;;</div><div class="line">                        res.push_back(tmp);</div><div class="line">                        j++;</div><div class="line">                        <span class="keyword">while</span>(j&lt;k &amp;&amp; nums[j]==nums[j<span class="number">-1</span>]) j++;</div><div class="line">                        k=len<span class="number">-1</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(nums[j]+nums[k]+nums[i]&gt;<span class="number">0</span>)</div><div class="line">                    &#123;</div><div class="line">                        k--;</div><div class="line">                        </div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        j++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="多重部分和问题"><a href="#多重部分和问题" class="headerlink" title="多重部分和问题"></a>多重部分和问题</h2><p>进阶可以转换成一个DP的题：有 n 种大小不同的数字 a[i]，每种 m[i] 个，判断是否可以从这些数字中选出若干个使他们的和恰好为 K。<br>设 dp[i+1][j] 为前 i 种数加和为 j 时第 i 种数最多能剩余多少个。（不能得到为-1）</p>
<p>这样状态转移方程为：<br><img src="http://data3.liuin.cn/2018-09-07-15363320821084.jpg" alt=""></p>
<p>模板代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a[maxn],m[maxn],dp[maxm];    <span class="comment">//a表示数，m表示数的个数，dp范围是所有数的和的范围</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> K)</span> <span class="comment">//n表示数字种类,K表示组成的和</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</div><div class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;    <span class="comment">//根据存储方式作出改变</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=K; ++j) &#123;</div><div class="line">			<span class="keyword">if</span>(dp[j] &gt;= <span class="number">0</span>) dp[j] = m[i]; <span class="comment">// 前i-1个数已经能凑成j了</span></div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(j &lt; a[i] || dp[j-a[i]] &lt;= <span class="number">0</span>) dp[j] = <span class="number">-1</span>; <span class="comment">// 否则，凑不成j或者a[i]已经用完，则无法满足</span></div><div class="line">			<span class="keyword">else</span> dp[j] = dp[j-a[i]] - <span class="number">1</span>; <span class="comment">// 否则可以凑成</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> dp[K]&gt;=<span class="number">0</span>;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="非负数组的子数组和为定值"><a href="#非负数组的子数组和为定值" class="headerlink" title="非负数组的子数组和为定值"></a>非负数组的子数组和为定值</h2><p>这个题应该是比较基础的一道题：因为数组和一定递增的，所以采用滑动窗口的思想，维护滑动窗口的两个指针i和j，如果当前窗口和小于target时j++，如果当前窗口和大于target时i++</p>
<h2 id="子数组和为定值"><a href="#子数组和为定值" class="headerlink" title="子数组和为定值"></a>子数组和为定值</h2><p>还是遍历一遍数组，使得总体的时间复杂度为O(n)，同时记录从第一个数到当前位置数的和为一张hash表，这个表对应的映射项可以是最早出现这个sum的index（以此来求最长子数组的长度），也可以是对应这个sum出现的次数（对应求满足条件的子数组个数）</p>
<h3 id="LeetCode-560"><a href="#LeetCode-560" class="headerlink" title="LeetCode 560"></a>LeetCode 560</h3><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = nums.size();</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, res = <span class="number">0</span>;</div><div class="line">        m[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</div><div class="line">        &#123;</div><div class="line">            sum += nums[i];</div><div class="line">            <span class="comment">// 加上剩余的值出现的次数</span></div><div class="line">            res += m[sum - k];</div><div class="line">            m[sum] ++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="变式"><a href="#变式" class="headerlink" title="变式"></a>变式</h3><p>在上面那道题的基础上改为求满足条件的最长子数组的长度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = nums.size();</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, res = <span class="number">0</span>;</div><div class="line">        m[<span class="number">0</span>] = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</div><div class="line">        &#123;</div><div class="line">            sum += nums[i];</div><div class="line">            <span class="keyword">if</span> (m.find(sum - k) != m.end())</div><div class="line">                res = max(res, i - m[sum - k]);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                m[sum] = i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="子数组和小于等于定值"><a href="#子数组和小于等于定值" class="headerlink" title="子数组和小于等于定值"></a>子数组和小于等于定值</h2><p>这里用到了两个辅助数组：<code>min_value</code>、<code>min_index</code>：<code>min_value[i]</code>表示以i位置开始往后加的最小累加和；<code>min_index</code>表示<code>min_value</code>对应的最小累加和的右边界，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr         5   4   -3  -1</div><div class="line">index       0   1   2   3</div><div class="line">min_value   5   0   -4  -1</div><div class="line">min_index   0   3   3   3</div></pre></td></tr></table></figure>
<p>这两个辅助数组是能够在O(n)时间复杂内计算出来的：倒序遍历，min_value[i] 只需要判断min_value[i+1]的值是不是负数，如果是负数就加上，不是就到本身这里结尾。得到这样一个数组以后我们就可能轻易得到从某一个位置开始和最小的子数组。</p>
<p>有了这两个辅助数组以后，就可以采用滑动窗口的思想，左右两个指针都不回退，右指针以上面辅助数组进行累加，左指针正常遍历，使得总体的时间复杂度为O(n)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = nums.size();</div><div class="line">        <span class="comment">// 计算两个辅助数组</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; min_value(k, <span class="number">0</span>), min_index(k, <span class="number">0</span>);</div><div class="line">        min_value[len<span class="number">-1</span>] = nums[len<span class="number">-1</span>];</div><div class="line">        min_index[len<span class="number">-1</span>] = len<span class="number">-1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</div><div class="line">        &#123;</div><div class="line">            min_value[i] = min_value[i+<span class="number">1</span>] &lt; <span class="number">0</span> ? min_value[i+<span class="number">1</span>] + nums[i] : nums[i];</div><div class="line">            <span class="keyword">if</span>(min_value[i+<span class="number">1</span>] &lt; <span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                min_value[i] = min_value[i+<span class="number">1</span>] + nums[i];</div><div class="line">                min_index[i] = min_index[i+<span class="number">1</span>];</div><div class="line">            &#125; </div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                min_value[i] = nums[i];</div><div class="line">                min_index[i] = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 滑动窗口求解</span></div><div class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>, res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>( ; l &lt; len; l++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">while</span>(sum &lt;= k)</div><div class="line">            &#123;</div><div class="line">                sum += min_value[r];</div><div class="line">                r = min_index[r] + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            res = max(res, r - l);</div><div class="line">            sum -= nums[l];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[分布式消息队列 NSQ 和 Kafka 对比]]></title>
      <url>/2018/07/11/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-NSQ-%E5%92%8C-Kafka-%E5%AF%B9%E6%AF%94/</url>
      <content type="html"><![CDATA[<p>谈谈分布式消息队列的一些特性，比较两种比较常用的消息队列——NSQ和Kafka</p>
<a id="more"></a>
<h2 id="消息队列的作用"><a href="#消息队列的作用" class="headerlink" title="消息队列的作用"></a>消息队列的作用</h2><ol>
<li>解耦，将一个流程加入一层数据接口拆分成两个部分，上游专注通知，下游专注处理</li>
<li>缓冲，应对流量的突然上涨变更，消息队列有很好的缓冲削峰作用</li>
<li>异步，上游发送消息以后可以马上返回，处理工作交给下游进行</li>
<li>广播，让一个消息被多个下游进行处理</li>
<li>冗余，保存处理的消息，防止消息处理失败导致的数据丢失</li>
</ol>
<h2 id="NSQ"><a href="#NSQ" class="headerlink" title="NSQ"></a>NSQ</h2><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>NSQ主要包含3个组件：</p>
<ul>
<li>nsqd：在服务端运行的守护进程，负责接收，排队，投递消息给客户端。能够独立运行，不过通常是由 nsqlookupd 实例所在集群配置的</li>
<li>nsqlookup：为守护进程，负责管理拓扑信息并提供发现服务。客户端通过查询 nsqlookupd 来发现指定话题（topic）的生产者，并且 nsqd 节点广播话题（topic）和通道（channel）信息</li>
<li>nsqadmin：一套WEB UI，用来汇集集群的实时统计，并执行不同的管理任务</li>
</ul>
<p><img src="http://data3.liuin.cn/2018-09-07-Xnip2018-09-07_11-17-37.png" alt=""></p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol>
<li>消息默认不可持久化，虽然系统支持消息持久化存储在磁盘中（通过 –mem-queue-size ），不过默认情况下消息都在内存中</li>
<li>消息最少会被投递一次，假设成立于 nsqd 节点没有错误</li>
<li>消息无序，是由重新队列(requeues)，内存和磁盘存储的混合导致的，实际上，节点间不会共享任何信息。它是相对的简单完成疏松队列</li>
<li>支持无 SPOF 的分布式拓扑，nsqd 和 nsqadmin 有一个节点故障不会影响到整个系统的正常运行</li>
<li>支持requeue，延迟消费机制</li>
<li>消息push给消费者</li>
</ol>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>单个nsqd可以有多个Topic，每个Topic又可以有多个Channel。Channel能够接收Topic所有消息的副本，从而实现了消息多播分发；而Channel上的每个消息被分发给它的订阅者，从而实现负载均衡，所有这些就组成了一个可以表示各种简单和复杂拓扑结构的强大框架。</p>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="http://data3.liuin.cn/2018-09-07-Xnip2018-09-07_11-47-34.png" alt=""></p>
<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul>
<li>Producer：消息发布者，负责发布消息到Kafka broker</li>
<li>Consumer：消息消费者，向Kafka broker读取消息的客户端</li>
<li>Broker：Kafka集群中的一个服务器</li>
<li>Topic：每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</li>
<li>Partition：Parition是物理上的概念，每个Topic包含一个或多个Partition</li>
<li>每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）</li>
</ul>
<blockquote>
<p>Topic &amp; Partition</p>
</blockquote>
<p>Topic在逻辑上可以被认为是一个queue，每条消费都必须指定它的Topic，可以简单理解为必须指明把这条消息放进哪个queue里。为了使得Kafka的吞吐率可以线性提高，物理上把Topic分成一个或多个Partition，每个Partition在物理上对应一个文件夹，该文件夹下存储这个Partition的所有消息和索引文件。</p>
<blockquote>
<p>Producer消息路由</p>
</blockquote>
<p>Producer发送消息到broker时，会根据Paritition机制选择将其存储到哪一个Partition。如果Partition机制设置合理，所有消息可以均匀分布到不同的Partition里，这样就实现了负载均衡。<br>在发送一条消息时，可以指定这条消息的key，Producer根据这个key和Partition机制来判断应该将这条消息发送到哪个Parition。</p>
<blockquote>
<p>Consumer Group</p>
</blockquote>
<p>使用Consumer high level API时，同一Topic的一条消息只能被同一个Consumer Group内的一个Consumer消费，但多个Consumer Group可同时消费这一消息。</p>
<p>这是Kafka用来实现一个Topic消息的广播（发给所有的Consumer）和单播（发给某一个Consumer）的手段。一个Topic可以对应多个Consumer Group。如果需要实现广播，只要每个Consumer有一个独立的Group就可以了。要实现单播只要所有的Consumer在同一个Group里。用Consumer Group还可以将Consumer进行自由的分组而不需要多次发送消息到不同的Topic。</p>
<h3 id="Consumer-API"><a href="#Consumer-API" class="headerlink" title="Consumer API"></a>Consumer API</h3><blockquote>
<p>Low Level API/Assign</p>
</blockquote>
<ul>
<li>指定目标 Partition</li>
<li>指定消费的起始Offset</li>
<li>指定每次消费的消息长度</li>
<li>只能消费特定Topic中特定Partition中的消息</li>
</ul>
<blockquote>
<p>High Level API/Subscribe</p>
</blockquote>
<ul>
<li>每个Consumer实例属于Consumer Group</li>
<li>默认情况下，Consumer Group会顺序消费某Topic的所有信息</li>
<li>Offset存于Zookeeper或者Kafka或者自定义存储</li>
<li>实现Rebalance机制</li>
</ul>
<h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><ul>
<li>支持Replica持久化</li>
<li>投递保证支持 at least one / at most one / exactly once</li>
<li>Partition / Comsumer Group内消息保证有序</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python 多线程与多进程]]></title>
      <url>/2018/07/04/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>最近实习接触到这方面的东西，整理了一下</p>
<a id="more"></a>
<h2 id="Python多线程并不是真的多线程"><a href="#Python多线程并不是真的多线程" class="headerlink" title="Python多线程并不是真的多线程"></a>Python多线程并不是真的多线程</h2><p>Python代码的执行由Python虚拟机（解释器）来控制。Python在设计之初就考虑要在主循环中，同时只有一个线程在执行，就像单CPU的系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序在CPU中运行。同样地，<strong>虽然Python解释器可以运行多个线程，只有一个线程在解释器中运行。对Python虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同时只有一个线程在运行</strong>。</p>
<p>在多线程环境中，Python虚拟机按照以下方式执行。</p>
<ol>
<li>设置GIL。</li>
<li>切换到一个线程去执行。</li>
<li>运行。</li>
<li>把线程设置为睡眠状态。</li>
<li>解锁GIL。</li>
<li>再次重复以上步骤。</li>
</ol>
<p>对所有面向I/O的（会调用内建的操作系统C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其他线程在这个线程等待I/O的时候运行。如果某线程并未使用很多I/O操作，它会在自己的时间片内一直占用处理器和GIL。也就是说，<strong>I/O密集型的Python程序比计算密集型的Python程序更能充分利用多线程的好处</strong>。</p>
<p>我们都知道，比方我有一个4核的CPU，那么这样一来，在单位时间内每个核只能跑一个线程，然后时间片轮转切换。但是Python不一样，它不管你有几个核，单位时间多个核只能跑一个线程，然后时间片轮转。看起来很不可思议？但是这就是GIL搞的鬼。任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。</p>
<h2 id="Python-多线程"><a href="#Python-多线程" class="headerlink" title="Python 多线程"></a>Python 多线程</h2><p>Python中有三种模式实现多线程：继承Thread类、Thread对象和multiprocessing.dummy线程池</p>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>继承Thread类，通过重写它的run方法实现多线程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># encoding=utf-8</span></div><div class="line"></div><div class="line"><span class="comment"># 直接从Thread继承，创建一个新的class，把线程执行的代码放到这个新的 class里</span></div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> time</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadImpl</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></div><div class="line">        threading.Thread.__init__(self)</div><div class="line">        self._num = num</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">global</span> total, mutex</div><div class="line">        </div><div class="line">        <span class="comment"># 打印线程名</span></div><div class="line">        <span class="keyword">print</span> threading.currentThread().getName()</div><div class="line"> </div><div class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">0</span>, int(self._num)):</div><div class="line">            <span class="comment"># 取得锁</span></div><div class="line">            mutex.acquire()</div><div class="line">            total = total + <span class="number">1</span></div><div class="line">            <span class="comment"># 释放锁</span></div><div class="line">            mutex.release()</div><div class="line"> </div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="comment">#定义全局变量</span></div><div class="line">    <span class="keyword">global</span> total, mutex</div><div class="line">    total = <span class="number">0</span></div><div class="line">    <span class="comment"># 创建锁</span></div><div class="line">    mutex = threading.Lock()</div><div class="line">    </div><div class="line">    <span class="comment">#定义线程池</span></div><div class="line">    threads = []</div><div class="line">    <span class="comment"># 创建线程对象</span></div><div class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="number">40</span>):</div><div class="line">        threads.append(ThreadImpl(<span class="number">100</span>))</div><div class="line">    <span class="comment"># 启动线程</span></div><div class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</div><div class="line">        t.start()</div><div class="line">    <span class="comment"># 等待子线程结束</span></div><div class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</div><div class="line">        t.join()  </div><div class="line">    </div><div class="line">    <span class="comment"># 打印执行结果</span></div><div class="line">    <span class="keyword">print</span> total</div></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ul>
<li>一定要有<code>Thread.__init__(self)</code>这句话</li>
<li>执行的功能函数必须叫run</li>
</ul>
<h3 id="Thread对象"><a href="#Thread对象" class="headerlink" title="Thread对象"></a>Thread对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># encoding=utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> time</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">threadFunc</span><span class="params">(num)</span>:</span></div><div class="line">    <span class="keyword">global</span> total, mutex</div><div class="line">    </div><div class="line">    <span class="comment"># 打印线程名</span></div><div class="line">    <span class="keyword">print</span> threading.currentThread().getName()</div><div class="line"> </div><div class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">0</span>, int(num)):</div><div class="line">        <span class="comment"># 取得锁</span></div><div class="line">        mutex.acquire()</div><div class="line">        total = total + <span class="number">1</span></div><div class="line">        <span class="comment"># 释放锁</span></div><div class="line">        mutex.release()</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(num)</span>:</span></div><div class="line">    <span class="comment">#定义全局变量</span></div><div class="line">    <span class="keyword">global</span> total, mutex</div><div class="line">    total = <span class="number">0</span></div><div class="line">    <span class="comment"># 创建锁</span></div><div class="line">    mutex = threading.Lock()</div><div class="line">    </div><div class="line">    <span class="comment">#定义线程池</span></div><div class="line">    threads = []</div><div class="line">    <span class="comment"># 先创建线程对象</span></div><div class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">0</span>, num):</div><div class="line">        threads.append(threading.Thread(target=threadFunc, args=(<span class="number">100</span>,)))</div><div class="line">    <span class="comment"># 启动所有线程</span></div><div class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</div><div class="line">        t.start()</div><div class="line">    <span class="comment"># 主线程中等待所有子线程退出</span></div><div class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</div><div class="line">        t.join()  </div><div class="line">        </div><div class="line">    <span class="comment"># 打印执行结果</span></div><div class="line">    <span class="keyword">print</span> total</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="comment"># 创建40个线程</span></div><div class="line">    main(<span class="number">40</span>)</div></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ul>
<li>args=是一个tuple，即使没有参数也应该用()</li>
<li>如果希望子线程异步工作，要设置setDaemon为True；如果希望等待子线程工作结束后主进程再执行，在线程start后join</li>
</ul>
<h3 id="multiprocessing-dummy线程池"><a href="#multiprocessing-dummy线程池" class="headerlink" title="multiprocessing.dummy线程池"></a>multiprocessing.dummy线程池</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># encoding=utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> multiprocessing</div><div class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool <span class="keyword">as</span> ThreadPool</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.pool = ThreadPool(processes=<span class="number">8</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self, para)</span>:</span></div><div class="line">        print(para)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multi_work</span><span class="params">(self, trans)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            self.pool.map(self.display, trans)</div><div class="line">        <span class="keyword">except</span> multiprocessing.TimeoutError:</div><div class="line">            print(<span class="string">"pool time out"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></div><div class="line">        self.pool.close()</div><div class="line">        self.pool.join()</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    test = Test()</div><div class="line">    t = range(<span class="number">0</span>, <span class="number">6</span>)</div><div class="line">    test.multi_work(t)</div><div class="line">    test.close()</div></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>pool的join要在close之后执行</li>
<li>pool.map有可能超时，尽量捕捉这个错误</li>
</ul>
<h2 id="Python-多进程"><a href="#Python-多进程" class="headerlink" title="Python 多进程"></a>Python 多进程</h2><p>Python 多进程的实现也有三种：继承自multiprocessing.Process类、multiprocessing.process对象和multiprocessing pool进程池</p>
<h3 id="继承自multiprocessing-Process类"><a href="#继承自multiprocessing-Process类" class="headerlink" title="继承自multiprocessing.Process类"></a>继承自multiprocessing.Process类</h3><p>这里和多线程第一种实现方式一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> multiprocessing</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(multiprocessing.Process)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        multiprocessing.Process.__init__(self)</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<h3 id="multiprocessing-process对象"><a href="#multiprocessing-process对象" class="headerlink" title="multiprocessing.process对象"></a>multiprocessing.process对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="comment"># 子进程要执行的代码</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(name)</span>:</span></div><div class="line">  print(<span class="string">'Run child process %s (%s)...'</span> % (name, os.getpid()))</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">  print(<span class="string">'Parent process %s.'</span> % os.getpid())</div><div class="line">  p = Process(target=run_proc, args=(<span class="string">'test'</span>,))</div><div class="line">  print(<span class="string">'Child process will start.'</span>)</div><div class="line">  p.start()</div><div class="line">  p.join()</div><div class="line">  print(<span class="string">'Child process end.'</span>)</div></pre></td></tr></table></figure>
<h3 id="multiprocessing-pool进程池"><a href="#multiprocessing-pool进程池" class="headerlink" title="multiprocessing pool进程池"></a>multiprocessing pool进程池</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div><div class="line"><span class="keyword">import</span> os, time, random</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></div><div class="line">  print(<span class="string">'Run task %s (%s)...'</span> % (name, os.getpid()))</div><div class="line">  start = time.time()</div><div class="line">  time.sleep(random.random() * <span class="number">3</span>)</div><div class="line">  end = time.time()</div><div class="line">  print(<span class="string">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">  print(<span class="string">'Parent process %s.'</span> % os.getpid())</div><div class="line">  p = Pool(<span class="number">4</span>)</div><div class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">    p.apply_async(long_time_task, args=(i,))</div><div class="line">  print(<span class="string">'Waiting for all subprocesses done...'</span>)</div><div class="line">  p.close()</div><div class="line">  p.join()</div><div class="line">  print(<span class="string">'All subprocesses done.'</span>)</div></pre></td></tr></table></figure>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol>
<li>多线程的线程间消息传递使用Queue.Queue；多进程使用multiprocessing.Queue；进程池必须使用multiprocessing.manager().Queue</li>
<li>多进程的消息传递可以采取Queue和Pipe两种高级数据结构，其中Queue是用Pipe实现的。Pipe只能支持两个进程的生产消费关系，如果存在多生产或者多消费的场景，只能用Queue。Pipe的效率高一些，但是高得有限，整体来看，多进程的消息传递的效率不高，尽量不要进行消息传递</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://realpython.com/python-gil/" target="_blank" rel="external">https://realpython.com/python-gil/</a></li>
<li><a href="https://my.oschina.net/cloudcoder/blog/226111" target="_blank" rel="external">https://my.oschina.net/cloudcoder/blog/226111</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode总结——Minimax算法]]></title>
      <url>/2018/06/30/LeetCode%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94Minimax%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>总结在解决博弈问题中会用到的一个算法——Minimax算法</p>
<a id="more"></a>
<h2 id="什么是Minimax算法"><a href="#什么是Minimax算法" class="headerlink" title="什么是Minimax算法"></a>什么是Minimax算法</h2><p>什么是Minimax，它是用在决策轮、博弈论和概率论中的一条决策规则。它被用来最小化最坏情况下的可能损失。“最坏”情况是对手带来的最坏情况，“最小”是我要执行的一个最优策略的目标。</p>
<p>实际使用中一般，DFS来遍历当前局势以后所有可能的结果，通过『最大化』自己和『最小化』对手的方法获取下一步的动作。</p>
<h2 id="LeetCode-486"><a href="#LeetCode-486" class="headerlink" title="LeetCode 486"></a>LeetCode 486</h2><p>给定一个数组，双方轮流从数组的两边取出一个数，判断最后谁取的数多。</p>
<p>这是一个博弈问题，站在我的角度一定是要使自己的收益最大，但是站在对方的角度一定是要使我的收益最小。此时我们可以用f[i][j]表示我方在i~j这个数组下的收益，s[i][j]表示对方从两边拿了一个数以后我方的收益。此时不难得出状态转移方程：<code>f[i][j] = max(nums[i] + s[i+1][j], nums[j] + s[i][j-1])</code> 和 <code>min(f[i+1][j], f[i][j-1])</code> </p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Minimax 算法</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = nums.size();</div><div class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; f(len, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len, <span class="number">0</span>)), s(len, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len, <span class="number">0</span>));</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) sum += i;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)</div><div class="line">        &#123;</div><div class="line">            f[j][j] = nums[j];</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = j<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</div><div class="line">            &#123;</div><div class="line">                f[i][j] = max(nums[i] + s[i+<span class="number">1</span>][j], nums[j] + s[i][j<span class="number">-1</span>]);</div><div class="line">                s[i][j] = min(f[i+<span class="number">1</span>][j], f[i][j<span class="number">-1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][len<span class="number">-1</span>] &gt;= (sum+<span class="number">1</span>)/<span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="LeetCode-375"><a href="#LeetCode-375" class="headerlink" title="LeetCode 375"></a>LeetCode 375</h2><p>题意：某人从1~n中选一个数k，你每次给出一个数x，他会告诉你x与n的关系(大于，小于或等于)，每次询问你都需要花费x的代价，问你至少需要花费多少钱才能保证查找到k是多少。</p>
<p>一道比较典型的Minimax题目，最小化最大值，当确定中间的一个数x的时候，为了保证找到k一定是选取两边的代价中最大的。但是你可以选取这个x时，你可以选取一个代价最小的x。dp[i][j]表示从i到j猜出值所需要的代价，这时我们可以得到状态转移方程：<code>dp[i][j] = min(x + max(dp[i][k-1], dp[k+1][j]) ) {i &lt;= k &lt;= j}</code></p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Minimax算法，dp思路</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, INT_MAX));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(i == j) dp[i][j] = <span class="number">0</span>;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; j) dp[i][j] = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n-i; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> tem = INT_MAX;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt;= j+i; k++)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(k == <span class="number">0</span>)</div><div class="line">                        tem = min(tem, k + dp[k+<span class="number">1</span>][j+i]);</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(k == n)</div><div class="line">                        tem = min(tem, k + dp[j][k<span class="number">-1</span>]);</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        tem = min(tem, k + max(dp[j][k<span class="number">-1</span>], dp[k+<span class="number">1</span>][j+i]));</div><div class="line">                &#125;</div><div class="line">                dp[j][j+i] = tem;</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="LeetCode-464"><a href="#LeetCode-464" class="headerlink" title="LeetCode 464"></a>LeetCode 464</h2><p>题意：给定两个数m和target，两人依次从1到m的m个数中取出一个数，当轮到的人取出一个数以后使得所有取出的数不小于target这个人就获胜了，判断第一个取的能不能取得游戏的胜利</p>
<p>按照Minimax的思路，当我方作出决策的时候一定作出的是最我方损失最小的决策。当我方所在一个状态数组（1到m中各个数的取出状态数组）和一个target的时候，这个时候我们要做的是从这个状态数组中标记一个数为拿出状态，使得其大于target或者使得轮到对方决策后一定是输。</p>
<p>这里比较棘手的就是这个状态数组了，但是题目给了一个条件，m的值不会超过20个，这个时候我们就可以做一个状态压缩——用status一个数表示整个状态数组：那么这个时候我们就可以得到状态转移方程：<code>dp[n][status] = ((1 &lt;&lt; x) &amp; status) == 0 &amp;&amp; (x &gt;= n || dp[n-x][status | (1 &lt;&lt; x)])</code>，其中<code>((1 &lt;&lt; x) &amp; status)</code>表示当前选择的数x是否被选择过；<code>status | (1 &lt;&lt; x)</code>表示选择了x以后的状态数组的状态</p>
<p>虽然得到状态转移方程，但是我们不好通过遍历求解，这个时候就可以将动态规划“退化”成递归加上状态记录。这里dp按理说是一个二维数组，但是status和n是有关系的，n表示的是总数减去其取出的数。这里使用map来表示这个dp数组，因为能够表示出三种状态：没有访问过、true、false</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; dp;</div><div class="line">    </div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Minimax算法思想，最小化对手的收益</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> desiredTotal)</span> </span>&#123;</div><div class="line">        n = maxChoosableInteger;</div><div class="line">        <span class="keyword">if</span>(n &gt;= desiredTotal) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span>((<span class="number">1</span> + n) * n / <span class="number">2</span> &lt; desiredTotal) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> solute(desiredTotal, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 因为status和nowNum是有关联关系的，所以map中需要一个</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solute</span><span class="params">(<span class="keyword">int</span> nowNum, <span class="keyword">int</span> status)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(dp.find(status) != dp.end()) <span class="keyword">return</span> dp[status];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> tem = (<span class="number">1</span> &lt;&lt; i);</div><div class="line">            <span class="keyword">if</span>((tem &amp; status) == <span class="number">0</span> &amp;&amp; (i &gt;= nowNum || !solute(nowNum - i, tem | status)))</div><div class="line">            &#123;</div><div class="line">                dp[status] = <span class="literal">true</span>;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        dp[status] = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[推荐两个终端代理工具：ProxyChains 和 Proxifier]]></title>
      <url>/2018/06/24/%E6%8E%A8%E8%8D%90%E4%B8%A4%E4%B8%AA%E7%BB%88%E7%AB%AF%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9AProxyChains-%E5%92%8C-Proxifier/</url>
      <content type="html"><![CDATA[<p>Shadowsocks代理是sock5代理，但是我们的终端中的很多应用都是不走sock5代理的，这个时候就需要一些工具来让这些数据通过sock5进行传输，这里推荐两个Linux和Mac中常用的工具：ProxyChains 和 Proxifier</p>
<a id="more"></a>
<h2 id="ProxyChains"><a href="#ProxyChains" class="headerlink" title="ProxyChains"></a>ProxyChains</h2><p>ProxyChains的功能就是Hook 了 sockets 相关的操作，让普通程序的 sockets 数据走 SOCKS/HTTP 代理。其在实现部分主要是重写了部分socket函数。</p>
<p>其能够在同一条代理链中整合不同类型的代理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">your_host &lt;--&gt;socks5 &lt;--&gt; http &lt;--&gt; socks4 &lt;--&gt; target_host</div></pre></td></tr></table></figure></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote>
<p>源码编译安装</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 下载源码</div><div class="line">$ git <span class="built_in">clone</span> https://github.com/rofl0r/proxychains-ng</div><div class="line">// 编译</div><div class="line">$ ./configure --prefix=/usr --sysconfdir=/etc</div><div class="line">$ make</div><div class="line">$ make install</div><div class="line">$ make install-config (安装proxychains.conf配置文件)</div></pre></td></tr></table></figure>
<blockquote>
<p>Mac 安装</p>
</blockquote>
<p>因为macOS 10.11 后开启了 <a href="https://support.apple.com/zh-cn/ht204899" target="_blank" rel="external">SIP（System Integrity Protection）</a> 会导致命令行下 proxychains-ng 代理的模式失效。所以要安装ProxyChains首先需要关闭SIP功能</p>
<ul>
<li>部分关闭SIP</li>
</ul>
<p>重启Mac，按住Option键进入启动盘选择模式，再按⌘ + R进入Recovery模式。<br>实用工具（Utilities）-&gt; 终端（Terminal）。<br>输入命令<code>csrutil enable --without debug</code>运行。<br>重启进入系统后，终端里输入 csrutil status，结果中如果有 Debugging Restrictions: disabled 则说明关闭成功。</p>
<ul>
<li>全部关闭SIP</li>
</ul>
<p>重启Mac，按住Option键进入启动盘选择模式，再按⌘ + R进入Recovery模式。<br>实用工具（Utilities）-&gt; 终端（Terminal）。<br>输入命令<code>csrutil disable</code>运行。<br>重启进入系统后，终端里输入 csrutil status，结果中如果有 System Integrity Protection status:disabled. 则说明关闭成功。</p>
<p>关闭以后通过<code>brew</code>进行安装就行了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install proxychains-ng</div></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>proxychains-ng默认配置文件名为proxychains.conf</p>
<ul>
<li>通过源代码编译安装的默认为/etc/proxychains.conf。</li>
<li>Mac下用<code>Homebrew</code>安装的默认为/usr/local/etc/proxychains.conf</li>
</ul>
<p>配置只需要将代理加入[ProxyList]中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[ProxyList]</div><div class="line">socks5  127.0.0.1 1086</div></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在你需要进行代理的页面前面加上<code>proxychains4</code>即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ proxhchains4 curl www.google.com</div></pre></td></tr></table></figure>
<h2 id="Proxifier"><a href="#Proxifier" class="headerlink" title="Proxifier"></a>Proxifier</h2><p>Mac用户可能会觉得关闭SIP会造成一些安全隐患，这个时候可以使用Mac下的一个工具：Proxifier</p>
<p>Proxifier可以设定Mac上不同的应用走不同的代理，我们把我们平常需要的一些终端应用设置走指定的代理就行了</p>
<h3 id="添加代理"><a href="#添加代理" class="headerlink" title="添加代理"></a>添加代理</h3><p>打开Proxifier，打开<code>Proxies-&gt;Add</code>，输入地址和端口号添加对应的sock5代理</p>
<p><img src="http://data3.liuin.cn/2018-06-24-15298257914991.jpg" alt=""></p>
<h3 id="设置代理规则"><a href="#设置代理规则" class="headerlink" title="设置代理规则"></a>设置代理规则</h3><p>在<code>Rules</code>模块中，我们可以设置指定应用、目标主机、目标端口走我们刚才添加的代理</p>
<p><img src="http://data3.liuin.cn/2018-06-24-15298261213304.jpg" alt=""></p>
<p>需要注意的是，给我们提供的代理的Shadowsocks要设置成直接连接不能加入代理中，否则会造成整个代理链成了一条环，最后上不了网。</p>
<p>设置以后就可能在终端中享受代理服务了~</p>
]]></content>
      
        <categories>
            
            <category> 软件使用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 效率提升 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识 Go 语言]]></title>
      <url>/2018/06/22/%E5%88%9D%E8%AF%86-Go-%E8%AF%AD%E8%A8%80/</url>
      <content type="html"><![CDATA[<p>今天来会一会这个小地鼠</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Go是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。Go语言号称集多数编程语言的优势于一身，具有较高的生产效率、先进的依赖管理和类型系统，以及原生的并发计算支持。</p>
<p>Go语言的语法接近C语言，但对于变量的声明有所不同。Go语言支持垃圾回收功能。Go语言的并行模型是以东尼·霍尔的通信顺序进程（CSP）为基础，采取类似模型的其他语言包括Occam和Limbo，但它也具有Pi运算的特征，比如通道传输。</p>
<p>与C++相比，Go语言并不包括如异常处理、继承、泛型、断言、虚函数等功能，但增加了 Slice 型、并发、管道、垃圾回收、接口（Interface）等特性的语言级支持</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol>
<li><p>部署简单。Go 是一个编译型语言，Go 编译生成的是一个静态可执行文件，除了 glibc 外没有其他外部依赖。</p>
</li>
<li><p>并发性好。Goroutine 和 channel 使得编写高并发的服务端软件变得相当容易，很多情况下完全不需要考虑锁机制以及由此带来的问题。</p>
</li>
<li><p>代码风格强制统一</p>
</li>
<li><p>Go语言语法趋于脚本化，比较简洁，但Go是编译型语言而非解释型语言。</p>
</li>
<li><p>Go语言使用垃圾自动回收机制（GC），GC是定时自动启动，人工可做稍微的干预。</p>
</li>
</ol>
<h2 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h2><ol>
<li>错误处理</li>
</ol>
<p>在Go语言中处理错误的基本模式是：函数通常返回多个值，其中最后一个值是error类型，用于表示错误类型极其描述；调用者每次调用完一个函数，都需要检查这个error并进行相应的错误处理：if err != nil { /*这种代码写多了不想吐么*/ }。此模式跟C语言那种很原始的错误处理相比如出一辙，并无实质性改进。</p>
<ol>
<li>软件包管理</li>
</ol>
<p>Go 语言的软件包管理绝对不是完美的。默认情况下，它没有办法制定特定版本的依赖库，也无法创建可复写的 builds。相比之下 Python、Node 和 Ruby 都有更好的软件包管理系统。然而通过正确的工具，Go 语言的软件包管理也可以表现得不错。</p>
<h2 id="基本语法学习"><a href="#基本语法学习" class="headerlink" title="基本语法学习"></a>基本语法学习</h2><p>找到两个口碑比较好的入门Go语言的教程：</p>
<ul>
<li><a href="https://tour.go-zh.org/welcome/1" target="_blank" rel="external">Go语言之旅</a></li>
<li><a href="https://legacy.gitbook.com/book/yar999/gopl-zh/details" target="_blank" rel="external">Go语言圣经</a></li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Go在Linux上的配置比较简单，无非就是下载一个二进制文件，然后添加一下环境变量。</p>
<p>Go在mac上推荐使用brew进行安装，使用官网的安装包进行安装因为<a href="https://support.apple.com/zh-cn/HT204899" target="_blank" rel="external">苹果对一些目录的保护</a>，后面在安装其他库的时候可能会存在问题</p>
<p>具体可以参考官方<a href="https://golang.org/doc/install" target="_blank" rel="external">配置文档</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.zhihu.com/question/21409296" target="_blank" rel="external">https://www.zhihu.com/question/21409296</a></li>
<li><a href="https://blog.csdn.net/itsenlin/article/details/53750262" target="_blank" rel="external">https://blog.csdn.net/itsenlin/article/details/53750262</a></li>
<li><a href="https://blog.csdn.net/liigo/article/details/23699459" target="_blank" rel="external">https://blog.csdn.net/liigo/article/details/23699459</a></li>
<li><a href="http://www.techug.com/post/bad-and-good-of-golang.html" target="_blank" rel="external">http://www.techug.com/post/bad-and-good-of-golang.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Go </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析——客户端和服务器]]></title>
      <url>/2018/06/19/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>Redis服务器是典型的一对多服务器程序:一个服务器可以与多个客户端建立网络连接。这篇文章将通过源码看看客户端和服务器的底层数据结构和工作过程</p>
<a id="more"></a>
<p>在Redis这种一对多的服务模式下，每个客户端可以向服务器发送命令请求,而服务器则接收并处理客户端发送的命令请求,并向客户端返回命令回复。通过使用由I/O多路复用技术实现的文件事件处理器,Redis服务器使用单线程单进程的方式来处理命令请求,并与多个客户端进行网络通信。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="客户端数据结构"><a href="#客户端数据结构" class="headerlink" title="客户端数据结构"></a>客户端数据结构</h3><p>客户端底层的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisClient &#123;</div><div class="line">    <span class="keyword">uint64_t</span> id;            <span class="comment">/* Client incremental unique ID. */</span></div><div class="line">    <span class="comment">// 套接字描述符</span></div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line">    redisDb *db;</div><div class="line">    <span class="keyword">int</span> dictid;</div><div class="line">    <span class="comment">// 客户端名字</span></div><div class="line">    robj *name;             <span class="comment">/* As set by CLIENT SETNAME */</span></div><div class="line">    <span class="comment">// 输入缓冲区，保存客户端发送的命令请求</span></div><div class="line">    sds querybuf;</div><div class="line">    <span class="keyword">size_t</span> querybuf_peak;   <span class="comment">/* Recent (100ms or more) peak of querybuf size */</span></div><div class="line">    <span class="comment">// 命令和命令参数</span></div><div class="line">    <span class="keyword">int</span> argc;</div><div class="line">    robj **argv;</div><div class="line">    <span class="comment">// 命令实现函数字典</span></div><div class="line">    <span class="keyword">struct</span> redisCommand *cmd, *lastcmd;</div><div class="line">    <span class="keyword">int</span> reqtype;</div><div class="line">    <span class="keyword">int</span> multibulklen;       <span class="comment">/* number of multi bulk arguments left to read */</span></div><div class="line">    <span class="keyword">long</span> bulklen;           <span class="comment">/* length of bulk argument in multi bulk request */</span></div><div class="line">    <span class="built_in">list</span> *reply;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> reply_bytes; <span class="comment">/* Tot bytes of objects in reply list */</span></div><div class="line">    <span class="keyword">int</span> sentlen;            <span class="comment">/* Amount of bytes already sent in the current</span></div><div class="line">                               buffer or object being sent. */</div><div class="line">    <span class="comment">// 创建客户端时间</span></div><div class="line">    <span class="keyword">time_t</span> ctime;           <span class="comment">/* Client creation time */</span></div><div class="line">    <span class="comment">// 客户端和服务器最后一次进行互动的时间</span></div><div class="line">    <span class="keyword">time_t</span> lastinteraction; <span class="comment">/* time of the last interaction, used for timeout */</span></div><div class="line">    <span class="keyword">time_t</span> obuf_soft_limit_reached_time;</div><div class="line">    <span class="comment">// 标志，记录客户端的角色</span></div><div class="line">    <span class="keyword">int</span> flags;              <span class="comment">/* REDIS_SLAVE | REDIS_MONITOR | REDIS_MULTI ... */</span></div><div class="line">    <span class="comment">// 标志是否通过身份验证</span></div><div class="line">    <span class="keyword">int</span> authenticated;      <span class="comment">/* when requirepass is non-NULL */</span></div><div class="line">    ... <span class="comment">// 其他相关属性</span></div><div class="line"></div><div class="line">    <span class="comment">/* Response buffer */</span></div><div class="line">    <span class="comment">// 回应缓冲区</span></div><div class="line">    <span class="keyword">int</span> bufpos;</div><div class="line">    <span class="keyword">char</span> buf[REDIS_REPLY_CHUNK_BYTES];</div><div class="line">&#125; redisClient;</div></pre></td></tr></table></figure>
<p>在客户端的各个属性中：</p>
<p>fd表示套接字描述符，伪客户端的fd属性的值为-1:伪客户端处理的命令请求来源于AOF文件或者Lua脚本,而不是网络,所以这种客户端不需要套接字连接；普通客户端的fd属性的值为大于-1的整数</p>
<p>命令和命令参数是对输入缓冲的命令进行解析以后获得命令和参数。</p>
<p><code>cmd</code>是命令的实现函数的数组，命令实现函数的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> redisCommand &#123;</div><div class="line">    <span class="comment">// 命令名称</span></div><div class="line">    <span class="keyword">char</span> *name;</div><div class="line">    <span class="comment">// 命令执行函数</span></div><div class="line">    redisCommandProc *proc;</div><div class="line">    <span class="comment">// 参数个数</span></div><div class="line">    <span class="keyword">int</span> arity;</div><div class="line">    <span class="comment">// 字符串表示flag</span></div><div class="line">    <span class="keyword">char</span> *sflags; <span class="comment">/* Flags as string representation, one char per flag. */</span></div><div class="line">    <span class="comment">// 实际flag</span></div><div class="line">    <span class="keyword">int</span> flags;    <span class="comment">/* The actual flags, obtained from the 'sflags' field. */</span></div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">// 指定哪些参数是key</span></div><div class="line">    <span class="keyword">int</span> firstkey; <span class="comment">/* The first argument that's a key (0 = no keys) */</span></div><div class="line">    <span class="keyword">int</span> lastkey;  <span class="comment">/* The last argument that's a key */</span></div><div class="line">    <span class="keyword">int</span> keystep;  <span class="comment">/* The step between first and last key */</span></div><div class="line">    <span class="comment">// 统计信息</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> microseconds, calls;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="客户端的创建和关闭"><a href="#客户端的创建和关闭" class="headerlink" title="客户端的创建和关闭"></a>客户端的创建和关闭</h3><p>当客户端向服务器发出connect请求的时候，服务器的事件处理器就会对这个事件进行处理，创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 创建一个新客户端</div><div class="line"> */</div><div class="line"><span class="function">redisClient *<span class="title">createClient</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 分配空间</span></div><div class="line">    redisClient *c = zmalloc(<span class="keyword">sizeof</span>(redisClient));</div><div class="line"></div><div class="line">    <span class="comment">// 当 fd 不为 -1 时，创建带网络连接的客户端</span></div><div class="line">    <span class="comment">// 如果 fd 为 -1 ，那么创建无网络连接的伪客户端</span></div><div class="line">    <span class="comment">// 因为 Redis 的命令必须在客户端的上下文中使用，所以在执行 Lua 环境中的命令时</span></div><div class="line">    <span class="comment">// 需要用到这种伪终端</span></div><div class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</div><div class="line">        <span class="comment">// 非阻塞</span></div><div class="line">        anetNonBlock(<span class="literal">NULL</span>,fd);</div><div class="line">        <span class="comment">// 禁用 Nagle 算法</span></div><div class="line">        anetEnableTcpNoDelay(<span class="literal">NULL</span>,fd);</div><div class="line">        <span class="comment">// 设置 keep alive</span></div><div class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</div><div class="line">            anetKeepAlive(<span class="literal">NULL</span>,fd,server.tcpkeepalive);</div><div class="line">        <span class="comment">// 绑定读事件到事件 loop （开始接收命令请求）</span></div><div class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el,fd,AE_READABLE,</div><div class="line">            readQueryFromClient, c) == AE_ERR)</div><div class="line">        &#123;</div><div class="line">            close(fd);</div><div class="line">            zfree(c);</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化各个属性</span></div><div class="line"></div><div class="line">    <span class="comment">// 默认数据库</span></div><div class="line">    selectDb(c,<span class="number">0</span>);</div><div class="line">    <span class="comment">// 套接字</span></div><div class="line">    c-&gt;fd = fd;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    </div><div class="line">    listSetFreeMethod(c-&gt;pubsub_patterns,decrRefCountVoid);</div><div class="line">    listSetMatchMethod(c-&gt;pubsub_patterns,listMatchObjects);</div><div class="line">    <span class="comment">// 如果不是伪客户端，那么添加到服务器的客户端链表中</span></div><div class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) listAddNodeTail(server.clients,c);</div><div class="line">    <span class="comment">// 初始化客户端的事务状态</span></div><div class="line">    initClientMultiState(c);</div><div class="line"></div><div class="line">    <span class="comment">// 返回客户端</span></div><div class="line">    <span class="keyword">return</span> c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于客户端的启动程序，其大致的逻辑是：读取本地配置，连接服务器获取服务器的配置，获取本地输入的命令并发送到服务器</p>
<p>一个普通客户端可以因为多种原因而被关闭:</p>
<ul>
<li>如果客户端进程退出或者被杀死,那么客户端与服务器之间的网络连接将被关闭,从而造成客户端被关闭。</li>
<li>如果客户端向服务器发送了带有不符合协议格式的命令请求,那么这个客户端也会被服务器关闭。</li>
<li>如果客户端成为了CLIENT KLLL命令的目标,那么它也会被关闭。</li>
</ul>
<p>关闭客户端的底层实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 释放客户端</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeClient</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    listNode *ln;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">/* Free the query buffer */</span></div><div class="line">    sdsfree(c-&gt;querybuf);</div><div class="line">    c-&gt;querybuf = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Deallocate structures used to block on blocking ops. */</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_BLOCKED) unblockClient(c);</div><div class="line">    dictRelease(c-&gt;bpop.keys);</div><div class="line"></div><div class="line">    <span class="comment">/* UNWATCH all the keys */</span></div><div class="line">    <span class="comment">// 清空 WATCH 信息</span></div><div class="line">    unwatchAllKeys(c);</div><div class="line">    listRelease(c-&gt;watched_keys);</div><div class="line"></div><div class="line">    <span class="comment">/* Unsubscribe from all the pubsub channels */</span></div><div class="line">    <span class="comment">// 退订所有频道和模式</span></div><div class="line">    pubsubUnsubscribeAllChannels(c,<span class="number">0</span>);</div><div class="line">    pubsubUnsubscribeAllPatterns(c,<span class="number">0</span>);</div><div class="line">    dictRelease(c-&gt;pubsub_channels);</div><div class="line">    listRelease(c-&gt;pubsub_patterns);</div><div class="line"></div><div class="line">    <span class="comment">/* Close socket, unregister events, and remove list of replies and</span></div><div class="line">     * accumulated arguments. */</div><div class="line">    <span class="comment">// 关闭套接字，并从事件处理器中删除该套接字的事件</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;fd != <span class="number">-1</span>) &#123;</div><div class="line">        aeDeleteFileEvent(server.el,c-&gt;fd,AE_READABLE);</div><div class="line">        aeDeleteFileEvent(server.el,c-&gt;fd,AE_WRITABLE);</div><div class="line">        close(c-&gt;fd);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 清空回复缓冲区</span></div><div class="line">    listRelease(c-&gt;reply);</div><div class="line"></div><div class="line">    <span class="comment">// 清空命令参数</span></div><div class="line">    freeClientArgv(c);</div><div class="line"></div><div class="line">    <span class="comment">/* Remove from the list of clients */</span></div><div class="line">    <span class="comment">// 从服务器的客户端链表中删除自身</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;fd != <span class="number">-1</span>) &#123;</div><div class="line">        ln = listSearchKey(server.clients,c);</div><div class="line">        redisAssert(ln != <span class="literal">NULL</span>);</div><div class="line">        listDelNode(server.clients,ln);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除客户端的阻塞信息</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_UNBLOCKED) &#123;</div><div class="line">        ln = listSearchKey(server.unblocked_clients,c);</div><div class="line">        redisAssert(ln != <span class="literal">NULL</span>);</div><div class="line">        listDelNode(server.unblocked_clients,ln);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (c-&gt;name) decrRefCount(c-&gt;name);</div><div class="line">    <span class="comment">// 清除参数空间</span></div><div class="line">    zfree(c-&gt;argv);</div><div class="line">    <span class="comment">// 清除事务状态信息</span></div><div class="line">    freeClientMultiState(c);</div><div class="line">    sdsfree(c-&gt;peerid);</div><div class="line">    <span class="comment">// 释放客户端 redisClient 结构本身</span></div><div class="line">    zfree(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="请求命令执行的过程"><a href="#请求命令执行的过程" class="headerlink" title="请求命令执行的过程"></a>请求命令执行的过程</h3><p>从客户端输入一条指令到服务端完成命令的内容并返回要经历以下这些步骤：</p>
<ol>
<li>发送命令请求，Redis服务器的命令请求来自 Redis客户端,当用户在客户端中键人一个命令请求时,客户端会将这个命令请求转换成协议格式,然后通过套接字发送给服务器</li>
<li>读取命令的内容，服务器接受到套接字以后会产生一个文件事件，通过对文件事件的处理，判断为命令内容</li>
<li>查找命令实现，根据客户端的命令参数argv[0]，在服务器的命令表中查找指定的命令，并将找到的命令保存到客户端状态的cmd属性里面</li>
<li>执行预备操作，在执行命令前需要进行一些操作：检查给出的命令是否有效（cmd是否为NULL）;判断给定的参数是否正确；判断客户端是否通过验证</li>
<li>调用命令的实现函数</li>
<li>执行后续的工作，包括添加日志，计算时间属性，进行AOF操作等等</li>
<li>将命令回复发送给客户端</li>
<li>客户端收到并打印命令</li>
</ol>
<h3 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h3><p>Redis服务器中的 serverCron函数默认每隔100毫秒执行一次,这个函数负责管理服务器的资源,并保持服务器自身的良好运转</p>
<p>因为serverCron的实现代码太过冗长，所以这里就简单说一些serverCron函数都干了哪些事情</p>
<ol>
<li>更新服务器时间缓存</li>
</ol>
<p>Redis服务器中许多的操作都需要用到当前的系统时间属性<code>unixtime</code>，serverCron会更新这个时间属性</p>
<ol>
<li>更新LRU时钟</li>
</ol>
<p>Reids服务器中实现过期键的删除需要计算其空转时间，计算空转时间需要用LRU时钟，serverCron会更新这个时钟保证Redis过期键删除功能的正常使用</p>
<ol>
<li>更新服务器内存峰值记录</li>
</ol>
<p>Redis中使用了一个属性<code>stat_peak_memory</code>记录了使用内存的峰值，这个属性需要serverCron进行更新</p>
<ol>
<li>处理SIGTERM信号</li>
</ol>
<p>在启动服务器时, Redis会为服务器进程的 SIGTERM信号关联处理器 sigtermhandier函数,这个信号处理器负责在服务器接到 SIGTERM信号时,打开服务器状态的 shutdown_asap标识。</p>
]]></content>
      
        <categories>
            
            <category> 源码剖析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode总结——字符串相关算法]]></title>
      <url>/2018/06/18/LeetCode%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>总结在LeetCode中字符串相关的常用的一些算法</p>
<a id="more"></a>
<h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><p>KMP算法解决的是两个字符串的匹配问题（一个字符串是不是另外一个字符串的子串）</p>
<p>暴力法所需要的时间复杂度是O(n*m)，KMP算法能够优化到O(n)。KMP算法的核心是使用一个next数组实现匹配的加速</p>
<h3 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h3><p>最长前缀后缀：一个字符串中所有的前缀和其所有的后缀中最长的相等的长度，比如说“abcabc”的最长前缀后缀为”abc”</p>
<p>给定一个串s的next数组next[]，其每一位next[i]表示串s[0…i-1]中最长前缀后缀</p>
<p>使用next数据对字符串匹配进行加速：s1中查找是否有子串s2，如果s1[i]匹配到s2[j]的时候不相等，并且此时next[j]=k，此时不需要重新回到s1[1]继续进行匹配，而是用s2[k]继续和s1[i]进行匹配，依次类推</p>
<p><img src="http://data3.liuin.cn/2018-06-17-15292350043789.jpg" alt=""></p>
<p>因为next数组是找到了最长前缀后缀的，所以其能够从最长前缀的匹配跳到最长后缀的匹配，因为中间不可能出现匹配的情况，如果出现匹配那么表示当前next计算的不可能是”最长“前缀后缀。</p>
<h3 id="next数组求法"><a href="#next数组求法" class="headerlink" title="next数组求法"></a>next数组求法</h3><p>规定<code>next[0] = -1</code>， 因为其前面没有字符串；<code>next[1] = 0</code>，因为其前面的字符串中只有一个字符，后面的next值的计算取决于前面的next值：</p>
<p>判断当前位置的字符和最长前缀的后一个字符是否相等，如果相等则<code>next[i] = next[i-1] + 1</code>，如果不等再判断最长前缀的最长前缀和其相等不相等，如果还不相等就继续找最长前缀，直到最长前缀长度为0的时候表示没有找到，这个时候<code>next[i] = 0</code></p>
<h3 id="LeetCode-028"><a href="#LeetCode-028" class="headerlink" title="LeetCode 028"></a>LeetCode 028</h3><p><a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="external">Implement strStr()</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = p.size();</div><div class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="comment">// 生成next数组</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(len, <span class="number">0</span>);</div><div class="line">        getNext(next, p);</div><div class="line">        <span class="comment">// 两个数组的遍历指针</span></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; j &lt; len)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(s[i] == p[j])</div><div class="line">            &#123;</div><div class="line">                i++;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>) i++;</div><div class="line">                <span class="comment">// 根据next数组中的信息进行重新指向</span></div><div class="line">                <span class="keyword">else</span> j = next[j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> j == len ? i - j : <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;next, <span class="built_in">string</span> p)</span></span></div><div class="line">    &#123;</div><div class="line">        next[<span class="number">0</span>] = <span class="number">-1</span>;</div><div class="line">        <span class="comment">// k表示最长前缀后缀的长度</span></div><div class="line">        <span class="keyword">int</span> k = <span class="number">-1</span>, i = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 计算到最后一位</span></div><div class="line">        <span class="keyword">while</span>(i &lt; p.size() - <span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 相匹配的时候对next数组赋值</span></div><div class="line">            <span class="keyword">if</span>(k == <span class="number">-1</span> || p[i] == p[k])</div><div class="line">                next[++i] = ++k;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                k = next[k];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="Manacher-算法"><a href="#Manacher-算法" class="headerlink" title="Manacher 算法"></a>Manacher 算法</h2><p>Manacher 算法解决的是字符串中最长的回文子串的问题</p>
<p>暴力法（技巧：中间添加辅助字符）解决这个问题的时间复杂度为O(n^2)，Manacher算法能够时间复杂度优化为O(n)</p>
<h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><ul>
<li>回文半径数组，以i为中心的的回文的半径长度</li>
<li>回文右边界，遍历过的回文能够达到的最右的下标</li>
<li>右边界中心位置，回文右边界对应的回文中心点下标</li>
</ul>
<h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><p>和暴力解法一样从左向右扩充判断，有以下几种情况：</p>
<ol>
<li>当前位置不在回文右边界里面，暴力扩充</li>
<li>当前位置在回文右边界里面，其关于右边界中心的对称点的回文区域<strong>在左边界里面</strong>，其回文半径和其对称点一样</li>
<li>当前位置在回文右边界里面，其关于右边界中心的对称点的回文左区域<strong>超过回文左边界</strong>，其回文半径为r-i</li>
<li>当前位置在回文右边界里面，其关于右边界中心的对称点的回文左区域<strong>与回文左边界重合（压线）</strong>，其回文半径需要在r-i的基础上往后判断</li>
</ol>
<p><img src="http://data3.liuin.cn/2018-06-17-15292498856933.jpg" alt=""></p>
<h3 id="LeetCode-005"><a href="#LeetCode-005" class="headerlink" title="LeetCode 005"></a>LeetCode 005</h3><p><a href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank" rel="external">Longest Palindromic Substring</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Manacher 算法</span></div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="comment">// 添加辅助字符#</span></div><div class="line">        <span class="built_in">string</span> new_s;</div><div class="line">        new_s.push_back(<span class="string">'#'</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</div><div class="line">        &#123;</div><div class="line">            new_s.push_back(s[i]);</div><div class="line">            new_s.push_back(<span class="string">'#'</span>);</div><div class="line">        &#125;</div><div class="line">        s = new_s;</div><div class="line">        <span class="keyword">int</span> len = s.size();</div><div class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="comment">// 回文半径数组</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pArr(len, <span class="number">0</span>);</div><div class="line">        <span class="comment">// C表示回文中心， R表示回文右边界</span></div><div class="line">        <span class="keyword">int</span> C = <span class="number">-1</span>, R = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">int</span> maxv = INT_MIN, maxi = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 在回文右边界里面与否的区分</span></div><div class="line">            <span class="comment">// 此时pArr表示的是起码不用验的区域 </span></div><div class="line">            pArr[i] = R &gt; i ? min(pArr[<span class="number">2</span>*C - i], R - i) : <span class="number">1</span>;</div><div class="line">            <span class="comment">// 区域没有越界</span></div><div class="line">            <span class="keyword">while</span>(i + pArr[i] &lt; len &amp;&amp; i - pArr[i] &gt; <span class="number">-1</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">// 情况1+4 扩充</span></div><div class="line">                <span class="keyword">if</span>(s[i + pArr[i]] == s[i - pArr[i]])</div><div class="line">                    pArr[i]++;</div><div class="line">                <span class="comment">// 情况2+3</span></div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(i + pArr[i] &gt; R)</div><div class="line">            &#123;</div><div class="line">                R = i + pArr[i];</div><div class="line">                C = i;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(maxv &lt; pArr[i])</div><div class="line">            &#123;</div><div class="line">                maxv = pArr[i];</div><div class="line">                maxi = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">string</span> res;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = maxi - maxv + <span class="number">1</span>; i &lt;= maxi + maxv - <span class="number">1</span>; i++)</div><div class="line">            <span class="keyword">if</span>(s[i] != <span class="string">'#'</span>) res.push_back(s[i]);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《大型网站技术架构》 笔记]]></title>
      <url>/2018/06/18/%E3%80%8A%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E3%80%8B-%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>最近用了三天的时间把《大型网站技术架构》看完了，收获颇多。这本书主要讲了一个网站从小到大发展过程在技术架构上的需要注意的地方，这里简短地记录一下我的收获吧。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>第一篇概述主要从大型网站的架构演化、架构模式和核心构架要素三个方面对大型网站技术架构进行了一个综合性的概述。</p>
<p>大型网站架构演化发展历程主要经过以下几个阶段：</p>
<ul>
<li>初始阶段的网站架构，能够跑来就行，所有的资源放在一个服务器上</li>
<li>应用服务和数据服务分离，随着需求的不断扩大，将应用和数据根据对硬件资源的要求不同分离成应用服务器、文件服务器和数据库服务器</li>
<li>使用缓存改善网站性能，根据二八定律把经常访问的一小部分数据缓存在内存中，减少对数据库访问的压力，改善网站性能</li>
<li>使用应用服务器集群改善网站的并发处理能力，通过负载均衡调度服务器，将请求分发到应用服务器集群中的任何一台服务器中</li>
<li>数据库读写分离，对数据库读的需求远大于写的需求，应用服务器在写数据的时候，访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库</li>
<li>使用反向代理和CDN加速网站响应，CDN解决不同的地区其访问性能有较大差异的情况，反向代理是应用在应用服务器的一种缓存手段</li>
<li>使用分布式文件系统和分布式数据库系统，分布式数据库是网站数据库拆分的最后手段</li>
<li>使用 NOSQL和搜索引擎，提供对可伸缩性的更好支持</li>
<li>业务拆分</li>
<li>分布式服务</li>
</ul>
<p>架构模式中讲了9种解决大型网站一系列问题的解决方案：</p>
<ul>
<li>分层，将系统在横向维度上切分成几个部分，使得每一个部门负责的职能比较单一</li>
<li>分割，在纵向方面对软件进行切分，将不同的功能和服务分割开来,包装成高内聚低耦合的模块单元</li>
<li>分布式，将分层和分割后的模块独立部署，达到处理更大的并发访问</li>
<li>集群，多台服务器部署相同应用构成一个集群,通过负载均衡设备共同对外提供服务</li>
<li>缓存，将数据存放在距离计算最近的位置以加快处理速度</li>
<li>异步，业务之间的消息传递不是同步调用,而是将一个业务操作分成多个阶段,每个阶段之间通过共享数据的方式异步执行进行协作</li>
<li>冗余，为网站的高可用性提供保障</li>
<li>自动化，在无人值守的情况下网站可以正常运行,一切都可以自动化是网站的理想状态</li>
<li>安全，互联网的开放特性使得其从诞生起就面对巨大的安全挑战</li>
</ul>
<p>核心架构要素中讲了5个核心架构要素：</p>
<ol>
<li>性能，访问的响应时间、TPS、系统性能计数器决定</li>
<li>可用性，高可用设计的目标就是当服务器宕机的时候,服务或者应用依然可用</li>
<li>伸缩性，通过不断向集群中加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的数据存储需求</li>
<li>扩展性，使网站能够快速响应需求变化，网站可伸缩架构的主要手段是事件驱动架构和分布式服务</li>
<li>安全性，保护网站不受恶意访问和攻击,保护网站的重要数据不被窃取</li>
</ol>
<h2 id="导图"><a href="#导图" class="headerlink" title="导图"></a>导图</h2><p>后面的内容比较多，我就整理成思维导图的形式吧</p>
<p><img src="http://data3.liuin.cn/2018-06-17-15292395484469.jpg" alt=""></p>
<p>展开的高清大图可以看<a href="https://data2.liuin.cn/2018-060-18-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84.svg" target="_blank" rel="external">这里</a></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析——事件]]></title>
      <url>/2018/06/16/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>对RDB处理事件的的过程实现进行分析</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis服务器是一个事件驱动程序,服务器需要处理以下两类事件</p>
<ul>
<li>文件事件( file event): Redis服务器通过套接字与客户端(或者其他 Redis服务器)进行连接,而文件事件就是服务器对套接字操作的抽象。服务器与客户端(或者其他服务器)的通信会产生相应的文件事件,而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li>
<li>时间事件( time event): Redis服务器中的一些操作需要在给定的时间点执行,而时间事件就是服务器对这类定时操作的抽象</li>
</ul>
<h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>Redis基于Reactor模式开发了自己的网络事件处理器:这个处理器被称为文件事件处理器( fle event handler)</p>
<ul>
<li>文件事件处理器使用I/o多路复用( multiplexing)程序来<strong>同时监听多个套接字</strong>,并根据套接字目前执行的任务来为套接字关联不同的事件处理器</li>
<li>当被监听的套接字准备好执行连接应答( accept)、读取(read)、写人( wrte)关闭( close)等操作时,与操作相对应的文件事件就会产生,这时<strong>文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件</strong>。</li>
</ul>
<p>虽然文件事件处理器以单线程方式运行,但通过使用I/O多路复用程序来监听多个套接字,文件事件处理器既实现了<strong>高性能的网络通信模型</strong>,又可以很好地与 Redis服务器中其他同样以单线程方式运行的模块进行对接,这保持了 Redis内部单线程设计的简单性。</p>
<p><img src="http://data3.liuin.cn/2018-06-17-15292019497333.jpg" alt=""></p>
<h3 id="事件结构定义"><a href="#事件结构定义" class="headerlink" title="事件结构定义"></a>事件结构定义</h3><p>在Redis中事件结构体的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeFileEvent &#123;</div><div class="line">    <span class="keyword">int</span> mask;   <span class="comment">// 读or写标记</span></div><div class="line">    aeFileProc *rfileProc;  <span class="comment">// 读处理函数</span></div><div class="line">    aeFileProc *wfileProc;  <span class="comment">// 写处理函数</span></div><div class="line">    <span class="keyword">void</span> *clientData;  <span class="comment">// 私有数据</span></div><div class="line">&#125; aeFileEvent;</div></pre></td></tr></table></figure></p>
<h3 id="事件的创建和删除"><a href="#事件的创建和删除" class="headerlink" title="事件的创建和删除"></a>事件的创建和删除</h3><p>针对事件的创建和删除的API有：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建文件事件</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask,</span></span></div><div class="line">        aeFileProc *proc, <span class="keyword">void</span> *clientData);</div><div class="line"><span class="comment">// 删除文件事件</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeDeleteFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span></span>;</div><div class="line"><span class="comment">// 根据文件描述符获取文件事件</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeGetFileEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这些接口的实现都比较简单，就是在<code>eventLoop</code>这个事件池中创建（删除）指定属性的事件</p>
<p>需要使用到事件的创建的地方有两个：</p>
<ul>
<li>一个是在初始化服务器的时候，需要添加一个对应套接字描述符的监听套接字来监听新的客户端连接</li>
<li>新的客户端连接的时候，需要添加一个文件事件来监听这个客户端的请求</li>
</ul>
<h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p>在Linux/Unix中实现I/O多路复用的方法有非常多，大致有select、 epoll、 export和 kqueue这些IO多路复用函数库来实现的</p>
<p>各种实现的性能也是不一样的，之前我写了一篇博客<a href="/2018/04/20/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8BSelect%E3%80%81Poll%E5%92%8CEpoll/">对比了三种I/O多路复用</a></p>
<p>在Redis中，其会根据具体底层操作系统的不同自动选择系统中性能最高的I/O多路复用函数库来作为 Redis的I/O多路复用程序的底层实现（从程序中看，其性能的排行应该是evport &gt; epoll &gt; kqueue &gt; select ）:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Include the best multiplexing layer supported by this system.</span></div><div class="line"> * The following should be ordered by performances, descending. */</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EVPORT</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_evport.c"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EPOLL</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_epoll.c"</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_KQUEUE</span></div><div class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_kqueue.c"</span></span></div><div class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_select.c"</span></span></div><div class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>各种不同的I/O多路复用库的使用方式是不一样的，所以Redis对功能进行了统一的封装，方便在不同的环境下的使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建，初始化</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span></span>;</div><div class="line"><span class="comment">// 改变能够监听事件的大小值</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiResize</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> setsize)</span></span>;</div><div class="line"><span class="comment">// 清空</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aeApiFree</span><span class="params">(aeEventLoop *eventLoop)</span></span>;</div><div class="line"><span class="comment">// 添加监听事件</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span></span>;</div><div class="line"><span class="comment">// 删除监听事件</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aeApiDelEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> delmask)</span></span>;</div><div class="line"><span class="comment">// 取出已经就绪的文件描述符</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">struct</span> timeval *tvp)</span></span></div></pre></td></tr></table></figure>
<p>下面以我比较熟悉的epoll为例查看封装的实现：</p>
<p>首先定义一个ae状态结构体，事实上就是epoll的文件描述符和一个获取监听事件中就绪文件描述符的文件表<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeApiState &#123;</div><div class="line">    <span class="keyword">int</span> epfd;</div><div class="line">    <span class="keyword">struct</span> epoll_event *events;</div><div class="line">&#125; aeApiState;</div></pre></td></tr></table></figure></p>
<p>创建的过程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</div><div class="line">    aeApiState *state = zmalloc(<span class="keyword">sizeof</span>(aeApiState));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!state) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="comment">// 监听指定大小的事件数量</span></div><div class="line">    state-&gt;events = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event)*eventLoop-&gt;setsize);</div><div class="line">    <span class="keyword">if</span> (!state-&gt;events) &#123;</div><div class="line">        zfree(state);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 创建epoll</span></div><div class="line">    state-&gt;epfd = epoll_create(<span class="number">1024</span>); <span class="comment">/* 1024 is just a hint for the kernel */</span></div><div class="line">    <span class="keyword">if</span> (state-&gt;epfd == <span class="number">-1</span>) &#123;</div><div class="line">        zfree(state-&gt;events);</div><div class="line">        zfree(state);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 指定数据</span></div><div class="line">    eventLoop-&gt;apidata = state;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>添加监听事件过程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span> </span>&#123;</div><div class="line">    aeApiState *state = eventLoop-&gt;apidata;</div><div class="line">    <span class="keyword">struct</span> epoll_event ee;</div><div class="line">    <span class="comment">/* If the fd was already monitored for some event, we need a MOD</span></div><div class="line">     * operation. Otherwise we need an ADD operation. */</div><div class="line">    <span class="keyword">int</span> op = eventLoop-&gt;events[fd].mask == AE_NONE ?</div><div class="line">            EPOLL_CTL_ADD : EPOLL_CTL_MOD;</div><div class="line"></div><div class="line">    ee.events = <span class="number">0</span>;</div><div class="line">    mask |= eventLoop-&gt;events[fd].mask; <span class="comment">/* Merge old events */</span></div><div class="line">    <span class="comment">// 根据时间的mask来决定监听读or写就绪</span></div><div class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;</div><div class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</div><div class="line">    ee.data.u64 = <span class="number">0</span>; <span class="comment">/* avoid valgrind warning */</span></div><div class="line">    ee.data.fd = fd;</div><div class="line">    <span class="comment">// 添加监听事件到内核中</span></div><div class="line">    <span class="keyword">if</span> (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="文件事件的处理"><a href="#文件事件的处理" class="headerlink" title="文件事件的处理"></a>文件事件的处理</h3><p>I/O多路复用接收到了就绪的事件的时候，就需要对事件进行处理，通过文件事件分派器来分派给不同的文件事件处理器，具体需要处理的文件事件类型如下：</p>
<ul>
<li>为了对连接服务器的各个客户端进行应答,服务器要为监听套接字关联连接应答处理器。</li>
<li>为了接收客户端传来的命令请求,服务器要为客户端套接字关联命令请求处理器。</li>
<li>为了向客户端返回命令的执行结果,服务器要为客户端套接字关联命令回复处理器。</li>
<li>当主服务器和从服务器进行复制操作时,主从服务器都需要关联特别为复制功能编写的复制处理器。</li>
</ul>
<p>值得注意的是连接应答处理时，需要新添加一个监听事件</p>
<blockquote>
<p>连接应答处理</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptTcpHandler</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> cport, cfd, max = MAX_ACCEPTS_PER_CALL;</div><div class="line">    <span class="keyword">char</span> cip[REDIS_IP_STR_LEN];</div><div class="line">    REDIS_NOTUSED(el);</div><div class="line">    REDIS_NOTUSED(mask);</div><div class="line">    REDIS_NOTUSED(privdata);</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(max--) &#123;</div><div class="line">        <span class="comment">// accept 客户端连接</span></div><div class="line">        cfd = anetTcpAccept(server.neterr, fd, cip, <span class="keyword">sizeof</span>(cip), &amp;cport);</div><div class="line">        <span class="keyword">if</span> (cfd == ANET_ERR) &#123;</div><div class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK)</div><div class="line">                redisLog(REDIS_WARNING,</div><div class="line">                    <span class="string">"Accepting client connection: %s"</span>, server.neterr);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        redisLog(REDIS_VERBOSE,<span class="string">"Accepted %s:%d"</span>, cip, cport);</div><div class="line">        <span class="comment">// 为客户端创建客户端状态（redisClient）</span></div><div class="line">        acceptCommonHandler(cfd,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过Redis对上面几种事件的应答处理，我们可以得出客户端和服务端的通信模型如下：</p>
<p><img src="http://data3.liuin.cn/2018-06-17-15292047392028.jpg" alt=""></p>
<h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>Redis的时间事件分为以下两类:</p>
<ul>
<li>定时事件:让一段程序在指定的时间之后执行一次。比如说,让程序X在当前时间的30毫秒之后执行一次。</li>
<li>周期性事件:让一段程序每隔指定时间就执行一次。比如说,让程序Y每隔30毫秒就执行一次。</li>
</ul>
<h3 id="事件结构定义-1"><a href="#事件结构定义-1" class="headerlink" title="事件结构定义"></a>事件结构定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeTimeEvent &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 时间事件的唯一标识符</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id; <span class="comment">/* time event identifier. */</span></div><div class="line">    <span class="comment">// 事件的到达时间</span></div><div class="line">    <span class="keyword">long</span> when_sec; <span class="comment">/* seconds */</span></div><div class="line">    <span class="keyword">long</span> when_ms; <span class="comment">/* milliseconds */</span></div><div class="line">    <span class="comment">// 事件处理函数</span></div><div class="line">    aeTimeProc *timeProc;</div><div class="line">    <span class="comment">// 事件释放函数</span></div><div class="line">    aeEventFinalizerProc *finalizerProc;</div><div class="line">    <span class="comment">// 多路复用库的私有数据</span></div><div class="line">    <span class="keyword">void</span> *clientData;</div><div class="line">    <span class="comment">// 指向下个时间事件结构，形成链表</span></div><div class="line">    <span class="keyword">struct</span> aeTimeEvent *next;</div><div class="line"></div><div class="line">&#125; aeTimeEvent;</div></pre></td></tr></table></figure>
<p>服务器将所有时间事件都放在一个无序链表中,每当时间事件执行器运行时,它就遍历整个链表,查找所有已到达的时间事件,并调用相应的事件处理器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 已就绪事件</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeFiredEvent &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 已就绪文件描述符</span></div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line"></div><div class="line">    <span class="comment">// 事件类型掩码，</span></div><div class="line">    <span class="comment">// 值可以是 AE_READABLE 或 AE_WRITABLE</span></div><div class="line">    <span class="comment">// 或者是两者的或</span></div><div class="line">    <span class="keyword">int</span> mask;</div><div class="line"></div><div class="line">&#125; aeFiredEvent;</div></pre></td></tr></table></figure>
<h3 id="时间事件相关API"><a href="#时间事件相关API" class="headerlink" title="时间事件相关API"></a>时间事件相关API</h3><p>时间事件相关API如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建时间事件</span></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">aeCreateTimeEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> milliseconds,</span></span></div><div class="line">        aeTimeProc *proc, <span class="keyword">void</span> *clientData,</div><div class="line">        aeEventFinalizerProc *finalizerProc);</div><div class="line"><span class="comment">// 删除时间事件</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeDeleteTimeEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id)</span></span>;</div><div class="line"><span class="comment">// 时间事件的执行器</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span>;</div><div class="line"><span class="comment">// 返回最近的时间事件</span></div><div class="line"><span class="function"><span class="keyword">static</span> aeTimeEvent *<span class="title">aeSearchNearestTimer</span><span class="params">(aeEventLoop *eventLoop)</span></span>;</div></pre></td></tr></table></figure>
<p>创建和删除时间事件的实现都比较简单，相当于构造和析构函数，我们先看看时间事件执行器的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">processTimeEvents</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>;</div><div class="line">    aeTimeEvent *te;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxId;</div><div class="line">    <span class="keyword">time_t</span> now = time(<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 通过重置事件的运行时间，</span></div><div class="line">    <span class="comment">// 防止因时间穿插（skew）而造成的事件处理混乱</span></div><div class="line">    <span class="keyword">if</span> (now &lt; eventLoop-&gt;lastTime) &#123;</div><div class="line">        te = eventLoop-&gt;timeEventHead;</div><div class="line">        <span class="keyword">while</span>(te) &#123;</div><div class="line">            te-&gt;when_sec = <span class="number">0</span>;</div><div class="line">            te = te-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 更新最后一次处理时间事件的时间</span></div><div class="line">    eventLoop-&gt;lastTime = now;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历链表</span></div><div class="line">    <span class="comment">// 执行那些已经到达的事件</span></div><div class="line">    te = eventLoop-&gt;timeEventHead;</div><div class="line">    maxId = eventLoop-&gt;timeEventNextId<span class="number">-1</span>;</div><div class="line">    <span class="keyword">while</span>(te) &#123;</div><div class="line">        <span class="keyword">long</span> now_sec, now_ms;</div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> id;</div><div class="line"></div><div class="line">        <span class="comment">// 跳过无效事件</span></div><div class="line">        <span class="keyword">if</span> (te-&gt;id &gt; maxId) &#123;</div><div class="line">            te = te-&gt;next;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 获取当前时间</span></div><div class="line">        aeGetTime(&amp;now_sec, &amp;now_ms);</div><div class="line"></div><div class="line">        <span class="comment">// 如果当前时间等于或等于事件的执行时间，那么说明事件已到达，执行这个事件</span></div><div class="line">        <span class="keyword">if</span> (now_sec &gt; te-&gt;when_sec ||</div><div class="line">            (now_sec == te-&gt;when_sec &amp;&amp; now_ms &gt;= te-&gt;when_ms))</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> retval;</div><div class="line"></div><div class="line">            id = te-&gt;id;</div><div class="line">            <span class="comment">// 执行事件处理器，并获取返回值</span></div><div class="line">            retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);</div><div class="line">            processed++;</div><div class="line"></div><div class="line">            <span class="comment">// 记录是否有需要循环执行这个事件时间</span></div><div class="line">            <span class="keyword">if</span> (retval != AE_NOMORE) &#123;</div><div class="line">                <span class="comment">// 是的， retval 毫秒之后继续执行这个时间事件</span></div><div class="line">                aeAddMillisecondsToNow(retval,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 不，将这个事件删除</span></div><div class="line">                aeDeleteTimeEvent(eventLoop, id);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 因为执行事件之后，事件列表可能已经被改变了</span></div><div class="line">            <span class="comment">// 因此需要将 te 放回表头，继续开始执行事件</span></div><div class="line">            te = eventLoop-&gt;timeEventHead;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            te = te-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> processed;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其总体的思想是：遍历所有已到达的时间事件并调用这些事件的处理器。已到达指的是,时间事件的when属性记录的UNIX时间截等于或小于当前时间的UNIX时间戳。</p>
<p><code>aeSearchNearestTimer</code>返回目前时间最近的时间事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 寻找里目前时间最近的时间事件</span></div><div class="line"><span class="comment">// 因为链表是乱序的，所以查找复杂度为 O（N）</span></div><div class="line"><span class="function"><span class="keyword">static</span> aeTimeEvent *<span class="title">aeSearchNearestTimer</span><span class="params">(aeEventLoop *eventLoop)</span></span></div><div class="line">&#123;</div><div class="line">    aeTimeEvent *te = eventLoop-&gt;timeEventHead;</div><div class="line">    aeTimeEvent *nearest = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(te) &#123;</div><div class="line">        <span class="keyword">if</span> (!nearest || te-&gt;when_sec &lt; nearest-&gt;when_sec ||</div><div class="line">                (te-&gt;when_sec == nearest-&gt;when_sec &amp;&amp;</div><div class="line">                 te-&gt;when_ms &lt; nearest-&gt;when_ms))</div><div class="line">            nearest = te;</div><div class="line">        te = te-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> nearest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="时间事件的处理"><a href="#时间事件的处理" class="headerlink" title="时间事件的处理"></a>时间事件的处理</h3><p>时间事件的主要处理应用在<code>serverCron</code>中，其函数的主要工作有：</p>
<ul>
<li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用等</li>
<li>清理数据库中的过期键值对</li>
<li>关闭和清理连接失效的客户端</li>
<li>尝试进行AOF和RDB持久化操作</li>
<li>如果是主服务器，就对从服务器进行定期同步</li>
<li>如果是集群模式，对集群进行定期同步和连接测试</li>
</ul>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>时间事件和文件事件都在一个事件循环结构体中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeEventLoop &#123;</div><div class="line">    <span class="comment">// 目前已注册的最大描述符</span></div><div class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">/* highest file descriptor currently registered */</span></div><div class="line">    <span class="comment">// 目前已追踪的最大描述符</span></div><div class="line">    <span class="keyword">int</span> setsize; <span class="comment">/* max number of file descriptors tracked */</span></div><div class="line">    <span class="comment">// 用于生成时间事件 id</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId;</div><div class="line">    <span class="comment">// 最后一次执行时间事件的时间</span></div><div class="line">    <span class="keyword">time_t</span> lastTime;     <span class="comment">/* Used to detect system clock skew */</span></div><div class="line">    <span class="comment">// 已注册的文件事件</span></div><div class="line">    aeFileEvent *events; <span class="comment">/* Registered events */</span></div><div class="line">    <span class="comment">// 已就绪的文件事件</span></div><div class="line">    aeFiredEvent *fired; <span class="comment">/* Fired events */</span></div><div class="line">    <span class="comment">// 时间事件</span></div><div class="line">    aeTimeEvent *timeEventHead;</div><div class="line">    <span class="comment">// 事件处理器的开关</span></div><div class="line">    <span class="keyword">int</span> stop;</div><div class="line">    <span class="comment">// 多路复用库的私有数据</span></div><div class="line">    <span class="keyword">void</span> *apidata; <span class="comment">/* This is used for polling API specific data */</span></div><div class="line">    <span class="comment">// 在处理事件前要执行的函数</span></div><div class="line">    aeBeforeSleepProc *beforesleep;</div><div class="line"></div><div class="line">&#125; aeEventLoop;</div></pre></td></tr></table></figure>
<p>在加入事件到进行处理事件中间的环节就是事件循环了，其调用的是<code>aeMain</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</div><div class="line"></div><div class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 如果有需要在事件处理前执行的函数，那么运行它</span></div><div class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</div><div class="line">            eventLoop-&gt;beforesleep(eventLoop);</div><div class="line"></div><div class="line">        <span class="comment">// 开始处理事件</span></div><div class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，当服务器开始运行的时候，事件循环就不停运行，其事件处理函数<code>aeProcessEvents</code>实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</div><div class="line"></div><div class="line">    <span class="comment">/* Nothing to do? return ASAP */</span></div><div class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</div><div class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">struct</span> timeval tv, *tvp;</div><div class="line"></div><div class="line">        <span class="comment">// 获取最近的时间事件</span></div><div class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</div><div class="line">            shortest = aeSearchNearestTimer(eventLoop);</div><div class="line">        <span class="keyword">if</span> (shortest) &#123;</div><div class="line">            <span class="comment">// 如果时间事件存在的话</span></div><div class="line">            <span class="comment">// 那么根据最近可执行时间事件和现在时间的时间差来决定文件事件的阻塞时间</span></div><div class="line">            <span class="keyword">long</span> now_sec, now_ms;</div><div class="line"></div><div class="line">            <span class="comment">// 计算距今最近的时间事件还要多久才能达到</span></div><div class="line">            <span class="comment">// 并将该时间距保存在 tv 结构中</span></div><div class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</div><div class="line">            tvp = &amp;tv;</div><div class="line">            tvp-&gt;tv_sec = shortest-&gt;when_sec - now_sec;</div><div class="line">            <span class="keyword">if</span> (shortest-&gt;when_ms &lt; now_ms) &#123;</div><div class="line">                tvp-&gt;tv_usec = ((shortest-&gt;when_ms+<span class="number">1000</span>) - now_ms)*<span class="number">1000</span>;</div><div class="line">                tvp-&gt;tv_sec --;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                tvp-&gt;tv_usec = (shortest-&gt;when_ms - now_ms)*<span class="number">1000</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 时间差小于 0 ，说明事件已经可以执行了，将秒和毫秒设为 0 （不阻塞）</span></div><div class="line">            <span class="keyword">if</span> (tvp-&gt;tv_sec &lt; <span class="number">0</span>) tvp-&gt;tv_sec = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (tvp-&gt;tv_usec &lt; <span class="number">0</span>) tvp-&gt;tv_usec = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            </div><div class="line">            <span class="comment">// 执行到这一步，说明没有时间事件</span></div><div class="line">            <span class="comment">// 那么根据 AE_DONT_WAIT 是否设置来决定是否阻塞，以及阻塞的时间长度</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</div><div class="line">                <span class="comment">// 设置文件事件不阻塞</span></div><div class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</div><div class="line">                tvp = &amp;tv;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">/* Otherwise we can block */</span></div><div class="line">                <span class="comment">// 文件事件可以阻塞直到有事件到达为止</span></div><div class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 处理文件事件，阻塞时间由 tvp 决定</span></div><div class="line">        numevents = aeApiPoll(eventLoop, tvp);</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</div><div class="line">            <span class="comment">// 从已就绪数组中获取事件</span></div><div class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</div><div class="line"></div><div class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</div><div class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</div><div class="line">            <span class="keyword">int</span> rfired = <span class="number">0</span>;</div><div class="line"></div><div class="line">            <span class="comment">// 读事件</span></div><div class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</div><div class="line">                <span class="comment">// rfired 确保读/写事件只能执行其中一个</span></div><div class="line">                rfired = <span class="number">1</span>;</div><div class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 写事件</span></div><div class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</div><div class="line">                <span class="keyword">if</span> (!rfired || fe-&gt;wfileProc != fe-&gt;rfileProc)</div><div class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            processed++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Check time events */</span></div><div class="line">    <span class="comment">// 执行时间事件</span></div><div class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</div><div class="line">        processed += processTimeEvents(eventLoop);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其主题的逻辑如下：</p>
<ul>
<li>查找最早的时间事件，判断是否需要执行，如需要，就标记下来，等待处理，并确定后面处理文件事件的阻塞时间</li>
<li>获取已准备好的文件事件描述符集</li>
<li>优先处理读事件</li>
<li>处理写事件</li>
<li>如有时间事件，就处理时间事件</li>
</ul>
<p><img src="http://data3.liuin.cn/2018-06-17-15292178140041.jpg" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过对Redis的时间事件和文件事件的解析，能够了解Redis客户端和服务端交互的基本过程，同时也能够了解到Redis是单线程的，整个事件循环是串行的</p>
]]></content>
      
        <categories>
            
            <category> 源码剖析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析——AOF持久化]]></title>
      <url>/2018/06/10/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94AOF%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>对RDB持久化的实现过程进行剖析</p>
<a id="more"></a>
<p>前面讲了RDB持久化的实现，其主要保存的是数据库中的键值对。除了RDB持久化功能之外, Redis还提供了AOF(Append Only File)持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同,AOF持久化是通过<strong>保存Redis服务器所执行的写命令</strong>来记录数据库状态的。</p>
<p><img src="http://data3.liuin.cn/2018-06-12-15287641912469.jpg" alt=""></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="服务器中的缓冲区"><a href="#服务器中的缓冲区" class="headerlink" title="服务器中的缓冲区"></a>服务器中的缓冲区</h3><p>在Redis中服务器状态结构体<code>redisServer</code>中有一个字段是<code>aof_buf</code>的缓冲区，当服务器执行完一条命令以后会以协议格式将被执行的写命令追加到服务器状态的<code>aof_buf</code>缓冲区的末尾:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> redisServer &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// AOF 状态（开启/关闭/可写）</span></div><div class="line">    <span class="keyword">int</span> aof_state;                  <span class="comment">/* REDIS_AOF_(ON|OFF|WAIT_REWRITE) */</span></div><div class="line">    </div><div class="line">    <span class="comment">// AOF 缓冲区</span></div><div class="line">    sds aof_buf;      <span class="comment">/* AOF buffer, written before entering the event loop */</span></div><div class="line"></div><div class="line">    <span class="comment">// AOF 文件的描述符</span></div><div class="line">    <span class="keyword">int</span> aof_fd;       <span class="comment">/* File descriptor of currently selected AOF file */</span></div><div class="line"></div><div class="line">    <span class="comment">// AOF 的当前目标数据库</span></div><div class="line">    <span class="keyword">int</span> aof_selected_db; <span class="comment">/* Currently selected DB in AOF */</span></div><div class="line">    ...</div></pre></td></tr></table></figure>
<h3 id="AOF文件的写入与同步"><a href="#AOF文件的写入与同步" class="headerlink" title="AOF文件的写入与同步"></a>AOF文件的写入与同步</h3><p>Redis的服务器进程就是一个事件循环(loop),这个循环中的文件事件负责接收客户端的命令请求,以及向客户端发送命令回复,而时间事件则负责执行像server_cron函数这样需要定时运行的函数。</p>
<p>因为服务器在处理文件事件时可能会执行写命令,使得一些内容被追加到 aof_buf缓冲区里面,所以在服务器每次结束一个事件循环之前,它都会调用<code>flushAppendOnlyFile</code>函数,考虑是否需要将 aof_buf缓冲区中的内容写人和保存到AOF文件里面</p>
<p>flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值来决定,各个不同值产生的行为</p>
<p><img src="http://data3.liuin.cn/2018-06-12-15287653307562.jpg" alt=""></p>
<p>命令写入实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedAppendOnlyFile</span><span class="params">(<span class="keyword">struct</span> redisCommand *cmd, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span> </span>&#123;</div><div class="line">    sds buf = sdsempty();</div><div class="line">    robj *tmpargv[<span class="number">3</span>];</div><div class="line"></div><div class="line">    <span class="comment">/* The DB this command was targeting is not the same as the last command</span></div><div class="line">     * we appendend. To issue a SELECT command is needed. </div><div class="line">     *</div><div class="line">     * 使用 SELECT 命令，显式设置数据库，确保之后的命令被设置到正确的数据库</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (dictid != server.aof_selected_db) &#123;</div><div class="line">        <span class="keyword">char</span> seldb[<span class="number">64</span>];</div><div class="line"></div><div class="line">        <span class="built_in">snprintf</span>(seldb,<span class="keyword">sizeof</span>(seldb),<span class="string">"%d"</span>,dictid);</div><div class="line">        buf = sdscatprintf(buf,<span class="string">"*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n"</span>,</div><div class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="built_in">strlen</span>(seldb),seldb);</div><div class="line"></div><div class="line">        server.aof_selected_db = dictid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="comment">// 省略其他命令的加入buff过程</span></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">/* Append to the AOF buffer. This will be flushed on disk just before</span></div><div class="line">     * of re-entering the event loop, so before the client will get a</div><div class="line">     * positive reply about the operation performed. </div><div class="line">     *</div><div class="line">     * 将命令追加到 AOF 缓存中，</div><div class="line">     * 在重新进入事件循环之前，这些命令会被冲洗到磁盘上，</div><div class="line">     * 并向客户端返回一个回复。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (server.aof_state == REDIS_AOF_ON)</div><div class="line">        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));</div><div class="line"></div><div class="line">    <span class="comment">/* If a background append only file rewriting is in progress we want to</span></div><div class="line">     * accumulate the differences between the child DB and the current one</div><div class="line">     * in a buffer, so that when the child process will do its work we</div><div class="line">     * can append the differences to the new append only file. </div><div class="line">     *</div><div class="line">     * 如果 BGREWRITEAOF 正在进行，</div><div class="line">     * 那么我们还需要将命令追加到重写缓存中，</div><div class="line">     * 从而记录当前正在重写的 AOF 文件和数据库当前状态的差异。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>)</div><div class="line">        aofRewriteBufferAppend((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf,sdslen(buf));</div><div class="line"></div><div class="line">    <span class="comment">// 释放</span></div><div class="line">    sdsfree(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>缓冲区人间写入AOF实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushAppendOnlyFile</span><span class="params">(<span class="keyword">int</span> force)</span> </span>&#123;</div><div class="line">    <span class="keyword">ssize_t</span> nwritten;</div><div class="line">    <span class="keyword">int</span> sync_in_progress = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 缓冲区中没有任何内容，直接返回</span></div><div class="line">    <span class="keyword">if</span> (sdslen(server.aof_buf) == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 策略为每秒 FSYNC </span></div><div class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC)</div><div class="line">        <span class="comment">// 是否有 SYNC 正在后台进行？</span></div><div class="line">        sync_in_progress = bioPendingJobsOfType(REDIS_BIO_AOF_FSYNC) != <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 每秒 fsync ，并且强制写入为假</span></div><div class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp; !force) &#123;</div><div class="line"></div><div class="line">        <span class="comment">/* With this append fsync policy we do background fsyncing.</span></div><div class="line">         *</div><div class="line">         * 当 fsync 策略为每秒钟一次时， fsync 在后台执行。</div><div class="line">         *</div><div class="line">         * If the fsync is still in progress we can try to delay</div><div class="line">         * the write for a couple of seconds. </div><div class="line">         *</div><div class="line">         * 如果后台仍在执行 FSYNC ，那么我们可以延迟写操作一两秒</div><div class="line">         * （如果强制执行 write 的话，服务器主线程将阻塞在 write 上面）</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (sync_in_progress) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 有 fsync 正在后台进行 。。。</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (server.aof_flush_postponed_start == <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">/* No previous write postponinig, remember that we are</span></div><div class="line">                 * postponing the flush and return. </div><div class="line">                 *</div><div class="line">                 * 前面没有推迟过 write 操作，这里将推迟写操作的时间记录下来</div><div class="line">                 * 然后就返回，不执行 write 或者 fsync</div><div class="line">                 */</div><div class="line">                server.aof_flush_postponed_start = server.unixtime;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.unixtime - server.aof_flush_postponed_start &lt; <span class="number">2</span>) &#123;</div><div class="line">                <span class="comment">/* We were already waiting for fsync to finish, but for less</span></div><div class="line">                 * than two seconds this is still ok. Postpone again. </div><div class="line">                 *</div><div class="line">                 * 如果之前已经因为 fsync 而推迟了 write 操作</div><div class="line">                 * 但是推迟的时间不超过 2 秒，那么直接返回</div><div class="line">                 * 不执行 write 或者 fsync</div><div class="line">                 */</div><div class="line">                <span class="keyword">return</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">/* Otherwise fall trough, and go write since we can't wait</span></div><div class="line">             * over two seconds. </div><div class="line">             *</div><div class="line">             * 如果后台还有 fsync 在执行，并且 write 已经推迟 &gt;= 2 秒</div><div class="line">             * 那么执行写操作（write 将被阻塞）</div><div class="line">             */</div><div class="line">            server.aof_delayed_fsync++;</div><div class="line">            redisLog(REDIS_NOTICE,<span class="string">"Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* If you are following this code path, then we are going to write so</span></div><div class="line">     * set reset the postponed flush sentinel to zero. </div><div class="line">     *</div><div class="line">     * 执行到这里，程序会对 AOF 文件进行写入。</div><div class="line">     *</div><div class="line">     * 清零延迟 write 的时间记录</div><div class="line">     */</div><div class="line">    server.aof_flush_postponed_start = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* We want to perform a single write. This should be guaranteed atomic</span></div><div class="line">     * at least if the filesystem we are writing is a real physical one.</div><div class="line">     *</div><div class="line">     * 执行单个 write 操作，如果写入设备是物理的话，那么这个操作应该是原子的</div><div class="line">     *</div><div class="line">     * While this will save us against the server being killed I don't think</div><div class="line">     * there is much to do about the whole server stopping for power problems</div><div class="line">     * or alike </div><div class="line">     *</div><div class="line">     * 当然，如果出现像电源中断这样的不可抗现象，那么 AOF 文件也是可能会出现问题的</div><div class="line">     * 这时就要用 redis-check-aof 程序来进行修复。</div><div class="line">     */</div><div class="line">    nwritten = write(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));</div><div class="line">    <span class="keyword">if</span> (nwritten != (<span class="keyword">signed</span>)sdslen(server.aof_buf)) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">static</span> <span class="keyword">time_t</span> last_write_error_log = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> can_log = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* Limit logging rate to 1 line per AOF_WRITE_LOG_ERROR_RATE seconds. */</span></div><div class="line">        <span class="comment">// 将日志的记录频率限制在每行 AOF_WRITE_LOG_ERROR_RATE 秒</span></div><div class="line">        <span class="keyword">if</span> ((server.unixtime - last_write_error_log) &gt; AOF_WRITE_LOG_ERROR_RATE) &#123;</div><div class="line">            can_log = <span class="number">1</span>;</div><div class="line">            last_write_error_log = server.unixtime;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Lof the AOF write error and record the error code. */</span></div><div class="line">        <span class="comment">// 如果写入出错，那么尝试将该情况写入到日志里面</span></div><div class="line">        <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (can_log) &#123;</div><div class="line">                redisLog(REDIS_WARNING,<span class="string">"Error writing to the AOF file: %s"</span>,</div><div class="line">                    strerror(errno));</div><div class="line">                server.aof_last_write_errno = errno;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (can_log) &#123;</div><div class="line">                redisLog(REDIS_WARNING,<span class="string">"Short write while writing to "</span></div><div class="line">                                       <span class="string">"the AOF file: (nwritten=%lld, "</span></div><div class="line">                                       <span class="string">"expected=%lld)"</span>,</div><div class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)nwritten,</div><div class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)sdslen(server.aof_buf));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 尝试移除新追加的不完整内容</span></div><div class="line">            <span class="keyword">if</span> (ftruncate(server.aof_fd, server.aof_current_size) == <span class="number">-1</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (can_log) &#123;</div><div class="line">                    redisLog(REDIS_WARNING, <span class="string">"Could not remove short write "</span></div><div class="line">                             <span class="string">"from the append-only file.  Redis may refuse "</span></div><div class="line">                             <span class="string">"to load the AOF the next time it starts.  "</span></div><div class="line">                             <span class="string">"ftruncate: %s"</span>, strerror(errno));</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">/* If the ftrunacate() succeeded we can set nwritten to</span></div><div class="line">                 * -1 since there is no longer partial data into the AOF. */</div><div class="line">                nwritten = <span class="number">-1</span>;</div><div class="line">            &#125;</div><div class="line">            server.aof_last_write_errno = ENOSPC;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Handle the AOF write error. */</span></div><div class="line">        <span class="comment">// 处理写入 AOF 文件时出现的错误</span></div><div class="line">        <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</div><div class="line">            <span class="comment">/* We can't recover when the fsync policy is ALWAYS since the</span></div><div class="line">             * reply for the client is already in the output buffers, and we</div><div class="line">             * have the contract with the user that on acknowledged write data</div><div class="line">             * is synched on disk. */</div><div class="line">            redisLog(REDIS_WARNING,<span class="string">"Can't recover from AOF write error when the AOF fsync policy is 'always'. Exiting..."</span>);</div><div class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/* Recover from failed write leaving data into the buffer. However</span></div><div class="line">             * set an error to stop accepting writes as long as the error</div><div class="line">             * condition is not cleared. */</div><div class="line">            server.aof_last_write_status = REDIS_ERR;</div><div class="line"></div><div class="line">            <span class="comment">/* Trim the sds buffer if there was a partial write, and there</span></div><div class="line">             * was no way to undo it with ftruncate(2). */</div><div class="line">            <span class="keyword">if</span> (nwritten &gt; <span class="number">0</span>) &#123;</div><div class="line">                server.aof_current_size += nwritten;</div><div class="line">                sdsrange(server.aof_buf,nwritten,<span class="number">-1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>; <span class="comment">/* We'll try again on the next call... */</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* Successful write(2). If AOF was in error state, restore the</span></div><div class="line">         * OK state and log the event. */</div><div class="line">        <span class="comment">// 写入成功，更新最后写入状态</span></div><div class="line">        <span class="keyword">if</span> (server.aof_last_write_status == REDIS_ERR) &#123;</div><div class="line">            redisLog(REDIS_WARNING,</div><div class="line">                <span class="string">"AOF write error looks solved, Redis can write again."</span>);</div><div class="line">            server.aof_last_write_status = REDIS_OK;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 更新写入后的 AOF 文件大小</span></div><div class="line">    server.aof_current_size += nwritten;</div><div class="line"></div><div class="line">    <span class="comment">/* Re-use AOF buffer when it is small enough. The maximum comes from the</span></div><div class="line">     * arena size of 4k minus some overhead (but is otherwise arbitrary). </div><div class="line">     *</div><div class="line">     * 如果 AOF 缓存的大小足够小的话，那么重用这个缓存，</div><div class="line">     * 否则的话，释放 AOF 缓存。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) &lt; <span class="number">4000</span>) &#123;</div><div class="line">        <span class="comment">// 清空缓存中的内容，等待重用</span></div><div class="line">        sdsclear(server.aof_buf);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 释放缓存</span></div><div class="line">        sdsfree(server.aof_buf);</div><div class="line">        server.aof_buf = sdsempty();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Don't fsync if no-appendfsync-on-rewrite is set to yes and there are</span></div><div class="line">     * children doing I/O in the background. </div><div class="line">     *</div><div class="line">     * 如果 no-appendfsync-on-rewrite 选项为开启状态，</div><div class="line">     * 并且有 BGSAVE 或者 BGREWRITEAOF 正在进行的话，</div><div class="line">     * 那么不执行 fsync </div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (server.aof_no_fsync_on_rewrite &amp;&amp;</div><div class="line">        (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Perform the fsync if needed. */</span></div><div class="line"></div><div class="line">    <span class="comment">// 总是执行 fsnyc</span></div><div class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</div><div class="line">        <span class="comment">/* aof_fsync is defined as fdatasync() for Linux in order to avoid</span></div><div class="line">         * flushing metadata. */</div><div class="line">        aof_fsync(server.aof_fd); <span class="comment">/* Let's try to get this data on the disk */</span></div><div class="line"></div><div class="line">        <span class="comment">// 更新最后一次执行 fsnyc 的时间</span></div><div class="line">        server.aof_last_fsync = server.unixtime;</div><div class="line"></div><div class="line">    <span class="comment">// 策略为每秒 fsnyc ，并且距离上次 fsync 已经超过 1 秒</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</div><div class="line">                server.unixtime &gt; server.aof_last_fsync)) &#123;</div><div class="line">        <span class="comment">// 放到后台执行</span></div><div class="line">        <span class="keyword">if</span> (!sync_in_progress) aof_background_fsync(server.aof_fd);</div><div class="line">        <span class="comment">// 更新最后一次执行 fsync 的时间</span></div><div class="line">        server.aof_last_fsync = server.unixtime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 其实上面无论执行 if 部分还是 else 部分都要更新 fsync 的时间</span></div><div class="line">    <span class="comment">// 可以将代码挪到下面来</span></div><div class="line">    <span class="comment">// server.aof_last_fsync = server.unixtime;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于三种不同的策略其效率和安全性能是不一样的：</p>
<ul>
<li><code>always</code>因为在每一个事件循环中都需要将所有的内容写入AOF文件，所以其效率是最低的，但是其安全性是最高的</li>
<li><code>everysec</code>是一个效率和安全性的折中。从效率上来讲, everysec模式足够快,并且就算出现故障停机,数据库也只丢失一秒钟的命令数据。</li>
<li><code>no</code>的同步时间需要有操作系统控制，这样其效率比较高但是安全性就比较差了</li>
</ul>
<h2 id="文件载入和数据的还原"><a href="#文件载入和数据的还原" class="headerlink" title="文件载入和数据的还原"></a>文件载入和数据的还原</h2><p>因为AOF文件里面包含了重建数据库状态所需的所有写命令,所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令,就可以还原服务器关闭之前的数据库状态。</p>
<p><img src="http://data3.liuin.cn/2018-06-12-15287660987749.jpg" alt=""></p>
<p>其底层主要通过<code>loadAppendOnlyFile</code>这个函数实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 执行 AOF 文件中的命令。</div><div class="line"> *</div><div class="line"> * 出错时返回 REDIS_OK 。</div><div class="line"> *</div><div class="line"> * 出现非执行错误（比如文件长度为 0 ）时返回 REDIS_ERR 。</div><div class="line"> *</div><div class="line"> * 出现致命错误时打印信息到日志，并且程序退出。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 为客户端</span></div><div class="line">    <span class="keyword">struct</span> redisClient *fakeClient;</div><div class="line"></div><div class="line">    <span class="comment">// 打开 AOF 文件</span></div><div class="line">    FILE *fp = fopen(filename,<span class="string">"r"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> redis_stat sb;</div><div class="line">    <span class="keyword">int</span> old_aof_state = server.aof_state;</div><div class="line">    <span class="keyword">long</span> loops = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 检查文件的正确性</span></div><div class="line">    <span class="keyword">if</span> (fp &amp;&amp; redis_fstat(fileno(fp),&amp;sb) != <span class="number">-1</span> &amp;&amp; sb.st_size == <span class="number">0</span>) &#123;</div><div class="line">        server.aof_current_size = <span class="number">0</span>;</div><div class="line">        fclose(fp);</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 检查文件是否正常打开</span></div><div class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Fatal error: can't open the append log file for reading: %s"</span>,strerror(errno));</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 暂时性地关闭 AOF ，防止在执行 MULTI 时，</div><div class="line">     * EXEC 命令被传播到正在打开的 AOF 文件中。</div><div class="line">     */</div><div class="line">    server.aof_state = REDIS_AOF_OFF;</div><div class="line"></div><div class="line">    fakeClient = createFakeClient();</div><div class="line"></div><div class="line">    <span class="comment">// 设置服务器的状态为：正在载入</span></div><div class="line">    <span class="comment">// startLoading 定义于 rdb.c</span></div><div class="line">    startLoading(fp);</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="comment">// 省略载入过程</span></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 如果能执行到这里，说明 AOF 文件的全部内容都可以正确地读取，</div><div class="line">     * 但是，还要检查 AOF 是否包含未正确结束的事务</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (fakeClient-&gt;flags &amp; REDIS_MULTI) <span class="keyword">goto</span> readerr;</div><div class="line"></div><div class="line">    <span class="comment">// 关闭 AOF 文件</span></div><div class="line">    fclose(fp);</div><div class="line">    <span class="comment">// 释放伪客户端</span></div><div class="line">    freeFakeClient(fakeClient);</div><div class="line">    <span class="comment">// 复原 AOF 状态</span></div><div class="line">    server.aof_state = old_aof_state;</div><div class="line">    <span class="comment">// 停止载入</span></div><div class="line">    stopLoading();</div><div class="line">    <span class="comment">// 更新服务器状态中， AOF 文件的当前大小</span></div><div class="line">    aofUpdateCurrentSize();</div><div class="line">    <span class="comment">// 记录前一次重写时的大小</span></div><div class="line">    server.aof_rewrite_base_size = server.aof_current_size;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div></pre></td></tr></table></figure>
<h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>因为AOF持久化是通过保存被执行的写命令来记录数据库状态的,所以随着服务器运行时间的流逝,AOF文件中的内容会越来越多,文件的体积也会越来越大,如果不加以控制的话,体积过大的AOF文件很可能对 Redis服务器、甚至整个宿主计算机造成影响,并且AOF文件的体积越大,便用AOF文件来进行数据还原所需的时间就越多。</p>
<p>为了解决AOF文件体积膨胀的问题, Redis提供了AOF文件重写( rewrite)功能。通过该功能, Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件,新旧两个AOF文件所保存的数据库状态相同,但新AOF文件不会包含任何浪费空间的冗余命令,所以新AOF文件的体积通常会比旧AOF文件的体积要小得多。</p>
<h3 id="AOF重写实现"><a href="#AOF重写实现" class="headerlink" title="AOF重写实现"></a>AOF重写实现</h3><p>AOF重写部分的主要实现（遍历所有的键，通过命令进行插入）如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">        </div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="comment">/* Iterate this DB writing every entry </span></div><div class="line">         *</div><div class="line">         * 遍历数据库所有键，并通过命令将它们的当前状态（值）记录到新 AOF 文件中</div><div class="line">         */</div><div class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</div><div class="line">            sds keystr;</div><div class="line">            robj key, *o;</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> expiretime;</div><div class="line"></div><div class="line">            <span class="comment">// 取出键</span></div><div class="line">            keystr = dictGetKey(de);</div><div class="line"></div><div class="line">            <span class="comment">// 取出值</span></div><div class="line">            o = dictGetVal(de);</div><div class="line">            initStaticStringObject(key,keystr);</div><div class="line"></div><div class="line">            <span class="comment">// 取出过期时间</span></div><div class="line">            expiretime = getExpire(db,&amp;key);</div><div class="line"></div><div class="line">            <span class="comment">/* If this key is already expired skip it </span></div><div class="line">             *</div><div class="line">             * 如果键已经过期，那么跳过它，不保存</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (expiretime != <span class="number">-1</span> &amp;&amp; expiretime &lt; now) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">            <span class="comment">/* Save the key and associated value </span></div><div class="line">             *</div><div class="line">             * 根据值的类型，选择适当的命令来保存值</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (o-&gt;type == REDIS_STRING) &#123;</div><div class="line">                <span class="comment">/* Emit a SET command */</span></div><div class="line">                <span class="keyword">char</span> cmd[]=<span class="string">"*3\r\n$3\r\nSET\r\n"</span>;</div><div class="line">                <span class="keyword">if</span> (rioWrite(&amp;aof,cmd,<span class="keyword">sizeof</span>(cmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">                <span class="comment">/* Key and value */</span></div><div class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,&amp;key) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_LIST) &#123;</div><div class="line">                <span class="keyword">if</span> (rewriteListObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_SET) &#123;</div><div class="line">                <span class="keyword">if</span> (rewriteSetObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_ZSET) &#123;</div><div class="line">                <span class="keyword">if</span> (rewriteSortedSetObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_HASH) &#123;</div><div class="line">                <span class="keyword">if</span> (rewriteHashObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                redisPanic(<span class="string">"Unknown object type"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">/* Save the expire time </span></div><div class="line">             *</div><div class="line">             * 保存键的过期时间</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) &#123;</div><div class="line">                <span class="keyword">char</span> cmd[]=<span class="string">"*3\r\n$9\r\nPEXPIREAT\r\n"</span>;</div><div class="line"></div><div class="line">                <span class="comment">// 写入 PEXPIREAT expiretime 命令</span></div><div class="line">                <span class="keyword">if</span> (rioWrite(&amp;aof,cmd,<span class="keyword">sizeof</span>(cmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,&amp;key) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">                <span class="keyword">if</span> (rioWriteBulkLongLong(&amp;aof,expiretime) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div></pre></td></tr></table></figure>
<p>因为新的AOF文件只包含还原当前数据库所必须的命令，所以新AOF文件不会浪费任何空间。</p>
]]></content>
      
        <categories>
            
            <category> 源码剖析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析——RDB持久化]]></title>
      <url>/2018/06/05/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94RDB%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>对RDB实现持久化的过程进行剖析</p>
<a id="more"></a>
<h2 id="持久化概述"><a href="#持久化概述" class="headerlink" title="持久化概述"></a>持久化概述</h2><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>因为Redis数据库是基于内存的Key-Value型数据库，他的所有数据库状态都存储在内存里面，如果服务器进程退出，那么存放在内存中的所有Redis数据库的状态都将消失。为了避免这种情况发生，就需要一种将数据库状态从内存转移到磁盘中的技术。</p>
<p>持久化就是这样一种将数据库的状态从内存存储到磁盘中的技术，Redis提供两种持久化：RDB持久化和AOF持久化。</p>
<h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>Redis提供了RDB持久化功能,这个功能可以将 Redis在内存中的数据库状态保存到磁盘里面,避免数据意外丢失。RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件,通过该文件可以还原生成RDB文件时的数据库状态。</p>
<p><img src="http://data3.liuin.cn/2018-06-08-15284258851033.jpg" alt=""></p>
<h2 id="RDB命令"><a href="#RDB命令" class="headerlink" title="RDB命令"></a>RDB命令</h2><p>Redis中生成RDB文件有两个命令：SAVE和BGSAVE。</p>
<p>SAVE命令会阻塞Redis服务器进程,直到RDB文件创建完毕为止,在服务器进程阻塞期间,服务器不能处理任何命令请求；BGSAVE命令会派生出一个子进程,然后由子进程负责创建RDB文件,服务器进程(父进程)继续处理命令请求</p>
<p>由此可见BGSAVE的实现是在SAVE的基础上进行的。</p>
<p>RDB文件的载入工作是在服务器启动时自动执行的,所以Redis并没有专门用于载入RDB文件的命令,只要 Redis服务器在启动时检测到RDB文件存在,它就会自动载入RDB文件。</p>
<h3 id="生成RDB文件实现"><a href="#生成RDB文件实现" class="headerlink" title="生成RDB文件实现"></a>生成RDB文件实现</h3><p>在讲生成RDB文件前首先要讲一个Redis中对I/O进行封装的一个结构体：<code>rio</code>，这个结构体在基本I/O的基础上加了一些计算校验和，获取文件指针所在偏移量等功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> _rio &#123;</div><div class="line"></div><div class="line">    <span class="comment">/* Backend functions.</span></div><div class="line">     * Since this functions do not tolerate short writes or reads the return</div><div class="line">     * value is simplified to: zero on error, non zero on complete success. */</div><div class="line">    <span class="comment">// API</span></div><div class="line">    <span class="keyword">size_t</span> (*read)(<span class="keyword">struct</span> _rio *, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len);</div><div class="line">    <span class="keyword">size_t</span> (*write)(<span class="keyword">struct</span> _rio *, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len);</div><div class="line">    <span class="keyword">off_t</span> (*tell)(<span class="keyword">struct</span> _rio *);</div><div class="line"></div><div class="line">    <span class="comment">/* The update_cksum method if not NULL is used to compute the checksum of</span></div><div class="line">     * all the data that was read or written so far. The method should be</div><div class="line">     * designed so that can be called with the current checksum, and the buf</div><div class="line">     * and len fields pointing to the new block of data to add to the checksum</div><div class="line">     * computation. */</div><div class="line">    <span class="comment">// 校验和计算函数，每次有写入/读取新数据时都要计算一次</span></div><div class="line">    <span class="keyword">void</span> (*update_cksum)(<span class="keyword">struct</span> _rio *, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len);</div><div class="line"></div><div class="line">    <span class="comment">/* The current checksum */</span></div><div class="line">    <span class="comment">// 当前校验和</span></div><div class="line">    <span class="keyword">uint64_t</span> cksum;</div><div class="line"></div><div class="line">    <span class="comment">/* number of bytes read or written */</span></div><div class="line">    <span class="keyword">size_t</span> processed_bytes;</div><div class="line"></div><div class="line">    <span class="comment">/* maximum single read or write chunk size */</span></div><div class="line">    <span class="keyword">size_t</span> max_processing_chunk;</div><div class="line"></div><div class="line">    <span class="comment">/* Backend-specific vars. */</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">struct</span> &#123;</div><div class="line">            <span class="comment">// 缓存指针</span></div><div class="line">            sds ptr;</div><div class="line">            <span class="comment">// 偏移量</span></div><div class="line">            <span class="keyword">off_t</span> pos;</div><div class="line">        &#125; buffer;</div><div class="line"></div><div class="line">        <span class="keyword">struct</span> &#123;</div><div class="line">            <span class="comment">// 被打开文件的指针</span></div><div class="line">            FILE *fp;</div><div class="line">            <span class="comment">// 最近一次 fsync() 以来，写入的字节量</span></div><div class="line">            <span class="keyword">off_t</span> buffered; <span class="comment">/* Bytes written since last fsync. */</span></div><div class="line">            <span class="comment">// 写入多少字节之后，才会自动执行一次 fsync()</span></div><div class="line">            <span class="keyword">off_t</span> autosync; <span class="comment">/* fsync after 'autosync' bytes written. */</span></div><div class="line">        &#125; file;</div><div class="line">    &#125; io;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>SAVE的实现就是依靠<code>rio</code>的，其所有的I/O都是通过<code>rio</code>进行的。SAVE实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSave</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">    dictIterator *di = <span class="literal">NULL</span>;</div><div class="line">    dictEntry *de;</div><div class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</div><div class="line">    <span class="keyword">char</span> magic[<span class="number">10</span>];</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> now = mstime();</div><div class="line">    FILE *fp;</div><div class="line">    rio rdb;</div><div class="line">    <span class="keyword">uint64_t</span> cksum;</div><div class="line"></div><div class="line">    <span class="comment">// 创建临时文件</span></div><div class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">"temp-%d.rdb"</span>, (<span class="keyword">int</span>) getpid());</div><div class="line">    fp = fopen(tmpfile,<span class="string">"w"</span>);</div><div class="line">    <span class="keyword">if</span> (!fp) &#123;</div><div class="line">        redisLog(REDIS_WARNING, <span class="string">"Failed opening .rdb for saving: %s"</span>,</div><div class="line">            strerror(errno));</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化 I/O</span></div><div class="line">    rioInitWithFile(&amp;rdb,fp);</div><div class="line"></div><div class="line">    <span class="comment">// 设置校验和函数</span></div><div class="line">    <span class="keyword">if</span> (server.rdb_checksum)</div><div class="line">        rdb.update_cksum = rioGenericUpdateChecksum;</div><div class="line"></div><div class="line">    <span class="comment">// 写入 RDB 版本号</span></div><div class="line">    <span class="built_in">snprintf</span>(magic,<span class="keyword">sizeof</span>(magic),<span class="string">"REDIS%04d"</span>,REDIS_RDB_VERSION);</div><div class="line">    <span class="keyword">if</span> (rdbWriteRaw(&amp;rdb,magic,<span class="number">9</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历所有数据库</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 指向数据库</span></div><div class="line">        redisDb *db = server.db+j;</div><div class="line"></div><div class="line">        <span class="comment">// 指向数据库键空间</span></div><div class="line">        dict *d = db-&gt;dict;</div><div class="line"></div><div class="line">        <span class="comment">// 跳过空数据库</span></div><div class="line">        <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 创建键空间迭代器</span></div><div class="line">        di = dictGetSafeIterator(d);</div><div class="line">        <span class="keyword">if</span> (!di) &#123;</div><div class="line">            fclose(fp);</div><div class="line">            <span class="keyword">return</span> REDIS_ERR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Write the SELECT DB opcode </span></div><div class="line">         *</div><div class="line">         * 写入 DB 选择器</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (rdbSaveType(&amp;rdb,REDIS_RDB_OPCODE_SELECTDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line">        <span class="keyword">if</span> (rdbSaveLen(&amp;rdb,j) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">        <span class="comment">/* Iterate this DB writing every entry </span></div><div class="line">         *</div><div class="line">         * 遍历数据库，并写入每个键值对的数据</div><div class="line">         */</div><div class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</div><div class="line">            sds keystr = dictGetKey(de);</div><div class="line">            robj key, *o = dictGetVal(de);</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> expire;</div><div class="line">            </div><div class="line">            <span class="comment">// 根据 keystr ，在栈中创建一个 key 对象</span></div><div class="line">            initStaticStringObject(key,keystr);</div><div class="line"></div><div class="line">            <span class="comment">// 获取键的过期时间</span></div><div class="line">            expire = getExpire(db,&amp;key);</div><div class="line"></div><div class="line">            <span class="comment">// 保存键值对数据</span></div><div class="line">            <span class="keyword">if</span> (rdbSaveKeyValuePair(&amp;rdb,&amp;key,o,expire,now) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line">        &#125;</div><div class="line">        dictReleaseIterator(di);</div><div class="line">    &#125;</div><div class="line">    di = <span class="literal">NULL</span>; <span class="comment">/* So that we don't release it again on error. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* EOF opcode </span></div><div class="line">     *</div><div class="line">     * 写入 EOF 代码</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (rdbSaveType(&amp;rdb,REDIS_RDB_OPCODE_EOF) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">/* CRC64 checksum. It will be zero if checksum computation is disabled, the</span></div><div class="line">     * loading code skips the check in this case. </div><div class="line">     *</div><div class="line">     * CRC64 校验和。</div><div class="line">     *</div><div class="line">     * 如果校验和功能已关闭，那么 rdb.cksum 将为 0 ，</div><div class="line">     * 在这种情况下， RDB 载入时会跳过校验和检查。</div><div class="line">     */</div><div class="line">    cksum = rdb.cksum;</div><div class="line">    memrev64ifbe(&amp;cksum);</div><div class="line">    rioWrite(&amp;rdb,&amp;cksum,<span class="number">8</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* Make sure data will not remain on the OS's output buffers */</span></div><div class="line">    <span class="comment">// 冲洗缓存，确保数据已写入磁盘</span></div><div class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</div><div class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line">    <span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">/* Use RENAME to make sure the DB file is changed atomically only</span></div><div class="line">     * if the generate DB file is ok. </div><div class="line">     *</div><div class="line">     * 使用 RENAME ，原子性地对临时文件进行改名，覆盖原来的 RDB 文件。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Error moving temp DB file on the final destination: %s"</span>, strerror(errno));</div><div class="line">        unlink(tmpfile);</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 写入完成，打印日志</span></div><div class="line">    redisLog(REDIS_NOTICE,<span class="string">"DB saved on disk"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 清零数据库脏状态</span></div><div class="line">    server.dirty = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 记录最后一次完成 SAVE 的时间</span></div><div class="line">    server.lastsave = time(<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 记录最后一次执行 SAVE 的状态</span></div><div class="line">    server.lastbgsave_status = REDIS_OK;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line"></div><div class="line">werr:</div><div class="line">    <span class="comment">// 关闭文件</span></div><div class="line">    fclose(fp);</div><div class="line">    <span class="comment">// 删除文件</span></div><div class="line">    unlink(tmpfile);</div><div class="line"></div><div class="line">    redisLog(REDIS_WARNING,<span class="string">"Write error saving DB on disk: %s"</span>, strerror(errno));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (di) dictReleaseIterator(di);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> REDIS_ERR;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码逻辑上看，SAVE的实现还是比较简单的，首先写入一些Redis版本信息，然后将数据库中的所有数据写入文件，最后加上一个校验和。</p>
<p>BESAVE在SAVE的基础上还要实现一些新进程创建等任务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveBackground</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">    <span class="keyword">pid_t</span> childpid;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start;</div><div class="line"></div><div class="line">    <span class="comment">// 如果 BGSAVE 已经在执行，那么出错</span></div><div class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">    <span class="comment">// 记录 BGSAVE 执行前的数据库被修改次数</span></div><div class="line">    server.dirty_before_bgsave = server.dirty;</div><div class="line"></div><div class="line">    <span class="comment">// 最近一次尝试执行 BGSAVE 的时间</span></div><div class="line">    server.lastbgsave_try = time(<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// fork() 开始前的时间，记录 fork() 返回耗时用</span></div><div class="line">    start = ustime();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> retval;</div><div class="line"></div><div class="line">        <span class="comment">/* Child */</span></div><div class="line"></div><div class="line">        <span class="comment">// 关闭网络连接 fd</span></div><div class="line">        closeListeningSockets(<span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 设置进程的标题，方便识别</span></div><div class="line">        redisSetProcTitle(<span class="string">"redis-rdb-bgsave"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 执行保存操作</span></div><div class="line">        retval = rdbSave(filename);</div><div class="line"></div><div class="line">        <span class="comment">// 打印 copy-on-write 时使用的内存数</span></div><div class="line">        <span class="keyword">if</span> (retval == REDIS_OK) &#123;</div><div class="line">            <span class="keyword">size_t</span> private_dirty = zmalloc_get_private_dirty();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (private_dirty) &#123;</div><div class="line">                redisLog(REDIS_NOTICE,</div><div class="line">                    <span class="string">"RDB: %zu MB of memory used by copy-on-write"</span>,</div><div class="line">                    private_dirty/(<span class="number">1024</span>*<span class="number">1024</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 向父进程发送信号</span></div><div class="line">        exitFromChild((retval == REDIS_OK) ? <span class="number">0</span> : <span class="number">1</span>);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="comment">/* Parent */</span></div><div class="line"></div><div class="line">        <span class="comment">// 计算 fork() 执行的时间</span></div><div class="line">        server.stat_fork_time = ustime()-start;</div><div class="line"></div><div class="line">        <span class="comment">// 如果 fork() 出错，那么报告错误</span></div><div class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</div><div class="line">            server.lastbgsave_status = REDIS_ERR;</div><div class="line">            redisLog(REDIS_WARNING,<span class="string">"Can't save in background: fork: %s"</span>,</div><div class="line">                strerror(errno));</div><div class="line">            <span class="keyword">return</span> REDIS_ERR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 打印 BGSAVE 开始的日志</span></div><div class="line">        redisLog(REDIS_NOTICE,<span class="string">"Background saving started by pid %d"</span>,childpid);</div><div class="line"></div><div class="line">        <span class="comment">// 记录数据库开始 BGSAVE 的时间</span></div><div class="line">        server.rdb_save_time_start = time(<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 记录负责执行 BGSAVE 的子进程 ID</span></div><div class="line">        server.rdb_child_pid = childpid;</div><div class="line"></div><div class="line">        <span class="comment">// 关闭自动 rehash</span></div><div class="line">        updateDictResizePolicy();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> REDIS_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> REDIS_OK; <span class="comment">/* unreached */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RDB文件载入实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoad</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">    <span class="keyword">uint32_t</span> dbid;</div><div class="line">    <span class="keyword">int</span> type, rdbver;</div><div class="line">    redisDb *db = server.db+<span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> expiretime, now = mstime();</div><div class="line">    FILE *fp;</div><div class="line">    rio rdb;</div><div class="line"></div><div class="line">    <span class="comment">// 打开 rdb 文件</span></div><div class="line">    <span class="keyword">if</span> ((fp = fopen(filename,<span class="string">"r"</span>)) == <span class="literal">NULL</span>) <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化写入流</span></div><div class="line">    rioInitWithFile(&amp;rdb,fp);</div><div class="line">    rdb.update_cksum = rdbLoadProgressCallback;</div><div class="line">    rdb.max_processing_chunk = server.loading_process_events_interval_bytes;</div><div class="line">    <span class="keyword">if</span> (rioRead(&amp;rdb,buf,<span class="number">9</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">    buf[<span class="number">9</span>] = <span class="string">'\0'</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 检查版本号</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(buf,<span class="string">"REDIS"</span>,<span class="number">5</span>) != <span class="number">0</span>) &#123;</div><div class="line">        fclose(fp);</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Wrong signature trying to load DB from file"</span>);</div><div class="line">        errno = EINVAL;</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line">    rdbver = atoi(buf+<span class="number">5</span>);</div><div class="line">    <span class="keyword">if</span> (rdbver &lt; <span class="number">1</span> || rdbver &gt; REDIS_RDB_VERSION) &#123;</div><div class="line">        fclose(fp);</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Can't handle RDB format version %d"</span>,rdbver);</div><div class="line">        errno = EINVAL;</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将服务器状态调整到开始载入状态</span></div><div class="line">    startLoading(fp);</div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">        robj *key, *val;</div><div class="line">        expiretime = <span class="number">-1</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* Read type. </span></div><div class="line">         *</div><div class="line">         * 读入类型指示，决定该如何读入之后跟着的数据。</div><div class="line">         *</div><div class="line">         * 这个指示可以是 rdb.h 中定义的所有以</div><div class="line">         * REDIS_RDB_TYPE_* 为前缀的常量的其中一个</div><div class="line">         * 或者所有以 REDIS_RDB_OPCODE_* 为前缀的常量的其中一个</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> ((type = rdbLoadType(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">        <span class="comment">// 读入过期时间值</span></div><div class="line">        <span class="keyword">if</span> (type == REDIS_RDB_OPCODE_EXPIRETIME) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 以秒计算的过期时间</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> ((expiretime = rdbLoadTime(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">            <span class="comment">/* We read the time so we need to read the object type again. </span></div><div class="line">             *</div><div class="line">             * 在过期时间之后会跟着一个键值对，我们要读入这个键值对的类型</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> ((type = rdbLoadType(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">            <span class="comment">/* the EXPIRETIME opcode specifies time in seconds, so convert</span></div><div class="line">             * into milliseconds. </div><div class="line">             *</div><div class="line">             * 将格式转换为毫秒*/</div><div class="line">            expiretime *= <span class="number">1000</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == REDIS_RDB_OPCODE_EXPIRETIME_MS) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 以毫秒计算的过期时间</span></div><div class="line"></div><div class="line">            <span class="comment">/* Milliseconds precision expire times introduced with RDB</span></div><div class="line">             * version 3. */</div><div class="line">            <span class="keyword">if</span> ((expiretime = rdbLoadMillisecondTime(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">            <span class="comment">/* We read the time so we need to read the object type again.</span></div><div class="line">             *</div><div class="line">             * 在过期时间之后会跟着一个键值对，我们要读入这个键值对的类型</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> ((type = rdbLoadType(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">        &#125;</div><div class="line">            </div><div class="line">        <span class="comment">// 读入数据 EOF （不是 rdb 文件的 EOF）</span></div><div class="line">        <span class="keyword">if</span> (type == REDIS_RDB_OPCODE_EOF)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* Handle SELECT DB opcode as a special case </span></div><div class="line">         *</div><div class="line">         * 读入切换数据库指示</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (type == REDIS_RDB_OPCODE_SELECTDB) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 读入数据库号码</span></div><div class="line">            <span class="keyword">if</span> ((dbid = rdbLoadLen(&amp;rdb,<span class="literal">NULL</span>)) == REDIS_RDB_LENERR)</div><div class="line">                <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">            <span class="comment">// 检查数据库号码的正确性</span></div><div class="line">            <span class="keyword">if</span> (dbid &gt;= (<span class="keyword">unsigned</span>)server.dbnum) &#123;</div><div class="line">                redisLog(REDIS_WARNING,<span class="string">"FATAL: Data file was created with a Redis server configured to handle more than %d databases. Exiting\n"</span>, server.dbnum);</div><div class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 在程序内容切换数据库</span></div><div class="line">            db = server.db+dbid;</div><div class="line"></div><div class="line">            <span class="comment">// 跳过</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Read key </span></div><div class="line">         *</div><div class="line">         * 读入键</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> ((key = rdbLoadStringObject(&amp;rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">        <span class="comment">/* Read value </span></div><div class="line">         *</div><div class="line">         * 读入值</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> ((val = rdbLoadObject(type,&amp;rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">        <span class="comment">/* Check if the key already expired. This function is used when loading</span></div><div class="line">         * an RDB file from disk, either at startup, or when an RDB was</div><div class="line">         * received from the master. In the latter case, the master is</div><div class="line">         * responsible for key expiry. If we would expire keys here, the</div><div class="line">         * snapshot taken by the master may not be reflected on the slave. </div><div class="line">         *</div><div class="line">         * 如果服务器为主节点的话，</div><div class="line">         * 那么在键已经过期的时候，不再将它们关联到数据库中去</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span> &amp;&amp; expiretime != <span class="number">-1</span> &amp;&amp; expiretime &lt; now) &#123;</div><div class="line">            decrRefCount(key);</div><div class="line">            decrRefCount(val);</div><div class="line">            <span class="comment">// 跳过</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Add the new object in the hash table </span></div><div class="line">         *</div><div class="line">         * 将键值对关联到数据库中</div><div class="line">         */</div><div class="line">        dbAdd(db,key,val);</div><div class="line"></div><div class="line">        <span class="comment">/* Set the expire time if needed </span></div><div class="line">         *</div><div class="line">         * 设置过期时间</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) setExpire(db,key,expiretime);</div><div class="line"></div><div class="line">        decrRefCount(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Verify the checksum if RDB version is &gt;= 5 </span></div><div class="line">     *</div><div class="line">     * 如果 RDB 版本 &gt;= 5 ，那么比对校验和</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (rdbver &gt;= <span class="number">5</span> &amp;&amp; server.rdb_checksum) &#123;</div><div class="line">        <span class="keyword">uint64_t</span> cksum, expected = rdb.cksum;</div><div class="line"></div><div class="line">        <span class="comment">// 读入文件的校验和</span></div><div class="line">        <span class="keyword">if</span> (rioRead(&amp;rdb,&amp;cksum,<span class="number">8</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">        memrev64ifbe(&amp;cksum);</div><div class="line"></div><div class="line">        <span class="comment">// 比对校验和</span></div><div class="line">        <span class="keyword">if</span> (cksum == <span class="number">0</span>) &#123;</div><div class="line">            redisLog(REDIS_WARNING,<span class="string">"RDB file was saved with checksum disabled: no check performed."</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cksum != expected) &#123;</div><div class="line">            redisLog(REDIS_WARNING,<span class="string">"Wrong RDB checksum. Aborting now."</span>);</div><div class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 关闭 RDB </span></div><div class="line">    fclose(fp);</div><div class="line"></div><div class="line">    <span class="comment">// 服务器从载入状态中退出</span></div><div class="line">    stopLoading();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line"></div><div class="line">eoferr: <span class="comment">/* unexpected end of file is handled here with a fatal exit */</span></div><div class="line">    redisLog(REDIS_WARNING,<span class="string">"Short read or OOM loading DB. Unrecoverable error, aborting now."</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> REDIS_ERR; <span class="comment">/* Just to avoid warning */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h2><p>从SAVE命令的实现过程，我们能够知道一个RDB文件总体结构可以这样划分：</p>
<p><img src="http://data3.liuin.cn/2018-06-08-15284270187199.jpg" alt=""></p>
<p>在数据库数据部分其最基本的元素是键值对，存储在RDB的数据又可以分含有过期键的键值对和没有过期键的键值对两种</p>
<p>没有过期键的键值对组织形式：</p>
<p><img src="http://data3.liuin.cn/2018-06-08-15284272306576.jpg" alt=""></p>
<p>含有过期键的键值对组织形式：</p>
<p><img src="http://data3.liuin.cn/2018-06-08-15284272441950.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 源码剖析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析——数据库]]></title>
      <url>/2018/05/30/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>本文将对Redis服务器的数据库实现进行介绍</p>
<a id="more"></a>
<h2 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h2><p>Redis服务器中一般保存了多个数据库，每个数据库用<code>redisDb</code>结构表示，结构的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisDb &#123;</div><div class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></div><div class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span></div><div class="line">    <span class="comment">// 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳</span></div><div class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span></div><div class="line">    <span class="comment">// 正处于阻塞状态的键</span></div><div class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP) */</span></div><div class="line">    <span class="comment">// 可以解除阻塞的键</span></div><div class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></div><div class="line">    <span class="comment">// 正在被 WATCH 命令监视的键</span></div><div class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></div><div class="line">    <span class="keyword">struct</span> evictionPoolEntry *eviction_pool;    <span class="comment">/* Eviction pool of keys */</span></div><div class="line">    <span class="comment">// 数据库号码</span></div><div class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID */</span></div><div class="line">    <span class="comment">// 数据库的键的平均 TTL ，统计信息</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></div><div class="line">&#125; redisDb;</div></pre></td></tr></table></figure>
<p>可以从Redis数据库中的定义中看到：数据库的所有键值对都存放在一个字典结构中，同时记录了用于键的删除所需要的过期时间。</p>
<p><img src="http://data3.liuin.cn/2018-05-30-15276449785249.jpg" alt=""></p>
<p>在Redis服务器结构中有一个数据库数组，存放各个数据库的指针；有一个记录数据库数量的变量dbnum，服务器初始化的时候根据这个变量来创建相应数量的数据库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> redisServer &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 数据库</span></div><div class="line">    redisDb *db;</div><div class="line">    <span class="comment">// 数据库数量</span></div><div class="line">    <span class="keyword">int</span> dbnum;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h2><p>每个 Redis客户端都有自己的目标数据库,每当客户端执行数据库写命令或者数据库读命令的时候,目标数据库就会成为这些命令的操作对象。默认情况下, Redis客户端的目标数据库为0号数据库,但客户端可以通过执行SELECT命令来切换目标数据库。</p>
<p>在客户端结构redisClient结构中用db属性记录客户端当前的目标数据库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisClient &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 记录客户端当前使用的数据库</span></div><div class="line">    redisDb *db;</div><div class="line">    ...</div><div class="line"></div><div class="line">&#125; redisClient</div></pre></td></tr></table></figure>
<p>redisClient.db指针指向redisServer.db数组的其中一个元素,而被指向的元素就是客户端的目标数据库。</p>
<p><img src="http://data3.liuin.cn/2018-05-30-15276464513190.jpg" alt=""></p>
<p>使用select切换数据库的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectDb</span><span class="params">(redisClient *c, <span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">    <span class="comment">// 验证db编号的合法性</span></div><div class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span> || id &gt;= server.dbnum)</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    c-&gt;db = &amp;server.db[id];</div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数据库的键空间"><a href="#数据库的键空间" class="headerlink" title="数据库的键空间"></a>数据库的键空间</h2><p>因为数据库的键空间是一个字典,所以所有针对数据库的操作,比如添加一个键值对到数据库,或者从数据库中删除一个键值对,又或者在数据库中获取某个键值对等,实际上都是通过对键空间字典进行操作来实现的</p>
<p><img src="http://data3.liuin.cn/2018-05-30-15276486205548.jpg" alt=""></p>
<h3 id="添加新键"><a href="#添加新键" class="headerlink" title="添加新键"></a>添加新键</h3><p>添加一个新键值对到数据库,实际上就是将一个新键值对添加到键空间字典里面,其中键为字符串对象,而值则为任意一种类型的 Redis对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbAdd</span><span class="params">(redisDb *db, robj *key, robj *val)</span> </span>&#123;</div><div class="line">    <span class="comment">// 拷贝字符串对象</span></div><div class="line">    sds copy = sdsdup(key-&gt;ptr);</div><div class="line">    <span class="comment">// 加入字典</span></div><div class="line">    <span class="keyword">int</span> retval = dictAdd(db-&gt;dict, copy, val);</div><div class="line"></div><div class="line">    redisAssertWithInfo(<span class="literal">NULL</span>,key,retval == REDIS_OK);</div><div class="line">    <span class="comment">// 如果值对象类型为list，需要判断该键是不是引起阻塞的键</span></div><div class="line">    <span class="keyword">if</span> (val-&gt;type == REDIS_LIST) signalListAsReady(db, key);</div><div class="line">    <span class="comment">// 如果开启的集群选项，则需要做相应的处理</span></div><div class="line">    <span class="keyword">if</span> (server.cluster_enabled) slotToKeyAdd(key);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p><img src="http://data3.liuin.cn/2018-05-30-15276578873211.jpg" alt=""></p>
<h3 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h3><p>删除数据库中的一个键,实际上就是在键空间里面删除键所对应的键值对对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></div><div class="line">     * the key, because it is shared with the main dictionary. */</div><div class="line">    <span class="comment">/* 如果有设定过期键，就去过期键字典中删除该键 */</span></div><div class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</div><div class="line">    <span class="keyword">if</span> (dictDelete(db-&gt;dict,key-&gt;ptr) == DICT_OK) &#123;</div><div class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><p>Reids中有LRU机制，能够实现对数据设置期限（过期时间），在期限到达的时候会执行删除机制。Redis中有三种不同的删除策略:</p>
<ul>
<li>定时删除:在设置键的过期时间的同时,创建一个定时器(timer),让定时器在键的过期时间来临时,立即执行对键的删除操作。</li>
<li>惰性删除:放任键过期不管,但是每次从键空间中获取键时,都检查取得的键是否过期,如果过期的话,就删除该键;如果没有过期,就返回该键。</li>
<li>定期删除:每隔一段时间,程序就对数据库进行一次检查,删除里面的过期键。至于要删除多少过期键,以及要检查多少个数据库,则由算法决定。</li>
</ul>
<p>在这三种策略中,第一种和第三种为主动删除策略,而第二种则为被动删除策略。</p>
<h3 id="过期时间的保存"><a href="#过期时间的保存" class="headerlink" title="过期时间的保存"></a>过期时间的保存</h3><p>redisDb结构的expires字典保存了数据库中所有键的过期时间,我们称这个字典为过期字典:</p>
<ul>
<li>过期字典的键是一个指针,这个指针指向键空间中的某个键对象(也即是某个数据库键)</li>
<li>过期字典的值是一个1ong 1ong类型的整数,这个整数保存了键所指向的数据库键的过期时间—个毫秒精度的UNIX时间戳。</li>
</ul>
<p><img src="http://data3.liuin.cn/2018-05-30-15276582632098.jpg" alt=""></p>
<h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>定时删除策略对内存是最友好的:通过使用定时器,定时删除策略可以保证过期键会尽可能快地被删除,并释放过期键所占用的内存。</p>
<p>另一方面,定时删除策略的缺点是,它对CPU时间是最不友好的:在过期键比较多的情况下,删除过期键这一行为可能会占用相当一部分CPU时间,在内存不紧张但是CPU时间非常紧张的情况下,将CPU时间用在删除和当前任务无关的过期键上,无疑会对服务器的响应时间和吞吐量造成影响。</p>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>惰性删除策略对CPU时间来说是最友好的:程序只会在取出键时才对键进行过期检查这可以保证删除过期键的操作只会在非做不可的情况下进行,并且删除的目标仅限于当前处理的键,这个策略<strong>不会在删除其他无关的过期键上花费任何CPU时间</strong>。</p>
<p>惰性删除策略的缺点是,它对内存是最不友好的:如果一个键已经过期,而这个键又仍然保留在数据库中,那么只要这个过期键不被删除,它所占用的内存就不会释放。</p>
<p>具体的实现是通过<code>expireIfNeeded</code>函数实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取定时时间</span></div><div class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key);</div><div class="line">    <span class="keyword">mstime_t</span> now;</div><div class="line">    <span class="comment">// 没有设置定时时间</span></div><div class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></div><div class="line">    <span class="comment">/* 服务器正在加载，不需要处理 */</span></div><div class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">/* lua相关 */</span></div><div class="line">    now = server.lua_caller ? server.lua_time_start : mstime();</div><div class="line">    <span class="comment">/* 主从复制相关 */</span></div><div class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> now &gt; when;</div><div class="line">    <span class="comment">/* 没有过期 */</span></div><div class="line">    <span class="keyword">if</span> (now &lt;= when) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">/* 删除键 */</span></div><div class="line">    server.stat_expiredkeys++;</div><div class="line">    propagateExpire(db,key);</div><div class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED,</div><div class="line">        <span class="string">"expired"</span>,key,db-&gt;id);</div><div class="line">    <span class="keyword">return</span> dbDelete(db,key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>从上面对定时删除和惰性删除的讨论来看,这两种删除方式在单一使用时都有明显的缺陷:</p>
<ul>
<li>定时删除占用太多CPU时间,影响服务器的响应时间和吞吐量。</li>
<li>惰性删除浪费太多内存,有内存泄漏的危险</li>
</ul>
<p>定期删除策略是前两种策略的一种整合和折中</p>
<ul>
<li>定期删除策略每隔一段时间执行一次删除过期键操作,并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li>
<li>除此之外,通过定期删除过期键,定期删除策略有效地减少了因为过期键而带来的内存浪费。</li>
</ul>
<p>定期删除策略的难点是确定删除操作执行的时长和频率</p>
<ul>
<li>如果删除操作执行得太频繁,或者执行的时间太长,定期删除策略就会退化成定时删除策略,以至于将CPU时间过多地消耗在删除过期键上面。</li>
<li>如果删除操作执行得太少,或者执行的时间太短,定期删除策略又会和惰性删除策略一样,出现浪费内存的情况</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 源码剖析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析——对象]]></title>
      <url>/2018/05/29/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>这篇文章将剖析Redis提供给用户的5种对象底层的数据结构和接口</p>
<a id="more"></a>
<p>前面讲了Reids底层所使用的一些数据结构：SDS、双端链表、字典、跳跃表等等，但是Redis并没有直接使用这些数据结构来构造键值对数据库。</p>
<h2 id="对象数据结构"><a href="#对象数据结构" class="headerlink" title="对象数据结构"></a>对象数据结构</h2><p>在redis.h中定义类redisObject的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Redis 对象定义</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisObject &#123;</div><div class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;       <span class="comment">// 类型</span></div><div class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;   <span class="comment">// 编码</span></div><div class="line">    <span class="comment">// 对象最后一次被访问的时间</span></div><div class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></div><div class="line">    <span class="comment">// 引用计数</span></div><div class="line">    <span class="keyword">int</span> refcount;</div><div class="line">    <span class="comment">// 实现的数据结构</span></div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line">&#125; robj;</div></pre></td></tr></table></figure>
<p>从代码中我们可以看到Redis对象所包含的信息有：类型、编码、实现指针、引用计数和访问时间</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>对于 Redis数据库保存的键值对来说,键总是一个字符串对象,而值则可以是字符串对象(string)、列表对象(list)、哈希对象(hash)、集合对象(set)或者有序集合对象(zset)的其中一种</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Object types */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_STRING 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LIST 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_SET 2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ZSET 3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_HASH 4</span></div></pre></td></tr></table></figure>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>对象的ptr指针指向对象的底层实现数据结构,而这些数据结构由对象的encoding属性决定encoding属性记录了对象所使用的编码,也即是说这个对象使用了什么数据结构作为对象的底层实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_RAW 0     <span class="comment">/* 编码为 简单动态字符串 */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INT 1     <span class="comment">/* 编码为 long类型的整数 */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_HT 2      <span class="comment">/* 编码为 字典 */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPMAP 3   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_LINKEDLIST 4 <span class="comment">/* 编码为 双端链表 */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPLIST 5 <span class="comment">/* 编码为 压缩列表 */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INTSET 6  <span class="comment">/* 编码为 整数集合 */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_SKIPLIST 7  <span class="comment">/* 编码为 跳跃表和字典 */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_EMBSTR 8  <span class="comment">/* 编码为 embstr编码的简单动态字符串 */</span></span></div></pre></td></tr></table></figure>
<p>每种类型的对象都至少对应两种不同的编码</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275795005914.jpg" alt=""></p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>Redis的对象系统实现了<strong>基于引用计数技术的内存回收机制</strong>,当程序不再使用某个对象的时候,这个对象所占用的内存就会被自动释放;另外, Redis还<strong>通过引用计数技术实现了对象共享机制</strong>,这一机制可以在适当的条件下,通过让多个数据库键共享同个对象来节约内存。</p>
<p>上面这些功能都是通过<code>refcount</code>这个属性来实现的：</p>
<ul>
<li>在创建一个新对象时,引用计数的值会被初始化为1</li>
<li>当对象被一个新程序使用时,它的引用计数值会被增一</li>
<li>当对象不再被一个程序使用时,它的引用计数值会被减一</li>
<li>当对象的引用计数值变为0时,对象所占用的内存会被释放</li>
</ul>
<p>修改引用计数的api如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrRefCount</span><span class="params">(robj *o)</span></span>;</div><div class="line"><span class="function">robj *<span class="title">resetRefCount</span><span class="params">(robj *obj)</span></span>;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>内存回收</p>
</blockquote>
<p>我们可以通过decrRefCount的实现看到当引用计数到达0的时候会自动释放对象所占有的资源</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) redisPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);</div><div class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// 释放对象占有的资源</span></div><div class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</div><div class="line">        <span class="keyword">case</span> REDIS_STRING: freeStringObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> REDIS_LIST: freeListObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> REDIS_SET: freeSetObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> REDIS_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> REDIS_HASH: freeHashObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>: redisPanic(<span class="string">"Unknown object type"</span>); <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        zfree(o);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        o-&gt;refcount--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>对象共享</p>
</blockquote>
<p>如果想创建一个与另外一个对象含有相同值的对象，这个时候可以启动对象的共享机制。</p>
<p>在Redis中,让多个键共享同一个值对象需要执行以下两个步骤</p>
<ul>
<li>将数据库键的值指针指向一个现有的值对象</li>
<li>将被共享的值对象的引用计数增一</li>
</ul>
<p>比如在从LongLong创建一个字符串对象的时候，首先要判断在不在共享对象的范围内，如果在的话就对引用计数加1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function">robj *<span class="title">createStringObjectFromLongLong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</div><div class="line"></div><div class="line">    robj *o;</div><div class="line"></div><div class="line">    <span class="comment">// value 的大小符合 REDIS 共享整数的范围</span></div><div class="line">    <span class="comment">// 那么返回一个共享对象</span></div><div class="line">    <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt; REDIS_SHARED_INTEGERS) &#123;</div><div class="line">        incrRefCount(shared.integers[value]);</div><div class="line">        o = shared.integers[value];</div><div class="line"></div><div class="line">    <span class="comment">// 不符合共享范围，创建一个新的整数对象</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 值可以用 long 类型保存，</span></div><div class="line">        <span class="comment">// 创建一个 REDIS_ENCODING_INT 编码的字符串对象</span></div><div class="line">        <span class="keyword">if</span> (value &gt;= LONG_MIN &amp;&amp; value &lt;= LONG_MAX) &#123;</div><div class="line">            o = createObject(REDIS_STRING, <span class="literal">NULL</span>);</div><div class="line">            o-&gt;encoding = REDIS_ENCODING_INT;</div><div class="line">            o-&gt;ptr = (<span class="keyword">void</span>*)((<span class="keyword">long</span>)value);</div><div class="line"></div><div class="line">        <span class="comment">// 值不能用 long 类型保存（long long 类型），将值转换为字符串，</span></div><div class="line">        <span class="comment">// 并创建一个 REDIS_ENCODING_RAW 的字符串对象来保存值</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            o = createObject(REDIS_STRING,sdsfromlonglong(value));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="对象的基本操作"><a href="#对象的基本操作" class="headerlink" title="对象的基本操作"></a>对象的基本操作</h2><p>Redis对象的基本操作包含了创建对象、销毁对象、编码转换等等</p>
<p>大部分操作的实现都在object.c文件中</p>
<h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>各种对象创建的API如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span></span>;  <span class="comment">// 创建对象，设定参数</span></div><div class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>;  <span class="comment">// 创建字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createRawStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>;   <span class="comment">// 创建raw编码的字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createEmbeddedStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>;  <span class="comment">// 创建embstr编码的字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createStringObjectFromLongLong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;  <span class="comment">// 根据传入LongLong创建字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createStringObjectFromLongDouble</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> value)</span></span>;  <span class="comment">// 根据传入的LongDouble创建字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createListObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建双端链表链表编码的列表对象</span></div><div class="line"><span class="function">robj *<span class="title">createZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建压缩列表编码的列表对象</span></div><div class="line"><span class="function">robj *<span class="title">createSetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建集合对象</span></div><div class="line"><span class="function">robj *<span class="title">createIntsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建整型集合编码的集合对象</span></div><div class="line"><span class="function">robj *<span class="title">createHashObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建hash对象</span></div><div class="line"><span class="function">robj *<span class="title">createZsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建zset对象</span></div><div class="line"><span class="function">robj *<span class="title">createZsetZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//创建压缩列表编码的zset对象</span></div></pre></td></tr></table></figure></p>
<p>具体我们以列表对象为例，看看创建对象的过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 创建一个 LINKEDLIST 编码的列表对象</div><div class="line"> */</div><div class="line"><span class="function">robj *<span class="title">createListObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="built_in">list</span> *l = listCreate();</div><div class="line">    robj *o = createObject(REDIS_LIST,l);</div><div class="line">    listSetFreeMethod(l,decrRefCountVoid);</div><div class="line">    o-&gt;encoding = REDIS_ENCODING_LINKEDLIST;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 创建一个 ZIPLIST 编码的列表对象</div><div class="line"> */</div><div class="line"><span class="function">robj *<span class="title">createZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</div><div class="line">    robj *o = createObject(REDIS_LIST,zl);</div><div class="line">    o-&gt;encoding = REDIS_ENCODING_ZIPLIST;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对象销毁"><a href="#对象销毁" class="headerlink" title="对象销毁"></a>对象销毁</h3><p>各种对象销毁的API如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeStringObject</span><span class="params">(robj *o)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeListObject</span><span class="params">(robj *o)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeSetObject</span><span class="params">(robj *o)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeZsetObject</span><span class="params">(robj *o)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeHashObject</span><span class="params">(robj *o)</span></span>;</div></pre></td></tr></table></figure></p>
<p>以List为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 释放列表对象</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeListObject</span><span class="params">(robj *o)</span> </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (o-&gt;encoding) &#123;</div><div class="line">    <span class="keyword">case</span> REDIS_ENCODING_LINKEDLIST:</div><div class="line">        listRelease((<span class="built_in">list</span>*) o-&gt;ptr);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> REDIS_ENCODING_ZIPLIST:</div><div class="line">        zfree(o-&gt;ptr);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        redisPanic(<span class="string">"Unknown list encoding type"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</div><div class="line">    listNode *current, *next;</div><div class="line"></div><div class="line">    <span class="comment">// 指向头指针</span></div><div class="line">    current = <span class="built_in">list</span>-&gt;head;</div><div class="line">    <span class="comment">// 遍历整个链表</span></div><div class="line">    len = <span class="built_in">list</span>-&gt;len;</div><div class="line">    <span class="keyword">while</span>(len--) &#123;</div><div class="line">        next = current-&gt;next;</div><div class="line">        <span class="comment">// 如果有设置值释放函数，那么调用它</span></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</div><div class="line">        <span class="comment">// 释放节点结构</span></div><div class="line">        zfree(current);</div><div class="line">        current = next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 释放链表结构</span></div><div class="line">    zfree(<span class="built_in">list</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和创建对象分多钟编码格式相对应，释放对象的时候也要根据编码具体执行释放</p>
<h2 id="对象交互指令"><a href="#对象交互指令" class="headerlink" title="对象交互指令"></a>对象交互指令</h2><p>Redis提供三个命令用户获取对象的一些参数：</p>
<ul>
<li>object refcount <key> 返回key所指的对象的引用计数</key></li>
<li>object encoding <key> 返回key所指的对象中存放的数据的编码方式</key></li>
<li>object idletime <key> 返回key所指的对象的空转时长</key></li>
</ul>
<p>具体的实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">objectCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    robj *o;</div><div class="line"></div><div class="line">    <span class="comment">// 返回对戏哪个的引用计数</span></div><div class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"refcount"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((o = objectCommandLookupOrReply(c,c-&gt;argv[<span class="number">2</span>],shared.nullbulk))</div><div class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line">        addReplyLongLong(c,o-&gt;refcount);</div><div class="line"></div><div class="line">    <span class="comment">// 返回对象的编码</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"encoding"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((o = objectCommandLookupOrReply(c,c-&gt;argv[<span class="number">2</span>],shared.nullbulk))</div><div class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line">        addReplyBulkCString(c,strEncoding(o-&gt;encoding));</div><div class="line">    </div><div class="line">    <span class="comment">// 返回对象的空闲时间</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"idletime"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((o = objectCommandLookupOrReply(c,c-&gt;argv[<span class="number">2</span>],shared.nullbulk))</div><div class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line">        addReplyLongLong(c,estimateObjectIdleTime(o)/<span class="number">1000</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        addReplyError(c,<span class="string">"Syntax error. Try OBJECT (refcount|encoding|idletime)"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 源码剖析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《UNIX网络编程卷1》笔记 基本套接字编程部分]]></title>
      <url>/2018/05/23/%E3%80%8AUNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B71%E3%80%8B%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%E9%83%A8%E5%88%86/</url>
      <content type="html"><![CDATA[<p>UNIX网络编程必读书籍——《UNIX网络编程卷1》  基本套接字编程 笔记</p>
<a id="more"></a>
<h1 id="套接字编程简介"><a href="#套接字编程简介" class="headerlink" title="套接字编程简介"></a>套接字编程简介</h1><h2 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h2><p>大多数套接字函数都需要一个指向套接字地址结构的指针作为参数。每个协议族都定义它自己的套接字地址结构。这些结构的名字均以 sockaddr_开头,并以对应每个协议族的唯一后缀结尾。</p>
<h3 id="IPv4套接字地址结构"><a href="#IPv4套接字地址结构" class="headerlink" title="IPv4套接字地址结构"></a>IPv4套接字地址结构</h3><p>IPv4套接字地址结构通常也称为“网际套接字地址结构”,它以 sockaddr_in命名,定义在<netinet in.h="">头文件中。POSIX定义：</netinet></p>
<p><img src="https://data2.liuin.cn/2018-05-22-15269964950047.jpg" alt=""></p>
<p>下面给出几点说明：</p>
<ul>
<li>并不是所有厂商都支持sin_len，即使有长度字段,我们也无须设置和检查它,除非涉及路由套接字，处理来自不同协议族的套接字地址结构的例程(例如路由表处理代码)在内核中使用的。</li>
<li>POSX规范只需要这个结构中的3个字段:sin_fari1y、 sin_addr和sin_port,</li>
</ul>
<h3 id="通用套接字地址结构"><a href="#通用套接字地址结构" class="headerlink" title="通用套接字地址结构"></a>通用套接字地址结构</h3><p>当作为一个参数传递进任何套接字函数时,套接字地址结构总是以引用形式(也就是以指向该结构的指针)来传递。然而以这样的指针作为参数之一的任何套接字函数必须处理来自所支持的任何协议族的套接字地址结构。</p>
<p>现在所采用的方法是在<sys socket.h="">头文件中定义一个通用的套接字地址结构：</sys></p>
<p><img src="https://data2.liuin.cn/2018-05-22-15269968296764.jpg" alt=""></p>
<p>于是套接字函数被定义为以指向某个通用套接字地址结构的一个指针作为其参数之一。这就要求对这些函数的任何调用都必须要将<strong>指向特定于协议的套接字地址结构的指针进行强制转换(casting),变成指向某个通用套接字地址结构的指针</strong></p>
<p>从应用程序开发人员的观点看,这些通用套接字地址结构的唯一用途就是<strong>对指向特定于协议的套接字地址结构的指针执行类型强制转换</strong>。</p>
<h3 id="套接字地址结构比较"><a href="#套接字地址结构比较" class="headerlink" title="套接字地址结构比较"></a>套接字地址结构比较</h3><p><img src="https://data2.liuin.cn/2018-05-22-15269969711360.jpg" alt=""></p>
<h2 id="值-结果参数"><a href="#值-结果参数" class="headerlink" title="值-结果参数"></a>值-结果参数</h2><p>当往一个套接字函数传递一个套接字地址结构时,该<strong>结构总是以引用形式来传递</strong>,也就是说传递的是指向该结构的一个指针。该结构的长度也作为一个参数来传递,不过其传递方式取决于该结构的传递方向:是从进程到内核,还是从内核到进程。</p>
<p>(1)从进程到内核传递套接字地址结构的函数有3个:bind、connect和 sendto。这些函数的一个参数是指向某个套接字地址结构的指针,另一个参数是该结构的整数大小。既然指针和指针所指内容的大小都传递给了内核,于是内核知道到底需从进程复制多少数据进来。</p>
<p><img src="https://data2.liuin.cn/2018-05-22-15269972347844.jpg" alt=""></p>
<p>(2)从内核到进程传递套接字地址结构的函数有4个: accept、 recvfrom、 getsockname和 getpeername。这4个函数的其中两个参数是<strong>指向某个套接字地址结构的指针</strong>和<strong>指向表示该结构大小的整数变量的指针</strong>。把套接字地址结构大小这个参数从一个整数改为指向某个整数变量的指针,其原因在于:当函数被调用时,结构大小是一个值(value),它告诉内核该结构的大小,这样内核在写该结构时不至于越界;当函数返回时,结构大小又是一个结果(result.),它告诉进程内核在该结构中究竟存储了多少信息。这种类型的参数称为值-结果(value-result)参数。</p>
<p><img src="https://data2.liuin.cn/2018-05-22-15269973186591.jpg" alt=""></p>
<p>在网络编程中,值-结果参数最常见的例子是所返回套接字地址结构的长度</p>
<h2 id="字节排序函数"><a href="#字节排序函数" class="headerlink" title="字节排序函数"></a>字节排序函数</h2><p>内存中有两种存储多字节数的方法：一种是将低序字节存储在起始地址,这称为小端(little-endian)字节序;另一种方法是将高序字节存储在起始地址,这称为大端(big-endian)字节序</p>
<p><img src="https://data2.liuin.cn/2018-05-22-15269974255787.jpg" alt=""></p>
<p>不同的主机中使用的字节序是不一样的。</p>
<p>套接字地址结构中的某些字段必须按照网络字节序进行维护。因此我们要关注如何在主机字节序和网络字节序之间相互转换。这两种字节序之间的转换使用以下4个函数：</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270558826021.jpg" alt=""></p>
<p>在这些函数的名字中,h代表host,n代表network,s代表short,l代表long。</p>
<h2 id="字节操作函数"><a href="#字节操作函数" class="headerlink" title="字节操作函数"></a>字节操作函数</h2><p>操纵多字节字段的函数有两组,它们<strong>既不对数据作解释,也不假设数据是以空字符结束的C字符串</strong>。当处理套接字地址结构时,我们需要这些类型的函数,因为我们需要操纵诸如IP地址这样的字段,这些字段可能包含值为0的字节,却并不是C字符串。以空字符结尾的C字符串是由在<string.h>头文件中定义、名字以str(表示字符串)开头的函数处理的。</string.h></p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270567699154.jpg" alt=""></p>
<p>bzero把目标字节串中指定数目的字节置为0。我们经常使用该函数来把一个套接字地址结构初始化为0。 bcopy将指定数目的字节从源字节串移到目标字节串。bcmp比较两个任意的字节串,若相同则返回值为0,否则返回值为非0。</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270568142560.jpg" alt=""></p>
<p>memset把目标字节串指定数目的字节置为值c。 memcpy类似bcopy,不过两个指针参数的顺序是相反的。当源字节串与目标字节串重叠时,bco能够正确处理,但是 memcpy的操作结果却不可知。这种情形下必须改用 ANSI C的 mernmove函数。</p>
<h2 id="inet-aton、inet-addr和inet-ntoa函数"><a href="#inet-aton、inet-addr和inet-ntoa函数" class="headerlink" title="inet_aton、inet_addr和inet_ntoa函数"></a>inet_aton、inet_addr和inet_ntoa函数</h2><p>在ASCII字符串(这是人们偏爱使用的格式)与网络字节序的二进制值(这是存放在套接字地址结构中的值)之间转换网际地址需要一些函数进行实现。</p>
<p>inet_aton、inet_addr和 inet_ntoa在点分十进制数串(例如“206,168,112.96”)与它长度为32位的网络字节序二进制值间转换IP4地址:</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270571324262.jpg" alt=""></p>
<h2 id="inet-pton和inet-ntop函数"><a href="#inet-pton和inet-ntop函数" class="headerlink" title="inet_pton和inet_ntop函数"></a>inet_pton和inet_ntop函数</h2><p>这两个函数是随Iv6出现的新函数,对于IPv4地址和Pv6地址都适用。本书通篇都在使用这两个函数。函数名中和n分别代表表达( presentation)和数值( numeric)。地址的表达格式通常是ASCⅡ字符串,数值格式则是存放到套接字地址结构中的二进制值</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270571987014.jpg" alt=""></p>
<h2 id="sock-ntop和相关函数"><a href="#sock-ntop和相关函数" class="headerlink" title="sock_ntop和相关函数"></a>sock_ntop和相关函数</h2><p>inet_ntop的一个基本问题是:它要求调用者传递一个指向某个二进制地址的指针,而该地址通常包含在一个套接字地址结构中,这就要求调用者必须知道这个结构的格式和地址族。</p>
<p>为了解决这个问题,我们将自行编写一个名为sock_ntop的函数,它以指向某个套接字地址结构的指针为参数,查看该结构的内部,然后调用适当的函数返回该地址的表达格式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sock_ntop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *sockaddr, <span class="keyword">sockelen_t</span> addrlen)</span></span>;</div></pre></td></tr></table></figure>
<p>仅为AF_INET下的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sock_ntop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *sockaddr, <span class="keyword">sockelen_t</span> addrlen)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> portstr[<span class="number">8</span>];</div><div class="line">	<span class="keyword">static</span> <span class="keyword">char</span> str[<span class="number">128</span>];</div><div class="line"></div><div class="line">	<span class="keyword">switch</span>(sockaddr-&gt;sa_family)&#123;</div><div class="line">		<span class="keyword">case</span> AF_INET:</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">struct</span> sockaddr_in *<span class="built_in">sin</span> = (<span class="keyword">struct</span> sockaddr_in *) sockeaddr;</div><div class="line">				<span class="keyword">if</span>(inet_ntop(AF_INET, &amp;<span class="built_in">sin</span>-&gt;sin_addr, str, <span class="keyword">sizeof</span>(str)) == <span class="literal">NULL</span>)</div><div class="line">					<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">				<span class="keyword">if</span>(ntohs(<span class="built_in">sin</span>-&gt;sin_port) != <span class="number">0</span>)</div><div class="line">				&#123;</div><div class="line">					<span class="built_in">snprintf</span>(portstr, <span class="keyword">sizeof</span>(portstr), <span class="string">":%d"</span>, ntohs(<span class="built_in">sin</span>-&gt;sin_port));</div><div class="line">					<span class="built_in">strcat</span>(str, portstr);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> str;</div><div class="line">			&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="readn、writen和readline函数"><a href="#readn、writen和readline函数" class="headerlink" title="readn、writen和readline函数"></a>readn、writen和readline函数</h2><p>字节流套接字(例如TCP套接字)上的read和 write函数所表现的行为不同于通常的文件IO。字节流套接字上调用read或 write输入或输出的字节数可能比请求的数量少,然而这不是出错的状态。这个现象的原因在于<strong>内核中用于套接字的缓冲区可能已达到了极限</strong>。</p>
<p>因为这个原因，我们可以在原始的读写函数的基础上，为了使得I/O传输所有的字符，我们不断调用read、write直到对所需要的数据完成所有的传输</p>
<h1 id="基本TCP套接字编程"><a href="#基本TCP套接字编程" class="headerlink" title="基本TCP套接字编程"></a>基本TCP套接字编程</h1><p>下图给出了TCP客户与服务器进程之间发生的一些典型事件的时间表：</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270592134854.jpg" alt=""></p>
<h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><p>为了执行网络O,一个进程必须做的第一件事情就是调用 socket函数,指定期望的通信协议类型(使用IPv4的TCP、使用IPv6的UDP、Unix域字节流协议等)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span> <span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: non-negative descriptor if OK, -1 on error</span></div></pre></td></tr></table></figure>
<p>其中family参数指明协议族。该参数也往往被称为协议域。type参数指明套接字类型。protocol参数应设为某个协议类型常值,或者设为0,以选择所给定mi和nye组合的系统默认值。</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270603977151.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270604018451.jpg" alt=""></p>
<p>socket函数在成功时返回一个小的非负整数值,它与文件描述符类似,我们把它称为套接字描述符(socket descriptor),简称sockfd</p>
<blockquote>
<p>对比AF_XXX和PF_XXX</p>
</blockquote>
<p>AF前缀表示地址族,PF前缀表示协议族。历史上曾有这样的想法:单个协议族可以支持多个地址族,<strong>PF值用来创建套接字,而AF值用于套接字地址结构</strong>。但实际上,支持多个地址族的协议族从来就未实现过,而且头文件<sys socket.h="">中为一给定协议定义的PF值总是与此协议的AF值相等。</sys></p>
<h2 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h2><p>TCP客户用 connect函数来建立与TCP服务器的连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *servaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>; </div><div class="line"><span class="comment">// Returns: 0 if OK, -1 on error</span></div></pre></td></tr></table></figure>
<p>sockfd是由socket函数返回的套接字描述符,第二个、第三个参数分别是一个指向套接字地址结构的指针和该结构的大小。客户在调用函数 connect前不必非得调用bind函数,因为如果需要的话,内核会确定源IP地址,并选择一个临时端口作为源端口。</p>
<p>建立连接是通过TCP三次握手建立的，建立连接中产生的具体错误可以通过返回值进行判断</p>
<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><p>bind函数把一个本地协议地址赋予一个套接字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span> <span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK,-1 on error</span></div></pre></td></tr></table></figure>
<p>第二个参数是一个指向特定于协议的地址结构的指针,第三个参数是该地址结构的长度。对于TCP,调用bind函数可以指定一个端口号,或指定一个IP地址,也可以两者都指定,还可以都不指定。</p>
<ul>
<li>服务器在启动时捆绑它们的众所周知端口</li>
<li>进程可以把一个特定的IP地址捆绑到它的套接字上,不过这个IP地址必须属于其所在主机的网络接口之一。对于TCP客户,这就为在该套接字上发送的IP数据报指派了源IP地址。对于TCP服务器,这就限定该套接字只接收那些目的地为这个P地址的客户连接。</li>
</ul>
<p>如果指定端口号为0,那么内核就在bind被调用时选择一个临时端口。然而如果指定IP地址为通配地址,那么内核将等到套接字已连接(TCP)或已在套接字上发出数据报(UDP)时才选择一个本地IP地址</p>
<h2 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h2><p>listen函数仅由TCP服务器调用,它做两件事情</p>
<ol>
<li>当 socket函数创建一个套接字时,它被假设为一个<strong>主动套接字</strong>,也就是说,它是一个将调用connect发起连接的客户套接字。listen函数把一个未连接的套接字转换成一个被动套接字,指示内核应接受指向该套接字的连接请求。</li>
<li>本函数的第二个参数规定了内核应该为相应套接字排队的最大连接个数。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span> <span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, -1 on error</span></div></pre></td></tr></table></figure>
<p>为了理解其中的backlog参数,我们必须认识到内核为任何一个给定的监听套接字维护两个队列:</p>
<ol>
<li>未完成连接队列(incomplete connection queue),每个这样的SYN分节对应其中一项:已由某个客户发出并到达服务器,而服务器正在等待完成相应的TCP三路握手过程。这些套接字处于SYN RCVD状态。</li>
<li>已完成连接队列(completed connection queue),每个已完成TCP三路握手过程的客户对应其中一项。这些套接字处于 ESTABLISHED状态</li>
</ol>
<h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><p>accept函数由TCP服务器调用,用于从已完成连接队列队头返回下一个已完成连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span> <span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *cliaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: non-negative descriptor if OK, -1 on error</span></div></pre></td></tr></table></figure>
<p>参数cliaddr和addrlen用来返回已连接的对端进程(客户)的协议地址。 addrlen是值-结果参数:调用前,我们将由*addrlen所引用的整数值置为由cliaddr所指的套接字地址结构的长度,返回时,该整数值即为由内核存放在该套接字地址结构内的确切字节数。</p>
<p>如果accept成功,那么其返回值是由内核自动生成的一个全新描述符,代表与所返回客户的TCP连接。在讨论 accept函数时,我们称它的第一个参数为<strong>监听套接字</strong>(listening socket)描述符(由socke创建,随后用作bind和listen的第一个参数的描述符),称它的返回值为<strong>已连接套接字</strong>( connected socket)描述符。</p>
<p>区分这两个套接字非常重要。一个服务器通常仅仅创建个监听套接字,它在该服务器的生命期内一直存在。内核为每个由服务器进程接受的客户连接创建一个已连接套接字(也就是说对于它的TCP三路握手过程已经完成)。当服务器完成对某个给定客户的服务时,相应的已连接套接字就被关闭。</p>
<h2 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h2><p>然而当服务一个客户请求可能花费较长时间时,我们并不希望整个服务器被单个客户长期占用,而是希望同时服务多个客户。Unix中编写并发服务器程序最简单的办法就是foxk一个子进程来服务每个客户。</p>
<p>当一个连接建立时, accept返回,服务器接着调用fork,然后由子进程服务客户(通过已连接套接字clientfd),父进程则等待另一个连接(通过监听套接字listened)。既然新的客户由子进程提供服务,父进程就关闭已连接套接。</p>
<h2 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h2><p>close一个TCP套接字的默认行为是把该套接字标记成已关闭,然后立即返回到调用进程。该套接字描述符不能再由调用进程使用,也就是说它不能再作为read或wrie的第一个参数。然而TCP将尝试发送已排队等待发送到对端的任何数据,发送完毕后发生的是正常的TCP连接终止序列。</p>
<p>并发服务器中父进程关闭已连接套接字只是导致相应描述符的引用计数值减1。既然引用计数值仍大于0,这个<strong>c1ose调用并不引发TCP的四分组连接终止序列</strong>。对于父进程与子进程共享已连接套接字的并发服务器来说,这正是所期望的。如果我们确实想在某个TCP连接上发送一个FⅠN,那么可以改用shutdow函数以代替c1ose。</p>
<h1 id="I-O复用：select和poll函数"><a href="#I-O复用：select和poll函数" class="headerlink" title="I/O复用：select和poll函数"></a>I/O复用：select和poll函数</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>有的时候，进程需要一种预先告知内核的能力,使得内核一旦发现进程指定的一个或多个I/O条件就绪(也就是说输入已准备好被读取,或者描述符已能承接更多的输出),它就通知进程。这个能力称为I/O复用(I/O multiplexing),是由se1ect和po11这两个函数支持的。</p>
<p>IO复用典型使用在下列网络应用场合:</p>
<ul>
<li>当客户处理多个描述符(通常是交互式输入和网络套接字)时,必须使用I/O复用。</li>
<li>一个客户同时处理多个套接字是可能的,不过比较少见。</li>
<li>如果一个TCP服务器既要处理监听套接字,又要处理已连接套接字,一般就要使用I/O复用</li>
<li>如果一个服务器即要处理TCP,又要处理UDP,一般就要使用I/O复用</li>
<li>如果一个服务器要处理多个服务或者多个协议,一般就要使用IO复用。</li>
</ul>
<p>IO复用并非只限于网络编程,许多重要的应用程序也需要使用这项技术。</p>
<h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h2><p>在介绍 select和poll这两个函数之前,我们需要回顾整体,查看Uniⅸ下可用的5种I/O模型的基本区别:</p>
<ul>
<li>阻塞式I/O;</li>
<li>非阻塞式I/O;</li>
<li>IO复用(se1ect和po11);</li>
<li>信号驱动式IO(SIGIO);</li>
<li>异步I/O(POSIX的aio_系列函数)。</li>
</ul>
<h3 id="阻塞式I-O模型"><a href="#阻塞式I-O模型" class="headerlink" title="阻塞式I/O模型"></a>阻塞式I/O模型</h3><p>默认情形下,所有套接字都是阻塞的</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274240586717.jpg" alt=""></p>
<p>在图中,进程调用 recvfrom,其系统调用直到数据报到达且被复制到应用进程的缓冲区中或者发生错误才返回。最常见的错误是系统调用被信号中断</p>
<h3 id="非阻塞式I-O模型"><a href="#非阻塞式I-O模型" class="headerlink" title="非阻塞式I/O模型"></a>非阻塞式I/O模型</h3><p>进程把一个套接字设置成非阻塞是在通知内核：当所请求的I/O操作非得把本进程投入睡眠才能完成时,不要把本进程投入睡眠,而是返回一个错误。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274241782814.jpg" alt=""></p>
<p>当一个应用进程像这样对一个非阻塞描述符循环调用 recvfrom时,我们称之为轮询</p>
<h3 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h3><p>有了I/O复用(I/O multiplexing),我们就可以调用select或po11,<strong>阻塞在这两个系统调用中的某一个之上,而不是阻塞在真正的I/O系统调用上</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274242724836.jpg" alt=""></p>
<p>我们阻塞于se]ect调用,等待数据报套接字变为可读。当se1ect返回套接字可读这一条件时,我们调用 recvfrom把所读数据报复制到应用进程缓冲区。</p>
<h3 id="信号驱动式IO模型"><a href="#信号驱动式IO模型" class="headerlink" title="信号驱动式IO模型"></a>信号驱动式IO模型</h3><p>我们也可以用信号,让内核在描述符就绪时发送SIGIO信号通知我们。我们称这种模型为信号驱动式I/O( signal-driven I/O)</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274243322666.jpg" alt=""></p>
<h3 id="异步I-O模型"><a href="#异步I-O模型" class="headerlink" title="异步I/O模型"></a>异步I/O模型</h3><p>这些函数的工作机制是:告知内核启动某个操作,并让内核在整个操作(包括将数据从内核复制到我们自己的缓冲区)完成后通知我们。这种模型与前一节介绍的信号驱动模型的主要区别在于:<strong>信号驱动式IO是由内核通知我们何时可以启动一个O操作,而异步LO模型是由内核通知我们IO操作何时完成</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274244101255.jpg" alt=""></p>
<h3 id="各种I-O模型的比较"><a href="#各种I-O模型的比较" class="headerlink" title="各种I/O模型的比较"></a>各种I/O模型的比较</h3><p><img src="https://data2.liuin.cn/2018-05-27-15274244780614.jpg" alt=""></p>
<p>上图对比了上述5种不同的I/O模型。可以看出,前4种模型的主要区别在于第一阶段,因为它们的第二阶段是一样的:在数据从内核复制到调用者的缓冲区期间,进程阻塞于recvfrom调用。相反,异步I/O模型在这两个阶段都要处理,从而不同于其他4种模型。</p>
<h2 id="select-函数"><a href="#select-函数" class="headerlink" title="select 函数"></a>select 函数</h2><p>该函数允许进程指示内核等待多个事件中的任何一个发生,并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。也就是说,我们调用 select告知内核对哪些描述符(就读、写或异常条件)感兴趣以及等待多长时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> <span class="keyword">struct</span> timeval *timeout)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: positive count of ready descriptors, 0 on timeout, –1 on error</span></div></pre></td></tr></table></figure>
<p>最后一个参数它告知内核等待所指定描述符中的任何一个就绪可花多少时间。</p>
<p>中间的三个参数 readset、 writeset和 excepts指定我们要让内核测试读、写和异常条件的描述符。目前支持的异常条件只有两个:<br>(1)某个套接字的带外数据的到达<br>(2)某个已置为分组模式的伪终端存在可从其主端读取的控制状态信息</p>
<p>如何给这3个参数中的每一个参数指定一个或多个描述符值是一个设计上的问题。se1ect使用描述符集,通常是一个整数数组,其中每个整数中的每一位对应一个描述符</p>
<p>select函数的中间三个参数 readset、 writeset和 excepts中,如果我们对某一个的条件不感兴趣,就可以把它设为空指针。事实上,如果这三个指针}均为空,我们就有了一个比UNIX的s1eep函数更为精确的定时器( sleep睡眠以秒为最小单位)。</p>
<p>头文件<sys select.h="">中定义的 FD_SETSIZE常值是数据类型 fd_set中的描述符总数,其值通常是1024,不过很少有程序用到那么多的描述符。<strong>maxfdpl参数迫使我们计算出所关心的最大描述符并告知内核该值</strong>。</sys></p>
<p>se1ect函数修改由指针 readset、 writeset和 excepts所指向的的描述符集,因而这三个参数都是值结果参数。调用该函数时,我们指定所关心的描述符的值,该函数返回时,结果将指示哪些描述符已就绪。该函数返回后,我们使用 FD_ISSET宏来测试 fa_set数据类型中的描述符描述符集内任何与未就绪描述符对应的位返回时均清成0。为此,每次重新调用se1ect函数时,我们都得再次把所有描述符集内所关心的位均置为1。</p>
<p>该函数的<strong>返回值表示跨所有描述符集的已就绪的总位数</strong>。如果在任何描述符就绪之前定时器到时,那么返回0。返回-1表示出错(这是可能发生的,譬如本函数被一个所捕获的信号中断)。</p>
<h3 id="描述符就绪条件"><a href="#描述符就绪条件" class="headerlink" title="描述符就绪条件"></a>描述符就绪条件</h3><p>我们一直在讨论等待某个描述符准备好I/O(读或写)或是等待其上发生一个待处理的异常条件(带外数据)。尽管可读性和可写性对于普通文件这样的描述符显而易见,然而对于引起select返回套接字“就绪”的条件我们必须讨论得更明确些</p>
<p>满足下列四个条件中的任何一个时,一个套接字准备好读</p>
<ol>
<li>该套接字接收缓冲区中的数据字节数大于等于套接字接收缓冲区低水位标记的当前大小。对这样的套接字执行读操作不会阻塞并将返回一个大于0的值(也就是返回准备好读入的数据)。</li>
<li>该连接的读半部关闭(也就是接收了FIN的TCP连接)。对这样的套接字的读操作将不阻塞并返回0(也就是返回EOF)。</li>
<li>该套接字是一个监听套接字且已完成的连接数不为0。对这样的套接字的accept通常不会阻塞</li>
<li>其上有一个套接字错误待处理。</li>
</ol>
<p>下列四个条件中的任何一个满足时,一个套接字准备好写</p>
<ol>
<li>该套接字发送缓冲区中的可用空间字节数大于等于套接字发送缓冲区低水位标记的当前大小,并且或者该套接字已连接,或者该套接字不需要连接(如UDP套接字)。这意味着如果我们把这样的套接字设置成非阻塞，写操作将不阻塞并返回一个正值(例如由传输层接受的字节数)。</li>
<li>该连接的写半部关闭。对这样的套接字的写操作将产生SIGPIP信号</li>
<li>使用非阻塞式connect的套接字已建立连接,或者connect已经以失败告终</li>
<li>其上有一个套接字错误待处理。</li>
</ol>
<p>如果一个套接字存在带外数据或者仍处于带外标记,那么它有异常条件待处理。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274255486025.jpg" alt=""></p>
<h2 id="shutdown函数"><a href="#shutdown函数" class="headerlink" title="shutdown函数"></a>shutdown函数</h2><p>终止网络连接的通常方法是调用c1ose函数。不过cose有两个限制,却可以使用shutdown来避免：</p>
<ol>
<li>close把描述符的引用计数减1,仅在该计数变为0时才关闭套接字。使用 shutdown可以不管引用计数就激发TCP的正常连接终止序列</li>
<li>close终止读和写两个方向的数据传送。既然TCP连接是全双工的,有时候我们需要告知对端我们已经完成了数据发送,即使对端仍有数据要发送给我们。</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-05-27-15274259894144.jpg" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, –1 on error</span></div></pre></td></tr></table></figure>
<p>该函数的行为依赖于howo参数的值:</p>
<ul>
<li>SHUT_RD——关闭连接的读这一半——套接字中不再有数据可接收,而且套接字接收缓冲区中的现有数据都被丢弃。进程不能再对这样的套接字调用任何读函数。对一个TCP套接字这样调用 shutdown函数后,由该套接字接收的来自对端的任何数据都被确认,然后悄然丢弃。</li>
<li>SHUT_WR——关闭连接的写这一半——对于TCP套接字,这称为半关闭。当前留在套接字发送缓冲区中的数据将被发送掉,后跟TCP的正常连接终止序列。我们已经说过,不管套接字描述符的引用计数是否等于0,这样的写半部关闭照样执行。进程不能再对这样的套接字调用任何写函数。</li>
<li>SHUT_RDWR——连接的读半部和写半部都关闭——这与调用shutdown两次等效:第一次调用指定 SHUT_RD,第二次调用指定 SHUT_WR</li>
</ul>
<h2 id="pselect-函数"><a href="#pselect-函数" class="headerlink" title="pselect 函数"></a>pselect 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span> <span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *timeout, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, –1 on error</span></div></pre></td></tr></table></figure>
<p>pselect相对于通常的select有两个变化。</p>
<ul>
<li>pselect使用timespec结构,而不使用timeval结构。前者指定纳秒数，后者指定微秒数</li>
<li>pselect函数增加了第六个参数:一个指向信号掩码的指针。该参数允许程序先禁止递交某些信号,再测试由这些当前被禁止信号的信号处理函数设置的全局变量,然后调用select,告诉它重新设置信号掩码。</li>
</ul>
<h2 id="poll-函数"><a href="#poll-函数" class="headerlink" title="poll 函数"></a>poll 函数</h2><p>po11提供的功能与se1ect类似,不过在处理流设备时,它能够提供额外的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(<span class="keyword">struct</span> pollfd *fdarray, <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, –1 on error</span></div></pre></td></tr></table></figure>
<p>第一个参数是指向一个结构数组第一个元素的指针。每个数组元素都是一个pollfd结构,用于指定测试某个给定描述符fd的条件。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274265737476.jpg" alt=""></p>
<p>要测试的条件由 events成员指定,函数在相应的 revents成员中返回该描述符的状态。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274266342975.jpg" alt=""></p>
<h1 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h1><h2 id="getsockopt和setsockopt函数"><a href="#getsockopt和setsockopt函数" class="headerlink" title="getsockopt和setsockopt函数"></a>getsockopt和setsockopt函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval <span class="keyword">socklen_t</span> optlen)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK,–1 on error</span></div></pre></td></tr></table></figure>
<p>其中sockfd必须指向一个打开的套接字描述符,level(级别)指定系统中解释选项的代码或为通用套接字代码,或为某个特定于协议的代码(例如IPv4、IPv6、TCP或SCTP)。optval是一个指向某个变量(*optval)的指针, setsockopt从*optval中取得选项待设置的新值, getsockopt则把已获取的选项当前值存放到*optval冲中。*optval的大小由最后一个参数指定,它对于setsockopt是一个值参数,对于 getsockopt是一个值-结果参数</p>
<p>套接字选项粗分为两大基本类型:一是<strong>启用或禁止某个特性的二元选项(称为标志选项)</strong>二是<strong>取得并返回我们可以设置或检查的特定值的选项</strong>(称为值选项)。</p>
<h2 id="通用套接字选项"><a href="#通用套接字选项" class="headerlink" title="通用套接字选项"></a>通用套接字选项</h2><p>通用套接字选项是与协议无关的，不过其中有些选项只能应用到某些特定类型的套接字中。</p>
<h3 id="SO-BROADCAST套接字选项"><a href="#SO-BROADCAST套接字选项" class="headerlink" title="SO_BROADCAST套接字选项"></a>SO_BROADCAST套接字选项</h3><p>本选项开启或禁止进程发送广播消息的能力。只有数据报套接字支持广播,并且还必须是在支持广播消息的网络上(例如以太网、令牌环网等)。我们不可能在点对点链路上进行广播,也不可能在基于连接的传输协议(例如TCP和SCTP)之上进行广播。</p>
<p>由于应用进程在发送广播数据报之前必须设置本套接字选项,因此它能够有效地防止一个进程在其应用程序根本没有设计成可广播时就发送广播数据报。</p>
<h3 id="SO-DEBUG套接字选项"><a href="#SO-DEBUG套接字选项" class="headerlink" title="SO_DEBUG套接字选项"></a>SO_DEBUG套接字选项</h3><p>本选项仅由TCP支持。当给一个TCP套接字开启本选项时,内核将为TCP在该套接字发送和接收的所有分组保留详细跟踪信息。这些信息保存在内核的某个环形缓冲区中,并可使用trpt程序进行检查。</p>
<h3 id="SO-DONTROUTE套接字选项"><a href="#SO-DONTROUTE套接字选项" class="headerlink" title="SO_DONTROUTE套接字选项"></a>SO_DONTROUTE套接字选项</h3><p>本选项规定外出的分组将绕过底层协议的正常路由机制</p>
<h3 id="SO-ERROR套接字选项"><a href="#SO-ERROR套接字选项" class="headerlink" title="SO_ERROR套接字选项"></a>SO_ERROR套接字选项</h3><p>当一个套接字上发生错误时,源自 Berkeley的内核中的协议模块将该套接字的名为so_error的变量设为标准的Unix Exxx值中的一个,我们称它为该套接字的待处理错误( pendingeror)。内核能够以下面两种方式之一立即通知进程这个错误。</p>
<ol>
<li>如果进程阻塞在对该套接字的 select调用上,那么无论是检查可读条件还是可写条件, select均返回并设置其中一个或所有两个条件。</li>
<li>如果进程使用信号驱动式I/O模型,那就给进程或进程组产生一个SIGTO信号。</li>
</ol>
<h3 id="SO-KEEPALIVE套接字选项"><a href="#SO-KEEPALIVE套接字选项" class="headerlink" title="SO_KEEPALIVE套接字选项"></a>SO_KEEPALIVE套接字选项</h3><p>给一个TCP套接字设置保持存活( keep-alive)选项后,如果2小时内在该套接字的任一方向上都没有数据交换,TCP就自动给对端发送一个保持存活探测分节( keep-alive probe)。这是一个对端必须响应的TCP分节,它会导致以下三种情况之一</p>
<ul>
<li>对端以期望的ACK响应。应用进程得不到通知(因为一切正常)。在又经过仍无动静的时后,TCP将发出另一个探测分节。</li>
<li>对端以RST响应,它告知本端TCP:对端已崩溃且己重新启动。该套接字的待处理错误被置为 ECONNRESET,套接字本身则被关闭。</li>
<li>对端对保持存活探测分节没有任何响应。</li>
</ul>
<p>本选项的功用是检测对端主机是否崩溃或变得不可达(譬如拨号调制解调器连接掉线,电源发生故障,等等)。如果对端进程崩溃,它的TCP将跨连接发送一个FIN,这可以通过调用select很容易地检测到。同时也要认识到,即使对任何保持存活探测分节均无响应(第三种情况),我们也不能肯定对端主机已经崩溃,因而TCP可能会终止一个有效连接。</p>
<p>本选项一般由服务器使用,不过客户也可以使用。服务器使用本选项是因为它们花大部分时间阻塞在等待穿越TCP连接的输入上,也就是说在等待客户的请求。然而如果客户主机连接掉线、电源掉电或系统崩溃,服务器进程将永远不会知道,并将继续等待永远不会到达的输入我们称这种情况为半开连接( half-open connection)。保持存活选项将检测出这些半开连接并终止它们。</p>
<h3 id="SO-LINGER套接字选项"><a href="#SO-LINGER套接字选项" class="headerlink" title="SO_LINGER套接字选项"></a>SO_LINGER套接字选项</h3><p>本选项指定close函数对面向连接的协议(例如TCP和SCTP,但不是UDP)如何操作。默认操作是c1ose立即返回,但是如果有数据残留在套接字发送缓冲区中,系统将试着把这些数据发送给对端。</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275638162436.jpg" alt=""></p>
<p>客户可以设置so_LINGER套接字选项,指定一个正的延滞时间。这种情况下客户的c1ose要到它的数据和FIN已被服务器主机的TCP确认后才返回</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275638674270.jpg" alt=""></p>
<p>然而我们会面临一个问题:在服务器应用进程读剩余数据之前,服务器主机可能崩溃,并且客户应用进程永远不会知道。更糟糕的是，下图展示了当给 SO_LINGER选项设置偏低的延滞时间值时可能发生的现象。</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275640017253.jpg" alt=""></p>
<p>让客户知道服务器已读取其数据的一个方法是改为调用shutdown(并设置它的第二个参数为 SHUT_WR)而不是调用c1ose,并等待对端c1ose连接的当地端(服务器端)。</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275641013574.jpg" alt=""></p>
<h2 id="IPv4套接字选项"><a href="#IPv4套接字选项" class="headerlink" title="IPv4套接字选项"></a>IPv4套接字选项</h2><p>这些套接字选项由IPv4处理,它们的级别(即 getsockopt和 setsockopt函数的第二个参数)为IPPROTO_IP。</p>
<h3 id="IP-HDRINCL套接字选项"><a href="#IP-HDRINCL套接字选项" class="headerlink" title="IP_HDRINCL套接字选项"></a>IP_HDRINCL套接字选项</h3><p>如果本选项是给一个原始IP套接字设置的,那么我们必须为所有在该原始套接字上发送的数据报构造自己的IP首部。一般情况下,在原始套接字上发送的数据报其IP首部是由内核构造的,不过有些应用程序(特别是路由跟踪程序 traceroute)需要构造自己的IP首部以取代IP置于该首部中的某些字段。</p>
<h3 id="IP-OPTIONS套接字选项"><a href="#IP-OPTIONS套接字选项" class="headerlink" title="IP_OPTIONS套接字选项"></a>IP_OPTIONS套接字选项</h3><p>本选项的设置允许我们在IPv4首部中设置IP选项</p>
<h3 id="IP-RECVDSTADDR套接字选项"><a href="#IP-RECVDSTADDR套接字选项" class="headerlink" title="IP_RECVDSTADDR套接字选项"></a>IP_RECVDSTADDR套接字选项</h3><p>本套接字选项导致所收到UDP数据报的且的IP地址由 recvmsg函数作为辅助数据返回</p>
<h3 id="IP-TOS套接字选项"><a href="#IP-TOS套接字选项" class="headerlink" title="IP_TOS套接字选项"></a>IP_TOS套接字选项</h3><p>本套接字选项允许我们为TCP、UDP或SCTP套接字设置IP首部中的服务类型字段</p>
<h2 id="TCP套接字选项"><a href="#TCP套接字选项" class="headerlink" title="TCP套接字选项"></a>TCP套接字选项</h2><p>TCP有两个套接字选项,它们的级别(即 get_sockopt和 set_sockopt函数的第二个参数)为IPPROTO_TCP。</p>
<h3 id="TCP-MAXSEG套接字选项"><a href="#TCP-MAXSEG套接字选项" class="headerlink" title="TCP_MAXSEG套接字选项"></a>TCP_MAXSEG套接字选项</h3><p>本选项允许我们获取或设置TCP连接的最大分节大小(MSS)。返回值是我们的TCP可以发送给对端的最大数据量,它通常是由对端使用SYN分节通告的MSS,除非我们的TCP选择使用个比对端通告的MSS小些的值。如果该值在相应套接字的连接建立之前取得,那么返回值是未从对端收到MSS选项的情况下所用的默认值。</p>
<h3 id="TCP-NODELAY套接字选项"><a href="#TCP-NODELAY套接字选项" class="headerlink" title="TCP_NODELAY套接字选项"></a>TCP_NODELAY套接字选项</h3><p>开启本选项将禁止TCP的 Nagle算法。默认情况下该算法是启动的。</p>
<p>Nagle算法的目的在于减少广域网(wAN)上小分组的数目。该算法指出:如果某个给定连接上有待确认数据( outstanding data),那么原本应该作为用戶写操作之响应的在该连接上立即发送相应小分组的行为就不会发生,直到现有数据被确认为止。这里“小”分组的定义就是小于MSS的任何分组。TCP总是尽可能地发送最大大小的分组, Nagle算法的目的在于防止一个连接在任何时刻有多个小分组待确认。</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275651499834.jpg" alt=""></p>
<h2 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h2><p>与代表“file control”(文件控制)的名字相符,fcntl函数可执行各种描述符控制操作。</p>
<p>fcntl函数提供了与网络编程相关的如下特性:</p>
<ul>
<li>非阻塞式I/O。通过使用F_SETFL命令设置O_NONBLOCK文件状态标志,我们可以把一个套接字设置为非阻塞型。</li>
<li>信号驱动式I/O。通过使用F_SEFL命令设置o_ASYNC文件状态标志,我们可以把一个套接字设置成一旦其状态发生变化,内核就产生一个SIGIO信号。</li>
<li>F_SETOWN命令允许我们指定用于接收SIGIO和SIGURG信号的套接字属主(进程ID或进程组IO)。其中 SIGIO信号是套接字被设置为信号驱动式I/O型后产生的,SIGURG信号是在新的带外数据到达套接字时产生的。F_GETOWN命令返回套接字的当前属主。</li>
</ul>
<h1 id="基本UDP套接字编程"><a href="#基本UDP套接字编程" class="headerlink" title="基本UDP套接字编程"></a>基本UDP套接字编程</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>在使用TCP编写的应用程序和使用UDP编写的应用程序之间存在一些本质差异,其原因在于这两个传输层之间的差别:UDP是无连接不可靠的数据报协议,非常不同于TCP提供的面向连接的可靠字节流。然而相比TCP,有些场合确实更适合使用UDP</p>
<p>下图给出了典型的UDP客户服务器程序的函数调用。客户不与服务器建立连接,而是只管使用sendto函数给服务器发送数据报,其中必须指定目的地(即服务器)的地址作为参数。类似地,服务器不接受来自客户的连接,而是只管调用 recvfrom函数,等待来自客户的某个数据到达</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275736670682.jpg" alt=""></p>
<h2 id="recvfrom和sendto函数"><a href="#recvfrom和sendto函数" class="headerlink" title="recvfrom和sendto函数"></a>recvfrom和sendto函数</h2><p>这两个函数类似于标准的read和write函数,不过需要三个额外的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags, <span class="keyword">struct</span> sockaddr *from, <span class="keyword">socklen_t</span> *addrlen);</div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *to, <span class="keyword">socklen_t</span> addrlen);</div><div class="line"></div><div class="line"><span class="comment">// Both return: number of bytes read or written if OK, –1 on error</span></div></pre></td></tr></table></figure>
<p>前三个参数<code>sockfd</code>、<code>buff</code>和<code>nbytes</code>等同于read和write函数的三个参数:描述符、指向读入或写出缓冲区的指针和读写字节数</p>
<p>sendto的to参数指向一个含有数据报接收者的协议地址(例如IP地址及端口号)的套接字地址结构,其大小由 addrlen参数指定。 recvfrom的fom参数指向一个将由该函数在返回时填写数据报发送者的协议地址的套接字地址结构,而在该套接字地址结构中填写的字节数则放在addrlen参数所指的整数中返回给调用者。注意, sendto的最后一个参数是一个整数值,而recvfrom的最后一个参数是一个指向整数值的指针(即值-结果参数)。</p>
<h2 id="数据报的丢失"><a href="#数据报的丢失" class="headerlink" title="数据报的丢失"></a>数据报的丢失</h2><p>我们的UDP客户服务器例子是不可靠的。如果一个客户数据报丢失(譬如说,被客户主机与服务器主机之间的某个路由器丢弃),客户将永远阻塞于dg_cli函数中的recvfrom调用,等待一个永远不会到达的服务器应答。类似地,如果客户数据报到达服务器,但是服务器的应答丢失了,客户也将永远阻塞于recvfrom调用。防止这样永久阻塞的一般方法是给客户的recvfrom调用设置一个超时。</p>
<p>但是仅仅给recvfrom调用设置超时并不是完整的解决办法。</p>
<h2 id="UDP的connect函数"><a href="#UDP的connect函数" class="headerlink" title="UDP的connect函数"></a>UDP的connect函数</h2><p>除非套接字已连接,否则异步错误是不会返回到UDP套接字的。我们确实可以给UDP套接字调用 connect(4,3节),然而这样做的结果却与TCP连接大相径庭:没有三路握手过程。内核只是检查是否存在立即可知的错误(例如一个显然不可达的目的地),记录对端的P地址和端口号(取自传递给 connect的套接字地址结构),然后立即返回到调用进程。</p>
<p>对于已连接UDP套接字,与默认的未连接UDP套接字相比,发生了三个变化</p>
<ol>
<li>我们再也不能给输出操作指定目的IP地址和端口号。也就是说,我们不使用sendto,而改用write或send写到已连接UDP套接字上的任何内容都自动发送到由connect指定的协议地址（例如IP地址和端口号）</li>
<li>我们不必使用recvfrom以获悉数据报的发送者,而改用read、recv或recvmsg</li>
<li>由已连接UDP套接字引发的异步错误会返回给它们所在的进程,而未连接UDP套接字不接收任何异步错误。</li>
</ol>
<p><img src="http://data3.liuin.cn/2018-05-29-15275750978867.jpg" alt=""></p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275751182016.jpg" alt=""></p>
<h3 id="给一个UDP套接字多次调用connect"><a href="#给一个UDP套接字多次调用connect" class="headerlink" title="给一个UDP套接字多次调用connect"></a>给一个UDP套接字多次调用connect</h3><p>拥有一个已连接UDP套接字的进程可出于下列两个目的之一再次调用 connect:</p>
<ol>
<li>指定新的IP地址和端口号</li>
<li>断开套接字。</li>
</ol>
<p>第一个目的(即给一个已连接UDP套接字指定新的对端)不同于TCP套接字中 connect的使用:对于TCP套接字, connect只能调用一次。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>当应用进程在一个未连接的UDP套接字上调用sendto时,源自Berkeley的内核暂时连接该套接字,发送数据报,然后断开该连接。在一个未连接的UDP套接字上给两个数据报调用sendto函数于是涉及内核执行下列6个步骤:</p>
<ul>
<li>连接套接字;</li>
<li>输出第一个数据报;</li>
<li>断开套接字连接;</li>
<li>连接套接字;</li>
<li>输出第二个数据报;</li>
<li>断开套接字连接。</li>
</ul>
<p>当应用进程知道自己要给同一目的地址发送多个数据报时,显式连接套接字效率更高。调用 connect后调用两次 write涉及内核执行如下步骤:</p>
<ul>
<li>连接套接字</li>
<li>输出第一个数据报</li>
<li>输出第二个数据报</li>
</ul>
<p>在这种情况下,内核只复制一次含有目的IP地址和端口号的套接字地址结构,相反当调用两次 sendto时,需复制两次。临时连接未连接的UDP套接字大约会耗费每个UDP传输三分之一的开销。</p>
<h1 id="名字与地址转换"><a href="#名字与地址转换" class="headerlink" title="名字与地址转换"></a>名字与地址转换</h1><p>到目前为止,以上所有例子都用数值地址来表示主机,用数值端口号来标识服务器。然而出于许多理由,我们应该使用名字而不是数值:名字比较容易记住;数值地址可以变动而名字保持不变;随着往Iv6上转移,数值地址变得相当长,手工键入数值地址更易出错。</p>
<h2 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h2><p>域名系统( Domain Name System,DNS)主要用于主机名字与IP地址之间的映射。主机名既可以是一个简单名字(simple name),,也可以是一个全限定域名(Fully Qualified Domain Name, FQDN), 比如说www.baidu.com</p>
<h3 id="资源记录"><a href="#资源记录" class="headerlink" title="资源记录"></a>资源记录</h3><p>DNS中记录的条目称为资源记录，主要的有以下几种：</p>
<ul>
<li>A记录把一个主机名映射成一个32位的IPV4地址</li>
<li>AAAA称为“四A”把一个主机名映射成一个128位的Iv6</li>
<li>称为“指针记录”( pointer record)的PTR记录把IP地址映射成主机名</li>
<li>MX记录把一个主机指定作为给定主机的“邮件交换器”</li>
</ul>
<h3 id="解析器和名字服务器"><a href="#解析器和名字服务器" class="headerlink" title="解析器和名字服务器"></a>解析器和名字服务器</h3><p>每个组织机构往往运行一个或多个名字服务器。常见的解析所做的东西就是把主机名映射成IPv4地址和做相反的映射。</p>
<p><img src="http://data3.liuin.cn/2018-06-14-15289459622135.jpg" alt=""></p>
<h3 id="DNS替代方案"><a href="#DNS替代方案" class="headerlink" title="DNS替代方案"></a>DNS替代方案</h3><p>不使用DNS也可能获取名字和地址信息。常用的替代方法有静态主机文件(通常是etc/hosts文件)、网络信息系统( Network Information System,NIS)以及轻权目录访问协议( Lightweight Directory Access Protocol,LDAP)。</p>
<h2 id="gethostbyname函数"><a href="#gethostbyname函数" class="headerlink" title="gethostbyname函数"></a>gethostbyname函数</h2><p>查找主机名最基本的函数是 gethostbyname。如果调用成功,它就返回一个指向 hostent结构的指针,该结构中含有所查找主机的所有IPv4地址。这个函数的局限是只能返回IPv4地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> hostent *<span class="title">gethostbyname</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *hostname)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: non-null pointer if OK,NULL on error with h_errno se</span></div></pre></td></tr></table></figure>
<p>hostent的数据结构如下：</p>
<p><img src="http://data3.liuin.cn/2018-06-14-15289462083765.jpg" alt=""></p>
<p><img src="http://data3.liuin.cn/2018-06-14-15289462760527.jpg" alt=""></p>
<p>gethostbyname执行的是对A记录的查询，所以只能够返回IPv4的地址</p>
<h2 id="gethostbyaddr函数"><a href="#gethostbyaddr函数" class="headerlink" title="gethostbyaddr函数"></a>gethostbyaddr函数</h2><p>gethostbyaddr的功能刚好和gethostbyname相反，试图由一个二进制的IP地址找到相应的主机名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> hostent *<span class="title">gethostbyaddr</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">socklen_t</span> len, <span class="keyword">int</span> family)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: non-null pointer if OK, NULL on error with h_errno set</span></div></pre></td></tr></table></figure>
<h2 id="getservbyname和-getservbyport函数"><a href="#getservbyname和-getservbyport函数" class="headerlink" title="getservbyname和 getservbyport函数"></a>getservbyname和 getservbyport函数</h2><p>像主机一样,<strong>服务也通常靠名字来认知</strong>。如果我们在程序代码中通过其名字而不是其端口号来指代一个服务,而且从名字到端口号的映射关系保存在一个文件中(通常是/etc/services),那么即使端口号发生变动,我们需修改的仅仅是/etc/services文件中的某行,而不必重新编译应用程序。</p>
<p>getservtbyname函数用于根据给定名字查找相应服务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> servent *<span class="title">getservbyname</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *servname, <span class="keyword">const</span> <span class="keyword">char</span> *protoname)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: non-null pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
<p>返回的servent结构：</p>
<p><img src="http://data3.liuin.cn/2018-06-14-15289465680796.jpg" alt=""></p>
<p>服务名参数 servname必须指定。如果同时指定了协议(即protoname参数为非空指针),那么指定服务必须有匹配的协议。有些因特网服务既用TCP也用UDP提供,其他因特网服务则仅仅支持单个协议(例如FTP要求使用TCP)。如果 protoname未指定而 servname指定服务支持多个协议,那么返回哪个端口号取决于实现。</p>
<p>getservbyport用于根据给定端口号和可选协议査找相应服务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> servent *<span class="title">getservbyport</span> <span class="params">(<span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *protoname)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: non-null pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《STL源码剖析》 笔记]]></title>
      <url>/2018/05/20/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B-%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>侯捷老师的《STL源码剖析》可谓是学习STL的经典。在书籍的自序中侯捷老师提到的”我的确认为99.99%的程序员所写的程序，在SGI STL面前都是三流水平“，这让我等菜鸟根本把持不住呀。</p>
<a id="more"></a>
<h1 id="空间配置其（allocator）"><a href="#空间配置其（allocator）" class="headerlink" title="空间配置其（allocator）"></a>空间配置其（allocator）</h1><p>以STL的运用角度而言，空间配置器是最不需要介绍的东西，它总是隐藏在切组件(更具体地说是指容器， container)的背后，默默工作，默默付出。但若以STL的实现角度而言，第一个需要介绍的就是空间配置器，因为整个<strong>STL的操作对象(所有的数值)都存放在容器之内</strong>，而容器一定需要配置空间以置放资料不先掌握空间配置器的原理，难免在阅读其它STL组件的实现时处处遇到挡路石。</p>
<h2 id="空间配置器的标准接口"><a href="#空间配置器的标准接口" class="headerlink" title="空间配置器的标准接口"></a>空间配置器的标准接口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">allocator::value_type</div><div class="line">allocator::pointer</div><div class="line">allocator::const_pointer</div><div class="line">allocator::reference</div><div class="line">allocator::const_reference</div><div class="line">allocator::sieze_type</div><div class="line">allocator::defference_type</div><div class="line"><span class="comment">// 一个嵌套的(nested) class template。 class rebind&lt;U&gt;拥有唯一成员other，那是一个 typedef，代表allocator&lt;U&gt;</span></div><div class="line">allocator::rebind</div><div class="line"><span class="comment">// default constructor</span></div><div class="line">allocator::allocator()</div><div class="line"><span class="comment">// copy constructor</span></div><div class="line">allocator::allocator(<span class="keyword">const</span> allocator&amp;)</div><div class="line"><span class="comment">// 泛化的 copy constructor</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;allocator::allocator(<span class="keyword">const</span> allocator&lt;U&gt;&amp;)</div><div class="line"><span class="comment">// 默认析构</span></div><div class="line">allocator::~allocator()</div><div class="line"><span class="comment">// 返回某个对象的地址</span></div><div class="line">pointer allocator::address(reference x) <span class="keyword">const</span></div><div class="line"><span class="comment">// 返回某个const对象的地址</span></div><div class="line">const_pointer allocator::address(const_reference x) <span class="keyword">const</span></div><div class="line"><span class="comment">// 配置空间，足以存储n个T对象</span></div><div class="line">pointer allocator::allocate(size_type n， <span class="keyword">const</span> <span class="keyword">void</span>* = <span class="number">0</span>)</div><div class="line"><span class="comment">// 归还先前配置的空间</span></div><div class="line"><span class="keyword">void</span> allocator::deallocate(pointer p， size_type n)</div><div class="line"><span class="comment">// 返回可成功配置的最大量</span></div><div class="line">size_type allocator::max_size() <span class="keyword">const</span></div><div class="line"><span class="comment">// 等同于 new(const void*) p) T(x)</span></div><div class="line"><span class="keyword">void</span> allocator::construct(pointer p， <span class="keyword">const</span> T&amp; x)</div><div class="line"><span class="comment">// 等同于 p-&gt;~T()</span></div><div class="line"><span class="keyword">void</span> allocator::destory(pointer p)</div></pre></td></tr></table></figure>
<h2 id="具备次配置力-sub-allocation-的SGI空间配置器"><a href="#具备次配置力-sub-allocation-的SGI空间配置器" class="headerlink" title="具备次配置力(sub-allocation)的SGI空间配置器"></a>具备次配置力(sub-allocation)的SGI空间配置器</h2><p>SGI STI的配置器与众不同，也与标准规范不同，其名称是a1loc而非allocator，而且不接受任何参数。</p>
<h3 id="SGI的标准空间配置器，std-allocator"><a href="#SGI的标准空间配置器，std-allocator" class="headerlink" title="SGI的标准空间配置器，std::allocator"></a>SGI的标准空间配置器，std::allocator</h3><p>虽然SGI也定义有一个符合部分标准、名为allocator的配置器，但SGI自己从未用过它，也不建议我们使用。主要原因是效率不佳，只把C++的<code>::operator new</code>和<code>::operator delete</code>做一层薄薄的包装而已。</p>
<h3 id="SGI特殊的空间配置器，std-alloc"><a href="#SGI特殊的空间配置器，std-alloc" class="headerlink" title="SGI特殊的空间配置器，std::alloc"></a>SGI特殊的空间配置器，std::alloc</h3><p>一般而言，我们所习惯的C++内存配置操作和释放操作是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Foo &#123; ... &#125;;</div><div class="line"></div><div class="line">Foo* pf = <span class="keyword">new</span> Foo;</div><div class="line"><span class="keyword">delete</span> pf;</div></pre></td></tr></table></figure>
<p>这其中的new算式内含两阶段操作(1)调用:: operator new配置内存;(2)调用Foo::Foo()构造对象内容。<br>delete算式也内含两阶段操作:(1)调用Foo::~FOO()将对象析构:(2)调用::operator delete释放内存</p>
<p>为了精密分工， STL allocator决定将这两阶段操作区分开来。内存配置操作由a11c:allocate()负责，内存释放操作由alloc::deallocate()负责对象构造操作由::construct()负责，对象析构操作由::destroy()负责。</p>
<p>配置器定义在<memory>中，SGI<memory>的主要组成如下：</memory></memory></p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270395375460.jpg" alt=""></p>
<h3 id="构造和析构基本工具-construct-和-destroy"><a href="#构造和析构基本工具-construct-和-destroy" class="headerlink" title="构造和析构基本工具: construct()和 destroy()"></a>构造和析构基本工具: construct()和 destroy()</h3><p><img src="https://data2.liuin.cn/2018-05-23-15270396596949.jpg" alt=""></p>
<h3 id="空间的配置与释放"><a href="#空间的配置与释放" class="headerlink" title="空间的配置与释放"></a>空间的配置与释放</h3><p>对象构造前的空间配置和对象析构后的空间释放，由<stla1loc.h>负责，SGI对此的设计哲学如下:</stla1loc.h></p>
<ul>
<li>向 system heap要求空间</li>
<li>考虑多线程( multi-threads)状态</li>
<li>考虑内存不足时的应变措施</li>
<li>考虑过多“小型区块”可能造成的内存碎片( fragment)问题</li>
</ul>
<p>考虑到小型区块所可能造成的内存破碎问题，SGI设计了<strong>双层级配置器</strong>：</p>
<p>第一级配置器直接使用malloc()和free()，第二级配置器则视情况采用不同的策略:当配置区块超过128 bytes时，视之为“足够大”，便调用第一级配置器;<strong>当配置区块小于128 bytes时，视之为“过小”，为了降低额外负担，便采用复杂的memory pool整理方式，而不再求助于第一级配置器</strong>。整个设计究竟只开放第一级配置器，或是同时开放第二级配置器</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270402949330.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270403004835.jpg" alt=""></p>
<h3 id="第一级配置器"><a href="#第一级配置器" class="headerlink" title="第一级配置器"></a>第一级配置器</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">template &lt;int inst&gt;</div><div class="line">class __malloc_alloc_template &#123;</div><div class="line">private:</div><div class="line">//malloc调用内存不足时调用函数</div><div class="line">static void *oom_malloc(size_t);</div><div class="line">//realloc调用内存不足时调用函数</div><div class="line">static void *oom_realloc(void *, size_t);</div><div class="line">//错误处理函数，类似C++的set_new_handler，默认值为０，如果不设置，则内存分配失败时，返回THROW_BAD_ALLOC</div><div class="line">#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG</div><div class="line">    static void (* __malloc_alloc_oom_handler)();</div><div class="line">#endif</div><div class="line">public:</div><div class="line">static void * allocate(size_t n)</div><div class="line">&#123;</div><div class="line">    void *result = malloc(n);	第一级配置器直接使用malloc分配内存</div><div class="line">    if (0 == result) result = oom_malloc(n);//如果分配失败，则调用oom_malloc()</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line">static void deallocate(void *p, size_t /* n */)</div><div class="line">&#123;</div><div class="line">    free(p);	//第一级配置器用free回收内存</div><div class="line">&#125;</div><div class="line">static void * reallocate(void *p, size_t /* old_sz */, size_t new_sz)</div><div class="line">&#123;</div><div class="line">    void * result = realloc(p, new_sz);	//第一级配置器用reallocate重分配内存</div><div class="line">    if (0 == result) result = oom_realloc(p, new_sz);／／分配失败，调用oom_realloc分配</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line">// 设置分配错误处理函数，用于在oom_malloc和oom_realloc中使用</div><div class="line">static void (* set_malloc_handler(void (*f)()))()</div><div class="line">&#123;</div><div class="line">    void (* old)() = __malloc_alloc_oom_handler;</div><div class="line">    __malloc_alloc_oom_handler = f;</div><div class="line">    return(old);</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">template &lt;int inst&gt;</div><div class="line">void * __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n)</div><div class="line">&#123;</div><div class="line">    void (* my_malloc_handler)();//声明一个函数指针，用于赋值 __malloc_alloc_oom_handler</div><div class="line">    void *result;//返回的内存指针</div><div class="line">    for (;;) &#123;	// 不断尝试释放内存，分配，再释放，再分配...</div><div class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</div><div class="line">        if (0 == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;//为设置处理函数时，抛出错误</div><div class="line">        (*my_malloc_handler)();		// 调用处理函数，尝试释放内存</div><div class="line">        result = malloc(n);			// 再重新分配内存。</div><div class="line">        if (result) return(result);//如果分配成功，返回指针</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">template &lt;int inst&gt;</div><div class="line">void * __malloc_alloc_template&lt;inst&gt;::oom_realloc(void *p, size_t n)</div><div class="line">&#123;</div><div class="line">    void (* my_malloc_handler)();</div><div class="line">    void *result;</div><div class="line">    for (;;) &#123;	// 不断尝试释放内存，分配，再释放，再分配...</div><div class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</div><div class="line">        if (0 == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;////为设置处理函数时，抛出错误</div><div class="line">        (*my_malloc_handler)();	//  调用处理函数，尝试释放内存</div><div class="line">        result = realloc(p, n);	// 再重新分配内存。</div><div class="line">        if (result) return(result);////如果分配成功，返回指针</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一级配置器以malloc(),free(), realloc()等C函数执行实际的内存配置、释放、重配置操作,并实现出类似C++ new-handler 的机制。所谓C++ new handler机制是,你可以要求系统在内存配置需求无法被满足时,调用一个你所指定的函数。</p>
<p>SGI第一级配置器的allocate()和 realloc()都是在调用ma11oc()和rea11oc()不成功后,改调用 oom_ma11oc()和oom_realloc()。后两者都有内循环,不断调用“内存不足处理例程”,期望在某次调用之后,获得足够的内存而圆满完成任务。</p>
<h3 id="第二级配置器"><a href="#第二级配置器" class="headerlink" title="第二级配置器"></a>第二级配置器</h3><p>第二级配置器多了一些机制,避免太多小额区块造成内存的碎片。小额区块带来的其实不仅是内存碎片,配置时的额外负担(overhead)也是一个大问题。额外负担永远无法避免,毕竟系统要靠这多出来的空间来管理内存。但是区块愈小,额外负担所占的比例就愈大,愈显得浪费</p>
<p>SGI第二级配置器的做法是,如果区块够大,超过128 bytes时,就移交第级配置器处理。当区块小于128 bytes时,则以内存池( memory pool)管理,此法又称为次层配置(sub-allocation):每次配置一大块内存,并维护对应之自由链表(free-list)。下次若再有相同大小的内存需求,就直接从free-lists中拨出。如果客端释还小额区块,就由配置器回收到free-lists中——是的,别忘了,配置器除了负责配置,也负责回收。</p>
<p>为了方便管理,SGl第二级配置器会主动将任何小额区块的内存<strong>需求量上调至8的倍数</strong>(例如客端要求30 bytes,就自动调整为32 bytes)并维护16个free-lists,各自管理大小分别为8,16,24,32,40,48,56,64,72,80,88,96,104,l12,120,128 bytes的小额区块。 </p>
<p>free-lists的节点结构如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> obj &#123;</div><div class="line">      <span class="keyword">union</span> obj * free_list_link;<span class="comment">//指向下一个内存的地址</span></div><div class="line">      <span class="keyword">char</span> client_data[<span class="number">1</span>];    <span class="comment">//内存的首地址</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><img src="https://data2.liuin.cn/2018-05-23-15270421196298.jpg" alt=""></p>
<h1 id="迭代器概念与traits编程技法"><a href="#迭代器概念与traits编程技法" class="headerlink" title="迭代器概念与traits编程技法"></a>迭代器概念与traits编程技法</h1><p>在设计模式中有一种迭代器模式，其定义如下：提供一种方法，使之能够依序巡访某个聚合物(容器)所含的各个元素，而又无需暴露该聚合物的内部表述方式</p>
<h2 id="迭代器设计思维——STL关键所在"><a href="#迭代器设计思维——STL关键所在" class="headerlink" title="迭代器设计思维——STL关键所在"></a>迭代器设计思维——STL关键所在</h2><p>STL的中心思想在于:将数据容器( containers)和算法 algorithms)分开，彼此独立设计，最后再以一帖胶着剂将它们撮合在一起。容器和算法的泛型化，从技术角度来看并不困难，C++的class templates和 function templates可分别达成目标。如何设计出两者之间的良好胶着剂，才是大难题</p>
<h2 id="迭代器是一种smart-pointer"><a href="#迭代器是一种smart-pointer" class="headerlink" title="迭代器是一种smart pointer"></a>迭代器是一种smart pointer</h2><p>迭代器是一种行为类似指针的对象，而指针的各种行为中最常见也最重要的便是内容提领(dereference)和成员访问( member access)，因此，迭代器最重要的编程工作就是对 operator*和 operator-&gt;进行重载( overloading)工作。</p>
<p>在设计实现每一个容器的迭代器的时候都会暴露许多这些容器的一些实现细节的东西，要设计出 LIstitem，首先必须对List的实现细节有非常丰富的了解。既然这无可避免，干脆就把迭代器的开发工作交给List的设计者好了，如此一来，所有实现细节反而得以封装起来不被使用者看到。<strong>这正是为什么每一种STL容器都提供有专属迭代器的缘故</strong></p>
<h2 id="迭代器相应的型别"><a href="#迭代器相应的型别" class="headerlink" title="迭代器相应的型别"></a>迭代器相应的型别</h2><p>迭代器中相应的型别之一是迭代器所指之物的型别</p>
<p>迭代器相应型别(associated types)不只是“迭代器所指对象的型别”一种而已。根据经验，最常用的相应型别有五种，然而并非任何情况下任何一种都可利用上述的 template参数推导机制来取得.我们需要更全面的解法</p>
<h1 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h1><h2 id="容器的概观与分类"><a href="#容器的概观与分类" class="headerlink" title="容器的概观与分类"></a>容器的概观与分类</h2><p>研究数据的特定排列方式，以利于搜寻或排序或其它特殊目的，这一专门学科我们称为数据结构( Data Structures)。大学信息类相关教育里面，与编程最有直接关系的科目，首推数据结构与算法( Algorithms)。几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。STL容器即是将运用最广的一些数据结构实现出来</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267795512022.jpg" alt=""></p>
<blockquote>
<p>序列式容器</p>
</blockquote>
<p>所谓序列式容器，其中的<strong>元素都可序( ordered)，但未必有序( sorted)</strong>。C++语言本身提供了一个序列式容器 array，STL另外再提供 vector， list， deque， stack， queue， priority-queue等等序列式容器。其中 stack和 queue由于只是将 deque改头换面而成，技术上被归类为一种配接器( adapter)</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="vector-概述"><a href="#vector-概述" class="headerlink" title="vector 概述"></a>vector 概述</h3><p>vector的数据安排以及操作方式，与 array非常相似。两者的唯一差别在于空间的运用的灵活性。 array是静态空间，一旦配置了就不能改变，如果需要更多的空间需要用户自己解决。vector是动态空间，随着元素的加人，它的内部机制会自行扩充空间以容纳新元素。因此， vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必因为害怕空间不足而开始就要求一个大块头 array了，我们可以安心使用 vector，吃多少用多少</p>
<h3 id="vector-迭代器"><a href="#vector-迭代器" class="headerlink" title="vector 迭代器"></a>vector 迭代器</h3><p>vector维护的是一个连续线性空间，所以不论其元素型别为何，<strong>普通指针都可以作为 vector的迭代器而满足所有必要条件</strong>，因为 vector迭代器所需要的操作行为普通指针天生就具备。 vector支持随机存取，而普通指针正有着这样的能力。所以， vector提供的是 Random Access Iterators。</p>
<h3 id="vector-的数据结构"><a href="#vector-的数据结构" class="headerlink" title="vector 的数据结构"></a>vector 的数据结构</h3><p>vector所采用的数据结构非常简单:线性连续空间。它以两个迭代器 start和 finish分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器end_of_storage指向整块连续空间(含备用空间)的尾端</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T， <span class="keyword">class</span> Alloc = alloc&gt;</div><div class="line"><span class="keyword">class</span> <span class="built_in">vector</span>&#123;</div><div class="line">...</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    iterator start;</div><div class="line">    iterator finish;</div><div class="line">    iterator end_of_storage;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了降低空间配置时的速度成本， vector实际配置的大小可能比客户端需求量更大一些，以备将来可能的扩充。这便是容量( capacity)的观念。换句话说个 vector的容量永远大于或等于其大小。一旦容量等于大小，便是满载，下次再有新增元素，整个 vector就得另觅居所</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267802557974.jpg" alt=""></p>
<h3 id="vector-的构造和内存管理"><a href="#vector-的构造和内存管理" class="headerlink" title="vector 的构造和内存管理"></a>vector 的构造和内存管理</h3><p>当我们以 push_back()将新元素插入于 vector尾端时，该函数首先检查是否还有备用空间，如果有就直接在备用空间上构造元素，并调整迭代器 finish，使vector变大。如果没有备用空间了，就扩充空间(重新配置、移动数据、释放原空间)</p>
<p>注意，所谓动态增加大小，并不是在原空间之后接续新空间(因为无法保证原空间之后尚有可供配置的空间)，而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此对 vector的任何操作，<strong>一旦引起空间重新配置，指向原 vector的所有迭代器就都失效了</strong>。这是程序员易犯的一个错误，务需小心</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="list-概述"><a href="#list-概述" class="headerlink" title="list 概述"></a>list 概述</h3><p>相较于vector的连续线性空间，list就显得复杂许多，它的好处是每次插人或删除一个元素，就配置或释放一个元素空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素移除，list永远是常数时间。</p>
<p>list和 vector是两个最常被使用的容器。什么时机下最适合使用哪一种容器，必须视元素的多寡、元素的构造复杂度、元素存取行为的特性而定。</p>
<h3 id="list的节点-node"><a href="#list的节点-node" class="headerlink" title="list的节点(node)"></a>list的节点(node)</h3><p>list的节点是一个典型的双向链表的结构</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267809077014.jpg" alt=""></p>
<h3 id="list的迭代器"><a href="#list的迭代器" class="headerlink" title="list的迭代器"></a>list的迭代器</h3><p>list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在储存空间中连续存在。list迭代器必须有能力指向list的节点，并有能力进行正确的递增、递减、取值、成员存取等操作。</p>
<p>由于STL list是一个双向链表(double linked-ist)，迭代器必须具备前移后移的能力，所以list提供的是 Bidirectional iteratorslist</p>
<p>有一个重要性质:插入操作( insert)和接合操作( splice)都不会造成原有的list迭代器失效。这在 vector是不成立的，因为 vector的插人操作可能造成内存的重新配置，导致原有的迭代器全部失效。甚至list的元素删除操作( erase)，也只有“指向被删除元素”的那个迭代器失效，其它迭代器不受任何影响</p>
<h3 id="list的数据结构"><a href="#list的数据结构" class="headerlink" title="list的数据结构"></a>list的数据结构</h3><p>SGL list不仅是一个双向链表，而且还是一个环状双向链表。所以它只需要个指针，便可以完整表现整个链表</p>
<p>如果让指针node指向刻意置于尾端的一个空白节点，node便能符合STL对于“前闭后开”区间的要求，成为1ast迭代器，如图所示</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267812961833.jpg" alt=""></p>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><h3 id="deque概述"><a href="#deque概述" class="headerlink" title="deque概述"></a>deque概述</h3><p>vector是单向开口的连续线性空间， deque则是一种双向开口的连续线性空间。所谓双向开口，意思是<strong>可以在头尾两端分别做元素的插入和删除操作</strong>。 vector当然也可以在头尾两端进行操作(从技术观点)，但是其头部操作效率奇差，无法被接受</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267815267741.jpg" alt=""></p>
<p>deque和 vector的最大差异，一在于deque允许于常数时间内对起头端进行元素的插入或移除操作，二在于 deque没有所谓容量( capacity)观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。换句话说，像 vector那样“因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在 deque是不会发生的。也因此， deque没有必要提供所谓的空间保留( reserve)功能</p>
<p>虽然 deque也提供 Ramdon Access iterator，但<strong>它的迭代器并不是普通指针，其复杂度和 vector不可以道里计</strong>(稍后看到源代码，你便知道)，这当然影响了各个运算层面。因此，除非必要，我们应尽可能选择使用 vector而非 deque</p>
<h3 id="deque的中控器"><a href="#deque的中控器" class="headerlink" title="deque的中控器"></a>deque的中控器</h3><p>deque是连续空间(至少逻辑上看来如此)，连续线性空间总令我们联想到array或 vector。 array无法成长， vector虽可成长，却只能向尾端成长，而且其所谓成长原是个假象，事实上是(1)另觅更大空间;(2)将原数据复制过去;(3)释放原空间三部曲。如果不是 <strong>vector每次配置新空间时都有留下一些余裕，其成长”假象所带来的代价将是相当高昂</strong></p>
<p>deque系由一段一段的定量连续空间构成。一旦有必要在 deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个 deque的头端或尾端deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象并提供随机存取的接口·避开了“重新配置、复制、释放”的轮回，<strong>代价则是复杂的迭代器架构</strong></p>
<p>受到分段连续线性空间的字面影响，我们可能以为 deque的实现复杂度和vector相比虽不中亦不远矣，其实不然。主要因为，既日<strong>分段连续线性空间，就必须有中央控制，而为了维持整体连续的假象，数据结构的设计及迭代器前进后退等操作都颇为繁琐</strong>。 deque的实现代码分量远比 vector或list都多得多</p>
<p>deque采用一块所谓的mqp(注意，不是STL的map容器)作为主控。这里所谓map是一小块连续空间，其中每个元素(此处称为一个节点，node)都是指针，指向另一段(较大的)连续线性空间，称为缓冲区。缓冲区才是 deque的储存空间主体。 </p>
<p>把令人头皮发麻的各种型别定义(为了型别安全，那其实是有必要的)整理下，我们便可发现，map其实是一个T**，也就是说它是一个指针，所指之物又是个指针，指向型别为T的一块空间，如图所示</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267828260370.jpg" alt=""></p>
<h3 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h3><p>deque是分段连续空间。维持其“整体连续”假象的任务，落在了迭代器的operator++和operator–两个运算子身上</p>
<p>让我们思考一下， deque迭代器应该具备什么结构。首先，它必须能够<strong>指出分段连续空间(亦即缓冲区)在哪里，其次它必须能够判断自己是否已经处于其所在缓冲区的边缘</strong>，如果是，一旦前进或后退时就必须跳跃至下一个或上一个缓冲区为了能够正确跳跃， deque必须<strong>随时掌握管控中心</strong>(map)。</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267830496256.jpg" alt=""></p>
<h3 id="deque的数据结构"><a href="#deque的数据结构" class="headerlink" title="deque的数据结构"></a>deque的数据结构</h3><p>deque除了维护一个先前说过的指向map的指针外，也维护 start，fini两个迭代器，分别指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素(的下一位置)。此外，它当然也必须记住目前的mqp大小。因为一旦mqp所提供的节点不足，就必须重新配置更大的一块map</p>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><h3 id="stack-概述"><a href="#stack-概述" class="headerlink" title="stack 概述"></a>stack 概述</h3><p>stack是一种先进后出( First In last out，FILO)的数据结构。它只有一个出口，形式如图4-18所示。 stack允许新增元素、移除元素、取得最顶端元素。但除了最顶端外，没有任何其它方法可以存取 stack的其它元素。换言之， stack不允许有遍历行为</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267835939355.jpg" alt=""></p>
<h3 id="stack-定义完整列表"><a href="#stack-定义完整列表" class="headerlink" title="stack 定义完整列表"></a>stack 定义完整列表</h3><p>以某种既有容器作为底部结构，将其接口改变，使之符合“先进后出”的特性，形成一个 stack，是很容易做到的， deque是双向开口的数据结构，若以dequ为底部结构并封闭其头端开口，便轻而易举地形成了一个 stack。因此， SGI STI便以 deque作为缺省情况下的 stack底部结构， stack的实现因而非常简单，源代码十分简短，本处完整列出</p>
<p>由于 stack系以底部容器完成其所有工作，而具有这种“修改某物接口，形成另一种风貌”之性质者，称为 adapter(配接器)，因此STL stack往往不被归类为 container(容器)，而被归类为 container adapter</p>
<h3 id="stack-没有迭代器"><a href="#stack-没有迭代器" class="headerlink" title="stack 没有迭代器"></a>stack 没有迭代器</h3><p>stack所有元素的进出都必须符合“先进后出”的条件，只有 stack顶端的元素，才有机会被外界取用。 stack不提供走访功能，也不提供迭代器</p>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h3 id="queue概述"><a href="#queue概述" class="headerlink" title="queue概述"></a>queue概述</h3><p>queue是一种先进先出( First In First Out，FIFO)的数据结构。它有两个出口。 queue允许新增元素、移除元素、从最底端加入元素、取得最顶端元素。但除了最底端可以加入、最顶端可以取出外，没有任何其它方法可以存取 queue的其它元素。换言之， queue不允许有遍历行为。</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267838406632.jpg" alt=""></p>
<h3 id="queue定义完整列表"><a href="#queue定义完整列表" class="headerlink" title="queue定义完整列表"></a>queue定义完整列表</h3><p>以某种既有容器为底部结构，将其接口改变，使其符合“先进先出”的特性形成一个 queue，是很容易做到的. deque是双向开口的数据结构，若以 deque为底部结构并封闭其底端的出口和前端的入口，便轻而易举地形成了一个 queue。因此， SGI STL便以 deque作为缺省情况下的 queue底部结构。</p>
<h3 id="queue没有迭代器"><a href="#queue没有迭代器" class="headerlink" title="queue没有迭代器"></a>queue没有迭代器</h3><p>queue所有元素的进出都必须符合“先进先出”的条件，只有 queue顶端的元素，才有机会被外界取用。 queue不提供遍历功能，也不提供迭代器</p>
<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><h3 id="heap概述"><a href="#heap概述" class="headerlink" title="heap概述"></a>heap概述</h3><p>heap并不归属于STL容器组件，它是个幕后英雄，扮演 priority queue的助手。顾名思义， priority queue允许用户以任何次序将任何元素推入容器内，但取出时一定是从优先权最高(也就是数值最高)的元素开始取。 binary max heap正是具有这样的特性，适合作为 priority queue的底层机制</p>
<p>如果使用list作为 priority queue的底层机制，元素插入操作可享常数时间。但是要找到list中的极值，却需要对整个list进行线性扫描。我们也可以改变做法，让元素插入前先经过排序这一关，使得list的元素值总是由小到大(或由大到小)，但这么一来，收之东隅却失之桑榆:虽然取得极值以及元素删除操作达到最高效率，可元素的插人却只有线性表现</p>
<p>比较麻辣的做法是以 binary search tree作为 prlorltyqueue的底层机制。这么一来，元素的插入和极值的取得就有O(logN)的表现但杀鸡用牛刀，未免小题大做，一来 binary search tree的输人需要足够的随机性，二来 binary search tree并不容易实现。 </p>
<p>比较适合的是binary heap的方案，所谓 binary heap就是一种 complete binary tree(完全二叉树)，也就是说，整棵 binary tree除了最底层的叶节点之外，是填满的，而最底层的叶节点(s)由左至右又不得有空隙。</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267842482184.jpg" alt=""></p>
<p>这么一来，我们需要的工具就很简单了:一个 array和一组heap算法(用来插入元素、删除元素、取极值，将某一整组数据排列成一个heap)</p>
<h3 id="heap算法"><a href="#heap算法" class="headerlink" title="heap算法"></a>heap算法</h3><h4 id="push-heap-算法"><a href="#push-heap-算法" class="headerlink" title="push_heap 算法"></a>push_heap 算法</h4><p><img src="https://data2.liuin.cn/2018-05-20-15267844079830.jpg" alt=""></p>
<h4 id="pop-heap-算法"><a href="#pop-heap-算法" class="headerlink" title="pop_heap 算法"></a>pop_heap 算法</h4><p><img src="https://data2.liuin.cn/2018-05-20-15267844125899.jpg" alt=""></p>
<h4 id="sort-heap-算法"><a href="#sort-heap-算法" class="headerlink" title="sort_heap 算法"></a>sort_heap 算法</h4><p>堆排序思想，不断对heap进行pop操作，达到排序效果</p>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><h3 id="priority-queue概述"><a href="#priority-queue概述" class="headerlink" title="priority_queue概述"></a>priority_queue概述</h3><p>顾名思义， priority_queue是一个拥有权值观念的 queue，它允许加人新元素、移除旧元素、审视元素值等功能。由于这是一个 queue，所以只允许在底端加入元素，并从顶端取出元素，除此之外别无其它存取元素的途径</p>
<p>priority_queue带有权值观念，其内的元素并非依照被推入的次序排列，而是自动依照元素的权值排列(通常权值以实值表示)。权值最高者，排在最前面</p>
<p>缺省情况下 priority_queue系利用一个max-heap完成，后者是一个以vector表现的 complete binary tree。max-heap可以满足priority_queue所需要的“依权值高低自动递增排序”的特性。</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267846191674.jpg" alt=""></p>
<h3 id="priority-queue定义完整列表"><a href="#priority-queue定义完整列表" class="headerlink" title="priority_queue定义完整列表"></a>priority_queue定义完整列表</h3><p>由于 priority-queue完全以底部容器为根据，再加上heap处理规则，所以其实现非常简单。缺省情况下是以 vector为底部容器。</p>
<p>queue以底部容器完成其所有工作。具有这种“修改某物接口，形成另一种风貌”之性质者，称为 adapter(配接器)，因此， STL prior1ty_ queue往往不被归类为 container(容器)，而被归类为 container adapter</p>
<h3 id="priority-queue没有迭代器"><a href="#priority-queue没有迭代器" class="headerlink" title="priority_queue没有迭代器"></a>priority_queue没有迭代器</h3><p>priority-queue的所有元素，进出都有一定的规则，只有 queue顶端的元素(权值最高者)，才有机会被外界取用。 priority_queue不提供遍历功能，也不提供迭代器。</p>
<h1 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h1><p>标准的STL关联式容器分为set(集合)和map(映射表)两大类，以及这两大类的衍生体 multiset(多键集合)和multimap(多键映射表)。这些容器的底层机制均以RB-tree(红黑树)完成。RB-tree也是一个独立容器，但并不开放给外界使用</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15268607936529.jpg" alt=""></p>
<p>所谓关联式容器，观念上类似关联式数据库(实际上则简单许多):每笔数据(每个元素)都有一个键值(key)和一个实值( value)。当元素被插人到关联式容器中时，容器内部结构(可能是RB-tree，也可能是hash-tab1e)便依照其键值大小，以某种特定规则将这个元素放置于适当位置.关联式容器没有所谓头尾(只有最大元素和最小元素)</p>
<h2 id="RB-tree（红黑树）"><a href="#RB-tree（红黑树）" class="headerlink" title="RB-tree（红黑树）"></a>RB-tree（红黑树）</h2><p>AVL-tree之外，另一个颇具历史并被广泛运用的平衡二又搜索树是RB-tree(红黑树)。所谓RB-tree，不仅是一个二叉搜索树，而且必须满足以下规则</p>
<ol>
<li>每个节点不是红色就是黑色</li>
<li>根节点为黑色</li>
<li>如果节点为红，其子节点必须为黑</li>
<li>任一节点至NULL(树尾端)的任何路径，所含之黑节点数必须相同</li>
</ol>
<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p>当插入一个新节点的时候，就会导致红黑树上面的规则被破坏。这个时候就要进行调整，其中包括了四种情况：</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15268627862296.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-21-15268628337631.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-21-15268628547016.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-21-15268628574449.jpg" alt=""></p>
<h3 id="RB-tree的元素操作"><a href="#RB-tree的元素操作" class="headerlink" title="RB-tree的元素操作"></a>RB-tree的元素操作</h3><p>RB-tree提供两种插入操作:insert_unique()和 insert_equal()，前者表示被插入节点的键值(key)在整棵树中必须独一无二(因此，如果树中已存在相同的键值，插入操作就不会真正进行)，后者表示被插入节点的键值在整棵树中可以重复，因此，无论如何插入都会成功(除非空间不足导致配置失败)。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set的特性是，所有元素都会根据元素的键值自动被排序。set的元素不像map那样可以同时拥有实值( value)和键值(key)，set元素的键值就是实值实值就是键值。<strong>set不允许两个元素有相同的键值</strong></p>
<p>我们可以通过set的迭代器改变set的元素值吗?不行，因为set元素值就是其键值，关系到set元素的排列规则。如果任意改变set元素值，会严重破坏set组织。set iterators是一种constant iterators(相对于 mutable iterators)</p>
<p>set拥有与1ist相同的某些性质:当<strong>客户端对它进行元素新增操作( insert)或删除操作( erase)时，操作之前的所有迭代器，在操作完成之后都依然有效</strong>。当然，被删除的那个元素的迭代器必然是个例外</p>
<p>由于RB-tree是一种平衡二叉搜索树，自动排序的效果很不错，所以标准的STL set即以RB-tree为底层机制。又由于set所开放的各种操作接口，RB-tree也都提供了，所以几乎所有的set操作行为，都只是转调用RB→tree的操作行为而已</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map的特性是，所有元素都会根据元素的键值自动被排序。map的所有元素都是pair，同时拥有实值( value)和键值(key)。pair的第一元素被视为键值第二元素被视为实值.map不允许两个元素拥有相同的键值。</p>
<p>可以通过map的迭代器修改value的值，但是不能更改key的值，因为修改key会破坏map的组织结构。因此， map iterators既不是一种constant iterators，也不是一种 mutable iterators</p>
<p>map拥有和1ist相同的某些性质:当客户端对它进行元素新增操作或删除操作时，操作之前的所有迭代器，在操作完成之后都依然有效。当然，被删除的那个元素的迭代器必然是个例外</p>
<p>map底层以RB-tree为实现机制，主要调用的是底层RB-tree的各种接口</p>
<h2 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h2><p>multiset的特性以及用法和set完全相同，唯一的差别在于它允许键值重复，因此它的插入操作采用的是底层机制RB-tree的 insert_equa1()而非insert unique()。</p>
<h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h2><p>multimap的特性以及用法与map完全相同，唯一的差别在于它允许键值重复，因此它的插入操作采用的是底层机制RB-tree的 insert_equal()而非insert_unique()。</p>
<h2 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h2><p>二叉搜索树具有对数平均时间(logarithmic average time)的表现，但这样的表现构造在一个假设上:输入数据有足够的随机性。这一节要介绍一种名为hashtable(散列表)的数据结构，这种结构在插人、删除、搜寻等操作上也具有“常数平均时间”的表现，而且这种表现是以统计为基础，不需仰赖输入元素的随机性</p>
<h3 id="hashtable-概述"><a href="#hashtable-概述" class="headerlink" title="hashtable 概述"></a>hashtable 概述</h3><p>hash table可提供对任何有名项( named item)的存取操作和删除操作。由于操作对象是有名项，所以 hash table也可被视为一种字典结构( dictionary)这种结构的用意在于提供常数时间之基本操作，就像 stack或 queue那样。乍听之下这几乎是不可能的任务，因为约束制条件如此之少，而元素个数增加，搜寻操作必定耗费更多时间</p>
<p>通过hash function来进行key和index之间的转换。但是使用hash function会产生冲突的问题</p>
<p>解决冲突的方法主要有以下几种：</p>
<ol>
<li>线性探测法，产生冲突的时候向下一个地址进行存储</li>
<li>二次探测法，产生冲突的时候以H+1^2，H+2^2…的形式进行存储</li>
<li>开链法，在表格中维护一个list</li>
</ol>
<h3 id="hashtable-的buckets与nodes"><a href="#hashtable-的buckets与nodes" class="headerlink" title="hashtable 的buckets与nodes"></a>hashtable 的buckets与nodes</h3><p>下图是以开链法( separate chaining)完成 hash table的图形表述。为了解说 SGI STL源代码，我遵循SGI的命名，称 hash table表格内的元素为桶子( bucket)，此名称的大约意义是，表格内的每个单元，涵盖的不只是个节点(元素)，甚且可能是一“桶”节点</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15268653336402.jpg" alt=""></p>
<h2 id="hash-set"><a href="#hash-set" class="headerlink" title="hash_set"></a>hash_set</h2><p>STL set多半以RB-tree为底层机制。SGI则是在STL标准规格之外另又提供了一个所谓的hash_set，以 hash table为底层机制。由于hash_set所供应的操作接口hashtable都提供了，所以几乎所有的hash_set操作行为，都只是转调用hashtab1e的操作行为而已</p>
<p>运用set，为的是能够快速搜寻元素。这一点，不论其底层是RB-tree或是hash table，都可以达成任务。但是请注意，<strong>RB-tree有自动排序功能而 hashtable没有，反应出来的结果就是，set的元素有自动排序功能而hash_set没有</strong>。</p>
<h2 id="hash-map"><a href="#hash-map" class="headerlink" title="hash_map"></a>hash_map</h2><p>SGI在STL标准规格之外，另提供了一个所谓的 hash_map，以 hash table为底层机制。由于 hash_map所供应的操作接口， hash table都提供了，所以几乎所有的hash_map操作行为，都只是转调用 hashtable的操作行为而已。</p>
<p>运用map，为的是能够根据键值快速搜寻元素。这一点，不论其底层是RB-tree或是 hash table，都可以达成任务。但是请注意，RB-tree有自动排序功能而hashtable没有，反应出来的结果就是，<strong>map的元素有自动排序功能而hash_map没有</strong></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> STL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《UNIX网络编程卷1》笔记 简介部分]]></title>
      <url>/2018/05/15/%E3%80%8AUNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B71%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AE%80%E4%BB%8B%E9%83%A8%E5%88%86/</url>
      <content type="html"><![CDATA[<p>UNIX网络编程必读书籍——《UNIX网络编程卷1》  简介部分 笔记</p>
<a id="more"></a>
<h1 id="传输层：TCP、UDP和SCTP"><a href="#传输层：TCP、UDP和SCTP" class="headerlink" title="传输层：TCP、UDP和SCTP"></a>传输层：TCP、UDP和SCTP</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>UDP是一个<strong>简单的、不可靠的数据报协议</strong>,而TCP是一个<strong>复杂、可靠的字节流协议</strong>。SCTP与TCP类似之处在于它<strong>也是一个可靠的传输协议,但它还提供消息边界、传输级别多宿</strong>（multihoming)支持以及将头端阻塞( head-of-line blockin)减少到最小的一种方法。我们必须了解由这些传输层协议提供给应用进程的服务,这样才能弄清这些协议处理什么,应用进程中又需要处理什么。</p>
<h2 id="总图"><a href="#总图" class="headerlink" title="总图"></a>总图</h2><p>TCP/IP协议族除了TCP和IP这两个协议以外，还有许多其他的成员：</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15269068803801.jpg" alt=""></p>
<h2 id="用户数据报协议（UDP）"><a href="#用户数据报协议（UDP）" class="headerlink" title="用户数据报协议（UDP）"></a>用户数据报协议（UDP）</h2><p>应用进程往一个UDP套接字写入一个消息,该消息随后被封装( encapsulating)到一个UDP数据报,该UDP数据报进而又被封装到一个IP数据报,然后发送到目的地。UDP不保证UDP数据报会到达其最终目的地,不保证各个数据报的先后顺序跨网络后保持不变,也不保证每个数据报只到达一次</p>
<p>使用UDP进行网络编程所遇到的问题是它缺乏可靠性。如果一个数据报到达了其最终目的地,但是校验和检测发现有错误,或者该数据报在网络传输途中被丢弃了,它就无法被投递给UDP套接字,也不会被源端自动重传。</p>
<p>每个UDP数据报都有一个长度。如果一个数据报正确地到达其目的地,那么该数据报的长度将随数据一道传递给接收端应用进程。同时TCP是一个字节流(byte-stream)协议,没有任何记录边界,这一点不同于UDP</p>
<h2 id="传输控制协议（TCP）"><a href="#传输控制协议（TCP）" class="headerlink" title="传输控制协议（TCP）"></a>传输控制协议（TCP）</h2><p>首先，TCP客户先与某个给定服务器<strong>建立一个连接</strong>,再跨该连接与那个服务器交换数据,然后终止这个连接。</p>
<p>其次,TCP还提供了<strong>可靠性</strong>( reliability)。当TCP向另一端发送数据时,它要求对端返回个确认。如果没有收到确认,TCP就自动重传数据并等待更长时间。在数次重传失败后,TCP才放弃。TCP通过给其中每个字节关联一个序列号对所发送的数据进行排序，从而达到确认重传的目的。</p>
<p>再次,TCP提供<strong>流量控制</strong>( flow control)。TCP总是告知对端在任何时刻它一次能够从对端接收多少字节的数据,这称为通告窗口( advertised window)。在任何时刻,该窗口指出接收缓冲区中当前可用的空间量,从而确保发送端发送的数据不会使接收缓冲区溢出。该窗口时刻动态变化。</p>
<p>最后,TCP连接是全双工的( full-duplex)。这意味着在一个给定的连接上应用可以在任何时刻在进出两个方向上既发送数据又接收数据。因此,TCP必须为每个数据流方向跟踪诸如序列号和通告窗口大小等状态信息。当然UDP也是全双工的。</p>
<h2 id="流控制传输协议（SCTP）"><a href="#流控制传输协议（SCTP）" class="headerlink" title="流控制传输协议（SCTP）"></a>流控制传输协议（SCTP）</h2><p>SCTP提供的服务与UDP和TCP提供的类似。SCTP在客户和服务器之间提供关联( association),并像TCP那样给应用提供可靠性、排序、流量控制以及全双工的数据传送。SCTP中使用“关联”一词取代“连接”是为了避免这样的内涵:一个连接只涉及两个IP地址之间的通信。一个关联指代两个系统之间的一次通信,它可能因为SCTP支持多宿而涉及不止两个地址</p>
<p>与TCP不同的是,SCTP是面向消息的(message-oriented)。它提供各个记录的按序递送服务。与UDP一样,由发送端写入的每条记录的长度随数据一道传递给接收端应用SCTP能够在所连接的端点之间提供多个流,每个流各自可靠地按序递送消息。</p>
<h2 id="TCP连接的建立和终止"><a href="#TCP连接的建立和终止" class="headerlink" title="TCP连接的建立和终止"></a>TCP连接的建立和终止</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://data2.liuin.cn/2018-05-21-15269078619660.jpg" alt=""></p>
<h3 id="TCP选项"><a href="#TCP选项" class="headerlink" title="TCP选项"></a>TCP选项</h3><p>每一个SYN可以含有多个TCP选项，下面是一些常用的：</p>
<ul>
<li>MSS选项。发送SYN的TCP一端使用本选项通告对端它的最大分节大小( maximunsegment size)即MSS,也就是它在本连接的每个TCP分节中愿意接受的最大数据量。</li>
<li>窗口规模选项。TCP连接任何一端能够通告对端的最大窗口大小是65535,因为在TCP首部中相应的字段占16位。</li>
<li>时间戳选项。这个选项对于高速网络连接是必要的,它可以防止由失而复现的分组°可能造成的数据损坏。</li>
</ul>
<h3 id="TCP-连接终止"><a href="#TCP-连接终止" class="headerlink" title="TCP 连接终止"></a>TCP 连接终止</h3><p><img src="https://data2.liuin.cn/2018-05-21-15269079942940.jpg" alt=""></p>
<h3 id="TCP-状态转换图"><a href="#TCP-状态转换图" class="headerlink" title="TCP 状态转换图"></a>TCP 状态转换图</h3><p>TCP建立连接和连接终止的操作可以用状态转换图来进行表示，其中一共有11种状态</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15269080313206.jpg" alt=""></p>
<h3 id="观察分组"><a href="#观察分组" class="headerlink" title="观察分组"></a>观察分组</h3><p>下图展示了一个完整的TCP连接所发生的实际分组交换情况，包括建立连接、数据传送和连接终止3个阶段</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15269082100424.jpg" alt=""></p>
<h2 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h2><p>TIME WAIT状态有两个存在的理由:</p>
<ol>
<li>可靠地实现TCP全双工连接的终止，当最终的ACK丢失的时候，客户端必须重新发出这个ACK，在这之前客户端必须维护之前的状态，以允许重新发送那个ACK</li>
<li>允许老的重复分节在网络中消逝，防止影响后面的TCP连接</li>
</ol>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>任何时候,多个进程可能同时使用TCP、UDP和SCTP这3种传输层协议中的任何一种。这3种协议都使用16位整数的端口号(port number)来区分这些进程</p>
<p>当一个客户想要跟一个服务器联系时,它必须标识想要与之通信的这个服务器。TCP、UDP和SCTP定义了一组众所周知的端口(well- known port),用于标识众所周知的服务。</p>
<p>另一方面,客户通常使用短期存活的临时端口( ephemeral port)。这些端口号通常<strong>由传输层协议自动赋予客户</strong>。客户通常不关心其临时端口的具体值,而只需确信该端口在所在主机中是唯一的就行。传输协议的代码确保这种唯一性</p>
<p>端口号被划分成以下3段：</p>
<ol>
<li>众所周知的端口为0~1023。这些端口由IANA分配和控制。可能的话,相同端口号就分配给TCP、UDP和SCTP的同一给定服务。</li>
<li>已登记的端口( registered port)为1024~49151。这些端口不受IANA控制,不过由LANA登记并提供它们的使用情况清单,以方便整个群体。</li>
<li>49152~65535是动态的( dynamic)或私用的( private)端口。IANA不管这些端口。它们就是我们所称的临时端口。(49152这个魔数是65536的四分之三。）</li>
</ol>
<blockquote>
<p>套接字对</p>
</blockquote>
<p>一个TCP连接的套接字对( socket pair)是一个定义该连接的两个端点的四元组:本地P地址、本地TCP端口号、外地IP地址、外地TCP端口号。套接字对唯一标识一个网络上的每个TCP连接。</p>
<h2 id="TCP端口号与并发服务器"><a href="#TCP端口号与并发服务器" class="headerlink" title="TCP端口号与并发服务器"></a>TCP端口号与并发服务器</h2><p>并发服务器中主服务器循环通过派生一个子进程来处理每个新的连接</p>
<p>我们必须在服务器主机上区分监听套接字和已连接套接字( connected socket)。注意已连接套接字使用与监听套接字相同的本地端口(21)。</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15269091556898.jpg" alt=""></p>
<p>从上面我们可以看到：TCP无法仅仅通过查看目的端口号来分离外来的分节到不同的端点。它必须查看套接字对的所有4个元素才能确定由哪个端点接收某个到达的分节。</p>
<h2 id="缓冲区大小和限制"><a href="#缓冲区大小和限制" class="headerlink" title="缓冲区大小和限制"></a>缓冲区大小和限制</h2><h3 id="TCP输出"><a href="#TCP输出" class="headerlink" title="TCP输出"></a>TCP输出</h3><p>每一个TCP套接字有一个发送缓冲区,我们可以使用 SO_SNDBUF套接字选项来更改该缓冲区的大小。当某个应用进程调用 write时,内核从该应用进程的缓冲区中复制所有数据到所写套接字的发送缓冲区。如果该套接字的发送缓冲区容不下该应用进程的所有数据(或是应用进程的缓冲区大于套接字的发送缓冲区,或是套接字的发送缓冲区中已有其他数据),该应用进程将被投入睡眠。这里假设该套接字是阻塞的,它是通常的默认设置。内核将不从wite系统调用返回,<strong>直到应用进程缓冲区中的所有数据都复制到套接字发送缓冲区</strong>。因此,从写一个TCP套接字的 write调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区,<strong>并不表明对端的TCP或应用进程已接收到数据</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15269096002757.jpg" alt=""></p>
<h3 id="UDP输出"><a href="#UDP输出" class="headerlink" title="UDP输出"></a>UDP输出</h3><p>任何UDP套接字都有发送缓冲区大小(我们可以使用 SO SNDBUE套接字选项更改它,见75节),不过它仅仅是可写到该套接字的UDP数据报的大小上限。如果一个应用进程写一个大于套接字发送缓冲区大小的数据报,内核将返回该进程一个 EMSGSIZE错误。既然UDP是不可靠的,它不必保存应用进程数据的一个副本,因此无需一个真正的发送缓冲区。</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15269096922589.jpg" alt=""></p>
<h2 id="常见因特网应用的协议使用"><a href="#常见因特网应用的协议使用" class="headerlink" title="常见因特网应用的协议使用"></a>常见因特网应用的协议使用</h2><p><img src="https://data2.liuin.cn/2018-05-21-15269097511476.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[APUE 伪终端]]></title>
      <url>/2018/05/05/APUE-%E4%BC%AA%E7%BB%88%E7%AB%AF/</url>
      <content type="html"><![CDATA[<p>《UNIX环境高级编程》第19章 伪终端 笔记</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>伪终端这个术语是指,对于一个应用程序而言,它看上去像一个终端,但事实上它并不是个真正的终端。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255087230010.jpg" alt=""></p>
<p>图中的关键点是：</p>
<ol>
<li>通常,一个进程打开伪终端主设备,然后调用fork。子进程建立一个新的会话,打开一个相应的伪终端从设备,将其文件描述符复制到标准输入、标准输出和标准错误,然后调用exec。伪终端从设备成为子进程的控制终端。</li>
<li>对于伪终端从设备上的用户进程来说,其标准输入、标准输出和标准错误都是终端设备。通过这些描述符,用户进程能够处理所有终端I/O函数。但是因为仍终端从设备不是真正的终端设备,所以无意义的函数调用(例如,改变波特率、发送中断符、设置奇偶校验)将被忽略</li>
<li>任何写到伪终端主设备的都会作为从设备的输入,反之亦然。事实上,所有从设备端的输入都来自于伪终端主设备上的用户进程。这看起来就像一个双向管道,但是从设备上的中断行规程使我们拥有管道没有的处理奇谈问题的能力</li>
</ol>
<p>伪终端的某些经典用途：</p>
<blockquote>
<p>网络登录服务器</p>
</blockquote>
<p>伪终端可用于构造提供网络登录的服务器。典型的例子是 telnetd和rlogind服务器</p>
<p>在rlogind服务器和登录shell之间有两个exec调用,这是因为login程序通常是在两个exec之间检验用户是否合法</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255090645150.jpg" alt=""></p>
<blockquote>
<p>窗口系统终端模拟</p>
</blockquote>
<p>窗口系统通常提供一个终端模拟器,这样我们就能在熟悉的命令行环境中通过shell来运行程序。终端模拟器作为shell和窗口管理器之间的媒介。每个shell在自己的窗口中执行。</p>
<p>shell将自己的标准输入、标准输出、标准错误连接到PTY的从设备端。终端模拟器程序打开PTY的主设备。终端模拟器除了作为窗口子系统的接口,还要负责模拟一种特殊的终端,这意味着它需要根据它所模拟的设备类型来响应返回码。这些码列在 termcap和 terminfo数据库中。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255091975517.jpg" alt=""></p>
<blockquote>
<p>script 程序</p>
</blockquote>
<p>script(1)程序是随大多数UNIX系统提供的,它将终端会话期间的所有输入和输出信息复制到一个文件中。为完成此工作,该程序将自己置于终端和一个新调用的登录 shell之间。这里要特别指出, script程序通常是从登录shell启动的,该 shell还要等待 script程序的终止。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255092890944.jpg" alt=""></p>
<blockquote>
<p>expect 程序</p>
</blockquote>
<p>伪终端可以用来在非交互模式中驱动交互式程序的运行。许多硬连线程序需要一个终端才能行, passwd(1)命令就是一个例子,它要求用户在系统提示后输入口令</p>
<blockquote>
<p>运行协同进程</p>
</blockquote>
<p>如果协同进程是一个已经编译的程序而我们又没有源程序,则无法在源程序中加入ff1ush语句来解决这个问题。我们需要做的是将一个伪终端放到两个进程之间,诱使协同进程认为它是由终端驱动的,而非另一个进程</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255094556754.jpg" alt=""></p>
<blockquote>
<p>观看长时间运行程序的输出</p>
</blockquote>
<p>使用任何一个标准 shell,可以将一个需要长时间运行的程序放到后台运行。但是,如果将该程序的标准输出重定向到一个文件,并且它产生的输出又不多,那么我们就不能方便地监控程序的进展,因为标准I/O库将完全缓冲它的标准输出。</p>
<p>如果有源程序,则可以加入fflush调用强制标准I/O缓冲区在某些节点冲洗或者把缓冲模式改使用 setybuf的行缓冲。然而,如果没有源程序,可以在pty程序下运行该程序,让标准I/O库认为标准输出是终端。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255095797010.jpg" alt=""></p>
<h2 id="打开伪终端设备"><a href="#打开伪终端设备" class="headerlink" title="打开伪终端设备"></a>打开伪终端设备</h2><p>PTY表现得就像物理终端设备一样,因此应用程序就无须在意它们在使用的是何种设备。各种平台打开伪终端设备的方法有所不同。posix_openpt函数提供了一种可移植的方法来打开下一个可用<strong>伪终端主设备</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; #include &lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">posix_openpt</span><span class="params">(<span class="keyword">int</span> oﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: ﬁle descriptor of next available PTY master if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>在伪终端从设备可用之前,它的权限必须设置,以便应用程序可以访问它。 grantpt函数提供这样的功能:它把从设备节点的用户ID设置为调用者的实际用户ID,设置其组ID为一非指定值,通常是可以访问该终端设备的组。权限被设置为:对个体所有者是读写,对组所有者是写(0620)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">grantpt</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlockpt</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 on success, −1 on error</span></div></pre></td></tr></table></figure>
<p>unlockpt函数用于准予对伪终端从设备的访问,从而允许应用程序打开该设备。阻止其他进程打开从设备后,建立该设备的应用程序有机会在使用主、从设备之前正确地初始化这些设备</p>
<p>注意,在 grantpt和unlockpt这两个函数中,文件描述符参数是与伪终端主设备关联的文件描述符。</p>
<p>如果给定了伪终端主设备的文件描述符,那么可以用 ptsname函数找到伪终端从设备的路径名。这使应用程序可以独立于给定平台的某种特定约定而标识从设备。注意,该函数返回的名字可能存储在静态存储中,因此后续的调用可能会覆盖它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ptsname</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to name of PTY slave if OK, NULL on error</span></div></pre></td></tr></table></figure>
<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><p>伪终端还有其他特性：</p>
<ol>
<li>打包模式</li>
</ol>
<p>打包模式(packet mode)能够使PTY主设备了解到PTY从设备的状态变化</p>
<ol>
<li>远程模式</li>
</ol>
<p>PTY主设备可以用 TIOCREMOTE ioct1命令将PTY从设备设置成远程模式</p>
<ol>
<li>窗口大小变化</li>
</ol>
<p>PTY主设备上的进程可以用 TIOCSWINSZ ioct1命令来设置从设备的窗口大小。如果新的大小和当前的大小不同, SIGWINCH信号将被发送到PTY从设备的前台进程组。</p>
<ol>
<li>信号发生</li>
</ol>
<p>读、写PTY主设备的进程可以向PTY从设备的进程组发送信号</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[APUE 终端I/O]]></title>
      <url>/2018/05/05/APUE-%E7%BB%88%E7%AB%AFI-O/</url>
      <content type="html"><![CDATA[<p>《UNIX环境高级编程》第18章 终端I/O 笔记</p>
<a id="more"></a>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>终端I/O有两种不同的工作模式:</p>
<ol>
<li>规范模式输入处理。在这种模式中,对终端输入以行为单位进行处理。对于每个读请求终端驱动程序最多返回一行</li>
<li>非规范模式输入处理。输入字符不装配成行</li>
</ol>
<p>如果不做特殊处理,则默认模式是规范模式</p>
<p>可以认为终端设备是由通常位于内核中的终端驱动程序控制的。每个终端设备都有一个输入列和一个输出队列,如图所示：</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255055612367.jpg" alt=""></p>
<p>有以下几点说明：</p>
<ul>
<li>如果打开了回显功能,则在输入队列和输出队列之间有一个隐含的连接</li>
<li>输入队列的长度MAX_INPUT是有限值。当一个特定设备的输入队列已经填满时,系统的行为将依赖于实现。这种情况发生时大多数UNIX系统回显响铃字符。</li>
<li>图中没有显示另一个输入限制MAX_CANON。这个限制是一个规范输入行的最大字节数</li>
<li>虽然输出队列的长度通常也是有限的,但是程序并不能获得这个定义其长度的常量为当输出队列将要填满时,内核便直接使写进程休眠,直至写队列中有可用的空间。</li>
</ul>
<p>大多数UNIX系统在一个称为终端行规程(terminal linediscipline)的模块中进行全部的规范处理。可以将这个模块设想成一个盒子,<strong>位于内核通用读、写函数和实际设备驱动程序之间</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255057246778.jpg" alt=""></p>
<p>由于将规范处理分离为单独的模块,所有的终端驱动程序都能够一致地支持规范处理。</p>
<p>所有可以检测和更改的终端设备特性都包含在termios结构中。该结构定义在头文件<termios.h>中,本章使用这一头文件。</termios.h></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255057581968.jpg" alt=""></p>
<p>各个标志位的作用：</p>
<ul>
<li>输入标志通过终端设备驱动程序控制字符的输入(例如,剥除输入字节的第8位,允许输入奇偶校验)</li>
<li>输出标志则控制驱动程序输出(例如,执行输出处理、将换行符转换为CRLF)</li>
<li>控制标志影响RS232串行线(例如,忽略调制解调器的状态线、每个字符的一个或两个停止位)</li>
<li>本地标志影响驱动程序和用户之间的接口(例如,回显打开或关闭、可视地擦除字符、允许终端产生的信号以及对后台输出的作业控制停止信号</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-05-05-15255058794969.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255058823469.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255058855001.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255058879538.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255058906529.jpg" alt=""></p>
<p>与终端有关的各个函数之间的关系</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255059407734.jpg" alt=""></p>
<h2 id="特殊输入字符"><a href="#特殊输入字符" class="headerlink" title="特殊输入字符"></a>特殊输入字符</h2><p>POSIX.1定义了11个在输入时要特殊处理的字符。实现定义了另外一些特殊字符</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255061027706.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255061066356.jpg" alt=""></p>
<p>在POSIX的11个特殊字符中,其中有9个字符的值可以任意更改。不能更改的两个特殊字符是换行符和回车符(分别是\n和\r),也可能是STOP和START字符(依赖于实现)。为了更改,只需要修改termios结构中c_cc数组的相应项。该数组中的元素都用名字作为下标进行引用,每个名字都以字母V开头。</p>
<p>对各个字符的详细解释可见原书内容</p>
<h2 id="获得和设置终端属性"><a href="#获得和设置终端属性" class="headerlink" title="获得和设置终端属性"></a>获得和设置终端属性</h2><p>为了获得和设置 termios结构,可以调用 tcgetattr和 tcsetattr函数。这样就可以检测和修改各种终端选项标志和特殊字符,使终端按我们所希望的方式进行操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcgetattr</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">struct</span> termios *termptr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsetattr</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> opt, <span class="keyword">const</span> <span class="keyword">struct</span> termios *termptr)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>tcsetattr的参数opt使我们可以指定在什么时候新的终端属性才起作用。opt可以指定为下列常量中的一个:</p>
<ul>
<li>TCSANOW   更改立即发生。</li>
<li>TCSADRAIN 发送了所有输出后更改才发生。若更改输出参数则应使用此选项。</li>
<li>TCSAFLUSH 发送了所有输出后更改才发生。更进一步,在更改发生时未读的所有输入数据都被丢弃(冲洗)。</li>
</ul>
<h2 id="终端选项标志"><a href="#终端选项标志" class="headerlink" title="终端选项标志"></a>终端选项标志</h2><p>包含终端选项标志的所有的解释，具体可查看原书</p>
<h2 id="stty命令"><a href="#stty命令" class="headerlink" title="stty命令"></a>stty命令</h2><p>上节说明的所有选项都可以被检查和更改:在程序中用tcgetattr和tcsetattr函数进行检查和更改;在命令行(或shell脚本)中用stty(1)命令进行检查和更改。简单地说,stty(1)命令就是终端I/O所列的前6个函数的接口。</p>
<h2 id="波特率函数"><a href="#波特率函数" class="headerlink" title="波特率函数"></a>波特率函数</h2><p>术语波特率(baud rate)是一个历史沿用的术语,现在它指的是“位/秒”(bit per second)。虽然大多数终端设备对输入和输出使用同一波特率,但是只要硬件许可,可以将它们设置为两个不同值。</p>
<p>设置波特率函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">speed_t</span> cfgetispeed(<span class="keyword">const</span> <span class="keyword">struct</span> termios *termptr); </div><div class="line"><span class="keyword">speed_t</span> cfgetospeed(<span class="keyword">const</span> <span class="keyword">struct</span> termios *termptr); </div><div class="line"></div><div class="line"><span class="comment">// Both return: baud rate value </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cfsetispeed</span><span class="params">(<span class="keyword">struct</span> termios *termptr, <span class="keyword">speed_t</span> speed)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cfsetospeed</span><span class="params">(<span class="keyword">struct</span> termios *termptr, <span class="keyword">speed_t</span> speed)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="行控制函数"><a href="#行控制函数" class="headerlink" title="行控制函数"></a>行控制函数</h2><p>下列4个函数提供了终端设备的行控制能力：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcdrain</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcflow</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> action)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcflush</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> <span class="built_in">queue</span>)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsendbreak</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> duration)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All four return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>tcdrain函数等待所有输出都被传递。<br>tcflow函数用于对输入和输出流控制进行控制。<br>tcflush函数冲洗(抛弃)输入缓冲区(其中的数据是终端驱动程序已接收到,但用户程序尚未读取的)或输出缓冲区(其中的数据是用户程序已经写入,但尚未被传递的)。<br>tcsendbreak函数在一个指定的时间区间内发送连续的0值位流。</p>
<h2 id="终端标识"><a href="#终端标识" class="headerlink" title="终端标识"></a>终端标识</h2><p>历史上,在大多数UNIX系统版本中,控制终端的名字一直是/dev/tty。POSIX.1提供了个运行时函数,可用来确定控制终端的名字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctermid</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to name of controlling terminal on success, pointer to empty string on error</span></div></pre></td></tr></table></figure>
<p>另外还有两个UNIX系统比较感兴趣的函数: isatty和 ttyname。如果文件描述符引用个终端设备,则 isatty返回真。 ttyname返回的是在该文件描述符上打开的终端设备的路径名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">isatty</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 1 (true) if terminal device, 0 (false) otherwise</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ttyname</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to pathname of terminal, NULL on error</span></div></pre></td></tr></table></figure>
<h2 id="规范模式"><a href="#规范模式" class="headerlink" title="规范模式"></a>规范模式</h2><p>规范模式很简单:发一个读请求,<strong>当一行已经输入后,终端驱动程序即返回</strong>。以下几个条件造成读返回。</p>
<ol>
<li>所请求的字节数已读到时,读返回。无需读一个完整的行。如果读了部分行,那么也不会丢失任何信息,下一次读从前一次读的停止处开始。</li>
<li>当读到一个行定界符时,读返回。</li>
<li>如果捕捉到信号,并且该函数不再自动重启,则读也返回</li>
</ol>
<h2 id="非规范模式"><a href="#非规范模式" class="headerlink" title="非规范模式"></a>非规范模式</h2><p>可以通过关闭termios结构中c_lf1ag字段的ICANON标志来指定非规范模式。在非规范模式中,输入数据不装配成行,不处理下列特殊字符: ERASE、KILL、EOF、NLEOL、EOL2、CR、REPRINT、STATUS和 WERASE。</p>
<p>如前所述,规范模式很容易理解:系统每次至多返回一行。但在非规范模式下,系统如何知道在什么时候将数据返回给我们呢?如果它一次返回一个字节,那么系统开销就会过大。在启动读数据之前,往往不知道要读多少数据,所以系统不能总是一次返回多个字节解决方法是,当已读了指定量的数据后,或者已经超过了给定量的时间后,即通知系统返回。</p>
<p>这种技术使用了 termios结构中c_cc数组的两个变量:MIN和TIME。c_cc数组中的这两个元素的下标名为VMIN和VTIM。</p>
<p>MIN指定一个read返回前的最小字节数。TIME指定等待数据到达的分秒数(分秒为秒的1/10)。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255076147395.jpg" alt=""></p>
<h2 id="终端窗口大小"><a href="#终端窗口大小" class="headerlink" title="终端窗口大小"></a>终端窗口大小</h2><p>大多数UNⅨX系统都提供了一种跟踪当前终端窗口大小的方法,在窗口大小发生变化时,使内核通知前台进程组。内核为每个终端和伪终端都维护了一个wins1ze结构</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255076954042.jpg" alt=""></p>
<p>提供这种功能的目的是,当窗口大小发生变化时应用程序能够得到通知(如v1编辑器)。应用程序接收此信号后,可以获取窗口大小的新值,然后重绘屏幕。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[APUE 高级进程间通信]]></title>
      <url>/2018/05/05/APUE-%E9%AB%98%E7%BA%A7%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<p>《UNIX环境高级编程》第17章 高级进程间通信 笔记</p>
<a id="more"></a>
<h2 id="UNIX-域套接字"><a href="#UNIX-域套接字" class="headerlink" title="UNIX 域套接字"></a>UNIX 域套接字</h2><p>UNIX域套接字用于在同一台计算机上运行的进程之间的通信。虽然因特网域套接字可用于同一目的,但<strong>UNIX域套接字的效率更高</strong>。UNIX域套接字仅仅复制数据,它们并不执行协议处理,不需要添加或删除网络报头,无需计算校验和,不要产生顺序号,无需发送确认报文。</p>
<p>UNIX域套接字<strong>提供流和数据报两种接口</strong>。UNIX域数据报服务是可靠的,既不会丢失报文也不会传递出错。UNIX域套接字就像是套接字和管道的混合。</p>
<p>可以使用它们面向网络的域套接字接口或者使用socketpair函数来创建一对无命名的、相互连接的UNIX域套接字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> sockfd[<span class="number">2</span>])</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>虽然接口足够通用,允许socketpair用于其他域,但一般来说操作系统仅对UNIX域提供支持</p>
<p>对相互连接的UNIX域套接字可以起到<strong>全双工管道的作用</strong>:两端对读和写开放。我们将其称为fd管道( fd-pipe),以便与普通的半双工管道区分开来。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254872539788.jpg" alt=""></p>
<p>曾经提到XSI消息队列的使用存在一个问题,即不能将它们和po11或者se1ect起使用,这是因为它们不能关联到文件描述符。然而,套接字是和文件描述符相关联的,消息到达时,可以用套接字来通知。对每个消息队列使用一个线程。每个线程都会在mmsgrcv调用中阻塞。当消息到达时,线程会把它写入一个UNIX域套接字的一端。当poll指示套接字可以读取数据时,应用程序会使用这个套接字的另外一端来接收这个消息。</p>
<blockquote>
<p>命名UNIX域套接字</p>
</blockquote>
<p>虽然socketpair函数能创建一对相互连接的套接字,但是每一个套接字都没有名字。这意味着无关进程不能使用它们。恰如因特网域套接字一样,可以命名UNIX域套接字,并可将其用于告示服务。但是要注意,UNX域套接字使用的地址格式不同于因特网域套接字，套接字地址格式会随实现而变。</p>
<p>UNIX域套接字的地址由 sockaddr_un结构表示。在 Linux3.20和 Solaris10中, sockaddr_un结构在头文件<sys un.h="">中的定义</sys></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254875673064.jpg" alt=""></p>
<p>sockaddr_un结构的sun_path成员包含一个路径名。当我们将一个地址绑定到一个UNIX域套接字时,系统会用该路径名创建一个S_IFSOCK类型的文件该文件仅用于向客户进程告示套接字名字。该文件无法打开,也不能由应用程序用于通信。</p>
<p>如果我们试图绑定同一地址时,该文件已经存在,那么bind请求会失败。当关闭套接字时,并不自动删除该文件,所以必须确保在应用程序退出前,对该文件执行解除链接操作。</p>
<h2 id="唯一连接"><a href="#唯一连接" class="headerlink" title="唯一连接"></a>唯一连接</h2><p>服务器进程可以使用标准bind、listen和 accept函数,为客户进程安排一个唯一UNIX域连接。客户进程使用 connect与服务器进程联系。在服务器进程接受了connect请求后,在服务器进程和客户进程之间就存在了唯一连接。</p>
<p>下图展示了客户进程和服务器进程存在连接之前二者的情形。服务器端把它的套接字绑定到sockaddr_un的地址并监听新的连接请求。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254879207178.jpg" alt=""></p>
<p>现在，开发3个函数,使用这些函数可以在运行于同一台计算机上的两个无关进程之间创建唯一连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span> </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">serv_listen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </div><div class="line"><span class="comment">// Returns: ﬁle descriptor to listen on if OK, negative value on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">serv_accept</span><span class="params">(<span class="keyword">int</span> listenfd, <span class="keyword">uid_t</span> *uidptr)</span></span>; </div><div class="line"><span class="comment">// Returns: new ﬁle descriptor if OK, negative value on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cli_conn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </div><div class="line"><span class="comment">// Returns: ﬁle descriptor if OK, negative value on error</span></div></pre></td></tr></table></figure>
<p>服务器进程可以调用serv_listen函数声明它要在一个众所周知的名字(文件系统中的某个路径名)上监听客户进程的连接请求。当客户进程想要连接至服务器进程时,它们将使用该名字。serv_listen函数的返回值是用于接收客户进程连接请求的服务器UNIX域套接字</p>
<p>服务器进程可以使用serv_accept函数等待客户进程连接请求的到达。当个请求到达时,系统自动创建一个新的UNIX域套接字,并将它与客户端套接字连接,最后将这个新套接字返回给服务器。此外,客户进程的有效用户ID存放在 uidptr指向的存储区中客户</p>
<p>进程调用cli_conn函数连接至服务器进程。客户进程指定的name参数必须与服务器进程调用serv_listen函数时所用的名字相同</p>
<p>这三个函数的具体实现可以查看书本</p>
<h2 id="传送文件描述符"><a href="#传送文件描述符" class="headerlink" title="传送文件描述符"></a>传送文件描述符</h2><p>在两个进程之间传送打开文件描述符的技术是非常有用的。因此可以对客户进程服务器进程应用进行不同的设计。它使一个进程(通常是服务器进程)能够处理打开一个文件所要做的一切操作(包括将网络名翻译为网络地址、拨号调制解调器、协商文件锁等)以及<strong>向调用进程送回个描述符</strong>,该描述符可被用于以后的所有I/O函数。涉及打开文件或设备的所有细节对客户进程而言都是透明的。</p>
<p>一般情况下，两个进程,它们打开了同一文件。虽然它们共享同一个v节点,但每个进程都有它自己的文件表项。当一个进程向另一个进程传送一个打开文件描述符时,我们想让发送进程和接收进程共享同文件表项。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254885933315.jpg" alt=""></p>
<p>在技术上,我们是<strong>将指向一个打开文件表项的指针从一个进程发送到另外一个进程</strong>。该指针被分配存放在接收进程的第一个可用描述符项中。(注意,不要造成错觉,以为发送进程和接收进程中的描述符编号是相同的,它们通常是不同的。)两个进程共享同一个打开文件表,这与foxk之后的父进程和子进程共享打开文件表的情况完全相同。</p>
<p>当发送进程将描述符传送给接收进程后,通常会关闭该描述符。发送进程关闭该描述符并不会真的关闭该文件或设备,其原因是该描述符仍被视为由接收进程打开(即使接收进程尚未接收到该描述符)</p>
<p>下面定义用以发送和接收文件描述符的3个函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include "apue.h" </div><div class="line"></div><div class="line">int send_fd(int fd, int fd_to_send); </div><div class="line">int send_err(int fd, int status, const char *errmsg); </div><div class="line">// Both return: 0 if OK, −1 on error </div><div class="line"></div><div class="line">int recv_fd(int fd, ssize_t (*userfunc)(int, const void *, size_t)); </div><div class="line">// Returns: ﬁle descriptor if OK, negative value on error</div></pre></td></tr></table></figure>
<p>具体的实现原书代码</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[APUE 网络IPC：套接字]]></title>
      <url>/2018/05/05/APUE-%E7%BD%91%E7%BB%9CIPC%EF%BC%9A%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
      <content type="html"><![CDATA[<p>《UNIX环境高级编程》第16章 网络IPC：套接字 笔记</p>
<a id="more"></a>
<h2 id="套接字描述"><a href="#套接字描述" class="headerlink" title="套接字描述"></a>套接字描述</h2><p>套接字是通信端点的抽象。正如使用文件描述符访问文件,应用程序用套接字描述符访问套接字。<strong>套接字描述符在UNIX系统中被当作是一种文件描述符</strong>。事实上,许多处理文件描述符的函数(如read和 write)可以用于处理套接字描述符。</p>
<p>为创建一个套接字,调用socket函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: ﬁle (socket) descriptor if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>参数 domain(域)确定通信的特性,包括地址格式</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254808968863.jpg" alt=""></p>
<p>参数type确定套接字的类型,进一步确定通信特征。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254809237060.jpg" alt=""></p>
<p>参数protocol通常是0,表示为给定的域和套接字类型选择默认协议。当对同一域和套接字类型支持多个协议时,可以使用 protocol选择一个特定协议</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254809947426.jpg" alt=""></p>
<p>对于数据报(SOCK_DGRAM)接口,两个对等进程之间通信时不需要逻辑连接。只需要向对等进程所使用的套接字送出一个报文。字节流(SOCK_STREAM)要求在交换数据之前,在本地套接字和通信的对等进程的套接字之间建立一个逻辑连接。</p>
<p>调用socket与调用open相类似。在两种情况下,均可获得用于I/O的文件描述符。当不再需要该文件描述符时,调用c1ose来关闭对文件或套接字的访问,并且释放该描述符以便重新使用虽然套接字描述符本质上是一个文件描述符,但不是所有参数为文件描述符的函数都可以接受套接字描述符。</p>
<h2 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h2><p>在学习用套接字做一些有意义的事情之前,需要知道如何标识一个目标通信进程。进程标识由两部分组成。一部分是<strong>计算机的网络地址</strong>,它可以帮助标识网络上我们想与之通信的计算机;另一部分是该<strong>计算机上用端口号</strong>表示的服务,它可以帮助标识特定的进程。</p>
<h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>字节序是一个处理器架构特性用于指示像整数这样的大数据类型内部的字节如何排序。</p>
<p>如果处理器架构支持大端(big-endian)字节序,那么<strong>最大字节地址出现在最低有效字节</strong>( Least Significant Byte,LSB)上，小端(little-endian)字节序则相反:<strong>最低有效字节包含最小字节地址</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254815015116.jpg" alt=""></p>
<p>网络协议指定了字节序,因此异构计算机系统能够交换协议信息而不会被字节序所混淆。TCPP协议栈使用大端字节序。应用程序交换格式化数据时,字节序问题就会出现</p>
<p>对于TCPP应用程序,有4个用来在处理器字节序和网络字节序之间实施转换的函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostint32);</div><div class="line"><span class="comment">// Returns: 32-bit integer in network byte order</span></div><div class="line"></div><div class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostint16);</div><div class="line"><span class="comment">// Returns: 16-bit integer in network byte order</span></div><div class="line"></div><div class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netint32);</div><div class="line"></div><div class="line"><span class="comment">// Returns: 32-bit integer in host byte order</span></div><div class="line"></div><div class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> netint16);</div><div class="line"></div><div class="line"><span class="comment">// Returns: 16-bit integer in host byte order</span></div></pre></td></tr></table></figure>
<p>h表示“主机”字节序,n表示“网络”字节序。1表示“长”(即4字节)整数,s表示“短”</p>
<h3 id="地址格式"><a href="#地址格式" class="headerlink" title="地址格式"></a>地址格式</h3><p>一个地址标识一个特定通信域的套接字端点,地址格式与这个特定的通信域相关。为使不同格式地址能够传入到套接字函数,地址会被<strong>强制转换</strong>成一个通用的地址结构sockaddr</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254817776056.jpg" alt=""></p>
<p>不同的系统实现可能会不一样</p>
<p>因特网地址定义在<netinet in.h="">头文件中。在IPv4因特网域(AF_INET)中,套接字地址用结构 sockaddr_in表示</netinet></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254818310427.jpg" alt=""></p>
<p>有时,需要打印出能被人理解而不是计算机所理解的地址格式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> addr, <span class="keyword">char</span> *<span class="keyword">restrict</span> str, <span class="keyword">socklen_t</span> size)</span></span>;</div><div class="line"><span class="comment">// Returns: pointer to address string on success, NULL on error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> str, <span class="keyword">void</span> *<span class="keyword">restrict</span> addr)</span></span>;</div><div class="line"><span class="comment">// Returns: 1 on success, 0 if the format is invalid, or −1 on error</span></div></pre></td></tr></table></figure>
<p>函数inet_ntop将网络字节序的二进制地址转换成文本字符串格式。inet_pton将文本字符串格式转换成网络字节序的二进制地址。</p>
<h3 id="将套接字和地址关联"><a href="#将套接字和地址关联" class="headerlink" title="将套接字和地址关联"></a>将套接字和地址关联</h3><p>将一个客户端的套接字关联上一个地址没有多少新意,可以让系统选一个默认的地址。然而,<strong>对于服务器,需要给一个接收客户端请求的服务器套接字关联上一个众所周知的地址</strong>。客户端应有一种方法来发现连接服务器所需要的地址,最简单的方法就是服务器保留一个地址并且注册在/etc/services或者某个名字服务中。</p>
<p>使用bind函数来关联地址和套接字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>对于使用的地址有以下一些限制:</p>
<ul>
<li>在进程正在运行的计算机上,指定的地址必须有效，不能指定一个其他机器的地址。</li>
<li>地址必须和创建套接字时的地址族所支持的格式相匹配。</li>
<li>地址中的端口号必须不小于1024,除非该进程具有相应的特权(即超级用户)</li>
<li>一般只能将一个套接字端点绑定到一个给定地址上,尽管有些协议允许多重绑定</li>
</ul>
<p>可以调用 getsockname函数来发现绑定到套接字上的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> alenp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>调用 getsockname之前,将 alenp设置为一个指向整数的指针,该整数指定缓冲区sockaddr的长度。返回时,该整数会被设置成返回地址的大小。如果地址和提供的缓冲区长</p>
<p>如果套接字已经和对等方连接,可以调用 getpeername函数来找到对方的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> alenp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>如果要处理一个面向连接的网络服务(SOCK_STREAM或SOCK_SEQPACKET),那么在开始交换数据以前,需要在请求服务的进程套接字(客户端)和提供服务的进程套接字(服务器)之间建立一个连接。使用connect函数来建立连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>在connect中指定的地址是我们想与之通信的服务器地址。如果 sockfd没有绑定到一个地址, connect会给调用者绑定一个默认地址。</p>
<p>服务器调用listen函数来宣告它愿意接受连接请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>一旦服务器调用了listen,所用的套接字就能接收连接请求。使用accept函数获得连接请求并建立连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> len)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: ﬁle (socket) descriptor if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>函数accept所返回的文件描述符是套接字描述符,该描述符连接到调用connect的客户端。这个新的套接字描述符和原始套接字(sockfd)具有相同的套接字类型和地址族。传给accept原始套接字没有关联到这个连接,而是继续保持可用状态并接收其他连接请求。</p>
<p>如果服务器调用accept,并且当前没有连接请求,服务器会阻塞直到一个请求到来。另外服务器可以使用poll或se1ect来等待一个请求的到来。在这种情况下,一个带有等待连接请求的套接字会以可读的方式出现</p>
<h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>既然一个套接字端点表示为一个文件描述符,那么只要建立连接,就可以使用read和 write来通过套接字通信。</p>
<p>尽管可以通过read和write交换数据,但这就是这两个函数所能做的一切。如果想指定选项,从多个客户端接收数据包,或者发送带外数据,就需要使用6个为数据传递而设计的套接字函数中的一个</p>
<p>3个函数用来发送数据,3个用于接收数据。首先,考查用于发送数据的函数。最简单的是send,它和 write很像,但是可以指定标志来改变处理传输数据的方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> send(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> ﬂags);</div><div class="line"></div><div class="line"><span class="comment">// Returns: number of bytes sent if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>前面3个参数和write参数一样，不同的是第4个参数flags：</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254833405785.jpg" alt=""></p>
<p>即使send成功返回,也并不表示连接的另一端的进程就一定接收了数据。我们所能保证的只是当send成功返回时,数据已经被无错误地发送到网络驱动程序上</p>
<p>函数 sendto和send很类似。区别在于sendto可以在无连接的套接字上指定一个目标地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> ﬂags, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *destaddr, <span class="keyword">socklen_t</span> destlen); </div><div class="line"></div><div class="line"><span class="comment">// Returns: number of bytes sent if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>对于面向连接的套接字,目标地址是被忽略的,因为连接中隐含了目标地址。对于无连接的套接字,除非先调用 connect设置了目标地址,否则不能使用send。 sendto提供了发送报文的另一种方式</p>
<p>通过套接字发送数据时,还有一个选择。可以调用带有msghdr结构的sendmsg来指定多重缓冲区传输数据,这和 writev函数很相似</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> sendmsg(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="keyword">int</span> ﬂags);</div><div class="line"></div><div class="line"><span class="comment">// Returns: number of bytes sent if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>与发送数据相对应的，接受数据也有三个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> recv(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> ﬂags);</div><div class="line"></div><div class="line"><span class="comment">// Returns: length of message in bytes, 0 if no messages are available and peer has done an orderly shutdown, or −1 on error</span></div></pre></td></tr></table></figure>
<p><img src="https://data2.liuin.cn/2018-05-05-15254835445782.jpg" alt=""></p>
<p>如果有兴趣定位发送者,可以使用 recvfrom来得到数据发送者的源地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> ﬂags, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> addrlen); </div><div class="line"></div><div class="line"><span class="comment">// Returns: length of message in bytes, 0 if no messages are available and peer has done an orderly shutdown, or −1 on error</span></div></pre></td></tr></table></figure>
<p>为了将接收到的数据送入多个缓冲区,类似于 readv,或者想接收辅助数据,可以使用 recvmso</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> recvmsg(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="keyword">int</span> ﬂags);</div><div class="line"></div><div class="line"><span class="comment">// Returns: length of message in bytes, 0 if no messages are available and peer has done an orderly shutdown, or −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h2><p>套接字机制提供了两个套接字选项接口来控制套接字行为。一个接口用来设置选项,另一个接口可以查询选项的状态。可以获取或设置以下3种选项</p>
<ol>
<li>通用选项,工作在所有套接字类型上</li>
<li>在套接字层次管理的选项,但是依赖于下层协议的支持</li>
<li>特定于某协议的选项,每个协议独有的</li>
</ol>
<p>可以使用 setsockopt函数来设置套接字选项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option, <span class="keyword">const</span> <span class="keyword">void</span> *val, <span class="keyword">socklen_t</span> len)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>参数 level标识了选项应用的协议。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254838324441.jpg" alt=""></p>
<p>参数val根据选项的不同指向一个数据结构或者一个整数。一些选项是on/off开关。如果整数非0,则启用选项。如果整数为0,则禁止选项。参数len指定了val指向的对象的大小</p>
<p>可以使用getsockopt来查看选项的当前值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option, <span class="keyword">void</span> *<span class="keyword">restrict</span> val, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> lenp)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="带外数据"><a href="#带外数据" class="headerlink" title="带外数据"></a>带外数据</h2><p>带外数据( out-of-band data)是一些通信协议所支持的可选功能,与普通数据相比,它允许更高优先级的数据传输。带外数据先行传输,即使传输队列已经有数据。TCP支持带外数据,但是UDP不支持。套接字接口对带外数据的支持很大程度上受TCP带外数据具体实现的影响。TCP将带外数据称为紧急数据( urgent data)。</p>
<p>TCP仅支持一个字节的紧急数据,但是允许紧急数据在普通数据传递机制数据流之外传输。</p>
<h2 id="非阻塞和异步I-O"><a href="#非阻塞和异步I-O" class="headerlink" title="非阻塞和异步I/O"></a>非阻塞和异步I/O</h2><p>在基于套接字的异步LO中,当从套接字中读取数据时,或者当套接字写队列中空间变得可用时,可以安排要发送的信号 SIGIO。</p>
<p>启用异步IO是一个两步骤的过程</p>
<ol>
<li>建立套接字所有权,这样信号可以被传递到合适的进程</li>
<li>通知套接字当IO操作不会阻塞时发信号</li>
</ol>
<p>可以使用3种方式来完成第一个步骤</p>
<ul>
<li>在fcnt1中使用 F_SETOWN命令</li>
<li>在ioct1中使用 FIOSETOWN命令</li>
<li>在ioctl中使用 SIOCSPGRP命令</li>
</ul>
<p>要完成第二个步骤,有两个选择</p>
<ul>
<li>在fcnt1中使用F_SETFL命令并且启用文件标志O_ASYNO</li>
<li>在ioctl中使用FI命令</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[APUE 进程间通信]]></title>
      <url>/2018/05/04/APUE-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<p>《UNIX环境高级编程》第15章 进程间通信 笔记</p>
<a id="more"></a>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道是UNX系统IPC的最古老形式,所有UNX系统都提供此种通信机制。</p>
<p>管道有以下两种局限性：</p>
<ol>
<li>历史上,它们是半双工的(即数据只能在一个方向上流动)。现在,某些系统提供全双工管道,但是为了最佳的可移植性,我们决不应预先假定系统支持全双工管道</li>
<li>管道只能在具有公共祖先的两个进程之间使用。通常,一个管道由一个进程创建,在进程调用fork之后,这个管道就能在父进程和子进程之间使用了。</li>
</ol>
<p>每当在管道中键入一个命令序列,让shell执行时,shell都会为每一条命令单独创建一个进程,然后用管道将前一条命令进程的标准输出与后一条命令的标准输入相连接。</p>
<p>管道是通过调用pipe函数创建的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</div><div class="line"></div><div class="line">Returns: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</div></pre></td></tr></table></figure>
<p>经由参数fd返回两个文件描述符:fd[0]为读而打开,fd[1]为写而打开。fd[1]的输出是fd[0]的输入。</p>
<p>单个进程中的管道几乎没有任何用处。通常,进程会先调用pipe,接着调用fork,从而创建从父进程到子进程的IPC通道,反之亦然</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254214499352.jpg" alt=""></p>
<p>对于一个从子进程到父进程的管道,父进程关闭fd[1],子进程关闭fd[0]当管道的一端被关闭后,下列两条规则起作用。<br>(1)当读(read)一个写端已被关闭的管道时,在所有数据都被读取后,read返回0,表示文件结束。(从技术上来讲,如果管道的写端还有进程,就不会产生文件的结束。可以复制一个管道的描述符,使得有多个进程对它具有写打开文件描述符。但是,通常一个管道只有一个读进程和一个写进程。）<br>(2)如果写(write)一个读端已被关闭的管道,则产生信号 SIGPIPE。如果忽略该信号或者捕捉该信号并从其处理程序返回,则 write返回-1, errno设置为 EPIPE。</p>
<h2 id="函数popen和pclose"><a href="#函数popen和pclose" class="headerlink" title="函数popen和pclose"></a>函数popen和pclose</h2><p>常见的操作是创建一个连接到另一个进程的管道,然后读其输出或向其输入端发送数据,为此,标准I/O库提供了两个函数 popen和 pclose。这两个函数实现的操作是:创建一个管道,fork一个子进程,关闭未使用的管道端,执行一个shell运行命令,然后等待命令终止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">`<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function">FILE *<span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</div><div class="line"><span class="comment">// Returns: ﬁle pointer if OK, NULL on error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *fp)</span></span>; </div><div class="line"><span class="comment">// Returns: termination status of cmdstring, or −1 on error</span></div></pre></td></tr></table></figure>
<p>函数 popen先执行fork,然后调用exec执行cstring,并且返回一个标准I/O文件指针。如果type是”r”,则文件指针连接到cstring的标准输出。如果type是”w”,则文件指针连接到 cmdstring的标准输入，表示写FILE中的东西</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254216672075.jpg" alt=""></p>
<p>可以将最后一个参数的使用方法和fopen类比，如果type是”r”,则返回的文件指针是可读的,如果type是”w”,则是可写的</p>
<h2 id="协同进程"><a href="#协同进程" class="headerlink" title="协同进程"></a>协同进程</h2><p>UNIX系统过滤程序从标准输入读取数据,向标准输出写数据。几个过滤程序通常在shell管道中线性连接。当一个过滤程序既产生某个过滤程序的输入,又读取该过滤程序的输出时,它就变成了协同进程(coprocess)。</p>
<p>协同进程通常在shell的后台运行,其标准输入和标准输出通过管道连接到另一个程序。</p>
<p>popen只提供连接到另一个进程的标准输入或标准输出的一个单向管道,而协同进程则有连接到另一个进程的两个单向管道:一个接到其标准输入,另一个则来自其标准输出。</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254220325027.jpg" alt=""></p>
<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>FIFO有时被称为命名管道。未命名的管道只能在两个相关的进程之间使用,而且这两个相关的进程还要有一个共同的创建了它们的祖先进程。但是,通过FIFO,不相关的进程也能交换数据。</p>
<p>FIFO是一种文件类型。通过<code>stat</code>结构的<code>st_mode</code>成员的编码可以知道文件是否是FIFO类型。可以用S_ ISFTEO宏对此进行测试。</p>
<p><strong>创建FIFO类似于创建文件</strong>。确实,FIFO的路径名存在于文件系统中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>当我们用 mkfifo或者 mkfifoat创建FIFO时,要用open来打开它。设置非阻塞以及对错误的处理和普通文件的处理是一样的。</p>
<p>类似于管道,若 write一个尚无进程为读而打开的FIFO,则产生信号SIGPIPE。若某个FIFO的最后一个写进程关闭了该FIFO,则将为该FIFO的读进程产生一个文件结束标志。</p>
<p>FIFO有以下两种用途</p>
<ul>
<li>shell命令使用FIFO将数据从一条管道传送到另一条时,无需创建中间临时文件</li>
<li>客户进程服务器进程应用程序中,FIFO用作汇聚点,在客户进程和服务器进程二者之间传递数据</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-05-04-15254224287657.jpg" alt=""></p>
<h2 id="XSI-IPC"><a href="#XSI-IPC" class="headerlink" title="XSI IPC"></a>XSI IPC</h2><p>有3种称作XSI IPC的IPC:消息队列、信号量以及共享存储器。它们之间有很多相似之处</p>
<h3 id="标识符与键"><a href="#标识符与键" class="headerlink" title="标识符与键"></a>标识符与键</h3><p>每个内核中的IPC结构(消息队列、信号量或共享存储段)都用一个非负整数的标识符(identifier)加以引用。</p>
<p>标识符是IPC对象的内部名。为使多个合作进程能够在同一IPC对象上汇聚,需要提供一个外部命名方案。为此,每个IPC对象都与一个键(key)相关联,将这个键作为该对象的外部名。键的数据结构是<code>key_t</code></p>
<p>有多种方法使客户进程和服务器进程在同一IPC结构上汇聚：</p>
<ol>
<li>服务器进程可以指定键IPC_PRIVATE创建一个新IPC结构,将返回的标识符存放在某处(如一个文件)以便客户进程取用。</li>
<li>可以在一个公用头文件中定义一个客户进程和服务器进程都认可的键。</li>
<li>客户进程和服务器进程认同一个路径名和项目ID，接着调用函数ftok将这两个值变成一个键</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">key_t</span> ftok(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> id);</div><div class="line"></div><div class="line"><span class="comment">// Returns: key if OK, (key_t)−1 on error</span></div></pre></td></tr></table></figure>
<p>ftok创建的键通常是用下列方式构成的:按给定的路径名取得其stat结构中的部分 st_dev和 st_ino字段,然后再将它们与项目ID组合起来。如果两个路径名引用的是两个不同的文件,那么ftok通常会为这两个路径名返回不同的键。但是,因为i节点编号和键通常都存放在长整型中,所以创建键时可能会丢失信息。这意味着,对于不同文件的两个路径名,如果使用同一项目ID,那么可能产生相同的键。</p>
<p>3个get函数( msgget、 semget和 shmget)都有两个类似的参数:一个key和一个整型flag。在创建新的IPC结构(通常由服务器进程创建)时,如果key是 IPC_PRIVATE或者和当前某种类型的IPC结构无关,则需要指明fag的 IPC_CREAT标志位。为了引用一个现有队列(通常由客户进程创建),key必须等于队列创建时指明的key的值,并且 IPC_CREAT必须不被指明。</p>
<p>注意,决不能指定 IPC_PRIVATE作为键来引用一个现有队列,因为这个特殊的键值总是用于创建一个新队列。为了引用一个用 IPC_PRIVATE键创建的现有队列,一定要知道这个相关的标识符,然后在其他IPC调用中(如 msgsnd、 nserc)使用该标识符,这样可以绕过get函数</p>
<p>如果希望创建一个新的IPC结构,而且要确保没有引用具有同一标识符的一个现有IPC结构,那么必须在flag中同时指定 IPC_CREAT和IPC_EXCL位。这样做了以后,如果IPC结构已经存在就会造成出错,返回 EEXIST(这与指定了O_CREAT和O_EXCL标志的open相类似)</p>
<h3 id="权限结构"><a href="#权限结构" class="headerlink" title="权限结构"></a>权限结构</h3><p>XSI IPC为每一个IPC结构关联了一个ipc_perm结构。该结构规定了权限和所有者,它至少包括下列成员:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct ipc_perm &#123; </div><div class="line">    uid_t uid; /* owner’s effective user ID */ </div><div class="line">    gid_t gid; /* owner’s effective group ID */ </div><div class="line">    uid_t cuid; /* creator’s effective user ID */ </div><div class="line">    gid_t cgid; /* creator’s effective group ID */ </div><div class="line">    mode_t mode; /* access modes */ </div><div class="line">    .</div><div class="line">    .</div><div class="line">    .</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>每个实现会包括另外一些成员。在创建IPC结构时,对所有字段都赋初值。</p>
<p>mode字段的值如下图所示，<strong>对于任何IPC结构都不存在执行权限</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274218221632.jpg" alt=""></p>
<h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><p>XSI IPC的一个基本问题是:<strong>IPC结构是在系统范围内起作用的,没有引用计数</strong>。例如,如果进程创建了一个消息队列,并且在该队列中放入了几则消息,然后终止,那么该消息队列及其内容不会被删除。它们会一直留在系统中直至发生下列动作为止:由某个进程调用 msgrcv或msct1读消息或删除消息队列;或某个进程执行 ipcri(1)命令删除消息队列;或正在自举的系统删除消息队列。</p>
<p>将此与管道相比,当最后一个引用管道的进程终止时,管道就被完全地删除了。对于FIFO而言,在最后一个引用FIFO的进程终止时,虽然FIFO的名字仍保留在系统中,直至被显式地删除,但是留在FIFO中的数据已被删除了</p>
<p>XSI IPC的另一个问题是:这些IPC结构在文件系统中没有名字，为了支持这些IPC对象，系统增加了许多的系统调用</p>
<p>因为这些形式的IPC不使用文件描述符,所以<strong>不能对它们使用多路转接I/O函数</strong></p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是消息的链接表,<strong>存储在内核中</strong>,由消息队列标识符标识。</p>
<p><code>msgget</code>用于创建一个新队列或打开一个现有队列。<code>msgsnd</code>将新消息添加到队列尾端。每个消息包含一个正的长整型类型的字段、一个非负的长度以及实际数据字节数(对应于长度),所有这些都在将消息添加到队列时,传送给<code>msgsnd</code>。 <code>msgrcv</code>用于从队列中取消息。我们并不定要以先进先出次序取消息,也可以按消息的类型字段取消息。</p>
<p>每个队列有一个msqid_ds结构与其相关联</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254293881565.jpg" alt=""></p>
<p>创建一个队列或者打开一个现有队列函数<code>msgget</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: message queue ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>msgctl函数对队列执行多种操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf )</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>cmd参数指定对msqid队列要执行的命令：</p>
<ul>
<li>IPC_STAT  获取此队列的msqid_ds结构</li>
<li>IPC_SET  设置队列结构</li>
<li>IPC_RMID  从系统中删除该消息队列以及仍在该消息队列中的所有数据</li>
</ul>
<p>调用msgsnd将数据放到消息队列中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>消息类型结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> mymesg &#123; </div><div class="line">    <span class="keyword">long</span> mtype; <span class="comment">/* positive message type */</span> </div><div class="line">    <span class="keyword">char</span> mtext[<span class="number">512</span>]; <span class="comment">/* message data, of length nbytes */</span> </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>msgrcv从队列中取用消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> msgrcv(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes, <span class="keyword">long</span> type, <span class="keyword">int</span> ﬂag); </div><div class="line"></div><div class="line"><span class="comment">// Returns: size of data portion of message if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量与已经介绍过的IPC机构(管道、FIFO以及消息列队)不同。它是一个计数器,用于为多个进程提供对共享数据对象的访问</p>
<p>为了正确地实现信号量,信号量值的测试及减1操作应当是原子操作。为此,信号量通常是在内核中实现的</p>
<p>常用的信号量形式被称为二元信号量(binary semaphore)。它控制单个资源,其初始值为1。但是,一般而言,信号量的初值可以是任意一个正值,该值表明有多少个共享资源单位可供共享应用。</p>
<p>下面3个特性造成了XSI信号量比较复杂：</p>
<ol>
<li>信号量并非是单个非负值,而必需定义为含有一个或多个信号量值的集合。</li>
<li>信号量的创建(semget)是独立于它的初始化(sectl)的。这是一个致命的缺点,因为不能原子地创建一个信号量集合,并且对该集合中的各个信号量值赋初值。</li>
<li>即使没有进程正在使用各种形式的XSI IPO,它们仍然是存在的。有的程序在终止时并没有释放已经分配给它的信号量,所以我们不得不为这种程序担心。</li>
</ol>
<p>当我们想使用XSI信号量时,首先需要通过调用函数 semget来获得一个信号量ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: semaphore ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>semctl函数包含对信号量的各种操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ... <span class="comment">/* union semun arg */</span> )</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: (see following)</span></div></pre></td></tr></table></figure></p>
<p>函数semop自动执行信号集合上面的操作数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">struct</span> sembuf semoparray[], <span class="keyword">size_t</span> nops)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>参数 semoparray是一个指针,它指向一个由 sembuf结构表示的信号量操作数组:</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254305267397.jpg" alt=""></p>
<h2 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h2><p>共享存储允许两个或多个进程共享一个给定的存储区。因为数据不需要在客户进程和服务器进程之间复制,所以这是最快的一种IPC。使用共享存储时要掌握的唯一窍门是,在多个进程之间同步访问一个给定的存储区。若服务器进程正在将数据放入共享存储区,则在它做完这一操作之前,客户进程不应当去取这些数据。通常,信号量用于同步共享存储访问。下面可以看到共享内存为什么是最快的一种IPC方式：</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274224200311.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274224241716.jpg" alt=""></p>
<p>我们已经看到了共享存储的一种形式,就是在多个进程将同一个文件映射到它们的地址空间的时候。XSI共享存储和内存映射的文件的不同之处在于,前者没有相关的文件。XSI共享存储段是内存的匿名段</p>
<p>内核为每一个共享存储段维护一个结构，包含以下成员：</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254405323155.jpg" alt=""></p>
<p>使用函数shmgget获取一个共享存储标识符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: shared memory ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>函数shmctl对共享存储段执行多种操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf )</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>一旦创建了一个共享存储段,进程就可调用 shmat将其连接到它的地址空间中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to shared memory segment if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>共享存储段连接到调用进程的哪个地址上与addr参数以及flag中是否指定SHM_RND位有关</p>
<ul>
<li>如果addr为0,则此段连接到由内核选择的第一个可用地址上。这是推荐的使用方式。</li>
<li>如果add非0,并且没有指定 SHM_RND,则此段连接到addr所指定的地址上。</li>
<li>如果add非0,并且指定了 SHM_RND,则此段连接到(addr-( addr mod SHMLBA))所表示的地址上。 SHM_RND命令的意思是“取整”。 SHMLBA的意思是“低边界地址倍数”,它总是2的乘方。该算式是将地址向下取最近1个 SHMLBA的倍数。</li>
</ul>
<p>当对共享存储段的操作已经结束时,则调用 shmdt与该段分离。注意,这<strong>并不从系统中删除其标识符以及其相关的数据结构</strong>。该标识符仍然存在,直至某个进程(一般是服务器进程)带IPC_RMID命令的调用shmctl特地删除它为止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *addr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>回忆一下mmap函数,它可将一个文件的若干部分映射至进程地址空间。这在概念上类似于用 shmat XSI IPC函数连接一个共享存储段。两者之间的主要区别是,用mmap映射的存储段是与文件相关联的,而XSI共享存储段则并无这种关联。</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254410116645.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[APUE 高级I/O]]></title>
      <url>/2018/05/04/APUE-%E9%AB%98%E7%BA%A7I-O/</url>
      <content type="html"><![CDATA[<p>《UNIX环境高级编程》第14章 高级I/O 笔记</p>
<a id="more"></a>
<h2 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h2><p>将系统调用分成两类:“低速”系统调用和其他。低速系统调用是可能会<strong>使进程永远阻塞的一类系统调用</strong>,包括:</p>
<ul>
<li>如果某些文件类型(如读管道、终端设备和网络设备)的数据并不存在,读操作可能会使调用者永远阻塞;</li>
<li>如果数据不能被相同的文件类型立即接受(如管道中无空间、网络流控制),写操作可能会使调用者永远阻塞</li>
<li>在某种条件发生之前打开某些文件类型可能会发生阻塞(如要打开一个终端设备,需要先等待与之连接的调制解调器应答,又如若以只写模式打开FIFO,那么在没有其他进程已用读模式打开该FIFO时也要等待)</li>
<li>对已经加上强制性记录锁的文件进行读写</li>
<li>某些ioctl操作;</li>
<li>某些进程间通信函数</li>
</ul>
<p>虽然读写磁盘文件会暂时阻塞调用者,但并不能将与磁盘I/O有关的系统调用视为“低速”。</p>
<p>非阻塞IO使我们可以发出open、read和 write这样的IO操作,并使这些操作不会永远阻塞。如果这种操作不能完成,则调用立即出错返回,表示该操作如继续执行将阻塞。</p>
<p>对于一个给定的描述符,有两种为其指定非阻塞I/O的方法。</p>
<ol>
<li>如果调用open获得描述符,则可指定<code>O_NONBLOCK</code>标志</li>
<li>对于已经打开的一个描述符,则可调用<code>fcntl</code>,由该函数打开<code>O_NONBLOCK</code>文件状态标志</li>
</ol>
<h2 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h2><p>记录锁(record locking)的功能是：当第一个进程正在读或修改文件的某个部分时,使用记录锁可以阻止其他进程修改同一文件区。对于UNIX系统而言,“记录”这个词是一种误用,因为UNIX系统内核根本没有使用文件记录这种概念。一个更适合的术语可能是字节范围锁(byte-range locking),因为它锁定的只是文件中的一个区域(也可能是整个文件)</p>
<p>设置记录锁的方法是使用fcntl函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* struct flock *ﬂockptr */</span> )</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: depends on cmd if OK (see following), −1 on error</span></div></pre></td></tr></table></figure></p>
<p>对于记录锁,cmd是<code>F_GETLK</code>、<code>F_SELK</code>或<code>F_SETLKW</code>。第三个参数(我们将调用<code>flockptr</code>)是一个指向flock结构的指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct flock &#123; </div><div class="line">    short l_type; /* F_RDLCK, F_WRLCK, or F_UNLCK */ </div><div class="line">    short l_whence; /* SEEK_SET, SEEK_CUR, or SEEK_END */ </div><div class="line">    off_t l_start; /* offset in bytes, relative to l_whence */ </div><div class="line">    off_t l_len; /* length, in bytes; 0 means lock to EOF */ </div><div class="line">    pid_t l_pid; /* returned with F_GETLK */ </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>flock结构说明如下：</p>
<ul>
<li>所希望的锁类型:<code>F_RDLCK</code>(共享读锁)、<code>F_WRLCK</code>(独占性写锁)或<code>F_UNLCK</code>(解锁个区域)。</li>
<li>要加锁或解锁区域的起始字节偏移量(<code>l_start</code>和<code>l_whence</code>)。</li>
<li>区域的字节长度(1_1en)。</li>
<li>进程的ID(l_pid)持有的锁能阻塞当前进程(仅由F_GETLK返回)</li>
</ul>
<p>上面提到了两种类型的锁:共享读锁和独占性写锁。基本规则是:任意多个进程在一个给定的字节上可以有一把共享的读锁,但是在一个给定字节上只能有一个进程有把独占写锁。</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254024702844.jpg" alt=""></p>
<p>在设置或释放文件上的一把锁时,系统按要求组合或分裂相邻区。其中一个部分解锁的时候进程分裂，再次将这个区域加锁的时候进行合并。</p>
<blockquote>
<p>锁的隐含继承和释放</p>
</blockquote>
<p>关于记录锁的自动继承和释放有3条规则：</p>
<ol>
<li>锁与进程和文件两者相关联。这有两重含义:第一重很明显,当一个进程终止时,它所建立的锁全部释放;第二重则不太明显,无论一个描述符何时关闭,<strong>该进程通过这一描述符引用的文件上的任何一把锁都会释放</strong>(这些锁都是该进程设置的)。</li>
<li>由fork产生的子进程不继承父进程所设置的锁</li>
<li>在执行exec后,新程序可以继承原执行程序的锁。但是注意,如果对一个文件描述符设置了执行时关闭标志,那么当作为exec的一部分关闭该文件描述符时,将释放相应文件的所有锁。</li>
</ol>
<blockquote>
<p>FreeBSD实现</p>
</blockquote>
<p><img src="https://data2.liuin.cn/2018-05-04-15254027539830.jpg" alt=""></p>
<h2 id="I-O多路转接"><a href="#I-O多路转接" class="headerlink" title="I/O多路转接"></a>I/O多路转接</h2><p>有的时候我们需要从多个文件描述符读的时候，我们不能在任一个描述符上进行阻塞读(read),否则可能会因为被阻塞在一个描述符的读操作上而导致另一个描述符即使有数据也无法处理。</p>
<p>一种比较好的技术是使用I/O多路转接(I/O multiplexing)。为了使用这种技术,先构造一张我们感兴趣的描述符(通常都不止一个)的列表,然后调用一个函数,直到这些描述符中的一个已准备好进行I/O时,该函数才返回。</p>
<h3 id="函数select和pselect"><a href="#函数select和pselect" class="headerlink" title="函数select和pselect"></a>函数select和pselect</h3><p>在所有POSIX兼容的平台上, select函数使我们可以执行I/O多路转接。传给se1ect的参数告诉内核:</p>
<ul>
<li>我们所关心的描述符:</li>
<li>对于每个描述符我们所关心的条件(是否想从一个给定的描述符读,是否想写一个给定的描述符,是否关心一个给定描述符的异常条件)</li>
<li>愿意等待多长时间(可以永远等待、等待一个固定的时间或者根本不等待)</li>
<li>从se1ect返回时,内核告诉我们已准备好的描述符的总数量</li>
<li>对于读、写或异常这3个条件中的每一个,哪些描述符已准备好</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *<span class="keyword">restrict</span> readfds, fd_set *<span class="keyword">restrict</span> writefds, fd_set *<span class="keyword">restrict</span> exceptfds, <span class="keyword">struct</span> timeval *<span class="keyword">restrict</span> tvptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, −1 on error</span></div></pre></td></tr></table></figure>
<p>中间3个参数 readfds、 writefds和exceptfds是指向描述符集的指针。这3个描述符集说明了我们关心的可读、可写或处于异常条件的描述符集合。每个描述符集存储在一个<code>fd_set</code>数据类型中。这个数据类型是由实现选择的,它可以为每一个可能的描述符保持一位。</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254037628736.jpg" alt=""></p>
<p>对于<code>fd_set</code>数据类型,唯一可以进行的处理是:分配一个这种类型的变量,将这种类型的一个变量值赋给同类型的另一个变量,或对这种类型的变量使用下列4个函数中的一个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</div><div class="line"><span class="comment">// Returns: nonzero if fd is in set, 0 otherwise</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;</div></pre></td></tr></table></figure>
<p>另外一个select函数的变体pselect：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *<span class="keyword">restrict</span> readfds, fd_set *<span class="keyword">restrict</span> writefds, fd_set *<span class="keyword">restrict</span> exceptfds, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> sigmask)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, −1 on error</span></div></pre></td></tr></table></figure>
<p>和select的不同点在于：</p>
<ul>
<li>超时使用的数据结构不一样，能够提供更加精准的超时时间</li>
<li>超时值被声明为const，保证了pselect不会改变这一个值</li>
<li>可使用可选信号屏蔽字</li>
</ul>
<h3 id="函数poll"><a href="#函数poll" class="headerlink" title="函数poll"></a>函数poll</h3><p>poll函数和select差不多，就是函数的接口不一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd fdarray[], <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, −1 on error</span></div></pre></td></tr></table></figure>
<p>与 select不同,pol1不是为每个条件(可读性、可写性和异常条件)构造一个描述符集,而是构造一个po11fd结构的数组,每个数组元素指定一个描述符编号以及我们对该描述符感兴趣的条件。</p>
<h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h2><p>在用异步I/O的时候,要通过选择来灵活处理多个并发操作,这会使应用程序的设计复杂化。更简单的做法可能是使用多线程,使用同步模型来编写程序,并让这些线程以异步的方式运行。</p>
<p>使用POSIX异步I/O接口，会带来这些麻烦：</p>
<ul>
<li>每个异步操作有3处可能产生错误的地方:一处在操作提交的部分,一处在操作本身的结果,还有一处在用于决定异步操作状态的函数中。</li>
<li>设计大量额外的设置和处理规则</li>
<li>从错误中恢复会比较困难</li>
</ul>
<h2 id="函数readv和writev"><a href="#函数readv和writev" class="headerlink" title="函数readv和writev"></a>函数readv和writev</h2><p>readv和 writev函数用于在一次函数调用中读、写多个非连续缓冲区。有时也将这两个函数称为散布读(scatter read)和聚集写(gather write)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> readv(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">struct</span> iovec *iov, <span class="keyword">int</span> iovcnt);</div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> writev(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">struct</span> iovec *iov, <span class="keyword">int</span> iovcnt);</div><div class="line"></div><div class="line"><span class="comment">// Both return: number of bytes read or written, −1 on error</span></div></pre></td></tr></table></figure>
<p>其中中间参数的数据结构iov如下：</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254044988663.jpg" alt=""></p>
<h2 id="函数readn和writen"><a href="#函数readn和writen" class="headerlink" title="函数readn和writen"></a>函数readn和writen</h2><p>管道、FIFO以及某些设备(特别是终端和网络)有下列两种性质</p>
<ol>
<li>一次read操作所返回的数据可能少于所要求的数据,即使还没达到文件尾端也可能是这样。这不是一个错误,应当继续读该设备。</li>
<li>一次 write操作的返回值也可能少于指定输出的字节数。</li>
</ol>
<p>下面两个函数 readn和 writen的功能分别是读、写指定的N字节数据,并处理返回值可能小于要求值的情况。这两个函数只是按需多次调用xead和 write直至读、写了N字节数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span> </span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); </div><div class="line"><span class="keyword">ssize_t</span> writen(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); </div><div class="line"></div><div class="line"><span class="comment">// Both return: number of bytes read or written, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="存储映射I-O"><a href="#存储映射I-O" class="headerlink" title="存储映射I/O"></a>存储映射I/O</h2><p>存储映射I/O(memory-mapped I/O)能<strong>将一个磁盘文件映射到存储空间中的一个缓冲区上</strong>。于是,当从缓冲区中取数据时,就相当于读文件中的相应字节。与此类似,将数据存入缓冲区时相应字节就自动写入文件。这样,就可以在不使用read和 write的情况下执行I/O。</p>
<p>为了使用这种功能,应首先告诉内核将一个给定的文件映射到一个存储区域中。这是由mmap函数实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> ﬂag, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> off )</span></span>; </div><div class="line"><span class="comment">// Returns: starting address of mapped region if OK, MAP_FAILED on error</span></div></pre></td></tr></table></figure>
<p>addr参数用于指定映射存储区的起始地址。通常将其设置为0,这表示由系统选择该映射区的起始地址。此函数的返回值是该映射区的起始地址。</p>
<p>fd参数是指定要被映射文件的描述符。在文件映射到地址空间之前,必须先打开该文件。len参数是映射的字节数,off是要映射字节在文件中的起始偏移量</p>
<p>prot参数指定了映射存储区的保护要求</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254123464536.jpg" alt=""></p>
<p>存储映射文件的基本情况</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254124013724.jpg" alt=""></p>
<p>flag参数可以使用的属性：</p>
<ul>
<li>MAP_FIXED  返回值必须等于addr。因为这不利于可移植性,所以不鼓励使用此标志。</li>
<li>MAP_SHARED  这一标志描述了本进程对映射区所进行的存储操作的配置。此标志指定存储操作修改映射文件,也就是,存储操作相当于对该文件的 write</li>
<li>MAP_PRIVATE  本标志说明,对映射区的存储操作导致创建该映射文件的一个私有副本</li>
</ul>
<p>off的值和addr的值(如果指定了 MAP_FIXED)通常被要求是系统虚拟存储页长度的倍数</p>
<p>与映射区相关的信号有 SIGSEGV和 SIGBUS:</p>
<ul>
<li>信号 SIGSEGV通常用于指示进程试图访问对它不可用的存储区。如果映射存储区被map指定成了只读的,那么进程试图将数据存入这个映射存储区的时候,也会产生此信号。</li>
<li>如果映射区的某个部分在访问时已不存在,则产生 SIGBUS信号。例如,假设用文件长度映射了一个文件,但在引用该映射区之前,另一个进程已将该文件截断。此时,如果进程试图访问对应于该文件已截去部分的映射区,将会接收到 SIGBUS信号</li>
</ul>
<p><strong>子进程能通过fork继承存储映射区</strong>(因为子进程复制父进程地址空间,而存储映射区是该地址空间的一个部分），新程序则不能通过exec继承存储映射区</p>
<p>调用mprotect可以更改一个现有映射的权限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>如果共享映射中的页已修改,那么可以调用 msync将该页冲洗到被映射的文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> ﬂags)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>如果映射是私有的,那么不修改被映射的文件。与其他存储映射函数一样,地址必须与页边界对齐。</p>
<p>当进程终止时,会自动解除存储映射区的映射,或者直接调用 munmap函数也可以解除映射区。关闭映射存储区时使用的文件描述符并不解除映射区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[APUE 守护进程]]></title>
      <url>/2018/05/04/APUE-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>《UNIX环境高级编程》第13章 守护进程 笔记</p>
<a id="more"></a>
<p>守护进程(daemon)是生存期长的一种进程。它们常常在系统引导装入时启动,仅在系统关闭时才终止。因为它们没有控制终端,所以说它们是在后台运行的。UNIX系统有很多守护进程,它们执行日常事务活动。</p>
<h2 id="守护进程的特征"><a href="#守护进程的特征" class="headerlink" title="守护进程的特征"></a>守护进程的特征</h2><p>系统进程依赖于操作系统实现。父进程ID为0的各进程通常是内核进程,它们作为系统引导装入过程的一部分而启动。(init是个例外,它是一个由内核在引导装入时启动的用户层次的命令。)内核进程是特殊的,通常存在于系统的整个生命期中。它们以超级用户特权运行,无控制终端,无命令行。</p>
<p>对于需要在进程上下文执行工作但却不被用户层进程上下文调用的每一个内核组件,通常有它自己的内核守护进程。例如,在Linux中</p>
<ul>
<li><code>kswapd</code>守护进程也称为内存换页守护进程。它支持虚拟内存子系统在经过一段时间后将脏页面慢慢地写回磁盘来回收这些页面</li>
<li><code>f1ush</code>守护进程在可用内存达到设置的最小阅值时将脏页面冲洗至磁盘。它也定期地将脏页面冲洗回磁盘来减少在系统出现故障时发生的数据丢失。多个冲洗守护进程可以同时存在,每个写回的设备都有一个冲洗守护进程。</li>
<li><code>sync_supers</code>守护进程定期将文件系统元数据冲洗至磁盘。</li>
<li><code>jbd</code>守护进程帮助实现了ext4文件系统中的日志功能。</li>
<li><code>cron</code>守护进程在定期安排的日期和时间执行命令。许多系统管理任务是通过<code>cron</code>每隔一段固定的时间就运行相关程序而得以实现的。</li>
<li><code>atd</code>守护进程与cron类似,它允许用户在指定的时间执行任务,但是每个任务它只执行一次,而非在定期安排的时间反复执行。</li>
<li><code>cupsa</code>守护进程是个打印假脱机进程,它处理对系统提出的各个打印请求。</li>
<li><code>sshd</code>守护进程提供了安全的远程登录和执行设施注意,大多数守护进程都以超级用户(root)特权运行。所有的守护进程都没有控制终端其终端名设置为问号。</li>
</ul>
<p>内核守护进程以无控制终端方式启动。用户层守护进程缺少控制终端可能是守护进程调用了 setid的结果。</p>
<h2 id="编程规则"><a href="#编程规则" class="headerlink" title="编程规则"></a>编程规则</h2><p>在编写守护进程程序时需遵循一些基本规则,以防止产生不必要的交互作用。下面先说明这些规则,</p>
<ol>
<li>首先要做的是调用<code>umask</code>将文件模式创建屏蔽字设置为一个已知值(通常是0)。由继承得来的文件模式创建屏蔽字可能会被设置为拒绝某些权限。如果守护进程要创建文件,那么它可能要设置特定的权限。</li>
<li>调用fork,然后使父进程exit。这样做实现了下面几点。第一,如果该守护进程是作为一条简单的shell命令启动的,那么父进程终止会让shell认为这条命令已经执行完毕。第二,虽然子进程继承了父进程的进程组ID,但获得了一个新的进程ID,这就保证了子进程不是一个进程组的组长进程。这是下面将要进行的setid调用的先决条件。</li>
<li>调用setid创建一个新会话，执行3步：成为新会话的首进程、成为新进程组的组长进程、没有控制终端</li>
<li>将当前工作目录更改为根目录</li>
<li>关闭不再需要的文件描述符</li>
<li>某些守护进程打开<code>/dev/null</code>使其具有文件描述符0、1和2,这样,任何一个试图读标准输入、写标准输出或标准错误的库例程都不会产生任何效果。因为守护进程并不与终端设备相关联所以其输出无处显示,也无处从交互式用户那里接收输入。</li>
</ol>
<h2 id="出错记录"><a href="#出错记录" class="headerlink" title="出错记录"></a>出错记录</h2><p>守护进程存在的一个问题是如何处理出错消息。因为它本就不应该有控制终端,所以不能只是简单地写到标准错误上。我们不希望所有守护进程都写到控制台设备上,因为在很多工作站上控制台设备都运行着一个窗口系统。我们也不希望每个守护进程将它自己的出错消息写到一个单独的文件中。对任何一个系统管理人员而言,如果要关心哪一个守护进程写到哪一个记录文件中并定期地检查这些文件,那么一定会使他感到头痛。所以,需要有一个集中的守护进程出错记录设施。</p>
<p>BSD的<code>sys1og</code>设施得到了广泛的应用。大多数守护进程都使用这一设施</p>
<p>有下面3种产生日志消息的方法：</p>
<ol>
<li>内核例程可以调用log函数</li>
<li>大多数用户进程(守护进程)调用sys1og(3)函数来产生日志消息</li>
<li>无论一个用户进程是在此主机上,还是在通过TCP/IP网络连接到此主机的其他主机上,都可将日志消息发向UDP端口514。</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-05-04-15253968653919.jpg" alt=""></p>
<p>通常, syslogd守护进程读取所有3种格式的日志消息。此守护进程在启动时读一个配置文件,其文件名一般为<code>/etc/sys1og.conf</code>,该文件决定了不同种类的消息应送向何处。例如,紧急消息可发送至系统管理员(若已登录),并在控制台上打印,而警告消息则可记录到一个文件中。</p>
<p>该设施的接口是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">openlog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ident, <span class="keyword">int</span> option, <span class="keyword">int</span> facility)</span></span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">(<span class="keyword">void</span>)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setlogmask</span><span class="params">(<span class="keyword">int</span> maskpri)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: previous log priority mask value</span></div></pre></td></tr></table></figure></p>
<h2 id="单实例守护进程"><a href="#单实例守护进程" class="headerlink" title="单实例守护进程"></a>单实例守护进程</h2><p>为了正常运作,某些守护进程会实现为,在任一时刻只运行该守护进程的一个副本。例如,这种守护进程可能需要排它地访问一个设备。对cron守护进程而言,如果同时有多个实例运行,那么每个副本都可能试图开始某个预定的操作,于是造成该操作的重复执行,这很可能导致出错。</p>
<p>文件和记录锁机制为一种方法提供了基础,该方法保证一个守护进程只有一个副本在运行。</p>
<h2 id="守护进程的惯例"><a href="#守护进程的惯例" class="headerlink" title="守护进程的惯例"></a>守护进程的惯例</h2><p>在UNIX系统中,守护进程遵循下列通用惯例：</p>
<ol>
<li>若守护进程使用锁文件,那么该文件通常存储在<code>/var/run</code>目录中</li>
<li>若守护进程支持配置选项,那么配置文件通常存放在<code>/etc</code>目录中</li>
<li>守护进程可用命令行启动,但通常它们是由系统初始化脚本之一(<code>/etc/rc*</code>或<code>etc/init.d/*</code>)启动的。如果在守护进程终止时,应当自动地重新启动它,则我们可在<code>/etc/inittab</code>中为该守护进程包括 respawn记录项,这样,init就将重新启动该守护进程。</li>
<li>若一个守护进程有一个配置文件,那么当该守护进程启动时会读该文件,但在此之后般就不会再查看它。若某个管理员更改了配置文件,那么该守护进程可能需要被停止,然后再启动,以使配置文件的更改生效。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[APUE 线程控制]]></title>
      <url>/2018/05/02/APUE-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>《UNIX环境高级编程》第12章 线程控制 笔记</p>
<a id="more"></a>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>pthread接口允许我们通过设置每个对象关联的不同属性来细调线程和同步对象的行为。通常,管理这些属性的函数都遵循相同的模式</p>
<ul>
<li>每个对象与它自己类型的属性对象进行关联</li>
<li>有一个初始化函数,把属性设置为默认值。</li>
<li>还有一个销毁属性对象的函数。</li>
<li>每个属性都有一个从属性对象中获取属性值的函数</li>
<li>每一个属性都有一个设置属性值的函数</li>
</ul>
<p>可以使用<code>pthread_attr_t</code>结构修改线程默认属性,并把这些属性与创建的线程联系起来。可以使用 <code>pthread_attr_init</code>函数初始化<code>pthread_attr_t</code>结构。在调用<code>pthread_attr_init</code>以后, <code>pthread_attr_t</code>结构所包含的就是操作系统实现支持的所有线程属性的默认值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>POSIX.1定义的线程属性：</p>
<p><img src="https://data2.liuin.cn/2018-05-02-15252530369029.jpg" alt=""></p>
<blockquote>
<p>detachstate 属性</p>
</blockquote>
<p>如果在创建线程时就知道不需要了解线程的终止状态,就可以修改<code>pthread_attr_t</code>结构中的<code>detachstate</code>线程属性,让线程一开始就处于分离状态。可以使用 pthread_attr_setdetachstate函数把线程属性 detachstate设置成以下两个合法值之一: PTHREAD_CREATE_DETACHED,以分离状态启动线程:或者 PTHREAD_CREATE_JOINABLE,正常启动线程,应用程序可以获取线程的终止状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *detachstate)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> detachstate)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<blockquote>
<p>stackaddr 属性</p>
</blockquote>
<p>对线程栈属性进行管理的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstack</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">void</span> **<span class="keyword">restrict</span> stackaddr, <span class="keyword">size_t</span> *<span class="keyword">restrict</span> stacksize)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstack</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *stackaddr, <span class="keyword">size_t</span> stacksize)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>对于进程来说,虚地址空间的大小是固定的。因为进程中只有一个栈,所以它的大小通常不是问题。但对于线程来说,同样大小的虚地址空间必须被所有的线程栈共享。如果应用程序使用了许多线程,以致这些线程栈的累计大小超过了可用的虚地址空间,就需要减少默认的线程栈大小。</p>
<p>另一方面,如果线程调用的函数分配了大量的自动变量,或者调用的函数涉及许多很深的栈帧(stack frame),那么需要的栈大小可能要比默认的大。</p>
<p>如果线程栈的虚地址空间都用完了,那可以使用ma1loc或者mnap来为可替代的栈分配空间,并用<code>pthread _attr_setstack</code>函数来改变新建线程的栈位置。由 tackaddr参数指定的地址可以用作线程栈的内存范围中的<strong>最低可寻址地址</strong>,该地址与处理器结构相应的边界应对齐。当然,这要假设ma11oc和mmap所用的虚地址范围与线程栈当前使用的虚地址范围不同。</p>
<blockquote>
<p>stacksize 属性</p>
</blockquote>
<p>stackaddr线程属性被定义为栈的最低内存地址,但这并不一定是栈的开始位置。对于一个给定的处理器结构来说,如果栈是从高地址向低地址方向增长的,那么 stackaddi线程属性将是栈的结尾位置,而不是开始位置</p>
<p>管理线程属性<code>stacksize</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstacksize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">size_t</span> *<span class="keyword">restrict</span> stacksize)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstacksize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> stacksize)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>如果希望<strong>改变默认的栈大小,但又不想自己处理线程栈的分配问题</strong>,这时使用 <code>pthread_attr_setstacksize</code>函数就非常有用。</p>
<blockquote>
<p>guardsize 属性</p>
</blockquote>
<p>线程属性guardsize控制着线程栈末尾之后用以避免栈溢出的扩展内存的大小这个属性默认值是由具体实现来定义的,但常用值是系统页大小。可以把 guardsize线程属性设置为0,不允许属性的这种特征行为发生:在这种情况下,不会提供警戒缓冲区。同样,如果修改了线程属性stackadar,系统就认为我们将自己管理栈,进而使栈警戒缓冲区机制无效,这等同于把 guardsize线程属性设置为0。</p>
<p>管理线程属性<code>guardsize</code>属性的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getguardsize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">size_t</span> *<span class="keyword">restrict</span> guardsize)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setguardsize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> guardsize)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>如果 guardsize线程属性被修改了,操作系统可能会把它取为页大小的整数倍。如果线程的栈指针溢出到警戒区域,应用程序就可能通过信号接收到出错信息。</p>
<h2 id="同步属性"><a href="#同步属性" class="headerlink" title="同步属性"></a>同步属性</h2><h3 id="互斥量属性"><a href="#互斥量属性" class="headerlink" title="互斥量属性"></a>互斥量属性</h3><p>互斥量属性是用<code>pthread_mutexattr_t</code>结构表示的，其初始化和销毁函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>值得注意的3个属性是:进程共享属性、健壮属性以及类型属性</p>
<p>存在这样的机制:允许相互独立的多个进程把同一个内存数据块映射到它们各自独立的地址空间中。就像多个线程访问共享数据一样,多个进程访问共享数据通常也需要同步。如果进程共享互斥量属性设置为<code>PTHREAD_PROCESS_SHARED</code>,从多个进程彼此之间共享的内存数据块中分配的互斥量就可以用于这些进程的同步</p>
<p>获得和修改进程共享属性的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>进程共享互斥量属性设置为<code>PTHREAD_PROCESS_PRIVATE</code>时,允许pthread线程库提供更有效的互斥量实现,这在多线程应用程序中是默认的情况。在多个进程共享多个互斥量的情况下,pthread线程库可以限制开销较大的互斥量实现。</p>
<p>互斥量健壮属性与在多个进程间共享的互斥量有关。这意味着,当持有互斥量的进程终止时需要解决互斥量状态恢复的问题。这种情况发生时,互斥量处于锁定状态,恢复起来很困难。</p>
<p>获取和设置互斥量健壮属性的函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getrobust</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> robust)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setrobust</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> robust)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure></p>
<h3 id="读写锁属性"><a href="#读写锁属性" class="headerlink" title="读写锁属性"></a>读写锁属性</h3><p>读写锁和互斥量类似，都有属性，用数据结构<code>pthread_rwlockattr_t</code>表示，初始化和反初始化函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_init</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_destroy</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>读写锁支持的唯一属性是进程共享属性。它与互斥量的进程共享属性是相同的。有一对函数用于读取和设置读写锁的进程共享属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_setpshared</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="条件变量属性"><a href="#条件变量属性" class="headerlink" title="条件变量属性"></a>条件变量属性</h3><p>目前定义了条件变量的两个属性:<strong>进程共享属性和时钟属性</strong>，用数据结构<code>pthread_condattr_t</code>表示，初始化和反初始化函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_init</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_destroy</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>获取和设置进程共享属性的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_setpshared</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>时钟属性控制计算<code>pthread_cond_timedwait</code>函数的超时参数(sp)时采用的是哪个时钟，相关函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_getclock</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">clockid_t</span> *<span class="keyword">restrict</span> clock_id)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_setclock</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr, <span class="keyword">clockid_t</span> clock_id)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="屏障属性"><a href="#屏障属性" class="headerlink" title="屏障属性"></a>屏障属性</h3><p>初始化和反初始化函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_init</span><span class="params">(<span class="keyword">pthread_barrierattr_t</span> *attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_destroy</span><span class="params">(<span class="keyword">pthread_barrierattr_t</span> *attr)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>目前定义的屏障属性只有进程共享属性,它控制着屏障是可以被多进程的线程使用,还是只能被初始化屏障的进程内的多线程使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_barrierattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_setpshared</span><span class="params">(<span class="keyword">pthread_barrierattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h2 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h2><p>多个控制线程在相同的时间有可能调用相同的函数。如果一个函数在相同的时间点可以被多个线程安全地调用,就称该函数是线程安全的。</p>
<p>如果一个函数对多个线程来说是可重入的,就说这个函数就是线程安全的。但这并不能说明对信号处理程序来说该函数也是可重入的。如果函数对异步信号处理程序的重入是安全的,那么就可以说函数是异步信号安全的。</p>
<h2 id="线程特定数据"><a href="#线程特定数据" class="headerlink" title="线程特定数据"></a>线程特定数据</h2><p>线程特定数据( thread-specific data),也称为<strong>线程私有数据</strong>( thread-private data.),是存储和查询某个特定线程相关数据的一种机制。我们把这种数据称为线程特定数据或线程私有数据的原因是,我们希望每个线程可以访问它自己单独的数据副本,而不需要担心与其他线程的同步访问问题</p>
<p>设置线程私有数据的原因：</p>
<ol>
<li>有时候需要维护基于每线程(per-thread)的数据，即使线程ID确实是小而连续的整数,我们可能还希望有一些额外的保护,防止某个线程的数据与其他线程的数据相混淆。</li>
<li>它提供了让基于进程的接口适应多线程环境的机制。一个很明显的例子就是errno，以前的接口(线程出现以前)把errno定义为进程上下文中全局可访问的整数。系统调用和库例程在调用或执行失败时设置把它作为操作失败时的附属结果。为了让线程也能够使用那些原本基于进程的系统调用和库例程, errno被重新定义为线程私有数据。这样,一个线程做了重置 errno的操作也不会影响进程中其他线程的 errno值。</li>
</ol>
<p>我们知道一个进程中的所有线程都可以访问这个进程的整个地址空间。除了使用寄存器以外,一个线程没有办法阻止另一个线程访问它的数据。线程特定数据也不例外。虽然底层的实现部分并不能阻止这种访问能力,但管理线程特定数据的函数可以提高线程间的数据独立性,使得线程不太容易访问到其他线程的线程特定数据</p>
<p>在分配线程特定数据之前,需要创建与该数据关联的键。这个键将用于获取对线程特定数据的访问。使用 <code>pthread_key_create</code>创建一个键</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt; </div><div class="line"></div><div class="line">int pthread_key_create(pthread_key_t *keyp, void (*destructor)(void *)); </div><div class="line"></div><div class="line">// Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
<p>创建的键存储在keyp指向的内存单元中,这个键可以被进程中的所有线程使用,但<strong>每个线程把这个键与不同的线程特定数据地址进行关联</strong>。创建新键时,每个线程的数据地址设为空值。</p>
<p>除了创建键以外, pthread<em>key</em> create可以为该键关联一个可选择的析构函数。当这个线程退出时,如果数据地址已经被置为非空值,那么析构函数就会被调用,它唯一的参数就是该数据地址。如果传入的析构函数为空,就表明没有析构函数与这个键关联。</p>
<p>线程<strong>通常使用malloc为线程特定数据分配内存</strong>。析构函数通常释放已分配的内存。如果线程在没有释放内存之前就退出了,那么这块内存就会丢失,即线程所属进程就出现了内存泄漏。</p>
<p>线程退出时,线程特定数据的析构函数将按照操作系统实现中定义的顺序被调用。析构函数可能会调用另一个函数,该函数可能会创建新的线程特定数据,并且把这个数据与当前的键关联起来。当所有的析构函数都调用完成以后,系统会检查是否还有非空的线程特定数据值与键关联,如果有的话,再次调用析构函数。</p>
<p>对所有的线程,我们都可以通过调用<code>pthread_key_de1ete</code>来取消键与线程特定数据值之间的关联关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_delete</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>上述函数不会激活与键关联的析构函数</p>
<p>需要确保分配的键并不会由于在初始化阶段的竞争而发生变动。解决这种竞争的方法是使用<code>pthread_once</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line"></div><div class="line">pthread_once_t initﬂag = PTHREAD_ONCE_INIT;</div><div class="line"></div><div class="line">int pthread_once(pthread_once_t *initﬂag, void (*initfn)(void));</div><div class="line"></div><div class="line">// Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
<p>initflag必须是一个非本地变量(如全局变量或静态变量),而且必须初始化为<code>PTHREAD_ONCE_INIT</code>。如果每个线程都调用 pthread_once,系统就能保证初始化例程initfn只被调用一次,即系统首次调用 pthread_once时。</p>
<p>键一旦创建以后,就可以通过调用<code>pthread_setspecific</code>函数把键和线程特定数据关联起来。可以通过 <code>pthread_ getspecific</code>函数获得线程特定数据的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: thread-speciﬁc data value or NULL if no value has been associated with the key</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key, <span class="keyword">const</span> <span class="keyword">void</span> *value)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h2 id="取消选项"><a href="#取消选项" class="headerlink" title="取消选项"></a>取消选项</h2><p>有两个线程属性并没有包含在<code>pthread_attr_t</code>结构中,它们是可取消状态和可取消类型。这两个属性影响着线程在响应<code>pthread_cancel</code>函数调用时所呈现的行为</p>
<p>可取消状态属性可以是<code>PTHREAD_CANCEL_ENABLE</code>,也可以是<code>PTHREAD_CANCEL_DISABLE</code>，线程可以通过调用`pthread_setcancel_state修改它的可取消状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcancelstate</span><span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span> *oldstate)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p><code>pthread_setcancel_state</code>把当前的可取消状态设置为state,把原来的可取消状态存储在由oldstate指向的内存单元,<strong>这两步是一个原子操作</strong>。</p>
<p><code>pthread_cancel</code>调用并不等待线程终止。在默认情况下,线程在取消请求发出以后还是继续运行,直到线程到达某个取消点。取消点是线程检查它是否被取消的一个位置,如果取消了,则按照请求行事。</p>
<p>线程启动时默认的可取消状态是<code>PTHREAD_CANCEL_ENABLE</code>。当状态设为<code>PTHREAD_CANCEL_DISABLE</code>时,对<code>pthread_cancel</code>的调用并不会杀死线程。相反,取消请求对这个线程来说还处于挂起状态,当取消状态变为<code>PTHREAD_CANCEL_ENABLE</code>时,线程将在下一个取消点上对所有挂起的取消请求进行处理</p>
<p>可以调用<code>pthread_testcancel</code>函数在程序中添加自己的取消点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_testcancel</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>默认的取消类型也称为推迟取消。调用<code>pthread_cancel</code>以后,在线程到达取消点之前,并不会出现真正的取消。可以通过调用<code>pthread_setcanceltype</code>来修改取消类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> *oldtype)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>有两种取消类型：推迟取消和异步取消，异步取消与推迟取消不同,因为使用异步取消时,线程可以在任意时间撤消,不是非得遇到取消点才能被取消</p>
<h2 id="线程和信号"><a href="#线程和信号" class="headerlink" title="线程和信号"></a>线程和信号</h2><p>每个<strong>线程都有自己的信号屏蔽字,但是信号的处理是进程中所有线程共享的</strong>。这意味着单个线程可以阻止某些信号,但当某个线程修改了与某个给定信号相关的处理行为以后,所有的线程都必须共享这个处理行为的改变。这样,如果一个线程选择忽略某个给定信号,那么另一个线程就可以通过以下两种方式撤消上述线程的信号选择:恢复信号的默认处理行为,或者为信号设置个新的信号处理程序</p>
<p>进程使用<code>sigprocmask</code>函数来阻止信号发送。线程使用的函数是<code>pthread_sigmask</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_sigmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> oset)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>pthread_sigmask函数与sigprocmask函数基本相同,不过pthread_sigmask工作在线程中,而且失败时返回错误码,不再像sigprocmask中那样设置errno并返回-1。set参数包含线程用于修改信号屏蔽字的信号集。how参数可以取下列3个值之一: SIG_BLOCK,把信号集添加到线程信号屏蔽字中, SIG_SETMASK,用信号集替换线程的信号屏蔽字;SIG_UNBLOCK,从线程信号屏蔽字中移除信号集。如果oset参数不为空,线程之前的信号屏蔽字就存储在它指向的siget_t结构中。线程可以通过把set参数设置为NULL,并把oser参数设置为si gset_t结构的地址,来获取当前的信号屏蔽字。这种情况中的how参数会被忽略</p>
<p>线程可以通过调用sigwait等待一个或多个信号的出现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigwait</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">int</span> *<span class="keyword">restrict</span> signop)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>set参数指定了线程等待的信号集。返回时, signop指向的整数将包含发送信号的数量</p>
<p>为了避免错误行为发生,线程在调用sigwait之前,必须阻塞那些它正在等待的信号</p>
<p>sigwait函数会原子地取消信号集的阻塞状态,直到有新的信号被递送</p>
<p>要把信号发送给进程,可以调用ki11。要把信号发送给线程,可以调用 pthread_kill<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_kill</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">int</span> signo)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure></p>
<h2 id="线程和fork"><a href="#线程和fork" class="headerlink" title="线程和fork"></a>线程和fork</h2><p>当线程调用fork时，就为子进程创建整个进程地址空间的副本</p>
<p>子进程通过继承整个地址空间的副本,还从父进程那儿继承了每个互斥量、读写锁和条件变量的状态。如果父进程包含一个以上的线程,子进程在fork返回以后,如果紧接着不是马上调用exec的话,就需要清理锁状态</p>
<p>在子进程内部,只存在一个线程,它是由父进程中调用fork的线程的副本构成的。</p>
<p>在多线程的进程中,为了避免不一致状态的问题, POSIX.1声明,在fork返回和子进程调用其中一个exec函数之间,子进程只能调用异步信号安全的函数。这就限制了在调用exec之前子进程能做什么,但不涉及子进程中锁状态的问题。</p>
<p>要清除锁状态，可以通过调用pthread_atfork函数建立fork处理程序</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt; </div><div class="line"></div><div class="line">int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void)); </div><div class="line"></div><div class="line">// Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
<p>用pthread_atfork函数最多可以安装3个帮助清理锁的函数。 <code>prepare_fork</code>处理程序由父进程在fork创建子进程前调用。这个fork处理程序的任务是<strong>获取父进程定义的所有锁</strong>。 <code>parent_fork</code>处理程序是在fork创建子进程以后、返回之前在父进程上下文中调用的。这个fok处理程序的任务是对<code>prepare_fork</code>处理程序获取的所有锁进行解锁。<code>child_fork</code>处理程序在fork返回之前在子进程上下文中调用。与 <code>parent_fork</code>处理程序一样, <code>child_fork</code>处理程序也必须释放<code>prepare_fork</code>处理程序获取的所有锁</p>
<h2 id="线程和I-O"><a href="#线程和I-O" class="headerlink" title="线程和I/O"></a>线程和I/O</h2><p>在多线程环境下，使用的都是pread和pwrite函数，这些函数都是源自操作，使得多线程下所有线程可以共享相同的文件描述符。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[APUE 线程]]></title>
      <url>/2018/05/02/APUE-%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>《UNIX环境高级编程》第11章 线程 笔记</p>
<a id="more"></a>
<h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p>在程序设计时就可以把进程设计成在某一时刻能够做不止一件事,每个线程处理各自独立的任务。这种方法有很多好处。</p>
<ul>
<li>通过为每种事件类型分配单独的处理线程,可以简化处理异步事件的代码。每个线程在进行事件处理时可以采用同步编程模式,同步编程模式要比异步编程模式简单得多。</li>
<li>多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享，而多个线程自动地可以访问相同的存储地址空间和文件描述符</li>
<li>有些问题可以分解从而提高整个程序的吞吐量。在只有一个控制线程的情况下,一个单线程进程要完成多个任务,只需要把这些任务串行化。但有多个控制线程时,相互独立的任务的处理就可以交叉进行,此时只需要为每个任务分配一个单独的线程。</li>
<li>交互的程序同样可以通过使用多线程来改善响应时间,多线程可以把程序中处理用户输入输出的部分与其他部分分开。</li>
</ul>
<p>处理器的数量并不影响程序结构,所以不管处理器的个数多少,程序都可以通过使用线程得以简化。</p>
<p>每个线程都包含有表示执行环境所必需的信息,其中包括<strong>进程中标识线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、 errno变量以及线程私有数据</strong></p>
<p>一个进程的所有信息对该进程的所有线程都是共享的,包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符</p>
<h2 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h2><p>就像每个进程有一个进程ID一样,每个线程也有一个线程ID。进程ID在整个系统中是唯一的,但线程ID不同,线程ID只有在它所属的进程上下文中才有意义。</p>
<p>线程ID是用pthread_t数据类型来表示的,实现的时候可以用一个结构来代表pthread_t数据类型,所以可移植的操作系统实现不能把它作为整数处理。因此必须使用一个函数来对两个线程ID进行比较:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> tid1, <span class="keyword">pthread_t</span> tid2)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: nonzero if equal, 0 otherwise</span></div></pre></td></tr></table></figure>
<p>线程可以通过调用 pthread_self函数获得自身的线程ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: the thread ID of the calling thread</span></div></pre></td></tr></table></figure>
<p>当线程需要识别以线程ID作为标识的数据结构时, pthread_self函数可以与pthread_equal函数一起使用。例如,主线程可能把工作任务放在一个队列中,用线程ID来控制每个工作线程处理哪些作业。如图所示,主线程把新的作业放到一个工作队列中,由3个工作线程组成的线程池从队列中移出作业。主线程不允许每个线程任意处理从队列顶端取出的作业,而是由主线程控制作业的分配,主线程会在每个待处理作业的结构中放置处理该作业的线程ID,每个工作线程只能移出标有自己线程ID的作业。</p>
<p><img src="https://data2.liuin.cn/2018-05-25-15272376666056.jpg" alt=""></p>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>新增的线程可以通过调用 pthread_create函数创建。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt; </div><div class="line"></div><div class="line">int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(*start_rtn)(void *), void *restrict arg); </div><div class="line"></div><div class="line">// Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
<p>当pthread_create成功返回时,新创建线程的线程ID会被设置成<code>tidp</code>指向的内存单元，<code>attr</code>参数用于定制各种不同的线程属性。新创建的线程从<code>start_rtn</code>函数的地址开始运行,该函数只有一个无类型指针参数<code>arg</code>。如果需要向<code>start_run</code>函数传递的参数有一个以上,那么需要把这些参数放到一个结构中,然后把这个结构的地址作为<code>arg</code>参数传入</p>
<p>线程创建时并不能保证哪个线程会先运行:是新创建的线程,还是调用线程。新创建的线程可以访问进程的地址空间,并且继承调用线程的浮点环境和信号屏蔽字,但是该线程的挂起信号集会被清除。</p>
<p>注意, pthread函数在调用失败时通常会返回错误码,它们并不像其他的POSIX函数一样设置 errno。每个线程都提供 errno的副本,这只是为了与使用 errno的现有函数兼容。</p>
<p>在使用pthread_create函数的时候有一些问题是需要注意的：</p>
<ul>
<li>在创建多线程程序的时候，有的时候主线程需要休眠,如果主线程不休眠,它就可能会退出,这样新线程还没有机会运行,整个进程可能就已经终止了。这种行为特征依赖于操作系统中的线程实现和调度算法</li>
<li>第二个特别之处在于新线程是通过调用 pthread_se1f函数获取自己的线程ID的,而不是从共享内存中读出的,或者从线程的启动例程中以参数的形式接收到。我们知道pthread_create会通过第一个参数(tidp)返回新建线程的线程ID。但是新建的线程并不能安全地使用它,如果新线程在主线程调用pthread_create返回之前就运行了,那么新线程看到的是未经初始化的ntid的内容,这个内容并不是正确的线程</li>
</ul>
<h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>如果进程中的任意线程调用了exit、_Exit或者_exit,那么整个进程就会终止</p>
<p>单个线程可以通过3种方式退出,因此可以在不终止整个进程的情况下,停止它的控制流。</p>
<ol>
<li>线程可以简单地从启动例程中返回,返回值是线程的退出码。</li>
<li>线程可以被同一进程中的其他线程取消。</li>
<li>线程调用 pthread_ex1t</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *rval_ptr)</span></span>;</div></pre></td></tr></table></figure>
<p><code>rval_ptr</code>参数是一个无类型指针,与传给启动例程的单个参数类似。进程中的其他线程也可以通过调用 <code>pthread_join</code>函数访问到这个指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **rval_ptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>调用线程将一直阻塞,直到指定的线程调用<code>pthread_exit</code>，从启动例程中返回或者被取消。如果线程简单地从它的启动例程返回, <code>rval_ptr</code>就包含返回码。如果线程被取消,由<code>rval_pir</code>指定的内存单元就设置为<code>PTHREAD_CANCELED</code></p>
<p>可以通过调用<code>pthread_join</code>自动把线程置于分离状态(马上就会讨论到),这样资源就可以恢复。如果线程已经处于分离状态, <code>pthread_join</code>调用就会失败,返回<code>EINVAL</code>,尽管这种行为是与具体实现相关的。</p>
<p>如果对线程的返回值并不感兴趣,那么可以把 rval_ptr设置为NULL。在这种情况下,调用pthread_join函数可以等待指定的线程终止,但并不获取线程的终止状态。</p>
<p>pthread_create和 pthread_exit函数的无类型指针参数可以传递的值不止一个,这个指针可以传递包含复杂信息的结构的地址,但是注意,<strong>这个结构所使用的内存在调用者完成调用以后必须仍然是有效的</strong>。</p>
<p>为了解决这个问题,可以使用全局结构,或者用mal1oc函数分配结构</p>
<p>线程可以通过调用<code>pthread_cancel</code>函数来请求取消同一进程中的其他线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>在默认情况下, pthread_cancel函数会使得由tid标识的线程的行为表现为如同调用了参数为 PTHREAD_CANCELED的 pthread_exit函数,但是,线程可以选择忽略取消或者控制如何被取消。注意 pthread_cancel<strong>并不等待线程终止,它仅仅提出请求</strong></p>
<p>线程可以安排它退出时需要调用的函数,这与进程在退出时可以用<code>atexit</code>函数安排退出是类似的。这样的函数称为线程清理处理程序( thread cleanup handler)。一个线程可以建立多个清理处理程序。处理程序记录在栈中,也就是说,它们的<strong>执行顺序与它们注册时相反</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line"></div><div class="line">void pthread_cleanup_push(void (*rtn)(void *), void *arg);</div><div class="line"></div><div class="line">void pthread_cleanup_pop(int execute);</div></pre></td></tr></table></figure>
<p>需要注意的是：如果线程是通过从它的启动例程中返回而终止的话,它的清理处理程序就不会被调用。还要注意,清理处理程序是按照与它们安装时相反的顺序被调用的</p>
<p>进程原语和线程原语的比较：</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15273825684274.jpg" alt=""></p>
<blockquote>
<p>线程的分离和结合</p>
</blockquote>
<p>在任何一个时间点上，线程是可结合的（joinable），或者是分离的（detached）。一个可结合的线程能够被其他线程收回其资源和杀死；在被其他线程回收之前，它的存储器资源（如栈）是不释放的。相反，一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放</p>
<p>在默认情况下,线程的终止状态会保存直到对该线程调用 pthread_join。如果线程已经被分离,线程的底层存储资源可以在线程终止时立即被收回。在线程被分离后,我们不能用pthread_join函数等待它的终止状态,因为对分离状态的线程调用 pthread_join会产生未定义行为。可以调用 pthread_detach分离线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当一个线程可以修改的变量,其他线程也可以读取或者修改的时候,我们就需要对这些线程进行同步,确保它们在访问变量的存储内容时不会访问到无效的值。</p>
<p>当一个线程修改变量时,其他线程在读取这个变量时可能会看到一个不一致的值。在变量修改时间多于一个存储器访问周期的处理器结构中,当存储器读与存储器写这两个周期交叉时,这种不一致就会出现。</p>
<p>为了解决这个问题,线程不得不使用锁,同一时间只允许一个线程访问该变量</p>
<p><img src="https://data2.liuin.cn/2018-05-02-15252443887056.jpg" alt=""></p>
<p>两个或多个线程试图在同一时间修改同一变量时,也需要进行同步</p>
<p>如果修改操作是原子操作,那么就不存在竞争。当多个线程观察不到数据的不一致时,那么操作就是顺序一致的。在现代计算机系统中,存储访问需要多个总线周期,多处理器的总线周期通常在多个处理器上是交叉的,所以我们并不能保证数据是顺序一致的。</p>
<p><img src="https://data2.liuin.cn/2018-05-25-15272391697777.jpg" alt=""></p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>可以使用 pthread的互斥接口来保护数据,确保同一时间只有一个线程访问数据。<strong>互斥量(mutex)</strong>从本质上说是一把锁,在访问共享资源前对互斥量进行设置(加锁),在访问完成后释放(解锁)互斥量。</p>
<p>互斥变量是用<code>pthread_mutex_t</code>数据类型表示的，使用互斥量之前必须要初始化，动态分配的互斥量在释放内存之前要调用<code>pthread_mutex_destory</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>要用默认的属性初始化互斥量,只需把attr设为NULL。</p>
<p>对互斥量进行加锁,需要调用<code>pthread_mutex_lock</code>。如果互斥量已经上锁,调用线程将阻塞直到互斥量被解锁。对互斥量解锁,需要调用<code>pthread_mutex_un1ock</code>。</p>
<p>如果线程不希望被阻塞,它可以使用<code>pthread_mutex_try1ock</code>尝试对互斥量进行加锁。如果调用 <code>pthread_mutex_try1ock</code>时互斥量处于未锁住状态,那么<code>pthread_mutex_try1ock</code>将锁住互斥量,不会出现阻塞直接返回0,否则<code>pthread_mutex_try1ock</code>就会失败,不能锁住互斥量,返回 EBUSY。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>如果线程试图对同一个互斥量加锁两次,那么它自身就会陷入死锁状态,可以通过仔细控制互斥量加锁的顺序来避免死锁的发生。例如,假设需要对两个互斥量A和B同时加锁。如果所有线程总是在对互斥量B加锁之前锁住互斥量A,那么使用这两个互斥量就不会产生死锁(当然在其他的资源上仍可能出现死锁)。</p>
<p>上面讲的是采用顺序加锁的形式避免死锁的方式。</p>
<p>有时候,应用程序的结构使得对互斥量进行排序是很困难的。如果涉及了太多的锁和数据结构,可用的函数并不能把它转换成简单的层次,那么就需要采用另外的方法。在这种情况下,可以先释放占有的锁,然后过一段时间再试。这种情况可以使用 pthread_mutex_trylock接口避免死锁。如果已经占有某些锁而且 pthread_mutex_try1ock接口返回成功,那么就可以前进。但是,如果不能获取锁,可以先释放已经占有的锁,做好清理工作,然后过一段时间再重新试。</p>
<h3 id="函数pthread-mutex-timelock"><a href="#函数pthread-mutex-timelock" class="headerlink" title="函数pthread_mutex_timelock"></a>函数pthread_mutex_timelock</h3><p>当线程试图获取一个已加锁的互斥量时,<code>pthread_mutex_timedlock</code>互斥量原语允许绑定线程阻塞时间。 <code>pthread_mutex_timedlock</code>函数与<code>pthread_mutex_timedlock</code>是基本等价的,但是在达到超时时间值时,<code>pthread_mutex_timedlock</code>不会对互斥量进行加锁,而是返回错误码 ETIME_DOUT。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; #include &lt;time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_timedlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁( reader-writer lock)与互斥量类似,不过读写锁允许更高的并行性。互斥量要么是锁住状态,要么就是不加锁状态,而且一次只有一个线程可以对其加锁。读写锁可以有3种状态:读模式下加锁状态,写模式下加锁状态,不加锁状态。一次只有一个线程可以占有写模式的读写锁,但是多个线程可以同时占有读模式的读写锁</p>
<p>读写锁非常适合于对数据结构读的次数远大于写的情况。读写锁也叫做共享互斥锁( shared-exclusive lock)。</p>
<p>初始化和销毁读写锁的函数和互斥量类似<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure></p>
<p>要在读模式下锁定读写锁,需要调用<code>pthread_rwlock_rdlock</code>。要在写模式下锁定读写锁,需要调用 <code>pthread_rwlock_wrlock</code>。不管以何种方式锁住读写锁,都可以调用<code>pthread_rw1ock_unlock</code>进行解锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>读写锁原语的条件版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="带有超时的读写锁"><a href="#带有超时的读写锁" class="headerlink" title="带有超时的读写锁"></a>带有超时的读写锁</h3><p>与互斥量一样，读写锁也有带有超时条件的加锁函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; #include &lt;time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedwrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量是线程可用的另一种同步机制。条件变量给多个线程提供了一个会合的场所。条件变量与互斥量一起使用时,允许线程以无竞争的方式等待特定的条件发生。</p>
<p>条件本身是由互斥量保护的。<strong>线程在改变条件状态之前必须首先锁住互斥量</strong>。其他线程在获得互斥量之前不会察觉到这种改变,因为互斥量必须在锁定以后才能计算条件。</p>
<p>条件变量使用的数据结构<code>pthread_cond_t</code>，同理也有初始化和销毁的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>我们使用<code>pthread_cond_wait</code>等待条件变量变为真。如果在给定的时间内条件不能满足那么会生成一个返回错误码的变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>传递给pthread_cond_wait的互斥量对条件进行保护。调用者<strong>把锁住的互斥量传给函数,函数然后自动把调用线程放到等待条件的线程列表上,对互斥量解锁</strong>。这就<strong>关闭了条件检查和线程进入休眠状态等待条件改变这两个操作之间的时间通道,这样线程就不会错过条件的任何变化</strong>。 pthread_cond_wait返回时,互斥量再次被锁住。</p>
<p>有两个函数可以用于通知线程条件已经满足。<code>pthread_cond_signal</code>函数<strong>至少能唤醒一个等待该条件的线程</strong>,而<code>pthread_cond_broadcast</code>函数则能<strong>唤醒等待该条件的所有线程</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁与互斥量类似,但它不是通过休眠使进程阻塞,而是在获取锁之前一直处于忙等(自旋)阻塞状态。自旋锁可用于以下情况:锁被持有的时间短,而且线程并不希望在重新调度上花费太多的成本</p>
<p>自旋锁通常作为底层原语用于实现其他类型的锁。</p>
<p>当自旋锁用在非抢占式内核中时是非常有用的:除了提供互斥机制以外,它们会阻塞中断这样中断处理程序就不会让系统陷入死锁状态,因为它需要获取已被加锁的自旋锁(把中断想成是另一种抢占)。在这种类型的内核中,中断处理程序不能休眠,因此它们能用的同步原语只能是自旋锁。</p>
<p>初始化和销毁函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_init</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock, <span class="keyword">int</span> pshared)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_destroy</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>加锁解锁函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_lock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_trylock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_unlock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>屏障(barrier)是用户<strong>协调多个线程并行工作的同步机制</strong>。屏障允许每个线程等待,直到所有的合作线程都到达某一点,然后从该点继续执行。我们已经看到一种屏障,<code>pthread_jo1n</code>函数就是一种屏障,允许一个线程等待,直到另一个线程退出。</p>
<p>但是屏障对象的概念更广,它们允许任意数量的线程等待,直到所有的线程完成处理工作而线程不需要退出。所有线程达到屏障后可以接着工作。</p>
<p>初始化和销毁函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_init</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *<span class="keyword">restrict</span> barrier, <span class="keyword">const</span> <span class="keyword">pthread_barrierattr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_destroy</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>初始化屏障时,可以使用<code>count</code>参数指定在允许所有线程继续运行之前,必须到达屏障的线程数目。使用<code>attr</code>参数指定屏障对象的属性,设置atmr为NULL,用默认属性初始化屏障。</p>
<p>可以使用<code>pthread_barrier_wait</code>函数来表明,线程已完成工作,准备等所有其他线程赶上来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_wait</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 or PTHREAD_BARRIER_SERIAL_THREAD if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>一旦达到屏障计数值,而且线程处于非阻塞状态,屏障就可以被重用。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[APUE 进程关系]]></title>
      <url>/2018/05/01/APUE-%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/</url>
      <content type="html"><![CDATA[<p>《UNIX环境高级编程》第9章 进程关系 笔记</p>
<a id="more"></a>
<h2 id="终端登录"><a href="#终端登录" class="headerlink" title="终端登录"></a>终端登录</h2><p>我们现在描述的过程用于经由终端登录至UNIX系统。该过程几乎与所使用的终端类型无关,所使用的终端可以是基于字符的终端、仿真基于字符终端的图形终端,或者运行窗口系统的图形终端。</p>
<ol>
<li>BSD终端登录</li>
</ol>
<p>系统管理者创建通常名为/etc/ttys的文件,其中,每个终端设备都有一行,每一行说明设备名和传到 getty程序的参数。</p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251450557245.jpg" alt=""></p>
<p>1ogin能处理多项工作。因为它得到了用户名,所以能调用<code>getpwnam</code>取得相应用户的口令文件登录项。然后调用<code>getpass</code>以显示提示“ Password:”,接着读用户键入的口令(自然,禁止回显用户键入的口令)。它调用 <code>crypt</code>将用户键入的口令加密,并与该用户在阴影口令文件中登录项的<code>pw_passwd</code>字段相比较。如果用户几次键入的口令都无效,则<code>1ogin</code>以参数1调用<code>exit</code>表示登录过程失败。父进程(init)了解到子进程的终止情况后,将再次调用<code>fork</code>,其后又执行了<code>getty</code>,对此终端重复上述过程。</p>
<p>如果用户正确登录，login就将完成如下工作：</p>
<ol>
<li>将当前工作目录更改为该用户的起始目录(chdir)。</li>
<li>调用chown更改该终端的所有权,使登录用户成为它的所有者。将对该终端设备的访问权限改变成“用户读和写”。</li>
<li>调用setgid及initgroups设置进程的组ID</li>
<li>用login得到的所有信息初始化环境:起始目录(HOME)、shell(SHEL)用户名(USER和 LOGNAME)以及一个系统默认路径(PATH)。</li>
<li>1ogin进程更改为登录用户的用户ID( setuid)并调用该用户的登录 shell</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-05-01-15251453247541.jpg" alt=""></p>
<h2 id="网络登录"><a href="#网络登录" class="headerlink" title="网络登录"></a>网络登录</h2><p>通过串行终端登录至系统和经由网络登录至系统两者之间的主要(物理上的)区别是:网络登录时,在终端和计算机之间的连接不再是点到点的。在网络登录情况下,1ogin仅仅是一种可用的服务,这与其他网络服务(如FIP或SMIP)的性质相同</p>
<p>为使同一个软件既能处理终端登录,又能处理网络登录,系统使用了一种称为伪终端(pseudo terminal)的软件驱动程序,它仿真串行终端的运行行为,并将终端操作映射为网络操作,反之亦然。</p>
<ol>
<li>BSD网络登录</li>
</ol>
<p>作为系统启动的一部分,init调用一个shell,,使其执行shell脚本/etc/rc。由此shell脚本启动一个守护进程 inetd。一旦此shell脚本终止, inetd的父进程就变成init。 inetd等待TCP/IP连接请求到达主机,而当一个连接请求到达时,它执行一次fork,然后生成的子进程exec适当的程序。</p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251533208482.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251534277316.jpg" alt=""></p>
<p>当通过终端或网络登录时,我们得到一个登录shell,其标准输入、标准输出和标准错误要么连接到一个终端设备,要么连接到一个伪终端设备上。</p>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><p>进程组是一个或多个进程的集合。通常,它们是在同一作业中结合起来的,<strong>同一进程组中的各进程接收来自同一终端的各种信号</strong>。每个进程组有一个唯一的进程组ID。进程组ID类似于进程ID——它是一个正整数,并可存放在pid_t数据类型中。函数 getpgrp返回调用进程的进程组ID。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getpgrp(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: process group ID of calling process</span></div></pre></td></tr></table></figure>
<p>getpgid函数返回指定进程所在的进程组ID：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getpgid(<span class="keyword">pid_t</span> pid);</div><div class="line"></div><div class="line"><span class="comment">// Returns: process group ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>每个进程组有一个组长进程。组长进程的进程组ID等于其进程ID。</p>
<p>进程组组长可以创建一个进程组、创建该组中的进程,然后终止。<strong>只要在某个进程组中有个进程存在,则该进程组就存在,这与其组长进程是否终止无关</strong>。从进程组创建开始到其中最后一个进程离开为止的时间区间称为进程组的生命期。某个进程组中的最后一个进程可以终止,也可以转移到另一个进程组</p>
<p>进程调用setpgid可以加入一个现有的进程组或者创建一个新进程组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>一个进程只能为它自己或它的子进程设置进程组ID。在它的子进程调用了exec后,它就不再更改该子进程的进程组ID</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话( session)是一个或多个进程组的集合</p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251538207763.jpg" alt=""></p>
<p>通常是由shell管道将几个进程编成一组的。</p>
<p>进程调用setsid函数建立一个新会话</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> setsid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: process group ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>如果调用此函数的进程不是一个进程组的组长,则此函数创建个新会话。具体会发生以下3件事。</p>
<ol>
<li>进程变成新会话的会话首进程( session leader,会话首进程是创建该会话的进程)。此时,该进程是新会话中的唯一进程</li>
<li>该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID。</li>
<li>该进程没有控制终端(下一节讨论控制终端)。如果在调用 setid之前该进程有一个控制终端,那么这种联系也被切断。</li>
</ol>
<p>如果该调用进程已经是一个进程组的组长,则此函数返回出错。为了保证不处于这种情况,通常先调用fork,然后使其父进程终止,而子进程则继续。因为子进程继承了父进程的进程组ID,而其进程ID则是新分配的,两者不可能相等,这就保证了子进程不是一个进程组的组长</p>
<p>会话首进程是具有唯一进程ID的单个进程,所以<strong>可以将会话首进程的进程ID视为会话ID</strong></p>
<p><code>getsid</code>函数返回会话首进程的进程组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getsid(<span class="keyword">pid_t</span> pid); </div><div class="line"></div><div class="line"><span class="comment">// Returns: session leader’s process group ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>如若pid是0, getsid返回调用进程的会话首进程的进程组ID。出于安全方面的考虑些实现有如下限制:如若pid并不属于调用者所在的会话,那么调用进程就不能得到该会话首进程的进程组ID</p>
<h2 id="控制终端"><a href="#控制终端" class="headerlink" title="控制终端"></a>控制终端</h2><p>会话和进程组还有一些其他特性</p>
<ul>
<li>一个会话可以有一个控制终端(controlling terminal)。这通常是终端设备(在终端登录情况下)或伪终端设备(在网络登录情况下)。</li>
<li>建立与控制终端连接的会话首进程被称为控制进程(controlling process)</li>
<li>一个会话中的几个进程组可被分成一个前台进程组(foreground process group)以及一个或多个后台进程组(background process group)</li>
<li>如果一个会话有一个控制终端,则它有一个前台进程组,其他进程组为后台进程组</li>
<li>无论何时键入终端的中断键(常常是Delete或Ctrl+C),都会将中断信号发送至前台进程组的所有进程。</li>
<li>无论何时键入终端的退出键(常常是Ctrl+),都会将退出信号发送至前台进程组的所有进程。</li>
<li>如果终端接口检测到调制解调器(或网络)已经断开连接,则将挂断信号发送至控制进程〔会话首进程)</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-05-01-15251544917844.jpg" alt=""></p>
<p>有时不管标准输入、标准输出是否重定向,程序都要与控制终端交互作用。保证程序能与控制终端对话的方法是open文件/dev/tty。在内核中,此特殊文件是控制终端的同义语。自然地,如果程序没有控制终端,则对于此设备的open将失败。</p>
<h2 id="函数tcgetpgrp、tcsetpgrp和tcgetsid"><a href="#函数tcgetpgrp、tcsetpgrp和tcgetsid" class="headerlink" title="函数tcgetpgrp、tcsetpgrp和tcgetsid"></a>函数tcgetpgrp、tcsetpgrp和tcgetsid</h2><p>需要有一种方法来通知内核哪一个进程组是前台进程组,这样,终端设备驱动程序就能知道将终端输入和终端产生的信号发送到何处</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> tcgetpgrp(<span class="keyword">int</span> fd); </div><div class="line"></div><div class="line"><span class="comment">// Returns: process group ID of foreground process group if OK, −1 on error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsetpgrp</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">pid_t</span> pgrpid)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>函数tcgetpgrp返回前台进程组ID,它与在fd上打开的终端相关联</p>
<p>如果进程有一个控制终端,则该进程可以调用 tcsetpgrp将前台进程组ID设置为pergid值应当是在同一会话中的一个进程组的ID。fd必须引用该会话的控制终端。</p>
<p>给出控制TTY的文件描述符,通过 tcgetsid函数,应用程序就能获得会话首进程的进程组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> tcgetsid(<span class="keyword">int</span> fd); </div><div class="line"></div><div class="line"><span class="comment">// Returns: session leader’s process group ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h2><p>作业控制允许<strong>在一个终端上启动多个作业(进程组)</strong>，它控制哪一个作业可以访问该终端以及哪些作业在后台运行。作业控制要求以下3种形式的支持。</p>
<ol>
<li>支持作业控制的 shell</li>
<li>内核中的终端驱动程序必须支持作业控制。</li>
<li>内核必须提供对某些作业控制信号的支持。</li>
</ol>
<p>从 shell使用作业控制功能的角度观察,用户可以在前台或后台启动一个作业。一个作业只是几个进程的集合,通常是一个进程管道。</p>
<p>当启动一个后台作业时，shell赋予其一个作业标识符，并打印一个或者多个进程ID，如下图所示：</p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251551733307.jpg" alt=""></p>
<p>我们可以键入一个影响前台作业的特殊字符—挂起键(通常采用Ctrl+z),与终端驱动程序进行交互作用。键入此字符使终端驱动程序将信号SIGTSTP发送至前台进程组中的所有进程,后台进程组作业则不受影响。实际上有3个特殊字符可使终端驱动程序产生信号,并将它们发送至前台进程组，他们是：</p>
<ul>
<li>中断字符(一般采用Delete或Ctrl+C)产生 SIGINT</li>
<li>退出字符(一般采用Ctrl+)产生 SIGQUIT</li>
<li>挂起字符(一般采用Ctrl+Z)产生 SIGTSTE。</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-05-01-15251552824446.jpg" alt=""></p>
<p>是否需要作业控制是一个有争议的问题。作业控制是在窗口终端广泛得到应用之前设计和实现的。很多人认为设计得好的窗口系统已经免除了对作业控制的需要。某些人抱怨作业控制的实现要求得到内核、终端驱动程序、 shell以及某些应用程序的支持,是吃力不讨好的事情。</p>
<h2 id="shell-执行程序"><a href="#shell-执行程序" class="headerlink" title="shell 执行程序"></a>shell 执行程序</h2><p><img src="https://data2.liuin.cn/2018-05-01-15251555962605.jpg" alt=""></p>
<h2 id="孤儿进程组"><a href="#孤儿进程组" class="headerlink" title="孤儿进程组"></a>孤儿进程组</h2><p>我们曾提及,一个其父进程己终止的进程称为孤儿进程( orphan process),这种进程由init进程“收养”。现在我们要说明整个进程组也可成为“孤儿”,以及POSIX.1如何处理它。</p>
<p>POSIX.1将孤儿进程组( orphaned process group)定义为:该组中每个成员的父进程要么是该组的一个成员,要么不是该组所属会话的成员。对孤儿进程组的另一种描述可以是:一个进程组不是孤儿进程组的条件是——该组中有一个进程,其父进程在属于同一会话的另一个组中。如果进程组不是孤儿进程组那么在属于同一会话的另一个组中的父进程就有机会重新启动该组中停止的进程。在这里,进程组中每一个进程的父进程(例如,进程6100的父进程是进程1)都属于另一个会话。所以此进程组是孤儿进程组</p>
<p>父进程终止后,进程组包含一个停止的进程,进程组成为孤儿进程组,POSIX.1要求向新孤儿进程组中处于停止状态的每一个进程发送挂断信号( SIGHUP),接着又向其发送继续信号( SIGCONT)。</p>
<p>在处理了挂断信号后,子进程继续。对挂断信号的系统默认动作是终止该进程,为此必须提供一个信号处理程序以捕捉该信号。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[APUE 进程控制]]></title>
      <url>/2018/04/30/APUE-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>《UNIX环境高级编程》第8章 进程控制 笔记</p>
<a id="more"></a>
<h2 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h2><p>每个进程都有一个非负整型表示的唯一进程ID。因为进程ID标识符总是唯一的,常将其用作其他标识符的一部分以保证其唯一性。</p>
<p>虽然是唯一的,但是<strong>进程ID是可复用的</strong>。当一个进程终止后,其进程ID就成为复用的候选者。大多数UNIX系统实现延迟复用算法,使得赋予新建进程的DD不同于最近终止进程所使用的ID。这防止了将新进程误认为是使用同一ID的某个已终止的先前进程。</p>
<p>系统中有一些专用进程,但具体细节随实现而不同。<strong>ID为0的进程通常是调度进程,常常被称为交换进程</strong>(swapper)。该进程是内核的一部分,它并不执行任何磁盘上的程序,因此也被称为系统进程。</p>
<p>进程ID为1通常是init进程,在自举过程结束时由内核调用。该进程的程序文件在UNIX的早期版本中是/etc/init,在较新版本中是/sbin/init。此进程负责在自举内核后启动一个UNIX系统。init通常读取与系统有关的初始化文件(/etc/rc*文件或/etc/inittab文件,以及在/etc/init.d中的文件),并将系统引导到一个状态(如多用户)。init进程决不会终止。它是一个普通的用户进程(与交换进程不同,它不是内核中的系统进程),但是它以超级用户特权运行。</p>
<p>每个UNIX系统实现都有它自己的一套提供操作系统服务的内核进程,例如,在某些UNIX的虚拟存储器实现中,进程ID2是页守护进程( page daemon),此进程负责支持虚拟存储器系统的分页操作。</p>
<p>返回进程标识符的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: process ID of calling process</span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getppid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: parent process ID of calling process</span></div><div class="line"></div><div class="line"><span class="keyword">uid_t</span> getuid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: real user ID of calling process</span></div><div class="line"></div><div class="line"><span class="keyword">uid_t</span> geteuid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: effective user ID of calling process</span></div><div class="line"></div><div class="line"><span class="keyword">gid_t</span> getgid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: real group ID of calling process</span></div><div class="line"></div><div class="line"><span class="keyword">gid_t</span> getegid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: effective group ID of calling process</span></div></pre></td></tr></table></figure>
<h2 id="函数fork"><a href="#函数fork" class="headerlink" title="函数fork"></a>函数fork</h2><p>一个现有进程调用fork函数创建一个新的进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 in child, process ID of child in parent, −1 on error</span></div></pre></td></tr></table></figure>
<p>由fork创建的新进程被称为子进程(child process) fork函数被调用一次,但返回两次。两次返回的区别是子进程的返回值是0,而父进程的返回值则是新建子进程的进程ID。</p>
<p>将子进程ID返回给父进程的理由是:因为一个进程的子进程可以有多个,<strong>并且没有一个函数使一个进程可以获得其所有子进程的进程ID</strong>。fork使子进程得到返回值0的理由是:一个进程只会有一个父进程,所以子进程总是可以调用 getppid以获得其父进程的进程ID(进程ID0总是由内核交换进程使用,所以一个子进程的进程ID不可能为0)</p>
<p>子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。</p>
<p>由于在fork之后经常跟随着exec,所以现在的很多实现并不执行一个父进程数据段栈和堆的完全副本。作为替代,使用了<strong>写时复制</strong>( copy-on-write,COW)技术。这些区域由父进程和子进程共享,而且内核将它们的访问权限改变为只读。如果父进程和子进程中的任一个试图修改这些区域,则内核只为修改区域的那块内存制作一个副本,通常是虚拟存储系统中的一“页”。</p>
<p>一般来说,在fork之后是父进程先执行还是子进程先执行是不确定的,这取决于内核所使用的调度算法。如果要求父进程和子进程之间相互同步,则要求某种形式的进程间通信。</p>
<blockquote>
<p>strlen 和 sizeof 的区别</p>
</blockquote>
<p>str1en计算不包含终止nul字节的字符串长度,而sizeof则计算包括终止nul字节的缓冲区长度。两者之间的另一个差别是,使用strlen需进行一次函数调用,而对于sizeof而言,因为缓冲区已用已知字符串进行初始化,其长度是固定的,所以 sizeof是在编译时计算缓冲区长度。</p>
<blockquote>
<p>文件共享</p>
</blockquote>
<p>fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中。我们说“复制”是因为对每个文件描述符来说,就好像执行了dup函数。<strong>父进程和子进程每个相同的打开描述符共享一个文件表项</strong>，因此他们共享的是一个文件偏移量。</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250766871953.jpg" alt=""></p>
<p>如果父进程和子进程写同一描述符指向的文件,但又没有任何形式的同步(如使父进程等待子进程),那么它们的输出就会相互混合(假定所用的描述符是在foxk之前打开的)。</p>
<p>在fork之后处理文件描述符有以下两种情况：</p>
<ol>
<li>父进程等待子进程完成</li>
<li>父进程和子进程各自执行不同的程序段</li>
</ol>
<p>除了打开文件之外,<strong>子进程继承父进程的属性</strong>有：</p>
<ul>
<li>实际用户ID、实际组ID、有效用户ID、有效组ID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>会话ID</li>
<li>控制终端</li>
<li>设置用户ID标志和设置组ID标志</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字</li>
<li>信号屏蔽和安排</li>
<li>对任一打开文件描述符的执行时关闭( close-on-exec)标志</li>
<li>环境</li>
<li>连接的共享存储段</li>
<li>存储映像</li>
<li>资源限制</li>
</ul>
<p>父进程和子进程的区别如下：</p>
<ul>
<li>fork的返回值不同</li>
<li>进程ID不同</li>
<li>这两个进程的父进程ID不同:子进程的父进程ID是创建它的进程的ID,而父进程的父进程ID则不变。</li>
<li>进程的 tms_utime、 tms_stime、 tms_cutime和tms_ultime的值设置为0</li>
<li>子进程不继承父进程设置的文件锁</li>
<li>子进程的未处理闹钟被清除</li>
<li>子进程的未处理信号集设置为空集</li>
</ul>
<p>使fork失败的原因主要有以下几个：</p>
<ol>
<li>系统中已经有了太多的进程</li>
<li>该实际用户ID的进程总数超过了系统限制</li>
</ol>
<p>fork有如下两种用法：</p>
<ol>
<li>一个父进程希望复制自己,使父进程和子进程同时执行不同的代码段</li>
<li>一个进程要执行一个不同的程序</li>
</ol>
<h2 id="函数vfork"><a href="#函数vfork" class="headerlink" title="函数vfork"></a>函数vfork</h2><p>vfork函数的调用序列和返回值与fork相同,但两者的语义不同</p>
<p>vfork函数用于创建一个新进程,而该新进程的目的是exec一个新程序。但是它并不将父进程的地址空间完全复制到子进程中,因为子进程会立即调用exec(或exit),于是也就<strong>不会引用该地址空间</strong>。不过在子进程调用exec或exit之前,它在父进程的空间中运行。这种优化工作方式在某些UNIX系统的实现中提高了效率,但如果子进程修改数据(除了用于存放 vfork返回值的变量)、进行函数调用、或者没有调用exec或exit就返回都可能会带来未知的结果。(就像上一节中提及的,实现采用写时复制技术以提高fork之后跟随exec操作的效率,但是不复制比部分复制还是要快一些)</p>
<p>vfork和fork之间的另一个区别是: <strong>vfork保证子进程先运行,在它调用exec或exit之后父进程才可能被调度运行,当子进程调用这两个函数中的任意一个时,父进程会恢复运行</strong>。</p>
<h2 id="函数exit"><a href="#函数exit" class="headerlink" title="函数exit"></a>函数exit</h2><p>进程有5种正常终止和3种异常终止的方式，5种正常终止的方式如下：</p>
<ol>
<li>从main返回</li>
<li>调用exit</li>
<li>调用_exit或_Exit</li>
<li>最后一个线程从其启动例程返回</li>
<li>从最后一个线程调用 pthread_exit</li>
</ol>
<p>3种异常终止方式：</p>
<ol>
<li>调用 abort</li>
<li>接到一个信号</li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<p>不管进程如何终止,最后都会执行内核中的同一段代码。这段代码为相应进程<strong>关闭所有打开描述符,释放它所使用的存储器等</strong>。</p>
<p>对上述任意一种终止情形,我们都希望终止进程能够通知其父进程它是如何终止的。对于3个终止函数(exit、_exit和_Exit),实现这一点的方法是,将其退出状态( exit status)作为参数传送给函数。在异常终止情况,内核(不是进程本身)<strong>产生一个指示其异常终止原因的终止状态</strong>( termination status)。在任意一种情况下,该终止进程的父进程都能用wait或wa1tpid函数(将在下一节说明)取得其终止状态。</p>
<p>上面说明了子进程将其终止状态返回给其父进程，但是如果父进程在子进程之前终止,又将如何呢?其回答是:<strong>对于父进程已经终止的所有进程,它们的父进程都改变为init进程</strong>。我们称这些进程由init进程收养。其操作过程大致是:在一个进程终止时,内核逐个检查所有活动进程,以判断它是否是正要终止进程的子进程,如果是,则该进程的父进程ID就更改为1(init进程的ID)。这种处理方法保证了每个进程有一个父进程。</p>
<p>如果子进程在父进程之前终止,那么父进程又如何能在做相应检查时得到子进程的终止状态呢?如果子进程完全消失了,父进程在最终准备好检查子进程是否终止时是无法获取它的终止状态的。内核为每个终止子进程保存了一定量的信息,所以当终止进程的父进程调用wait或 waitpid时,可以得到这些信息。</p>
<p>在UNIX术语中,一个已经终止、但是其父进程尚未对其进行善后处理(获取终止子进程的有关信息、释放它仍占用的资源)的进程被称为<strong>僵死进程</strong>(zombie)。ps(1)命令将僵死进程的状态打印为Z。如果编写一个长期运行的程序,它fork了很多子进程,那么除非父进程等待取得子进程的终止状态,不然这些子进程终止后就会变成僵死进程</p>
<p>最后一个要考虑的问题是:一个由init进程收养的进程终止时会发生什么?它会不会变成一个僵死进程?对此问题的回答是“否”,因为init被编写成无论何时只要有一个子进程终止,init就会调用一个wait函数取得其终止状态。这样也就防止了在系统中塞满僵死进程。</p>
<h2 id="函数wait-和-waitpid"><a href="#函数wait-和-waitpid" class="headerlink" title="函数wait 和 waitpid"></a>函数wait 和 waitpid</h2><p>当一个进程正常或异常终止时,内核就向其父进程发送 SIGCHLD信号。因为子进程终止是个异步事件(这可以在父进程运行的任何时候发生),所以这种信号也是内核向父进程发的异步通知。父进程可以选择忽略该信号,或者提供一个该信号发生时即被调用执行的函数(信号处理程序)。对于这种信号的系统默认动作是忽略它。</p>
<p>现在我们要知道的是调用wait和waitpid时进程都发生什么：</p>
<ul>
<li>如果其所有子进程都还在运行,则阻塞。</li>
<li>如果一个子进程已终止,正等待父进程获取其终止状态,则取得该子进程的终止状态立即返回</li>
<li>如果它没有任何子进程,则立即出错返回。</li>
</ul>
<p>如果进程由于接收到 SIGCHLD信号而调用wait,我们期望wait会立即返回。但是如果在间点调用wait,则进程可能会阻塞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *statloc); </div><div class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options); </div><div class="line"></div><div class="line"><span class="comment">// Both return: process ID if OK, 0 (see later), or −1 on error</span></div></pre></td></tr></table></figure>
<p>两个函数的区别如下：</p>
<ul>
<li>在一个子进程终止前,wait使其调用者阻塞,而 waitpid有一选项,可使调用者不阻塞</li>
<li>waitpid并不等待在其调用之后的第一个终止子进程,它有若千个选项,可以控制它所等待的进程</li>
</ul>
<p>这两个函数的参数statloc是一个整型指针。如果statloc不是一个空指针,则终止进程的终止状态就存放在它所指向的单元内。如果不关心终止状态,则可将该参数指定为空指针</p>
<p>对于waitpid函数中pid参数的作用解释如下。</p>
<ul>
<li>pid == -1  等待任一子进程。此种情况下, waitpid与wait等效</li>
<li>pid &gt; 0  等待进程ID与pid相等的子进程</li>
<li>pid == 0  等待组ID等于调用进程组ID的任一子进程。</li>
<li>pid &lt; -1  等待组ID等于pid绝对值的任一子进程</li>
</ul>
<p>waitpid函数返回终止子进程的进程ID,并将该子进程的终止状态存放在由saoc指向的存储单元中。</p>
<p>options参数可以使我们能够进一步控制waitpid函数的操作</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250876888707.jpg" alt=""></p>
<h2 id="函数waitid"><a href="#函数waitid" class="headerlink" title="函数waitid"></a>函数waitid</h2><p>另一个取得进程终止状态的函数waited,此函数类似于 waitpid,但提供了更多的灵活性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">waitid</span><span class="params">(<span class="keyword">idtype_t</span> idtype, <span class="keyword">id_t</span> id, <span class="keyword">siginfo_t</span> *infop, <span class="keyword">int</span> options)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>与 waitpid相似, waitid允许一个进程指定要等待的子进程。但它使用两个单独的参数表示要等待的子进程所属的类型,而不是将此与进程DD或进程组ID组合成一个参数。</p>
<p>idtype参数：</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250878149783.jpg" alt=""></p>
<p>options参数：</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250878305949.jpg" alt=""></p>
<h2 id="函数wait3和wait4"><a href="#函数wait3和wait4" class="headerlink" title="函数wait3和wait4"></a>函数wait3和wait4</h2><p>wait3和wait4提供的功能比上面的函数多一个，该参数允许内核返回由终止进程及其所有子进程使用的资源概况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> wait3(<span class="keyword">int</span> *statloc, <span class="keyword">int</span> options, <span class="keyword">struct</span> rusage *rusage);</div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> wait4(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options, <span class="keyword">struct</span> rusage *rusage);</div><div class="line"></div><div class="line"><span class="comment">// Both return: process ID if OK, 0, or −1 on error</span></div></pre></td></tr></table></figure>
<p>资源统计信息包括用户CPU时间总量、系统CPU时间总量、缺页次数、接收到信号的次数等。</p>
<h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><p>当多个进程都企图对共享数据进行某种处理,而最后的结果又取决于进程运行的顺序时,我们认为发生了竞争条件(race condition)。如果在fork之后的某种逻辑显式或隐式地依赖于在fork之后是父进程先运行还是子进程先运行,那么fork函数就会是竞争条件活跃的滋生地</p>
<p>如果一个进程希望等待一个子进程终止,则它必须调用wait函数中的一个。如果一个进程要等待其父进程终止,则可使用下列形式的循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">while</span>(getppid() != <span class="number">1</span>)</div><div class="line">    sleep(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>这种形式的循环称为轮询( polling),它的问题是浪费了CPU时间,因为调用者每隔1s都被唤醒,然后进行条件测试</p>
<p>为了避免竞争条件和轮询,在多个进程之间需要有某种形式的信号发送和接收的方法。在UNIX中可以使用信号机制。各种形式的进程间通信(IPC)也可使用。</p>
<h2 id="函数exec"><a href="#函数exec" class="headerlink" title="函数exec"></a>函数exec</h2><p>用fork函数创建新的子进程后,子进程往往要调用一种exec函数以执行另个程序。当进程调用一种exec函数时,该进程执行的程序完全替换为新程序,而新程序则从其main函数开始执行。因为调用exec并不创建新进程,所以前后的进程ID并未改变。<strong>exec只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段</strong>。</p>
<p>有7中不同的exec函数可以使用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span> )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ...<span class="comment">/* (char *)0, char *const envp[] */</span> )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ﬁlename, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span> )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ﬁlename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fexecve</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All seven return: −1 on error, no return on success</span></div></pre></td></tr></table></figure></p>
<p>这些函数之间的第一个区别是前4个函数取路径名作为参数,后两个函数则取文件名作为参数,最后一个取文件描述符作为参数。</p>
<p>第二个区别与参数表的传递有关(1表示列表list,v表示矢量vector)。函数exec1、exec1p和 execle要求将新程序的每个命令行参数都说明为一个单独的参数。这种参数表以空指针结尾。对于另外4个函数( execv、 execvp、execve和 fexecve),则应先构造一个指向各参数的指针数组,然后将该数组地址作为这4个函数的参数。</p>
<p>最后一个区别与向新程序传递环境表相关。以e结尾的3个函数(eXec1e、 execve和 fexecve)可以传递一个指向环境字符串指针数组的指针。其他4个函数则使用调用进程中的 environ变量为新程序复制现有的环境</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15251006856272.jpg" alt=""></p>
<p>前面曾提及,在执行exec后,进程ID没有改变。但新程序从调用进程继承了的下列属性:</p>
<ul>
<li>进程ID和父进程ID</li>
<li>实际用户ID和实际组ID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>会话ID</li>
<li>控制终端</li>
<li>闹钟尚余留的时间</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字</li>
<li>文件锁</li>
<li>进程信号屏蔽</li>
<li>未处理信号</li>
<li>资源限制</li>
<li>nice值</li>
<li>tms_utime、tms_stime、tms_cutime以及tms_ctime值</li>
</ul>
<p>在很多UNIX实现中,这7个函数中只有<code>execve</code>是内核的系统调用。另外6个只是库函数它们最终都要调用该系统调用。</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15251008959267.jpg" alt=""></p>
<h2 id="更改用户ID和更改组ID"><a href="#更改用户ID和更改组ID" class="headerlink" title="更改用户ID和更改组ID"></a>更改用户ID和更改组ID</h2><p>在UNIX系统中,特权(如能改变当前日期的表示法)以及访问控制(如熊否读、写一个特定文件),是基于用户ID和组ID的。当程序需要增加特权,或需要访问当前并不允许访问的资源时,我们需要更换自己的用户ID或组ID,使得新ID具有合适的特权或访问权限。与此类似当程序需要降低其特权或阻止对某些资源的访问时,也需要更换用户ID或组ID,新ID不具有相应特权或访问这些资源的能力</p>
<p>在设计应用时,我们总是试图使用<strong>最小特权( least privilege)模型</strong>。依照此模型我们的程序应当只具有为完成给定任务所需的最小特权。这降低了由恶意用户试图哄骗我们的程序以未预料的方式使用特权造成的安全性风险</p>
<p>设置用户ID和组ID的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>使用时注意如下：</p>
<ul>
<li>若进程具有超级用户特权,则 setuid函数将实际用户ID、有效用户ID以及保存的设置用户ID设置为uid</li>
<li>若进程没有超级用户特权,但是uid等于实际用户ID或保存的设置用户ID,则 setid只将有效用户ID设置为uid。不更改实际用户ID和保存的设置用户ID</li>
<li>如果上面两个条件都不满足,则 errno设置为 EPERM,并返回-1</li>
</ul>
<p>关于内核所维护的3个ID，需要注意的事项如下：</p>
<ul>
<li>只有超级用户才可以更改实际用户ID，通常,实际用户ID是在用户登录时,由1ogin(1)程序设置的,而且决不会改变它。</li>
<li>仅当对程序文件设置了设置用户ID位时,exec函数才设置有效用户ID</li>
<li>保存的设置用户ID是由exec复制有效用户ID而得到的</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-04-30-15251013810789.jpg" alt=""></p>
<ol>
<li>函数setreuid和setregid</li>
</ol>
<p>其功能是交换实际用户ID和有效用户ID的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setreuid</span><span class="params">(<span class="keyword">uid_t</span> ruid, <span class="keyword">uid_t</span> euid)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setregid</span><span class="params">(<span class="keyword">gid_t</span> rgid, <span class="keyword">gid_t</span> egid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<ol>
<li>函数seteuid和setegid</li>
</ol>
<p>它们类似于 setuid和 setgid,但只更改有效用户ID和有效组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>各个函数之间的区别</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15251015827722.jpg" alt=""></p>
<h2 id="解释器文件"><a href="#解释器文件" class="headerlink" title="解释器文件"></a>解释器文件</h2><p>所有现今的UNIX系统都支持解释器文件(interpreter file)。这种文件是文本文件,其起始行的形式是：</p>
<p><code>#! pathname [optional-argument]</code></p>
<p>最常见的如下：</p>
<p><code>#! /bin/sh</code></p>
<p>对这种文件的识别是由内核作为exec系统调用处理的一部分来完成的。内核使调用exec函数的进程<strong>实际执行的并不是该解释器文件,而是在该解释器文件第一行中 pathname所指定的文件</strong>。一定要将解释器文件(文本文件,它以#!开头)和解释器(由该解释器文件第一行中的 pathname指定)区分开来</p>
<p>当内核exec解释器(/home/sar/bin/echoarg)时,argv[0]是该解释器的 pathname,argv[1]是解释器文件中的可选参数</p>
<h2 id="函数system"><a href="#函数system" class="headerlink" title="函数system"></a>函数system</h2><p>ISO C定义了system函数,但是其操作对系统的依赖性很强</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: (see below)</span></div></pre></td></tr></table></figure>
<p>如果 cmdstring是一个空指针,则仅当命令处理程序可用时, system返回非0值,这一特征可以确定在一个给定的操作系统上是否支持 system函数。在UNIX中, system总是可用的。</p>
<p>因为 system在其实现中调用了fork、exec和 waitpid,因此有3种返回值<br>(1)fork失败或者 waitpid返回除 EINTR之外的出错,则 system返回-1,并且设置errno以指示错误类型。<br>(2)如果 exec失败(表示不能执行shel1),则其返回值如同 shell执行了exit(127)一样<br>(3)否则所有3个函数(fork、exec和 waitpid)都成功,那么 system的返回值是 shell的终止状态,其格式已在 waitpid中说明。</p>
<p>使用 system而不是直接使用fork和exec的优点是: system进行了所需的各种出错处理以及各种信号处理</p>
<h2 id="进程会计"><a href="#进程会计" class="headerlink" title="进程会计"></a>进程会计</h2><p>大多数UNIX系统提供了一个选项以进行进程会计( process accounting)处理。启用该选项后,每当进程结束时内核就写一个会计记录。典型的会计记录包含总量较小的二进制数据,一般包括<strong>命令名、所使用的CPU时间总量、用户ID和组ID、启动时间</strong>等。</p>
<p>一个至今没有说明的函数(acct)启用和禁用进程会计。唯一使用这一函数的是<code>accton(8)</code>命令(这是在几种平台上都类似的少数几条命令中的一条)。超级用户执行一个带路径名参数的accton命令启用会计处理。会计记录写到指定的文件中</p>
<p>会计记录结构定义在头文件<sys acct.h="">中，每个系统都有不同，但是基本样式如下：</sys></p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251417041152.jpg" alt=""></p>
<p>会计记录所需的各个数据(各CPU时间、传输的字符数等)都由内核保存在进程表中,并在个新进程被创建时初始化(如fork之后在子进程中)。进程终止时写一个会计记录。</p>
<p>这产生两个后果:</p>
<p>第一,我们不能获取永远不终止的进程的会计记录。像init这样的进程在系统生命周期中直在运行,并不产生会计记录。这也同样适合于内核守护进程,它们通常不会终止<br>第二,在会计文件中记录的顺序对应于进程终止的顺序,而不是它们启动的顺序。</p>
<h2 id="用户标识"><a href="#用户标识" class="headerlink" title="用户标识"></a>用户标识</h2><p>任一进程都可以得到其实际用户ID和有效用户ID及组ID。但是,我们有时希望找到运行该程序用户的登录名。</p>
<p>系统通常记录用户登录时使用的名字(见68节),用get1ogin函数可以获取此登录名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getlogin</span><span class="params">(<span class="keyword">void</span>)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to string giving login name if OK, NULL on error</span></div></pre></td></tr></table></figure>
<p>如果调用此函数的进程没有连接到用户登录时所用的终端,则函数会失败。通常称这些进程为守护进程(daemon)</p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>UNIX系统历史上对进程提供的只是基于调度优先级的粗粒度的控制。调度策略和调度优先级是由内核确定的。<strong>进程可以通过调整nice值选择以更低优先级运行</strong>(通过调整nice值降低它对CPU的占有,因此该进程是“友好的”)。只有特权进程允许提高调度权限</p>
<p>Single UNIX Specification中nice值的范围在0~(2*NZERO)-1之间,有些实现支持0~2*NERO。nice值越小,优先级越高。虽然这看起来有点倒退,但实际上是有道理的:你越友好,你的调度优先级就越低。 NERO是系统默认的nice值。</p>
<p>进程可以通过nice函数获取或更改它的nice值。使用这个函数,进程只能影响自己的nce值,不能影响任何其他进程的nice值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">nice</span><span class="params">(<span class="keyword">int</span> incr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: new nice value − NZERO if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>getpriority函数可以像nice函数那样用于获取进程的nice值,但是 getpriority还可以获取一组相关进程的nice值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: nice value between −NZERO and NZERO−1 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>setpriority函数可用于为进程、进程组和属于特定用户ID的所有进程设置优先级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who, <span class="keyword">int</span> value)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h2><p>我们可以度量的3个时间:墙上时钟时间、用户CPU时间和系统CPU时间。任一进程都可调用 times函数获得它自己以及已终止子进程的土述值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">clock_t</span> times(<span class="keyword">struct</span> tms *buf );</div><div class="line"></div><div class="line"><span class="comment">// Returns: elapsed wall clock time in clock ticks if OK, −1 on error</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[APUE 进程环境]]></title>
      <url>/2018/04/29/APUE-%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<p>《UNIX环境高级编程》第7章 进程环境 笔记</p>
<a id="more"></a>
<h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>C程序总是从main函数开始执行，main函数的原型是：</p>
<p><code>int main(int argc, char *argv);</code></p>
<p>其中，argc是命令行参数的数目，argv是指向参数的各个指针所构成的数组</p>
<p>当内核执行C程序时(使用一个exec函数),在调用main前先调用一个特殊的启动例程。可执行程序文件将此启动例程指定为程序的起始地址—这是由连接编辑器设置的,而连接编辑器则由C编译器调用。启动例程从内核取得命令行参数和环境变量值,然后为按上述方式调用main函数做好安排。</p>
<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>有8种方法使得进程终止(termination)，其中5种为正常终止：</p>
<ol>
<li>从main返回</li>
<li>调用exit</li>
<li>调用_exit或_Exit</li>
<li>最后一个线程从其启动例程返回</li>
<li>从最后一个线程调用 pthread_exit</li>
</ol>
<p>异常终止有3种方式,它们是:</p>
<ol>
<li>调用 abort</li>
<li>接到一个信号</li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<blockquote>
<p>退出函数</p>
</blockquote>
<p>3个函数用于正常终止一个程序:_exit和_Exit立即进入内核,exit则先执行一些清理处理,然后返回内核。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>; </div><div class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</div></pre></td></tr></table></figure>
<p><code>exit</code>函数总是执行一个标准I/O库的清理关闭操作:对于所有打开流调用fc1ose函数。这造成输出缓冲中的所有数据都被冲洗(写到文件上)</p>
<p>3个退出函数都带一个整型参数,称为终止状态(或退出状态, exit status)。大多数UNIX系统 shell都提供检查进程终止状态的方法。</p>
<blockquote>
<p>函数atexit</p>
</blockquote>
<p>按照ISO C的规定,一个进程可以登记多至32个函数,这些函数将由exit自动调用。我们称这些函数为终止处理程序( exit handler),并调用 atexit函数来登记这些函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">int atexit(void (*func)(void));</div><div class="line"></div><div class="line">// Returns: 0 if OK, nonzero on error</div></pre></td></tr></table></figure>
<p>其中, <code>atexit</code>的参数是一个函数地址,当调用此函数时无需向它传递任何参数,也不期望它返回一个值。exit调用这些函数的顺序与它们登记时候的顺序相反。同一函数如若登记多次也会被调用多次。</p>
<p>exit首先调用各终止程序，然后关闭（通过fclose）所有打开的流</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250569958373.jpg" alt=""></p>
<p>注意,<strong>内核使程序执行的唯一方法是调用一个exec函数。进程自愿终止的唯一方法是显式或隐式地(通过调用exit)调用exit或Exit</strong>。进程也可非自愿地由一个信号使其终止</p>
<p>atexit函数有点像析构函数的意思</p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>当执行一个程序时,调用exec的进程可将命令行参数传递给该新程序。</p>
<p>ISO C和POSIX.1都要求argv[argc]是一个空指针。这就使我们可以将参数处理循环改写为</p>
<p><code>for(i = 0; argv[i] != NULL; i++)</code></p>
<h2 id="环境表"><a href="#环境表" class="headerlink" title="环境表"></a>环境表</h2><p>每个程序都接收到一张环境表。与参数表一样,<strong>环境表也是一个字符指针数组</strong>,其中每个指针包含一个以null结束的C字符串的地址。全局变量 environ则包含了该指针数组的地址</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250572321583.jpg" alt=""></p>
<h2 id="C程序的存储空间布局"><a href="#C程序的存储空间布局" class="headerlink" title="C程序的存储空间布局"></a>C程序的存储空间布局</h2><p>C程序一直由以下几个部分组成：</p>
<ul>
<li>正文段。这是由CPU执行的机器指令部分。通常,正文段是可共享的</li>
<li>初始化数据段。通常将此段称为数据段,它包含了程序中需明确地赋初值的变量</li>
<li>未初始化数据段。通常将此段称为bss段,这一名称来源于早期汇编程序一个操作符,意思是“由符号开始的块”( block started by symbol),在程序开始执行之前,<strong>内核将此段中的数据初始化为0或空指针</strong>。</li>
<li>栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。</li>
<li>堆。通常在堆中进行动态存储分配。</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-04-30-15250574049036.jpg" alt=""></p>
<p>栈顶和堆顶的虚拟地址空间很大。</p>
<p>未初始化数据段的内容并不存放在磁盘程序文件中。其原因是,内核在程序开始运行前将它们都设置为0。需要存放在磁盘程序文件中的段只有正文段和初始化数据段</p>
<h2 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h2><p>共享库使得<strong>可执行文件中不再需要包含公用的库函数</strong>,而只需在所有进程都可引用的存储区中保存这种库例程的一个副本。程序第一次执行或者第一次调用某个库函数时,<strong>用动态链接方法将程序与共享库函数相链接</strong>。这减少了每个可执行文件的长度,但增加了一些运行时间开销。这种时间开销发生在该程序第一次被执行时,或者每个共享库函数第一次被调用时。共享库的另一个优点是<strong>可以用库函数的新版本代替老版本而无需对使用该库的程序重新连接编辑</strong>(假定参数的数目和类型都没有发生改变)</p>
<h2 id="存储空间分配"><a href="#存储空间分配" class="headerlink" title="存储空间分配"></a>存储空间分配</h2><p>ISO C说明了3个用于存储空间动态分配的函数</p>
<ol>
<li>ma11oc,分配指定字节数的存储区。此存储区中的初始值不确定。</li>
<li>cal1oc,为指定数量指定长度的对象分配存储空间。该空间中的每一位(bit)都初始化为0</li>
<li>rea11oc,增加或减少以前分配区的长度。当增加长度时,可能需将以前分配区的内容移到另一个足够大的区域,以便在尾端提供增加的存储区,而新增区域内的初始值则不确定。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nobj, <span class="keyword">size_t</span> size)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> newsize)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All three return: non-null pointer if OK, NULL on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</div></pre></td></tr></table></figure>
<p>这3个分配函数所返回的指针一定是适当对齐的,使其可用于任何数据对象。</p>
<p>函数free释放ptr指向的存储空间。被释放的空间通常被送入可用存储区池,以后,可在用上述3个分配函数时再分配。</p>
<p>这些分配例程通常用sbrk(2)系统调用实现。该系统调用扩充(或缩小)进程的堆。</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境字符串的形式是 <code>name=value</code></p>
<p>UNIX内核并不查看这些字符串,它们的解释完全取决于各个应用程序。</p>
<p>可以使用getenv函数获得环境变量的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to value associated with name, NULL if not found</span></div></pre></td></tr></table></figure>
<p>此函数返回一个指针,它指向<code>name=value</code>字符串中的 value。</p>
<p>设置环境变量的三个函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, nonzero on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> rewrite)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>用法：</p>
<ul>
<li>putenv取形式为<code>name=value</code>的字符串,将其放到环境表中。如果name已经存在,则先删除其原来的定义。</li>
<li>setenv将name设置为value。</li>
<li>unsetenv删除name的定义</li>
</ul>
<p>环境表(指向实际<code>name=value</code>字符串的指针数组)和环境字符串通常存放在进程存储空间的顶部(栈之上)。删除一个字符串很简单——只要先在环境表中找到该指针,然后将所有后续指针都向环境表首部顺次移动一个位置。但是增加一个字符串或修改一个现有的字符串就困难得多。环境表和环境字符串通常占用的是进程地址空间的顶部,所以它不能再向高地址方向(向上)扩展:同时也不能移动在它之下的各栈帧,所以它也不能向低地址方向(向下)扩展。两者组合使得该空间的长度不能再增加。</p>
<h2 id="函数setjmp和longjmp"><a href="#函数setjmp和longjmp" class="headerlink" title="函数setjmp和longjmp"></a>函数setjmp和longjmp</h2><p>在C中,goto语句是不能跨越函数的,而执行这种类型跳转功能的是函数 setjmp和1ongjmp两个函数对于处理发生在很深层嵌套函数调用中的出错情况是非常有用的</p>
<p>setjmp和1ongjmp函数可以看成一个非局部goto函数。非局部指的是这不是由普通的C语言goto语句在一个函数内实施的跳转,而是在栈上跳过若于调用帧,返回到当前函数调用路径上的某一个函数中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if called directly, nonzero if returning from a call to longjmp</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="函数getrlimit和setrlimit"><a href="#函数getrlimit和setrlimit" class="headerlink" title="函数getrlimit和setrlimit"></a>函数getrlimit和setrlimit</h2><p>每个进程都有一组资源限制,其中一些可以用getrlimit和 setrlimit函数查询和更改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">struct</span> rlimit *rlptr)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> <span class="keyword">struct</span> rlimit *rlptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[APUE 系统数据文件和信息]]></title>
      <url>/2018/04/28/APUE-%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E4%BF%A1%E6%81%AF/</url>
      <content type="html"><![CDATA[<p>《UNIX环境高级编程》第6章 系统数据文件和信息 笔记</p>
<a id="more"></a>
<h2 id="口令文件"><a href="#口令文件" class="headerlink" title="口令文件"></a>口令文件</h2><p>UNX系统口令文件(POSX1则将其称为用户数据库)包含了如下图所示的各字段,这些字段包含在<pwd.h>中定义的 passwd结构中。</pwd.h></p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250520434469.jpg" alt=""></p>
<p>由于历史原因,口令文件是<code>/etc/passwd</code>,而且是一个ASCII文件。字段之间用冒号分隔。</p>
<p>关于这些信息有以下这些注意事项：</p>
<ul>
<li>通常有一个用户名为root的登录项,其用户ID是0(超级用户）</li>
<li>加密口令包含一个字段，现在出于安全的考虑把加密口令存放在另一个文件中</li>
<li>口令文件项中的某些字段可能是空。如果加密口令字段为空,这通常就意味着该用户没有口令(不推荐这样做)。 </li>
<li>shel字段包含了一个可执行程序名,它被用作该用户的登录 shell.若该字段为空,则取系统默认值,通常是<code>/bin/sh</code>。</li>
<li>为了阻止一个特定用户登录系统,除使用/dev/nu11外,还有若干种替代方法。</li>
</ul>
<p>有两个获取口令文件项的函数。在给出用户登录名或数值用户ID后,这两个函数就能查看相关项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> passwd *<span class="title">getpwuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> passwd *<span class="title">getpwnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
<p>如果想要查看整个口令文件，下面3个函数可以用于此目的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> passwd *<span class="title">getpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer if OK, NULL on error or end of ﬁle</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">endpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>调用<code>getpwent</code>时,它返回口令文件中的下一个记录项。函数<code>setpwent</code>反绕它所使用的文件（倒回到所有口令文件的开始）, <code>endpwent</code>则关闭这些文件</p>
<h2 id="阴影口令"><a href="#阴影口令" class="headerlink" title="阴影口令"></a>阴影口令</h2><p>加密口令是经单向加密算法处理过的用户口令副本。因为此算法是单向的,所以不能从加密口令猜测到原来的口令。</p>
<p>现在,某些系统将加密口令存放在另个通常称为阴影口令( shadow password)的文件中。该文件至少要包含用户名和加密囗令。</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250527613967.jpg" alt=""></p>
<p>阴影口令文件不应是一般用户可以读取的。仅有少数几个程序需要访问加密口令,如1ogin(1)和 passwd(1),这些程序常常是设置用户ID为root的程序。</p>
<h2 id="组文件"><a href="#组文件" class="headerlink" title="组文件"></a>组文件</h2><p>UNIX组文件中包含如下的字段，这些字段在<grp.h>所定义的group的数据结构中</grp.h></p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250528423155.jpg" alt=""></p>
<p>查看组名或数值组ID：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> group *<span class="title">getgrgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>; </div><div class="line"><span class="function"><span class="keyword">struct</span> group *<span class="title">getgrnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
<p>和用户信息一样查看所有组文件函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> group *<span class="title">getgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>; </div><div class="line"><span class="comment">// Returns: pointer if OK, NULL on error or end of ﬁle</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">endgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="附属组ID"><a href="#附属组ID" class="headerlink" title="附属组ID"></a>附属组ID</h2><p>我们不仅可以属于口令文件记录项中组ID所对应的组,也可属于多至16个另外的组。文件访问权限检查相应被修改为:不仅将进程的有效组ID与文件的组ID相比较,而且也将所有附属组ID与文件的组ID进行比较</p>
<p>使用附属组ID的优点是不必再显式地经常更改组。一个用户会参与多个项目,因此也就要同时属于多个组,此类情况是常有的。</p>
<p>以下3个函数用于获取和设置附属组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getgroups</span><span class="params">(<span class="keyword">int</span> gidsetsize, <span class="keyword">gid_t</span> grouplist[])</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: number of supplementary group IDs if OK, −1 on error</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt; /* on Linux */ </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; /* on FreeBSD, Mac OS X, and Solaris */ </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgroups</span><span class="params">(<span class="keyword">int</span> ngroups, <span class="keyword">const</span> <span class="keyword">gid_t</span> grouplist[])</span></span>; </div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt; /* on Linux and Solaris */ </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; /* on FreeBSD and Mac OS X */ </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">initgroups</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *username, <span class="keyword">gid_t</span> basegid)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p><code>getgroups</code>将进程所属用户的各附属组ID填写到数组<code>grouplist</code>中,填写入该数组的附属组ID数最多为 <code>gidsetsize</code>个。实际填写到数组中的附属组ID数由函数返回。</p>
<p><code>setgroups</code>可由超级用户调用以便为调用进程设置附属组ID表。<code>grouplist</code>是组ID数组,而 <code>ngroups</code>说明了数组中的元素数。 <code>ngroups</code>的值不能大于 NGROUPS_MAX.</p>
<h2 id="登录账户记录"><a href="#登录账户记录" class="headerlink" title="登录账户记录"></a>登录账户记录</h2><p>大多数UNIX系统都提供下列两个数据文件:utmp文件记录当前登录到系统的各个用户;wtmp文件跟踪各个登录和注销事件。</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250533552178.jpg" alt=""></p>
<h2 id="系统标识"><a href="#系统标识" class="headerlink" title="系统标识"></a>系统标识</h2><p>有一个uname函数,它返回与主机和操作系统有关的信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/utsname.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">uname</span><span class="params">(<span class="keyword">struct</span> utsname *name)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: non-negative value if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="时间和日期例程"><a href="#时间和日期例程" class="headerlink" title="时间和日期例程"></a>时间和日期例程</h2><p>由UNIX内核提供的基本时间服务是计算自协调世界时公元1970年1月1日00：00：00这一特定时间以来经过的秒数。</p>
<p>用数据结构<code>time_t</code>表示，据类型 time_t表示的,我们称它们为日历时间。日历时间包括时间和日期。UNIX在这方面与其他操作系统的区别是:(a)以协调统一时间而非本地时间计时;(b)可自动进行转换,如变换到夏令时;(c)将时间和日期作为一个量值保存。</p>
<p><code>time</code>函数返回当前时间和日期</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">time_t</span> time(<span class="keyword">time_t</span> *calptr);</div><div class="line"></div><div class="line"><span class="comment">// Returns: value of time if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>时间值作为函数值返回。如果参数非空,则时间值也存放在由calptr指向的单元内</p>
<p>关于日期和时间，有许多相关的函数，以下列出其中一些函数的关系：</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250538112744.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[APUE 标准I/O库]]></title>
      <url>/2018/04/27/APUE-%E6%A0%87%E5%87%86I-O%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>《UNIX环境高级编程》第5章 标准I/O库 笔记</p>
<a id="more"></a>
<h2 id="流和FILE对象"><a href="#流和FILE对象" class="headerlink" title="流和FILE对象"></a>流和FILE对象</h2><p>之前所描述的所有I/O函数都是围绕文件描述符的。当打开一个文件时,即返回一个文件描述符,然后该文件描述符就用于后续的I/O操作。而对于标准I/O库,它们的操作是围绕流(stream)进行。当标准I/O库打开或者创建一个文件时，我们已使一个流与一个文件相关联</p>
<p>对于ASCI字符集,一个字符用一个字节表示。对于国际字符集,一个字符可用多个字节表示。标准IO文件流可用于单字节或多字节(“宽”)字符集。流的定向( stream’s orientation)决定了所读、写的字符是单字节还是多字节的。fwide函数用于设置流的定向</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE *fp, <span class="keyword">int</span> mode)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: positive if stream is wide oriented, negative if stream is byte oriented, or 0 if stream has no orientation</span></div></pre></td></tr></table></figure>
<p><code>mode</code>参数设置为负时为字节定向、为正时为宽定向、为0时不设置流的定向、但是返回该流定向的值</p>
<p>当打开一个流时,标准IO函数 fopen返回一个指向FILE对象的指针。为了引用一个流，需将FILE指针作为参数传给每个标准I/O函数。</p>
<h2 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h2><p>对一个进程预定义了3个流,并且这3个流可以自动地被进程使用,它们是:标准输入、标准输出和标准错误。这些流引用的文件与文件描述符 STDIN_FILENO、 STDOUT_FILENO和STDERR_FILENO所引用的相同。</p>
<h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>标准I/O库提供缓冲的目的是尽可能减少使用read和write调用的次数。标准I/O库最令人迷人的也是其缓冲：</p>
<p>标准I/O提供了以下3种类型的缓冲：</p>
<ol>
<li>全缓冲。在这种情况下,在填满标准I/O缓冲区后才进行实际I/O操作。</li>
</ol>
<p>术语冲洗(flush)说明标准I/O缓冲区的写操作。缓冲区可由标准I/O例程自动地冲洗,或者可以调用函数ff1ush冲洗一个流。</p>
<ol>
<li>行缓冲，在这种情况下,当在输入和输出中遇到换行符时,标准I/O库执行I/O操作。当流涉及一个终端时(如标准输入和标准输出),通常使用行缓冲。</li>
</ol>
<p>对于行缓冲有两个限制。第一,因为标准/O库用来收集每一行的缓冲区的长度是固定的,所以只要填满了缓冲区,那么即使还没有写一个换行符,也进行O操作。第二,任何时候只要通过标准I/O库要求从(a)一个不带缓冲的流,或者(b)一个行缓冲的流(它从内核请求需要数据)得到输入数据,那么就会冲洗所有行缓冲输出流。</p>
<ol>
<li>不带缓冲。标准I/O库不对字符进行缓冲存储。</li>
</ol>
<p>对任何一个给定的流,如果我们并不喜欢这些系统默认,则可调用下列两个函数中的一个更改缓冲类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf )</span></span>;   <span class="comment">// 打开或者关闭缓冲机制</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, nonzero on error</span></div></pre></td></tr></table></figure>
<p>使用setvbuf，我们可以精确说明所需的缓冲类型。这是用<code>mode</code>参数实现的：_IOFBF 全缓冲  _IOLBF  行缓冲  _IONBF  不带缓冲</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247582189497.jpg" alt=""></p>
<p>任何时候，我们可以强制冲洗一个流：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, EOF on error</span></div></pre></td></tr></table></figure></p>
<h2 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h2><p>下列3个函数打开一个标准I/O流</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>; </div><div class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type, FILE *<span class="keyword">restrict</span> fp)</span></span>; </div><div class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All three return: ﬁle pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
<p>3个函数的区别如下：</p>
<ol>
<li>fopen函数打开路径名为pathname的一个指定的文件。</li>
<li>freopen函数在一个指定的流上打开一个指定的文件,如若该流已经打开,则先关闭该流。若该流已经定向,则使用 freopen清除该定向。此函数一般用于将一个指定的文件打开为一个预定义的流:标准输入、标准输出或标准错误。</li>
<li>fopen函数取一个已有的文件描述符，并使一个标准的I/O流与改描述符相结合</li>
</ol>
<p><code>type</code>参数指定对该流的读写方式</p>
<p><img src="https://data2.liuin.cn/2018-04-29-15249858189861.jpg" alt=""></p>
<p>使用字符b作为type的部分,这使得标准I/O系统可以区分文本文件和二进制文件。因为UNIX内核并不对这两种文件进行区分,所以在UNIX系统环境下指定字符b作为type的部分实际上并无作用。</p>
<p>调用<code>fclose</code>关闭一个打开的流：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, EOF on error</span></div></pre></td></tr></table></figure>
<h2 id="读和写流"><a href="#读和写流" class="headerlink" title="读和写流"></a>读和写流</h2><p>一旦打开了流,则可在3种不同类型的非格式化I/O中进行选择,对其进行读、写操作：</p>
<ol>
<li>每次一个字符I/O</li>
<li>每次一行I/O</li>
<li>直接I/O</li>
</ol>
<blockquote>
<p>输入函数</p>
</blockquote>
<p>以下3个函数可以用于一次读一个字符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All three return: next character if OK, EOF on end of ﬁle or error</span></div></pre></td></tr></table></figure>
<p>函数getchar等同于getc(stdin)。前两个函数的区别是，getc可以被实现为宏，而fgetc不能被实现为宏</p>
<p>注意,不管是出错还是到达文件尾端,这3个函数都返回同样的值。为了区分这两种不同的情况,必须调用 ferror或feof。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: nonzero (true) if condition is true, 0 (false) otherwise </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *fp)</span></span>;</div></pre></td></tr></table></figure>
<p>大多数情况下，每一个流的FILE对象中都维护了两个标志：出错标志和文件结束标志。调用clearerr可以清楚这些标志。</p>
<p>从流中读取数据以后,可以调用 ungetc将字符再压送回流中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: c if OK, EOF on error</span></div></pre></td></tr></table></figure>
<blockquote>
<p>输出函数</p>
</blockquote>
<p>对应于上面每一个输入函数都有一个输出函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All three return: c if OK, EOF on error</span></div></pre></td></tr></table></figure>
<h2 id="每一行-I-O"><a href="#每一行-I-O" class="headerlink" title="每一行 I/O"></a>每一行 I/O</h2><p>以下两个函数提供每次输入一行的功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> n, FILE *<span class="keyword">restrict</span> fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *buf )</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: buf if OK, NULL on end of ﬁle or error</span></div></pre></td></tr></table></figure>
<p>这两个函数都指定了缓冲区的地址,读入的行将送入其中。gets从标准输入读,而fgets从指定的流读</p>
<p>对于 fgets,必须指定缓冲的长度n。此函数一直读到下一个换行符为止,但是不超过n个字符,读入的字符被送入缓冲区。</p>
<p>gets是一个不推荐使用的函数。其问题是调用者在使用qets时不能指定缓冲区的长度。这样就可能造成缓冲区溢出(如若该行长于缓冲区长度),写到缓冲区之后的存储空间中,从而产生不可预料的后果。这种缺陷可以被利用制作蠕虫病毒。</p>
<p>fputs和puts提供每次输出一行的功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> str, FILE *<span class="keyword">restrict</span> fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: non-negative value if OK, EOF on error</span></div></pre></td></tr></table></figure>
<p>函数 fputs将一个以nul字节终止的字符串写到指定的流,尾端的终止符nu不写出。</p>
<h2 id="二进制I-O"><a href="#二进制I-O" class="headerlink" title="二进制I/O"></a>二进制I/O</h2><p>之前提到的I/O函数函数以一次一个字符或一次一行的方式进行操作。如果进行二进制I/O操作,那么我们更愿意一次读或写一个完整的结构。</p>
<p>有下面两个函数提供二进制的I/O操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp);</div><div class="line"></div><div class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp);</div><div class="line"></div><div class="line"><span class="comment">// Both return: number of objects read or written</span></div></pre></td></tr></table></figure>
<p>这些函数有两个用法：</p>
<ol>
<li>读写二进制数组</li>
<li>读写自定义的一个结构体</li>
</ol>
<p>其中参数<code>nobj</code>表示要读写的对象的个数</p>
<p>使用二进制I/O的基本问题是,它只能用于读在同一系统上已写的数据。这样就导致了一个问题：在一个系统写的数据要在另一个系统上进行处理。在这种环境下,这两个函数可能就不能正常工作,其原因是:</p>
<ol>
<li>在一个结构中,同一成员的偏移量可能随编译程序和系统的不同而不同(由于不同的对齐要求)。</li>
<li>用来存储多字节整数和浮点值的二进制格式在不同的系统结构间也可能不同</li>
</ol>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>在UNIX中,标准I/O库最终都要调用I/O例程来实现（read、write）。每个标准I/O流都有一个与其相关联的文件描述符,可以对一个流调用<code>fi1eno</code>函数以获得其描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: the ﬁle descriptor associated with the stream</span></div></pre></td></tr></table></figure>
<h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><p>标准I/O库提供两个函数来创建临时文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to unique pathname</span></div><div class="line"></div><div class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: ﬁle pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
<p>tmpnam函数产生一个与现有文件名不同的一个有效路径名字符串。每次调用它时,都产生个不同的路径名,最多调用次数是 TMP_MAX</p>
<p>若ptr是NULL,则所产生的路径名存放在一个静态区中,指向该静态区的指针作为函数值返回。</p>
<p>tmpfile创建一个临时二进制文件(类型wb+),在关闭该文件或程序结束时将自动删除这种文件</p>
<p>tmpfi1e函数经常使用的标准UNIX技术是先调用 tmpnam产生一个唯一的路径名,然后用该路径名创建一个文件,并立即un1ink它。</p>
<h2 id="内存流"><a href="#内存流" class="headerlink" title="内存流"></a>内存流</h2><p>标准I/O库把数据缓存在内存中,因此每次一字符和每次一行的I/O更有效。我们也可以通过调用 setbuf或 setvbuf函数让IO库使用我们自己的缓冲区。</p>
<p>有3个函数可以用于内存流的创建，第一个函数是fmemopen函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function">FILE *<span class="title">fmemopen</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: stream pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[APUE 文件和目录]]></title>
      <url>/2018/04/26/APUE-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>《UNIX环境高级编程》第4章 文件和目录 笔记</p>
<a id="more"></a>
<h2 id="函数stat、fstat、fstatat和lstat"><a href="#函数stat、fstat、fstatat和lstat" class="headerlink" title="函数stat、fstat、fstatat和lstat"></a>函数stat、fstat、fstatat和lstat</h2><p>返回文件信息的主要有4个函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">struct</span> stat *buf )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname,<span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All four return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>一旦给出pathname：</p>
<ul>
<li>stat将返回与此命名文件有关的信息结构：</li>
<li>fstat函数获得已在描述符fd上打开文件的有关信息</li>
<li>1stat函数类似于stat,但是当命名的文件是一个符号链接时,1stat返回该符号链接的有关信息,而不是由该符号链接引用的文件的信息。</li>
<li>fstatat函数为一个相对于当前打开目录(由fd参数指向)的路径名返回文件统计信息。</li>
</ul>
<p>第二个参数buf是一个指针，其指向一个我们必须提供的结构。函数来填充由buf指向的结构。其基本格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> stat &#123; </div><div class="line">    <span class="keyword">mode_t</span> st_mode; <span class="comment">/* file type &amp; mode (permissions) */</span> </div><div class="line">    <span class="keyword">ino_t</span> st_ino; <span class="comment">/* i-node number (serial number) */</span> </div><div class="line">    <span class="keyword">dev_t</span> st_dev; <span class="comment">/* device number (file system) */</span> </div><div class="line">    <span class="keyword">dev_t</span> st_rdev; <span class="comment">/* device number for special files */</span> </div><div class="line">    <span class="keyword">nlink_t</span> st_nlink; <span class="comment">/* number of links */</span> </div><div class="line">    <span class="keyword">uid_t</span> st_uid; <span class="comment">/* user ID of owner */</span> </div><div class="line">    <span class="keyword">gid_t</span> st_gid; <span class="comment">/* group ID of owner */</span> </div><div class="line">    <span class="keyword">off_t</span> st_size; <span class="comment">/* size in bytes, for regular files */</span> </div><div class="line">    <span class="keyword">struct</span> timespec st_atim; <span class="comment">/* time of last access */</span> </div><div class="line">    <span class="keyword">struct</span> timespec st_mtim; <span class="comment">/* time of last modification */</span> </div><div class="line">    <span class="keyword">struct</span> timespec st_ctim; <span class="comment">/* time of last file status change */</span> </div><div class="line">    <span class="keyword">blksize_t</span> st_blksize; <span class="comment">/* best I/O block size */</span> </div><div class="line">    <span class="keyword">blkcnt_t</span> st_blocks; <span class="comment">/* number of disk blocks allocated */</span> </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>UNIX系统的大多数文件是普通文件或目录,但是也有另外一些文件类型。文件类型包括如下几种：</p>
<ol>
<li>普通文件（regular file）文本文件或者二进制文件</li>
<li>目录文件（directory file），对一个目录文件具有读权限的任一进程都可以读该目录的内容,但只有内核可以直接写目录文件。</li>
<li>块特殊文件（block special file），这种类型的文件提供对设备(如磁盘)带缓冲的访问,</li>
<li>字符特殊文件(character special file)。这种类型的文件提供对设备不带缓冲的访问</li>
<li>FIFO，用于进程间通信的命名管道</li>
<li>套接字（socket），用于网络间进程通信</li>
<li>符号链接（symbol link），这种类型的文件指向另一个文件</li>
</ol>
<p>文件类型信息包含在stat结构的 st_mode成员中。也可以使用自带的宏确定的文件类型</p>
<h2 id="设置用户ID和设置组ID"><a href="#设置用户ID和设置组ID" class="headerlink" title="设置用户ID和设置组ID"></a>设置用户ID和设置组ID</h2><p>和一个进程相关联的ID有6个：</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247249639065.jpg" alt=""></p>
<ul>
<li>实际用户ID和实际组ID标识我们究竟是谁。这两个字段在登录时取自口令文件中的登录项。通常,在一个登录会话期间这些值并不改变,但是超级用户进程有办法改变</li>
<li>有效用户ID、有效组IDD以及附属组ID决定了我们的文件访问权限</li>
<li>保存的设置用户ID和保存的设置组ID在执行一个程序时包含了有效用户ID和有效组ID的副本</li>
</ul>
<p>通常,有效用户ID等于实际用户ID,有效组ID等于实际组ID</p>
<p>每个文件有一个所有者和组所有者,所有者由stat结构中的<code>st_uid</code>指定,组所有者则由<code>st_gid</code>指定</p>
<h2 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a>文件访问权限</h2><p>st_mode值也包含了对文件的访问权限位。当提及文件时,指的是前面所提到的任何类型的文件。所有文件类型(目录、字符特别文件等)都有访问权限( access permission)。</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247252761376.jpg" alt=""></p>
<p>3类访问权限的使用方式如下：</p>
<ul>
<li>我们用名字打开任一类型的文件时,对该名字中包含的每一个目录,包括它可能隐含的当前工作目录都应具有执行权限。这就是为什么对于目录其执行权限位常被称为搜索位的原因</li>
<li>对于一个文件的读权限决定了我们是否能够打开现有文件进行读操作</li>
<li>对于一个文件的写权限决定了我们是否能够打开现有文件进行写操作</li>
<li>为了在open函数中对一个文件指定O_TRUNC标志,必须对该文件具有写权限</li>
<li>为了在一个目录中创建一个新文件,必须对该目录具有写权限和执行权限</li>
<li>为了删除一个现有文件,必须对包含该文件的目录具有写权限和执行权限。</li>
</ul>
<p>进程每次打开、创建或者删除一个文件的时候，内核就对文件进行访问权限测试。</p>
<p>内核测试的具体内容：</p>
<ol>
<li>若进程的有效用户ID是0(超级用户),则允许访问。这给予了超级用户对整个文件系统进行处理的最充分的自由</li>
<li>若进程的有效用户ID等于文件的所有者ID(也就是进程拥有此文件),那么如果所有者适当的访问权限位被设置,则允许访问;否则拒绝访问。</li>
<li>若进程的有效组ID或进程的附属组ID之一等于文件的组ID,那么如果组适当的访问权限位被设置,则允许访问;否则拒绝访问。</li>
<li>若其他用户适当的访问权限位被设置,则允许访问;否则拒绝访问</li>
</ol>
<h2 id="新文件和目录的所有权"><a href="#新文件和目录的所有权" class="headerlink" title="新文件和目录的所有权"></a>新文件和目录的所有权</h2><p>新文件的用户ID设置为进程的有效用户ID。</p>
<p>关于组ID，POSIX实现有两种方案：</p>
<ul>
<li>进程有效组ID</li>
<li>所在目录的组ID</li>
</ul>
<h2 id="函数access和faccessat"><a href="#函数access和faccessat" class="headerlink" title="函数access和faccessat"></a>函数access和faccessat</h2><p>正如前面所说,当用open函数打开一个文件时,内核以进程的有效用户ID和有效组ID为基础执行其访问权限测试。有时,进程也希望按其实际用户ID和实际组ID来测试其访问能力。</p>
<p><code>access</code>和 <code>faccessat</code>函数是按实际用户ID和实际组ID进行访问权限测试的。(该测试也分成4步）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccessat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p><code>flag</code>参数可以用于改变<code>faccessat</code>的行为,如果<code>fag</code>设置为<code>AT_EACCESS</code>,访问检查用的是调用进程的有效用户ID和有效组D,而不是实际用户ID和实际组ID</p>
<h2 id="函数umask"><a href="#函数umask" class="headerlink" title="函数umask"></a>函数umask</h2><p><code>umask</code>函数为进程设置文件模式创建屏蔽字,并返回之前的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">mode_t</span> umask(<span class="keyword">mode_t</span> cmask);</div><div class="line"></div><div class="line"><span class="comment">// Returns: previous ﬁle mode creation mask</span></div></pre></td></tr></table></figure>
<p><code>cmask</code>是9个权限访问为常量（S_IRUSR、S_IWUSR）的若干个或组成的</p>
<p>在进程创建一个新文件或新目录时,就一定会使用文件模式创建屏蔽字</p>
<p>UNX系统的大多数用户从不处理他们的 umask值。通常在登录时,由 shell的启动文件设置一次,然后,再不改变。</p>
<p>用户可以设置 umask值以控制他们所创建文件的默认权限。该值表示成八进制数,一位代表一种要屏蔽的权限,这示于图4-10中。设置了相应位后,它所对应的权限就会被拒绝常用的几种 umask值是002、022和027。002阻止其他用户写入你的文件,022阻止同组成员和其他用户写入你的文件,027阻止同组成员写你的文件以及其他用户读、写或执行你的文件。</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247265122569.jpg" alt=""></p>
<h2 id="函数chmod、fchmod和fchmodat"><a href="#函数chmod、fchmod和fchmodat" class="headerlink" title="函数chmod、fchmod和fchmodat"></a>函数chmod、fchmod和fchmodat</h2><p>chmod、fchmod和fchmodat这3个函数使我们可以更改现有文件的访问权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmodat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All three return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>chmod函数在指定的文件上进行操作,而fchmod函数则对已打开的文件进行操作。fchmodat函数与chmod函数在下面两种情况下是相同的:一种是 pathname参数为绝对路径另一种是/参数取值为 AT_FDCWD而 pathname参数为相对路径。</p>
<p>为了改变一个文件的权限位,进程的有效用户ID必须等于文件的所有者ID,或者该进程必须具有超级用户权限。</p>
<h2 id="粘着位"><a href="#粘着位" class="headerlink" title="粘着位"></a>粘着位</h2><p>在UNIX尚未使用请求分页式技术的早期版本中, S_ISVTX位被称为粘着位( sticky bit)。如果一个可执行程序文件的这一位被设置了,那么当该程序第一次被执行,在其终止时,程序正文部分的一个副本仍被保存在交换区(程序的正文部分是机器指令)。这使得下次执行该程序时能较快地将其装载入内存。</p>
<p>后来的UNIX版本称它为保存正文位( saved-text bit),因此也就有了常量S_ISVTX。现今较新的UNX系统大多数都配置了虚拟存储系统以及快速文件系统,所以不再需要使用这种技术</p>
<p>现在粘着位的使用方法是：<br>如果对一个目录设置了粘着位,只有对该目录具有写权限的用户并且满足下列条件之一,才能删除或重命名该目录下的文件</p>
<ul>
<li>拥有此文件</li>
<li>拥有此目录</li>
<li>是超级用户</li>
</ul>
<h2 id="函数chown、fchown、fchownat和lchown"><a href="#函数chown、fchown、fchownat和lchown" class="headerlink" title="函数chown、fchown、fchownat和lchown"></a>函数chown、fchown、fchownat和lchown</h2><p>下面几个chown函数可用于更改文件的用户ID和组ID。如果两个参数 owner或 group中的任意一个是-1,则对应的ID不变</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchownat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>; All four <span class="keyword">return</span>: </div><div class="line"></div><div class="line"><span class="comment">// 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>基于BSD的系统一直规定只有超级用户才能更改一个文件的所有者这样做的原因是防止用户改变其文件的所有者从而摆脱磁盘空间限额对他们的限制。 System V则允许任一用户更改他们所拥有的文件的所有者。</p>
<h2 id="文件长度"><a href="#文件长度" class="headerlink" title="文件长度"></a>文件长度</h2><p><code>stat</code>结构成员<code>st_size</code>表示以字节为单位的文件的长度。此字段只对普通文件、目录文件和符号链接有意义。</p>
<p>对于普通文件,其文件长度可以是0；对于目录,文件长度通常是一个数(如16或512)的整倍数；对于符号链接,文件长度是在文件名中的实际字节数。</p>
<p>现今,大多数现代的UNIⅨ系统提供字段stb1ks1ze和st_b1ocks。其中,第一个是对文件I/O较合适的块长度,第二个是所分配的实际512字节块块数。</p>
<blockquote>
<p>文件空洞</p>
</blockquote>
<p>空洞是由所设置的文件偏移量超过文件尾端，并写入了某些数据造成的。</p>
<h2 id="文件截断"><a href="#文件截断" class="headerlink" title="文件截断"></a>文件截断</h2><p>有时我们需要在文件尾端处截去一些数据以缩短文件。将一个文件的长度截断为0是一个特例,在打开文件时使用 O_TRUNC标志可以做到这一点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">off_t</span> length)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>这两个函数将一个现有文件长度截断为 length。如果该文件以前的长度大于 length,则超过length以外的数据就不再能访问。如果以前的长度小于 length,文件长度将增加,在以前的文件尾端和新的文件尾端之间的数据将读作0(也就是可能在文件中创建了一个空洞)</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>目前,正在使用的UNIX文件系统有多种实现。例如, Solaris支持多种不同类型的磁盘文件系统:传统的基于BSD的UNIX文件系统(称为UFS),读、写DOS格式软盘的文件系统(称为PCFS),以及读CD的文件系统(称为HSFS)。</p>
<p>我们可以把一个磁盘分成一个或多个分区。每个分区可以包含一个文件系统，i节点是固定长度的记录项,它包含有关文件的大部分信息。</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247278022212.jpg" alt=""></p>
<p>更仔细地观察一个柱面组的i节点和数据块部分：</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247278729393.jpg" alt=""></p>
<p>在图中有两个目录项指向同一个i节点。每个i节点中都有一个链接计数,其值是指向该i节点的目录项数。只有当链接计数减少至0时,才可删除该文件(也就是可以释放该文件占用的数据块)。这就是为什么“解除对一个文件的链接”操作并不总是意味着“释放该文件占用的磁盘块”的原因。这也是为什么删除一个目录项的函数被称之为<code>un1ink</code></p>
<p>另外一种链接类型称为符号链接( symbolic link)。符号链接文件的实际内容(在数据块中)包含了该符号链接所指向的文件的名字。</p>
<p>节点包含了文件有关的所有信息:文件类型、文件访问权限位、文件长度和指向文件数据块的指针等。stat结构中的大多数信息都取自i节点。只有两项重要数据存放在目录项中:文件名和节点编号。</p>
<p>因为目录项中的i节点编号指向同一文件系统中的相应i节点,<strong>一个目录项不能指向另个文件系统的i节点</strong>。这就是为什么1n(1)命令不能跨越文件系统的原因</p>
<p>当在不更换文件系统的情况下为一个文件重命名时,该文件的实际内容并未移动,只需构造一个指向现有i节点的新目录项,并删除老的目录项。链接计数不会改变。</p>
<p>我们说明了普通文件链接计数的概念，对于目录的链接计数相关方法如下：</p>
<p>任何一个叶目录(不包含任何其他目录的目录)的链接计数总是2,数值2来自于命名该目录( testdir)的目录项以及在该目录中的.项。在父目录中的每一个子目录都使该父目录的链接计数增加1</p>
<h2 id="函数link、linkat、unlink、unlinkat和remove"><a href="#函数link、linkat、unlink、unlinkat和remove" class="headerlink" title="函数link、linkat、unlink、unlinkat和remove"></a>函数link、linkat、unlink、unlinkat和remove</h2><p>创建一个指向现有文件的链接的方法是使用linke或者linkat函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">linkat</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">int</span> nfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>这两个函数创建一个新目录项<code>newpath</code>,它引用现有文件 <code>existingpath</code></p>
<p>为了删除一个现有的目录项、可以调用unlink函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlinkat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>这两个函数删除目录项,并将由pathname所引用文件的链接计数减1。如果对该文件还有其他链接,则仍可通过其他链接访问该文件的数据。如果出错,则不对该文件做任何更改。</p>
<p>我们在前面已经提及,为了解除对文件的链接,必须对包含该目录项的目录具有写和执行权限。如果对该目录设置了粘着位,则对该目录必须具有写权限,并且具备下面三个条件之一:拥有该文件、拥有该目录或者具有超级用户权限</p>
<p>只有当链接计数达到0时,该文件的内容才可被删除。另一个条件也会阻止删除文件的内容——<strong>只要有进程打开了该文件,其内容也不能删除</strong>。关闭一个文件时,内核首先检查打开该文件的进程个数;如果这个计数达到0,内核再去检查其链接计数;如果计数也是0,那么就删除该文件的内容。</p>
<p>ulink的这种特性经常被程序用来确保即使是在程序崩溃时,它所创建的临时文件也不会遗留下来。进程用open或 creat创建一个文件,然后立即调用 unlink,因为该文件仍旧是打开的,所以不会将其内容删除。只有当进程关闭该文件或终止时，该文件的内容才被删除。</p>
<p>我们也可以用<code>remove</code>函数解除对一个文件或目录的链接。对于文件,<code>remove</code>的功能与<code>unlink</code>相同。对于目录,<code>remove</code>的功能与<code>rmdir</code>相同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="函数rename和renameat"><a href="#函数rename和renameat" class="headerlink" title="函数rename和renameat"></a>函数rename和renameat</h2><p>文件或目录可以用 rename函数或者 renameat函数进行重命名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">renameat</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">int</span> newfd,<span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2><p>符号链接是对一个文件的间接指针,它与上一节所述的硬链接有所不同,硬链接直接指向文件的i节点。引入符号链接的原因是为了避开硬链接的一些限制：</p>
<ul>
<li>硬链接通常要求链接和文件位于同一文件系统中。</li>
<li>只有超级用户才能创建指向目录的硬链接(在底层文件系统支持的情况下)。</li>
</ul>
<p>对符号链接以及它指向何种对象并无任何文件系统限制,任何用户都可以创建指向目录的符号链接。符号链接一般用于将一个文件或整个目录结构移到系统中另一个位置</p>
<h2 id="创建和读取符号链接"><a href="#创建和读取符号链接" class="headerlink" title="创建和读取符号链接"></a>创建和读取符号链接</h2><p>可以用symlink或symlikat函数创建一个符号链接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlinkat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>因为open函数跟随符号链接,所以需要有一种方法打开该链接本身,并读该链接中的名字read1ink和 readlinkat函数提供了这种功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> readlink(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize); </div><div class="line"><span class="keyword">ssize_t</span> readlinkat(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize); </div><div class="line"></div><div class="line"><span class="comment">// Both return: number of bytes read if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="文件的时间"><a href="#文件的时间" class="headerlink" title="文件的时间"></a>文件的时间</h2><p>每个文件属性所保存的实际精度依赖于文件系统的实现。对于把时间戳记录在秒级的文件系统来说,纳秒这个字段就会被填充为0。对于时间戳的记录精度高于秒级的文件系统来说,不足秒的值被转换成纳秒并记录在纳秒这个字段中。</p>
<p>每个文件维护3个时间字段：<br><img src="https://data2.liuin.cn/2018-04-26-15247296049968.jpg" alt=""></p>
<p>注意修改时间( st_mtim)和状态更改时间( st_ctim)之间的区别。修改时间是文件内容最后一次被修改的时间。状态更改时间是该文件的i节点最后一次被修改的时间。系统并不维护对一个i节点的最后一次访问时间,所以 access和stat函数并不更改这3个时间中的任一个。</p>
<h2 id="函数futimens、utimensat和utimes"><a href="#函数futimens、utimensat和utimes" class="headerlink" title="函数futimens、utimensat和utimes"></a>函数futimens、utimensat和utimes</h2><p>一个文件的访问和修改时间可以用以下几个函数更改。<code>futimens</code>和<code>utimensat</code>函数可以指定纳秒级精度的时间戳。用到的数据结构是与stat函数族相同的timespec结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimens</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>])</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimensat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>], <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="函数mkdir、mkdirat和rmdir"><a href="#函数mkdir、mkdirat和rmdir" class="headerlink" title="函数mkdir、mkdirat和rmdir"></a>函数mkdir、mkdirat和rmdir</h2><p>用 mkdir和 mkdirat函数创建目录,用rmdir函数删除目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdirat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>这两个函数创建一个新的空目录。其中,.和..目录项是自动创建的。所指定的文件访问权限mode由进程的文件模式创建屏蔽字修改。</p>
<p>用 <code>rmdir</code>函数可以删除一个空目录。空目录是只包含.和..这两项的目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="读目录"><a href="#读目录" class="headerlink" title="读目录"></a>读目录</h2><p>对某个目录具有访问权限的任一用户都可以读该目录,但是,为了防止文件系统产生混乱只有内核才能写目录。</p>
<p>读目录相关的系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>; </div><div class="line"><span class="function">DIR *<span class="title">fdopendir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: pointer if OK, NULL on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> dirent *<span class="title">readdir</span><span class="params">(DIR *dp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer if OK, NULL at end of directory or error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">telldir</span><span class="params">(DIR *dp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: current location in directory associated with dp </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekdir</span><span class="params">(DIR *dp, <span class="keyword">long</span> loc)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="函数chdir、fchdir和getcwd"><a href="#函数chdir、fchdir和getcwd" class="headerlink" title="函数chdir、fchdir和getcwd"></a>函数chdir、fchdir和getcwd</h2><p>每个进程都有一个当前工作目录,此目录是搜索所有相对路径名的起点(不以斜线开始的路径名为相对路径名)。当用户登录到UNIX系统时,其当前工作目录通常是口令文件(/etc/ passwd)中该用户登录项的第6个字段——用户的起始目录( home directory)。当前工作目录是进程的一个属性,起始目录则是登录名的一个属性</p>
<p>进程调用chdir和fchdir函数可以改变当前工作目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchdir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>我们需要一个函数,它从当前工作目录(.)开始,用.找到其上一级目录,然后读其目录项,直到该目录项中的i节点编号与工作目录i节点编号相同,这样地就找到了其对应的文件名按照这种方法,逐层上移,直到遇到根,这样就得到了当前工作目录完整的绝对路径名。很幸运,函数 getcwd就提供了这种功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: buf if OK, NULL on error</span></div></pre></td></tr></table></figure>
<h2 id="文件访问权限位小结"><a href="#文件访问权限位小结" class="headerlink" title="文件访问权限位小结"></a>文件访问权限位小结</h2><p><img src="https://data2.liuin.cn/2018-04-26-15247306715849.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[I/O多路复用之Select、Poll和Epoll]]></title>
      <url>/2018/04/20/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8BSelect%E3%80%81Poll%E5%92%8CEpoll/</url>
      <content type="html"><![CDATA[<p>近期写一个在线聊天室的时候接触到epoll，加上之前腾讯面试的时候面试官有问到这一题。这里就对select、poll和epoll做一个总结，目的是让自己更加深入地理解，大部分内容来自网上，可能存在错误，欢迎大家指正。</p>
<a id="more"></a>
<h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p>之前在讲阻塞/非阻塞和同步/异步的理解的时候讲到，在Unix网络I/O中，有三种同步I/O方式：阻塞式I/O、非阻塞式I/O和I/O复用。</p>
<p>I/O多路复用简单来说就是对多个文件进行操作，<strong>通过一种机制一个进程能同时等待多个文件描述符</strong>，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回</p>
<p>select，poll，epoll都是I/O多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</div></pre></td></tr></table></figure>
<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。nfds表示所有监视的文件描述符中最高的数+1，同时可以定义时间timeout，超过时间将返回0。</p>
<p>调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在 Linux内核层面, select使用了内核poll例程集合。每个例程都返回有关单个文件描述符就绪的信息。这个就绪信息以位掩码的形式返回。select主要是轮询这些例程集合，当有例程返回的文件描述符就绪信息表示已经就绪以后，阻塞的select就会返回。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。</p>
<p>但是通过上面实现的分析，select还存在的问题是：</p>
<ul>
<li>被监控的fds需要从用户空间拷贝到内核空间。为了减少数据拷贝带来的性能损坏，内核对被监控的fds集合大小做了限制，并且这个是通过宏控制的，大小不可改变(限制为1024)。</li>
<li>每次调用 select,内核都必须轮询检查所有被指定的文件描述符,看它们是否处于就绪态。当检查大量处于密集范围内的文件描述符时,该操作将会耗费大量的时间</li>
<li>select调用完成后,程序必须检査返回的数据结构中的每个元素,以此查明哪个文件描述符处于就绪态了</li>
</ul>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div></pre></td></tr></table></figure>
<p>不同与select使用三个集合来表示三个fdset的方式，poll使用一个 pollfd的数组实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> pollfd &#123;</div><div class="line">   <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></div><div class="line">   <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span></div><div class="line">   <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>fd表示检测的文件描述符，要测试的条件由 events成员指定,函数在相应的 revents成员中返回该描述符的状态。和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>
<p>在API调用上其与select的区别是：</p>
<ul>
<li>由于 select的参数fd_set同时也是保存调用结果的地方,如果要在循环中重复调用select的话,我们必须每次都要重新初始化fd_set。而poll通过独立的两个字段 events(针对输入)和 revents(针对输出)来处理,从而避免每次都要重新初始化参数</li>
<li>select提供的超时精度(微秒)比poll提供的超时精度(毫秒)高。(这两个系统调用的超时精度都受软件时钟粒度的限制。)</li>
</ul>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>poll在Linux内核中的实现原理和select是一样的，同样是通过轮询poll例程集合来判断文件描述符的状态的。</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>poll虽然解决了fds集合大小1024的限制问题，但是，它并没改变大量描述符数组被整体复制于用户态和内核态的地址空间之间，以及个别描述符就绪触发整体描述符集合的遍历的低效问题。poll随着监控的socket集合的增加性能线性下降，poll不适合用于大并发场景。</p>
<p>select中存在的性能问题poll中也一样存在</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一组函数来完成任务,而不是单个函数。epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中,从而无须像 select和poll那样每次调用都要重复传人文件描述符集或事件集。但epoll要使用一个额外的文件描述符,来唯一标识内核中的这个事件表。</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>epoll含有的接口有三个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;   </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span></span></div><div class="line">                      <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout);</div></pre></td></tr></table></figure>
<blockquote>
<p>epoll_create</p>
</blockquote>
<p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</p>
<p>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽</p>
<blockquote>
<p>epoll_ctl</p>
</blockquote>
<p>对由<code>epfd</code>所引用的epoll实例进行操作，其中<code>op</code>表示操作类型(包含增删改)，<code>fd</code>表示操作的目标文件描述符，<code>event</code>和文件描述符相关联表示具体监听什么事件，以下是<code>event</code>的具体数据结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</div><div class="line">   <span class="keyword">void</span>        *ptr;</div><div class="line">   <span class="keyword">int</span>          fd;</div><div class="line">   <span class="keyword">uint32_t</span>     u32;</div><div class="line">   <span class="keyword">uint64_t</span>     u64;</div><div class="line">&#125; <span class="keyword">epoll_data_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> epoll_event &#123;</div><div class="line">   <span class="keyword">uint32_t</span>     events;      <span class="comment">/* 监听的事件属性，通常包含：读、写、出错、挂断等等 */</span></div><div class="line">   <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* 事件信息 */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>epoll_wait</p>
</blockquote>
<p>等待<code>epfd</code>所引用的epoll实例上的I/O就绪，同时用<code>events</code>来获得从内核得到的事件集合、<code>maxevents</code>表示传入的events有多少</p>
<p>函数返回以后可以遍历event数组，对已经就绪的I/O进行处理。</p>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>在每个事件的属性中可以设置对文件描述符的工作模式，有两种模式：水平触发LT（level trigger）和边沿出发ET（edge trigger）。LT模式是默认模式。两种模式的区别如下：</p>
<p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序可以不立即处理该事件</strong>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p>
<p>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序必须立即处理该事件</strong>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<h3 id="EPOLLONESHOT事件"><a href="#EPOLLONESHOT事件" class="headerlink" title="EPOLLONESHOT事件"></a>EPOLLONESHOT事件</h3><p>即使我们使用ET模式,一个socket上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如一个线程(或进程,下同)在读取完某个 socket上的数据后开始处理这些数据,而在数据的处理过程中该 socket上又有新数据可读( EPOLLIN再次被触发),此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个socket的局面。这当然不是我们期望的。我们期望的是<strong>一个socket连接在任一时刻都只被一个线程处理</strong>。这一点可以使用 epoll的 EPOLLONESHOT事件实现。</p>
<p>对于注册了EPOLLONESHOT事件的文件描述符,操作系统最多触发其上注册的一个可读、可写或者异常事件,且只触发一次,除非我们使用 epoll_ctl函数重置该文件描述符上注册的 EPOLLONESHOT事件。这样,当一个线程在处理某个 socket时,其他线程是不可能有机会操作该 socket的。但反过来思考,注册了 EPOLLONESHOT事件的 socket一且被某个线程处理完毕,该线程就应该立即重置这个 socket上的 EPOLLONESHOT事件,以确保这个socket下一次可读时,其 EPOLLIN事件能被触发,进而让其他工作线程有机会继续处理这个socket</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>当通过epoll_ctl指定了需要监视的文件描述符时，内核会在与打开的文件描述上下文相关联的列表中记录该描述符。之后每当执行I/O操作使得文件描述符成为就绪态时，就会启用回调函数使得内核就在epoll描述符的就绪列表中添加一个元素。(单个打开的文件描述上下文中的一次I/O事件可能导致与之相关的多个文件描述符成为就绪态)之后的epoll_wait()调用从就绪列表中简单地取出这些元素。这样采用回调的方式获取就绪的文件描述符相比select和poll轮询的方式效率就快很多</p>
<p>在 epoll中我们使用 epoll_ctl在内核空间中建立一个事件表,事件表会将待监视的文件描述符都记录下来。一旦这个数据结构建立完成,稍后每次调用epoll_wait时就不需要再传递任何与文件描述符有关的信息给内核了,而调用返回的信息中只包含那些已经处于就绪态的描述符。这样就减少了将文件描述符信息从用户态转移到内核态所需要的消耗。</p>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)</p>
<p>其优点主要有如下几点：</p>
<ul>
<li>监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于1024</li>
<li>在执行调用的时候不需要将监听的文件描述符集合从用户态复制到内核态，减少开销</li>
<li>IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>监视事件数量</p>
</blockquote>
<p>select受限于1024（依据系统而定），poll虽然数量上没有收到限制，但是因为需要轮询数量非常大的时候性能会下降，epoll在数量和性能上面都没有限制</p>
<blockquote>
<p>实现方式</p>
</blockquote>
<p>select，poll实现需要自己不断轮询所有fd集合，直到设备就绪。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程<br>虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的 时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间，这就是回调机制带来的性能提升。</p>
<blockquote>
<p>开销</p>
</blockquote>
<p>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内 部定义的等待队列），这也能节省不少的开销</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Unix网络编程》</li>
<li>《Linux高性能服务器编程》</li>
<li><a href="https://segmentfault.com/a/1190000003063859#articleHeader9" target="_blank" rel="external">https://segmentfault.com/a/1190000003063859#articleHeader9</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1005481" target="_blank" rel="external">https://cloud.tencent.com/developer/article/1005481</a></li>
<li><a href="http://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="external">http://www.cnblogs.com/Anker/p/3265058.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Unix </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《Effective C++》 笔记]]></title>
      <url>/2018/04/19/%E3%80%8AEffective-C-%E3%80%8B-%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>《Effective C++》的副标题是改善程序与设计的55个具体做法。这本书用比较多的示例展示了很多改善C++程序的方法，值得一读。</p>
<a id="more"></a>
<h2 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h2><h3 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款01：视C++为一个语言联邦</h3><p>C++高效编程守则视状况而变化,取决于你使用C++的哪一部分。</p>
<h3 id="条款02：尽量以const，enum，inline替换-define"><a href="#条款02：尽量以const，enum，inline替换-define" class="headerlink" title="条款02：尽量以const，enum，inline替换#define"></a>条款02：尽量以const，enum，inline替换#define</h3><p>“宁可以编译器替换预处理器”</p>
<p>使用<code>#define</code>时在编译之前所有的常量都被替换成了数字，如果在编译的时候产生错误，那么追溯错误产生的源头将是一件非常困难的事情。使用<code>const</code>就不一样，其变量一定会被编译器看到，当然就会引入<code>symbol table</code>中</p>
<p>当我们以常量替换<code>#defines</code>,有两种特殊情况值得说说。第一是定义常量指针( constant pointers)。由于常量定义式通常被放在头文件内(以便被不同的源码含入),因此有必要将指针(而不只是指针所指之物)声明为<code>const</code></p>
<p>第二个值得注意的是<code>class</code>专属常量。为了将常量的作用域(scope)限制于<code>class</code>内,你必须让它成为 class一个成员(member);而为确保此常量至多只有一份实体,你必须让它成为一个<code>static</code>成员:</p>
<blockquote>
<p>重点</p>
<ul>
<li>对于单纯常量,最好以 const对象或 enums替换#defines</li>
<li>对于形似函数的宏( macros),最好改用 inline函数替换#defines</li>
</ul>
</blockquote>
<h3 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h3><p>const的一件奇妙的事情是，它允许你指定一个语义约束，而编译器会强制执行这项约束。</p>
<p>const语法虽然变化多端,但并不莫测高深。如果关键字const出现在星号左边,表示被指物是常量(底层const)；如果出现在星号右边,表示指针自身是常量(顶层const);如果出现在星号两边,表示被指物和指针两者都是常量。</p>
<p>const最具威力的用法是面对函数声明时的应用。在一个函数声明式内, const可以和函数返回值、各参数、函数自身(如果是成员函数)产生关联。</p>
<blockquote>
<p>const 成员函数</p>
</blockquote>
<p>将 const实施于成员函数的目的,是为了确认该成员函数可作用于 const对象身上。这一类成员函数之所以重要,基于两个理由。第一,它们使 class接口比较容易被理解。这是因为,得知哪个函数可以改动对象内容而哪个函数不行,很是重要。第二,它们使“操作 const对象”成为可能。</p>
<blockquote>
<p>重点</p>
<ul>
<li>将某些东西声明为 const可帮助编译器侦测出错误用法。 const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体</li>
<li>当 const和non- const成员函数有着实质等价的实现时,令non- const版本调用 const版本可避免代码重复。</li>
</ul>
</blockquote>
<h3 id="条款04：确认对象使用前已被初始化"><a href="#条款04：确认对象使用前已被初始化" class="headerlink" title="条款04：确认对象使用前已被初始化"></a>条款04：确认对象使用前已被初始化</h3><p>在某些语境下x保证被初始化(为0),但在其他语境中却不保证。<strong>读取未初始化的值会导致不明确行为</strong></p>
<p>对于内置类型之外的东西，初始化的任务落在了构造函数的身上。我们要确保每一个构造函数都将对象的每一个成员初始化。但是我们很容易混淆复制和初始化的而例子，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; b);</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> thea;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> theb;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">A::A(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; b)</div><div class="line">&#123;</div><div class="line">    thea = a;   <span class="comment">// 这些都是赋值，而非初始化</span></div><div class="line">    theb = b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>C++规定,对象的成员变量的初始化动作发生在进入构造函数本体之前。所以构造函数最好使用成员初值列进行初始化。</p>
<blockquote>
<p>重点</p>
<ul>
<li>为内置型对象进行手工初始化,因为C++不保证初始化它们。</li>
<li>构造函数最好使用成员初值列( member initialization list),而不要在构造函数本体内使用赋值操作( assignment)。初值列列出的成员变量,其排列次序应该和它们在 class中的声明次序相同。</li>
</ul>
</blockquote>
<h2 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h2><h3 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款05：了解C++默默编写并调用哪些函数</h3><p>如果你自己没声明,编译器就会为它声明(编译器版本的)一个copy构造函数、一个 copy assignment操作符和一个析构函数。此外如果你没有声明任何构造函数,编译器也会为你声明一个 default构造函数。所有这些函数都是 public且in1ine。</p>
<p>default构造函数和析构函数主要是给编译器一个地方用来放置“藏身幕后”的代码,像是调用 base classes和non-static成员变量的构造函数和析构函数。</p>
<p>至于copy构造函数和 copy assignment操作符,编译器创建的版本只是单纯地将来源对象的每一个non- static成员变量拷贝到目标对象。</p>
<blockquote>
<p>重点</p>
<ul>
<li>编译器可以暗自为 class创建default构造函数、copy构造函数、 copy assignment操作符,以及析构函数。</li>
</ul>
</blockquote>
<h3 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>如果你不希望 class支持某一特定机能,只要不声明对应函数就是了。但这个策略对copy构造函数和copy assignment操作符却不起作用</p>
<p>所有编译器产出的函数都是 public.为阻止这些函数被创建出来,你得自行声明它们,但这里并没有什么需求使你必须将它们声明为 public。因此你可以将cory构造函数或 copy assignment操作符声明为 private。藉由明确声明一个成员函数,你阻止了编译器暗自创建其专属版本;而令这些函数为 private,使你得以成功组织别人调用他</p>
<blockquote>
<p>重点</p>
<ul>
<li>为驳回编译器自动(暗自)提供的机能,可将相应的成员函数声明为 private并且不予实现。</li>
</ul>
</blockquote>
<h3 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h3><p>C++明白指出,当 derived class对象经由一个base class指针被删除,而该 base class带着一个non- virtual析构函数,其结果未有定义实际执行时通常发生的是对象的 derived成分没被销毁。</p>
<p>消除这个问题的做法很简单:给 base class一个 virtua析构函数</p>
<blockquote>
<p>重点</p>
<ul>
<li>polymorphic(带多态性质的) base classes应该声明一个 virtual析构函数。如果class带有任何 virtual函数,它就应该拥有一个 virtual析构函数。</li>
</ul>
</blockquote>
<h3 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h3><p>C++并不禁止析构函数吐出异常,但它不鼓励你这样做。理由是当有多个（比如在vector中）对象需要销毁的时候，第一个对象和第二个对象析构是都抛出异常，这种情况下程序不是结束执行就是导致未定义行为。</p>
<blockquote>
<p>重点</p>
<ul>
<li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常,析构函数应该捕捉任何异常,然后吞下它们(不传播)或结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应,那么 class应该提供一个普通函数(而非在析构函数中)执行该操作。</li>
</ul>
</blockquote>
<h3 id="条款09：绝不要在构造函数和析构函数中调用virtual函数"><a href="#条款09：绝不要在构造函数和析构函数中调用virtual函数" class="headerlink" title="条款09：绝不要在构造函数和析构函数中调用virtual函数"></a>条款09：绝不要在构造函数和析构函数中调用virtual函数</h3><p>base class构造期间 virtual函数绝不会下降到derived classes阶层。取而代之的是,对象的作为就像隶属base类型一样。非正式的说法或许比较传神:在 base class构造期间, virtual函数不是 virtual函数。</p>
<p>由于base class构造函数的执行更早于derived class构造函数,当base class构造函数执行时 derived class的成员变量尚未初始化。如果此期间调用的 virtual函数下降至 derived classes阶层,要知道 derived class的函数几乎必然取用 local成员变量,而那些成员变量尚未初始化。这将是一张通往不明确行为和彻夜调试大会串的直达车票。“要求使用对象内部尚未初始化的成分”是危险的代名词,所以C++不让你走这条路。</p>
<p>相同道理也适用于析构函数。一旦derived class析构函数开始执行,对象内的derived class成员变量便呈现未定义值,所以C++视它们仿佛不再存在。进入base class析构函数后对象就成为一个base class对象,而C++的任何部分包括virtual函数、 dynamic casts等等也就那么看待它。</p>
<blockquote>
<p>重点</p>
<ul>
<li>在构造和析构期间不要调用 virtual函数,因为这类调用从不下降至 derived class(比起当前执行构造函数和析构函数的那层)</li>
</ul>
</blockquote>
<h3 id="条款10：令operator-返回一个-reference-to-this"><a href="#条款10：令operator-返回一个-reference-to-this" class="headerlink" title="条款10：令operator= 返回一个 reference to *this"></a>条款10：令operator= 返回一个 reference to *this</h3><p>复制可以写成连锁形式：</p>
<p><code>x = y = z = 15;</code></p>
<p>同时赋值采用右结合律,所以上述连锁赋值被解析为:</p>
<p><code>x = (y = (z = 15));</code></p>
<p>为了实现“连锁赋值”,赋值操作符必须返回一个 reference指向操作符的左侧实参。</p>
<blockquote>
<p>重点</p>
<ul>
<li>令赋值( assignment)操作符返回一个 reference to *this。</li>
</ul>
</blockquote>
<h3 id="条款11：在operator-中处理“自我赋值”"><a href="#条款11：在operator-中处理“自我赋值”" class="headerlink" title="条款11：在operator= 中处理“自我赋值”"></a>条款11：在operator= 中处理“自我赋值”</h3><p>“自我赋值“发生在对象赋值给自己时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Widget &#123; ... &#125; ;</div><div class="line">Widget w;</div><div class="line">...</div><div class="line">w = w;</div></pre></td></tr></table></figure>
<p>这看起来有点愚蠢,但它合法,所以不要认定客户绝不会那么做。</p>
<p>自我赋值可能出现的一个问题是, operator=函数内的*this(赋值的目的端)和rhs有可能是同一个对象。果真如此 delete就不只是销毁当前对象的 bitmap,它也销毁rhs的 bitmap。</p>
<p>欲阻止这种错误,传统做法是藉由 operator=最前面的一个“证同测试( identitytest)”达到“自我赋值”的检验目的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>重点</p>
<ul>
<li>确保当对象自我赋值时 operator=有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及 copy-and-swap。</li>
<li>确定任何函数如果操作一个以上的对象,而其中多个对象是同一个对象时,其行为仍然正确。</li>
</ul>
</blockquote>
<h3 id="条款12：复制对象时勿忘其每一个成分"><a href="#条款12：复制对象时勿忘其每一个成分" class="headerlink" title="条款12：复制对象时勿忘其每一个成分"></a>条款12：复制对象时勿忘其每一个成分</h3><blockquote>
<p>重点</p>
<ul>
<li>Copying函数应该确保复制“对象内的所有成员变量”及“所有 base class成分”。</li>
<li>不要尝试以某个 copying函数实现另一个 copying函数。应该将共同机能放进第三个函数中,并由两个 coping函数共同调用。</li>
</ul>
</blockquote>
<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h3 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h3><p>有的时候我们我们使用工厂函数获得某个特定的对象的指针的时候，在使用完毕时候需要将其占用的空间释放，尽管我们有这个意识，但是在实际开发中，如果中间出现异常或者return可能会造成内存泄漏的现象。</p>
<p>为了确保使用工厂函数返回的资源总是被释放,我们需要将资源放进对象内,当控制流离开f,<strong>该对象的析构函数会自动释放那些资源</strong>。实际上这正是隐身于本条款背后的半边想法:把资源放进对象内,我们便可倚赖C++的“析构函数自动调用机制”确保资源被释放。(稍后讨论另半边想法。)</p>
<blockquote>
<p>重点</p>
<ul>
<li>为防止资源泄漏,请使用RAII对象,它们在构造函数中获得资源并在析构函数中释放资源</li>
<li>两个常被使用的 RAII classes分别是trl::shared_ptr和 auto_ptr。前者通常是较佳选择,因为其copy行为比较直观。若选择 auto_ptr,复制动作会使它(被复制物)指向null</li>
</ul>
</blockquote>
<h3 id="条款14：在资源管理类中小心coping行为"><a href="#条款14：在资源管理类中小心coping行为" class="headerlink" title="条款14：在资源管理类中小心coping行为"></a>条款14：在资源管理类中小心coping行为</h3><p>我们使用C API管理一个互斥对象的时候，有lock和unlock两个函数可以用；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(Mutex* pm)</span></span>;     <span class="comment">// 锁定</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(Mutex* pm)</span></span>;   <span class="comment">// 解锁</span></div></pre></td></tr></table></figure>
<p>为了确保不会忘记解锁一个互斥量，我们可以使用上一个条款的建议，创建一个对象来管理这个互斥量，使得“资源在构造期间获得，在析构期间释放”</p>
<p>但是如果这个对象发生复制的时候怎么办？大多时候有以下两种可行的方案：</p>
<ul>
<li>禁止复制</li>
<li>对底层资源祭出“引用计数法”（reference-count）</li>
</ul>
<blockquote>
<p>重点</p>
<ul>
<li>复制RAII对象必须一并复制它所管理的资源,所以资源的copying行为决定RAII对象的copying行为。</li>
<li>普遍而常见的 Rail class copying行为是:抑制 copying、施行引用计数法( reference counting)。不过其他行为也都可能被实现</li>
</ul>
</blockquote>
<h3 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h3><p>资源管理类( resource-managing classes)很棒。它们是你对抗资源泄漏的堡垒。排除此等泄漏是良好设计系统的根本性质。在一个完美世界中你将倚赖这样的classes来处理和资源之间的所有互动,而不是玷污双手直接处理原始资源(rawresources)。但这个世界并不完美。许多APIs直接指涉资源,所以除非你发誓(这其实是一种少有实际价值的举动)永不录用这样的APls,否则只得绕过资源管理对象( resource-managing objects)直接访问原始资源( raw resources)。</p>
<p>由于有时候还是必须取得RAI对象内的原始资源,某些 RAII class设计者于是联想到“将油脂涂在滑轨上”,做法是提供一个显示转换函数或者隐式转换函数。</p>
<blockquote>
<p>重点</p>
<ul>
<li>APIs往往要求访问原始资源( raw resources),所以每一个 RAII class应该提供一个“取得其所管理之资源”的办法。</li>
<li>对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全,但隐式转换对客户比较方便。</li>
</ul>
</blockquote>
<h3 id="条款16：成对使用new和delete时要采取相同格式"><a href="#条款16：成对使用new和delete时要采取相同格式" class="headerlink" title="条款16：成对使用new和delete时要采取相同格式"></a>条款16：成对使用new和delete时要采取相同格式</h3><p>当你使用new(也就是通过new动态生成一个对象),有两件事发生。第内存被分配出来(通过名为 operator new的函数)。第二,针对此内存会有一个(或更多)构造函数被调用。</p>
<p>当你使用 delete,也有两件事发生:针对此内存会有一个(或更多)析构函数被调用,然后内存才被释放(通过名为 operator delete的函数)。</p>
<p>delete的最大问题在于:即将被删除的内存之内究竟存有多少对象?这个问题的答案决定了有多少个析构函数必须被调用起来。实际上这个问题可以更简单些:即将被删除的那个指针,所指的是单一对象或对象数组?这是个必不可缺的问题,因为单一对象的内存布局一般而言不同于数组的内存布局。</p>
<p>所以在成对使用new和delete的时候要采取相同的形式</p>
<blockquote>
<p>重点</p>
<ul>
<li>如果你在new表达式中使用[],必须在相应的de1ete表达式中也使用[]。如果你在new表达式中不使用[],一定不要在相应的 delete表达式中使用[]</li>
</ul>
</blockquote>
<h3 id="条款17：以独立语句将newed对象置入智能指针"><a href="#条款17：以独立语句将newed对象置入智能指针" class="headerlink" title="条款17：以独立语句将newed对象置入智能指针"></a>条款17：以独立语句将newed对象置入智能指针</h3><blockquote>
<p>重点</p>
<ul>
<li>以独立语句将 newed对象存储于(置入)智能指针内。如果不这样做,一旦异常被抛出,有可能导致难以察觉的资源泄漏。</li>
</ul>
</blockquote>
<h2 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h2><h3 id="条款18：让接口容易被正确使用，不容易被误用"><a href="#条款18：让接口容易被正确使用，不容易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不容易被误用"></a>条款18：让接口容易被正确使用，不容易被误用</h3><p>欲开发一个“容易被正确使用,不容易被误用”的接口,首先必须考虑客户可能做出什么样的错误。</p>
<p>预防客户错误的另一个办法是,限制类型内什么事可做,什么事不能做。常见的限制是加上 const。例如，以const修饰operator* 的返回类型可以阻止客户因“用户自定义类型”而犯错：</p>
<p><code>if( a * b = c ) ...</code>原意应该为做一次比较动作</p>
<p>下面是另一个一般性准则“让 types容易被正确使用,不容易被误用”的表现形式“除非有好理由,否则应该尽量令你的 types的行为与内置 types一致”。客户已经知道像int这样的type有些什么行为,所以你应该努力让你的 types在合样合理的前提下也有相同表现。</p>
<blockquote>
<p>重点</p>
<ul>
<li>好的接口很容易被正确使用,不容易被误用。你应该在你的所有接口中努力达成这些性质。</li>
<li>“促进正确使用”的办法包括接口的一致性,以及与内置类型的行为兼容。</li>
<li>“阻止误用”的办法包括建立新类型、限制类型上的操作,束缚对象值,以及消除客户的资源管理责任</li>
</ul>
</blockquote>
<h3 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款19：设计class犹如设计type</h3><p>设计优秀的 classes是一项艰巨的工作,因为设计好的 types是一项艰巨的工作。好的 types有自然的语法,直观的语义,以及一或多个高效实现品。在C++中,一个不良规划下的 class定义恐怕无法达到上述任何一个目标。甚至 class的成员函数的效率都有可能受到它们“如何被声明”的影响。</p>
<p>设计一个class需要思考如下的一些问题：</p>
<ul>
<li>新type的对象应该如何被创建和销毁?这会影响到你的 class的构造函数和析构函数以及内存分配函数和释放函数( operator new, operator new[], operator delete和 operator delete[])的设计,当然前提是如果你打算撰写它们。</li>
<li>对象的初始化和对象的赋值该有什么样的差别?这个答案决定你的构造函数和赋值操作符的行为,以及其间的差异。</li>
<li>新type的对象如果被 passed by value(以值传递),意味着什么?记住,copy构造函数用来定义一个type的 pass-by-value该如何实现。</li>
<li>什么是新“type”的合法值</li>
<li>你的新type需要配合某个继承图系( inheritance graph)吗?</li>
</ul>
<h3 id="条款20：宁以pass-by-reference-to-const-替换-pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const-替换-pass-by-value" class="headerlink" title="条款20：宁以pass-by-reference-to-const 替换 pass-by-value"></a>条款20：宁以pass-by-reference-to-const 替换 pass-by-value</h3><p>一般情况下，使用pass-by-reference-to-const能够调用更少的构造函数和析构函数，从而使得程序更加高效。</p>
<p>以by reference方式传递参数也可以避免 slicing(对象切割)问题。当一个 derived class对象以 by value方式传递并被视为一个 base class对象, base class的copy构造函数会被调用,而“造成此对象的行为像个 derived class对象”的那些特化性质全被切割掉了,仅仅留下一个 base class对象。</p>
<p>但是如果你有个对象属于内置类型(例如int), pass by value往往比 pass by reference的效率高些。对内置类型而言,当你有机会选择采用 pass-by-value或 pass-by-reference-to-const时,选择 pass-by-value并非没有道理。这个忠告也适用于STL的迭代器和函数对象,因为习惯上它们都被设计为passed by value。迭代器和函数对象的实践者有责任看看它们是否高效且不受切割问题</p>
<blockquote>
<p>重点</p>
<ul>
<li>尽量以 pass-by-reference-to-const替换 pass-by-value。前者通常比较高效,并可避免切割问题( slicing problem)</li>
<li>以上规则并不适用于内置类型,以及STL的迭代器和函数对象。对它们而言,pas- by-value往往比较适当。</li>
</ul>
</blockquote>
<h3 id="条款21：必须返回对象的时，别妄想返回其reference"><a href="#条款21：必须返回对象的时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象的时，别妄想返回其reference"></a>条款21：必须返回对象的时，别妄想返回其reference</h3><p>所谓 reference只是个名称,代表某个既有对象。任何时候看到一个 reference声明式,你都应该立刻问自己,它的另一个名称是什么?因为它一定是某物的另一个名称。</p>
<p>有的时候我们在返回引用的时候，其引用的对象如果一个局部变量，而这个局部变量在退出前就销毁了，所以不能够使用引用；如果所引用的对象是通过动态创建内存的方式创建的，这种情况下由谁来实施delete是一个问题。</p>
<blockquote>
<p>重点</p>
<ul>
<li>绝不要返回 pointer或 reference指向一个 local stack对象,或返回 reference指向个 heap-allocated对象,或返回 pointer或 reference指向一个 local static对象而有可能同时需要多个这样的对象。</li>
</ul>
</blockquote>
<h3 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h3><p>如果成员变量不是 public,客户唯一能够访问对象的办法就是通过成员函数。如果 public接口内的每样东西都是函数,客户就不需要在打算访问 class成员时迷惑地试着记住是否该使用小括号(圆括号)。他们只要做就是了,因为每样东西都是函数。就生命而言,这至少可以省下许多搔首弄耳的时间</p>
<p>使用函数可以让你对成员变量的处理有更精确的控制。如果你令成员变量为 public,每个人都可以读写它,但如果你以函数取得或设定其值,你就可以实现出“不准访问”、“只读访问”以及“读写访问”。</p>
<p>还是不够说服你?是端出大口径武器的时候了:封装啦。如果你通过函数访问成员变量,日后可改以某个计算替换这个成员变量,而 class客户一点也不会知道 class的内部实现已经起了变化。</p>
<blockquote>
<p>重点</p>
<ul>
<li>切记将成员变量声明为 private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证,并提供 class作者以充分的实现弹性。</li>
<li>protected并不比 public更具封装性。</li>
</ul>
</blockquote>
<h3 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款23：宁以non-member、non-friend替换member函数</h3><p>面向对象守则要求,数据以及操作数据的那些函数应该被捆绑在一块,这意味它建议 member函数是较好的选择。不幸的是这个建议不正确。这是基于对面向对象真实意义的一个误解。面向对象守则要求数据应该尽可能被封装,然而与直观相反地,member函数带来的封装性比non-member函数低。</p>
<p>让我们从封装开始讨论。如果某些东西被封装,它就不再可见。<strong>愈多东西被封装愈少人可以看到它。而愈少人看到它,我们就有愈大的弹性去变化它</strong>,因为我们的改变仅仅直接影响看到改变的那些人事物。因此,愈多东西被封装,我们改变那些东西的能力也就愈大。这就是我们首先推崇封装的原因:<strong>它使我们能够改变事物而只影响有限客户</strong>。</p>
<p>现在考虑对象内的数据。愈少代码可以看到数据(也就是访问它),愈多的数据可被封装,而我们也就愈能自由地改变对象数据,例如改变成员变量的数量、类型等等。</p>
<blockquote>
<p>重点</p>
<ul>
<li>宁可拿non-member non-friend函数替换 member函数。这样做可以增加封装性、包裹弹性(packaging flexibility)和机能扩充性。 </li>
</ul>
</blockquote>
<h3 id="条款24：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆需类型转换，请为此采用non-member函数"></a>条款24：若所有参数皆需类型转换，请为此采用non-member函数</h3><p>只有当参数被列于参数列(parameter list)内,这个参数才是隐式类型转换的合格参与者。地位相当于“被调用之成员函数所隶属的那个对象”一一即this对象—的那个隐喻参数,绝不是隐式转换的合格参与者。</p>
<blockquote>
<p>重点</p>
<ul>
<li>如果你需要为某个函数的所有参数(包括被this指针所指的那个隐喻参数)进行类型转换,那么这个函数必须是个non-member</li>
</ul>
</blockquote>
<h3 id="条款25：考虑写出一个不抛异常的swap函数"><a href="#条款25：考虑写出一个不抛异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛异常的swap函数"></a>条款25：考虑写出一个不抛异常的swap函数</h3><p>如果swap的缺省实现码对你的 class或 class template提供可接受的效率,你不需要额外做任何事。任何尝试置换(swap)那种对象的人都会取得缺省版本,而那将有良好的运作。</p>
<p>其次,如果swap缺省实现版的效率不足(那几乎总是意味你的 class或 template使用了某种pmpl手法),试着做以下事情</p>
<ul>
<li>提供一个 public swap成员函数,让它高效地置换你的类型的两个对象值。这个函数绝不该抛出异常。</li>
<li>在你的cass或 template所在的命名空间内提供一个non-member swap,并令它调用上述swap成员函数。</li>
<li>如果你正编写一个cass而非 class template),为你的clas特化stc并令它调用你的swap成员函数。</li>
</ul>
<p>唯一还未明确的是我的劝告:成员版swap绝不可抛出异常。那是因为swap的个最好的应用是帮助 classes(和 class templates)提供强烈的异常安全性(exception-safety)保障。</p>
<p>高效率的swap几乎总是基于对内置类型的操作(例如pmpl手法的底层指针),而内置类型上的操作绝不会抛出异常。</p>
<blockquote>
<p>重点</p>
<ul>
<li>当std::swap对你的类型效率不高时,提供一个swap成员函数,并确定这个函数不抛出异常。</li>
<li>如果你提供一个member swap,也该提供一个non-member swap用来调用前者。对于 classes(而非 templates),也请特化std::swap。</li>
<li>调用swap时应针对std::swap使用 using声明式,然后调用swap并且不带任何“命名空间资格修饰”</li>
<li>为“用户定义类型”进行std templates全特化是好的,但千万不要尝试在std内加入某些对std而言全新的东西</li>
</ul>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="条款26：尽可能延后变量定义式出现的时间"><a href="#条款26：尽可能延后变量定义式出现的时间" class="headerlink" title="条款26：尽可能延后变量定义式出现的时间"></a>条款26：尽可能延后变量定义式出现的时间</h3><p>只要你定义了一个变量而其类型带有一个构造函数或析构函数,那么当程序的控制流( control flow)到达这个变量定义式时,你便得承受构造成本;当这个变量离开其作用域时,你便得承受析构成本。即使这个变量最终并未被使用,仍需耗费这些成本,所以你应该尽可能避免这种情形。</p>
<blockquote>
<p>重点</p>
<ul>
<li>尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。</li>
</ul>
</blockquote>
<h3 id="条款27：尽量减少转型动作"><a href="#条款27：尽量减少转型动作" class="headerlink" title="条款27：尽量减少转型动作"></a>条款27：尽量减少转型动作</h3><p>C++提供四种新式转型：<br><code>const_cast&lt;T&gt;( expression )</code><br><code>dynamic_cast&lt;T&gt;( expression )</code><br><code>reinterpret_cast&lt;T&gt;( expression )</code><br><code>static_cast&lt;T&gt;(expression )</code></p>
<ul>
<li>const_cast通常被用来将对象的常量性转除</li>
<li>dynamic_cast主要用来执行“安全向下转型”(safe downcasting),也就是用来决定某对象是否归属继承体系中的某个类型。</li>
<li>reinterpret_cast意图执行低级转型,实际动作(及结果)可能取决于编译器这也就表示它不可移植。</li>
<li>static_cast用来强迫隐式转换</li>
</ul>
<p>许多程序员相信,转型其实什么都没做,只是告诉编译器把某种类型视为另一种类型。这是错误的观念。任何一个类型转换(不论是通过转型操作而进行的显式完成的隐式转换〕往往真的令编译器编译出运行期间执行的码。</p>
<blockquote>
<p>重点</p>
<ul>
<li>如果可以,尽量避免转型,特别是在注重效率的代码中避免 dynamic casts如果有个设计需要转型动作,试着发展无需转型的替代设计。</li>
<li>如果转型是必要的,试着将它<strong>隐藏于某个函数背后</strong>。客户随后可以调用该函数,而不需将转型放进他们自已的代码内。</li>
<li>宁可使用C++-style(新式)转型,不要使用旧式转型。前者很容易辨识出来,而且也比较有着分门别类的职掌。</li>
</ul>
</blockquote>
<h3 id="条款28：避免返回handles指向对象内部部分"><a href="#条款28：避免返回handles指向对象内部部分" class="headerlink" title="条款28：避免返回handles指向对象内部部分"></a>条款28：避免返回handles指向对象内部部分</h3><p>第一,成员变量的封装性最多只等于“返回其reference”的函数的访问级别。第二,如果 const成员函数传出一个 reference,后者所指数据与对象自身有关联,而它又被存储于对象之外,那么这个函数的调用者可以修改那笔数据。</p>
<blockquote>
<p>重点</p>
<ul>
<li>避免返回 handles(包括 references、指针、迭代弋器)指向对象内部。遵守这个条可增加封装性,帮助 const成员函数的行为像个 const,并将发生“虚吊号码牌”( dangling handles)的可能性降至最低。</li>
</ul>
</blockquote>
<h3 id="条款29：为“异常安全”而努力是值得的"><a href="#条款29：为“异常安全”而努力是值得的" class="headerlink" title="条款29：为“异常安全”而努力是值得的"></a>条款29：为“异常安全”而努力是值得的</h3><p>当异常抛出时，带有异常安全性的函数会：</p>
<ol>
<li>不泄露任何资源</li>
<li>不允许数据破坏</li>
</ol>
<p>异常安全函数提供下面三个保证之一：</p>
<ul>
<li>基本承诺:如果异常被抛出,程序内的任何事物仍然保持在有效状态下。没有任何对象或数据结构会因此而败坏,所有对象都处于一种内部前后一致的状态</li>
<li>强烈保证:如果异常被抛出,程序状态不改变。调用这样的函数需有这样的认知:如果函数成功,就是完全成功,如果函数失败,程序会回复到“调用函数之前”的状态。</li>
<li>不抛掷( nothrow)保证,承诺绝不抛出异常,因为它们总是能够完成它们原先承诺的功能。作用于内置类型(例如ints,指针等等)身上的所有操作都提供nothrow保证。这是异常安全码中一个必不可少的关键基础材料。</li>
</ul>
<blockquote>
<p>重点</p>
<ul>
<li>异常安全函数( exception-safe functions)即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证:基本型、强烈型、不抛异常型。</li>
<li>强烈保证”往往能够以 copy-and-swap实现出来,但“强烈保证”并非对所有函数都可实现或具备现实意义</li>
<li>函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。</li>
</ul>
</blockquote>
<h3 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款30：透彻了解inlining的里里外外</h3><p>编译器最优化机制通常被设计用来浓缩那些“不含函数调用”的代码,所以当你 inline某个函数,或许编译器就因此有能力对它(函数本体)执行语境相关最优化。然而编写程序就像现实生活一样,没有白吃的午餐。 inline函数也不例外。 inline函数背后的整体观念是,将“对此函数的每一个调用”都以函数本体替换之。首先这样会增加你的目标代码的大小</p>
<p>Inline函数通常一定被置于头文件内,因为大多数建置环境( build environments)在编译过程中进行 inlining,而为了将一个“函数调用”替换为“被调用函数的本体”,编译器必须知道那个函数长什么样子。</p>
<p>程序库设计者必须评估“将函数声明为 inline”的冲击: inline函数无法随着程序库的升级而升级。换句话说如果f是程序库内的一个 inline函数,客户将“f函数本体”编进其程序中,<strong>一旦程序库设计者决定改变f,所有用到f的客户端程序都必须重新编译</strong>。这往往是大家不愿意见到的。</p>
<blockquote>
<p>重点</p>
<ul>
<li>将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级( binary upgradability)更容易,也可使潜在的代码膨胀问题最小化,使程序的速度提升机会最大化。</li>
<li>不要只因为function templates出现在头文件,就将它们声明为inline</li>
</ul>
</blockquote>
<h3 id="条款31：将文件间的编译依存关系将至最低"><a href="#条款31：将文件间的编译依存关系将至最低" class="headerlink" title="条款31：将文件间的编译依存关系将至最低"></a>条款31：将文件间的编译依存关系将至最低</h3><p>问题出在C++并没有把“将接口从实现中分离”这事做得很好。 Class的定义式不只详细叙述了clas接口,还包括十足的实现细目。如果一个类定义中有编译依赖的其他文件中的类，那么修改所依赖的类的定义会导致现在的文件需要重新编译。这样的连串编译依存关系( cascading compilation dependencies)会对许多项目造成难以形容的灾难</p>
<p>上述的东西的一种解决方案是“前置声明每一件东西”，但是这个存在两个问题：第一，对于模板的前置声明比较复杂；第二、编译器必须在编译期间知道对象的大小，知道其大小就必须知道class中是如何实现的</p>
<blockquote>
<p>重点</p>
<ul>
<li>支持“编译依存性最小化”的一般构想是:相依于声明式,不要相依于定义式。基于此构想的两个手段是 Handle classes和 Interface classes</li>
<li>程序库头文件应该以“完全且仅有声明式”( full and declaration- only forms)的形式存在。这种做法不论是否涉及 templates都适用。</li>
</ul>
</blockquote>
<h2 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h2><h3 id="条款32：确定你的public继承塑模出is-a关系"><a href="#条款32：确定你的public继承塑模出is-a关系" class="headerlink" title="条款32：确定你的public继承塑模出is-a关系"></a>条款32：确定你的public继承塑模出is-a关系</h3><p>以C++进行面向对象编程,最重要的一个规则是: public inheritance(公开继承)意味”is-a”(是一种)的关系。把这个规则牢牢地烙印在你的心中吧!</p>
<p>ls-a并非是唯一存在于 classes之间的关系。另两个常见的关系是has-a(有个)和is-implemented-in- terms-of(根据某物实现出)。</p>
<blockquote>
<p>重点</p>
<ul>
<li>“public继承”意味ls-a。适用于base classes身上的每一件事情一定也适用于derived classes身上,因为每一个derived class对象也都是一个 base class对象。</li>
</ul>
</blockquote>
<h3 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h3><p>当编译器处于someFunc的作用域内并遭遇名称x时,它在 local作用域内查找是否有什么东西带着这个名称。如果找到就不再找其他作用域。C++的名称遮掩规则( name-hiding rules)所做的唯一事情就是:遮掩名称。至于名称是否应和相同或不同的类型,并不重要。</p>
<p>现在导入继承。我们知道,当位于一个derived class成员函数内指涉( refer to)base class内的某物(也许是个成员函数、 typedef、或成员变量)时,编译器可以找出我们所指涉的东西,因为 derived classes继承了声明于 base classes内的所有东西。实际运作方式是, derived class作用域被嵌套在 base class作用域内</p>
<p>有时候你并不想继承 base classes的所有函数,这是可以理解的。在 public继承下,这绝对不可能发生,因为它违反了 public继承所暗示的“base和 derived classes之间的is-a关系”。</p>
<blockquote>
<p>重点</p>
<ul>
<li>derived classes内的名称会遮掩 base classes内的名称。在public继承下从来没有人希望如此。</li>
<li>为了让被遮掩的名称再见天日,可使用using声明式或转交函数( forwardingfunctions)。</li>
</ul>
</blockquote>
<h3 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h3><p>表面上直截了当的 public继承概念,经过更严密的检查之后,发现它由两部分组成:函数接日( function interfaces)继承和函数实现( function implementations.)继承。这两种继承的差异,很像本书导读所讨论的函数声明与函数定义之间的差异。</p>
<p>pure virtual函数有两个最突出的特性:它们必须被任何“继承了它们”的具体对象class重新声明,而且它们在抽象 class中通常没有定义。把这两个性质摆在一起,你就会明白:<strong>声明一个 pure virtual函数的目的是为了让 derived classes只继承函数接口</strong>。</p>
<p>简朴的 impure virtual函数背后的故事和 pure virtual函数有点不同。一如往常,derived classes继承其函数接口,但 impure virtual函数会提供一份实现代码, derived classes可能覆写( override)它。稍加思索,你就会明白:<strong>声明简朴的(非纯) impure virtual函数的目的,是让 derived classes继承该函数的接口和缺省实现</strong></p>
<p>如果成员函数是个non-virtual函数,意味是它并不打算在 derived classes中有不同的行为。实际上一个 non-virtual成员函数所表现的不变性( invariant)凌驾其特异性( specialization),因为它表示不论 derived class变得多么特异化,它的行为都不可以改变。就其自身而言:<strong>声明non-virtual函数的目的是为了令 derived classes继承函数的接口及一份强制性实现</strong>。</p>
<p>pure virtual函数、 simple (impure)vmal函数、 non-virtual函数之间的差异,使你得以精确指定你想要 derived classes继承的东西:只继承接口,或是继承接口和一份缺省实现,或是继承接口和一份强制实现。由于这些不同类型的声明意味根本意义并不相同的事情,当你声明你的成员函数时,必须谨慎选择。</p>
<p>如果你确实履行,应该能够避免经验不足的 class设计者最常犯的两个错误：</p>
<ul>
<li>第一个错误是将所有函数声明为non-virtual这使得 derived classes没有余裕空间进行特化工作</li>
<li>另一个常见错误是将所有成员函数声明为 virtual</li>
</ul>
<blockquote>
<p>重点</p>
<ul>
<li>接口继承和实现继承不同在 public继承之下, derived classes总是继承 base class的接口。</li>
<li>pure virtual函数只具体指定接口继承。</li>
<li>简朴的(非纯) impure virtual函数具体指定接口继承及缺省实现继承。</li>
<li>non-virtual函数具体指定接口继承以及强制性实现继承。</li>
</ul>
</blockquote>
<h3 id="条款35：考虑virtual函数以外的其他选择"><a href="#条款35：考虑virtual函数以外的其他选择" class="headerlink" title="条款35：考虑virtual函数以外的其他选择"></a>条款35：考虑virtual函数以外的其他选择</h3><p>当你为解决问题而寻找某个设计方法时,不妨考虑virtual函数的替代方案。</p>
<ol>
<li>使用non-virtual interface(NVI)手法,那是Template Method设计模式的一种特殊形式。它以 public non-virtual成员函数包裹较低访问性( private或 protected)的 virtua函数。</li>
<li>将 virtual函数替换为“函数指针成员变量”,这是 Strategy设计模式的一种分解表现形式。</li>
<li>以tr1:: function成员变量替换 virtual函数,因而允许使用任何可调用物( callable entit!y)搭配一个兼容于需求的签名式。这也是 Strategy设计模式的某种形式。</li>
<li>将继承体系内的 virtual函数替换为另一个继承体系内的 virtual函数。这是Strategy设计模式的传统实现手法。</li>
</ol>
<p>以上并未彻底而详尽地列出 virtual函数的所有替换方案,但应该足够让你知道的确有不少替换方案。此外,它们各有其相对的优点和缺点,你应该把它们全部列入考虑</p>
<h3 id="条款36：绝不重新定义继承而来的non-virtual函数"><a href="#条款36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36：绝不重新定义继承而来的non-virtual函数"></a>条款36：绝不重新定义继承而来的non-virtual函数</h3><p>对于D继承B以及non-virtual成员函数B::mf身上：</p>
<ul>
<li>适用于B对象的每一件事,也适用于D对象,因为每个D对象都是一个B对象;</li>
<li>B的 derived classes一定会继承mf的接口和实现,因为mf是B的一个non-virtual函数。</li>
</ul>
<p>现在,如果b重新定义mf,你的设计便出现矛盾。如果D真有必要实现出与B不同的mf,并且如果每一个B对象——不管多么特化—一真的必须使用B所提供的mf实现码,那么“每个D都是一个B”就不为真。既然如此D就不该以 public形式继承B。另一方面,如果D真的必须以 public方式继承B,并且如果D真有需要实现出与B不同的mf,那么mf就无法为B反映出“不变性凌驾特异性”的性质。既然这样mf应该声明为 virtual函数。最后,如果每个D真的是一个B,并且如果mf真的为B反映出“不变性凌驾特异性”的性质,那么D便不需要重新定义mf,而且它也不应该尝试这样做。</p>
<blockquote>
<p>重点</p>
<ul>
<li>绝对不要重新定义继承而来的 non-virtua函数</li>
</ul>
</blockquote>
<h3 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款37：绝不重新定义继承而来的缺省参数值</h3><p>让我们一开始就将讨论简化。你只能继承两种函数: virtual和 non-virtual函数。然而重新定义一个继承而来的non-virtual函数永远是错误的(见条款36),所以我们可以安全地将本条款的讨论局限于“继承一个带有缺省参数值的 virtual函数”。</p>
<p>这种情况下,本条款成立的理由就非常直接而明确了: <strong>virtual函数系动态绑定( dynamically bound),而缺省参数值却是静态绑定( statically bound)</strong>。</p>
<p>为什么C++坚持以这种乖张的方式来运作呢?答案在于运行期效率。如果缺省参数值是动态绑定,编译器就必须有某种办法在运行期为 virtua函数决定适当的参数缺省值。这比目前实行的“在编译期决定”的机制更慢而且更复杂。为了程序的执行速度和编译器实现上的简易度,C++做了这样的取舍,其结果就是你如今所享受的执行效率。但如果你没有注意本条款所揭示的忠告,很容易发生混淆。</p>
<blockquote>
<p>重点</p>
<ul>
<li>绝对不要重新定义一个继承而来的缺省参数值,因为缺省参数值都是静态绑定,而 virtual函数—你唯一应该覆写的东西—却是动态绑定。</li>
</ul>
</blockquote>
<h3 id="条款38：通过复合塑模出has-a或”根据某物实现出”"><a href="#条款38：通过复合塑模出has-a或”根据某物实现出”" class="headerlink" title="条款38：通过复合塑模出has-a或”根据某物实现出”"></a>条款38：通过复合塑模出has-a或”根据某物实现出”</h3><p>复合( composition)是类型之间的一种关系,当某种类型的对象内含它种类型的对象,便是这种关系。</p>
<p>条款32曾说,“public继承”带有is-a(是一种)的意义。复合也有它自己的意义实际上它有两个意义。复合意味has-a(有一个)或 is-implemented-in-terms-of(根据某物实现出)。</p>
<blockquote>
<p>重点</p>
<ul>
<li>复合( composition)的意义和 public继承完全不同</li>
<li>在应用域( application domain),复合意味has-a(有一个)。在实现域( implementation domain),复合意味 is-implemented- in-terms-of(根据某物实现出)</li>
</ul>
</blockquote>
<h3 id="条款39：明智而审慎得使用private继承"><a href="#条款39：明智而审慎得使用private继承" class="headerlink" title="条款39：明智而审慎得使用private继承"></a>条款39：明智而审慎得使用private继承</h3><p>统御 private继承的首要规则你刚才已经见过了:如果classes之间的继承关系是 private,编译器不会自动将一个 derived class对象(例如Student)转换为一个 base class对象(例如 Person)。这和 public继承的情况不同。第二条规则是,由 private base class继承而来的所有成员,在 derived class中都会变成 private属性,纵使它们在base class中原本是 protected或 public属性。</p>
<p>Private继承意味 implemented-in-terms-of(根据某物实现出)。如果你让 class D以 private形式继承 class B,你的用意是为了采用 class B内已经备妥的某些特性,不是因为B对象和D对象存在有任何观念上的关系。 private继承纯粹只是一种实现技术(这就是为什么继承自一个 private baseclass的每样东西在你的clas内都是 private:因为它们都只是实现枝节而已)。借用条款34提出的术语, <strong>private继承意味只有实现部分被继承,接口部分应略去</strong>。</p>
<blockquote>
<p>重点</p>
<ul>
<li>Private继承意味 is-implemented-in-terms-of(根据某物实现出)。它通常比复合( composition)的级别低。但是当 derived clas需要访问 protected base class的成员,或需要重新定义继承而来的 virtua函数时,这么设计是合理的。</li>
<li>和复合( composition)不同, private继承可以造成 empty base最优化。这对致力于“对象尺寸最小化”的程序库开发者而言,可能很重要。</li>
</ul>
</blockquote>
<h3 id="条款40：明智而审慎得使用多重继承"><a href="#条款40：明智而审慎得使用多重继承" class="headerlink" title="条款40：明智而审慎得使用多重继承"></a>条款40：明智而审慎得使用多重继承</h3><p>当派生类继承的多个基类中都有某个同名成员函数的时候，可能会产生歧义。这个时候C++处理的方法与C++用来解析( resolving)重载函数调用的规则相符:在看到是否有个函数可取用之前,C++首先确认这个函数对此调用之言是最佳匹配。找出最佳匹配函数后才检验其可取用性。</p>
<p>从正确行为的观点看, public继承应该总是 virtuale。如果这是唯一一个观点,规则很简单:任何时候当你使用 public继承,请改用 virtual public继承。但是,啊呀,正确性并不是唯一观点。为避免继承得来的成员变量重复,编译器必须提供若干幕后戏法,而其后果是:使用 virtual继承的那些 classes所产生的对象往往比使用non- virtual继承的兄弟们体积大,访问 virtual base classes的成员变量时,也比访问non- virtual base classes的成员变量速度慢。种种细节因编译器不同而异,但基本重点很清楚:你得为 virtual继承付出代价。</p>
<blockquote>
<p>重点</p>
<ul>
<li>多重继承比单一继承复杂。它可能导致新的歧义性,以及对 virtual继承的需要。</li>
<li>virtual继承会增加大小、速度、初始化(及赋值)复杂度等等成本。如果 virtual base classes不带任何数据,将是最具实用价值的情况。</li>
<li>多重继承的确有正当用途。其中一个情节涉及“ public继承某个 Interface class”和“ private继承某个协助实现的 class”的两相组合。</li>
</ul>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[APUE 信号]]></title>
      <url>/2018/04/18/APUE-%E4%BF%A1%E5%8F%B7/</url>
      <content type="html"><![CDATA[<p>《UNIX环境高级编程》第10章 信号 笔记</p>
<a id="more"></a>
<p>信号是软件中断。很多比较重要的应用程序都需处理信号。信号提供了一种<strong>处理异步事件</strong>的方法,例如,终端用户键入中断键,会通过信号机制停止一个程序,或及早终止管道中的下一个程序。</p>
<h2 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h2><p>每个信号都有一个名字，这些名字都以3个字符SIG开头，比如：SIGINT中断信号、SIGABRT夭折信号、SIGALRM闹钟信号。</p>
<p>产生信号的条件：</p>
<ul>
<li>当用户按某些终端键时,引发终端产生的信号。</li>
<li>硬件异常产生信号:除数为0、无效的内存引用等。</li>
<li>进程调用ki11(2)函数可将任意信号发送给另一个进程或进程组。</li>
<li>用户可用ki11(1)命令将信号发送给其他进程</li>
<li>当检测到某种软件条件已经发生,并应将其通知有关进程时也产生信号</li>
</ul>
<p>信号是异步事件的经典实例。产生信号的事件对进程而言是随机出现的。进程不能简单地测试一个变量(如 errno)来判断是否发生了一个信号,而是必须告诉内核“在此信号发生时,请执行下列操作”。</p>
<p>在某个信号出现时,可以告诉内核按下列3种方式之一进行处理,我们称之为信号的处理或与信号相关的动作：</p>
<ul>
<li>忽略此信号，有两种信号不能被忽略，它们是 SIGKILL和 SIGSTOP。这两种信号不能被忽略的原因是:它们向内核和超级用户提供了使进程终止或停止的可靠方法。</li>
<li>捕捉信号，通知内核在某种信号发生时,调用一个用户函数。在用户函数中,可执行用户希望对这种事件进行的处理。</li>
<li>执行系统默认操作</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-04-18-15240592901538.jpg" alt=""></p>
<h2 id="函数signal"><a href="#函数signal" class="headerlink" title="函数signal"></a>函数signal</h2><p>UNX系统信号机制最简单的接口是 signal函数，其用于捕获信号，并捕获以后发生什么事情。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> signo, <span class="keyword">void</span> (*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>); </div><div class="line"></div><div class="line"><span class="comment">//Returns: previous disposition of signal (see following) if OK, SIG_ERR on error</span></div></pre></td></tr></table></figure>
<p><code>signo</code>参数是信号名。<code>func</code>的值是常量SIG_IGN、常量SIG_DEL或当接到此信号后要调用的函数的地址。<code>SIG_IGN</code>表示向内核表示忽略此信号(记住有两个信号 SIGKILI和 SIGSTOP不能忽略)。SIG_DEL表示接到此信号后的动作是系统默认动作。</p>
<p>当指定函数地址时，则在信号发生时，调用该函数，我们称这种处理为捕获该信号，称此函数为信号处理程序( signal handler)或信号捕捉函数 (signal-catching function)</p>
<blockquote>
<p>程序启动</p>
</blockquote>
<p>当执行一个程序时,所有信号的状态都是系统默认或忽略。通常所有信号都被设置为它们的默认动作,除非调用exec的进程忽略该信号。确切地讲,<strong>exec函数将原先设置为要捕捉的信号都更改为默认动作</strong>,其他信号的状态则不变(一个进程原先要捕捉的信号,当其执行一个新程序后,就不能再捕捉了,因为信号捕捉函数的地址很可能在所执行的新程序文件中已无意义)。</p>
<blockquote>
<p>进程创建</p>
</blockquote>
<p>当一个进程调用fork时,其子进程继承父进程的信号处理方式。因为子进程在开始时复制了父进程内存映像,所以信号捕捉函数的地址在子进程中是有意义的</p>
<h2 id="不可靠信号"><a href="#不可靠信号" class="headerlink" title="不可靠信号"></a>不可靠信号</h2><p>在早期的UNX版本中(如V7),信号是不可靠的。不可靠在这里指的是,信号可能会丢失。一个信号发生了,但进程却可能一直不知道这一点。同时,进程对信号的控制能力也很差,它能捕捉信号或忽略它。有时用户希望通知内核阻塞某个信号:不要忽略该信号,在其发生时记住它然后在进程做好了准备时再通知它。这种阻塞信号的能力当时并不具备</p>
<p>这些早期版本的另一个问题是:在进程不希望某种信号发生时,它不能关闭该信号。进程能做的一切就是忽略该信号。</p>
<h2 id="中断的系统调用"><a href="#中断的系统调用" class="headerlink" title="中断的系统调用"></a>中断的系统调用</h2><p>早期UNX系统的一个特性是:如果进程在执行一个低速系统调用而阻塞期间捕捉到一个信号,则该系统调用就被中断不再继续执行。该系统调用返回出错,其erno设置为EINTR。</p>
<p>为了支持这种特性,将系统调用分成两类:低速系统调用和其他系统调用。低速系统调用是可能会使进程永远阻塞的一类系统调用，包括：</p>
<ul>
<li>如果某些类型文件(如读管道、终端设备和网络设备)的数据不存在,则读操作可能会使调用者永远阻塞;</li>
<li>如果这些数据不能被相同的类型文件立即接受,则写操作可能会使调用者永远阻塞</li>
<li>在某种条件发生之前打开某些类型文件,可能会发生阻塞(例如要打开一个终端设备需要先等待与之连接的调制解调器应答)</li>
<li>pause函数(按照定义,它使调用进程休眠直至捕捉到一个信号)和wait函数;</li>
<li>某些ioct操作</li>
<li>某些进程间通信函数</li>
</ul>
<p>在这些低速系统调用中,一个值得注意的例外是与磁盘I/O有关的系统调用。虽然读、写个磁盘文件可能暂时阻塞调用者(在磁盘驱动程序将请求排入队列,然后在适当时间执行请求期间),但是除非发生硬件错误,IO操作总会很快返回,并使调用者不再处于阻塞状态。</p>
<p>可以用中断系统调用这种方法来处理的一个例子是:一个进程启动了读终端操作,而使用该终端设备的用户却离开该终端很长时间。在这种情况下,进程可能处于阻塞状态几个小时甚至数天,除非系统停机,否则一直如此</p>
<h2 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h2><p>进程捕捉到信号并对其进行处理时,进程正在执行的正常指令序列就被信号处理程序临时中断,它首先执行该信号处理程序中的指令。如果从信号处理程序返回,则继续执行在捕捉到信号时进程正在执行的正常指令序列(这类似于发生硬件中断时所做的)。但在信号处理程序中,<strong>不能判断捕捉到信号时进程执行到何处</strong>。处理信号处理程序以后原来程序中有一部分会重复执行。</p>
<p>在信号处理函数中保证调用安全的函数（可以被安全中断的函数），这些函数是<strong>可重入的</strong>并被称之为<strong>异步信号安全的</strong>。</p>
<p>大多数函数是不可重入的,因为<br>(a)已知它们使用静态数据结构;<br>(b)它们调用mal1oc或free;<br>(c)它们是标准I/O函数。标准IO库的很多实现都以不可重入方式使用全局数据结构</p>
<h2 id="可靠信号术语与语义"><a href="#可靠信号术语与语义" class="headerlink" title="可靠信号术语与语义"></a>可靠信号术语与语义</h2><p>我们需要先定义一些在讨论信号时会用到的术语。首先,当造成信号的事件发生时,为进程产生一个信号(或向一个进程发送一个信号)。事件可以是硬件异常(如除以0)、软件条件(如a1arm定时器超时)、终端产生的信号或调用ki11函数。当一个信号产生时,<strong>内核通常在进程表中以某种形式设置一个标志</strong>。</p>
<p>当对信号采取了这种动作时,我们说向进程递送了一个信号。在信号产生(generation)和递送(delivery)之间的时间间隔内,称信号是<strong>未决的</strong>(pending)</p>
<p>进程可以选用“阻塞信号递送”。如果为进程产生了一个阻塞的信号,而且对该信号的动作是系统默认动作或捕捉该信号,则为该进程将此信号保持为未决状态,直到该进程对此信号解除了阻塞,或者将对此信号的动作更改为忽略。内核在递送一个原来被阻塞的信号给进程时(而不是在产生该信号时),才决定对它的处理方式。于是进程在信号递送给它之前仍可改变对该信号的动作。进程调用<code>sigpending</code>函数来判定哪些信号是设置为阻塞并处于未决状态的。</p>
<p>每个进程都有一个信号屏蔽字( signal mask.),它规定了当前要阻塞递送到该进程的信号集。对于每种可能的信号,该屏蔽字中都有一位与之对应。对于某种信号,若其对应位已设置,则它当前是被阻塞的。进程可以调用 <code>sigprocmask</code>来检测和更改其当前信号屏蔽字。</p>
<h2 id="函数kill和raise"><a href="#函数kill和raise" class="headerlink" title="函数kill和raise"></a>函数kill和raise</h2><p>ki11函数将信号发送给进程或进程组。 ralse函数则允许进程向自身发送信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signo)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>进程将信号发送给其他进程需要权限。超级用户可将信号发送给任一进程。对于非超级用户,其基本规则是发送者的实际用户DD或有效用户ID必须等于接收者的实际用户ID或有效用户ID。</p>
<h2 id="函数alarm和pause"><a href="#函数alarm和pause" class="headerlink" title="函数alarm和pause"></a>函数alarm和pause</h2><p>使用alarm函数可以设置一个定时器(闹钟时间),在将来的某个时刻该定时器会超时。当定时器超时时,产生 SIGALRM信号。如果忽略或不捕捉此信号,则其默认动作是终止调用该a1arm函数的进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 or number of seconds until previously set alarm</span></div></pre></td></tr></table></figure>
<p>每个进程只能有一个闹钟时间。如果在调用a1arm时,之前已为该进程注册的闹钟时间还没有超时,则该闹钟时间的余留值作为本次a1arm函数调用的值返回。以前注册的闹钟时间则被新值代替。</p>
<p>如果有以前注册的尚未超过的闹钟时间,而且本次调用的 seconds值是0,则取消以前的闹钟时间,其余留值仍作为a1arm函数的返回值</p>
<p>pause函数使调用进程挂起直至捕捉到一个信号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: −1 with errno set to EINTR</span></div></pre></td></tr></table></figure>
<p>只有执行了一个信号处理程序并返回时，pause才返回</p>
<h2 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h2><p>我们需要有一个能表示多个信号—信号集(signal set)的数据类型。我们将在sigprocmask类函数中使用这种数据类型,以便告诉内核不允许发生该信号集中的信号。不同的信号的编号可能超过一个整型量所包含的位数,所以一般而言,不能用整型量中的一位代表一种信号,也就是不能用一个整型量表示信号集。POSIX 定义数据类型sigset_t以包含一个信号集,并且定义了下列5个处理信号集的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All four return: 0 if OK, −1 on error int sigismember(const sigset_t *set, int signo); Returns: 1 if true, 0 if false, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="函数sigprocmask"><a href="#函数sigprocmask" class="headerlink" title="函数sigprocmask"></a>函数sigprocmask</h2><p>调用函数<code>sigprocmask</code>可以检测或更改,或同时进行检测和更改进程的信号屏蔽字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> oset)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>如果oset为是非空指针，则进程当前的信号屏蔽字通过oset返回<br>其次,若ser是一个非空指针,则参数how指示如何修改当前信号屏蔽字。主要的操作有并集、交集、替代</p>
<p>在调用<code>sigprocmask</code>后如果有任何未决的、不再阻塞的信号,则在<code>sigprocmask</code>返回前至少将其中之一递送给该进程</p>
<h2 id="函数sigpending"><a href="#函数sigpending" class="headerlink" title="函数sigpending"></a>函数sigpending</h2><p><code>sigpending</code>函数返回一信号集,对于调用进程而言,其中的各信号是阻塞不能递送的,因而也一定是当前未决的。该信号集通过set参数返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="函数sigaction"><a href="#函数sigaction" class="headerlink" title="函数sigaction"></a>函数sigaction</h2><p><code>sigaction</code>函数的功能是检查或修改(或检查并修改)与指定信号相关联的处理动作。此函数取代了UNX早期版本使用的 signal函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> <span class="keyword">struct</span> sigaction *<span class="keyword">restrict</span> act, <span class="keyword">struct</span> sigaction *<span class="keyword">restrict</span> oact)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>参数signo是要检测或修改其具体动作的信号编号。若act指针非空,则要修改其动作。如果oact指针非空,则系统经由oact指针返回该信号的上一个动作。</p>
<h2 id="函数abort"><a href="#函数abort" class="headerlink" title="函数abort"></a>函数abort</h2><p>abort函数的功能是使程序异常终止，此函数将 SIGABRT信号发送给调用进程(进程不应忽略此信号)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// This function never returns</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Unix 进程间通信]]></title>
      <url>/2018/04/13/Unix-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<p>总结Unix下进程间通信的几种方式及其特点</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="进程同步和进程通信的区别"><a href="#进程同步和进程通信的区别" class="headerlink" title="进程同步和进程通信的区别"></a>进程同步和进程通信的区别</h3><p>关于这个问题，网络和很多书籍上把这两者混为一谈，对于这两者的区别，说法也有很多种。</p>
<p>其中一种说法是：</p>
<blockquote>
<p>进程互斥、同步与通信的关系：进程竞争资源时要实施互斥，互斥是一种特殊的同步，实质上需要解决好进程同步问题，进程同步是一种进程通信，由此看来，进程互斥、同步都可以看做进程的通信</p>
</blockquote>
<p>个人比较认同是以下这种说法：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行</li>
<li>进程通信：进程间传输信息</li>
</ul>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<p>在进程同步中介绍的信号量也属于进程通信的一种方式，但是属于低级别的进程通信，因为它传输的信息非常小。</p>
<h3 id="消息传递与共享内存"><a href="#消息传递与共享内存" class="headerlink" title="消息传递与共享内存"></a>消息传递与共享内存</h3><p>消息传递提供一种机制以允许进程不必通过共享地址空间来实现通信和同步，消息传递工具提供至少两种操作:发送(消息)和接收(消息)。由进程发送的消息可以是定长的或变长的。</p>
<p>操作系统提供用于通信的通道，进程通过读写这个通道进行通信。</p>
<p>Unix中基于消息传递实现的IPC有：管道、FIFO、消息队列以及网络间的Socket通信</p>
<p>共享内存的进程间通信需要通信进程建立共享内存区域。通常,一块共享内存区域驻留在生成共享内存段进程的地址空间。其他希望使用这个共享内存段进行通信的进程必须将此放到它们自己的地址空间上。</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道用于有亲缘关系的两个进程（父子进程）进行通信，写进程在管道的尾端写入数据，读进程在管道的首端读出数据。管道提供了简单的流控制机制，进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。</p>
<p>通常,一个管道由一个进程创建,在进程调用fork之后,这个管道就能在父进程和子进程之间使用了。</p>
<p>管道存在以下这些局限性：</p>
<ol>
<li>历史上,它们是半双工的(即数据只能在一个方向上流动)。现在,某些系统提供全双工管道,但是为了最佳的可移植性,我们决不应预先假定系统支持全双工管道</li>
<li>管道只能在具有公共祖先的两个进程之间使用。</li>
</ol>
<p>在Unix中管道是通过调用<code>pipe</code>函数创建的。对于一个从子进程到父进程的管道,父进程关闭fd[1],子进程关闭fd[0]。</p>
<p><img src="https://data2.liuin.cn/2018-04-18-15240546357016.jpg" alt=""></p>
<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>FIFO有时被称为命名管道。未命名的管道只能在两个相关的进程之间使用,而且这两个相关的进程还要有一个共同的创建了它们的祖先进程。但是,通过FIFO,不相关的进程也能交换数据。</p>
<p>在Unix中使用<code>mkfifo</code>或者<code>mkfifoat</code>创建FIFO，使用<code>open</code>打开，使用正常文件的I/O函数对FIFO进行读写操作实现进程间通信的目的。</p>
<p>使用FIFO实现两进程间通信的例子：</p>
<p><img src="https://data2.liuin.cn/2018-04-18-15240551859039.jpg" alt=""></p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是消息的链接表,存储在内核中,由消息队列标识符标识。</p>
<p>在Unix中使用<code>msgget</code>用于创建一个新队列或打开一个现有队列、<code>msgsnd</code>将新消息添加到队列尾端。<code>mmsgrcv</code>用于从队列中取消息。我们并不定要以先进先出次序取消息,也可以按消息的类型字段取消息。<br>每个消息包含一个正的长整型类型的字段、一个非负的长度以及实际数据字节数(对应于长度),所有这些都在将消息添加到队列时,传送给 msgsna。</p>
<p>消息队列相比于其他方式有很多优点：它提供有格式的字节流，减少了开发人员的工作量；消息具有类型（system V）或优先级（posix）</p>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>Socket 是网络进程间通信的一种，我们将描述套接字网络进程间通信接口,进程用该接口能够和其他进程通信,无论它们是在同一台计算机上还是在不同的计算机上。实际上,这正是套接字接口的设计目标之一。</p>
<p>Socket自身携带同步机制，不需要额外的方式来辅助实现同步。</p>
<p>在Unix中使用<code>socket</code>、<code>bind</code>、<code>connect</code>、<code>listen</code>、<code>accept</code>等一系列系统调用建立连接并进行通信。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量是一个计数器，用于多进程提供对共享数据对象的访问。</p>
<p>为了获得共享资源,进程需要执行下列操作。</p>
<ol>
<li>测试控制该资源的信号量</li>
<li>若此信号量的值为正,则进程可以使用该资源。在这种情况下,进程会将信号量值减1,表示它使用了一个资源单位。</li>
<li>否则,若此信号量的值为0,则进程进入休眠状态,直至信号量值大于0。进程被唤醒后,它返回至步骤(1)。</li>
</ol>
<p>当进程不再使用由一个信号量控制的共享资源时,该信号量值增1。如果有进程正在休眠等待此信号量,则唤醒它们。</p>
<p>为了正确地实现信号量,信号量值的测试及减1操作应当是原子操作。为此,信号量通常是在内核中实现的。</p>
<p>因为只能传递简单的数据，所以信号量常常只是用来进行进程间的同步。</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享存储允许两个或多个进程共享一个给定的存储区。因为数据不需要在客户进程和服务器进程之间复制,所以这是最快的一种IPC。</p>
<p>不过使用共享内存的时候要注意保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>管道</td>
<td>创建简单</td>
<td>容量有限、速度慢、只能用于父子进程通讯、半双工通信方式</td>
</tr>
<tr>
<td>FIFO</td>
<td>克服了管道没有名字的限制、允许无亲缘关系进程间的通信</td>
<td>速度慢</td>
</tr>
<tr>
<td>消息队列</td>
<td>承载信息量比较多、能够承载有格式的字节流</td>
<td>容量受到系统限制</td>
</tr>
<tr>
<td>Socket</td>
<td>能够实现网络间进程的通信</td>
<td>实现比较复杂</td>
</tr>
<tr>
<td>信号量</td>
<td>能够比较好地解决同步问题</td>
<td>传递的信息较少，只能用于同步</td>
</tr>
<tr>
<td>共享内存</td>
<td>速度快</td>
<td>要解决线程安全的问题</td>
</tr>
</tbody>
</table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Unix环境高级编程》</li>
<li>《Unix-Linux编程实践教程》</li>
<li>《操作系统概念》</li>
<li><a href="http://www.cnblogs.com/youngforever/p/3250270.html" target="_blank" rel="external">http://www.cnblogs.com/youngforever/p/3250270.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[同步/异步与阻塞/非阻塞的理解]]></title>
      <url>/2018/04/09/%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E4%B8%8E%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>近期在了解网络编程的时候对同步/异步和阻塞/非阻塞这些概念有一些混淆，所查了一些资料总结了这篇文章。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于同步/异步与阻塞/非阻塞的理解可能各个领域的人的回答是不一样的，在网络上也有各种各样的说法。这其实是因为不同的人的知识背景不同，并且在讨论这个问题的时候上下文(context)也不相同。本文主要结合网络上的观点以及一些书籍谈谈对同步/异步与阻塞/非阻塞大致概念上的理解，以及在Linux Network IO上的这四个概念的情况。</p>
<h2 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h2><p>同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)</p>
<p>所谓同步，就是在发出一个<strong>调用</strong>时，在没有得到结果之前，该<strong>调用</strong>就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由<strong>调用者</strong>主动等待这个<strong>调用</strong>的结果。</p>
<p>而异步则是相反，<strong>调用</strong>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<strong>调用</strong>发出后，<strong>被调用者</strong>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
<p>打一个不恰当的比方：</p>
<blockquote>
<p>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p>
</blockquote>
<h2 id="阻塞-非阻塞"><a href="#阻塞-非阻塞" class="headerlink" title="阻塞/非阻塞"></a>阻塞/非阻塞</h2><p>阻塞和非阻塞关注的是程序在<strong>等待调用结果（消息，返回值）时的状态</strong>.</p>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<p>例子：</p>
<blockquote>
<p>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。</p>
</blockquote>
<p>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>
<p>把自己挂起可以是在电话里面一直等着老板回信（同步阻塞），也可以是挂掉电话以后一直等着老板回电过来（异步阻塞）。先玩一会儿可以是电话接通着你去玩一会儿（同步非阻塞），也可以是电话挂了你去玩老板回电给你的时候你回来接（异步非阻塞）。</p>
<p>阻塞和非阻塞描述的是一种状态，同步与非同步描述的是行为方式。</p>
<h2 id="Unix-网络IO"><a href="#Unix-网络IO" class="headerlink" title="Unix 网络IO"></a>Unix 网络IO</h2><p>POSIX对同步I/O和异步I/O的定义如下：</p>
<ul>
<li>同步I/O操作( synchronous I/O opetation) 导致请求进程阻塞,直到I/O操作完成</li>
<li>异步IO操作( asynchronous I/O opetation) 不导致请求进程阻塞。</li>
</ul>
<p>在Unix中有四种常用的网络IO模型：</p>
<ul>
<li>阻塞式I/O</li>
<li>非阻塞式I/O</li>
<li>I/O复用</li>
<li>异步I/O</li>
</ul>
<p>其中前者都是同步I/O</p>
<h3 id="阻塞式I-O"><a href="#阻塞式I-O" class="headerlink" title="阻塞式I/O"></a>阻塞式I/O</h3><p>默认情况下，所有套接字都是阻塞的。在下面展示recvfrom系统调用中把数据接收过程分成两个阶段：1. 等待数据 2. 数据复制到用户空间。</p>
<p><img src="https://data2.liuin.cn/2018-04-09-15232418188483.jpg" alt=""></p>
<p>在等待过程中，进程不能做其他事情，所以是阻塞式的。什么时候调用结束：有结果或者报错的时候，调用才结束，所以是同步的。</p>
<h3 id="非阻塞式I-O"><a href="#非阻塞式I-O" class="headerlink" title="非阻塞式I/O"></a>非阻塞式I/O</h3><p><img src="https://data2.liuin.cn/2018-04-09-15232420864225.jpg" alt=""></p>
<p>在非阻塞式I/O中进程在进行系统调用recvfrom的时候，如果数据没有准备好线程不会等待，而是不断询问，直到数据准备好，复制数据到用户空间以后，接受数据这个动作才算完成。</p>
<p>因为线程不是一直在等待数据返回，其中也可以做其他的事情，所以是非阻塞式的，对于接受数据这个动作，进程会不断询问，知道最后有结果才算结束，所以是同步式的。</p>
<h3 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h3><p><img src="https://data2.liuin.cn/2018-04-09-15232424437721.jpg" alt=""></p>
<p>我们阻塞于 select调用,等待数据报套接字变为可读。当se1ect返回套接字可读这一条件时,我们调用 recvfrom把所读数据报复制到应用进程缓冲区。</p>
<h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><p><img src="https://data2.liuin.cn/2018-04-09-15232425049293.jpg" alt=""></p>
<p>异步I/O的工作模式时:告知内核启动某个操作,并让内核在整个操作(包括将数据从内核复制到我们自己的缓冲区)完成后通知我们。所以进程不需要一直询问其数据是否准备好</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><img src="https://data2.liuin.cn/2018-04-09-15232425884264.jpg" alt=""></p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://www.zhihu.com/question/19732473/answer/20851256" target="_blank" rel="external">https://www.zhihu.com/question/19732473/answer/20851256</a></li>
<li>《Unix 网络编程》</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Unix </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Github分布式爬虫——数据分析]]></title>
      <url>/2018/04/07/Github%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>对Github分布式爬虫爬取的20w用户信息和40w仓库信息进行简单的分析和统计</p>
<a id="more"></a>
<p>这里爬取的数据主要有两大类：用户数据和仓库数据，此次分析的数据量：256171用户数据，434994仓库数据</p>
<h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><h3 id="全球用户榜单"><a href="#全球用户榜单" class="headerlink" title="全球用户榜单"></a>全球用户榜单</h3><h4 id="Followers人数榜"><a href="#Followers人数榜" class="headerlink" title="Followers人数榜"></a>Followers人数榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/1024025" alt=""></td>
<td><a href="https://github.com/torvalds" target="_blank" rel="external">https://github.com/torvalds</a></td>
<td>6</td>
<td>2</td>
<td>70400</td>
<td>0</td>
<td>8</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/66577" alt=""></td>
<td><a href="https://github.com/JakeWharton" target="_blank" rel="external">https://github.com/JakeWharton</a></td>
<td>95</td>
<td>228</td>
<td>45000</td>
<td>12</td>
<td>3541</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/905434" alt=""></td>
<td><a href="https://github.com/ruanyf" target="_blank" rel="external">https://github.com/ruanyf</a></td>
<td>48</td>
<td>206</td>
<td>38200</td>
<td>0</td>
<td>1645</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/25254" alt=""></td>
<td><a href="https://github.com/tj" target="_blank" rel="external">https://github.com/tj</a></td>
<td>273</td>
<td>2000</td>
<td>34400</td>
<td>46</td>
<td>3310</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/499550" alt=""></td>
<td><a href="https://github.com/yyx990803" target="_blank" rel="external">https://github.com/yyx990803</a></td>
<td>141</td>
<td>779</td>
<td>29200</td>
<td>90</td>
<td>2553</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/110953" alt=""></td>
<td><a href="https://github.com/addyosmani" target="_blank" rel="external">https://github.com/addyosmani</a></td>
<td>295</td>
<td>807</td>
<td>29000</td>
<td>254</td>
<td>928</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/810438" alt=""></td>
<td><a href="https://github.com/gaearon" target="_blank" rel="external">https://github.com/gaearon</a></td>
<td>227</td>
<td>1300</td>
<td>27200</td>
<td>171</td>
<td>3019</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/39191" alt=""></td>
<td><a href="https://github.com/paulirish" target="_blank" rel="external">https://github.com/paulirish</a></td>
<td>266</td>
<td>723</td>
<td>25600</td>
<td>245</td>
<td>2375</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/170270" alt=""></td>
<td><a href="https://github.com/sindresorhus" target="_blank" rel="external">https://github.com/sindresorhus</a></td>
<td>975</td>
<td>2500</td>
<td>23600</td>
<td>50</td>
<td>4753</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/119893" alt=""></td>
<td><a href="https://github.com/kennethreitz" target="_blank" rel="external">https://github.com/kennethreitz</a></td>
<td>141</td>
<td>1900</td>
<td>21200</td>
<td>197</td>
<td>5626</td>
</tr>
</tbody>
</table>
<h4 id="Following人数榜"><a href="#Following人数榜" class="headerlink" title="Following人数榜"></a>Following人数榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/3076393" alt=""></td>
<td><a href="https://github.com/KevinHock" target="_blank" rel="external">https://github.com/KevinHock</a></td>
<td>19</td>
<td>198</td>
<td>1300</td>
<td>284000</td>
<td>639</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/5877145" alt=""></td>
<td><a href="https://github.com/angusshire" target="_blank" rel="external">https://github.com/angusshire</a></td>
<td>8</td>
<td>217000</td>
<td>10300</td>
<td>230000</td>
<td>30</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/6508763" alt=""></td>
<td><a href="https://github.com/dalinhuang99" target="_blank" rel="external">https://github.com/dalinhuang99</a></td>
<td>20</td>
<td>75</td>
<td>3200</td>
<td>162000</td>
<td>1293</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/3604053" alt=""></td>
<td><a href="https://github.com/cusspvz" target="_blank" rel="external">https://github.com/cusspvz</a></td>
<td>109</td>
<td>1200</td>
<td>6600</td>
<td>130000</td>
<td>90</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/6673982" alt=""></td>
<td><a href="https://github.com/MichalPaszkiewicz" target="_blank" rel="external">https://github.com/MichalPaszkiewicz</a></td>
<td>60</td>
<td>558</td>
<td>4600</td>
<td>72700</td>
<td>172</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/418638" alt=""></td>
<td><a href="https://github.com/nfultz" target="_blank" rel="external">https://github.com/nfultz</a></td>
<td>70</td>
<td>2500</td>
<td>2600</td>
<td>61600</td>
<td>2141</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/14251570" alt=""></td>
<td><a href="https://github.com/mstraughan86" target="_blank" rel="external">https://github.com/mstraughan86</a></td>
<td>15</td>
<td>454</td>
<td>3400</td>
<td>60500</td>
<td>299</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/32831059" alt=""></td>
<td><a href="https://github.com/opengiineer" target="_blank" rel="external">https://github.com/opengiineer</a></td>
<td>19</td>
<td>90</td>
<td>1600</td>
<td>55700</td>
<td>46</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/778015" alt=""></td>
<td><a href="https://github.com/ahmetabdi" target="_blank" rel="external">https://github.com/ahmetabdi</a></td>
<td>130</td>
<td>4100</td>
<td>448</td>
<td>53300</td>
<td>1954</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/4107768" alt=""></td>
<td><a href="https://github.com/brunocasanova" target="_blank" rel="external">https://github.com/brunocasanova</a></td>
<td>46</td>
<td>152</td>
<td>2400</td>
<td>48300</td>
<td>13</td>
</tr>
</tbody>
</table>
<h4 id="Stars榜"><a href="#Stars榜" class="headerlink" title="Stars榜"></a>Stars榜</h4><p>看看谁收藏的仓库最多</p>
<table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/5877145" alt=""></td>
<td><a href="https://github.com/angusshire" target="_blank" rel="external">https://github.com/angusshire</a></td>
<td>8</td>
<td>217000</td>
<td>10300</td>
<td>230000</td>
<td>30</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1610158" alt=""></td>
<td><a href="https://github.com/mcanthony" target="_blank" rel="external">https://github.com/mcanthony</a></td>
<td>4300</td>
<td>42500</td>
<td>375</td>
<td>12700</td>
<td>21</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/3947125" alt=""></td>
<td><a href="https://github.com/maoabc1818" target="_blank" rel="external">https://github.com/maoabc1818</a></td>
<td>9</td>
<td>32200</td>
<td>121</td>
<td>95</td>
<td>2</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/391299" alt=""></td>
<td><a href="https://github.com/JT5D" target="_blank" rel="external">https://github.com/JT5D</a></td>
<td>210</td>
<td>29300</td>
<td>276</td>
<td>6200</td>
<td>0</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/500775" alt=""></td>
<td><a href="https://github.com/reduxionist" target="_blank" rel="external">https://github.com/reduxionist</a></td>
<td>15</td>
<td>25800</td>
<td>174</td>
<td>429</td>
<td>62</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/6948067" alt=""></td>
<td><a href="https://github.com/pranavlathigara" target="_blank" rel="external">https://github.com/pranavlathigara</a></td>
<td>1200</td>
<td>24600</td>
<td>793</td>
<td>14900</td>
<td>130</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/2882" alt=""></td>
<td><a href="https://github.com/nikolay" target="_blank" rel="external">https://github.com/nikolay</a></td>
<td>12</td>
<td>23100</td>
<td>243</td>
<td>349</td>
<td>469</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/3759759" alt=""></td>
<td><a href="https://github.com/denji" target="_blank" rel="external">https://github.com/denji</a></td>
<td>1300</td>
<td>22500</td>
<td>181</td>
<td>397</td>
<td>305</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/24416962" alt=""></td>
<td><a href="https://github.com/roscopecoltran" target="_blank" rel="external">https://github.com/roscopecoltran</a></td>
<td>156</td>
<td>21000</td>
<td>121</td>
<td>4400</td>
<td>599</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/6257454" alt=""></td>
<td><a href="https://github.com/Jerzerak" target="_blank" rel="external">https://github.com/Jerzerak</a></td>
<td>1</td>
<td>18900</td>
<td>54</td>
<td>0</td>
<td>3</td>
</tr>
</tbody>
</table>
<h4 id="Reps榜"><a href="#Reps榜" class="headerlink" title="Reps榜"></a>Reps榜</h4><p>Github上创建仓库最多的人在这里</p>
<table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/675997" alt=""></td>
<td><a href="https://github.com/pombredanne" target="_blank" rel="external">https://github.com/pombredanne</a></td>
<td>40600</td>
<td>6500</td>
<td>149</td>
<td>87</td>
<td>2558</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/1732196" alt=""></td>
<td><a href="https://github.com/carriercomm" target="_blank" rel="external">https://github.com/carriercomm</a></td>
<td>20400</td>
<td>12900</td>
<td>72</td>
<td>176</td>
<td>151</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/14135456" alt=""></td>
<td><a href="https://github.com/digideskio" target="_blank" rel="external">https://github.com/digideskio</a></td>
<td>18000</td>
<td>88</td>
<td>120</td>
<td>3900</td>
<td>113</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/431924" alt=""></td>
<td><a href="https://github.com/guoyu07" target="_blank" rel="external">https://github.com/guoyu07</a></td>
<td>11600</td>
<td>91</td>
<td>20</td>
<td>1000</td>
<td>112</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/12729391" alt=""></td>
<td><a href="https://github.com/modulexcite" target="_blank" rel="external">https://github.com/modulexcite</a></td>
<td>10700</td>
<td>4200</td>
<td>30</td>
<td>192</td>
<td>15</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/1218365" alt=""></td>
<td><a href="https://github.com/PlumpMath" target="_blank" rel="external">https://github.com/PlumpMath</a></td>
<td>10100</td>
<td>508</td>
<td>31</td>
<td>147</td>
<td>103</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/3380677" alt=""></td>
<td><a href="https://github.com/carabina" target="_blank" rel="external">https://github.com/carabina</a></td>
<td>9300</td>
<td>8700</td>
<td>83</td>
<td>5</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/4687038" alt=""></td>
<td><a href="https://github.com/jorik041" target="_blank" rel="external">https://github.com/jorik041</a></td>
<td>9200</td>
<td>53</td>
<td>20</td>
<td>129</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1332574" alt=""></td>
<td><a href="https://github.com/treejames" target="_blank" rel="external">https://github.com/treejames</a></td>
<td>8000</td>
<td>6900</td>
<td>93</td>
<td>897</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/498130" alt=""></td>
<td><a href="https://github.com/mehulsbhatt" target="_blank" rel="external">https://github.com/mehulsbhatt</a></td>
<td>7400</td>
<td>364</td>
<td>23</td>
<td>9</td>
<td>104</td>
</tr>
</tbody>
</table>
<h4 id="Contribution榜"><a href="#Contribution榜" class="headerlink" title="Contribution榜"></a>Contribution榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/3244" alt=""></td>
<td><a href="https://github.com/robertbrook" target="_blank" rel="external">https://github.com/robertbrook</a></td>
<td>67</td>
<td>32</td>
<td>63</td>
<td>114</td>
<td>539804</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/20975616" alt=""></td>
<td><a href="https://github.com/SimiCode" target="_blank" rel="external">https://github.com/SimiCode</a></td>
<td>24</td>
<td>11</td>
<td>5</td>
<td>15</td>
<td>377077</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/751143" alt=""></td>
<td><a href="https://github.com/jasoncalabrese" target="_blank" rel="external">https://github.com/jasoncalabrese</a></td>
<td>75</td>
<td>50</td>
<td>64</td>
<td>19</td>
<td>357587</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/56100" alt=""></td>
<td><a href="https://github.com/kinlane" target="_blank" rel="external">https://github.com/kinlane</a></td>
<td>222</td>
<td>242</td>
<td>346</td>
<td>588</td>
<td>199240</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/415831" alt=""></td>
<td><a href="https://github.com/talos" target="_blank" rel="external">https://github.com/talos</a></td>
<td>113</td>
<td>95</td>
<td>143</td>
<td>7</td>
<td>115891</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/283441" alt=""></td>
<td><a href="https://github.com/honzajavorek" target="_blank" rel="external">https://github.com/honzajavorek</a></td>
<td>87</td>
<td>167</td>
<td>128</td>
<td>93</td>
<td>80301</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1006477" alt=""></td>
<td><a href="https://github.com/felixonmars" target="_blank" rel="external">https://github.com/felixonmars</a></td>
<td>420</td>
<td>369</td>
<td>806</td>
<td>149</td>
<td>70179</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/1317792" alt=""></td>
<td><a href="https://github.com/xndcn" target="_blank" rel="external">https://github.com/xndcn</a></td>
<td>33</td>
<td>86</td>
<td>67</td>
<td>8</td>
<td>67634</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/3935007" alt=""></td>
<td><a href="https://github.com/ojengwa" target="_blank" rel="external">https://github.com/ojengwa</a></td>
<td>293</td>
<td>469</td>
<td>67</td>
<td>8</td>
<td>49621</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/10103766" alt=""></td>
<td><a href="https://github.com/SergioChan" target="_blank" rel="external">https://github.com/SergioChan</a></td>
<td>47</td>
<td>372</td>
<td>982</td>
<td>598</td>
<td>42202</td>
</tr>
</tbody>
</table>
<p>365天，天天绿是种怎样的体验？</p>
<h3 id="中国用户榜单"><a href="#中国用户榜单" class="headerlink" title="中国用户榜单"></a>中国用户榜单</h3><p>这里只是通过location中”China”、”Shanghai”类似的关键词对中国用户进行区分，所以可能有遗漏的地方，还请谅解。此次统计的中国用户数据有18011</p>
<h4 id="Followers人数榜-1"><a href="#Followers人数榜-1" class="headerlink" title="Followers人数榜"></a>Followers人数榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/905434" alt=""></td>
<td><a href="https://github.com/ruanyf" target="_blank" rel="external">https://github.com/ruanyf</a></td>
<td>48</td>
<td>206</td>
<td>38200</td>
<td>0</td>
<td>1645</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/499550" alt=""></td>
<td><a href="https://github.com/yyx990803" target="_blank" rel="external">https://github.com/yyx990803</a></td>
<td>141</td>
<td>779</td>
<td>29200</td>
<td>90</td>
<td>2553</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/2503423" alt=""></td>
<td><a href="https://github.com/daimajia" target="_blank" rel="external">https://github.com/daimajia</a></td>
<td>63</td>
<td>2900</td>
<td>20000</td>
<td>241</td>
<td>21</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/470058" alt=""></td>
<td><a href="https://github.com/michaelliao" target="_blank" rel="external">https://github.com/michaelliao</a></td>
<td>61</td>
<td>81</td>
<td>19700</td>
<td>0</td>
<td>297</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/327019" alt=""></td>
<td><a href="https://github.com/JacksonTian" target="_blank" rel="external">https://github.com/JacksonTian</a></td>
<td>229</td>
<td>583</td>
<td>15500</td>
<td>151</td>
<td>805</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/1169522" alt=""></td>
<td><a href="https://github.com/Trinea" target="_blank" rel="external">https://github.com/Trinea</a></td>
<td>24</td>
<td>1500</td>
<td>14100</td>
<td>38</td>
<td>80</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/2267900" alt=""></td>
<td><a href="https://github.com/stormzhang" target="_blank" rel="external">https://github.com/stormzhang</a></td>
<td>5</td>
<td>1500</td>
<td>12800</td>
<td>91</td>
<td>9</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/97227" alt=""></td>
<td><a href="https://github.com/lifesinger" target="_blank" rel="external">https://github.com/lifesinger</a></td>
<td>2</td>
<td>278</td>
<td>12000</td>
<td>13</td>
<td>1</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/729648" alt=""></td>
<td><a href="https://github.com/cloudwu" target="_blank" rel="external">https://github.com/cloudwu</a></td>
<td>102</td>
<td>63</td>
<td>11700</td>
<td>1</td>
<td>690</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/472311" alt=""></td>
<td><a href="https://github.com/phodal" target="_blank" rel="external">https://github.com/phodal</a></td>
<td>254</td>
<td>1700</td>
<td>11100</td>
<td>15</td>
<td>5924</td>
</tr>
</tbody>
</table>
<h4 id="Following人数榜-1"><a href="#Following人数榜-1" class="headerlink" title="Following人数榜"></a>Following人数榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/3693121" alt=""></td>
<td><a href="https://github.com/fordream" target="_blank" rel="external">https://github.com/fordream</a></td>
<td>724</td>
<td>21</td>
<td>919</td>
<td>19800</td>
<td>1</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/17972943" alt=""></td>
<td><a href="https://github.com/Vermisse" target="_blank" rel="external">https://github.com/Vermisse</a></td>
<td>15</td>
<td>25</td>
<td>2300</td>
<td>10400</td>
<td>102</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/93859" alt=""></td>
<td><a href="https://github.com/technologiclee" target="_blank" rel="external">https://github.com/technologiclee</a></td>
<td>149</td>
<td>844</td>
<td>374</td>
<td>9500</td>
<td>6</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/15626022" alt=""></td>
<td><a href="https://github.com/shenzhoudance" target="_blank" rel="external">https://github.com/shenzhoudance</a></td>
<td>599</td>
<td>6</td>
<td>108</td>
<td>7700</td>
<td>2373</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/10573715" alt=""></td>
<td><a href="https://github.com/kotobukki" target="_blank" rel="external">https://github.com/kotobukki</a></td>
<td>15</td>
<td>68</td>
<td>111</td>
<td>7500</td>
<td>889</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/29220207" alt=""></td>
<td><a href="https://github.com/vincentpanqi" target="_blank" rel="external">https://github.com/vincentpanqi</a></td>
<td>1800</td>
<td>714</td>
<td>47</td>
<td>5600</td>
<td>102</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/1727724" alt=""></td>
<td><a href="https://github.com/ovwane" target="_blank" rel="external">https://github.com/ovwane</a></td>
<td>220</td>
<td>1100</td>
<td>120</td>
<td>5500</td>
<td>329</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/9153294" alt=""></td>
<td><a href="https://github.com/pisual" target="_blank" rel="external">https://github.com/pisual</a></td>
<td>39</td>
<td>62</td>
<td>917</td>
<td>4900</td>
<td>122</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/23236638" alt=""></td>
<td><a href="https://github.com/youkaichao" target="_blank" rel="external">https://github.com/youkaichao</a></td>
<td>39</td>
<td>0</td>
<td>58</td>
<td>4800</td>
<td>113</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/7576876" alt=""></td>
<td><a href="https://github.com/bloodycoder" target="_blank" rel="external">https://github.com/bloodycoder</a></td>
<td>73</td>
<td>34</td>
<td>162</td>
<td>4200</td>
<td>390</td>
</tr>
</tbody>
</table>
<h4 id="Stars榜-1"><a href="#Stars榜-1" class="headerlink" title="Stars榜"></a>Stars榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1041542" alt=""></td>
<td><a href="https://github.com/weimingtom" target="_blank" rel="external">https://github.com/weimingtom</a></td>
<td>2100</td>
<td>9100</td>
<td>172</td>
<td>1800</td>
<td>1724</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/2041398" alt=""></td>
<td><a href="https://github.com/jiangplus" target="_blank" rel="external">https://github.com/jiangplus</a></td>
<td>28</td>
<td>8800</td>
<td>85</td>
<td>115</td>
<td>13</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1024948" alt=""></td>
<td><a href="https://github.com/DavidAlphaFox" target="_blank" rel="external">https://github.com/DavidAlphaFox</a></td>
<td>346</td>
<td>7800</td>
<td>167</td>
<td>83</td>
<td>1122</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/480859" alt=""></td>
<td><a href="https://github.com/mayulu" target="_blank" rel="external">https://github.com/mayulu</a></td>
<td>12</td>
<td>7700</td>
<td>133</td>
<td>616</td>
<td>14</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/4370703" alt=""></td>
<td><a href="https://github.com/hzy87email" target="_blank" rel="external">https://github.com/hzy87email</a></td>
<td>73</td>
<td>7700</td>
<td>77</td>
<td>167</td>
<td>3</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1468284" alt=""></td>
<td><a href="https://github.com/se77en" target="_blank" rel="external">https://github.com/se77en</a></td>
<td>197</td>
<td>7600</td>
<td>119</td>
<td>455</td>
<td>0</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/12030169" alt=""></td>
<td><a href="https://github.com/JaredYeDH" target="_blank" rel="external">https://github.com/JaredYeDH</a></td>
<td>166</td>
<td>7400</td>
<td>45</td>
<td>636</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/10380759" alt=""></td>
<td><a href="https://github.com/xhs" target="_blank" rel="external">https://github.com/xhs</a></td>
<td>20</td>
<td>7200</td>
<td>43</td>
<td>119</td>
<td>10</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/1881113" alt=""></td>
<td><a href="https://github.com/paladin74" target="_blank" rel="external">https://github.com/paladin74</a></td>
<td>618</td>
<td>7100</td>
<td>52</td>
<td>901</td>
<td>1</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/3856" alt=""></td>
<td><a href="https://github.com/mrluanma" target="_blank" rel="external">https://github.com/mrluanma</a></td>
<td>12</td>
<td>7000</td>
<td>126</td>
<td>541</td>
<td>36</td>
</tr>
</tbody>
</table>
<h4 id="Reps榜-1"><a href="#Reps榜-1" class="headerlink" title="Reps榜"></a>Reps榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/10938976" alt=""></td>
<td><a href="https://github.com/skyformat99" target="_blank" rel="external">https://github.com/skyformat99</a></td>
<td>6000</td>
<td>143</td>
<td>98</td>
<td>3200</td>
<td>134</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/1203820" alt=""></td>
<td><a href="https://github.com/tempbottle" target="_blank" rel="external">https://github.com/tempbottle</a></td>
<td>4200</td>
<td>59</td>
<td>21</td>
<td>18</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/8662447" alt=""></td>
<td><a href="https://github.com/JamesLinus" target="_blank" rel="external">https://github.com/JamesLinus</a></td>
<td>4100</td>
<td>1600</td>
<td>89</td>
<td>3300</td>
<td>181</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/12955801" alt=""></td>
<td><a href="https://github.com/hu19891110" target="_blank" rel="external">https://github.com/hu19891110</a></td>
<td>3600</td>
<td>90</td>
<td>11</td>
<td>112</td>
<td>107</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/452743" alt=""></td>
<td><a href="https://github.com/WilliamRen" target="_blank" rel="external">https://github.com/WilliamRen</a></td>
<td>2900</td>
<td>3200</td>
<td>32</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/3414057" alt=""></td>
<td><a href="https://github.com/chagge" target="_blank" rel="external">https://github.com/chagge</a></td>
<td>2300</td>
<td>8</td>
<td>16</td>
<td>669</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/6813552" alt=""></td>
<td><a href="https://github.com/forging2012" target="_blank" rel="external">https://github.com/forging2012</a></td>
<td>2200</td>
<td>789</td>
<td>8</td>
<td>71</td>
<td>151</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1041542" alt=""></td>
<td><a href="https://github.com/weimingtom" target="_blank" rel="external">https://github.com/weimingtom</a></td>
<td>2100</td>
<td>9100</td>
<td>172</td>
<td>1800</td>
<td>1724</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/23429527" alt=""></td>
<td><a href="https://github.com/isuhao" target="_blank" rel="external">https://github.com/isuhao</a></td>
<td>2000</td>
<td>153</td>
<td>62</td>
<td>2700</td>
<td>282</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/5791117" alt=""></td>
<td><a href="https://github.com/ycaihua" target="_blank" rel="external">https://github.com/ycaihua</a></td>
<td>1900</td>
<td>109</td>
<td>38</td>
<td>589</td>
<td>133</td>
</tr>
</tbody>
</table>
<h4 id="Contribution榜-1"><a href="#Contribution榜-1" class="headerlink" title="Contribution榜"></a>Contribution榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1006477" alt=""></td>
<td><a href="https://github.com/felixonmars" target="_blank" rel="external">https://github.com/felixonmars</a></td>
<td>420</td>
<td>369</td>
<td>806</td>
<td>149</td>
<td>70179</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/10103766" alt=""></td>
<td><a href="https://github.com/SergioChan" target="_blank" rel="external">https://github.com/SergioChan</a></td>
<td>47</td>
<td>372</td>
<td>982</td>
<td>598</td>
<td>42202</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/12693644" alt=""></td>
<td><a href="https://github.com/dragon-yuan" target="_blank" rel="external">https://github.com/dragon-yuan</a></td>
<td>16</td>
<td>109</td>
<td>35</td>
<td>50</td>
<td>18591</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/8347202" alt=""></td>
<td><a href="https://github.com/fengss" target="_blank" rel="external">https://github.com/fengss</a></td>
<td>30</td>
<td>67</td>
<td>15</td>
<td>1</td>
<td>12560</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/9410171" alt=""></td>
<td><a href="https://github.com/xieguigang" target="_blank" rel="external">https://github.com/xieguigang</a></td>
<td>41</td>
<td>115</td>
<td>136</td>
<td>143</td>
<td>10999</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/9280577" alt=""></td>
<td><a href="https://github.com/csjunxu" target="_blank" rel="external">https://github.com/csjunxu</a></td>
<td>194</td>
<td>81</td>
<td>35</td>
<td>51</td>
<td>9935</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/559179" alt=""></td>
<td><a href="https://github.com/airyland" target="_blank" rel="external">https://github.com/airyland</a></td>
<td>183</td>
<td>1400</td>
<td>996</td>
<td>175</td>
<td>8852</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/11537812" alt=""></td>
<td><a href="https://github.com/yutiansut" target="_blank" rel="external">https://github.com/yutiansut</a></td>
<td>216</td>
<td>1100</td>
<td>298</td>
<td>8</td>
<td>7311</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/1826685" alt=""></td>
<td><a href="https://github.com/lloydzhou" target="_blank" rel="external">https://github.com/lloydzhou</a></td>
<td>92</td>
<td>556</td>
<td>52</td>
<td>69</td>
<td>6729</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/8784712" alt=""></td>
<td><a href="https://github.com/egoist" target="_blank" rel="external">https://github.com/egoist</a></td>
<td>647</td>
<td>2700</td>
<td>3600</td>
<td>40</td>
<td>6236</td>
</tr>
</tbody>
</table>
<h3 id="个人网站中顶级域名分布情况"><a href="#个人网站中顶级域名分布情况" class="headerlink" title="个人网站中顶级域名分布情况"></a>个人网站中顶级域名分布情况</h3><p><img src="https://data2.liuin.cn/2018-04-01-15225621477939.jpg" alt=""></p>
<h3 id="用户公布邮箱情况"><a href="#用户公布邮箱情况" class="headerlink" title="用户公布邮箱情况"></a>用户公布邮箱情况</h3><p><img src="https://data2.liuin.cn/2018-04-01-15225624252077.jpg" alt=""></p>
<h3 id="用户所在公司情况"><a href="#用户所在公司情况" class="headerlink" title="用户所在公司情况"></a>用户所在公司情况</h3><p>公布公司的前8</p>
<p><img src="https://data2.liuin.cn/2018-04-01-15225631364406.jpg" alt=""></p>
<p>云图</p>
<p><img src="https://data2.liuin.cn/2018-04-01-15225635127953.jpg" alt=""></p>
<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><h3 id="Stars榜-2"><a href="#Stars榜-2" class="headerlink" title="Stars榜"></a>Stars榜</h3><table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/freeCodeCamp/freeCodeCamp" target="_blank" rel="external">freeCodeCamp/freeCodeCamp</a></td>
<td><a href="https://github.com/freeCodeCamp" target="_blank" rel="external">freeCodeCamp</a></td>
<td>JavaScript</td>
<td>291895</td>
<td>13667</td>
<td>11334</td>
</tr>
<tr>
<td><a href="https://github.com/twbs/bootstrap" target="_blank" rel="external">twbs/bootstrap</a></td>
<td><a href="https://github.com/twbs" target="_blank" rel="external">twbs</a></td>
<td>CSS</td>
<td>123341</td>
<td>58717</td>
<td>17645</td>
</tr>
<tr>
<td><a href="https://github.com/EbookFoundation/free-programming-books" target="_blank" rel="external">EbookFoundation/free-programming-books</a></td>
<td><a href="https://github.com/EbookFoundation" target="_blank" rel="external">EbookFoundation</a></td>
<td></td>
<td>103480</td>
<td>26331</td>
<td>4634</td>
</tr>
<tr>
<td><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">tensorflow/tensorflow</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>C++</td>
<td>95028</td>
<td>60694</td>
<td>30887</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/react" target="_blank" rel="external">facebook/react</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>92602</td>
<td>17473</td>
<td>9773</td>
</tr>
<tr>
<td><a href="https://github.com/vuejs/vue" target="_blank" rel="external">vuejs/vue</a></td>
<td><a href="https://github.com/vuejs" target="_blank" rel="external">vuejs</a></td>
<td>JavaScript</td>
<td>89447</td>
<td>13129</td>
<td>2581</td>
</tr>
<tr>
<td><a href="https://github.com/sindresorhus/awesome" target="_blank" rel="external">sindresorhus/awesome</a></td>
<td><a href="https://github.com/sindresorhus" target="_blank" rel="external">sindresorhus</a></td>
<td></td>
<td>82141</td>
<td>10785</td>
<td>725</td>
</tr>
<tr>
<td><a href="https://github.com/getify/You-Dont-Know-JS" target="_blank" rel="external">getify/You-Dont-Know-JS</a></td>
<td><a href="https://github.com/getify" target="_blank" rel="external">getify</a></td>
<td></td>
<td>78848</td>
<td>14404</td>
<td>1465</td>
</tr>
<tr>
<td><a href="https://github.com/d3/d3" target="_blank" rel="external">d3/d3</a></td>
<td><a href="https://github.com/d3" target="_blank" rel="external">d3</a></td>
<td>JavaScript</td>
<td>74472</td>
<td>19024</td>
<td>4132</td>
</tr>
<tr>
<td><a href="https://github.com/airbnb/javascript" target="_blank" rel="external">airbnb/javascript</a></td>
<td><a href="https://github.com/airbnb" target="_blank" rel="external">airbnb</a></td>
<td>JavaScript</td>
<td>68833</td>
<td>13127</td>
<td>1607</td>
</tr>
</tbody>
</table>
<h3 id="Forks榜"><a href="#Forks榜" class="headerlink" title="Forks榜"></a>Forks榜</h3><table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/jtleek/datasharing" target="_blank" rel="external">jtleek/datasharing</a></td>
<td><a href="https://github.com/jtleek" target="_blank" rel="external">jtleek</a></td>
<td></td>
<td>4332</td>
<td>184409</td>
<td>29</td>
</tr>
<tr>
<td><a href="https://github.com/rdpeng/ProgrammingAssignment2" target="_blank" rel="external">rdpeng/ProgrammingAssignment2</a></td>
<td><a href="https://github.com/rdpeng" target="_blank" rel="external">rdpeng</a></td>
<td>R</td>
<td>528</td>
<td>110145</td>
<td>7</td>
</tr>
<tr>
<td><a href="https://github.com/octocat/Spoon-Knife" target="_blank" rel="external">octocat/Spoon-Knife</a></td>
<td><a href="https://github.com/octocat" target="_blank" rel="external">octocat</a></td>
<td>HTML</td>
<td>10043</td>
<td>97471</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">tensorflow/tensorflow</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>C++</td>
<td>95028</td>
<td>60694</td>
<td>30887</td>
</tr>
<tr>
<td><a href="https://github.com/twbs/bootstrap" target="_blank" rel="external">twbs/bootstrap</a></td>
<td><a href="https://github.com/twbs" target="_blank" rel="external">twbs</a></td>
<td>CSS</td>
<td>123341</td>
<td>58717</td>
<td>17645</td>
</tr>
<tr>
<td><a href="https://github.com/SmartThingsCommunity/SmartThingsPublic" target="_blank" rel="external">SmartThingsCommunity/SmartThingsPublic</a></td>
<td><a href="https://github.com/SmartThingsCommunity" target="_blank" rel="external">SmartThingsCommunity</a></td>
<td>Groovy</td>
<td>853</td>
<td>38018</td>
<td>2448</td>
</tr>
<tr>
<td><a href="https://github.com/rdpeng/RepData_PeerAssessment1" target="_blank" rel="external">rdpeng/RepData_PeerAssessment1</a></td>
<td><a href="https://github.com/rdpeng" target="_blank" rel="external">rdpeng</a></td>
<td></td>
<td>69</td>
<td>29883</td>
<td>13</td>
</tr>
<tr>
<td><a href="https://github.com/github/gitignore" target="_blank" rel="external">github/gitignore</a></td>
<td><a href="https://github.com/github" target="_blank" rel="external">github</a></td>
<td></td>
<td>63853</td>
<td>29259</td>
<td>2738</td>
</tr>
<tr>
<td><a href="https://github.com/angular/angular.js" target="_blank" rel="external">angular/angular.js</a></td>
<td><a href="https://github.com/angular" target="_blank" rel="external">angular</a></td>
<td>JavaScript</td>
<td>58232</td>
<td>28872</td>
<td>8755</td>
</tr>
<tr>
<td><a href="https://github.com/EbookFoundation/free-programming-books" target="_blank" rel="external">EbookFoundation/free-programming-books</a></td>
<td><a href="https://github.com/EbookFoundation" target="_blank" rel="external">EbookFoundation</a></td>
<td></td>
<td>103480</td>
<td>26331</td>
<td>4634</td>
</tr>
</tbody>
</table>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>stars排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/torvalds/linux" target="_blank" rel="external">torvalds/linux</a></td>
<td><a href="https://github.com/torvalds" target="_blank" rel="external">torvalds</a></td>
<td>C</td>
<td>57191</td>
<td>21032</td>
<td>744803</td>
</tr>
<tr>
<td><a href="https://github.com/firehol/netdata" target="_blank" rel="external">firehol/netdata</a></td>
<td><a href="https://github.com/firehol" target="_blank" rel="external">firehol</a></td>
<td>C</td>
<td>28607</td>
<td>2389</td>
<td>6690</td>
</tr>
<tr>
<td><a href="https://github.com/antirez/redis" target="_blank" rel="external">antirez/redis</a></td>
<td><a href="https://github.com/antirez" target="_blank" rel="external">antirez</a></td>
<td>C</td>
<td>28340</td>
<td>10916</td>
<td>6679</td>
</tr>
<tr>
<td><a href="https://github.com/git/git" target="_blank" rel="external">git/git</a></td>
<td><a href="https://github.com/git" target="_blank" rel="external">git</a></td>
<td>C</td>
<td>21665</td>
<td>12634</td>
<td>50674</td>
</tr>
<tr>
<td><a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="external">Bilibili/ijkplayer</a></td>
<td><a href="https://github.com/Bilibili" target="_blank" rel="external">Bilibili</a></td>
<td>C</td>
<td>18374</td>
<td>5191</td>
<td>2584</td>
</tr>
<tr>
<td><a href="https://github.com/php/php-src" target="_blank" rel="external">php/php-src</a></td>
<td><a href="https://github.com/php" target="_blank" rel="external">php</a></td>
<td>C</td>
<td>16996</td>
<td>4745</td>
<td>107206</td>
</tr>
<tr>
<td><a href="https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System" target="_blank" rel="external">SamyPesse/How-to-Make-a-Computer-Operating-System</a></td>
<td><a href="https://github.com/SamyPesse" target="_blank" rel="external">SamyPesse</a></td>
<td>C</td>
<td>16957</td>
<td>3015</td>
<td>243</td>
</tr>
<tr>
<td><a href="https://github.com/wg/wrk" target="_blank" rel="external">wg/wrk</a></td>
<td><a href="https://github.com/wg" target="_blank" rel="external">wg</a></td>
<td>C</td>
<td>15386</td>
<td>1245</td>
<td>72</td>
</tr>
<tr>
<td><a href="https://github.com/ggreer/the_silver_searcher" target="_blank" rel="external">ggreer/the_silver_searcher</a></td>
<td><a href="https://github.com/ggreer" target="_blank" rel="external">ggreer</a></td>
<td>C</td>
<td>14854</td>
<td>954</td>
<td>1974</td>
</tr>
<tr>
<td><a href="https://github.com/kripken/emscripten" target="_blank" rel="external">kripken/emscripten</a></td>
<td><a href="https://github.com/kripken" target="_blank" rel="external">kripken</a></td>
<td>C</td>
<td>14373</td>
<td>1704</td>
<td>18154</td>
</tr>
</tbody>
</table>
<p>forks排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/torvalds/linux" target="_blank" rel="external">torvalds/linux</a></td>
<td><a href="https://github.com/torvalds" target="_blank" rel="external">torvalds</a></td>
<td>C</td>
<td>57191</td>
<td>21032</td>
<td>744803</td>
</tr>
<tr>
<td><a href="https://github.com/git/git" target="_blank" rel="external">git/git</a></td>
<td><a href="https://github.com/git" target="_blank" rel="external">git</a></td>
<td>C</td>
<td>21665</td>
<td>12634</td>
<td>50674</td>
</tr>
<tr>
<td><a href="https://github.com/antirez/redis" target="_blank" rel="external">antirez/redis</a></td>
<td><a href="https://github.com/antirez" target="_blank" rel="external">antirez</a></td>
<td>C</td>
<td>28340</td>
<td>10916</td>
<td>6679</td>
</tr>
<tr>
<td><a href="https://github.com/arduino/Arduino" target="_blank" rel="external">arduino/Arduino</a></td>
<td><a href="https://github.com/arduino" target="_blank" rel="external">arduino</a></td>
<td>C</td>
<td>7936</td>
<td>6184</td>
<td>6649</td>
</tr>
<tr>
<td><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July" target="_blank" rel="external">julycoding/The-Art-Of-Programming-By-July</a></td>
<td><a href="https://github.com/julycoding" target="_blank" rel="external">julycoding</a></td>
<td>C</td>
<td>13544</td>
<td>5666</td>
<td>3630</td>
</tr>
<tr>
<td><a href="https://github.com/MarlinFirmware/Marlin" target="_blank" rel="external">MarlinFirmware/Marlin</a></td>
<td><a href="https://github.com/MarlinFirmware" target="_blank" rel="external">MarlinFirmware</a></td>
<td>C</td>
<td>3615</td>
<td>5340</td>
<td>9015</td>
</tr>
<tr>
<td><a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="external">Bilibili/ijkplayer</a></td>
<td><a href="https://github.com/Bilibili" target="_blank" rel="external">Bilibili</a></td>
<td>C</td>
<td>18374</td>
<td>5191</td>
<td>2584</td>
</tr>
<tr>
<td><a href="https://github.com/php/php-src" target="_blank" rel="external">php/php-src</a></td>
<td><a href="https://github.com/php" target="_blank" rel="external">php</a></td>
<td>C</td>
<td>16996</td>
<td>4745</td>
<td>107206</td>
</tr>
<tr>
<td><a href="https://github.com/esp8266/Arduino" target="_blank" rel="external">esp8266/Arduino</a></td>
<td><a href="https://github.com/esp8266" target="_blank" rel="external">esp8266</a></td>
<td>C</td>
<td>7063</td>
<td>4378</td>
<td>2697</td>
</tr>
<tr>
<td><a href="https://github.com/FFmpeg/FFmpeg" target="_blank" rel="external">FFmpeg/FFmpeg</a></td>
<td><a href="https://github.com/FFmpeg" target="_blank" rel="external">FFmpeg</a></td>
<td>C</td>
<td>10314</td>
<td>4377</td>
<td>90611</td>
</tr>
</tbody>
</table>
<h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><p>stars排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">tensorflow/tensorflow</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>C++</td>
<td>95028</td>
<td>60694</td>
<td>30887</td>
</tr>
<tr>
<td><a href="https://github.com/electron/electron" target="_blank" rel="external">electron/electron</a></td>
<td><a href="https://github.com/electron" target="_blank" rel="external">electron</a></td>
<td>C++</td>
<td>58531</td>
<td>7642</td>
<td>18669</td>
</tr>
<tr>
<td><a href="https://github.com/apple/swift" target="_blank" rel="external">apple/swift</a></td>
<td><a href="https://github.com/apple" target="_blank" rel="external">apple</a></td>
<td>C++</td>
<td>43250</td>
<td>6795</td>
<td>68510</td>
</tr>
<tr>
<td><a href="https://github.com/nwjs/nw.js" target="_blank" rel="external">nwjs/nw.js</a></td>
<td><a href="https://github.com/nwjs" target="_blank" rel="external">nwjs</a></td>
<td>C++</td>
<td>33478</td>
<td>3731</td>
<td>3188</td>
</tr>
<tr>
<td><a href="https://github.com/x64dbg/x64dbg" target="_blank" rel="external">x64dbg/x64dbg</a></td>
<td><a href="https://github.com/x64dbg" target="_blank" rel="external">x64dbg</a></td>
<td>C++</td>
<td>33242</td>
<td>684</td>
<td>3923</td>
</tr>
<tr>
<td><a href="https://github.com/bitcoin/bitcoin" target="_blank" rel="external">bitcoin/bitcoin</a></td>
<td><a href="https://github.com/bitcoin" target="_blank" rel="external">bitcoin</a></td>
<td>C++</td>
<td>30209</td>
<td>18101</td>
<td>16629</td>
</tr>
<tr>
<td><a href="https://github.com/google/protobuf" target="_blank" rel="external">google/protobuf</a></td>
<td><a href="https://github.com/google" target="_blank" rel="external">google</a></td>
<td>C++</td>
<td>24950</td>
<td>7150</td>
<td>5557</td>
</tr>
<tr>
<td><a href="https://github.com/BVLC/caffe" target="_blank" rel="external">BVLC/caffe</a></td>
<td><a href="https://github.com/BVLC" target="_blank" rel="external">BVLC</a></td>
<td>C++</td>
<td>23550</td>
<td>14390</td>
<td>4118</td>
</tr>
<tr>
<td><a href="https://github.com/opencv/opencv" target="_blank" rel="external">opencv/opencv</a></td>
<td><a href="https://github.com/opencv" target="_blank" rel="external">opencv</a></td>
<td>C++</td>
<td>23493</td>
<td>16901</td>
<td>23654</td>
</tr>
<tr>
<td><a href="https://github.com/rethinkdb/rethinkdb" target="_blank" rel="external">rethinkdb/rethinkdb</a></td>
<td><a href="https://github.com/rethinkdb" target="_blank" rel="external">rethinkdb</a></td>
<td>C++</td>
<td>20993</td>
<td>1665</td>
<td>33382</td>
</tr>
</tbody>
</table>
<p>forks排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">tensorflow/tensorflow</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>C++</td>
<td>95028</td>
<td>60694</td>
<td>30887</td>
</tr>
<tr>
<td><a href="https://github.com/bitcoin/bitcoin" target="_blank" rel="external">bitcoin/bitcoin</a></td>
<td><a href="https://github.com/bitcoin" target="_blank" rel="external">bitcoin</a></td>
<td>C++</td>
<td>30209</td>
<td>18101</td>
<td>16629</td>
</tr>
<tr>
<td><a href="https://github.com/opencv/opencv" target="_blank" rel="external">opencv/opencv</a></td>
<td><a href="https://github.com/opencv" target="_blank" rel="external">opencv</a></td>
<td>C++</td>
<td>23493</td>
<td>16901</td>
<td>23654</td>
</tr>
<tr>
<td><a href="https://github.com/BVLC/caffe" target="_blank" rel="external">BVLC/caffe</a></td>
<td><a href="https://github.com/BVLC" target="_blank" rel="external">BVLC</a></td>
<td>C++</td>
<td>23550</td>
<td>14390</td>
<td>4118</td>
</tr>
<tr>
<td><a href="https://github.com/electron/electron" target="_blank" rel="external">electron/electron</a></td>
<td><a href="https://github.com/electron" target="_blank" rel="external">electron</a></td>
<td>C++</td>
<td>58531</td>
<td>7642</td>
<td>18669</td>
</tr>
<tr>
<td><a href="https://github.com/google/protobuf" target="_blank" rel="external">google/protobuf</a></td>
<td><a href="https://github.com/google" target="_blank" rel="external">google</a></td>
<td>C++</td>
<td>24950</td>
<td>7150</td>
<td>5557</td>
</tr>
<tr>
<td><a href="https://github.com/apple/swift" target="_blank" rel="external">apple/swift</a></td>
<td><a href="https://github.com/apple" target="_blank" rel="external">apple</a></td>
<td>C++</td>
<td>43250</td>
<td>6795</td>
<td>68510</td>
</tr>
<tr>
<td><a href="https://github.com/cocos2d/cocos2d-x" target="_blank" rel="external">cocos2d/cocos2d-x</a></td>
<td><a href="https://github.com/cocos2d" target="_blank" rel="external">cocos2d</a></td>
<td>C++</td>
<td>11759</td>
<td>6496</td>
<td>36641</td>
</tr>
<tr>
<td><a href="https://github.com/ArduPilot/ardupilot" target="_blank" rel="external">ArduPilot/ardupilot</a></td>
<td><a href="https://github.com/ArduPilot" target="_blank" rel="external">ArduPilot</a></td>
<td>C++</td>
<td>3110</td>
<td>6153</td>
<td>31379</td>
</tr>
<tr>
<td><a href="https://github.com/dmlc/xgboost" target="_blank" rel="external">dmlc/xgboost</a></td>
<td><a href="https://github.com/dmlc" target="_blank" rel="external">dmlc</a></td>
<td>C++</td>
<td>11406</td>
<td>5192</td>
<td>3254</td>
</tr>
</tbody>
</table>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>stars排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">ReactiveX/RxJava</a></td>
<td><a href="https://github.com/ReactiveX" target="_blank" rel="external">ReactiveX</a></td>
<td>Java</td>
<td>32001</td>
<td>5594</td>
<td>5328</td>
</tr>
<tr>
<td><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="external">iluwatar/java-design-patterns</a></td>
<td><a href="https://github.com/iluwatar" target="_blank" rel="external">iluwatar</a></td>
<td>Java</td>
<td>31422</td>
<td>10072</td>
<td>2022</td>
</tr>
<tr>
<td><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="external">elastic/elasticsearch</a></td>
<td><a href="https://github.com/elastic" target="_blank" rel="external">elastic</a></td>
<td>Java</td>
<td>29931</td>
<td>10408</td>
<td>30528</td>
</tr>
<tr>
<td><a href="https://github.com/square/retrofit" target="_blank" rel="external">square/retrofit</a></td>
<td><a href="https://github.com/square" target="_blank" rel="external">square</a></td>
<td>Java</td>
<td>27182</td>
<td>5311</td>
<td>1569</td>
</tr>
<tr>
<td><a href="https://github.com/square/okhttp" target="_blank" rel="external">square/okhttp</a></td>
<td><a href="https://github.com/square" target="_blank" rel="external">square</a></td>
<td>Java</td>
<td>25870</td>
<td>6054</td>
<td>3147</td>
</tr>
<tr>
<td><a href="https://github.com/google/guava" target="_blank" rel="external">google/guava</a></td>
<td><a href="https://github.com/google" target="_blank" rel="external">google</a></td>
<td>Java</td>
<td>23154</td>
<td>5323</td>
<td>4676</td>
</tr>
<tr>
<td><a href="https://github.com/spring-projects/spring-boot" target="_blank" rel="external">spring-projects/spring-boot</a></td>
<td><a href="https://github.com/spring-projects" target="_blank" rel="external">spring-projects</a></td>
<td>Java</td>
<td>22927</td>
<td>17555</td>
<td>16129</td>
</tr>
<tr>
<td><a href="https://github.com/PhilJay/MPAndroidChart" target="_blank" rel="external">PhilJay/MPAndroidChart</a></td>
<td><a href="https://github.com/PhilJay" target="_blank" rel="external">PhilJay</a></td>
<td>Java</td>
<td>21393</td>
<td>5939</td>
<td>1938</td>
</tr>
<tr>
<td><a href="https://github.com/kdn251/interviews" target="_blank" rel="external">kdn251/interviews</a></td>
<td><a href="https://github.com/kdn251" target="_blank" rel="external">kdn251</a></td>
<td>Java</td>
<td>21348</td>
<td>3503</td>
<td>370</td>
</tr>
<tr>
<td><a href="https://github.com/bumptech/glide" target="_blank" rel="external">bumptech/glide</a></td>
<td><a href="https://github.com/bumptech" target="_blank" rel="external">bumptech</a></td>
<td>Java</td>
<td>21032</td>
<td>4132</td>
<td>2190</td>
</tr>
</tbody>
</table>
<p>forks排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/spring-projects/spring-boot" target="_blank" rel="external">spring-projects/spring-boot</a></td>
<td><a href="https://github.com/spring-projects" target="_blank" rel="external">spring-projects</a></td>
<td>Java</td>
<td>22927</td>
<td>17555</td>
<td>16129</td>
</tr>
<tr>
<td><a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="external">spring-projects/spring-framework</a></td>
<td><a href="https://github.com/spring-projects" target="_blank" rel="external">spring-projects</a></td>
<td>Java</td>
<td>20126</td>
<td>13328</td>
<td>16384</td>
</tr>
<tr>
<td><a href="https://github.com/apache/incubator-dubbo" target="_blank" rel="external">apache/incubator-dubbo</a></td>
<td><a href="https://github.com/apache" target="_blank" rel="external">apache</a></td>
<td>Java</td>
<td>17706</td>
<td>12714</td>
<td>2201</td>
</tr>
<tr>
<td><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="external">elastic/elasticsearch</a></td>
<td><a href="https://github.com/elastic" target="_blank" rel="external">elastic</a></td>
<td>Java</td>
<td>29931</td>
<td>10408</td>
<td>30528</td>
</tr>
<tr>
<td><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="external">iluwatar/java-design-patterns</a></td>
<td><a href="https://github.com/iluwatar" target="_blank" rel="external">iluwatar</a></td>
<td>Java</td>
<td>31422</td>
<td>10072</td>
<td>2022</td>
</tr>
<tr>
<td><a href="https://github.com/eugenp/tutorials" target="_blank" rel="external">eugenp/tutorials</a></td>
<td><a href="https://github.com/eugenp" target="_blank" rel="external">eugenp</a></td>
<td>Java</td>
<td>4950</td>
<td>8411</td>
<td>7809</td>
</tr>
<tr>
<td><a href="https://github.com/zxing/zxing" target="_blank" rel="external">zxing/zxing</a></td>
<td><a href="https://github.com/zxing" target="_blank" rel="external">zxing</a></td>
<td>Java</td>
<td>18000</td>
<td>7345</td>
<td>3425</td>
</tr>
<tr>
<td><a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="external">nostra13/Android-Universal-Image-Loader</a></td>
<td><a href="https://github.com/nostra13" target="_blank" rel="external">nostra13</a></td>
<td>Java</td>
<td>16040</td>
<td>6476</td>
<td>1025</td>
</tr>
<tr>
<td><a href="https://github.com/checkstyle/checkstyle" target="_blank" rel="external">checkstyle/checkstyle</a></td>
<td><a href="https://github.com/checkstyle" target="_blank" rel="external">checkstyle</a></td>
<td>Java</td>
<td>3597</td>
<td>6402</td>
<td>7658</td>
</tr>
<tr>
<td><a href="https://github.com/netty/netty" target="_blank" rel="external">netty/netty</a></td>
<td><a href="https://github.com/netty" target="_blank" rel="external">netty</a></td>
<td>Java</td>
<td>13422</td>
<td>6122</td>
<td>8723</td>
</tr>
</tbody>
</table>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>stars排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/vinta/awesome-python" target="_blank" rel="external">vinta/awesome-python</a></td>
<td><a href="https://github.com/vinta" target="_blank" rel="external">vinta</a></td>
<td>Python</td>
<td>47930</td>
<td>9270</td>
<td>1222</td>
</tr>
<tr>
<td><a href="https://github.com/rg3/youtube-dl" target="_blank" rel="external">rg3/youtube-dl</a></td>
<td><a href="https://github.com/rg3" target="_blank" rel="external">rg3</a></td>
<td>Python</td>
<td>35575</td>
<td>6532</td>
<td>16048</td>
</tr>
<tr>
<td><a href="https://github.com/toddmotto/public-apis" target="_blank" rel="external">toddmotto/public-apis</a></td>
<td><a href="https://github.com/toddmotto" target="_blank" rel="external">toddmotto</a></td>
<td>Python</td>
<td>35115</td>
<td>3319</td>
<td>1760</td>
</tr>
<tr>
<td><a href="https://github.com/jakubroztocil/httpie" target="_blank" rel="external">jakubroztocil/httpie</a></td>
<td><a href="https://github.com/jakubroztocil" target="_blank" rel="external">jakubroztocil</a></td>
<td>Python</td>
<td>34746</td>
<td>2362</td>
<td>965</td>
</tr>
<tr>
<td><a href="https://github.com/nvbn/thefuck" target="_blank" rel="external">nvbn/thefuck</a></td>
<td><a href="https://github.com/nvbn" target="_blank" rel="external">nvbn</a></td>
<td>Python</td>
<td>34601</td>
<td>1723</td>
<td>1463</td>
</tr>
<tr>
<td><a href="https://github.com/pallets/flask" target="_blank" rel="external">pallets/flask</a></td>
<td><a href="https://github.com/pallets" target="_blank" rel="external">pallets</a></td>
<td>Python</td>
<td>34411</td>
<td>10562</td>
<td>3205</td>
</tr>
<tr>
<td><a href="https://github.com/django/django" target="_blank" rel="external">django/django</a></td>
<td><a href="https://github.com/django" target="_blank" rel="external">django</a></td>
<td>Python</td>
<td>32956</td>
<td>13953</td>
<td>25601</td>
</tr>
<tr>
<td><a href="https://github.com/tensorflow/models" target="_blank" rel="external">tensorflow/models</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>Python</td>
<td>32262</td>
<td>17985</td>
<td>2109</td>
</tr>
<tr>
<td><a href="https://github.com/josephmisiti/awesome-machine-learning" target="_blank" rel="external">josephmisiti/awesome-machine-learning</a></td>
<td><a href="https://github.com/josephmisiti" target="_blank" rel="external">josephmisiti</a></td>
<td>Python</td>
<td>31793</td>
<td>7780</td>
<td>1033</td>
</tr>
<tr>
<td><a href="https://github.com/requests/requests" target="_blank" rel="external">requests/requests</a></td>
<td><a href="https://github.com/requests" target="_blank" rel="external">requests</a></td>
<td>Python</td>
<td>31508</td>
<td>5824</td>
<td>5416</td>
</tr>
</tbody>
</table>
<p>forks排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/tensorflow/models" target="_blank" rel="external">tensorflow/models</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>Python</td>
<td>32262</td>
<td>17985</td>
<td>2109</td>
</tr>
<tr>
<td><a href="https://github.com/shadowsocks/shadowsocks" target="_blank" rel="external">shadowsocks/shadowsocks</a></td>
<td><a href="https://github.com/shadowsocks" target="_blank" rel="external">shadowsocks</a></td>
<td>Python</td>
<td>24278</td>
<td>15499</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://github.com/django/django" target="_blank" rel="external">django/django</a></td>
<td><a href="https://github.com/django" target="_blank" rel="external">django</a></td>
<td>Python</td>
<td>32956</td>
<td>13953</td>
<td>25601</td>
</tr>
<tr>
<td><a href="https://github.com/scikit-learn/scikit-learn" target="_blank" rel="external">scikit-learn/scikit-learn</a></td>
<td><a href="https://github.com/scikit-learn" target="_blank" rel="external">scikit-learn</a></td>
<td>Python</td>
<td>27088</td>
<td>13623</td>
<td>22684</td>
</tr>
<tr>
<td><a href="https://github.com/ansible/ansible" target="_blank" rel="external">ansible/ansible</a></td>
<td><a href="https://github.com/ansible" target="_blank" rel="external">ansible</a></td>
<td>Python</td>
<td>29373</td>
<td>10728</td>
<td>36562</td>
</tr>
<tr>
<td><a href="https://github.com/pallets/flask" target="_blank" rel="external">pallets/flask</a></td>
<td><a href="https://github.com/pallets" target="_blank" rel="external">pallets</a></td>
<td>Python</td>
<td>34411</td>
<td>10562</td>
<td>3205</td>
</tr>
<tr>
<td><a href="https://github.com/keras-team/keras" target="_blank" rel="external">keras-team/keras</a></td>
<td><a href="https://github.com/keras-team" target="_blank" rel="external">keras-team</a></td>
<td>Python</td>
<td>27833</td>
<td>10213</td>
<td>4442</td>
</tr>
<tr>
<td><a href="https://github.com/udacity/fullstack-nanodegree-vm" target="_blank" rel="external">udacity/fullstack-nanodegree-vm</a></td>
<td><a href="https://github.com/udacity" target="_blank" rel="external">udacity</a></td>
<td>Python</td>
<td>202</td>
<td>9370</td>
<td>53</td>
</tr>
<tr>
<td><a href="https://github.com/vinta/awesome-python" target="_blank" rel="external">vinta/awesome-python</a></td>
<td><a href="https://github.com/vinta" target="_blank" rel="external">vinta</a></td>
<td>Python</td>
<td>47930</td>
<td>9270</td>
<td>1222</td>
</tr>
<tr>
<td><a href="https://github.com/odoo/odoo" target="_blank" rel="external">odoo/odoo</a></td>
<td><a href="https://github.com/odoo" target="_blank" rel="external">odoo</a></td>
<td>Python</td>
<td>9200</td>
<td>7889</td>
<td>115520</td>
</tr>
</tbody>
</table>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>stars排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/freeCodeCamp/freeCodeCamp" target="_blank" rel="external">freeCodeCamp/freeCodeCamp</a></td>
<td><a href="https://github.com/freeCodeCamp" target="_blank" rel="external">freeCodeCamp</a></td>
<td>JavaScript</td>
<td>291895</td>
<td>13667</td>
<td>11334</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/react" target="_blank" rel="external">facebook/react</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>92602</td>
<td>17473</td>
<td>9773</td>
</tr>
<tr>
<td><a href="https://github.com/vuejs/vue" target="_blank" rel="external">vuejs/vue</a></td>
<td><a href="https://github.com/vuejs" target="_blank" rel="external">vuejs</a></td>
<td>JavaScript</td>
<td>89447</td>
<td>13129</td>
<td>2581</td>
</tr>
<tr>
<td><a href="https://github.com/d3/d3" target="_blank" rel="external">d3/d3</a></td>
<td><a href="https://github.com/d3" target="_blank" rel="external">d3</a></td>
<td>JavaScript</td>
<td>74472</td>
<td>19024</td>
<td>4132</td>
</tr>
<tr>
<td><a href="https://github.com/airbnb/javascript" target="_blank" rel="external">airbnb/javascript</a></td>
<td><a href="https://github.com/airbnb" target="_blank" rel="external">airbnb</a></td>
<td>JavaScript</td>
<td>68833</td>
<td>13127</td>
<td>1607</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/react-native" target="_blank" rel="external">facebook/react-native</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>62128</td>
<td>14129</td>
<td>13166</td>
</tr>
<tr>
<td><a href="https://github.com/angular/angular.js" target="_blank" rel="external">angular/angular.js</a></td>
<td><a href="https://github.com/angular" target="_blank" rel="external">angular</a></td>
<td>JavaScript</td>
<td>58232</td>
<td>28872</td>
<td>8755</td>
</tr>
<tr>
<td><a href="https://github.com/jquery/jquery" target="_blank" rel="external">jquery/jquery</a></td>
<td><a href="https://github.com/jquery" target="_blank" rel="external">jquery</a></td>
<td>JavaScript</td>
<td>48560</td>
<td>15318</td>
<td>6316</td>
</tr>
<tr>
<td><a href="https://github.com/nodejs/node" target="_blank" rel="external">nodejs/node</a></td>
<td><a href="https://github.com/nodejs" target="_blank" rel="external">nodejs</a></td>
<td>JavaScript</td>
<td>47212</td>
<td>9904</td>
<td>21744</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/create-react-app" target="_blank" rel="external">facebook/create-react-app</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>46391</td>
<td>9259</td>
<td>1484</td>
</tr>
</tbody>
</table>
<p>forks排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/angular/angular.js" target="_blank" rel="external">angular/angular.js</a></td>
<td><a href="https://github.com/angular" target="_blank" rel="external">angular</a></td>
<td>JavaScript</td>
<td>58232</td>
<td>28872</td>
<td>8755</td>
</tr>
<tr>
<td><a href="https://github.com/udacity/frontend-nanodegree-resume" target="_blank" rel="external">udacity/frontend-nanodegree-resume</a></td>
<td><a href="https://github.com/udacity" target="_blank" rel="external">udacity</a></td>
<td>JavaScript</td>
<td>915</td>
<td>25814</td>
<td>84</td>
</tr>
<tr>
<td><a href="https://github.com/d3/d3" target="_blank" rel="external">d3/d3</a></td>
<td><a href="https://github.com/d3" target="_blank" rel="external">d3</a></td>
<td>JavaScript</td>
<td>74472</td>
<td>19024</td>
<td>4132</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/react" target="_blank" rel="external">facebook/react</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>92602</td>
<td>17473</td>
<td>9773</td>
</tr>
<tr>
<td><a href="https://github.com/jquery/jquery" target="_blank" rel="external">jquery/jquery</a></td>
<td><a href="https://github.com/jquery" target="_blank" rel="external">jquery</a></td>
<td>JavaScript</td>
<td>48560</td>
<td>15318</td>
<td>6316</td>
</tr>
<tr>
<td><a href="https://github.com/nightscout/cgm-remote-monitor" target="_blank" rel="external">nightscout/cgm-remote-monitor</a></td>
<td><a href="https://github.com/nightscout" target="_blank" rel="external">nightscout</a></td>
<td>JavaScript</td>
<td>439</td>
<td>15228</td>
<td>4505</td>
</tr>
<tr>
<td><a href="https://github.com/mrdoob/three.js" target="_blank" rel="external">mrdoob/three.js</a></td>
<td><a href="https://github.com/mrdoob" target="_blank" rel="external">mrdoob</a></td>
<td>JavaScript</td>
<td>40668</td>
<td>15152</td>
<td>22927</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/react-native" target="_blank" rel="external">facebook/react-native</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>62128</td>
<td>14129</td>
<td>13166</td>
</tr>
<tr>
<td><a href="https://github.com/freeCodeCamp/freeCodeCamp" target="_blank" rel="external">freeCodeCamp/freeCodeCamp</a></td>
<td><a href="https://github.com/freeCodeCamp" target="_blank" rel="external">freeCodeCamp</a></td>
<td>JavaScript</td>
<td>291895</td>
<td>13667</td>
<td>11334</td>
</tr>
<tr>
<td><a href="https://github.com/vuejs/vue" target="_blank" rel="external">vuejs/vue</a></td>
<td><a href="https://github.com/vuejs" target="_blank" rel="external">vuejs</a></td>
<td>JavaScript</td>
<td>89447</td>
<td>13129</td>
<td>2581</td>
</tr>
</tbody>
</table>
<h3 id="语言使用比例"><a href="#语言使用比例" class="headerlink" title="语言使用比例"></a>语言使用比例</h3><p>stars 超过100的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229847469176.jpg" alt=""></p>
<p>stars 超过1000的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229848318605.jpg" alt=""></p>
<p>stars 超过10000的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229848710272.jpg" alt=""></p>
<p>forks 超过100的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229849187089.jpg" alt=""></p>
<p>forks 超过1000的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229849529776.jpg" alt=""></p>
<p>forks 超过10000的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229849860861.jpg" alt=""></p>
<p>欢迎大家Star我的<a href="https://github.com/Sixzeroo/GithubCrawler" target="_blank" rel="external">Github项目</a></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Github分布式爬虫——实现]]></title>
      <url>/2018/04/05/Github%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>使用Redis实现分布式爬虫</p>
<a id="more"></a>
<p>主要使用Scrapy、Redis、MongoDB实现，Scrapy作为异步爬虫框架、Redis实现分布式以及Cookies池的存储，MongoDB实现底层数据存储</p>
<h2 id="分布式示意图"><a href="#分布式示意图" class="headerlink" title="分布式示意图"></a>分布式示意图</h2><p><img src="https://data2.liuin.cn/2018-03-25-15219437958574.jpg" alt=""></p>
<p>主机中安装Redis和MongoDB</p>
<p>Redis中存储：</p>
<ul>
<li>所有Scrapy爬虫的待爬取队列</li>
<li>去重用的已发出Request指纹</li>
</ul>
<p>MongoDB负责最终数据的存储</p>
<p>可创建多个Scrapy从机进行爬取，实现分布式。</p>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul>
<li>共享爬取队列实现分布式</li>
<li>生成Request的指纹实现分布式的去重</li>
<li>随机指定User-Agent</li>
<li>通过Redis实现Cookies池并进行更新</li>
</ul>
<h2 id="分布式实现"><a href="#分布式实现" class="headerlink" title="分布式实现"></a>分布式实现</h2><h3 id="请求队列"><a href="#请求队列" class="headerlink" title="请求队列"></a>请求队列</h3><p>各个分布式爬虫共同维护一个Request请求队列，使用的是Redis的list。队列可以实现FIFO，LIFO或者优先级队列。</p>
<p>爬取的时候一开始使用的是优先级队列，但是后来因为不好设置优先级，导致最后都是User的item，导致Rep的饥饿现象，所以到后面换成FIFO队列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FifoQueue</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="string">"""Per-spider FIFO queue"""</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""Return the length of the queue"""</span></div><div class="line">        <span class="keyword">return</span> self.server.llen(self.key)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, request)</span>:</span></div><div class="line">        <span class="string">"""Push a request"""</span></div><div class="line">        self.server.lpush(self.key, self._encode_request(request))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self, timeout=<span class="number">0</span>)</span>:</span></div><div class="line">        <span class="string">"""Pop a request"""</span></div><div class="line">        <span class="keyword">if</span> timeout &gt; <span class="number">0</span>:</div><div class="line">            data = self.server.brpop(self.key, timeout)</div><div class="line">            <span class="keyword">if</span> isinstance(data, tuple):</div><div class="line">                data = data[<span class="number">1</span>]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            data = self.server.rpop(self.key)</div><div class="line">        <span class="keyword">if</span> data:</div><div class="line">            <span class="keyword">return</span> self._decode_request(data)</div></pre></td></tr></table></figure>
<p>同时需要设置request队列的大小限制，因为爬取Github页面的时候可能爬取一个star列表以后就会产生几十个Request，这样很容易把Redis的队列挤爆：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">enqueue_request</span><span class="params">(self, request)</span>:</span></div><div class="line">    <span class="comment"># set upper limit of request num</span></div><div class="line">    <span class="keyword">if</span> len(self.queue) &gt; REQUEST_NUM:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.dont_filter <span class="keyword">and</span> self.df.request_seen(request):</div><div class="line">        self.df.log(request, self.spider)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">if</span> self.stats:</div><div class="line">        self.stats.inc_value(<span class="string">'scheduler/enqueued/redis'</span>, spider=self.spider)</div><div class="line">    self.queue.push(request)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>没有设置数量大小的时候，1G内存的主机跑一个多小时之后就挂掉了：</p>
<p><img src="https://data2.liuin.cn/2018-03-21-15215617499559.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-20-15215615819339.jpg" alt=""></p>
<h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><p>为了使用共同的请求队列，所以需要重写Scheduler，重写的Scheduler负责把要爬取的request放入队列以及从队列中找出request进行爬取</p>
<h3 id="去重集合"><a href="#去重集合" class="headerlink" title="去重集合"></a>去重集合</h3><p>本地爬虫通常需要解决一个去重问题，通常使用的是数据库查询，爬取之前判断url是否请求过。分布式爬虫就是在这个的基础上共用一个去重集合，使用的是Redis的set。</p>
<p>判断一个Request是否已经爬取过，这里不是使用url，因为不同的url可能代表的是同一种资源，比如：<code>http://www.example.com/query?cat=222&amp;id=111</code>和<code>http://www.example.com/query?cat=222&amp;id=111</code> 事实表示的是一个东西。此外，发出的Request还可能与当时的Cookie有关，因为里面还会有用户信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 计算Request指纹判断有没有重复</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_seen</span><span class="params">(self, request)</span>:</span></div><div class="line">    fp = self.request_fingerprint(request)</div><div class="line">    <span class="keyword">if</span> USEBLOOMFILTER == <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">if</span> self.bf.isContains(fp):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.bf.insert(fp)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="comment"># This returns the number of values added, zero if already exists.</span></div><div class="line">        added = self.server.sadd(self.key, fp)</div><div class="line">        <span class="keyword">return</span> added == <span class="number">0</span></div></pre></td></tr></table></figure>
<p>这里采用的方案是生成一个Request的指纹，实际上是把request的url，method和指定的header使用sha1算法得到一个hash值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Request 指纹计算方法</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_fingerprint</span><span class="params">(request, include_headers=None)</span>:</span></div><div class="line">    <span class="keyword">if</span> include_headers:</div><div class="line">        include_headers = tuple(to_bytes(h.lower())</div><div class="line">                                 <span class="keyword">for</span> h <span class="keyword">in</span> sorted(include_headers))</div><div class="line">    cache = _fingerprint_cache.setdefault(request, &#123;&#125;)</div><div class="line">    <span class="keyword">if</span> include_headers <span class="keyword">not</span> <span class="keyword">in</span> cache:</div><div class="line">        fp = hashlib.sha1()</div><div class="line">        fp.update(to_bytes(request.method))</div><div class="line">        fp.update(to_bytes(canonicalize_url(request.url)))</div><div class="line">        fp.update(request.body <span class="keyword">or</span> <span class="string">b''</span>)</div><div class="line">        <span class="keyword">if</span> include_headers:</div><div class="line">            <span class="keyword">for</span> hdr <span class="keyword">in</span> include_headers:</div><div class="line">                <span class="keyword">if</span> hdr <span class="keyword">in</span> request.headers:</div><div class="line">                    fp.update(hdr)</div><div class="line">                    <span class="keyword">for</span> v <span class="keyword">in</span> request.headers.getlist(hdr):</div><div class="line">                        fp.update(v)</div><div class="line">        cache[include_headers] = fp.hexdigest()</div><div class="line">    <span class="keyword">return</span> cache[include_headers]</div></pre></td></tr></table></figure>
<h2 id="反反爬虫策略"><a href="#反反爬虫策略" class="headerlink" title="反反爬虫策略"></a>反反爬虫策略</h2><h3 id="随机User-Agent"><a href="#随机User-Agent" class="headerlink" title="随机User-Agent"></a>随机User-Agent</h3><p>使用中间件实现随机User-Agent，随机替换掉request的header的User-Agent参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitHubUserAgentMiddleware</span><span class="params">(UserAgentMiddleware)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></div><div class="line">        agent = random.choice(agents)</div><div class="line">        request.headers[<span class="string">'User-Agent'</span>] = agent</div></pre></td></tr></table></figure>
<h3 id="Cookies池"><a href="#Cookies池" class="headerlink" title="Cookies池"></a>Cookies池</h3><p>首先使用多账号模拟登录，获取到很多已登录账号的cookies，放入到Redis的hashset中，各个爬虫共用这一个Cookies池。爬虫同样实现一个中间件，替换Request的Cookies。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Cookie 中间件</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitHubCookieMiddleware</span><span class="params">(RetryMiddleware)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,settings)</span>:</span></div><div class="line">        RetryMiddleware.__init__(self,settings)</div><div class="line">        self.rconn = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, db=<span class="number">3</span>)</div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></div><div class="line">        <span class="keyword">return</span> cls(crawler.settings)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></div><div class="line">        keys = self.rconn.hkeys(REDIS_COOKIE)</div><div class="line">        <span class="keyword">if</span>(len(keys) == <span class="number">0</span>):</div><div class="line">            print(<span class="string">"cookies don't work!"</span>)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        key = random.choice(keys)</div><div class="line">        <span class="comment"># 获取最新cookie</span></div><div class="line">        value = self.rconn.hget(REDIS_COOKIE, key)</div><div class="line">        <span class="keyword">if</span>( isinstance(value, bytes) ):</div><div class="line">            value = value.decode(<span class="string">'utf-8'</span>)</div><div class="line">        cookies = json.loads(value)</div><div class="line">        request.cookies = cookies</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一个为了了解分布式工作原理而做的一个小的项目，其中很多地方存在缺陷，欢迎大家在Github上留建议：</p>
<p><a href="https://github.com/Sixzeroo/GithubCrawler" target="_blank" rel="external">https://github.com/Sixzeroo/GithubCrawler</a></p>
<p>同时也可以查看下一篇关于Github用户和仓库数据分析的文章</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 题解——Redundant Connection II]]></title>
      <url>/2018/03/28/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Redundant-Connection-II/</url>
      <content type="html"><![CDATA[<p>LeetCode 题解——Redundant Connection II</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个有向图，求其有向的最小生成树（除了根节点之外所有的节点都有一条入边指向它），同时给出的有向图刚好只多出一条边</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>前一道题是求只多出一条边的无向图的最小生成树，使用并查集很容易就能够求解。</p>
<p>这一道有向图的题就比较复杂一点了，有向图的最小生成树又叫最小树形图，常规算法是使用<a href="https://www.liuin.cn/2017/03/25/%E5%88%9D%E8%AF%86-%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95/">朱刘算法</a>。这里因为只多出一条边，所以不用这么麻烦。</p>
<p>总共有三种情况：</p>
<ol>
<li>有环，但是没有入度为2的节点</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-03-28-15222211302563.jpg" alt=""></p>
<ol>
<li>有环，同时有入度为2的节点</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-03-28-15222211412345.jpg" alt=""></p>
<ol>
<li>无环，有入度为2的节点</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-03-28-15222211561578.jpg" alt=""></p>
<p>第一种情况，按照无向图的处理方式进行就行了，使用并查集返回最后一条形成环的边。</p>
<p>后面两种情况，首先要找到入度为2的节点，选出指向这个节点的两条边，处理完其他的边以后处理这两条边，使用并查集找出最后一个连接的两个节点已经在同一集合中的边</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> par[<span class="number">3000</span>];</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">            par[i] = i;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> par[x] = find(par[x]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></div><div class="line">    &#123;</div><div class="line">        x = find(x);</div><div class="line">        y = find(y);</div><div class="line">        <span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</div><div class="line">        par[y] = x;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 并查集</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findRedundantDirectedConnection(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</div><div class="line">        <span class="keyword">int</span> len = edges.size();</div><div class="line">        init(len);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegre(len, <span class="number">0</span>), outdegre(len, <span class="number">0</span>);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; problem_edge;</div><div class="line">        <span class="keyword">int</span> node = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 统计入度，找到入度为2的点</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:edges)</div><div class="line">        &#123;</div><div class="line">            indegre[i[<span class="number">1</span>]]++;</div><div class="line">            <span class="keyword">if</span>(indegre[i[<span class="number">1</span>]] == <span class="number">2</span>) node = i[<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:edges)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i[<span class="number">1</span>] == node)</div><div class="line">            &#123;</div><div class="line">                problem_edge.push_back(i);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 有环的情况</span></div><div class="line">            <span class="keyword">int</span> a = find(i[<span class="number">0</span>]), b= find(i[<span class="number">1</span>]);</div><div class="line">            <span class="keyword">if</span>(a == b) </div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">            unite(i[<span class="number">0</span>], i[<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 无环的情况，从入度为2的节点入手</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:problem_edge)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> a = find(i[<span class="number">0</span>]), b= find(i[<span class="number">1</span>]);</div><div class="line">            <span class="keyword">if</span>(a == b) <span class="keyword">return</span> i;</div><div class="line">            <span class="keyword">else</span> unite(a,b);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析——内存分配]]></title>
      <url>/2018/03/23/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      <content type="html"><![CDATA[<p>内存分配是程序需要解决的一个大问题，也应该是剖析一个程序的源码最基础最关键的部分之一。</p>
<a id="more"></a>
<p>Redis的内存分配主要是在C语言中对内存处理的函数：malloc、realloc、free的基础加了一些封装和异常的处理。</p>
<p>其特点主要有以下三点：</p>
<ol>
<li>添加对使用内存的统计，在分配和释放内存的时候都会更新记录使用内存的量</li>
<li>支持线程安全模式，通过锁的机制对use_memory进行控制，避免其出现脏数据的可能</li>
<li>增添对内存溢出的处理</li>
</ol>
<p>首先Redis源码中与内存分配相关的以下全局变量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>;    <span class="comment">// 使用的内存大小</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> zmalloc_thread_safe = <span class="number">0</span>;   <span class="comment">// 线程安全模式状态</span></div><div class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;   <span class="comment">// 为此服务器</span></div></pre></td></tr></table></figure></p>
<h2 id="内存分配相关功能函数"><a href="#内存分配相关功能函数" class="headerlink" title="内存分配相关功能函数"></a>内存分配相关功能函数</h2><p>Redis中和内存分配相关的功能函数主要有以下这些：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void *zmalloc(size_t size);   </div><div class="line">void *zcalloc(size_t size);</div><div class="line">void *zrealloc(void *ptr, size_t size);</div><div class="line">void zfree(void *ptr);</div><div class="line">char *zstrdup(const char *s);  // 封装的字符复制函数</div><div class="line">size_t zmalloc_used_memory(void);   // 获取使用的内存大小</div><div class="line">void zmalloc_enable_thread_safeness(void);    // 开启线程安全模式</div><div class="line">void zmalloc_set_oom_handler(void (*oom_handler)(size_t));   // 自定义的内存溢出处理方法</div><div class="line">float zmalloc_get_fragmentation_ratio(size_t rss);  // 使用内存和所给内存之比</div><div class="line">size_t zmalloc_get_rss(void);  // 获取rss信息</div><div class="line">size_t zmalloc_get_private_dirty(void);   // 获取实际物理分配的内存</div></pre></td></tr></table></figure></p>
<h2 id="内存申请与调整"><a href="#内存申请与调整" class="headerlink" title="内存申请与调整"></a>内存申请与调整</h2><p>Redis中和内存申请相关的函数主要是zmalloc、zcalloc和zrealloc，分别是对C语言中的malloc、calloc和realloc的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对malloc进行封装，加上异常处理和内存统计</span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="comment">// 多申请的内存用于存储次块空间大小</span></div><div class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</div><div class="line"></div><div class="line">    <span class="comment">// 内存溢出</span></div><div class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</div><div class="line">    <span class="comment">// 进行内存统计</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</div><div class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size+PREFIX_SIZE);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</div><div class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 封装重新分配内存函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="keyword">void</span> *realptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">size_t</span> oldsize;</div><div class="line">    <span class="keyword">void</span> *newptr;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zmalloc(size);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="comment">// 原来所使用空间的大小</span></div><div class="line">    oldsize = zmalloc_size(ptr);</div><div class="line">    <span class="comment">// 重新分配新的空间</span></div><div class="line">    newptr = <span class="built_in">realloc</span>(ptr,size);</div><div class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</div><div class="line"></div><div class="line">    <span class="comment">// 更新保存的使用内存值</span></div><div class="line">    update_zmalloc_stat_free(oldsize);</div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(newptr));</div><div class="line">    <span class="keyword">return</span> newptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</div><div class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</div><div class="line">    newptr = <span class="built_in">realloc</span>(realptr,size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</div><div class="line"></div><div class="line">    *((<span class="keyword">size_t</span>*)newptr) = size;</div><div class="line">    update_zmalloc_stat_free(oldsize);</div><div class="line">    update_zmalloc_stat_alloc(size);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先要注意的是对内存溢出的处理，可以自定义处理函数，其默认的处理方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 默认溢出处理方法</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zmalloc_default_oom</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"zmalloc: Out of memory trying to allocate %zu bytes\n"</span>,</div><div class="line">        size);</div><div class="line">    fflush(<span class="built_in">stderr</span>);</div><div class="line">    <span class="built_in">abort</span>();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 内存溢出处理方法</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*zmalloc_oom_handler)</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= zmalloc_default_oom;</div></pre></td></tr></table></figure>
<p>然后我们可以看到每次在调整内存的时候，都会对全局变量use_memory进行改变，调整是以<code>sizeof(long)</code>的整数倍进行调整的。在改变use_memory的时候会判断是否在线程安全模式下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 更新使用的内存数量值</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) do &#123; \</span></div><div class="line">    size_t _n = (__n); \</div><div class="line">    <span class="comment">// _n调整为size(long)的整数倍</span></div><div class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</div><div class="line">    <span class="comment">// 线程安全模式，原子性增加使用内存大小 （加锁）</span></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \</div><div class="line">        update_zmalloc_stat_add(_n); \</div><div class="line">    <span class="comment">// 不使用线程安全模式，直接增加</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123; \</div><div class="line">        used_memory += _n; \</div><div class="line">    &#125; \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_add(__n) do &#123; \</span></div><div class="line">    pthread_mutex_lock(&amp;used_memory_mutex); \</div><div class="line">    used_memory += (__n); \</div><div class="line">    pthread_mutex_unlock(&amp;used_memory_mutex); \</div><div class="line">&#125; while(0)</div></pre></td></tr></table></figure>
<h2 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h2><p>内存释放部分和申请部分类似，主要是对free函数的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取内存占用空间大小</span></div><div class="line"><span class="keyword">size_t</span> zmalloc_size(<span class="keyword">void</span> *ptr) &#123;</div><div class="line">    <span class="comment">// 减去统计内存大小的部分</span></div><div class="line">    <span class="keyword">void</span> *realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</div><div class="line">    <span class="keyword">size_t</span> size = *((<span class="keyword">size_t</span>*)realptr);</div><div class="line">    <span class="comment">/* Assume at least that all the allocations are padded at sizeof(long) by</span></div><div class="line">     * the underlying allocator. */</div><div class="line">    <span class="comment">// 调整为sizeof(long)的整数倍，方便对齐</span></div><div class="line">    <span class="keyword">if</span> (size&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) size += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(size&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>));</div><div class="line">    <span class="keyword">return</span> size+PREFIX_SIZE;</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">// 封装对系统的free调用</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="keyword">void</span> *realptr;</div><div class="line">    <span class="keyword">size_t</span> oldsize;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="comment">// 减少对内存的计数</span></div><div class="line">    update_zmalloc_stat_free(zmalloc_size(ptr));</div><div class="line">    <span class="built_in">free</span>(ptr);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</div><div class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</div><div class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</div><div class="line">    <span class="built_in">free</span>(realptr);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对use_memory的操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 释放内存以后对内存空间统计变量的改变</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_free(__n) do &#123; \</span></div><div class="line">    size_t _n = (__n); \</div><div class="line">    <span class="comment">// 以sizeof(long)的整数倍进行调整</span></div><div class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</div><div class="line">    <span class="comment">// 线程安全模式</span></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \</div><div class="line">        update_zmalloc_stat_sub(_n); \</div><div class="line">    &#125; <span class="keyword">else</span> &#123; \</div><div class="line">        used_memory -= _n; \</div><div class="line">    &#125; \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><p>除了最基本的一些内存分配的函数以外，还实现了一些辅助函数(如复制字符串、获取已经使用内存的大小）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 复制字符串操作</span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</div><div class="line">    <span class="keyword">size_t</span> l = <span class="built_in">strlen</span>(s)+<span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> *p = zmalloc(l);</div><div class="line"></div><div class="line">    <span class="comment">// 调用字符复制函数</span></div><div class="line">    <span class="built_in">memcpy</span>(p,s,l);</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取已经使用的内存大小</span></div><div class="line"><span class="keyword">size_t</span> zmalloc_used_memory(<span class="keyword">void</span>) &#123;</div><div class="line">    <span class="keyword">size_t</span> um;</div><div class="line"></div><div class="line">    <span class="comment">// 线程安全模式</span></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__ATOMIC_RELAXED) || defined(HAVE_ATOMIC)</span></div><div class="line">        um = update_zmalloc_stat_add(<span class="number">0</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        pthread_mutex_lock(&amp;used_memory_mutex);</div><div class="line">        um = used_memory;</div><div class="line">        pthread_mutex_unlock(&amp;used_memory_mutex);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 非线程安全情况下，直接赋值</span></div><div class="line">        um = used_memory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> um;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 源码剖析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析——跳跃表]]></title>
      <url>/2018/03/22/Redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>Redis使用跳跃表作为有序集合键的底层实现之一，跳跃表(skiplist)是一种有序数据结构,它通过在每个节点中维持多个指向其他节点的指针,从而达到快速访问节点的目的。</p>
<a id="more"></a>
<p>跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找,还可以通过顺序性操作来批量处理节点。在大部分情况下,跳跃表的效率可以和平衡树相媲美,并且因为跳跃表的实现比平衡树要来得更为简单,所以有不少程序都使用跳跃表来代替平衡树。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>一个跳跃表的整体结构如下：<br><img src="https://data2.liuin.cn/2018-03-22-15217053998776.jpg" alt=""></p>
<h3 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h3><p>跳跃表节点的数据结构定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 跳跃表节点</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplistNode &#123;</div><div class="line">    robj *obj;   <span class="comment">// 保存的值</span></div><div class="line">    <span class="keyword">double</span> score;  <span class="comment">// 节点分值</span></div><div class="line">    <span class="keyword">struct</span> zskiplistNode *backward;  <span class="comment">// 后退指针</span></div><div class="line">    <span class="comment">// 层</span></div><div class="line">    <span class="keyword">struct</span> zskiplistLevel &#123;    </div><div class="line">        <span class="keyword">struct</span> zskiplistNode *forward;   <span class="comment">// 前进指针</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;   <span class="comment">// 跨度</span></div><div class="line">    &#125; level[];</div><div class="line">&#125; zskiplistNode;</div></pre></td></tr></table></figure></p>
<ul>
<li>层：level数组包含多个元素,每个元素都包含一个指向其他节点的指针,程序可以通过这些层来加快访问其他节点的速度,一般来说,层的数量越多,访问其他节点的速度就越快</li>
<li>前进指针：每个层都有一个指向表尾方向的前进指针,用于从表头向表尾方向访问节点</li>
<li>跨度：表示两个节点之间的距离（前进指针指向节点和当前节点的距离）</li>
<li>后退指针：用于从表尾向表头访问节点</li>
<li>score分值：跳跃表中所有的节点按照分值进行排序</li>
<li>obj：保存的成员，一般为sds数据结构</li>
</ul>
<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 跳跃表</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplist &#123;</div><div class="line">    <span class="keyword">struct</span> zskiplistNode *header, *tail; <span class="comment">// 头结点、尾节点</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;  <span class="comment">// 长度</span></div><div class="line">    <span class="keyword">int</span> level; <span class="comment">// 最高层节点的层数</span></div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure>
<p>跳跃表记录了头结点和尾结点的指针、长度（即跳跃表中节点数目）和层数最大的节点的层数，注意表头节点的层高并不计算在内。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="创建跳跃表"><a href="#创建跳跃表" class="headerlink" title="创建跳跃表"></a>创建跳跃表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建跳跃表节点</span></div><div class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</div><div class="line">    <span class="comment">// 分配内存空间</span></div><div class="line">    zskiplistNode *zn = zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> zskiplistLevel));</div><div class="line">    <span class="comment">// 初始化</span></div><div class="line">    zn-&gt;score = score;</div><div class="line">    zn-&gt;obj = obj;</div><div class="line">    <span class="keyword">return</span> zn;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建跳跃表</span></div><div class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    zskiplist *zsl;</div><div class="line"></div><div class="line">    <span class="comment">// 分配内存空间</span></div><div class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</div><div class="line">    zsl-&gt;level = <span class="number">1</span>;</div><div class="line">    zsl-&gt;length = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 表头为32层的空节点，每一层都指向NULL</span></div><div class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</div><div class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</div><div class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</div><div class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">return</span> zsl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见：</p>
<ul>
<li>创建的跳跃表的初识level层数值为1</li>
<li>刚创建的跳跃表的头结点是一个有32层的空节点，其中每一层的forward都是NULL</li>
</ul>
<h3 id="跳跃表插入节点"><a href="#跳跃表插入节点" class="headerlink" title="跳跃表插入节点"></a>跳跃表插入节点</h3><p>跳跃表插入节点的部分有些复杂，需要改变节点前后节点的forward、backward指针以及长度等信息。其基本思想是：使用update表记录新节点在各层中forward指针指向它的节点，然后插入，同时改变这些复杂的指向关系。</p>
<p>其中rank数组是用来记录每一个节点再整个节点表中的排位信息，其是通过每层中的跨度计算得来的。</p>
<p>新插入的节点的层数是通过幂次定律决定的一个1-32的数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回一个1-32的层数值，使用幂次定律，越大的数出现的概率越小</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</div><div class="line">    <span class="comment">// 使用幂次定律，1/4概率</span></div><div class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</div><div class="line">        level += <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 跳跃表插入节点</span></div><div class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    <span class="comment">// 记录每一个节点的排位信息</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</div><div class="line">    <span class="keyword">int</span> i, level;</div><div class="line"></div><div class="line">    redisAssert(!isnan(score));</div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="comment">// 查找插入位置，从最高的层开始</span></div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></div><div class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</div><div class="line">        <span class="comment">// 遍历跳跃表</span></div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            <span class="comment">// 对比分值</span></div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                    <span class="comment">// 对比成员</span></div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>))) &#123;</div><div class="line">            <span class="comment">// 计算排位</span></div><div class="line">            rank[i] += x-&gt;level[i].span;</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 第i层将要和新节点连接的节点</span></div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* we assume the key is not already inside, since we allow duplicated</span></div><div class="line">     * scores, and the re-insertion of score and redis object should never</div><div class="line">     * happen since the caller of zslInsert() should test in the hash table</div><div class="line">     * if the element is already inside or not. */</div><div class="line">    <span class="comment">// 获取层数</span></div><div class="line">    level = zslRandomLevel();</div><div class="line">    <span class="comment">// 新的层数比原来所以节点的层数都大</span></div><div class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 初始化未使用的层</span></div><div class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</div><div class="line">            rank[i] = <span class="number">0</span>;</div><div class="line">            update[i] = zsl-&gt;header;</div><div class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</div><div class="line">        &#125;</div><div class="line">        zsl-&gt;level = level;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 创建指定层数的新节点</span></div><div class="line">    x = zslCreateNode(level,score,obj);</div><div class="line">    <span class="comment">// 使用update中的信息将为新的节点建立连接</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</div><div class="line">        <span class="comment">// 设置新节点的forward</span></div><div class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</div><div class="line">        <span class="comment">// 前面的节点的forward指向新节点</span></div><div class="line">        update[i]-&gt;level[i].forward = x;</div><div class="line"></div><div class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></div><div class="line">        <span class="comment">// 更新跨节点数量</span></div><div class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</div><div class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* increment span for untouched levels */</span></div><div class="line">    <span class="comment">// 没有和新节点接触的节点的跨度也要加一</span></div><div class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        update[i]-&gt;level[i].span++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 更新后退指针（新节点的后退指针+前面一个节点的后退指针）</span></div><div class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</div><div class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</div><div class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        zsl-&gt;tail = x;</div><div class="line">    <span class="comment">// 更新长度</span></div><div class="line">    zsl-&gt;length++;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="跳跃表删除节点"><a href="#跳跃表删除节点" class="headerlink" title="跳跃表删除节点"></a>跳跃表删除节点</h3><p>删除节点的方法差不多就是插入节点方法的反向操作，首先找到目标节点（通过update数组记录沿途节点），接触forward指针关系，更新跳跃表的层数和长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank */</span></div><div class="line"><span class="comment">// 跳跃表内部删除节点，update数组为forward指向本节点的数组</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslDeleteNode</span><span class="params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="comment">// 解除forward关系</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123;</div><div class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="number">1</span>;</div><div class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            update[i]-&gt;level[i].span -= <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 更新backward指针</span></div><div class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward) &#123;</div><div class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x-&gt;backward;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        zsl-&gt;tail = x-&gt;backward;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果删除的节点是层数最大的节点，则更新跳跃表的最大层数</span></div><div class="line">    <span class="keyword">while</span>(zsl-&gt;level &gt; <span class="number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level<span class="number">-1</span>].forward == <span class="literal">NULL</span>)</div><div class="line">        zsl-&gt;level--;</div><div class="line">    <span class="comment">// 跳跃表长度减一</span></div><div class="line">    zsl-&gt;length--;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Delete an element with matching score/object from the skiplist. */</span></div><div class="line"><span class="comment">// 跳跃表删除节点</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslDelete</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历跳跃表，找到目标节点，并记录沿途节点</span></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>)))</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* We may have multiple elements with the same score, what we need</span></div><div class="line">     * is to find the element with both the right score and object. */</div><div class="line">    <span class="comment">// 只有在分值和对象都相同的时候才删除</span></div><div class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</div><div class="line">    <span class="keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; equalStringObjects(x-&gt;obj,obj)) &#123;</div><div class="line">        zslDeleteNode(zsl, x, update);</div><div class="line">        zslFreeNode(x);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="跳跃表查找节点"><a href="#跳跃表查找节点" class="headerlink" title="跳跃表查找节点"></a>跳跃表查找节点</h3><p>跳跃表中查找节点相关的操作主要有获取排名、依据排名获取信息。其基本思想和插入节点找到插入位置一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通过分值和对象值获取排位信息，以1为起始值</span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *o)</span> </span>&#123;</div><div class="line">    zskiplistNode *x;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rank = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="comment">// 从最高层依次往下</span></div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,o) &lt;= <span class="number">0</span>))) &#123;</div><div class="line">            <span class="comment">// 排位增加</span></div><div class="line">            rank += x-&gt;level[i].span;</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* x might be equal to zsl-&gt;header, so test if obj is non-NULL */</span></div><div class="line">        <span class="comment">// 对象和分数值都相等</span></div><div class="line">        <span class="keyword">if</span> (x-&gt;obj &amp;&amp; equalStringObjects(x-&gt;obj,o)) &#123;</div><div class="line">            <span class="keyword">return</span> rank;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Finds an element by its rank. The rank argument needs to be 1-based. */</span></div><div class="line"><span class="comment">// 通过排位获取节点</span></div><div class="line"><span class="function">zskiplistNode* <span class="title">zslGetElementByRank</span><span class="params">(zskiplist *zsl, <span class="keyword">unsigned</span> <span class="keyword">long</span> rank)</span> </span>&#123;</div><div class="line">    zskiplistNode *x;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> traversed = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="comment">// 从最高层依次往下找</span></div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt;= rank)</div><div class="line">        &#123;</div><div class="line">            traversed += x-&gt;level[i].span;</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 找到相应的节点</span></div><div class="line">        <span class="keyword">if</span> (traversed == rank) &#123;</div><div class="line">            <span class="keyword">return</span> x;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用一张图能够简单表示这种查找行为，例如找到5这个节点：</p>
<p><img src="https://data2.liuin.cn/2018-03-22-56782.png" alt="56782"></p>
]]></content>
      
        <categories>
            
            <category> 源码剖析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析——链表和字典]]></title>
      <url>/2018/03/20/Redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>链表和字典（dict）是比较常用的数据结构，但是C语言在底层并没有内置这种数据结构，这里通过源码查看这两个数据结构在Redis底层的实现</p>
<a id="more"></a>
<h2 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h2><p>Redis底层使用的是一个双端链表</p>
<p>链表节点结构定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 双端链表节点</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> listNode &#123;</div><div class="line">    <span class="keyword">struct</span> listNode *prev;  <span class="comment">// 前置节点</span></div><div class="line">    <span class="keyword">struct</span> listNode *next;  <span class="comment">// 后置节点</span></div><div class="line">    <span class="keyword">void</span> *value;   <span class="comment">// 节点值</span></div><div class="line">&#125; listNode;</div></pre></td></tr></table></figure></p>
<p>链表迭代器结构定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 双端链表迭代器</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> listIter &#123;</div><div class="line">    listNode *next; <span class="comment">// 迭代的指针</span></div><div class="line">    <span class="keyword">int</span> direction;  <span class="comment">// 迭代的方向</span></div><div class="line">&#125; listIter;</div></pre></td></tr></table></figure></p>
<p>通过迭代器可以比较容易对整个链表进行遍历，从而轻松实现查找等功能。</p>
<p>链表结构定义<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 双端链表</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">list</span> &#123;</div><div class="line">    listNode *head;  <span class="comment">// 头结点</span></div><div class="line">    listNode *tail;  <span class="comment">// 尾节点</span></div><div class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);  <span class="comment">// 节点值复制函数，可指定复制的方法</span></div><div class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);  <span class="comment">// 节点值释放函数</span></div><div class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);  <span class="comment">// 节点值对比函数</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;   <span class="comment">// 链表中所包含的节点数量</span></div><div class="line">&#125; <span class="built_in">list</span>;</div></pre></td></tr></table></figure></p>
<p>Redis底层中所包含的链表API都是对链表常用功能的实现，比如说插入、删除、搜索等，这里不在解释。</p>
<p>Redis的链表实现的特点有如下几个：</p>
<ul>
<li>双端，方便向前和向后便利</li>
<li>多态，链表节点使用void*指针来保存节点值,并且可以通过1ist结构的dup、free、 match三个属性为节点值设置类型特定函数,所以链表可以用于保存各种不同类型的值。</li>
</ul>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典,又称为符号表( symbol table)、关联数组( associative array)或映射(map),是种用于<strong>保存键值对(key- value pair)的抽象数据结构</strong>。</p>
<p>字典在Reds中的应用相当广泛,比如 Redis的数据库就是使用字典来作为底层实现的,对数据库的增、删、查、改操作也是构建在对字典的操作之上的。</p>
<h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><p>Redis的字典用哈希表作为底层实现，哈希表中含有哈希表节点，而每一个哈希表节点就保存了字典中的一个键值对。</p>
<blockquote>
<p>哈希表</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictht &#123;</div><div class="line">    dictEntry **table;  <span class="comment">// 哈希表的节点数组</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size; <span class="comment">// 哈希表大小</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;  <span class="comment">// 哈希表的大小掩码，用于计算索引值，总等于size-1</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used; <span class="comment">// 哈希表中含有的节点数</span></div><div class="line">&#125; dictht;</div></pre></td></tr></table></figure>
<p>sizemask属性的值总是等于size-1,这个属性和哈希值一起决定一个键应该被放到tab1e数组的哪个索引上面。</p>
<blockquote>
<p>哈希表节点</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 哈希表节点</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictEntry &#123;</div><div class="line">    <span class="keyword">void</span> *key;  <span class="comment">// 键  </span></div><div class="line">    <span class="keyword">union</span> &#123;  </div><div class="line">        <span class="keyword">void</span> *val;</div><div class="line">        <span class="keyword">uint64_t</span> u64;</div><div class="line">        <span class="keyword">int64_t</span> s64;</div><div class="line">        <span class="keyword">double</span> d;</div><div class="line">    &#125; v;   <span class="comment">// 值</span></div><div class="line">    <span class="keyword">struct</span> dictEntry *next;  <span class="comment">// 下一个哈希表结点，形成链表</span></div><div class="line">&#125; dictEntry;</div></pre></td></tr></table></figure>
<p>Redis中哈希表解决冲突的方法是拉链法，所以其中有next属性指向另一个哈希表节点的指针,这个指针可以将多个哈希值相同的键值对连接在一次,以此来解决键冲突( collision)的问题。</p>
<blockquote>
<p>字典</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dict &#123;</div><div class="line">    dictType *type;  <span class="comment">// 类型特定函数</span></div><div class="line">    <span class="keyword">void</span> *privdata;  <span class="comment">// 私有数据</span></div><div class="line">    dictht ht[<span class="number">2</span>];   <span class="comment">// 含有两个哈希表</span></div><div class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">// rehash 索引，当rehash不再运行的时候，值为-1</span></div><div class="line">    <span class="keyword">int</span> iterators;  <span class="comment">// 现在正在运行的迭代器数量</span></div><div class="line">&#125; dict;</div></pre></td></tr></table></figure>
<p>type属性和 privata属性是针对不同类型的键值对,为创建多态字典而设置的；ht属性是一个包含两个项的数组,数组中的每个项都是一个 dictht哈希表,一般情况下,字典只使用ht[0]哈希表,ht[1]哈希表只会在对ht[0]哈希表进行 rehash时使用。</p>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>把一个新的键值对加入到字典中，首先要根据key计算出哈希值和索引值，然后把新的哈希节点加到哈希表数组的指定索引上面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 计算哈希值</span></div><div class="line">    h = dictHashKey(d, key);</div><div class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</div><div class="line">        <span class="comment">// 计算索引值</span></div><div class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</div><div class="line">        <span class="comment">/* Search if this slot does not already contain the given key */</span></div><div class="line">        <span class="comment">// 查找key是否存在</span></div><div class="line">        he = d-&gt;ht[table].table[idx];</div><div class="line">        <span class="keyword">while</span>(he) &#123;</div><div class="line">            <span class="keyword">if</span> (dictCompareKeys(d, key, he-&gt;key))</div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">            he = he-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>Redis使用的是Murmur算法计算哈希值的，这种算法的优点在于,即使输人的键是有规律的,算法仍能给出一个很好的随机分布性,并且算法的计算速度也非常快。</p>
<h3 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h3><p>Redis采用的是链地址法( separate chaining)解决键冲突的，每个哈希表节点都有个next指针,多个哈希表节点可以用next指针构成一个单向链表,被分配到同一个索引上的多个节点可以用这个单向链表连接起来,这就解决了键冲突的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Allocate the memory and store the new entry */</span></div><div class="line">ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</div><div class="line">entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</div><div class="line">entry-&gt;next = ht-&gt;table[index];  <span class="comment">// 把新的哈希节点加入到哈希数组索引处，并放在链表的头结点处</span></div><div class="line">ht-&gt;table[index] = entry;</div><div class="line">ht-&gt;used++;</div></pre></td></tr></table></figure>
<p><img src="https://data2.liuin.cn/2018-03-20-15215263654971.jpg" alt=""></p>
<h3 id="重新散列（rehash）"><a href="#重新散列（rehash）" class="headerlink" title="重新散列（rehash）"></a>重新散列（rehash）</h3><p>当dict不断进行添加或删除等操作的时候，所保存的键值对也会不断的增加或者减少。为了使哈希表的负载因子（load factor）维持在合理的范围内，此时就需要对哈希表的大小进行相应的扩展或者收缩。</p>
<p>这个工作通过重新散列（rehash）来进行，执行的主要步骤如下：</p>
<ul>
<li>为dict的ht[1]哈希表分配合适的空间，空间的大小取决于要执行的操作和ht[0]哈希表中键值对的数量</li>
<li>对所有在ht[0]中的键值对重新计算哈希索引值，将他们转移到ht[1]中</li>
<li>释放ht[0]，将ht[1]设置为ht[0]</li>
</ul>
<p>其中负载因子的计算公式为：<code>load_factor = ht[0].used / ht[0].size</code></p>
<blockquote>
<p>渐进式rehash</p>
</blockquote>
<p>在进行rehash的过程中需要将所有的键值对从ht[0]迁移到ht[1]中，如果键值对的数量比较大的话，就会导致Redis需要停止一段时间的服务才能够完成这些操作，所以为了避免对服务性能造成影响，rehash并不是一次性的、集中式地完成的，而是分多次、渐进式完成的。</p>
<p>具体的步骤如下：</p>
<ul>
<li>为ht[1]分配空间，同时保留ht[0]和ht[1]两个哈希表</li>
<li>在dict中维持一个索引计数变量rehashldx，将其值设为0，表示开始rehash（不工作是为-1）</li>
<li>在rehash是，每对dict进行一次操作的时候，除了进行制定操作外还要ht[0]哈希表中rehashldx索引上的索引键值对转移的ht[1]上，完成以后将rehashldx加一</li>
<li>当完成了所有ht[0]到ht[1]键值对的转移工作时，表示完成了rehash，此时将rehashldx的值设为-1</li>
</ul>
<p>在渐进式rehash的过程中，dict同时拥有两个hash表，所以dict的删除、查找、更新等操作会在两个哈希表上同时进行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在rehash期间每进行一次操作，迁移一个索引中所有的键值对</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></div><div class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</div><div class="line">        dictEntry *de, *nextde;</div><div class="line"></div><div class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></div><div class="line">         * elements because ht[0].used != 0 */</div><div class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</div><div class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</div><div class="line">            d-&gt;rehashidx++;</div><div class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</div><div class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></div><div class="line">        <span class="comment">// 对每一个键值对重新计算hash值、index值，进行迁移</span></div><div class="line">        <span class="keyword">while</span>(de) &#123;</div><div class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</div><div class="line"></div><div class="line">            nextde = de-&gt;next;</div><div class="line">            <span class="comment">/* Get the index in the new hash table */</span></div><div class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</div><div class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</div><div class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</div><div class="line">            d-&gt;ht[<span class="number">0</span>].used--;</div><div class="line">            d-&gt;ht[<span class="number">1</span>].used++;</div><div class="line">            de = nextde;</div><div class="line">        &#125;</div><div class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</div><div class="line">        d-&gt;rehashidx++; <span class="comment">// 将rehashldx的值加一</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></div><div class="line">    <span class="comment">// 完成渐进式rehash工作</span></div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</div><div class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</div><div class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</div><div class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</div><div class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* More to rehash... */</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 源码剖析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析——简单动态字符串(SDS)]]></title>
      <url>/2018/03/19/Redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2-SDS/</url>
      <content type="html"><![CDATA[<p>解析Redis的一个底层数据结构——简单动态数组，讨论起优点和不足</p>
<a id="more"></a>
<p>Redis没有直接使用C语言传统的字符串表示(以空字符结尾的字符数组),而是自己构建了一种名为<strong>简单动态字符串</strong>( simple dynamic string,SDS)的抽象类型,并将SDS用作 Redis的默认字符串表示。现在作者把这一个部分抽出来，单独做了一个项目，地址在<a href="https://github.com/antirez/sds" target="_blank" rel="external">这里</a></p>
<h2 id="数据结构定义定义"><a href="#数据结构定义定义" class="headerlink" title="数据结构定义定义"></a>数据结构定义定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sdshdr &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;   <span class="comment">// buf数组中已经使用的字节数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>;  <span class="comment">// buf数组中未使用的字节数量</span></div><div class="line">    <span class="keyword">char</span> buf[];         <span class="comment">// 字节数组，保存字符</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>SDS遵循C字符串以空字符结尾的惯例,保存空字符的1字节空间不计算在SDS的1en属性里面,并且为空字符分配额外的1字节空间,以及添加空字符到字符串末尾等操作</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><h3 id="获取字符串长度是常数级复杂度"><a href="#获取字符串长度是常数级复杂度" class="headerlink" title="获取字符串长度是常数级复杂度"></a>获取字符串长度是常数级复杂度</h3><p>C语言中获取字符串的长度需要把整个字符串都遍历一遍，而对于SDS来说，只需要访问len属性，将时间复杂度从O（N）降低到了O（1）</p>
<h3 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h3><p>除了获取字符串长度的复杂度高之外,C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出( buffer overflow)。C语言字符串进行拼接的时候如果不对原来的字符串分配足够的空间，容易造成溢出。</p>
<p>与C字符串不同,SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性:当SDS API需要对SDS进行修改时,API会先检查SDS的空间是否满足修改所需的要求,如果不满足的话,API会自动将SDS的空间扩展至执行修改所需的大小,然后才执行实际的修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 追加长度为len的字符串到buf的末尾</span></div><div class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh;</div><div class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</div><div class="line"></div><div class="line">    <span class="comment">// 扩展sds空间，确保其至少含有len+1个空间可以放置字符串</span></div><div class="line">    s = sdsMakeRoomFor(s,len);</div><div class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    <span class="comment">// 复制字符串</span></div><div class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</div><div class="line">    <span class="comment">// 更新长度</span></div><div class="line">    sh-&gt;len = curlen+len;</div><div class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>-len;</div><div class="line">    s[curlen+len] = <span class="string">'\0'</span>;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h3><p>C语言中，每次对字符串进行修改都要进行内存的重新分配，在SDS中使用<strong>空间预分配和惰性空间释放</strong>来减少内存重新分配的次数</p>
<blockquote>
<p>空间预分配</p>
</blockquote>
<p>SDS在执行空间扩展的时候将执行以下策略：</p>
<ul>
<li>如果对SDS进行修改之后,SDS的长度(也即是1en属性的值)将小于1MB,那么程序分配和1en属性同样大小的未使用空间,这时SDs1en属性的值将和free属性的值相同。</li>
<li>如果对SDs进行修改之后,SDS的长度将大于等于1MB,那么程序会分配1MB的未使用空间。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对sds中buf的长度进行扩展，至少有addlen+1长度的剩余空间</span></div><div class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh, *newsh;</div><div class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</div><div class="line">    <span class="keyword">size_t</span> len, newlen;</div><div class="line"></div><div class="line">    <span class="comment">// 目前剩余空间足够</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</div><div class="line">    len = sdslen(s);</div><div class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    newlen = (len+addlen);</div><div class="line">    <span class="comment">// 分配两倍空间</span></div><div class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</div><div class="line">        newlen *= <span class="number">2</span>;</div><div class="line">    <span class="comment">// 分配1M空间</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        newlen += SDS_MAX_PREALLOC;</div><div class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+newlen+<span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 更新剩余空间</span></div><div class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</div><div class="line">    <span class="keyword">return</span> newsh-&gt;buf;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>惰性空间释放</p>
</blockquote>
<p>惰性空间释放用于优化SDS的字符串缩短操作:当SDS的API需要缩短SDS保存的字符串时,程序并不立即使用内存重分配来回收缩短后多出来的字节,而是使用free属性将这些字节的数量记录起来,并等待将来使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 移除所有在s中出现过的cset字符</span></div><div class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    <span class="keyword">char</span> *start, *end, *sp, *ep;</div><div class="line">    <span class="keyword">size_t</span> len;</div><div class="line"></div><div class="line">    sp = start = s;</div><div class="line">    ep = end = s+sdslen(s)<span class="number">-1</span>;</div><div class="line">    <span class="keyword">while</span>(sp &lt;= end &amp;&amp; <span class="built_in">strchr</span>(cset, *sp)) sp++;</div><div class="line">    <span class="keyword">while</span>(ep &gt; start &amp;&amp; <span class="built_in">strchr</span>(cset, *ep)) ep--;</div><div class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep-sp)+<span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (sh-&gt;buf != sp) memmove(sh-&gt;buf, sp, len);</div><div class="line">    sh-&gt;buf[len] = <span class="string">'\0'</span>;</div><div class="line">    <span class="comment">// 并没有释放buf空间，而是增加free数量</span></div><div class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>+(sh-&gt;len-len);</div><div class="line">    sh-&gt;len = len;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>C字符串中的字符必须符合某种编码方式，并且除了字符串的末尾处，字符串里面不能包含空字符。使得C字符串只能保存文本数据,而不能保存像图片、音频、视频、压缩文件这样的二进制数据。</p>
<p>Redis可以适用于各种不同的使用场景,SDS的API都是二进制安全的(binary-safe),所有 SDS API都会以处理二进制的方式来处理SDs存放在buf数组里的数据</p>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><h3 id="API返回后不能确定内部是否重新分配了空间"><a href="#API返回后不能确定内部是否重新分配了空间" class="headerlink" title="API返回后不能确定内部是否重新分配了空间"></a>API返回后不能确定内部是否重新分配了空间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s = sdscat(s, <span class="string">"Hello world"</span>);</div></pre></td></tr></table></figure>
<p>s既是参数，又作为了返回值，原因是我们在调用sdscat函数之前不确定s的剩余空间是否足够分配出data长度的字节，如果不够的话，内部会重新malloc空间，然后把目前的sds包括头部全部挪过去，这样的话如果我们没有把返回的地址重新赋值给s,那么s实际上是失效的。</p>
]]></content>
      
        <categories>
            
            <category> 源码剖析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识Redis]]></title>
      <url>/2018/03/19/%E5%88%9D%E8%AF%86Redis/</url>
      <content type="html"><![CDATA[<p>这篇文章是我在认识Redis过程中的一些笔记</p>
<a id="more"></a>
<h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>官网的介绍：</p>
<blockquote>
<p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.</p>
</blockquote>
<p>简单来说就是一个数据存储在内存中的一个key-value存储系统。</p>
<p>通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。而键（key）只能是字符串类型（String）</p>
<h2 id="Redis有什么优势"><a href="#Redis有什么优势" class="headerlink" title="Redis有什么优势"></a>Redis有什么优势</h2><h3 id="支持多种数据结构k"><a href="#支持多种数据结构k" class="headerlink" title="支持多种数据结构k"></a>支持多种数据结构k</h3><p>key-value系统中的值支持多种数据结构：字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)。使得我们使用的时候更加方便，更容易和已有的代码进行整合</p>
<h3 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h3><p>redis使用rdb和aof做数据的持久化存储。主从数据同时，生成rdb文件，并利用缓冲区添加新的数据更新操作做对应的同步。将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</p>
<h3 id="性能好"><a href="#性能好" class="headerlink" title="性能好"></a>性能好</h3><p>因为数据是存储在内存中，所以读写速度非常高。Redis能读的速度是110000次/s,写的速度是81000次/s 。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>Redis的所有操作都是原子的，同时支持几个操作合并以后的原子性</p>
<h3 id="丰富的特性"><a href="#丰富的特性" class="headerlink" title="丰富的特性"></a>丰富的特性</h3><p>支持pulish/subscribe、key过期等特性</p>
<h2 id="Redis有什么缺点"><a href="#Redis有什么缺点" class="headerlink" title="Redis有什么缺点"></a>Redis有什么缺点</h2><h3 id="使用内存，资源有限"><a href="#使用内存，资源有限" class="headerlink" title="使用内存，资源有限"></a>使用内存，资源有限</h3><p>因为数据存储在内存中，单台机器的存储数据量跟机器本身的内存大小有很大的关系。虽然redis本身有key过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。</p>
<h2 id="Redis-适用场景"><a href="#Redis-适用场景" class="headerlink" title="Redis 适用场景"></a>Redis 适用场景</h2><p>Redis因为其性能非常，所以很多在普通数据上运行不够理想的功能使用Redis都能够得到比较好的效果</p>
<h3 id="需要快速排序的相关应用"><a href="#需要快速排序的相关应用" class="headerlink" title="需要快速排序的相关应用"></a>需要快速排序的相关应用</h3><p>像排行榜、过期项目这些功能需要我们快速排序并进行更新，我们就可以使用到Redis</p>
<h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p>在很多普通数据库中实现一个计数器的功能往往会遇到写入敏感等一些问题。这个在Redis中能够有很好的解决：Redis支持原子递增（atomic increment）</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Redis能够替代memcached，让你的缓存从只能存储数据变得能够更新数据，因此你不再需要每次都重新生成数据了。</p>
<h2 id="安装及使用"><a href="#安装及使用" class="headerlink" title="安装及使用"></a>安装及使用</h2><p>这里可以参考官方文档或者<a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="external">菜鸟教程</a></p>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《C++ Primer》笔记 高级主题部分]]></title>
      <url>/2018/03/18/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98%E9%83%A8%E5%88%86/</url>
      <content type="html"><![CDATA[<p>《C++ Primer》笔记 高级主题部分，时间关系只看了其中一部分</p>
<a id="more"></a>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>大型程序往往会使用多个独立开发的库,这些库又会定义大量的全局名字,如类、函数和模板等。当应用程序用到多个供应商提供的库时,不可避免地会发生某些名字相互冲突的情况。多个库将名字放置在全局命名空间中将引发命名空间污染( namespace pollution)。</p>
<p><strong>命名空间</strong>( namespace)为防止名字冲突提供了更加可控的机制。<strong>命名空间分割了全局命名空间,其中每个命名空间是一个作用域</strong>。通过在某个命名空间中定义库的名字,库的作者(以及用户1)可以避免全局名字固有的限制。</p>
<h3 id="命名空间定义"><a href="#命名空间定义" class="headerlink" title="命名空间定义"></a>命名空间定义</h3><p>一个命名空间的定义包含两部分:首先是关键字 name space,随后是命名空间的名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内,主要包括:类、变量(及其初始化操作)、函数(及其定义)、模板和其他命名空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> cplusplus_primer &#123; </div><div class="line">    <span class="keyword">class</span> Sales_data &#123; / * ... * /&#125;; </div><div class="line">    Sales_data <span class="keyword">operator</span>+(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;); </div><div class="line">    <span class="keyword">class</span> Query &#123; <span class="comment">/* ... */</span> &#125;; </div><div class="line">    <span class="keyword">class</span> Query_base &#123; <span class="comment">/* ... */</span>&#125;; </div><div class="line">&#125; <span class="comment">// like blocks, namespaces do not end with a semicolon</span></div></pre></td></tr></table></figure>
<blockquote>
<p>每一个命名空间都是一个作用域</p>
</blockquote>
<p>和其他作用域类似,命名空间中的每个名字都必须表示该空间内的唯一实体。因为不同命名空间的作用域不同,所以在不同命名空间内可以有相同名字的成员。</p>
<blockquote>
<p>命名空间可以不连续</p>
</blockquote>
<p>命名空间可以定义在几个不同的部分,这点与其他作用域不太一样。命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件组成一个命名空间。此时,命名空间的组织方式类似于我们管理自定义类及函数的方式</p>
<ul>
<li>命名空间的一部分成员的作用是定义类,以及声明作为类接口的函数及对象,则这些成员应该置于头文件中,这些头文件将被包含在使用了这些成员的文件中。</li>
<li>命名空间成员的定义部分则置于另外的源文件中</li>
</ul>
<blockquote>
<p>定义命名空间成员</p>
</blockquote>
<p>假定作用域中存在合适的声明语句,则命名空间中的代码可以使用同一命名空间定义的名字的简写形式:</p>
<blockquote>
<p>全局命名空间</p>
</blockquote>
<p>全局作用域中定义的名字(即在所有类、函数及命名空间之外定义的名字)也就是定义在<strong>全局命名空间</strong>( global namespace)中。全局命名空间以隐式的方式声明,并且在所有程序中都存在。全局作用域中定义的名字被隐式地添加到全局命名空间中。</p>
<h3 id="使用命名空间成员"><a href="#使用命名空间成员" class="headerlink" title="使用命名空间成员"></a>使用命名空间成员</h3><p>像 namespace_name:: member_name 这样使用命名空间的成员显然非常烦琐,特别是当命名空间的名字很长时尤其如此。幸运的是,我们可以通过一些其他更简便的方法使用命名空间的成员。</p>
<blockquote>
<p>命名空间的别名</p>
</blockquote>
<p>命名空间的别名( namespace alias)使得我们可以为命名空间的名字设定一个短得多的同义词。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> primer = cplusplus_primer;</div></pre></td></tr></table></figure>
<blockquote>
<p>using声明：扼要概述</p>
</blockquote>
<p>一条using声明( using declaration)语句一次只引入命名空间的一个成员。它使得我们可以清楚地知道程序中所用的到底是哪个名字。</p>
<p>using声明引入的名字遵守与过去一样的作用域规则:它的有效范围从uS1ng声明的地方开始,一直到 using声明所在的作用域结束为止。在此过程中,外层作用域的同名实体将被隐藏。未加限定的名字只能在 using声明所在的作用域以及其内层作用域中使用。</p>
<blockquote>
<p>using 指示</p>
</blockquote>
<p>using指示( using directive)和 using声明类似的地方是,我们可以使用命名空间名字的简写形式:和 using声明不同的地方是,我们无法控制哪些名字是可见的,因为所有名字都是可见的</p>
<p>using指示以关键字using开始,后面是关键字 namespace以及命名空间的名字。</p>
<blockquote>
<p>using 指示与作用域</p>
</blockquote>
<p>using指示引入的名字的作用域远比 using声明引入的名字的作用域复杂。如我们所知,uS1ng声明的名字的作用域与uS1ng声明语句本身的作用域一致,从效果上看就好像 using声明语句为命名空间的成员在当前作用域内创建了一个别名一样。</p>
<p>using指示所做的绝非声明别名这么简单。相反,<strong>它具有将命名空间成员提升到包含命名空间本身和using指示的最近作用域的能力</strong>。    </p>
<blockquote>
<p>类、命名空间与作用域</p>
</blockquote>
<p>对命名空间内部名字的查找遵循常规的查找规则:即由内向外依次查找每个外层作用域。外层作用域也可能是一个或多个嵌套的命名空间,直到最外层的全局命名空间查找过程终止。只有位于开放的块中且在使用点之前声明的名字才被考虑</p>
<h2 id="tuple类型"><a href="#tuple类型" class="headerlink" title="tuple类型"></a>tuple类型</h2><p>tuple是类似pair的模板。每个pair的成员类型都不相同,但每个pair都恰好有两个成员。不同 tuple类型的成员类型也不相同,但<strong>一个tup1e可以有任意数量的成员</strong>。每个确定的 tuple类型的成员数目是固定的,但一个tuple类型的成员数目可以与另一个 tuple类型不同。</p>
<p>当我们希望将一些数据组合成单一对象,但又不想麻烦地定义一个新数据结构来表示这些数据时,tup1e是非常有用的。</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209268356387.jpg" alt=""></p>
<p>我们可以将 tuple看作一个“快速而随意”的数据结构。</p>
<h3 id="定义和初始化tuple"><a href="#定义和初始化tuple" class="headerlink" title="定义和初始化tuple"></a>定义和初始化tuple</h3><p>当我们定义一个 tuple时,需要指出每个成员的类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD; <span class="comment">// all three members set to 0 tuple&lt;string,</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;, <span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; someVal(<span class="string">"constants"</span>, &#123;<span class="number">3.14</span>, <span class="number">2.718</span>&#125;, <span class="number">42</span>, &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);</div></pre></td></tr></table></figure>
<p>当我们创建一个tup1e对象时,可以使用 tuple的默认构造函数,它会对每个成员进行值初始化;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">// error</span></div><div class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;   <span class="comment">// OK</span></div></pre></td></tr></table></figure>
<p>类似 make_pair函数,标准库定义了 make_tuple函,我们还可以用它来生成 tuple对象。</p>
<blockquote>
<p>访问tuple的成员</p>
</blockquote>
<p>tuple的成员都是未命名的。要访问一个 tuple的成员,就要使用一个名为get的标准库函数模板。为了使用get,我们必须指定一个显式模板实参,它指出我们想要访问第几个成员。我们传递给qet一个tup1e对象,它返回指定成员的引用:</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209364781943.jpg" alt=""></p>
<p>尖括号中的值必须是一个整型常量表达式。</p>
<p>如果不知道一个tup1e准确的类型细节信息,可以用两个辅助类模板来查询tuple成员的数量和类型:</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209366456481.jpg" alt=""></p>
<blockquote>
<p>关系和相等运算符</p>
</blockquote>
<p>tuple 的关系和相等运算符的行为类似容器的对应操作。</p>
<h3 id="使用tuple返回多个值"><a href="#使用tuple返回多个值" class="headerlink" title="使用tuple返回多个值"></a>使用tuple返回多个值</h3><p>tuple的一个常见用途是从一个函数返回多个值。</p>
<blockquote>
<p>返回tuple的函数</p>
</blockquote>
<p><img src="https://data2.liuin.cn/2018-03-13-15209367806251.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 题解——Longest Valid Parentheses]]></title>
      <url>/2018/03/18/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Longest-Valid-Parentheses/</url>
      <content type="html"><![CDATA[<p>LeetCode 题解——Longest Valid Parentheses</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个括号字符串，求出其中匹配的子字符串的最大长度</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>一个思路是用动态规划思想：用数组dp[i]表示以s[i]结尾的匹配子字符串的长度，这样我们可以得到状态转移方程：</p>
<p><img src="https://data2.liuin.cn/2018-03-18-15213386227746.jpg" alt=""></p>
<p>其中后面一个分支表示的情况是，最后以后<code>)</code>跳过前面的已经能够匹配的子字符串能和其前面的<code>(</code>匹配</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = s.length(), res = <span class="number">0</span>;</div><div class="line">        <span class="comment">// len+1 数组，最前面一个当做0</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(len+<span class="number">1</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i&gt;<span class="number">1</span> &amp;&amp; s[i<span class="number">-1</span>] == <span class="string">')'</span> &amp;&amp; s[i<span class="number">-2</span>] == <span class="string">'('</span>) dp[i]=dp[i<span class="number">-2</span>] + <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(i&gt;<span class="number">1</span> &amp;&amp; s[i<span class="number">-1</span>] == <span class="string">')'</span> &amp;&amp; s[i<span class="number">-2</span>] == <span class="string">')'</span> &amp;&amp; s[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>] == <span class="string">'('</span>) dp[i] = dp[i<span class="number">-1</span>] + dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>] + <span class="number">2</span>;</div><div class="line">            res = max(res, dp[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="利用栈"><a href="#利用栈" class="headerlink" title="利用栈"></a>利用栈</h3><p>这种括号字符串的题目，大部分都能够用栈来解决，按照以往的思路：遇到左括号入栈、遇到右括号出栈，这样输入匹配的括号之后，栈里面的东西不多不少，如果此时我们记录，第一个入栈时的位置，那么最后一个出栈的时候就可以通过位置（index）计算其长度了。</p>
<p>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</div><div class="line">        <span class="keyword">int</span> len = s.length();</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        st.push(<span class="number">-1</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</div><div class="line">                st.push(i);</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                st.pop();</div><div class="line">                <span class="comment">// 栈为空的时候表示新的串匹配开始</span></div><div class="line">                <span class="keyword">if</span>(st.empty())</div><div class="line">                    st.push(i);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                &#123;</div><div class="line">                    res = max(res, i-st.top());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LaTeX 数学公式]]></title>
      <url>/2018/03/16/LaTeX-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>平时写Markdown的时候难免会遇到一些用数学公式的情况，这里总结一些常用数学公式的写法。</p>
<a id="more"></a>
<h2 id="数学结构"><a href="#数学结构" class="headerlink" title="数学结构"></a>数学结构</h2><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p>常用的上下标结构</p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211921156811.jpg" alt=""></p>
<table>
<thead>
<tr>
<th>公式</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$A_{ij} = 2^{i+j}$</code></td>
<td>$A_{ij} = 2^{i+j}$</td>
</tr>
<tr>
<td><code>$A = 90^\circ$</code></td>
<td>$A = 90^\circ$</td>
</tr>
<tr>
<td><code>$\int_0^1 f(t) \dif t = \iint_D g(x, y) \dif x \dif y$</code></td>
<td>$\int_0^1 f(t) \cos t = \iint_D g(x, y) \cos x \sin y$</td>
</tr>
</tbody>
</table>
<h3 id="上下画线与花括号"><a href="#上下画线与花括号" class="headerlink" title="上下画线与花括号"></a>上下画线与花括号</h3><ul>
<li>\overline和\underline命令可用来在公式的上方和下方划横线</li>
<li>\overbrace和\underbrace带上花括号</li>
</ul>
<table>
<thead>
<tr>
<th>公式</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\overline{a+b} = \overline a \overline b$</code></td>
<td>$\overline{a+b} = \overline a \overline b$</td>
</tr>
<tr>
<td><code>$\overbrace {a+b+c} = \underbrace{1+2+3}$</code></td>
<td>$\overbrace {a+b+c} = \underbrace{1+2+3}$</td>
</tr>
</tbody>
</table>
<h3 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h3><p>分式使用<code>\face{分子}{分母}</code>得到</p>
<table>
<thead>
<tr>
<th>公式</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\frac{1}{\frac 12 (a+b)} = \frac{2}{a+b}$</code></td>
<td>$\frac{1}{\frac 12 (a+b)} = \frac{2}{a+b}$</td>
</tr>
</tbody>
</table>
<h3 id="根式"><a href="#根式" class="headerlink" title="根式"></a>根式</h3><p>根式是又一种常见的数学结构,用单参数的命令<code>\sqrt</code>得到,同时可以带一个可选参数,表示开方的次数</p>
<table>
<thead>
<tr>
<th>公式</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\sqrt[n] {\frac{x^2 + \sqrt 2}{x+y}}$</code></td>
<td>$\sqrt[n] {\frac{x^2 + \sqrt 2}{x+y}}$</td>
</tr>
</tbody>
</table>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>各种外括号不同的矩阵：</p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211932205959.jpg" alt=""></p>
<p>在矩阵环境中,不同的列用符号&amp;分隔,行用\分隔,矩阵每列中元素居中对齐</p>
<table>
<thead>
<tr>
<th>公式</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$ A = \begin{pmatrix} a &amp; b &amp; c \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; a \end{pmatrix}$</code></td>
<td>$ A = \begin {pmatrix} a &amp; b &amp; c \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; a \end {pmatrix}$</td>
</tr>
<tr>
<td><code>$ A = \begin{bmatrix} a_{11} &amp; \dots &amp; a_{1n} \\  &amp; \ddots &amp; \vdots \\ 0 &amp; &amp; a_{nn} \end{bmatrix} $</code></td>
<td>$ A = \begin{bmatrix} a_{11} &amp; \dots &amp; a_{1n} \\  &amp; \ddots &amp; \vdots \\ 0 &amp; &amp; a_{nn} \end{bmatrix} $</td>
</tr>
</tbody>
</table>
<h2 id="符号与类型"><a href="#符号与类型" class="headerlink" title="符号与类型"></a>符号与类型</h2><h3 id="字母表和普通符号"><a href="#字母表和普通符号" class="headerlink" title="字母表和普通符号"></a>字母表和普通符号</h3><p><img src="https://data2.liuin.cn/2018-03-16-15211956280206.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211956379753.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211956477483.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211956663623.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211956803907.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211956929506.jpg" alt=""></p>
<h3 id="数学算子"><a href="#数学算子" class="headerlink" title="数学算子"></a>数学算子</h3><p><img src="https://data2.liuin.cn/2018-03-16-15211957120206.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211957244734.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211957348221.jpg" alt=""></p>
<h3 id="二元运算符与关系符"><a href="#二元运算符与关系符" class="headerlink" title="二元运算符与关系符"></a>二元运算符与关系符</h3><p><img src="https://data2.liuin.cn/2018-03-16-15211957624199.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211957708521.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211957833150.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211957967157.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211958049898.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211958460225.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211958550071.jpg" alt=""></p>
<h3 id="括号与定界符"><a href="#括号与定界符" class="headerlink" title="括号与定界符"></a>括号与定界符</h3><p><img src="https://data2.liuin.cn/2018-03-16-15211959051369.jpg" alt=""></p>
<h3 id="标点"><a href="#标点" class="headerlink" title="标点"></a>标点</h3><p><img src="https://data2.liuin.cn/2018-03-16-15211959300033.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211959403756.jpg" alt=""></p>
<h2 id="在Hexo中使用LaTeX编辑数学公式"><a href="#在Hexo中使用LaTeX编辑数学公式" class="headerlink" title="在Hexo中使用LaTeX编辑数学公式"></a>在Hexo中使用LaTeX编辑数学公式</h2><p>在Hexo中编辑数学公式一般用的是<a href="https://github.com/hexojs/hexo-math" target="_blank" rel="external">这个</a>插件</p>
<p>其中有一个比较坑的点就是，不能够识别<code>\</code>和<code>_</code>这些符号，因为其在Markdown语法中也有一些意义，所以在某些情况下使用的时候还要在前面加一个<code>\</code>进行转义：</p>
<ul>
<li>后面接<code>,</code> 各种括号的时候，前面<code>_</code>所表示符号前面要加<code>\</code>转义</li>
</ul>
<p>另外可以更换markdown的渲染引擎，参考<a href="https://jdhao.github.io/2017/10/06/hexo-markdown-latex-equation/" target="_blank" rel="external">这里</a></p>
<p>主要参考：《LaTeX 入门》</p>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 题解——Substring with Concatenation of All Words]]></title>
      <url>/2018/03/15/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Substring-with-Concatenation-of-All-Words/</url>
      <content type="html"><![CDATA[<p>LeetCode 题解——Substring with Concatenation of All Words</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个字符串，和一组匹配字符串（vector），其中每一个字符串的长度是相同的，后面的这一组字符串可以形成一个组合，比如[“ab”,”cd”]可以组合成的字符串有：”abcd” “cdab”。题目要求我们在给定的这个字符串中查找出现后面这些组合的子串的位置（给出首字母位置）</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目中给出的匹配字符串组中每一个字符串的长度是相同的这个条件降低了题目的难度，如果从普通的字符串匹配的思路下手的话，就是每次从原串截取对比的长度是一样的，然后截取的字符串可以分割成几个长度相同的子字符串，我们只要判断这几个字符子串是否都在给出的这组匹配字符串中就行了。</p>
<p>这里使用两个unordered_map(Hash实现，性能更优)来判断是否都在这组字符串中，第一个map存储匹配字符串组中的字符串和出现的次数（都是1），第二个map存储截取的字符串分割以后的子串（并且在匹配字符串组中）以及其出现的次数，如果其次数大于1，表示截取的这段不符合条件，进行下一次匹配。</p>
<p>map有两个作用：查找字符串；记录出现次数</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        <span class="comment">// 用来进行对比的map</span></div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; contrast;</div><div class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> s : words)</div><div class="line">        &#123;</div><div class="line">            contrast[s]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> slen = s.length(), wlen = words[<span class="number">0</span>].length(), wsize = words.size();</div><div class="line">        <span class="comment">// 依次截取一定长度的字符串进行匹配</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;slen-wsize*wlen+<span class="number">1</span>; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; tem;</div><div class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(; j&lt;wsize; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">// 分割以后的每一个字符串</span></div><div class="line">                <span class="built_in">string</span> stem = s.substr(i+j*wlen, wlen);</div><div class="line">                <span class="comment">// 判断是否在匹配字符串组中</span></div><div class="line">                <span class="keyword">if</span>(contrast.find(stem) != contrast.end())</div><div class="line">                &#123;</div><div class="line">                    tem[stem]++;</div><div class="line">                    <span class="comment">// 出现次数超过1，放弃</span></div><div class="line">                    <span class="keyword">if</span>(tem[stem] &gt; contrast[stem])</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(j == wsize)</div><div class="line">                res.push_back(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Coursera 吴恩达机器学习 课程笔记]]></title>
      <url>/2018/03/13/Coursera-%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>Coursera 吴恩达机器学习 课程笔记</p>
<a id="more"></a>
<h1 id="监督学习和无监督学习"><a href="#监督学习和无监督学习" class="headerlink" title="监督学习和无监督学习"></a>监督学习和无监督学习</h1><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>维基百科中的定义：</p>
<blockquote>
<p>监督式学习（英语：Supervised learning），是一个机器学习中的方法，可以由训练资料中学到或建立一个模式（函数 / learning model），并依此模式推测新的实例。训练资料是由输入物件（通常是向量）和预期输出所组成。函数的输出可以是一个连续的值（称为回归分析），或是预测一个分类标签（称作分类）</p>
</blockquote>
<p>在监督学习中, 我们的预测结果可以是连续值, 也可以是离散值. 我们根据这样的属性将监督学习氛围回归问题和分类问题.</p>
<h3 id="监督学习举例"><a href="#监督学习举例" class="headerlink" title="监督学习举例"></a>监督学习举例</h3><blockquote>
<p>回归问题</p>
</blockquote>
<p>通过给定的一个房子的面积来预测这个房子在市场中的价格. 这里的房子的面积就是特征, 房子的价格就是一个输出值. 为了解决这个问题, 我们获取了大量的房地产数据, 每一条数据都包含房子的面积及其对应价格. 第一, 我们的数据不仅包含房屋的面积, 还包含其对应的价格, 而我们的目标就是通过面积预测房价. 所以这应该是一个监督学习; 其次, 我们的输出数据房价可以看做是连续的值, 所以这个问题是一个回归问题.</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208368350754.jpg" alt=""></p>
<blockquote>
<p>分类问题</p>
</blockquote>
<p>我们的目标应该是要对数据进行分类. 现在我们的数据是有关乳腺癌的医学数据, 它包含了肿瘤的大小以及该肿瘤是良性的还是恶性的. 我们的目标是给定一个肿瘤的大小来预测它是良性还是恶性. 我们可以用0代表良性，1代表恶性. 这就是一个分类问题, 因为我们要预测的是一个离散值. </p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208368814648.jpg" alt=""></p>
<p>在这个例子中特征只有一个即瘤的大小。 对于大多数机器学习的问题, 特征往往有多个(上面的房价问题也是, 实际中特征不止是房子的面积). 例如下图， 有“年龄”和“肿瘤大小”两个特征。</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208369551948.jpg" alt=""></p>
<h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>在无监督学习中, 我们的数据并没有给出特定的标签, 例如上面例子中的房价或者是良性还是恶性. 我们目标也从预测某个值或者某个分类变成了寻找数据集中特殊的或者对我们来说有价值结构. </p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208370522571.jpg" alt=""></p>
<h3 id="无监督学习举例"><a href="#无监督学习举例" class="headerlink" title="无监督学习举例"></a>无监督学习举例</h3><blockquote>
<p>新闻分类</p>
</blockquote>
<p>Google News搜集网上的新闻，并且根据新闻的主题将新闻分成许多簇, 然后将在同一个簇的新闻放在一起。如图中红圈部分都是关于BP Oil Well各种新闻的链接，当打开各个新闻链接的时候，展现的都是关于BP Oil Well的新闻。</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208370968972.jpg" alt=""></p>
<blockquote>
<p>根据给定基因将人群分类</p>
</blockquote>
<p><img src="https://data2.liuin.cn/2018-03-12-15208371698906.jpg" alt=""></p>
<h1 id="单变量线性回归"><a href="#单变量线性回归" class="headerlink" title="单变量线性回归"></a>单变量线性回归</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="训练集"><a href="#训练集" class="headerlink" title="训练集"></a>训练集</h3><p>由训练样例(training example)组成的集合就是训练集(training set)</p>
<h3 id="假设函数"><a href="#假设函数" class="headerlink" title="假设函数"></a>假设函数</h3><p>使用某种学习算法对训练集的数据进行训练, 我们可以得到假设函数(Hypothesis Function)</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208382454378.jpg" alt=""></p>
<p>我们使用如下方法表示假设函数，</p>
<p>$$ {h_\theta(x)=\theta_0+\theta_1x} $$</p>
<p>以上这个模型就叫做单变量的线性回归(Linear Regression with One Variable).</p>
<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><h3 id="什么是代价函数"><a href="#什么是代价函数" class="headerlink" title="什么是代价函数"></a>什么是代价函数</h3><p>只要我们知道了假设函数, 我们就可以进行预测了. 关键是, 假设函数中有两个未知的量$\theta_0$,$\theta_1$. 当选择不同的$\theta_0$和$\theta_1$时, 我们模型的效果肯定是不一样的. 我们的想法是选择某个$\theta_0$和$\theta_1$，使得对于训练样例$(x,y)$，$h_\theta(x)$最“接近”$y$。越是接近, 代表这个假设函数越是准确, 这里我们选择均方误差来作为衡量标准, 即我们想要每个样例的估计值与真实值之间差的平方的均值最小:（其中$1/2$只是为了我们后面计算方便）</p>
<p>$$<br>{\mathop{min}\limits_{\theta_0,\theta_1}\frac{1}{2m}\sum_{i=0}^m\left(h_\theta(x^{(i)})-y^{(i)}\right)^2}<br>$$</p>
<p>记作：</p>
<p>$${J(\theta_0,\theta_1) = \frac{1}{2m}\sum_{i=0}^m\left(h_\theta(x^{(i)})-y^{(i)}\right)^2 }$$</p>
<p>这样就得到了我们的代价函数(cost function), 也就是我们的优化目标, 我们想要代价函数最小:</p>
<p>$$ \mathop{min}\limits_{\theta_0,\theta_1}J(\theta_0,\theta_1)$$</p>
<h3 id="代价函数和假设函数"><a href="#代价函数和假设函数" class="headerlink" title="代价函数和假设函数"></a>代价函数和假设函数</h3><p>对于不同的$\theta_1$，对应着不同的假设函数$h_\theta(x)$，于是就有了不同的代价函数$J (\theta_1)$的值。将这些点连接起来就可以得到$J(\theta_1)$和$\theta_1$关系的图像：</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208395529904.jpg" alt=""></p>
<p>我们的目标是找到一个$\theta$使得$J(\theta_1)$最小</p>
<p>如果我们考虑两个变量，能够绘制$J(\theta_0,\theta_1)$的图形如下</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208397051963.jpg" alt=""></p>
<p>由于3D图形不太方便我们研究，我们就使用二维的等高线(上图右上角教授写的contour plots/figures)，这样看上去比较清楚一些。越靠近中心表示$J(\theta_0,\theta_1)$值越小</p>
<h2 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h2><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>梯度下降算法是一种优化算法, 它可以帮助我们找到一个函数的局部极小值点. 它不仅仅可以用在线性回归模型中, 在机器学习许多其他的模型中也可以使用它. 对于我们现在研究的单变量线性回归来说, 我们想要使用梯度下降来找到最优的$\theta_0$,$\theta_1$。</p>
<p>它的思想是，首先随机选择两个$\theta_0$,$\theta_1$，不断改变他们的值使得$J(\theta)$最小，最终找到$J(\theta)$的最小点</p>
<p>可以把梯度下降的过程想象成下山坡, 如果想要尽可能快的下坡, 应该每次都往坡度最大的方向下山.</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208400482188.jpg" alt=""></p>
<p>算法过程：（要注意的是，算法是每次同时改变$\theta_0$和$\theta_1$的值）</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208401837391.jpg" alt=""></p>
<h3 id="梯度和学习率"><a href="#梯度和学习率" class="headerlink" title="梯度和学习率"></a>梯度和学习率</h3><p>学习率$\alpha$会影响梯度下降的幅度。如果$\alpha$的值太小，$\theta$的值每次会变化很小，那么梯度下降就会比较慢；相反，如果$\alpha$过大，$\theta$的值每次就会变化很大，有可能超过最低点，可能导致永远没法到达最低点。</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208404559020.jpg" alt=""></p>
<p>由于随着越来越接近最低点, 相应的梯度(绝对值)也会逐渐减小，所以每次下降程度就会越来越小, 我们并不需要减小$\alpha$的值来减小下降程度。</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208404858375.jpg" alt=""></p>
<h3 id="计算梯度"><a href="#计算梯度" class="headerlink" title="计算梯度"></a>计算梯度</h3><p>将偏导计算出来就得到了完整梯度下降算法：</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208405675961.jpg" alt=""></p>
<p>事实上，用于线性回归的代价函数总是一个凸函数(Convex Function)。这样的函数没有局部最优解，只有一个全局最优解。所以我们在使用梯度下降的时候，总会得到一个全局最优解。</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208406207656.jpg" alt=""></p>
<h1 id="多变量线性回归"><a href="#多变量线性回归" class="headerlink" title="多变量线性回归"></a>多变量线性回归</h1><h2 id="假设函数-1"><a href="#假设函数-1" class="headerlink" title="假设函数"></a>假设函数</h2><p>在之前的单变量线性回归中, 我们的问题只涉及到了房子面积这一个特征。在实际问题中, 会有很多特征. 例如, 除了房子面积, 还有房子的卧室数量, 房子的楼层数, 房子建筑年龄.</p>
<p>在单变量线性回归中假设函数为：</p>
<p>$${h_\theta(x)=\theta_0+\theta_1x}$$</p>
<p>现在对于多变量，可以设其假设函数为：</p>
<p>$${h_\theta(x)=\theta_0+\theta_1x_1+\theta_2x_2+…+\theta_nx_n}$$</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208613808836.jpg" alt=""></p>
<p>得到其向量表示：</p>
<p>$${h_\theta(x)=\theta_0x_0+\theta_1x_1+\theta_2x_2+…+\theta_nx_n= \theta^Tx}$$</p>
<h2 id="梯度下降-1"><a href="#梯度下降-1" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>多变量情况下的梯度下降其实没有区别, 只需要把对应的偏导数项换掉即可</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208618844580.jpg" alt=""></p>
<h2 id="特征处理"><a href="#特征处理" class="headerlink" title="特征处理"></a>特征处理</h2><h3 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h3><p>如果每个特征的范围相差的很大, 梯度下降会很慢. 为了解决这个问题, 我们在梯度下降之前应该对数据做特征归缩放(Feature Scaling)处理, 从而将所有的特征的数量级都在一个差不多的范围之内, 以加快梯度下降的速度.</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208619474872.jpg" alt=""></p>
<p>通常我们需要把特征都缩放到$[-1,1]$(附近)这个范围</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208619856026.jpg" alt=""></p>
<h3 id="均值均一化"><a href="#均值均一化" class="headerlink" title="均值均一化"></a>均值均一化</h3><p>还有一个特征处理的方法就是均值归一化(Mean normalization)</p>
<p>$${x_i=\frac{x_i-\mu_i}{max-min}}$$</p>
<h2 id="代价函数与学习率"><a href="#代价函数与学习率" class="headerlink" title="代价函数与学习率"></a>代价函数与学习率</h2><p>我们可以通过画出$\mathop{min}\limits_{\theta}J(\theta)$与迭代次数的关系来观察梯度下降的运行情况，</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209095236343.jpg" alt=""></p>
<p>出现下面两种情况，应该选择更小的学习率$\alpha$，</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209096625766.jpg" alt=""></p>
<p>注意：</p>
<ul>
<li>如果$\alpha$足够小，，那么$J(\theta)$在每次迭代之后都会减小</li>
<li>如果$\alpha$太小， 梯度下降会进行的非常缓慢.</li>
</ul>
<p>进行尝试的值：<br><img src="https://data2.liuin.cn/2018-03-13-15209097782077.jpg" alt=""></p>
<h2 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h2><p>多项式回归(Polynomial Regression)是研究一个因变量与一个或多个自变量间多项式的回归分析方法。如果自变量只有一个时，称为一元多项式回归；如果自变量有多个时，称为多元多项式回归。</p>
<p>我们可以将房屋的面积作为第一个特征, 面积的平方作为第二个特征, 面积的立方作为第三个特征:</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209102744925.jpg" alt=""></p>
<p>除了三次函数模型, 这里也可以选择平方根函数模型, 如下图所示</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209107024350.jpg" alt=""></p>
<h2 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h2><h3 id="正规方程介绍"><a href="#正规方程介绍" class="headerlink" title="正规方程介绍"></a>正规方程介绍</h3><p>之前我们一直是用的梯度下降求解最优值. 它的缺点就是需要进行很多次迭代才能得到全局最优解. 有没有更好的方法呢? 我们先来看一个最简单的例子, 假设现在的代价函数为$J(\theta)=a\theta^2+b\theta+c$，在导数等于0的时候取到最优解。</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209111273173.jpg" alt=""></p>
<p>下面我们介绍一种向量化的求解方法。首先, 在数据集前加上一列$X_0$，值都为1，然后将所有的变量都放入矩阵$X$中（包括加上的$x_0$）；再将输出值放入向量$y$中. 最后通过公式$$\theta=(X^TX)^{-1}X^Ty$$就可以算出最优解</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209221924071.jpg" alt=""></p>
<p>更通用的表达方式</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209222169590.jpg" alt=""></p>
<h3 id="梯度下降和正规方程的比较"><a href="#梯度下降和正规方程的比较" class="headerlink" title="梯度下降和正规方程的比较"></a>梯度下降和正规方程的比较</h3><p><img src="https://data2.liuin.cn/2018-03-13-15209222993254.jpg" alt=""></p>
<h3 id="正规方程不可逆的情况"><a href="#正规方程不可逆的情况" class="headerlink" title="正规方程不可逆的情况"></a>正规方程不可逆的情况</h3><p>使用正规方程还有一个问题就是$X^TX$可能存在不可逆的情况. 这个时候, 可能是因为我们使用了冗余的特征, 还有一个原因是我们使用了太多的特征(特征的数量超过了样本的数量). 对于这种情况我们可以删掉一些特征或者使用正则化(正则化在后面的课中讲).</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209223711085.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《C++ Primer》笔记 类设计者的工具部分]]></title>
      <url>/2018/03/11/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7%E9%83%A8%E5%88%86/</url>
      <content type="html"><![CDATA[<p>《C++ Primer》笔记 类设计者的工具部分</p>
<a id="more"></a>
<h1 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h1><p>当定义一个类时,我们显式地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作,包括:拷贝构造函数( copy constructor)、拷贝赋值运算符( copy-assignment operator)、移动构造函数(moveconstructor)、移动赋值运算符(move-assignment operator)和析构函数( destructor)。</p>
<h2 id="拷贝、赋值与销毁"><a href="#拷贝、赋值与销毁" class="headerlink" title="拷贝、赋值与销毁"></a>拷贝、赋值与销毁</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>如果一个构造函数的第一个参数是自身类类型的引用,且任何额外参数都有默认值,则此构造函数是拷贝构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Foo&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Foo();      <span class="comment">// 默认构造函数</span></div><div class="line">    Foo(<span class="keyword">const</span> Foo&amp;);  <span class="comment">// 拷贝构造函数</span></div></pre></td></tr></table></figure>
<p>拷贝构造函数的第一个参数必须是一个引用类型,原因我们稍后解释。虽然我们可以定义个接受非 const引用的拷贝构造函数,但此参数几乎总是一个 const的引用。拷贝构造函数在几种情况下都会被隐式地使用。因此,拷贝构造函数通常不应该是 explicit（抑制构造函数定义的隐式转换）的</p>
<blockquote>
<p>合成拷贝构造函数</p>
</blockquote>
<p>对某些类来说,合成拷贝构造函数( synthesized copy constructor)用来阻止我们拷贝该类类型的对象。而一般情况,<strong>合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中</strong>。</p>
<blockquote>
<p>拷贝初始化</p>
</blockquote>
<p>当使用直接初始化时,我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。当我们使用拷贝初始化(copy initialization)时,我们要求<strong>编译器将右侧运算对象拷贝到正在创建的对象中,如果需要的话还要进行类型转换</strong>。</p>
<blockquote>
<p>拷贝初始化使用场景</p>
</blockquote>
<p>拷贝初始化不仅在我们用=定义变量时会发生,在下列情况下也会发生</p>
<ul>
<li>将一个对象作为实参传递给一个非引用类型的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li>
</ul>
<blockquote>
<p>参数和返回值</p>
</blockquote>
<p>在函数调用过程中,具有非引用类型的参数要进行拷贝初始化。类似的,当一个函数具有非引用的返回类型时,返回值会被用来初始化调用方的结果。</p>
<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><blockquote>
<p>重载赋值运算符</p>
</blockquote>
<p>重载运算符本质上是函数,其名字由 operator关键字后接表示要定义的运算符的符号组成。因此,赋值运算符就是一个名为 operator=的函数。类似于任何其他函数,运算符函数也有一个返回类型和一个参数列表。</p>
<p>重载运算符的参数表示运算符的运算对象。某些运算符,包括赋值运算符,必须定义为成员函数。如果一个运算符是一个成员函数,其左侧运算对象就绑定到隐式的this参数。对于一个二元运算符,例如赋值运算符,其右侧运算对象作为显式参数传递。</p>
<p>为了与内置类型的赋值保持一致,<strong>赋值运算符通常返回一个指向其左侧运算对象的引用</strong>。另外值得注意的是,标准库通常要求保存在容器中的类型要具</p>
<blockquote>
<p>合成拷贝赋值运算符</p>
</blockquote>
<p>与处理拷贝构造函数一样,如果一个类未定义自己的拷贝赋值运算符,编译器会为它生成一个合成拷贝赋值运算符</p>
<p>等价合成拷贝赋值运算符：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data &amp;rhs)</div><div class="line">&#123;</div><div class="line">    bookNo = rhs.bookNo;</div><div class="line">    revenue = rhs.revenur;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数执行与构造函数相反的操作:构造函数初始化对象的非 static数据成员还可能做一些其他工作;析构函数释放对象使用的资源,并销毁对象的非 static数据成员</p>
<blockquote>
<p>析构函数完成什么工作</p>
</blockquote>
<p>如同构造函数有一个初始化部分和一个函数体,析构函数也有一个函数体和一个析构部分。在一个构造函数中,成员的初始化是在函数体执行之前完成的,且按照它们在类中出现的顺序进行初始化。<strong>在一个析构函数中,首先执行函数体,然后销毁成员。成员按初始化顺序的逆序销毁</strong>。</p>
<blockquote>
<p>什么时候用到析构函数</p>
</blockquote>
<p>无论何时一个对象被销毁,就会自动调用其析构函数:</p>
<ol>
<li>变量在离开其作用域时被销毁。</li>
<li>当一个对象被销毁时,其成员被销毁。</li>
<li>容器(无论是标准库容器还是数组)被销毁时,其元素被销毁。</li>
<li>对于动态分配的对象,当对指向它的指针应用 delete运算符时被销毁</li>
<li>对于临时对象,当创建它的完整表达式结束时被销毁。</li>
</ol>
<blockquote>
<p>合成析构函数</p>
</blockquote>
<p>当一个类未定义自己的析构函数时,编译器会为它定义一个合成析构函数( synthesizeddestructor)。类似拷贝构造函数和拷贝赋值运算符,对于某些类,合成析构函数被用来阻止该类型的对象被销毁。如果不是这种情况，合成析构函数就为空</p>
<p>认识到析构函数体自身并不直接销毁成员是非常重要的。<strong>成员是在析构函数体之后隐含的析构阶段中被销毁的</strong>。在整个对象销毁过程中,析构函数体是作为成员销毁步骤之外的另一部分而进行的。</p>
<h3 id="三-五法则"><a href="#三-五法则" class="headerlink" title="三/五法则"></a>三/五法则</h3><p>如前所述,有三个基本操作可以控制类的拷贝操作:拷贝构造函数、拷贝赋值运算符和析构函数。</p>
<blockquote>
<p>需要析构函数的类也需要拷贝和赋值操作</p>
</blockquote>
<p>当我们决定一个类是否要定义它自己版本的拷贝控制成员时,一个基本原则是<strong>首先确定这个类是否需要一个析构函数。通常,对析构函数的需求要比对拷贝枃造函数或赋偵运算符的需求更为明显</strong>。如果这个类需要一个析构函数,我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。</p>
<blockquote>
<p>需要拷贝操作的类也需要赋值操作，反之亦然</p>
</blockquote>
<p>虽然很多类需要定义所有(或是不需要定义任何)拷贝控制成员,但某些类所要完成的工作,只需要拷贝或赋值操作,不需要析构函数。</p>
<p>这个例子引出了第二个基本原则:如果一个类需要一个拷贝构造函数,几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然—如果一个类需要一个拷贝赋值运篁符,几平可以肯定它也需要一个拷贝构造函数。然而,无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。</p>
<h3 id="使用-default"><a href="#使用-default" class="headerlink" title="使用=default"></a>使用=default</h3><p>我们可以通过将拷贝控制成员定义为= defau1t来显式地要求编译器生成合成的版本</p>
<p><img src="https://data2.liuin.cn/2018-03-05-15202146959452.jpg" alt=""></p>
<h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><p>虽然大多数类应该定义(而且通常也的确定义了)拷贝构造函数和拷贝赋值运算符,但对某些类来说,这些操作没有合理的意义。在此情况下,定义类时必须采用某种机制阻止拷贝或赋值。</p>
<blockquote>
<p>定义删除的函数</p>
</blockquote>
<p>在新标准下,我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数( deletedfunction)来阻止拷贝。删除的函数是这样一种函数:我们虽然声明了它们,但不能以任何方式使用它们]。在函数的参数列表后面加上=de1ete来指出我们希望将它定义为删除的:</p>
<blockquote>
<p>析构函数不能是删除的成员</p>
</blockquote>
<p>值得注意的是,我不能删除析构函数。如果析构函数被删除,就无法销毁此类型的对象了。对于一个删除了析构函数的类型,编译器将不允许定义该类型的变量或创建该类的临时对象。而且,如果一个类有某个成员的类型删除了析构函数,我们也不能定义该类</p>
<blockquote>
<p>private 拷贝控制</p>
</blockquote>
<p>在新标准发布之前,类是通过将其拷贝构造函数和拷贝赋值运算符声明为 private的来阻止拷贝:</p>
<p><img src="https://data2.liuin.cn/2018-03-05-15202148530112.jpg" alt=""></p>
<p>友元和成员函数仍旧可以拷贝对象。为了阻止友元和成员函数进行拷贝,我们将这些拷贝控制成员声明为 private的,但并不定义它们。</p>
<h2 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h2><p>通常,管理类外资源的类必须定义拷贝控制成员。某些类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数,那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。为了定义这些成员,我首先必须确定此类型对象的拷贝语义。一般来说,有两种选择:可以定义拷贝操作,<strong>使类的行为看起来像一个值或者像一个指针</strong>。</p>
<p>类的行为像一个值,意味着它应该也有自己的状态。当我们拷贝一个像值的对象时,副本和原对象是完全独立的。改变副本不会对原对象有任何影响,反之亦然。</p>
<p>行为像指针的类则共享状态。当我们拷贝一个这种类的对象时,副本和原对象使用相同的底层数据。改变副本也会改变原对象,反之亦然</p>
<h3 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h3><p>为了提供类值的行为,对于类管理的资源,每个对象都应该拥有一份自己的拷贝。这意味着对于ps指向的 string,每个 Hasptr对象都必须有自己的拷贝。</p>
<blockquote>
<p>类值拷贝赋值运算符</p>
</blockquote>
<p>赋值运算符通常组合了析构函数和构造函数的操作。类似析构函数,赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数,赋值操作会从右侧运算对象拷贝数据。</p>
<h3 id="定义行为像指针的类"><a href="#定义行为像指针的类" class="headerlink" title="定义行为像指针的类"></a>定义行为像指针的类</h3><p>对于行为类似指针的类,我们需要为其定义拷贝构造函数和拷贝赋值运算符,来拷贝指针成员本身而不是它指向的 string。我们的类仍然需要自己的析构函数来释放接受string参数的构造函数分配的内存。</p>
<p>令一个类展现类似指针的行为的最好方法是使用 share_ptr来管理类中的资源</p>
<p>但是,有时我们希望直接管理资源。在这种情况下,使用<strong>引用计数</strong>( reference count)就很有用了。</p>
<blockquote>
<p>定义一个使用引用计数的类</p>
</blockquote>
<p><img src="https://data2.liuin.cn/2018-03-05-15202156946283.jpg" alt=""></p>
<h2 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h2><p>除了定义拷贝控制成员,管理资源的类通常还定义一个名为swap的函数。对于那些与重排元素顺序的算法一起使用的类,定义swap是非常重要的。这类算法在需要交换两个元素时会调用swap。</p>
<p>为了交换两个对象，我们需要一次拷贝和两次赋值</p>
<blockquote>
<p>在赋值运算符中使用swap</p>
</blockquote>
<p>定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为拷贝并交换( copy and swap)的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// rhs按值传递，使用HasPtr的拷贝构造函数</span></div><div class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(HasPtr rhs)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 交换左侧运算对象和局部变量rhs的内容</span></div><div class="line">    swap(*<span class="keyword">this</span>, rhs);</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="动态内存管理类"><a href="#动态内存管理类" class="headerlink" title="动态内存管理类"></a>动态内存管理类</h2><p>某些类需要在运行时分配可变大小的内存空间。这种类通常可以(并且如果它们确实可以的话,一般应该)使用标准库容器来保存它们的数据。</p>
<p>但是,这一策略并不是对每个类都适用:某些类需要自己进行内存分配。这些类一般来说必须定义自己的拷贝控制成员来管理所分配的内存</p>
<h2 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h2><p>新标准的一个最主要的特性是可以移动而非拷贝对象的能力。在某些情况下,移动而非拷贝对象会大幅度提升性能。</p>
<p>在旧C++标准中,没有直接的方法移动对象。因此,即使不必拷贝对象的情况下,我们也不得不拷贝。如果对象较大,或者是对象本身要求分配内存空间(如 string),进行不必要的拷贝代价非常高。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>为了支持移动操作,新标准引入了一种新的引用类型——<strong>右值引用</strong>( rvalue reference)。所谓右值引用就是必须绑定到右值的引用。我们通过&amp;&amp;而不是&amp;来获得右值引用。如我们将要看到的,右值引用有一个重要的性质——一只能绑定到一个将要销毁的对象。</p>
<p>一般而言,一个左值表达式表示的是一个对象的身份,而一个右值表达式表示的是对象的值</p>
<p>类似任何引用,一个右值引用也不过是某个对象的另一个名字而已。如我们所知,对于常规引|用(为了与右值引用区分开来,我们可以称之为左值引用( Ivalue reference),我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用有着完全相反的绑定特性:<strong>我们可以将一个右值引用绑定到这类表达式上,但不能将一个右值引用直接绑定到一个左值上</strong></p>
<p><img src="https://data2.liuin.cn/2018-03-05-15202204986268.jpg" alt=""></p>
<blockquote>
<p>左值持久，右值短暂</p>
</blockquote>
<p>考察左值和右值表达式的列表,两者相互区别之处就很明显了:左值有持久的状态而右值要么是字面常量,要么是在表达式求值过程中创建的临时对象。</p>
<p>由于右值引用只能绑定到临时对象,我们得知</p>
<ul>
<li>所引用的对象将要被销毁</li>
<li>该对象没有其他用户</li>
</ul>
<p>这两个特性意味着:使用右值引用的代码可以自由地接管所引用的对象的资源</p>
<blockquote>
<p>标准库move函数</p>
</blockquote>
<p>虽然不能将一个右值引用直接绑定到一个左值上,但我们可以显式地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用,此函数定义在头文件uti1ity中。</p>
<h3 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h3><p>类似拷贝构造函数,移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是,这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样,任何额外的参数都必须有默认实参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">StrVec::StrVec(StrVec &amp;&amp;s) <span class="keyword">noexcept</span>   <span class="comment">// 移动操作不应抛出异常</span></div><div class="line">: elements(s.elements), first_free(s.first_free), cap(s.cap)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// s这种状态对于运行析构函数式安全的</span></div><div class="line">    s.elements = s.first_fiee = s.cap = <span class="literal">nullptr</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了完成资源移动,移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。特别是,一旦资源完成移动,源对象必须不再指向被移动的资源——这些资源的所有权已经归属新创建的对象</p>
<blockquote>
<p>移动赋值运算符</p>
</blockquote>
<p>移动赋值运算符执行与析构函数和移动构造函数相同的工作。与移动构造函数一样如果我们的移动赋值运算符不抛出任何异常,我们就应该将它标记为 noexcept。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp; rhs) <span class="keyword">noexcept</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != rhs)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">free</span>();</div><div class="line">        element = rhs.element;</div><div class="line">        first_free = rhs.first_free;</div><div class="line">        cap = rhs.cap;</div><div class="line">        <span class="comment">// 设置为可析构状态</span></div><div class="line">        rhs.element = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>移动以后源对象必须可析构</p>
</blockquote>
<p>从一个对象移动数据并不会销毁此对象,但有时在移动操作完成后,源对象会被销毁因此,当我们编写一个移动操作时,必须确保移后源对象进入一个可析构的状态。上面的Strvec的移动操作满足这一要求,这是通过将移后源对象的指针成员置为nu11ptr来实现的。</p>
<p>在移动操作之后,移后源对象必须保持有效的、可析构的状态,但是用户不能对其值进行任何假设。</p>
<blockquote>
<p>合成的移动操作</p>
</blockquote>
<p>只有当一个类没有定义任何自己版本的拷贝控制成员,且类的每个非 static数据成员都可以移动时,编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型,且该类有对应的移动操作,编译器也能移动这个成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">struct</span> X &#123;</div><div class="line">    <span class="keyword">int</span> i;          <span class="comment">// 内置类型可移动</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s;  <span class="comment">// string类型自定义了移动函数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> hasX &#123;</div><div class="line">    X mem;          <span class="comment">// X有合成移动函数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">X x, x2 = <span class="built_in">std</span>::move(x);         <span class="comment">// 使用合成的移动函数</span></div><div class="line">hasX hx, hx2 = <span class="built_in">std</span>::move(hx);   <span class="comment">// 使用合成的移动函数</span></div></pre></td></tr></table></figure>
<p>与拷贝操作不同,移动操作永远不会隐式定义为删除的函数。但是,如果我们显式地要求编译器生成= default的移动操作,且编译器不能移动所有成员,则编译器会将移动操作定义为删除的函数。</p>
<hr>
<h1 id="操作重载和类型转换"><a href="#操作重载和类型转换" class="headerlink" title="操作重载和类型转换"></a>操作重载和类型转换</h1><p>当运算符被用于类类型的对象时,C+语言允许我们为其指定新的含义:同时,我们也能自定义类类型之间的转换规则。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>重载的运算符是具有特殊名字的函数:它们的名字由关键字 operator和其后要定义的运算符号共同组成。和其他函数一样,重载的运算符也包含返回类型、参数列表以及函数体。</p>
<p>重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有个参数,二元运算符有两个。</p>
<p>如果一个运算符函数是成员函数,则它的第一个(左侧)运算对象绑定到隐式的this指针上。</p>
<p>可以被重载的运算符：<br><img src="https://data2.liuin.cn/2018-03-06-15202996380435.jpg" alt=""></p>
<p>我们只能重载已有的运算符,而无权发明新的运算符号。对于一个重载的运算符来说,其优先级和结合律与对应的内置运算符保持一致。</p>
<blockquote>
<p>直接调用重载运算符函数</p>
</blockquote>
<p>我们也能像调用普通函数一样直接调用运算符函数,先指定函数名字,然后传入数量正确、类型适当的实参:</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15202997181932.jpg" alt=""></p>
<blockquote>
<p>某些运算符不应该被重载</p>
</blockquote>
<p>回忆之前介绍过的,某些运算符指定了运算对象求值的顺序。因为使用重载的运算符本质上是一次函数调用,所以这些<strong>关于运算对象求值顺序的规则无法应用到重载的运算符上</strong>。特别是,逻辑与运算符、逻辑或运算符和逗号运算符的运算对又象求值顺序规则无法保留下来。除此之外,&amp;&amp;和||运算符的重载版本也无法保留内置运算符的短路求值属性,两个运算对象总是会被求值。</p>
<p>还有一个原因使得我们一般不重载逗号运算符和取地址运篁符:C+语言已经<strong>定义了这两种运算符用于类类型对象时的特殊含义</strong>,这一点与大多数运算符都不相同。因为这两种运算符已经有了内置的含义,所以一般来说它们不应该被重载,否则它们的行为将异于常态,从而导致类的用户无法适应。</p>
<blockquote>
<p>赋值和复合赋值运算符</p>
</blockquote>
<p>赋值运算符的行为与复合版本的类似:赋值之后,左侧运算对象和右侧运算对象的值相等,并且运算符应该返回它左侧运算对象的一个引用。<strong>重载的赋值运算应该继承而非违背其内置版本的含义</strong>。</p>
<blockquote>
<p>选择作为成员还是非成员</p>
</blockquote>
<p>当我们定义重载的运算符时,必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。</p>
<p>下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择：</p>
<ul>
<li>赋值(=)、下标([])、调用(())和成员访问箭头(-&gt;)运算符必须是成员。</li>
<li>复合赋值运算符一般来说应该是成员,但并非必须,这一点与赋值运算符略有不同。</li>
<li>改变对象状态的运算符或者与给定类型密切相关的运算符,如递增、递减和解引用运算符,通常应该是成员。</li>
<li>具有对称性的运算符可能转换任意一端的运算对象,例如算术、相等性、关系和位运算符等,因此它们通常应该是普通的非成员函数。</li>
</ul>
<h2 id="输入和输出运算符"><a href="#输入和输出运算符" class="headerlink" title="输入和输出运算符"></a>输入和输出运算符</h2><p>IO标准库分别使用&gt;&gt;和&lt;&lt;执行输入和输出操作。</p>
<h3 id="重载输出运算符-lt-lt"><a href="#重载输出运算符-lt-lt" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符&lt;&lt;</h3><p>输出运算符的<strong>第一个形参是一个非常量 ostream对象的引用</strong>。之所以ostream是非常量是因为向流写入内容会改变其状态;而该形参是引用是因为我们无法直接复制一个 ostream对象。</p>
<p><strong>第二个形参一般来说是一个常量的引用,该常量是我们想要打印的类类型</strong>。第二个形参是引用的原因是我们希望避免复制实参;而之所以该形参可以是常量是因为(通常情况下)打印对象不会改变对象的内容。</p>
<p>为了与其他输出运算符保持一致, operator&lt;&lt;一般要返回它的 ostream形参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Sale_data &amp;item)</div><div class="line">&#123;</div><div class="line">    os &lt;&lt; item.isbon() &lt;&lt; <span class="string">" "</span> &lt;&lt; item.units_old ;</div><div class="line">    <span class="keyword">return</span> os;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>输入运算符尽量减少格式化操作</p>
</blockquote>
<p>用于内置类型的输出运算符不太考虑格式化操作,尤其不会打印换行符,用户希望类的输出运算符也像如此行事。如果运算符打印了换行符,则用户就无法在对象的同一行内接着打印一些描述性的文本了。</p>
<blockquote>
<p>输入输出函数必须为非成员函数</p>
</blockquote>
<p>与 iostream标准库兼容的输入输出运算符必须是普通的非成员函数,而不能是类的成员函数。否则,它们的左侧运算对象将是我们的类的一个对象</p>
<p>因此,<strong>如果我们希望为类自定义IO运算符,则必须将其定义成非成员函数</strong>。当然,IO运算符通常需要读写类的非公有数据成员,所以IO运算符一般被声明为友元</p>
<h3 id="重载输入运算符-gt-gt"><a href="#重载输入运算符-gt-gt" class="headerlink" title="重载输入运算符&gt;&gt;"></a>重载输入运算符&gt;&gt;</h3><p>通常情况下,输入运算符的<strong>第一个形参是运算符将要读取的流的引用</strong>,<strong>第二个形参是将要读入到的(非常量)对象的引用</strong>。该运算符通常会返回某个给定流的引|用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Sales_data &amp;item)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">double</span> price;</div><div class="line">    is &gt;&gt; item.bokNo &gt;&gt; item.units_sold &gt;&gt; price;</div><div class="line">    item.revence = item.units_sold * price;</div><div class="line">    <span class="keyword">return</span> is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>输入时的错误</p>
</blockquote>
<ul>
<li>当流含有错误类型的数据时读取操作可能失败。</li>
<li>当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败。</li>
</ul>
<h2 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h2><p>我们把<strong>算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换</strong>。因为这些运算符一般不需要改变运算对象的状态,所以形参都是常量的引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Sales_data <span class="keyword">operator</span>+(Sales_data &amp;lhs, Sales_data &amp;rhs)</div><div class="line">&#123;</div><div class="line">    Sale_data sum = lhs;</div><div class="line">    sum += rhs;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><p>C++中的类通过定义相等运算符来检验两个对象是否相等。</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15203006569640.jpg" alt=""></p>
<p>设计准则：</p>
<ol>
<li>如果一个类含有判断两个对象是否相等的操作,则它显然应该把函数定义成oprator=而非一个普通的命名函数:因为用户肯定希望能使用==比较对象,所以提供了==就意味着用户无须再费时费力地学习并记忆一个全新的函数名字此外,类定义了==运算符之后也更容易使用标准库容器和算法。</li>
<li>如果类定义了 perator==,则该运算符应该能判断一组给定的对象中是否含有重复数据。</li>
<li>通常情况下,相等运算符应该具有传递性</li>
<li>如果类定义了 operator==,则这个类也应该定义 operator!=。对于用户来说当他们能使用==时肯定也希望能使用!=,反之亦然</li>
<li>相等运算符和不相等运算符中的一个应该把工作委托给另外一个</li>
</ol>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>定义了相等运算符的类也常常(但不总是)包含关系运算符。特别是,因为关联容器和一些算法要用到小于运算符,所以定义。 operator&lt;会比较有用。</p>
<ol>
<li>定义顺序关系，令其与关联容器中对关键词的要求一致</li>
<li>如果类同时含有==运算符的话，则定义一种关系令其与==保持一致</li>
</ol>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>之前已经介绍过拷贝赋值和移动赋值运算符,它们可以把<strong>类的一个对象赋值给该类的另一个对象</strong>。此外,类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象。</p>
<p>复合赋值运算符不非得是类的成员,不过我们还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部。为了与内置类型的复合赋值保持一致,类中的复合赋值运算符也要返回其左侧运算对象的引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Sale_data &amp;Sale_data::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Sale_data &amp;rhs)</div><div class="line">&#123;</div><div class="line">    units_sold += rhs.units_sold;</div><div class="line">    revenue += rhs.revenus;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><p>表示容器的类通常可以通过元素在容器中的位置访问元素,这些类一般会定义下标运算符 operator[]。</p>
<p><strong>下标运算符必须是成员函数</strong></p>
<p>为了与下标的原始定义兼容,<strong>下标运算符通常以所访问元素的引用作为返回值</strong>,这样做的好处是下标可以出现在赋值运算符的任意一端。进一步,我们最好<strong>同时定义下标运算符的常量版本和非常量版本</strong>,当作用于一个常量对象时,下标运算符返回常量引用以确保我们不会给返回的对象赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">class</span> StrVec &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</div><div class="line">    &#123; <span class="keyword">return</span> element[n]; &#125;</div><div class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) <span class="keyword">const</span></div><div class="line">    &#123; <span class="keyword">return</span> element[n]; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p>在迭代器类中通常会实现递増运算符(++)和递减运算符(–),这两种运算符使得类可以在元素的序列中前后移动。</p>
<blockquote>
<p>定义前置递增/递减运算符</p>
</blockquote>
<p>递增和递减运算符的工作机理非常相似:它们首先调用 check函数检验Strblobptr是否有效,如果是,接着检查给定的索引值是否有效。如果 check函数没有抛出异常,则运算符返回对象的引用。</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15203036806102.jpg" alt=""></p>
<blockquote>
<p>区分前置和后置运算符</p>
</blockquote>
<p>要想同时定义前置和后置运算符,必须首先解决一个问题,即普通的重载形式无法区分这两种情况。前置和后置版本使用的是同一个符号,意味着其重载版本所用的名字将是相同的,并且运算对象的数量和类型也相同。</p>
<p>为了解决这个问题,<strong>后置版本接受一个额外的(不被使用)int类型的形参</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15203037487660.jpg" alt=""></p>
<h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><p>在迭代器类及智能指针类中常常用到解引用运算符(*)和箭头运算符(-&gt;)。</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15203038781378.jpg" alt=""></p>
<blockquote>
<p>对箭头运算符返回值的限定</p>
</blockquote>
<p>和大多数其他运算符一样(尽管这么做不太好),我们能令 operator*完成任何我们指定的操作。换句话说,我们可以让 operator*返回一个固定值42,或者打印对象的内容,或者其他。<strong>箭头运算符则不是这样,它永远不能丢掉成员访问这个最基本的含义</strong>。当我们重载箭头时,可以改变的是箭头从哪个对象当中获取成员,而箭头获取成员这一事实则永远不变。</p>
<h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h2><p>如果类重载了函数调用运算符,则我们可以像使用函数一样使用该类的对象</p>
<h3 id="lambda-是函数对象"><a href="#lambda-是函数对象" class="headerlink" title="lambda 是函数对象"></a>lambda 是函数对象</h3><p>当我们编写了一个 lambda后,编译器将该表达式翻译成一个未命名类的未命名对象。在 lambda表达式产生的类中含有一个重载的函数调用运算符</p>
<h2 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h2><p>我们同样能定义对于类类型的类型转换,通过定义类型转换运算符可以做到这一点。转换构造函数和类型转换运算符共同定义了<strong>类类型转换</strong>( class-type conversions),这样的转换有时也被称作用户定义的类型转换(user- defined conversions)</p>
<h3 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h3><p>类型转换运算符( conversion operator)是类的一种特殊成员函数,它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">operator type()const;</div></pre></td></tr></table></figure></p>
<p>其中type表示某种类型。类型转换运算符可以面向任意类型(除了void之外)进行定义,只要该类型能作为函数的返回类型。因此,我们不允许转换成数组或者函数类型,但允许转换成指针(包括数组指针及函数指针)或者引用类型类型</p>
<p>转换运算符既没有显式的返回类型,也没有形参,而且必须定义成类的成员函数。类型转换运算符通常不应该改变待转换对象的内容,因此,类型转换运算符一般被定义成const成员。</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15203046723464.jpg" alt=""></p>
<h3 id="避免有二义性的类型转换"><a href="#避免有二义性的类型转换" class="headerlink" title="避免有二义性的类型转换"></a>避免有二义性的类型转换</h3><p>如果类中包含一个或多个类型转换,则必须确保在类类型和目标类型之间只存在唯一一种转换方式。否则的话,我们编写的代码将很可能会具有二义性在两种情况下可能产生多重转换路径。</p>
<p>第一种情况是<strong>两个类提供相同的类型转换</strong>;例如,当A类定义了一个接受B类对象的转换构造函数,同时B类定义了一个转换目标是A类的类型转换运算符时,我们就说它们提供了相同的类型转换</p>
<p>第二种情况是<strong>类定义了多个转换规则,而这些转换涉及的类型本身可以通过其他类型转换联系在一起</strong>。最典型的例子是算术运算符,对某个给定的类来说,最好只定义最多个与算术类型有关的转换规则。</p>
<hr>
<h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="OOP：概述"><a href="#OOP：概述" class="headerlink" title="OOP：概述"></a>OOP：概述</h2><p>面向对象程序设计( object-oriented programmin)的核心思想是<strong>数据抽象、继承和动态绑定</strong>。通过使用数据抽象,我们可以将类的接口与实现分离(见第7章);使用继承,可以定义相似的类型并对其相似关系建模;使用动态绑定,可以在一定程度上忽略相似类型的区别,而以统一的方式使用它们的对象。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>通过继承( inheritance)联系在一起的类构成一种层次关系。通常在层次关系的根部有一个<strong>基类</strong>( base class),其他类则直接或间接地从基类继承而来,这些继承得到的类称为<strong>派生类</strong>( derived class)。</p>
<p>在C++语言中,基类将<strong>类型相关的函数与派生类不做改变直接继承的函数区分对待</strong>。对于某些函数,<strong>基类希望它的派生类各自定义适合自身的版本,此时基类就将这些函数声明成虚函数</strong>( virtual function)。</p>
<p>派生类必须通过使用<strong>类派生列表</strong>( class derivation list)明确指出它是从哪个(哪些)基类继承而来的。类派生列表的形式是:首先是一个冒号,后面紧跟以逗号分隔的基类列表其中每个基类前面可以有访问说明符:</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204752450638.jpg" alt=""></p>
<p>派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上 virtual关键字,但是并不是非得这么做。</p>
<h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>通过使用动态绑定( dynamic binding),我们们能用同一段代码分别处理 Quote和Bu1k_quote的对象(Bulk_quote 继承Quote）</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204753653946.jpg" alt=""></p>
<p>因为函数 print_total的item形参是基类Quote的一个引用,我们既能使用基类Quote的对象调用该函数,也能使用派生类Bulk_quote的对象调用它;</p>
<p>因为在上述过程中函数的运行版本由实参决定,即在运行时选择函数的版本,所以动态绑定有时又被称为运行时绑定(run-time binding)。</p>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><p>基类通常都应该定义一个虚析构函数,即使该函数不执行任何实际操作也是如</p>
<blockquote>
<p>成员函数与继承</p>
</blockquote>
<p>在C++语言中,基类必须将它的两种成员函数区分开来:一种是<strong>基类希望其派生类进行覆盖的函数</strong>:另一种是<strong>基类希望派生类直接继承而不要改变的函数</strong>。对于前者,基类通常将其定义为<strong>虚函数</strong>( virtual)。当我们使用指针或引用调用虚函数时,该调用将被动态绑定。根据引用或指针所绑定的对象类型不同,该调用可能执行基类的版本,也可能执行某个派生类的版本。</p>
<p>任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把个函数声明成虚函数,则该函数在派生类中隐式地也是虚函数。</p>
<p>成员函数如果没被声明为虚函数,则其解析过程发生在编译时而非运行时。</p>
<blockquote>
<p>访问控制和继承</p>
</blockquote>
<p>派生类可以继承定义在基类中的成员,但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样,派生类能访问公有成员,而不能访问私有成员。不过在某些时候基类中还有这样一种成员,基类希望它的派生类有权访问该成员,同时禁止其他用户访向。我们用受保护的( protected)访向运算符说明这样的成员。</p>
<h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><p>派生类必须通过使用类派生列表( class derivation list)明确指出它是从哪个(哪些)基类继承而来的。类派生列表的形式是:首先是一个冒号,后面紧跟以逗号分隔的基类列表,其中每个基类前面可以有以下三种访问说明符中的一个:<strong>public、 protected或者private</strong></p>
<p>派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明,因此,我们的Bulk_quote类必须包含一个 net_price成员:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Bulk_quote : <span class="keyword">public</span> Quote &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Bulk_quote() = <span class="keyword">default</span>;</div><div class="line">    Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;, <span class="keyword">double</span>, <span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">double</span>);</div><div class="line">    <span class="comment">// 覆盖基类函数</span></div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> override</span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> min_qty = <span class="number">0</span>;</div><div class="line">    <span class="keyword">double</span> discount = <span class="number">0.0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大多数类都只继承自一个类,这种形式的继承被称作“单继承”,</p>
<blockquote>
<p>派生类中的虚函数</p>
</blockquote>
<p>派生类经常(但不总是)覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数,则该虚函数的行为类似于其他的普通成员,派生类会直接继承其在基类中的版本。</p>
<p>派生类可以在它覆盖的函数前使用 virtual关键字,但不是非得这么做。</p>
<blockquote>
<p>派生类对象及派生类向基类的类型转换</p>
</blockquote>
<p>一个派生类对象包含多个组成部分:一个含有<strong>派生类自己定义的(非静态)成员的子对象</strong>,以及一个与该派生类<strong>继承的基类对应的子对象</strong>,如果有多个基类,那么这样的子对象也有多个。</p>
<p>因为在派生类对象中含有与其基类对应的组成部分,所以我们<strong>能把派生类的对象当成基类对象来使用</strong>,而且我们也能将基类的<strong>指针或引用</strong>绑定到派生类对象中的基类部分上</p>
<p>这种转换通常称为派生类到基类的( derived-to-base)类型转换。和其他类型转换一样,编译器会隐式地执行派生类到基类的转专换</p>
<blockquote>
<p>派生类构造函数</p>
</blockquote>
<p>尽管在派生类对象中含有从基类继承而来的成员,但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样,派生类也必须使用基类的构造函数来初始化它的基类部分</p>
<p>派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段执行初始化操作的。类似于我们初始化成员的过程,派生类构造函数同样是<strong>通过构造函数初始化列表来将实参传递给基类构造函数的</strong>。</p>
<p>除非我们特别指出,否则派生类对象的基类部分会像数据成员一样执行默认初始化。如果想使用其他的基类构造函数,我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。</p>
<blockquote>
<p>派生类使用基类成员</p>
</blockquote>
<p>派生类可以访问基类的公有成员和受保护成员:</p>
<p>目前只需要了解<strong>派生类的作用域嵌套在基类的作用域之内</strong>。因此,对于派生类的一个成员来说,它使用派生类成员(例如min aty和 discount)的方式与使用基类成员(例如 price)的方式没什么不同。</p>
<blockquote>
<p>继承与静态成员</p>
</blockquote>
<p>如果基类定义了一个静态成员,则在<strong>整个继承体系中只存在该成员的唯一定义</strong>。不论从基类中派生出来多少个派生类,对于每个静态成员来说都只存在唯一的实例。</p>
<p>静态成员遵循通用的访问控制规则,如果基类中的成员是pr⊥Vate的,则派生类无权访问它。假设某静态成员是可访问的,则我们既能通过基类使用它也能通过派生类使用它</p>
<blockquote>
<p>派生类的声明</p>
</blockquote>
<p>派生类的声明与其他类差别不大(参见7.3.3节,第250页),声明中包含类名但是不包含它的派生列表:</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204772352734.jpg" alt=""></p>
<blockquote>
<p>被用作基类的类</p>
</blockquote>
<p>如果我们想将某个类用作基类,则该类必须已经定义而非仅仅声明:</p>
<p>这一规定的原因显而易见:派生类中包含并且可以使用它从基类继承而来的成员,为了使用这些成员,派生类当然要知道它们是什十么。</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204772841857.jpg" alt=""></p>
<p>在这个继承关系中,Base是D1的直接基类( direct base),同时是D2的间接基类( indirectbase)。直接基类出现在派生列表中,而间接基类由派生类通过其直接基类继承而来</p>
<p>最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。</p>
<blockquote>
<p>防止继承发生</p>
</blockquote>
<p>有时我们会定义这样一种类,我们不希望其他类继承它,或者不想考虑它是否适合作为一个基类。为了实现这一日的,C++11新标准提供了一种防止继承发生的方法,即在类名后跟一个关键字final:</p>
<h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>通常情况下,如果我们想把引用或指针绑定到一个对象上,则引用或指针的类型应与对象的类型一致。存在继承关系的类是一个重要的意外：<strong>我们可以把基类的指针或者应用绑定到派生类对象上</strong>。</p>
<p>可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义:当使用基类的引用(或指针)时,实际上我们并不清楚该引用(或指针)所绑定对象的真实类型。该对象可能是基类的对象,也可能是派生类的对象。</p>
<blockquote>
<p>静态类型与动态类型</p>
</blockquote>
<p>当我们使用存在继承关系的类型时,必须<strong>将一个变量或其他表达式的静态类型</strong>( static type)与该表达式表示对象的动态类型( dynamic type)区分开来。表达式的静态类型在编译时总是已知的,它是变量声明时的类型或表达式生成的类型:动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。</p>
<p><strong>如果表达式既不是引用也不是指针,则它的动态类型永远与静态类型一致</strong>。</p>
<blockquote>
<p>不存在从基类向派生类的隐式类型转换</p>
</blockquote>
<p>之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分,而基类的引用或指针可以绑定到该基类部分上。一个基类的对象既可以以独立的形式存在,也可以作为派生类对象的一部分存在。如果基类对象不是派生类对象的一部分,则它只含有基类定义的成员,而不含有派生类定义的成员。</p>
<blockquote>
<p>对象之间不存在转换</p>
</blockquote>
<p>派生类向基类的自动类型转换只对指针或引用类型有效,在派生类类型和基类类型之间不存在这样的转换。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><blockquote>
<p>对虚函数的调用可能在运行时才被解析</p>
</blockquote>
<p>当某个虚函数通过指针或引用调用时,编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个</p>
<p>必须要搞清楚的一点是,动态绑定只有当我们通过指针或引用调用虚函数时才会发生。当我们通过一个具有普通类型(非引用非指针)的表达式调用虚函数时,在编译时就会将调用的版本确定下来。</p>
<blockquote>
<p>派生类中的虚函数</p>
</blockquote>
<p>当我们在派生类中覆盖了某个虚函数时,可以再一次使用 virtual关键字指出该函数的性质。然而这么做并非必须,因为<strong>一旦某个函数被声明成虚函数,则在所有派生类中它都是虚函数</strong>。</p>
<p>一个派生类的函数如果覆盖了某个继承而来的虚函数,则它的形参类型必须与被它覆盖的基类函数完全一致。</p>
<blockquote>
<p>final 和 override说明符</p>
</blockquote>
<p>派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同,这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时,派生类的函数并没有覆盖掉基类中的版本。就实际的编程习惯而言,这种声明往主往意味着发生了错误,因为我们可能原本希望派生类能覆盖掉基类中的虚函数,但是一不小心把形参列表弄错了。</p>
<p>在C++11新标准中我们可以使用override关键字来说明派生类中的虚函数。这么做的好处是在使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误,后者在编程实践中显得更加重要。</p>
<p>我们还能把某个函数指定为final,如果我们已经把函数定义成final了,则之后任何尝试覆盖该函数的操作都将引发错误</p>
<p>同一个函数可以同时添加final和override说明符；</p>
<blockquote>
<p>虚函数和默认实参</p>
</blockquote>
<p>和其他函数一样,虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参,则该实参值由本次调用的静态类型决定。</p>
<p>换句话说,如果我们通过基类的引用或指针调用函数,则使用基类中定义的默认实参,即使实际运行的是派生类中的函数版本也是如此匕。此时,传入派生类函数的将是基类函数定义的默认实参。</p>
<blockquote>
<p>回避虚函数的机制</p>
</blockquote>
<p>在某些情况下,我们希望对虚函数的调用不要进行动态绑定,而是强迫其执行虚函数的某个特定版本。</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204936697970.jpg" alt=""></p>
<p>什么时候我们需要回避虚函数的默认机制呢?通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。</p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><blockquote>
<p>纯虚函数</p>
</blockquote>
<p>当我们不想让用户从一个类中创建一个对象时，我们可以使用纯虚函数。</p>
<p>和普通的虚函数不一样,一个纯虚函数无须定义。我们通过在函数体的位置(即在声明语句的分号之前)书写=0就可以将一个虚函数说明为纯虚函数。其中,=0只能出现在类内部的虚函数声明语句处</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 用于保存折扣值和购买量的类</span></div><div class="line"><span class="keyword">class</span> Disc_quote</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Disc_quote() = <span class="keyword">default</span>;</div><div class="line">	Disc_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price, </div><div class="line">		<span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> dsc) :</div><div class="line">			Quote(book, price), quantity(qty), discount(disc) &#123; &#125;;</div><div class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> quantity = <span class="number">0</span>;</div><div class="line">	<span class="keyword">double</span> discount = <span class="number">0.0</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>含有纯虚函数的类是抽象基类</p>
</blockquote>
<p>含有(或者未经覆盖直接继承)纯虚函数的类是抽象基类( abstract base class)。<strong>抽象基类负责定义接口,而后续的其他类可以覆盖该接口。我们不能(直接)创建一个抽象基类的对象</strong>。</p>
<blockquote>
<p>重构</p>
</blockquote>
<p>重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。对于面向对象的应用程序来说,重构是一种很普遍的现象。</p>
<h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><blockquote>
<p>受保护成员</p>
</blockquote>
<p>一个类使用 protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。 </p>
<blockquote>
<p>公有、私有和受保护继承</p>
</blockquote>
<p>某个类对其继承而来的成员的访问权限受到两个因素影响:一是在<strong>基类中该成员的访问说明符</strong>,二是在<strong>派生类的派生列表中的访问说明符</strong>。</p>
<p>派生访问说明符对于派生类的成员(及友元)能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关。 </p>
<p>派生访问说明符的目的是<strong>控制派生类用户(包括派生类的派生类在内)对于基类成员的访问权限</strong>:</p>
<p>假设我们之前还定义了一个名为 Prot_derv的类,它采用受保护继承,则Base的所有公有成员在新定义的类中都是受保护的。 Prot_Derv的用户不能访间 pub_mem,但是 Prot_derv的成员和友元可以访问那些继承而来的成员</p>
<blockquote>
<p>友元和继承</p>
</blockquote>
<p>就像友元关系不能传递一样,友元关系同样也不能继承。<strong>基类的友元在访问派生类成员时不具有特殊性</strong></p>
<p>当一个类将另一个类声明为友元时,这种友元关系只对做出声明的类有效。对于原来那个类来说,其友元的基类或者派生类不具有特殊的访问能力</p>
<blockquote>
<p>改变个别成员的可访问性</p>
</blockquote>
<p>有时我们需要改变派生类继承的某个名字的访问级别,通过使用 using声明。</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15205140838880.jpg" alt=""></p>
<p>因为 Derived使用了私有继承,所以继承而来的成员s1ze和n(在默认情况下)是Derived的私有成员。然而,我们使用us1ng声明语句改变了这些成员的可访问性。改变之后, Derived的用户将可以使用size成员,而 Derived的派生类将能使用n</p>
<blockquote>
<p>默认的继承保护级别</p>
</blockquote>
<p>我们曾经介绍过使用 struct和c1asS关键字定义的类具有不同的默认访问说明符。类似的,默认派生运算符也由定义派生类所用的关键字来决定默认情况下,<strong>使用c1ass关键字定义的派生类是私有继承的;而使用 struct关键字定义的派生类是公有继承的:</strong></p>
<p>两者的差别只有这一个。</p>
<h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><p>每个类定义自己的作用域,在这个作用域内我们定义类的成员。当存在继承关系时,<strong>派生类的作用域嵌套在其基类的作用域之内</strong>。如果一个名字在派生类的作用域内无法正确解析,则编译器将继续在外层的基类作用域中寻找该名字的定义</p>
<blockquote>
<p>在编译时进行名字查找</p>
</blockquote>
<p>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致(当使用基类的引用或指针时会发生这种情况),但是我们能使用哪些成员仍然是由静态类型决定的。</p>
<blockquote>
<p>名字冲突和继承</p>
</blockquote>
<p>和其他作用域一样,派生类也能重用定义在其直接基类或间接基类中的名字,此时<strong>定义在内层作用域(即派生类)的名字将隐藏定义在外层作用域(即基类)的名字</strong></p>
<blockquote>
<p>通过作用域运算符来使用隐藏的成员</p>
</blockquote>
<p>我们可以通过作用域运算符来使用一个被隐藏的基类成员:</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15205150138642.jpg" alt=""></p>
<p>作用域运算符将覆盖掉原有的査找规则,并指示编译器从BaSe类的作用域开始査找mem</p>
<blockquote>
<p>一如既往，名字查找先于类型检查</p>
</blockquote>
<p>如前所述,<strong>声明在内层作用域的函数并不会重载声明在外层作用域的函数</strong>。因此,定义派生类中的函数也不会重载其基类中的成员。和其他作用域样,如果派生类(即内层作用域)的成员与基类(即外层作用域)的某个成员同名,则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致,基类成员也仍然会被隐藏掉</p>
<blockquote>
<p>虚函数与作用域</p>
</blockquote>
<p>我们现在可以理解为什么基类与派生类中的虚函数必须有相同的形参列表了。<strong>假如基类与派生类的虚函数接受的实参不同,则我们就无法通过基类的引用或指针调用派生类的虚函数了</strong>。例如:</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15205151324990.jpg" alt=""></p>
<blockquote>
<p>覆盖重载的函数</p>
</blockquote>
<p>如果派生类希望所有的重载版本对于它来说都是可见的,那么它就需要覆盖所有的版本,或者一个也不覆盖。有时一个类仅需覆盖重载集合中的一些而非全部函数</p>
<h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>继承关系对基类拷贝控制最直接的影响是<strong>基类通常应该定义一个虚析构函数</strong>,这样我们就能动态分配继承体系中的对象了。如前所述,当我们de1ete一个动态分配的对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型,则有可能出现指针的静态类型与被删除对象的动态类型不符的情况</p>
<p>我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本:</p>
<p>和其他虚函数一样,析构函数的虚属性也会被继承。</p>
<p><strong>如果一个类需要析构函数,那么它也同样需要拷贝和赋值操作。基类的析构函数并不遵循上述准则</strong>,它是个重要的例外。一个基类总是需要析构函数,而且它能将析构函数设定为虚函数。</p>
<blockquote>
<p>虚析构函数将阻止合成移动操作</p>
</blockquote>
<p>基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响:如果一个类定义了析构函数,即使它通过= defau1t的形式使用了合成的版本,编译器也不会为这个类合成移动操作</p>
<h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><p>基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似:它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外,这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。</p>
<ul>
<li>合成的Bu1k_quote默认构造函数运行 Disc_quote的默认构造函数,后者又运行 Quote的默认构造函数。</li>
</ul>
<p>无论基类成员是合成的版本(如ρuote继承体系的例子)还是自定义的版本都没有太大影响。唯一的要求是相应的成员应该可访问并且不是一个被删除的函数。</p>
<blockquote>
<p>派生类中的删除的拷贝控制与基类的关系</p>
</blockquote>
<p>基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员定义成被删除的函数</p>
<ul>
<li>·如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问,则派生类中对应的成员将是被删除的,原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作</li>
<li>·如果在基类中有一个不可访问或删除掉的析构函数,则派生类中合成的默认和拷贝构造函数将是被删除的,因为编译器无法销毁派生类对象的基类部分。</li>
</ul>
<blockquote>
<p>移动操作与继承</p>
</blockquote>
<p>大多数基类都会定义一个虚析构函数。因此在默认情况下,基类通常不含有合成的移动操作,而且在它的派生类中也没有合成的移动操作。</p>
<h3 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h3><p>派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员,还负责初始化派生类对象的基类部分。因此,派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时,也要拷贝和移动基类部分的成员。类似的,派生类赋值运算符也必须为其基类部分的成员赋值。</p>
<blockquote>
<p>定义派生类的拷贝和移动构造函数</p>
</blockquote>
<p>当为派生类定义拷贝或移动构造函数时,我们通常使用对应的基类构造函数初始化对象的基类部分</p>
<p><img src="https://data2.liuin.cn/2018-03-09-15205965427434.jpg" alt=""></p>
<blockquote>
<p>派生类赋值运算符</p>
</blockquote>
<p>与拷贝和移动构造函数一样,派生类的赋值运算符也必须显式地为其基类部分赋值:</p>
<p>值得注意的是,无论基类的构造函数或赋值运算符是自定义的版本还是合成的版本,派生类的对应操作都能使用它们。</p>
<blockquote>
<p>派生类析构函数</p>
</blockquote>
<p>在析构函数体执行完成后,对象的成员会被隐式销毁。类似的,对象的基类部分也是隐式销毁的。因此,和构造函数及赋值运算符不同的是,派生类析构函数只负责销毁由派生类自己分配的资源:</p>
<p>对象销毁的顺序正好与其创建的顺序相反:派生类析构函数首先执行,然后是基类的析构函数,以此类推,沿着继承体系的反方向直至最后。</p>
<blockquote>
<p>在构造函数和析构函数中调用虚函数</p>
</blockquote>
<p>派生类对象的基类部分将首先被构建。当执行基类的构造函数时,该对象的派生类部分是未被初始化的状态。类似的,销毁派生类对象的次序正好相反,因此当执行基类的析构函数时,派生类部分已经被销毁掉了。</p>
<p>为了能够正确地处理这种未完成状态,编译器认为对象的类型在构造或析构的过程中仿佛发生了改变一样。也就是说,<strong>当我们构建一个对象时,需要把对象的类和构造函数的类看作是同一个;对虚函数的调用绑定正好符合这种把对象的类和构造函数的类看成同一个的要求;对于析构函数也是同样的道理。</strong></p>
<h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><p>在C++11新标准中,派生类能够重用其直接基类定义的构造函数。尽管如我们所知,这些构造函数并非以常规的方式继承而来,但是为了方便,我们不妨姑且称其为“继承”的。一个类只初始化它的直接基类,出于同样的原因,一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数,则编译器将为派生类合成它们。</p>
<p>派生类继承基类构造函数的方式是提供一条注明了(直接)基类名的uS1ng声明语句。举个例子,我们可以重新定义Bu1k_quote类,令其继承Disc_quote类的构造函数:</p>
<p><img src="https://data2.liuin.cn/2018-03-09-15205968035260.jpg" alt=""></p>
<blockquote>
<p>继承的构造函数的特点</p>
</blockquote>
<p>和普通成员的 using声明不一样构造函数的 using声明不会改变该构造函数的访问级别。</p>
<h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><p>当我们使用容器存放继承体系中的对象时,通常必须采取间接存储的方式。因为不允许在容器中保存不同类型的元素,所以我们不能把具有继承关系的多种类型的对象直接在放在容器当中。</p>
<blockquote>
<p>在容器中放置（智能）指针而非对象</p>
</blockquote>
<p>当我们希望在容器中存放具有继承关系的对象时,我们实际上存放的通常是基类的指针(更好的选择是智能指针。和往常一样,这些指针所指对象的动态类型可能是基类类型,也可能是派生类类型</p>
<h3 id="编写Basket类"><a href="#编写Basket类" class="headerlink" title="编写Basket类"></a>编写Basket类</h3><p>对于C++面向对象的编程来说,一个悖论是我们无法直接使用对象进行面向对象编程。相反,我们必须使用指针和引用。因为指针会增加程序的复杂性,所以我们经常定义一些辅助的类来处理这种复杂情况。</p>
<hr>
<h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><p>面向对象编程(OOP)和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于:OOP能处理类型在程序运行之前都未知的情况;而在泛型编程中,在编译时就能获知类型了。</p>
<p>模板是C++中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。</p>
<h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>我们可以定义一个通用的函数模板( function template),而不是为每个类型都定义一个新函数。一个函数模板就是一个公式,可用来生成针对特定类型的函数版本。 compare的模板版本可能像下面这样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">if</span>(v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>模板定义以关键字 template开始,后跟一个模板参数列表( template parameter list.,这是一个逗号分隔的一个或多个模板参数( template parameter)的列表,用小于号(&lt;)和大于号(&gt;)包围起来。<strong>在模板定义中，模板参数列表不能为空</strong>。</p>
<p>模板参数表示在类或函数定义中用到的类型或值。当使用模板时,我们(隐式地或显式地)指定模板实参( template argument),将其绑定到模板参数上。</p>
<blockquote>
<p>实例化函数模板</p>
</blockquote>
<p>当我们调用一个函数模板时!,<strong>编译器(通常)用函数实参来为我们推断模板实参</strong>。</p>
<p>编译器用推断出的模板参数来为我们实例化( instantiate)一个特定版本的函数。当编译器实例化一个模板时,它使用实际的模板实参代替对应的模板参数来创建出模板的一个新“实例”。</p>
<blockquote>
<p>模板类型参数</p>
</blockquote>
<p>我们的 compare函数有一个模板<strong>类型参数</strong>( type parameter.)。一般来说,我们可以<strong>将类型参数看作类型说明符</strong>,就像内置类型或类类型说明符一样使用。特别是,类型参数可以用来指定返回类型或函数的参数类型,以及在函数体内用于变量声明或类型转换</p>
<p>类型参数前必须使用关键字c1asS或 typename</p>
<p><img src="https://data2.liuin.cn/2018-03-10-15206812431993.jpg" alt=""></p>
<blockquote>
<p>非类型模板参数</p>
</blockquote>
<p>除了定义类型参数,还可以在模板中定义非类型参数( nontype parameter)。<strong>一个非类型参数表示一个值而非一个类型</strong>。我通过一个特定的类型名而非关键字c1ass或typename来指定非类型参数。</p>
<p>当一个模板被实例化时,非类型参数被一个用户提供的或编译器推断出的值所代替。</p>
<blockquote>
<p>inline 和constexpr 的函数模板</p>
</blockquote>
<p>函数模板可以声明为in1ine或 constexpr的,如同非模板函数一样。in1ine或constexpr说明符放在模板参数列表之后,返回类型之前:</p>
<blockquote>
<p>编写类型无关的代码</p>
</blockquote>
<p>我们最初的 compare函数虽然简单,但它说明了编写泛型代码的两个重要原则:</p>
<ul>
<li>模板中的函数参数是 const的引用</li>
<li>函数体中的条件判断仅使用&lt;比较运算</li>
</ul>
<p>通过将函数参数设定为 const的引用,我们保证了函数可以用于不能拷贝的类型。</p>
<p>如果编写代码时只使用&lt;运算符,我们就降低了 compare函数对要处理的类型的要求。这些类型必须支持&lt;,但不必同时支持&gt;。</p>
<blockquote>
<p>模板编译</p>
</blockquote>
<p>当编译器遇到一个模板定义时,它并不生成代码。<strong>只有当我们实例化出模板的一个特定版本时,编译器才会生成代码</strong>。当我们使用(而不是定义)模板时,编译器才生成代码特性影响了我们如何组织代码以及错误何时被检测到。</p>
<p>为了生成一个实例化版本,编译器需要掌握函数模板或类模板成员函数的定义。因此,与非模板代码不同,模板的头文件通常既包括声明也包括定义。</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板( class template)是用来生成类的蓝图的。与函数模板的不同之处是,<strong>编译器不能为类模板推断模板参数类型</strong>。如我们已经多次看到的,<strong>为了使用类模板,我们必须在模板名后的尖括号中提供额外信息</strong>——用来代替模板参数的模板实参列表。</p>
<blockquote>
<p>定义类模板</p>
</blockquote>
<p>类似函数模板,类模板以关键字 template开始,后跟模板参数列表。在类模板(及其成员)的定义中,我们将模板参数当作替身,代替使用模板时用户需要提供的类型或值:</p>
<p><img src="https://data2.liuin.cn/2018-03-10-15206822514896.jpg" alt=""></p>
<blockquote>
<p>实例化类模板</p>
</blockquote>
<p>当使用一个类模板时,我们必须提供额外信息。我们现在知道这些额外信息是显式模板实参( explicit template argument)列表,它们被绑定到模板参数。编译器使用这些模板实参来实例化出特定的类。</p>
<blockquote>
<p>在模板作用域中引用模板类型</p>
</blockquote>
<p>为了阅读模板类代码,应该记住类<strong>模板的名字不是一个类型名</strong>。类模板用来实例化类型,而一个实例化的类型总是包含模板参数的</p>
<p>可能令人迷惑的是,<strong>一个类模板中的代码如果使用了另外一个模板,通常不将一个实际类型(或值)的名字用作其模板实参。相反的,我们通常将模板自己的参数当作被使用模板的实参</strong>。</p>
<p>例如,我们的data成员使用了两个模板, vector和 shared_ptr。我们知道,无论何时使用模板都必须提供模板实参。在本例中,我们提供的模板实参就是Bob的模板参数。因此,data的定义如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::share_ptr&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; &gt; data;</div></pre></td></tr></table></figure>
<blockquote>
<p>类模板的成员函数</p>
</blockquote>
<p>与其他任何类相同,我们既可以在类模板内部,也可以在类模板外部为其定义成员函数,且<strong>定义在类模板内的成员函数被隐式声明为内联函数</strong>。</p>
<p>类模板的成员函数本身是一个普通函数。但是,类模板的每个实例都有其自己版本的成员函数。因此,类模板的成员函数具有和模板相同的模板参数。因而,定义在类模板之外的成员函数就必须以关键字temp1ate开始,后接类模板参数列表。</p>
<p>当我们在类外定义一个成员时,必须说明成员属于哪个类。而且,<strong>从一个模板生成的类的名字中必须包含其模板实参</strong>。</p>
<blockquote>
<p>类模板成员函数的实例化</p>
</blockquote>
<p>默认情况下,一个类模板的成员函数只有当程序用到它时才进行实例化。</p>
<p>如果一个成员函数没有被使用,则它不会被实例化。成员函数只有在被用到时才进行实例化,这一特性使得即使某种类型不能完全符合模板操作的要求。</p>
<blockquote>
<p>在类代码内简化模板类名的使用</p>
</blockquote>
<p>当我们使用一个类模板类型时必须提供模板实参,但这一规则有一个例外。<strong>在类模板自己的作用域中,我们可以直接使用模板名而不提供实参</strong></p>
<blockquote>
<p>在类模板外使用类模板名</p>
</blockquote>
<p>当我们在类模板外定义其成员时,必须记住,我们并不在类的作用域中,直到遇到类名才表示进入类的作用域(参见</p>
<blockquote>
<p>模板类和友元</p>
</blockquote>
<p>当一个类包含一个友元声明时,类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板友元,则友元被授权可以访问所有模板实例。如果友元自身是模板,类可以授权给所有友元模板实例,也可以只授权给特定实例</p>
<blockquote>
<p>一对一友好关系</p>
</blockquote>
<p><strong>类模板与另一个(类或函数)模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-03-10-15206826958070.jpg" alt=""></p>
<blockquote>
<p>通用和特定的友好关系</p>
</blockquote>
<p>一个类也可以将另一个模板的每个实例都声明为自己的友元,或者限定特定的实例为友元</p>
<p>为了让所有实例成为友元,友元声明中必须使用与类模板本身不同的模板参数</p>
<blockquote>
<p>模板类型别名</p>
</blockquote>
<p>类模板的一个实例定义了一个类类型,与任何其他类类型一样,我们可以定义一个typedef来引用实例化的类:</p>
<p><code>typedef Blob&lt;string&gt; StrBlob;</code></p>
<blockquote>
<p>类模板的static成员</p>
</blockquote>
<p>与任何其他 static数据成员相同,模板类的每个 static数据成员必须有且仅有个定义。但是,类模板的每个实例都有一个独有的 static对象。因此,与定义模板的成员函数类似,我们将 static数据成员也定义为模板</p>
<p>与非模板类的静态成员相同,我们可以通过类类型对象来访问一个类模板的 statio成员,也可以使用作用域运算符直接访问成员。当然,为了通过类来直接访问 static成员,我们必须引用一个特定的实例</p>
<h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><p>类似函数参数的名字,一个模板参数的名字也没有什么内在含义。我们通常将类型参数命名为T,但实际上我们们可以使用任何名字:</p>
<blockquote>
<p>模板参数与作用域</p>
</blockquote>
<p>模板参数遵循普通的作用域规则。<strong>一个模板参数名的可用范围是在其声明之后,至模板声明或定义结束之前</strong>。与任何其他名字一样,模板参数会隐藏外层作用域中声明的相同名字。</p>
<blockquote>
<p>模板声明</p>
</blockquote>
<p>模板声明必须包含模板参数，一个给定模板的每个声明和定义必须有相同数量和种类(即,类型或非类型)的参数。</p>
<blockquote>
<p>使用类的类型成员</p>
</blockquote>
<p>假定T是一个模板类型参数,当编译器遇到类似里T::mem这样的代码时,它不会知道mem是一个类型成员还是一个 static数据成员,直至实例化时才会知道。但是,为了处理模板,编译器必须知道名字是否表示一个类型。</p>
<p>默认情况下,<strong>C++语言假定通过作用域运算符访问的名字不是类型</strong>。因此,如果我们希望使用一个模板类型参数的类型成员,就必须显式告诉编译器该名字是一个类型。</p>
<blockquote>
<p>默认模板实参</p>
</blockquote>
<p>就像我们能为函数参数提供默认实参一样,我们也可以提供默认模板实参( default template argument)。</p>
<blockquote>
<p>模板默认实参与类模板</p>
</blockquote>
<p>无论何时使用一个类模板,我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。特别是,如果一个类模板为其所有模板参数都提供了默认实参,且我们希望使用这些默认实参,就必须在模板名之后跟一个空尖括号对:</p>
<h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><p>一个类(无论是普通类还是类模板)可以包含本身是模板的成员函数。这种成员被称为成员模板( member template)。成员模板不能是虚函数。</p>
<blockquote>
<p>普通（非模板）类的成员模板</p>
</blockquote>
<p><img src="https://data2.liuin.cn/2018-03-12-15208165159357.jpg" alt=""></p>
<blockquote>
<p>类模板的成员模板</p>
</blockquote>
<p>对于类模板,我们也可以为其定义成员模板。在此情况下,类和成员各自有自己的、独立的模板参数。</p>
<p>与类模板的普通函数成员不同,成员模板是函数模板。当我们在类模板外定义一个成员模板时,必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前,后跟成员自己的模板参数列表:</p>
<blockquote>
<p>实例化与成员模板</p>
</blockquote>
<p>为了实例化一个类模板的成员模板,我们必须同时提供类和函数模板的实参。与往常样,我们在哪个对象上调用成员模板,编译器就根据该对象的类型来推断类模板参数的实参。</p>
<h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><p>当模板被使用时才会进行实例化这一特性意味着,<strong>相同的实例可能出现在多个对象文件中</strong>。当两个或多个独立编译的源文件使用了相同的模板并提供了相同的模板参数时,每个文件中就都会有该模板的一个实例。</p>
<p>在大系统中,在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中,我们可以通过显式实例化( explicit instantiation)来避免这种开销。一个显式实例化有如下：</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208167547457.jpg" alt=""></p>
<p>当编译器遇到 extern模板声明时,它不会在本文件中生成实例化代码。将一个实例化声明为 extern就表示承诺在程序其他位置有该实例化的一个非 extern声明(定义)。</p>
<blockquote>
<p>实例化定义会实例化所有成员</p>
</blockquote>
<p><strong>一个类模板的实例化定义会实例化该模板的所有成员,包括内联的成员函数</strong>。当编译器遇到一个实例化定义时,它不了解程序使用哪些成员函数。因此,与处理类模板的普通实例化不同,编译器会实例化该类的所有成员。即使我们不使用某个成员,它也会被实例化。因此,我们用来显式实例化一个类模板的类型,必须能用于模板的所有成员</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 题解——Container With Most Water]]></title>
      <url>/2018/03/09/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Container-With-Most-Water/</url>
      <content type="html"><![CDATA[<p>LeetCode 题解——Container With Most Water</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目首先给出一个数组b，数组中的每一个数可以确定平面直角坐标系上的一个点<code>(i,b[i])</code>，两个点可以确定一个容器：两个点分别向x轴引垂线形成的容器，求所有形成的容器中容积（面积）最大的那一个。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先想到的是暴力法，枚举所有的情况，这样的时间复杂度是O(n^2)，要优化这个算法的话，要么就优化成O(logn)或者O(n)，如果想要优化成O(n)的话就意味着扫描一遍即可。</p>
<p>这样可以找到一个贪心的方法：用两个指针从两边向中间进行扫描，这样我们所求的面积的底在变小，要想扫描到更大的面积的情况只有更长的高才有可能找到，所以就在扫描过程中舍弃掉较小高度的点，让指针继续向中间靠拢。</p>
<h2 id="代码（C-）"><a href="#代码（C-）" class="headerlink" title="代码（C++）"></a>代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = height.size()<span class="number">-1</span>;</div><div class="line">        <span class="keyword">int</span> res = min(height[i], height[j])*(j-i);</div><div class="line">        <span class="comment">// 从两边向中间扫描</span></div><div class="line">        <span class="keyword">while</span>(i&lt;j)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(height[i] &lt; height[j])</div><div class="line">                i++;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                j--;</div><div class="line">            res = max(res, min(height[i], height[j])*(j-i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 题解——Regular Expression Matching]]></title>
      <url>/2018/03/09/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Regular-Expression-Matching/</url>
      <content type="html"><![CDATA[<p>LeetCode 题解——Regular Expression Matching</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>实现支持.和*正则匹配</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一开始的想法是从左向右进行模拟匹配，模拟的代码比较长，后面遇到这种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">aaa</div><div class="line">a*a</div></pre></td></tr></table></figure></p>
<p>就行不通了</p>
<p>事实上，上面那种情况的我们在匹配a*的时候，要分是否匹配a这个东西分两种情况进行讨论，这个时候就有一种递归的思路：<br>首先判断第一个字符是否匹配，然后判断是否是*模式，是的话可以匹配这个字符也可以不匹配，如果不是*模式的话就判断后面。</p>
<p>递归代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> plen = p.size(), slen = s.size();</div><div class="line">        <span class="keyword">if</span>(plen == <span class="number">0</span>) <span class="keyword">return</span> slen == <span class="number">0</span>;</div><div class="line">        <span class="comment">// 是否匹配第一个</span></div><div class="line">        <span class="keyword">bool</span> matchfirst = (slen != <span class="number">0</span> &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>));</div><div class="line">        <span class="comment">// 是否是*模式</span></div><div class="line">        <span class="keyword">if</span>(plen &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">'*'</span>)</div><div class="line">            <span class="keyword">return</span> (isMatch(s, p.substr(<span class="number">2</span>)) || (matchfirst &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p)));</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> (matchfirst &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>)));</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这样的递归我们会发现有大量的重复调用，这个时候可以使用动态规划进行优化。<br><code>dp[i][j]</code>表示<code>isMatch(s.strsub(i), p.strsub(j))</code>，由上面的递归方案我们可以推得</p>
<p><code>dp[i][j]</code>= </p>
<ol>
<li>dp[i][j+2],当前为*模式时不匹配的情况</li>
<li>dp[i+1][j],当前为*模式，并且第一个字符匹配成功的情况</li>
<li>dp[i+1][j],非*模式，第一个字符匹配成功的情况</li>
</ol>
<p>DP代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> plen = p.length(), slen = s.length();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; dp(slen + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; (plen + <span class="number">1</span>, <span class="literal">false</span>));</div><div class="line">        dp[slen][plen] = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=slen ;i&gt;=<span class="number">0</span>;--i)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=plen<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">// 判断第一个是否匹配</span></div><div class="line">                <span class="keyword">bool</span> match = (i&lt;slen &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">'.'</span>));</div><div class="line">                <span class="comment">// 是*模式，两种方案，匹配/不匹配</span></div><div class="line">                <span class="keyword">if</span>(j+<span class="number">1</span> &lt; plen &amp;&amp; p[j+<span class="number">1</span>] == <span class="string">'*'</span>)</div><div class="line">                    dp[i][j] = dp[i][j+<span class="number">2</span>] || (match &amp;&amp; dp[i+<span class="number">1</span>][j]);</div><div class="line">                <span class="comment">// 非*模式</span></div><div class="line">                <span class="keyword">else</span></div><div class="line">                    dp[i][j] = (match &amp;&amp; dp[i+<span class="number">1</span>][j+<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 题解——Median of Two Sorted Arrays]]></title>
      <url>/2018/03/08/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Median-of-Two-Sorted-Arrays/</url>
      <content type="html"><![CDATA[<p>LeetCode 题解——Median of Two Sorted Arrays</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定两个有序数组，求这两个有序数组中所有数的中位数</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先理解什么是中位数，中位数把这两个数组中的所有的数有序放到一起，排在中间的那一个数（或者两个数）就是中位数，我们也可以从另外一个角度去看，中位数作为边界把这些数分割成两半。这两边的数的个数是相等的。</p>
<p>对于这两个数组就相当于每个数组都有一个数把这个数组分割成两半：</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204918440445.jpg" alt=""></p>
<p>这里考虑使用二分法求解，对于两个数组，两边的数的个数是相等的。由此，考虑一种分割情况，我们可以假设A数组从i点分割，这样因为两边的数的个数相等很容易算得B数组的分割点<code>j=(n+m+1)/2-i</code>，对于每一种分割有三种情况：</p>
<ol>
<li><code>A[i]&gt;=B[j-1] &amp;&amp; B[j]&gt;=A[i-1]</code>这种情况下，刚好取得中位数</li>
<li><code>A[i]&lt;B[j-1]</code> 这种情况下，表示我们选取的i点过小，可以通过二分进一步缩减范围</li>
<li><code>B[j]&lt;A[i-1]</code> 这种情况下，表示我们选取的i点过大，可以通过二分进一步缩减范围</li>
</ol>
<p>除此之外另外还要注意几点：</p>
<ol>
<li>我们选取的i要从数组数量较小的那个数组中选取，因为如果从数组数量大的数组中选取的话，可能导致选取的i较小，使得计算出的j值大于B数组中的元素个数</li>
<li>存在一些特殊情况在端点分割的特殊情况，比如i=0，i=n，j=0，j=m的这些情况。在这样的情况下，我们可以只需要计算左边数的最大值，和右边数的最小值即可。</li>
<li>最后的结果要对总数是奇数还是偶数进行讨论，如果是奇数的话，表示中位数是左边那一堆中的最大值；如果是偶数的话，中位数中左边一堆数的最大值和右边一堆书的最小值的平均值。</li>
</ol>
<h2 id="代码（C-）"><a href="#代码（C-）" class="headerlink" title="代码（C++）"></a>代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = nums1.size(), m = nums2.size();</div><div class="line">        <span class="comment">// 对小的数组进行分割</span></div><div class="line">        <span class="keyword">if</span>(n &gt; m)</div><div class="line">        &#123;</div><div class="line">            swap(nums1, nums2);</div><div class="line">            swap(n,m);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 二分法确定两个界限</span></div><div class="line">        <span class="keyword">int</span> i, j, iMin = <span class="number">0</span>, iMax = n;</div><div class="line">        <span class="keyword">while</span>(iMin &lt;= iMax)</div><div class="line">        &#123;</div><div class="line">            i = (iMin + iMax)/<span class="number">2</span> ;</div><div class="line">            j = (m+n+<span class="number">1</span>)/<span class="number">2</span> - i;</div><div class="line">            <span class="comment">// i的取值过大</span></div><div class="line">            <span class="keyword">if</span>(i &gt; iMin &amp;&amp; nums1[i<span class="number">-1</span>] &gt; nums2[j])</div><div class="line">            &#123;</div><div class="line">                iMax = i - <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// i的取值过小的情况</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; iMax &amp;&amp; nums1[i] &lt; nums2[j<span class="number">-1</span>]) </div><div class="line">            &#123;</div><div class="line">                iMin = i + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 找到中位数</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) left = nums2[j<span class="number">-1</span>];</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) left = nums1[i<span class="number">-1</span>];</div><div class="line">                <span class="keyword">else</span> left = max(nums1[i<span class="number">-1</span>], nums2[j<span class="number">-1</span>]);</div><div class="line">                <span class="comment">// 总数是奇数的时候</span></div><div class="line">                <span class="keyword">if</span> ( (m + n) % <span class="number">2</span>) <span class="keyword">return</span> left;</div><div class="line">                </div><div class="line">                <span class="keyword">int</span> right = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span>(i == n) right = nums2[j];</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == m) right = nums1[i];</div><div class="line">                <span class="keyword">else</span> right = min(nums1[i], nums2[j]);</div><div class="line">                <span class="keyword">return</span> (left + right)/<span class="number">2.0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[APUE 文件I/O]]></title>
      <url>/2018/03/06/APUE-%E6%96%87%E4%BB%B6I-O/</url>
      <content type="html"><![CDATA[<p>《UNIX环境高级编程》第2章 文件I/O 笔记</p>
<a id="more"></a>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>UNX系统中的大多数文件只需用到5个函数:open、read、 write、 lseek以及c1ose。</p>
<p>本章描述的函数经常被称为不带缓冲的I/O( unbuffered I/O,与将在第5章中说明的标准I/O函数相对照)。术语不带缓冲指的是每个read和 write都调用内核中的一个系统调用。</p>
<p>只要涉及在多个进程间共享资源,原子操作的概念就变得非常重要。我们将通过文件IO和open函数的参数来讨论此概念。</p>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>对于内核而言,<strong>所有打开的文件都通过文件描述符引用</strong>。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时,内核向进程返回一个文件描述符。</p>
<p>按照惯例,UNIX系统shell把<strong>文件描述符0与进程的标准输入关联,文件描述符1与标准输出关联,文件描述符2与标准错误关联</strong>。这是各种shel以及很多应用程序使用的惯例.</p>
<h2 id="函数open和openat"><a href="#函数open和openat" class="headerlink" title="函数open和openat"></a>函数open和openat</h2><p>用于打开或者创建一个文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oﬂag, ... <span class="comment">/* mode_t mode */</span> )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oﬂag, ... <span class="comment">/* mode_t mode */</span> )</span></span>; </div><div class="line"><span class="comment">//Both return: ﬁle descriptor if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>我们将最后一个参数写为…,ISO C用这种方法表明余下的参数的数量及其类型是可变的。对于open函数而言,仅当创建新文件时才使用最后这个参数(稍后将对此进行说明)。</p>
<p>path参数是要打开或创建文件的名字。oflag参数可用来说明此函数的多个选项。用一个或者多个常量“或”运算构成oflag参数</p>
<p>使用的常量可以参考原书</p>
<h2 id="函数create"><a href="#函数create" class="headerlink" title="函数create"></a>函数create</h2><p>可以调用create函数创建一个文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">//Returns: ﬁle descriptor opened for write-only if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>此函数等效于<code>open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);</code></p>
<p>creat的一个不足之处是它以只写方式打开所创建的文件。</p>
<h2 id="函数close"><a href="#函数close" class="headerlink" title="函数close"></a>函数close</h2><p>调用close函数关闭一个打开的文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>关闭一个文件时还会释放该进程加在该文件上的所有记录锁。</p>
<p>当一个进程终止时,内核自动关闭它所有的打开文件。很多程序都利用了这一功能而不显式地用c1ose关闭打开文件。</p>
<h2 id="函数lseek"><a href="#函数lseek" class="headerlink" title="函数lseek"></a>函数lseek</h2><p>每个打开文件都有一个与其相关联的“<strong>当前文件偏移量</strong>”( current file offset)。它通常是一个非负整数,用以度量从文件开始处计算的字节数。</p>
<p>调用1seek显式地为一个打开文件设置偏移量：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</div><div class="line"></div><div class="line"><span class="comment">//Returns: new ﬁle offset if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>对参数offet的解释与参数 whence的值有关。</p>
<ul>
<li>若 whence是 SEEK_SET,则将该文件的偏移量设置为距文件开始处 offset个字节。</li>
<li>若 whence是 SEEK_CUR,则将该文件的偏移量设置为其当前值加 offset, offset可为正或负。</li>
<li>若 whence是 SEEK_END,则将该文件的偏移量设置为文件长度加 offset, offset可正可负。</li>
</ul>
<p>通常,文件的当前偏移量应当是一个非负整数,但是,某些设备也可能允许负的偏移量。但对于普通文件,其偏移量必须是非负值。</p>
<p>1seek仅将当前的文件偏移量记录在内核中,它并不引起任何IO操作。然后,该偏移量用于下一个读或写操作。</p>
<p>文件偏移量可以大于文件的当前长度,在这种情况下,对该文件的下一次写将加长该文件,并在文件中构成一个空洞,这一点是允许的。位于文件中但没有写过的字节都被读为0</p>
<p><strong>文件中的空洞并不要求在磁盘上占用存储区</strong>。具体处理方式与文件系统的实现有关,当定位到超出文件尾端之后写时,对于新写的数据需要分配磁盘块,但是对于原文件尾端和新开始写位置之间的部分则不需要分配磁盘块。</p>
<p>创建一个具有空洞的文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">char</span>	buf1[] = <span class="string">"abcdefghij"</span>;</div><div class="line"><span class="keyword">char</span>	buf2[] = <span class="string">"ABCDEFGHIJ"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span>		fd;</div><div class="line"></div><div class="line">	<span class="comment">// 创建文件</span></div><div class="line">	<span class="keyword">if</span> ((fd = creat(<span class="string">"file.hole"</span>, FILE_MODE)) &lt; <span class="number">0</span>)</div><div class="line">		err_sys(<span class="string">"creat error"</span>);</div><div class="line"></div><div class="line">	<span class="comment">// 写入a-j，此时文件偏移量为10</span></div><div class="line">	<span class="keyword">if</span> (write(fd, buf1, <span class="number">10</span>) != <span class="number">10</span>)</div><div class="line">		err_sys(<span class="string">"buf1 write error"</span>);</div><div class="line">	<span class="comment">/* offset now = 10 */</span></div><div class="line"></div><div class="line">	<span class="comment">// 改变文件偏移量到16384</span></div><div class="line">	<span class="keyword">if</span> (lseek(fd, <span class="number">16384</span>, SEEK_SET) == <span class="number">-1</span>)</div><div class="line">		err_sys(<span class="string">"lseek error"</span>);</div><div class="line">	<span class="comment">/* offset now = 16384 */</span></div><div class="line"></div><div class="line">	<span class="comment">// 在新的文件偏移量下写入A-J</span></div><div class="line">	<span class="keyword">if</span> (write(fd, buf2, <span class="number">10</span>) != <span class="number">10</span>)</div><div class="line">		err_sys(<span class="string">"buf2 write error"</span>);</div><div class="line">	<span class="comment">/* offset now = 16394 */</span></div><div class="line"></div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为1seek使用的偏移量是用off_t类型表示的,所以允许具体实现根据各自特定的平台自行选择大小合适的数据类型。</p>
<h2 id="函数read"><a href="#函数read" class="headerlink" title="函数read"></a>函数read</h2><p>调用read函数从打开文件中读数据<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); </div><div class="line"></div><div class="line"><span class="comment">//Returns: number of bytes read, 0 if end of ﬁle, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>如read成功,则返回读到的字节数。如已到达文件的尾端,则返回0。</p>
<p>有多种情况可使实际读到的字节数少于要求读的字节数</p>
<ul>
<li>读普通文件时,在读到要求字节数之前已到达了文件尾端。</li>
<li>当从终端设备读时,通常一次最多读一行。</li>
<li>当从网络读时,网络中的缓冲机制可能造成返回值小于所要求读的字节数</li>
<li>当从管道或FIFO读时,如若管道包含的字节少于所需的数量,那么read将只返回实际可用的字节数</li>
<li>当从某些面向记录的设备(如磁带)读时,一次最多返回一个记录。</li>
<li>当一信号造成中断,而已经读了部分数据量时。</li>
</ul>
<h2 id="函数write"><a href="#函数write" class="headerlink" title="函数write"></a>函数write</h2><p>调用write函数想打开文件写数据<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); </div><div class="line"></div><div class="line"><span class="comment">//Returns: number of bytes written if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>其返回值通常与参数 nbytes的值相同,否则表示出错。 write出错的一个常见原因是磁盘已写满,或者超过了一个给定进程的文件长度限制</p>
<h2 id="I-O效率"><a href="#I-O效率" class="headerlink" title="I/O效率"></a>I/O效率</h2><p>BUFFSIZE 一般选取与磁盘块相同大小的字节数，大多数情况问4096</p>
<p>大多数文件系统为改善性能都采用某种预读( read ahead)技术。当检测到正进行顺序读取时,系统就试图读入比应用所要求的更多数据,并假想应用很快就会读这些数据。</p>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>UNIX系统支持在不同进程间共享打开文件。在介绍dup函数之前,先要说明这种共享。为此先介绍内核用于所有I/O的数据结构。</p>
<p>内核使用3种数据结构表示打开文件,它们之间的关系决定了在文件共享方面一个进程对另个进程可能产生的影响。</p>
<ol>
<li><strong>每个进程在进程表中都有一个记录项,记录项中包含一张打开文件描述符表</strong>,可将其视为一个矢量,每个描述符占用一项。与每个文件描述符相关联的是文件描述符标志和指向一个文件表项的指针。</li>
<li><strong>内核为所有打开文件维持一张文件表</strong>。每个文件表项包含文件状态标志(读、写、添写、同步和非阻塞等)、当前文件偏移量、指向该文件v节点表项的指针</li>
<li>每个打开文件(或设备)都有一个v节点( v-node)结构。v节点包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件,v节点还包含了该文件的i节点(i-node,索引节点)。</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-03-07-15203821021363.jpg" alt=""></p>
<blockquote>
<p>创建v节点结构的目的是对在一个计算机系统上的多文件系统类型提供支持。把与文件系统无关的i节点部分称为v节点。Linux没有将相关数据结构分为i节点和ⅴ节点,而是采用了一个与文件系统相关的i节点和个与文件系统无关的i节点。</p>
</blockquote>
<p>两个独立进程打开同一个文件</p>
<p><img src="https://data2.liuin.cn/2018-03-07-15203822136634.jpg" alt=""></p>
<p>文件描述符标志和文件状态标志在作用范围方面的区别,前者只用于一个进程的一个描述符,而后者则应用于指向该给定文件表项的任何进程中的所有描述符。</p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><ol>
<li>追加到一个文件</li>
</ol>
<p>多个进程同时使用这种方法将数据追加写到同一文件,则会产生问题</p>
<p>问题出在逻辑操作“先定位到文件尾端,然后写”,它使用了两个分开的函数调用。解决问题的方法是使这两个操作对于其他进程而言成为一个原子操作。</p>
<ol>
<li>函数pread和pwrite</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset); </div><div class="line"></div><div class="line"><span class="comment">//Returns: number of bytes read, 0 if end of ﬁle, −1 on error</span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> pwrite(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset); </div><div class="line"></div><div class="line"><span class="comment">//Returns: number of bytes written if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>调用 pread相当于调用1seek后调用read,但是 pread又与这种顺序调用有下列重要区别:1. 调用 pread时,无法中断其定位和读操作。2. 不更新当前文件偏移量。</p>
<p>调用pwrite相当于调用1seek后调用 write,但也与它们有类似的区别。</p>
<h2 id="函数dup和dup2"><a href="#函数dup和dup2" class="headerlink" title="函数dup和dup2"></a>函数dup和dup2</h2><p>下面两个用来复制一个文件描述符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//Both return: new ﬁle descriptor if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>由dup返回的新文件描述符一定是当前可用文件描述符中的最小数值。对于dup2,可以用fd2参数指定新描述符的值。如果fd2已经打开,则先将其关闭。如若fd等于fd2,则dup2返回fd2,而不关闭它。否则,fd2的 FD_CLOEXEO文件描述符标志就被清除,这样fd2在进程调用exec时是打开状态</p>
<p>dup(1)以后的内核数据结构：<br><img src="https://data2.liuin.cn/2018-03-07-15203828993104.jpg" alt=""></p>
<h2 id="函数sync、-fsync和-fdatasync"><a href="#函数sync、-fsync和-fdatasync" class="headerlink" title="函数sync、 fsync和 fdatasync"></a>函数sync、 fsync和 fdatasync</h2><p>传统的UNⅨ系统实现在内核中设有缓冲区高速缓存或页高速缓存,大多数磁盘I/O都通过缓冲区进行。当我们向文件写入数据时,内核通常先将数据复制到缓冲区中,然后排入队列,晚些时候再写入磁盘。这种方式被称为<strong>延迟写</strong>( delayed write)</p>
<p>通常,当内核需要重用缓冲区来存放其他磁盘块数据时,它会把所有延迟写数据块写入磁盘为了保证磁盘上实际文件系统与缓冲区中内容的一致性,UNIX系统提供了sync、 fsync和Edatasync三个函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//Returns: 0 if OK, −1 on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>sync只是将所有修改过的块缓冲区排入写队列,然后就返回,它并不等待实际写磁盘操作结束。</p>
<p>fsync函数只对由文件描述符/指定的一个文件起作用,并且等待写磁盘操作结束才返回fsync可用于数据库这样的应用程序,这种应用程序需要确保修改过的块立即写到磁盘上。</p>
<p>fdatasync函数类似于 sync,但它只影响文件的数据部分。而除数据外, fsync还会同步更新文件的属性。</p>
<h2 id="函数fcntl"><a href="#函数fcntl" class="headerlink" title="函数fcntl"></a>函数fcntl</h2><p>fcntl函数可以改变已经打开文件的属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* int arg */</span> )</span></span>; </div><div class="line"></div><div class="line"><span class="comment">//Returns: depends on cmd if OK (see following), −1 on error</span></div></pre></td></tr></table></figure>
<p>fcnt1函数有以下5种功能</p>
<ol>
<li>复制一个已有的描述符(cmd= F_DUPFD或 F_DUPFD_CLOEXEC)。</li>
<li>获取/设置文件描述符标志(cmd= E_GETED或 F_SETED)。</li>
<li>获取/设置文件状态标志(cmd= F_GETEL或 F_SETEL)</li>
<li>获取/设置异步IO所有权(cmd= F_GETOWN或F_SETOWN)。</li>
<li>获取/设置记录锁(cmd= F_GETLK、 F_SETLK或 F_SETLKW)</li>
</ol>
<p>在修改文件描述符标志或文件状态标志时必须谨慎,先要获得现在的标志值,然后按照期望修改它,最后设置新标志值。不能只是执行 F_SETED或 E_SETEL命令,这样会关闭以前设置的标志位。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">set_fl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span> <span class="comment">/* flags are file status flags to turn on */</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span>		val;</div><div class="line"></div><div class="line">	<span class="comment">// 获取现在的文件标志位</span></div><div class="line">	<span class="keyword">if</span> ((val = fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</div><div class="line">		err_sys(<span class="string">"fcntl F_GETFL error"</span>);</div><div class="line"></div><div class="line">	<span class="comment">// 计算新的标志值</span></div><div class="line">	val |= flags;		<span class="comment">/* turn on flags */</span></div><div class="line">         </div><div class="line">	<span class="comment">// 设置新的标志值</span></div><div class="line">	<span class="keyword">if</span> (fcntl(fd, F_SETFL, val) &lt; <span class="number">0</span>)</div><div class="line">		err_sys(<span class="string">"fcntl F_SETFL error"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="函数ioctl"><a href="#函数ioctl" class="headerlink" title="函数ioctl"></a>函数ioctl</h2><p>每个设备驱动程序可以定义它自己专用的一组ioct1命令,系统则为不同种类的设备提供通用的 ioctl命令。</p>
<h2 id="dev-fd"><a href="#dev-fd" class="headerlink" title="/dev/fd"></a>/dev/fd</h2><p>较新的系统都提供名为/aev/fd的目录,其目录项是名为0、1、2等的文件。打开文件/dev/fd/n等效于复制描述符n(假定描述符n是打开的)。</p>
<p>大多数系统忽略它所指定的mode,而另外一些系统则要求mode必须是所引用的文件(在这里是标准输入)初始打开时所使用的打开模式的一个子集。</p>
<p>某些系统提供路径名/dev/ stdin、/dev/stdoυt和/dev/ stderr,这些等效于dev/fd/0、/dev/fd/1和/dev/fd/2。</p>
<p>dev/fd文件主要由shell使用,它允许使用路径名作为调用参数的程序,能用处理其他路径名的相同方式处理标准输入和输出。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《C++ Primer》笔记 C++标准库部分]]></title>
      <url>/2018/03/04/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-C-%E6%A0%87%E5%87%86%E5%BA%93%E9%83%A8%E5%88%86/</url>
      <content type="html"><![CDATA[<p>《C++ Primer》笔记 C++基础部分</p>
<a id="more"></a>
<h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><p>大部分的I/O库设施：</p>
<ul>
<li>istream(输入流)类型,提供输入操作。</li>
<li>ostream(输出流)类型,提供输出操作。</li>
<li>cin，一个 istream对象,从标准输入读取数据。</li>
<li>cout,一个 ostream对象,向标准输出写入数据。</li>
<li>cerr,一个 ostream对象,通常用于输出程序错误消息,写入到标准错误・</li>
<li>>&gt;运算符,用来从一个istream对象读取输入数据。</li>
<li>&lt;&lt;运算符,用来向一个ostream对象写入输出数据。</li>
<li>getline函数,从一个给定的 istream读取一行数据,存入一个给定的 string对象中。</li>
</ul>
<h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><p>我们已经使用过的IO类型和对象都是操纵char数据的。默认情况下,这些对象都是关联到用户的控制台窗口的。</p>
<p>为了支持这些不同种类的IO处理操作,在 istream和ostream之外,标准库还定义了其他一些IO类型:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518671687211.jpg" alt="enter description here"></p>
<p>为了支持宽字符的语言，标准库定义了一组类型和对象来操纵wchat_t类型的数据。宽字符版本的类型和函数的名字以一个w开始。</p>
<blockquote>
<p>IO类型之间的关系</p>
</blockquote>
<p>标准库使我们能忽略这些不同类型的流之间的差异,这是通过<strong>继承机制</strong>( inheritance)实现的。利用模板,我们可以使用具有继承关系的类,而不必了解继承机制如何工作的细节。简单地说,继承机制使我们可以声明一个特定的类继承自另一个类。我们通常可以将一个派生类(继承类)对象当作其基类(所继承的类)对象来使用</p>
<h3 id="IO对象无拷贝或赋值"><a href="#IO对象无拷贝或赋值" class="headerlink" title="IO对象无拷贝或赋值"></a>IO对象无拷贝或赋值</h3><p>我们不能拷贝或者对IO对象赋值，由于不能拷贝IO对象，因此我们也不能将形参或者函数返回类型设置为流类型。进行IO操作的函数通常以引用的方式传递和返回流。</p>
<p>读取或者返回一个IO对象会改变其状态，因此传递和引用不能是const的</p>
<h3 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h3><blockquote>
<p>查询流状态</p>
</blockquote>
<p>IO库定义了一个与机器无关的 iostate类型,它提供了表达流状态的完整功能。这个类型应作为一个位集合来使用</p>
<blockquote>
<p>管理条件状态</p>
</blockquote>
<p>流对象的 rdstate 成员返回一个iostate值,对应流的当前状态。 setstate操作将给定条件位置位,表示发生了对应错误。clear成员是一个重載的成员:它有一个不接受参数的版本,而另一个版本接受一个 iostate类型型的参数。</p>
<h3 id="管理输出缓存"><a href="#管理输出缓存" class="headerlink" title="管理输出缓存"></a>管理输出缓存</h3><p>每一个输出流都管理一个缓冲区，用来保存程序读写的数据。</p>
<p>文本串可能立即打印出来,但也有可能被操作系统保存在缓冲区中,随后再打印。有了缓冲机制,操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很耗时,<strong>允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升</strong>。</p>
<p>导致缓冲刷新(即,数据真正写到输出设备或文件)的原因有很多：</p>
<ul>
<li>程序正常结束,作为main函数的 return操作的一部分,缓冲冲刷新被执行。</li>
<li>缓冲区满时,需要刷新缓冲,而后新的数据才能继续写入缓冲区。</li>
<li>我们可以使用操纵符如endl来显式刷新缓冲区。</li>
<li>在每个输出操作之后,我们可以用操纵符unitbuf设置流的内部状态,来清空缓冲区。</li>
<li>一个输出流可能被关联到另一个流。在这种情况下,当读写被关联的流时,关联到的流的缓冲区会被刷新。</li>
</ul>
<blockquote>
<p>刷新输出缓冲区</p>
</blockquote>
<p>我们已经使用过操纵符endl,它完成换行并刷新缓冲区的工作。IO库中还有两个类似的操纵符:flush和ends。flush刷新缓冲区,但不输出任何额外的字符;ends向缓冲区插入一个空字符,然后刷新缓冲区</p>
<blockquote>
<p>uintbuf操作符</p>
</blockquote>
<p>如果想在每次输出操作后都刷新缓冲区,我们可以使用 unitbuf操纵符。它告诉流在接下来的每次写操作之后都进行一次=flush操作。而 nounitbuf操纵符则重置流,使其恢复使用正常的系统管理的缓冲区刷新机制:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518672433805.jpg" alt="enter description here"></p>
<h2 id="文件的输入输出"><a href="#文件的输入输出" class="headerlink" title="文件的输入输出"></a>文件的输入输出</h2><p>头文件 fstream定义了三个类型来支持文件IO: ifstream从一个给定文件读取数据,ofstream向一个给定文件写入数据,以及 fstream可以读写给定文件。</p>
<p>除了继承自 iostream类型的行为之外, fstream中定义的类型还增加了一些新的成员来管理与流关联的文件</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518672783415.jpg" alt="enter description here"></p>
<h3 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h3><p>当我们想要读写一个文件时,可以定义一个文件流对象,并将对象与文件关联起来。每个文件流类都定义了一个名为open的成员函数,它完成一些系统相关的操作,来定位给定的文件,并视情况打开为读或写模式。</p>
<blockquote>
<p>成员函数open和close</p>
</blockquote>
<p>如果我们定义一个空文件流对象，随后我们可以调用open来将它与文件关联起来。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518672886373.jpg" alt="enter description here"></p>
<p>如果调用open失败, failbit会被置位。因为调用open可能失败,进行open是否成功的检测通常是一个好习惯</p>
<h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><p>每一个流都有一个关联的<strong>文件模式</strong>（file mode），用来指出如何使用文件。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518672976516.jpg" alt="enter description here"></p>
<p>无论用哪种方式打开文件,我们都可以指定文件模式,调用open打开文件时可以,用一个文件名初始化流来隐式打开文件时也可以。</p>
<blockquote>
<p>以out模式打开文件会丢弃</p>
</blockquote>
<p>已有数据默认情况下,当我们打开一个 ofstream时,文件的内容会被丢弃。阻止一个ofstream清空给定文件内容的方法是同时指定aap模式:</p>
<h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><p>sstream头文件定义了三个类型来支持内存IO,这些类型可以向 string写入数据,从string读取数据,就像string是一个IO流一样。</p>
<p>istringstream从 string读取数据，ostringstream向 string写入数据,而头文件 stringstream既可从 string读数据也可向 string写数据。与fstream类型类似,头文件 sstream中定义的类型都继承自我们已经使用过的 iostream头文件中定义的类型。除了继承得来的操作, sstream中定义的类型还增加了一些成员来管理与流相关联的string。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518676701978.jpg" alt="enter description here"></p>
<h3 id="使用istringstream"><a href="#使用istringstream" class="headerlink" title="使用istringstream"></a>使用istringstream</h3><p>当我们的某些工作室对整行的文本进行处理，而其他的一些工作是处理行内的单个单词时，通常可以使用istringstream</p>
<h3 id="使用ostringstream"><a href="#使用ostringstream" class="headerlink" title="使用ostringstream"></a>使用ostringstream</h3><p>当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>C++使用标准库类来处理面向流的输入和输出:</p>
<ol>
<li>iostream处理控制台</li>
<li>fstream处理命名文件</li>
<li>stringstream完成内存string的IO</li>
</ol>
<hr>
<h1 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h1><p>一个容器就是一些特定类型对象的集合。<strong>顺序容器</strong>( sequential container)为程序员提供了<strong>控制元素存储和访问顺序的能力</strong>。这种顺序<strong>不依赖于元素的值,而是与元素加入容器时的位置相对应</strong>。与之相对的,我们将在第11章介绍的有序和无序关联容器,则根据关键字的值来存储元素。</p>
<h2 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_16_1518790789624.jpg" alt="enter description here"></p>
<p>以上就是标准库中的顺序容器了，所有顺序容器提供快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：</p>
<ul>
<li>向容器添加或从容器中删除元素的代价</li>
<li>非顺序访问容器中元素的代价</li>
</ul>
<p>除了固定大小的的 array外,其他容器都提供高效、灵活的内存管理。</p>
<p>list和 forward_list 两个容器的设计目的是<strong>令容器任何位置的添加和删除操作都很快速</strong>。作为代价,这两个容器不支持元素的随机访问:为了访问一个元素,我们只能遍历整个容器。而且,与 vector、 deque和 array相比,这两个容器的额外内存开销也很大。</p>
<p>deque是一个更为复杂的数据结构。与string和 vector类似, deque支持快速的随机访问。与 string和 vector一样,在 deque的中间位置添加或删除元素的代价(可能)很高。但是,<strong>在 deque的两端添加或删除元素都是很快的</strong>,与list或forward_list添加删除元素的速度相当。</p>
<p>以下是选择容器的基本原则：</p>
<ul>
<li>除非你有很好的理由选择其他容器,否则应使用 vector。</li>
<li>如果你的程序有很多小的的元素,且空间的额外开销很重要,则不要使用list或forward_list。</li>
<li>如果程序要求随机访问元素,应使用 vector或 deque如果程序要求在容器的中间插入或删除元素,应使用list或forward_list。</li>
<li>如果程序需要在头尾位置插入或删除元素,但不会在中间位置进行插入或删除操作,则使用 deque</li>
<li>如果程序只有在读取输入时才需要在容器中间位置插入元素,随后需要随机访问元素,则：首先，确定是否真的需要在容器中间添加元素；如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的额内容拷贝到一个vector 中</li>
</ul>
<h2 id="容器库概览"><a href="#容器库概览" class="headerlink" title="容器库概览"></a>容器库概览</h2><p>容器类型上形成了一种层次：</p>
<ul>
<li>某些操作是所有容器类型都提供的</li>
<li>另外一些操作仅针对顺序容器、关联容器或无序容器</li>
<li>还有一些操作只适用于一小部分容器</li>
</ul>
<p>本节我们介绍所有容器都适用的操作</p>
<p>一般来说，每个容器都定义在一个头文件中，文件名与类型名相同；顺序容器几乎可以保存任意类型的元素。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_16_1518793115931.jpg" alt="enter description here"></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>与容器一样,迭代器有着公共的接口:如果一个迭代器提供某个操作,那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。</p>
<p>一个迭代器范围( iterator range)由一对迭代器表示,两个迭代器分别指向同一个容器中的元素或者是<strong>尾元素之后的位置</strong>( one past the last element)。这两个迭代器通常被称为 begin和end,或者者是 first和laste(可能有些误导),它们标记了容器中元素的个范围</p>
<p>这种元素范围被称为<strong>左闭合区间</strong>( left-inclusive interval),其标准数学描述为<code>[begin, end)</code></p>
<h3 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h3><p>反向迭代器就是一种反向遍历容器的迭代器,与正向迭代器相比,各种操作的含义也都发生了颠倒</p>
<p>,通过类型别名,我们可以在不了解容器中元素类型的情况下使用它。如果需要元素类型,可以使用容器的value_type。如果需要元素类型的一个引用,可以使用 reference或 const_reference。这些元素相关的类型别名在泛型编程中非常有用</p>
<h3 id="begin-和-end成员"><a href="#begin-和-end成员" class="headerlink" title="begin 和 end成员"></a>begin 和 end成员</h3><p>begin和end操作生成指向容器中第一个元素和尾元素之后位置的迭代器。这两个迭代器最常见的用途是形成一个包含容器中所有元素的迭代器范围</p>
<h3 id="容器定义和初始化"><a href="#容器定义和初始化" class="headerlink" title="容器定义和初始化"></a>容器定义和初始化</h3><p>每个容器类型都定义了一个默认构造函数。除 array之外,其他容器的默认构造函数都会创建一个指定类型的空容器,且都可以接受指定容器大小和元素初始值的参数。</p>
<blockquote>
<p>将一个容器初始化为另一个容器的拷贝</p>
</blockquote>
<p>将一个新容器创建为另一个容器的拷贝的方法有两种:可以直接拷贝整个容器,或者( array除外)拷贝由一个迭代器对指定的元素范围。为了创建一个容器为另一个容器的拷贝,两个容器的类型及其元素类型必须匹配。不过,当传递迭代器参数来拷贝一个范围时,就不要求容器类型是相同的了。而且,新容器和原容器中的元素类型也可以不同,只要能将要拷贝的元素转换</p>
<blockquote>
<p>与顺序容器大小相关的构造函数</p>
</blockquote>
<p>除了与关联容器相同的构造函数外,顺序容器( array除外)还提供另一个构造函数,它接受一个容器大小和一个(可选的)元素初始值。</p>
<h3 id="赋值与swap"><a href="#赋值与swap" class="headerlink" title="赋值与swap"></a>赋值与swap</h3><p>赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝。</p>
<blockquote>
<p>使用assign</p>
</blockquote>
<p>顺序容器( array除外)还定义了一个名为 assign的成员,允许我们从一个不同但相容的类型赋值,或者从容器的一个子序列赋值。assign操作用参数所指定的元素(的拷贝)替换左边容器中的所有元素。例如,我们可以用 assign实现将一个 vector中的一段char*值赋予一个list中的 string：<br><img src="https://data2.liuin.cn/story-writer/2018_2_16_1518794438240.jpg" alt="enter description here"></p>
<blockquote>
<p>使用swap</p>
</blockquote>
<p>除 array外,交换两个容器内容的操作保证会很快——元素本身并未交换,swap只是交換了两个容器的内部数据结构。</p>
<p>元素不会被移动的事实意味着,除string外,指向容器的迭代器、引用和指针在swap操作之后都不会失效。它们仍指向swap操作之前所指向的那些元素。但是,在swap之后,这些元素已经属于不同的容器了。</p>
<p>与其他容器不同,swap两个 array会真正交换它们的元素。因此,交換两个 array所需的时间与 array中元素的数目成正比。</p>
<h3 id="容器大小操作"><a href="#容器大小操作" class="headerlink" title="容器大小操作"></a>容器大小操作</h3><p>除了一个例外,每个容器类型都有三个与大小相关的操作：</p>
<ul>
<li>成员函数size，返回容器中元素的数目; </li>
<li>empty当size为0时返回布尔值true,否则返回回false</li>
<li>max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。</li>
</ul>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符左右两边的运算对象必须是相同类型的容器,且必须保存相同类型的元素。</p>
<p>比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与string的关系运算类似:</p>
<ul>
<li>如果两个容器具有相同大小且所有元素都两两对应相等,则这两个容器相等;否则两个容器不等</li>
<li>如果两个容器大小不同,但较小容器中每个元素都等于较大容器中的对应元素,则则较小容器小于较大容器。</li>
<li>如果两个容器都不是另一个容器的前缀子序列,则它们的比较结果取決于第一个不相等的元素的比较结果。</li>
</ul>
<h2 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h2><h3 id="向顺序容器添加元素"><a href="#向顺序容器添加元素" class="headerlink" title="向顺序容器添加元素"></a>向顺序容器添加元素</h3><p>除 array外,所有标准库容器都提供灵活的内存管理。在运行时可以动态添加或刑除元素来改变容器大小。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518833554118.jpg" alt="enter description here"></p>
<p>在一个 vector或 string的尾部之外的任何位置,或是一个 deque的首尾之外的任何位置添加元素,都需要移动元素。而且,向一个 vector或 string添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存,并将元素从旧的空间移动到新的空间中。</p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>包括 array在内的每个顺序容器都有一个 front成员函数,而除 forward_list之外的所有顺序容器都有一个back成员函数。这两个操作分别返回首元素和尾元素的引用</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518833711199.jpg" alt="enter description here"></p>
<blockquote>
<p>下标操作和安全的随机访问</p>
</blockquote>
<p>提供快速随机访问的容器( string、 vector、 deque和 array)也都提供下标运算符。就像我们已经看到的那样,下标运算符接受一个下标参数,返回容器中该位置的元素的引用。<strong>给定下标必须“在范围内”</strong>(即,大于等于0,且小于容器的大小)。保证下标有效是程序员的责任,下标运算符并不检査下标是否在合法范围内。<strong>使用越界的下标是一种严重的程序设计错误</strong>,而且编译器并不检査这种错误。</p>
<p>如果我们希望确保下标是合法的,可以使用at成员函数。at成员函数类似下标运算,但如果下标越界,at会地出一个out of range异常:</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518834076074.jpg" alt="enter description here"></p>
<h3 id="特殊的forward-list操作"><a href="#特殊的forward-list操作" class="headerlink" title="特殊的forward_list操作"></a>特殊的forward_list操作</h3><p>在一个单向链表中,没有简单的方法来获取一个元素的前驱。出于这个原因,在一个 forward_list中添加或删除元素的操作是通过改变给定元素之后的元素来完成的</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518834143966.jpg" alt="enter description here"></p>
<h3 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h3><p>我们可以用rsize来增大或缩小容器・与往常一样, array不支持 resize。如果当前大小大于所要求的大小,容器后部的元素会被別除:如果当前大小小于新大小,会将新元素添加到容器后部:</p>
<h3 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h3><p>向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误,很可能引起与使用未初始化指针一样的问题</p>
<p>当你使用迭代器(或指向容器元素的引用或指针)时,最小化要求迭代器必须保持有效的程序片段是一个好的方法。</p>
<p>程序必须保证每个循环中都更新迭代器、引用或指针</p>
<blockquote>
<p>不要保存end返回的迭代器</p>
</blockquote>
<p>当我们添加删除 vector或 string的元素后,或在 deque中首元素之外任何位置添加删除元素后,原来end返回的迭代器总是会失效。因此,<strong>添加或删除元素的循环程序必须反复调用end,而不能在循环之前保存end返回的迭代器</strong>,一直当作容器末尾使用。通常C++标准库的实现中end()操作都很快,部分就是因为这个原因。</p>
<h2 id="vector对象是如何增长的"><a href="#vector对象是如何增长的" class="headerlink" title="vector对象是如何增长的"></a>vector对象是如何增长的</h2><p>为了支持快速随机访问，vector将元素连续存储——每个元素紧挨着前一个元素存储。</p>
<p>假定容器中元素是连续存储的,且容器的大小是可变的,考虑向 vector或string中添加元素会发生什么:如果没有空间容纳新元素,容器不可能简单地将它添加到内存中其他位置一一因为元素必须连续存储。容器必须分配新的内存空间来保存已有元素和新元素,将已有元素从旧位置移动到新空间中,然后添加新元素,释放旧存储空间。如如果我们每添加一个新元素, vector就执行一次这样的内存分配和释放操作,性能会慢到不可</p>
<p>为了避免这种代价,标准库实现者采用了可以减少容器空间重新分配次数的策略。当不得不获取新的内存空间时, vector和 string的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用,可用来保存更多的新元素。</p>
<p>vector 在每次重新分配内存的时候都要移动所有元素</p>
<blockquote>
<p>管理容量的成员函数</p>
</blockquote>
<p> capacity操作告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素。 reserve操作允许我们通知容器它应该准备保存多少个元素。</p>
<blockquote>
<p>capacity和size</p>
</blockquote>
<p>理解 capacity和size的区别非常重要。容器的size是指它已经保存的元素的数目;而 capacity则是在不分配新的内存空间的前提下它最多可以保存多少元素。</p>
<h2 id="额外的string操作"><a href="#额外的string操作" class="headerlink" title="额外的string操作"></a>额外的string操作</h2><h3 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861676844.jpg" alt="enter description here"></p>
<blockquote>
<p>substr操作</p>
</blockquote>
<p>substr操作返回一个str1ng,它是原始 string的一部分或全部的拷贝。可以传递给 substr一个可选的开始位置和计数值:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861736953.jpg" alt="enter description here"></p>
<h3 id="改变string的其他方法"><a href="#改变string的其他方法" class="headerlink" title="改变string的其他方法"></a>改变string的其他方法</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861803653.jpg" alt="enter description here"></p>
<h3 id="string搜索操作"><a href="#string搜索操作" class="headerlink" title="string搜索操作"></a>string搜索操作</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861836971.jpg" alt="enter description here"></p>
<h3 id="compare函数"><a href="#compare函数" class="headerlink" title="compare函数"></a>compare函数</h3><p>除了关系运算符外,标准准库str1ng类型还提供了一组compare函数,这些函数与C标准库的 strcmp函数很相似。类似 strcmp,据据s是等于、大于还是小于参数指定的字符串,s. compare返回回0、正数或负数。</p>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861942715.jpg" alt="enter description here"></p>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>除了顺序容器外,标准库还定义了三个顺序容器适配器: stack、 queue和priority_queue。<strong>适配器</strong>( adaptor)是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上,<strong>一个适配器是一种机制,能使某种事物的行为看起来像另外一种事物一样</strong>。一个容器适配器接受一种已有的容器类型,使其行为看起来像一种不同的类型。</p>
<blockquote>
<p>定义一个适配器</p>
</blockquote>
<p>每个适配器都定义两个构造函数:默认构造函数创建一个空对象,接受一个容器的构造函数拷贝该容器来初始化适配器。</p>
<p>默认情况下, stack和 queue是基于 deque实现的,priority_queue是在 vector之上实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第三个类型参数,来重载默认容器类型。</p>
<p>对于一个给定的适配器,可以使用哪些容器是有限制的。所有适配器都要求容器具有添加和删除元素的能力。因此,适配器不能构造在aray之上。类似的,我们也不能用forward_list来构造适配器,因为所有适配器都要求容器具有添加、删除以及访间尾元素的能力。 stack只要求 push_back、 pop_back和back操作,因此可以使用除 array</p>
<blockquote>
<p>栈适配器<br><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518862439794.jpg" alt="enter description here"></p>
</blockquote>
<p>每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作。我们只可以使用适配器操作,而不能使用底层容器类型的操作。</p>
<blockquote>
<p>队列适配器</p>
</blockquote>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518862492187.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518862504010.jpg" alt="enter description here"></p>
<p>标准库queue使用一种先进先出（first-in，first-out，FIFO）的存储和访问策略</p>
<p>priority_queue 允许我们为队列中的元素建立优先级，新加入的元素会排在所有优先级比它低的已有元素之前。</p>
<hr>
<h1 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h1><p>标准库容器定义的操作集合惊人得小。标准库并未给每个容器添加大量功能,而是提供了一组算法,这些算法中的大多数都独立于任何特定的容器。这些算法是通用的( generic,或称泛型的):它们可用于不同类型的容器和不同类型的元素。</p>
<p>顺序容器只定义了很少的一些操作，我们可以想象用户可能还希望做其他很多有用的操作:查找特定元素、替換或別除二个特定值、重排元素顺序等。</p>
<p>标准库并未给每个容器都定义成员函数来实现这些操作,而是定义了一组<strong>泛型算法</strong>( generic algorithm):称它们为“算法”,是因为它们实现了一些经典算法的公共接接口,如排序和搜索;称它们是“泛型的”,是因为它们可以用于不同类型的元素和多种容器类型</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一般情况下,泛型算法并不直接操作容器,而是遍历由两个迭代器指定的一个元素范围来进行操作。</p>
<p><strong>迭代器令算法不依赖于容器，但是算法依赖于容器的操作类型</strong>。虽然迭代器的使用令算法不依赖于容器类型,但大多数算法都使用了一个(或多个)元素类型上的操作。</p>
<p>泛型算法本身不会执行容器的操作，它们只会运行于迭代器上，执行迭代器的操作。</p>
<h2 id="初始泛型算法"><a href="#初始泛型算法" class="headerlink" title="初始泛型算法"></a>初始泛型算法</h2><h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p>一些算法只会读取其输入范围内的元素,而从不改变元素。find就是这样一种算法</p>
<p>另一个只读算法是 accumulate,它定义在头文件 numeric i中。 accumulate函数接受三个参数,前两个指出了需要求和的元素的范围,第三个参数是和的初值。accumulate将第三个参数作为求和起点,这蕴含着一个编程假定:将元素类型加到和的类型上的操作必须是可行的。即,序列中元素的类型必须与第三个参数匹配,或者能够转换为第三个参数的类型。</p>
<p>另一个只读算法是equal，用于确定两个序列是否保存相同的值。</p>
<h3 id="写容器元素的算法"><a href="#写容器元素的算法" class="headerlink" title="写容器元素的算法"></a>写容器元素的算法</h3><p>一些算法将新值赋予序列中的元素。当我们使用这类算法时,必须注意<strong>确保序列原大小至少不小于我们要求算法写入的元素数目</strong>。记住,<strong>算法不会执行容器操作,因此它们身不可能改变容器的大小</strong>。</p>
<p>一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素,该序列从目的位置迭代器指向的元素开始。</p>
<blockquote>
<p>介绍back_inserter</p>
</blockquote>
<p>一种保证算法有足够元素空间来容纳输出数据的方法是使用<strong>插入迭代器</strong>( InsertIterator)。插入送代器是一种向容器中添加元素的迭代器。通常情况,当我们通过一个送代器向容器元素赋值时,值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时,一个与赋值号右側值相等的元素被添加到容器中。</p>
<p>back_inserter接受一个指向容器的引用,返回一个与该容器绑定的插入迭代器当我们通过此迭代器赋值时,赋值运算符会调用 push_back将一个具有给定值的元素添加到容器中</p>
<blockquote>
<p>拷贝算法</p>
</blockquote>
<p>拷贝(copy)算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器,前两个表示一个输入范围,第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。</p>
<h3 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h3><p>某些算法会重排容器中元素的顺序,一个明显的例子是sort。调用sort会重排输入序列中的元素,使之有序,它是利用元素类型的运算符来实现排序的</p>
<blockquote>
<p>清除重复单词</p>
</blockquote>
<p>我们就可以使用另一个称为unique的标准库算法来重排ⅴector,使得不重复的元素出现在ⅴector的开始部分。由于算法不能执行容器的操作,我们将使用 vector的 erase成员来完成真正的删除操作</p>
<h2 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h2><p>很多算法都会比较输入序列中的元素。默认情况下,这类算法使用元素类型的&lt;或=运算符完成比较。标准库还为这些算法定义了额外的版本,允许<strong>我们提供自己定义的操作来代替默认运算符</strong>。</p>
<h3 id="向算法传递参数"><a href="#向算法传递参数" class="headerlink" title="向算法传递参数"></a>向算法传递参数</h3><blockquote>
<p>谓词</p>
</blockquote>
<p>谓词是一个可调用的表达式,其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类:一元谓词( unary predicate,意味着它们只接受单一参数)和二元谓词binary predicate,,意味着它们有两个参数)。接受谓词参数的算法对输入序列中的元素调用谓词。因此,元素类型必须能转换为谓词的参数类型。接受一个二元谓词参数的sOrt版本用这个谓词代替&lt;来比较元素。</p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>根据算法接受一元谓词还是二元谓词,我们传递给算法的谓词必须严格接受一个或两个参数。但是,有时我们希望进行的操作需要更多参数,超出了算法对谓词的限制。</p>
<blockquote>
<p>介绍lambda</p>
</blockquote>
<p>我们可以向一个算法传递任何类别的<strong>可调用对象</strong>( callable object)。对于一个对象或一个表达式,如果可以对其使用调用运算符,则称它为可调用的。即,如果e是一个可调用的表达式,则我们可以编写代码e(args),其中args是个逗号分隔的一个或多个参数的列表</p>
<p>到目前为止,<strong>我们使用过的仅有的两种可调用对象是函数和函数指针</strong>。还有其他两种可调用对象:重载了函数调用运算符的类,,以及 lambda表达式( lambda expression)</p>
<p>一个 lambda表达达式表示一个可调用的代码单元。我们们可以将其理解为一个未命名的内联函数。与任何函数类似似,一个 lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同, lambda可能定义在函数内部。一个 lambda表达式具有如下形式：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_18_1518953656030.jpg" alt="enter description here"></p>
<blockquote>
<p>向lambda传递参数</p>
</blockquote>
<p>与一个普通函数调用类似,调用一个 lambda时给定的实参被用来初始化 lambda的形参。通常,实参和形参的类型必须匹配。但与普通函数不同, <strong>lambda不能有默认参数</strong>。因此,一个 lambda调用的实参数目永远与形参数目相等。</p>
<blockquote>
<p>使用捕获列表</p>
</blockquote>
<p>虽然一个 lambda可以出现在一个函数中,使用其局部变量,但它只能使用那些明确指明的变量。<strong>一个 lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量</strong>。捕获列表指引 lambda在其内部包含访问局部变量所需的信息。</p>
<h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>当定义一个 lambda时,编译器生成一个与 lambda对应的新的(未命名的)类类型。目前,可以这样理解,当向个函数传递一个 lambda时,同时定义了一个新类型和该类型的一个对象:传递的参数就是此编译器生成的类类型的未命名对象。类似的,当使用auto定义一个用 lambda初始化的变量时,定义了一个从 lambda生成的类型的对象。</p>
<p>默认情況下,从 lambda生成的类都包含一个对应该 lambda 所捕获的変量的数据成员。类似任何普通类的数据成员, lambda的数据成员也在 lambda对象创建时被初始化。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_18_1518954256455.jpg" alt="enter description here"></p>
<blockquote>
<p>值捕获</p>
</blockquote>
<p>类似参数传递，变量的捕获方式也可以是值或引用。与传值参数类似,采用值捕获的前提是变量可以拷贝。与参数不同,被捕获的变量的值是在 lambda创建时拷贝,而不是调用时拷贝</p>
<blockquote>
<p>引用捕获</p>
</blockquote>
<p>一个以引用方式捕获的变量与其他任何类型的引用的行为类似。当我们在 lambda 函数体内使用此变量时,实际上使用用的是引用所绑定的对象。</p>
<blockquote>
<p>隐式捕获</p>
</blockquote>
<p>除了显式列出我们希望使用的来自所在函数的变量之外,还可以让编译器根据 lambda体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表,应在捕获列表中写一个&amp;或=。&amp;告诉编译器采用捕获引用方式,=则表示采用值捕获方式。</p>
<p>当我们混合使用隐式捕获和显式捕获时,捕获列表中的第一个元素必须是一个&amp;或=。此符号指定了默认捕获方式为引用或值。</p>
<p>当混合使用隐式捕获和显式捕获时,显式捕获的变量必须使用与隐式捕获不同的方式。即,如果隐式捕获是引用方式(使用了&amp;),则则显式捕获命名变量必须采用值方式,因此不能在其名字前使用&amp;。类似的,如如果隐式捕获采用的是值方式(使用了=),则显式捕获命名变量必须采用引用方式,即,在名字前使用&amp;。</p>
<blockquote>
<p>可变lambda</p>
</blockquote>
<p>默认情况下,对于一个值被拷贝的变量, lambda不会改变其值。如果我们希望能改变个被捕获的变量的值,就必须在参数列表首加上关键键字 mutale。</p>
<blockquote>
<p>指定的lambda返回类型</p>
</blockquote>
<p>默认情况下,如果一个 lambda体包含 return之外的任何语句,则编译器假定此 lambda返回void。与其他返回void的函数类似,被推断返回void的 lambda不能返回值。</p>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>对于那种只在一两个地方使用的简单操作, lambda表达式是最有用的。如果我们需要在很多地方使用相同的操作,通常应该定义一个函数,而不是多次编写相同的 lambda表达式。类似的,如果一个操作需要很多语句才能完成,通通常使用函数更好。</p>
<p>如果lambda的捕获列表为空，通常可以用函数来替代它。</p>
<p>但是,对于捕获局部变量的 lambda,用函数来替换它就不是那么容易了。</p>
<blockquote>
<p>标准bind函数</p>
</blockquote>
<p>我们可以解决向 check_size传递递一个长度参数的问题,方法是使用一个新的名为bind的标准库函数,它定义在头文件 functiona1中。可以将bind函数看作一个通用的函数适配记器,它接受一个可调用对象,生成一个新的可调用对象来“适应”原对象的参数列表</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_18_1518954580235.jpg" alt="enter description here"></p>
<h2 id="再探迭代器"><a href="#再探迭代器" class="headerlink" title="再探迭代器"></a>再探迭代器</h2><p>除了为每个容器定义的迭代器之外,标准库还定义了额外几种迭代器。这些迭代器包括以下几种</p>
<ul>
<li>插入迭代器( Insert iterator):这些迭代器被绑定到一个容器上,可用来向容器插入元素</li>
<li>流迭代器( stream Iterator):这些迭代器被绑定到输入或输出流上,可用来遍历所关联的IO流。</li>
<li>反向迭代器( reverse Iterator):这些迭代器向后而不是向前移动。除了forward1ist之外的标准库容器都有反向迭代器。</li>
<li>移动迭代器( move iterator):这些专用的迭代器不是拷贝其中的元素,而是移动它们。我们将在13.6.2节(第480页)介绍移动迭代器</li>
</ul>
<h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><p>插入器是一种迭代器适配器,它接受一个容器,生成一个迭代器,能实现向给定容器添加元素。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519893284405.jpg" alt="enter description here"></p>
<p>插入器有三种类型，其差异在于元素插入的位置：</p>
<ul>
<li>back_inserter创建一个使用 push_back的迭代器</li>
<li>front_inserter创建一个使用 push_front的迭代器</li>
<li>inserter创建一个使用 insert的迭代器。此函数接受第二个参数,这个参数必须是一个指向给定容器的迭代器。<strong>元素将被插入到给定迭代器所表示的元素之前</strong>。</li>
</ul>
<h3 id="iostream-迭代器"><a href="#iostream-迭代器" class="headerlink" title="iostream 迭代器"></a>iostream 迭代器</h3><p>虽然 iostream类型不是容器,但标准库定义了可以用于这些IO类型对象的迭代器。istream iterator读取输入流,ostream iterator向一个输出流写数据。<strong>这些迭代器将它们对应的流当作一个特定类型的元素序列来处理</strong>。通过使用流迭代器,我们可以用泛型算法从流对象读取数据以及向其写入数据。</p>
<blockquote>
<p>istream_iterator 允许使用懒惰求值</p>
</blockquote>
<p>当我们将一个 istream_iterator绑定到一个流时,标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据,直到我们使用迭代器时才真正读取。标准库中的实现所保证的是,<strong>在我们第一次解引用迭代器之前,从流中读取数据的操作已经完成了</strong>。对于大多数程序来说,立即读取还是推迟读取没什么差别。</p>
<h3 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h3><p>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器,递增(以及递减)操作的含义会颠倒过来。递增一个反向迭代器(++it)会移动到前一个元素;递减一个迭代器(–it)会移动到下一个元素。</p>
<p>除了 forwardlist之外,其他容器都支持反向迭代器。</p>
<h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><p>任何算法的最基本的特性是它要求其迭代器提供哪些操作。算法所要求的迭代器操作可以分为5个迭代器类别( Iterator category)。每个算法都会对它的每个迭代器参数指明须提供哪类迭代器。</p>
<p>算法还共享了一组参数传递规范和一组命名规范</p>
<h3 id="5类迭代器"><a href="#5类迭代器" class="headerlink" title="5类迭代器"></a>5类迭代器</h3><p>类似容器,迭代器也定义了一组公共操作。一些操作所有迭代器都支持,另外一些只有特定类别的迭代器才支持。例如, ostream_iterator只支持递增、解引用和赋值。vector、 string和 deque的迭代器除了这些操作外,还支持递减、关系和算术运算。</p>
<p>C++标准指明了泛型和数值算法的每个迭代器参数的最小类别。例如,find算法在一个序列上进行一遍扫描,对元素进行只读操作,因此至少需要输入迭代器。 </p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519894770101.jpg" alt="enter description here"></p>
<h3 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h3><p>在任何其他算法分类之上,还有一组参数规范。理解这些参数规范对学习新算法很有帮助—通过理解参数的含义,你可以将注意力集中在算法所做的操作上。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519894916626.jpg" alt="enter description here"></p>
<h3 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h3><p>除了参数规范,算法还遵循一套命名和重载规范。这些规范处理诸如:如何提供一个操作代替默认的&lt;或==运算符以及算法是将输出数据写入输入序列还是一个分离的目的位置等问题。</p>
<h2 id="特定容器算法"><a href="#特定容器算法" class="headerlink" title="特定容器算法"></a>特定容器算法</h2><p>与其他容器不同,链表类型list和forward_list定义了几个成员函数形式的算法。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519895023511.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519895035177.jpg" alt="enter description here"></p>
<hr>
<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>关联容器和顺序容器有着根本的不同:关联容器中的元素是按关键字来保存和访问的。与之相对,顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p>
<p>关联容器支持高效的关键字查找和访问。两个主要的<strong>关联容器</strong>( associative container)类型是map和set。map中的元素是一些关键字-值( key-value)对:关键字起到索引的作用,值则表示与索引相关联的数据。set中每个元素只包含一个关键字;set支持高效的关键字查询操作——检查一个给定关键字是否在set中。</p>
<p>标准库提供8个关联容器,。这8个容器间的不同体现在三个维度上:每个容器<br>(1)<strong>或者是一个set,或者是一个map</strong>;<br>(2)<strong>或者要求不重复的关键字,或者允许重复关键字</strong>;<br>(3)<strong>按顺序保存元素,或无序保存</strong></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519989186109.jpg" alt="enter description here"></p>
<h2 id="使用关联容器"><a href="#使用关联容器" class="headerlink" title="使用关联容器"></a>使用关联容器</h2><p>map是关键字值对的集合。例如,可以将一个人的名字作为关键字,将其电话号码作为值。我们称这样的数据结构为“将名字映射到电话号码”。map类型通常被称为关联数组( associative array)。关联数组与“正常”数组类似,不同之处在于其下标不必是整数。</p>
<p>与之相对,set就是关键字的简单集合。当只是想知道一个值是否存在时,set是最有用的。</p>
<h2 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h2><p>关联容器不支持顺序容器的位置相关的操作,例如 push_front或 push_back。原因是<strong>关联容器中元素是根据关键字存储的,这些操作对关联容器没有意义</strong>。而且,关联容器也<strong>不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作</strong>。</p>
<h3 id="定义关联容器"><a href="#定义关联容器" class="headerlink" title="定义关联容器"></a>定义关联容器</h3><p>当定义一个map时,必须既指明关键字类型又指明值类型;而定义一个set时,只需指明关键字类型,因为set中没有值。</p>
<p>map的初始化：<br><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519990637584.jpg" alt="enter description here"></p>
<h3 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h3><p>对于有序容器—map、 multimap、set以及 multiset,<strong>关键字类型必须定义元素比较的方法</strong>。默认情况下,标准库使用关键字类型的&lt;运算符来比较两个关键字。</p>
<blockquote>
<p>有序容器的关键字类型</p>
</blockquote>
<p>可以向一个算法提供我们自己定义的比较操作,与之类似也可以提供自己定义的操作来代替关键字上的&lt;运算符。所提供的操作必须在关键字类型上定义一个<strong>严格弱序</strong>( strict weak ordering)。</p>
<blockquote>
<p>使用关键字类型的比较函数</p>
</blockquote>
<p>用来组织一个容器中元素的操作的类型也是该容器类型的一部分。<strong>为了指定使用自定义的操作,必须在定义关联容器类型时提供此操作的类型</strong>。如前所述,用尖括号指出要定义哪种类型的容器,自定义的操作类型必须在尖括号中紧跟着元素类型给出</p>
<p>此处,我们使用 decltype来指出自定义操作的类型。记住,当用 decltype来获得一个函数指针类型时,必须加上一个*来指出我们要使用一个给定函数类型的指针</p>
<h3 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h3><p>在介绍关联容器操作之前,我们需要了解名为pair的标准库类型,它定义在头文件utility中。</p>
<p>一个pair保存两个数据成员。类似容器,pair是一个用来生成特定类型的模板当创建一个pair时,我们必须提供两个类型名,pa1r的数据成员将具有对应的类型。两个类型不要求一样:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519991091913.jpg" alt="enter description here"></p>
<p>与其他标准库类型不同,pair的数据成员是public的。两个成员分别命名为 first和 second。我们用普通的成员访问符号来访问它们</p>
<h2 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a>关联容器操作</h2><p>关联容器还定义了一些表示容器关键字和值的类型</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992027517.jpg" alt="enter description here"></p>
<h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><p>当解引用一个关联容器迭代器时,我们会得到一个类型为容器的value_type的值的引用。对map而言,value_type是一个pair类型,其 first成员保存 const的关键字, second成员保存值</p>
<blockquote>
<p>set 的迭代器是const的</p>
</blockquote>
<p>虽然set类型同时定义了 iterator和 const_iterator类型,但两种类型都只允许只读访问set中的元素。与不能改变一个map元素的关键字一样,一个set中的关键字也是 const的。可以用一个set迭代器来读取元素的值,但不能修改:</p>
<blockquote>
<p>遍历关联容器</p>
</blockquote>
<p>map和set类型都支持 begin和end操作。与往常一样我们可以用这些函数获取迭代器,然后用迭代器来遍历容器。</p>
<blockquote>
<p>关联容器和算法</p>
</blockquote>
<p>我们通常不对关联容器使用泛型算法。关键字是 const这一特性意味着<strong>不能将关联容器传递给修改或重排容器元素的算法</strong>,因为这类算法需要向元素写入值,而set类型中的元素是cnst的,map中的元素是pair,其第一个成员是 const的。</p>
<p>关联容器可用于只读取元素的算法。</p>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>关联容器的 insert成员向容器中添加一个元素或一个元素范围。由于map和set(以及对应的无序类型)包含不重复的关键字,因此插入一个已存在的元素对容器没有任何影响</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992536522.jpg" alt="enter description here"></p>
<blockquote>
<p>向map添加元素</p>
</blockquote>
<p>对一个map进行 insert操作时,必须记住元素类型是pair。通常,对于想要插入的数据,并没有一个现成的pair对象。可以在 insert的参数列表中创建一个pair</p>
<blockquote>
<p>检测insert的返回值</p>
</blockquote>
<p>insert(或emplace)返回的值依赖于容器类型和参数。对于不包含重复关键字的容器,添加单一元素的 insert和 emplace版本返回一个pair,告诉我们插入操作是否成功。pair的 first成员是一个迭代器,指向具有给定关键字的元素; second成员是一个bool值,指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中</p>
<h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992521248.jpg" alt="enter description here"></p>
<h3 id="map的下标操作"><a href="#map的下标操作" class="headerlink" title="map的下标操作"></a>map的下标操作</h3><p>map和 unordered_map容器提供了下标运算符和一个对应的at函数。set类型不支持下标,因为set中没有与关键字相关联的“值”。元素本身就是关键字,因此“获取与一个关键字相关联的值”的操作就没有意义了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992604789.jpg" alt="enter description here"></p>
<h3 id="访问元素-1"><a href="#访问元素-1" class="headerlink" title="访问元素"></a>访问元素</h3><p>关联容器提供多种查找一个指定元素的方法</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992681370.jpg" alt="enter description here"></p>
<blockquote>
<p>对map使用find代替下标操作</p>
</blockquote>
<p>对map和 unordered map类型,下标运算符提供了最简单的提取元素的方法。但是如我们所见,使用下标操作有一个严重的副作用:如果关键字还未在map中,下标操作会插入一个具有给定关键字的元素。这种行为是否正确完全依赖于我们的预期是什么。</p>
<h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p>新标准定义了4个<strong>无序关联容器</strong>( unordered associative container)。这些容器不是使用比较运算符来组织元素,而是使用一个哈希函数( hash function)和关键字类型==运算符。在关键字类型的元素没有明显的序关系的情况下,无序容器是非常有用的。</p>
<blockquote>
<p>使用无序容器</p>
</blockquote>
<p>除了哈希管理操作之外,无序容器还提供了与有序容器相同的操作(find、 insert）</p>
<blockquote>
<p>管理桶</p>
</blockquote>
<p>无序容器在存储上组织为一组桶,每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素,容器首先计算元素的哈希值,它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字,所有具有相同关键字的元素也都会在同一个桶中。因此,无序容器的性能依赖于哈希函数的质量和桶的数量和大小。</p>
<hr>
<h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><p>动态对象的正确释放被证明是编程中极其容易出错的地方。为了更安全地使用动态对象,标准库定义了两个智能指针类型来管理动态分配的对象。<strong>当一个对象应该被释放时,指向它的智能指针可以确保自动地释放它</strong>。</p>
<p>除了静态内存和栈内存,每个程序还拥有一个内存池。这部分内存被称作<strong>自由空间</strong>( free store)或<strong>堆</strong>(heap)。程序用堆来存储动态分配( dynamically allocate)的对象——即那些在程序运行时分配的对象。</p>
<h2 id="动态内存和智能指针"><a href="#动态内存和智能指针" class="headerlink" title="动态内存和智能指针"></a>动态内存和智能指针</h2><p>在C++中,动态内存的管理是通过一对运算符来完成的: <code>new</code>,在动态内存中为对象分配空间并返回一个指向该对象的指针,我们可以选择对对象进行初始化; <code>delete</code>,接受一个动态对象的指针,销毁该对象,并释放与之关联的内存</p>
<p>为了更容易(同时也更安全)地使用动态内存,新的标准库提供了两种智能指针( smart pointer.)类型来管理动态对象。智能指针的行为类似常规指针,重要的区别是它<strong>负责自动释放所指向的对象</strong>。新标准库提供的这两种智能指针的区别在于管理底层指针的方式<code>shared_ptr</code>允许多个指针指向同一个对于象; <code>unique_ptr</code>则“独占”所指向的对象。标准库还定义了一个名为 <code>weak_ptr</code>的伴随类,它是一种弱引用,指向 <code>shared_ptr</code>所管理的对象。这三种类型都定义在 memory头文件中。</p>
<h3 id="share-ptr类"><a href="#share-ptr类" class="headerlink" title="share_ptr类"></a>share_ptr类</h3><p>类似 vector,智能指针也是模板。因此,当我们创建一个智能指针时,必须提供额外的信息—指针可以指向的类型。智能指针的使用方式与普通指针类似。解引用一个智能指针返回它指向的对象。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520129716802.jpg" alt="enter description here"></p>
<blockquote>
<p>make_shared 函数</p>
</blockquote>
<p>最安全的分配和使用动态内存的方法是调用一个名为 make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它,返回指向此对象的 shared_ptr。</p>
<p>当要用 make_shared时,必须指定想要创建的对象的类型。定义方式与模板类相同在函数名之后跟一个尖括号,在其中给出类型</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520129795731.jpg" alt="enter description here"></p>
<blockquote>
<p>shared_ptr 的拷贝和赋值</p>
</blockquote>
<p>我们可以认为每个 shared_ptr都有一个关联的计数器,通常称其为<strong>引用计数</strong>( reference count)。无论何时我们拷贝一个 shared_ptr,计数器都会递增。一旦一个 shared_ptr的计数器变为0,它就会自动释放自己所管理的对象</p>
<blockquote>
<p>shared_ptr 自动销毁所管理的对象</p>
</blockquote>
<p>当指向一个对象的最后一个 shared_ptr被销毁时, shared_ptr类会自动销毁此对象。它是通过另一个特殊的成员函数——析构函数( destructor)完成销毁工作的。</p>
<blockquote>
<p>使用动态生存期的资源的类</p>
</blockquote>
<p>程序使用动态内存出于以下三种原因之一：</p>
<ul>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个资源之间共享数据</li>
</ul>
<h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><p>C++语言定义了两个运算符来分配和释放动态内存。运算符new分配内存, delete释放new分配的内存。</p>
<blockquote>
<p>使用new动态分配和初始化对象</p>
</blockquote>
<p>在自由空间分配的内存是无名的,因此new无法为其分配的对象命名,而是返回一个指向该对象的指针。</p>
<p>默认情况下,动态分配的对象是默认初始化的,这意味着内置类型或组合类型的对象的值将是未定义的,而类类型对象将用默认构造函数进行初始化</p>
<blockquote>
<p>内存耗尽</p>
</blockquote>
<p>一旦一个程序用光了它所有可用的内在,new表达式就会失败。默认情况下,加果new不能分配所要求的内存空间,它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常:</p>
<p>动态内存管理的时候非常容易出错：</p>
<ol>
<li>忘记delete内存</li>
<li>使用已经释放掉的对象</li>
<li>同一块内存释放两次</li>
</ol>
<blockquote>
<p>delete 之后重置指针</p>
</blockquote>
<p>当我们 delete一个指针后,指针值就变为无效了。虽然指针已经无效,但在很多机器上指针仍然保存着(已经释放了的)动态内存的地址。在 delete之后,指针就变成了人们所说的<strong>空悬指针</strong>( dangling pointer),即<strong>指向一块曾经保存数据对象但现在已经无效的内存的指针</strong>。</p>
<p>未初始化指针的所有缺点空悬指针也都有。有一种方法可以避免空悬指针的问题:在指针即将要离开其作用域之前释放掉它所关联的内存。</p>
<h3 id="share-ptr和new结合使用"><a href="#share-ptr和new结合使用" class="headerlink" title="share_ptr和new结合使用"></a>share_ptr和new结合使用</h3><p>如果我们不初始化一个智能指针，那么这个指针就会被初始化为一个空指针。</p>
<p>接受指针参数的智能指针构造函数是explicit的（禁止隐式转换）。因此,我们不能将一个内置指针隐式转换为一个智能指针,必须使用直接初始化形式</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520130371151.jpg" alt="enter description here"></p>
<h3 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h3><p>如果使用智能指针,即使程序块过早结束,智能指针类也能确保在内存不再需要时将其释放</p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>一个 <code>unique_ptr</code>“拥有”它所指向的对象。与 <code>shared_ptr</code>不同,某个时刻只能有一个 <code>unique_ptr</code>指向一个给定对象。当 <code>unique_ptr</code>被销毁时,它所指向的对象也被销毁。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520130502646.jpg" alt="enter description here"></p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr是一种不控制所指向对象生存期的智能指针,它指向由一个<code>shared_ptr</code>管理的对象。将一个 <code>weak_ptr</code>绑定到一个<code>shared_ptr</code>不会改变<code>shared_ptr</code>的引用计数。一旦最后一个指向对象的 <code>shared_ptr</code>被销毁,对象就会被释放。即使有<code>weak_ptr</code>指向对象,对象也还是会被释放。因此,<code>weak_ptr</code>的名字抓住了这种智能指针“弱”共享对象的特点。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520130696044.jpg" alt="enter description here"></p>
<p>由于对象可能不存在,我们不能使用 weak_ptr直接访问对象,而必须调用1ock。此函数检查 weak_ptr指向的对象是否仍存在。如果存在,lock返回一个指向共享对象的 shared_ptr。</p>
<p>weak_ptr的真正价值在于他能够帮助shared_ptr处理一些问题，其重点在于他对指向的对象没有管理权，表示我指向的东西就是这个，但是不管其释放不释放，其使用上有点像原始指针。</p>
<p>他的应用场景主要在于有的时候我们不需要shared_ptr释放资源这个功能的时候，比如说双向链表中的释放资源问题，会形成一个死环，当把节点中的引用改成弱引用就可以解决这个问题；比如内存中的缓存问题，可以使用weak_ptr找到需要在内存中的对象。</p>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>new和 delete运算符一次分配释放一个对象,但某些应用需要一次为很多对象分配内存的功能。</p>
<p>为了支持这种需求,C++语言和标准库提供了两种一次分配一个对象数组的方法。C+语言定义了另一种new表达式语法,可以分配并初始化一个对象数组。标准库中包含个名为allocator的类,允许我们们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力</p>
<h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h3><p>为了让new分配一个对象数组,我们要在类型名之后跟一对方括号,在其中指明要分配的对象的数目。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span> [get_size()]; <span class="comment">// pia指向第一个int</span></div></pre></td></tr></table></figure>
<p>虽然我们]通常称newT[]分配的内存为“动态数组”,但这种叫法某种程度上有些误导。当用new分配一个数组时,我们并未得到一个数组类型的对象,而是得到一个数组元素类型的指针。不能对动态数组调用begin和end。</p>
<blockquote>
<p>释放动态数组</p>
</blockquote>
<p>为了释放动态数组,我们使用一种特殊形式的 delete—在指针前加上一个空方括号对:</p>
<blockquote>
<p>智能指针和动态数组</p>
</blockquote>
<p>标准库提供了一个可以管理new分配的数组的 unique_ptr版本。为了用一个unique_ptr管理动态数组,我们必须在对象类型后面跟一对空方括号:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520132049585.jpg" alt="enter description here"></p>
<h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>new有一些灵活性上的局限,其中一方面表现在它将内存分配和对象构造组合在了起。类似的, delete将对象析构和内存释放组合在了一起。我们分配单个对象时,通常希望将内存分配和对象初始化组合在一起。因为在这种情况下,我们几乎肯定知道对象应有什么值。</p>
<p>标准库allocator类定义在头文件 memory中,它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法,它分配的内存是原始的、未构造的。allocator是一个模板。</p>
<blockquote>
<p>allocator 分配未构造的内存</p>
</blockquote>
<p>allocator分配的内存是未构造的( unconstructed)。我们按需要在此内存中构造对象。在新标准库中, construct成员函数接受一个指针和零个或多个额外参数,在给定位置构造一个元素。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Docker部署Hexo博客]]></title>
      <url>/2018/03/02/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>本文展示使用Docker部署Hexo博客（当然也可以是其他的服务）在服务器上的一种方案，主要用到是webhook来触发git pull操作。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之前部署Hexo博客的时候好像配置蛮久的，想着能不能把这些东西都放进Docker里面，以后换服务器以后部署也方面，于是便有了这波操作。</p>
<p>这里使用的是<a href="https://github.com/adnanh/webhook" target="_blank" rel="external">webhook</a>这个轮子来实现持续集成的。</p>
<p>工作示意图：<br>本地编辑—-git push—-&gt;Github—-webhook—-&gt;server—-get pull—-&gt;内容更新</p>
<p>使用到两个Docker：</p>
<ol>
<li><code>webhook</code>:  当push新的commit到GitHub（或其他平台）时解析GitHub发过来的webhook执行脚本更新网站内容</li>
<li><code>nginx</code>: Web服务器，展示网站内容</li>
</ol>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx容器的配置比较简单,只需要修改<code>nginx.conf</code>配置，监听80端口就行了。（如果需要需要https，则需要配置要证书以及配置监听443端口）。</p>
<p>这里贴出我的<code>docker-compose.yml</code>文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">version: &apos;3&apos;</div><div class="line">services:</div><div class="line">    web:</div><div class="line">        image: nginx</div><div class="line">        volumes:</div><div class="line">            - ./nginx.conf:/etc/nginx/nginx.conf</div><div class="line">            - ./sites-enabled:/etc/nginx/sites-enabled</div><div class="line">            - /path-to-your-content:/var/www</div><div class="line">            - ./ssl:/ssl</div><div class="line">        ports:</div><div class="line">            - &quot;80:80&quot;</div><div class="line">            - &quot;443:443&quot;</div></pre></td></tr></table></figure></p>
<p>ssl文件夹中的是证书，<code>path-to-your-content</code>是你静态页面的路径。</p>
<h2 id="Webhook"><a href="#Webhook" class="headerlink" title="Webhook"></a>Webhook</h2><p>Webhook任务是解析发过来的请求，然后执行脚本来从远程仓库中拉取更新。</p>
<p>首先是构建镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">FROM golang</div><div class="line">MAINTAINER sixzeroo &lt;sixzeroo60@gmail.com&gt;</div><div class="line"></div><div class="line">RUN mkdir -p /code/webhook \</div><div class="line">    &amp;&amp; touch /code/webhook/hook.json \</div><div class="line">    &amp;&amp; go get github.com/adnanh/webhook</div><div class="line"></div><div class="line">WORKDIR /code/webhook</div><div class="line"></div><div class="line">ENTRYPOINT /go/bin/webhook -hooks /code/webhook/hooks.json -verbose</div></pre></td></tr></table></figure></p>
<p>成品：<a href="https://hub.docker.com/r/sixzeroo/webhook/" target="_blank" rel="external">sixzeroo/webhook</a></p>
<p>之后就可以使用webhook来创建钩子任务了，其中配置文件在<code>hooks.json</code>中：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  &#123;</div><div class="line">    <span class="attr">"id"</span>: <span class="string">"your-id"</span>,</div><div class="line">    <span class="attr">"execute-command"</span>: <span class="string">"/code/webhook/work.sh"</span>,</div><div class="line">    <span class="attr">"command-working-directory"</span>: <span class="string">"/code/webhook"</span></div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>执行的脚本就是从GitHub中拉取更新而已，<code>work.sh</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#! /bin/sh</div><div class="line"></div><div class="line">cd /var/www &amp;&amp; git pull</div><div class="line"></div><div class="line">curtime=`date +&quot;%Y%m%d%H%M%S&quot;`</div><div class="line"></div><div class="line">if [ $? -eq 0 ];then</div><div class="line">    echo &quot;$curtime pull success!&quot; &gt;&gt; /code/webhook/git.log</div><div class="line">else</div><div class="line">    echo &quot;$curtime pull fail!&quot; &gt;&gt; /code/webhook/git.log</div><div class="line">fi</div></pre></td></tr></table></figure></p>
<p>最后配置整个服务，<code>docker-compose.yml</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">version: &quot;3&quot;</div><div class="line">services:</div><div class="line"></div><div class="line">    webhook:</div><div class="line">        image: sixzeroo/webhook</div><div class="line">        volumes:</div><div class="line">         - ./:/code/webhook</div><div class="line">         - /path-to-your-content:/var/www</div><div class="line">         - /key-path:/root/.ssh</div><div class="line">        ports:</div><div class="line">         - &quot;9000:9000&quot;</div></pre></td></tr></table></figure></p>
<p>其中<code>key-path</code>是你ssh文件夹路径</p>
<p>最后启动两个服务就可以工作了，设置GitHub当有push的时候发送<code>http://your-host:9000/hooks/your-id</code>这样的webhook就行了。</p>
<p>这里不把两个容器放到一个服务里面的原因是Nginx容器之后会有新的服务部署，里面会做一些修改。</p>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker Swarm 简介]]></title>
      <url>/2018/02/28/Docker-Swarm-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>Docker Swarm 为Docker 提供容器集群服务，是 Docker 官 方对容器云生态进行支持的核心方案。</p>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Swarm 是使用 SwarmKit 构建的 Docker 引擎内置（原生）的集群管理和编排工具。 Swarm 集群之前需要了解以下几个概念。</p>
<h3 id="什么是swarm"><a href="#什么是swarm" class="headerlink" title="什么是swarm"></a>什么是swarm</h3><p>嵌入在Docker Engine中的集群管理和编排功能是通过swarmkit构建的。 Swarmkit是一个独立的项目，它实现了Docker的编排层，并直接在Docker中使用。</p>
<p>一个群由多个Docker主机组成，这些主机以群模式运行并充当管理者（管理成员资格和委派）和工作者（运行群集服务）。 给定的Docker主机可以是管理员，工作者或执行这两种角色。 当您创建服务时，您可以定义其理想状态（副本数量，可用的网络和存储资源，将服务暴露给外部世界等等）。 Docker的工作是维持这个理想的状态。 例如，如果工作者节点变得不可用，Docker会在其他节点上调度该节点的任务。 任务是一个正在运行的容器，它是swarm服务的一部分，由swarm管理器管理，而不是独立的容器。</p>
<p>群集服务相对于独立容器的主要优势之一是可以修改服务的配置，其中包括连接的网络和卷，而无需手动重新启动服务。 Docker将更新配置，停止使用过时配置的服务任务，并创建与所需配置相匹配的新服务。</p>
<p>当Docker以群集模式运行时，您仍然可以在参与群集的任何Docker主机以及群集服务上运行独立容器。 独立容器和群集服务之间的一个主要区别是，只有群集管理员可以管理群集，而独立容器可以在任何守护进程上启动。 Docker守护进程可以作为管理者，工作者或两者参与群体。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>与Docker Engine集成的集群管理</li>
<li>分散设计：Docker Engine在部署时不需要处理节点角色之间的差异，而是在运行时处理这些特殊的东西</li>
<li>声明式服务模式：Docker Engine使用声明性方法来让您在应用程序堆栈中定义各种服务的所需状态。</li>
<li>伸缩服务</li>
<li>理想状态调整</li>
<li>多主机联网</li>
<li>服务发现</li>
</ul>
<h3 id="节点（Nodes）"><a href="#节点（Nodes）" class="headerlink" title="节点（Nodes）"></a>节点（Nodes）</h3><p>节点是参与群体的Docker引擎的一个实例。 您也可以将其视为Docker节点。 您可以在单台物理计算机或云服务器上运行一个或多个节点，但生产群部署通常包括分布在多台物理机和云计算机上的Docker节点。</p>
<p>节点分为管理( manager)节点和工作( wor ker)节点。</p>
<p>管理节点用于 Swarm集群的管理, <code>docker swarm</code>命令基本只能在管理节点执行(节点退出集群命令 docker swarm leave可以在工作节点执行)。一个 Swarm集群可以有多个管理节点,但只有一个管理节点可以成为 <code>leader</code> ,<code>leader</code>通过<code>raft</code>协议实现。</p>
<p>工作节点是任务执行节点,管理节点将服务( servlce)下发至工作节点执行。管理节点默认也作为工作节点。你也可以通过配置让服务只运行在管理节点</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_28_1519799540229.jpg" alt="enter description here"></p>
<h3 id="服务（Services）和任务（Tasks）"><a href="#服务（Services）和任务（Tasks）" class="headerlink" title="服务（Services）和任务（Tasks）"></a>服务（Services）和任务（Tasks）</h3><p>服务（Services）是要在管理器或工作节点上执行的任务的定义。它是群体系统的中心结构，也是群体与用户互动的主要根源。</p>
<p>任务（Task）包含一个Docker容器和在容器内运行的命令。它是swarm的原子调度单位。</p>
<p>服务有两种模式：</p>
<ul>
<li><code>replicated services</code> 按照一定规则在各个工作节点上运行指定个数的任务</li>
<li><code>global services</code>每个工作节点上运行一个任务</li>
</ul>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_28_1519799982888.jpg" alt="enter description here"></p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="初始化-swarm-init"><a href="#初始化-swarm-init" class="headerlink" title="初始化 (swarm init)"></a>初始化 (swarm init)</h3><p>使用<code>docker swarm init</code>来在本机初始化一个swarm集群</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ docker swarm init --advertise-addr 192.168.99.100</div><div class="line">Swarm initialized: current node (dxn1zf6l61qsb1josjja83ngz) is now a manager.</div><div class="line"></div><div class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</div><div class="line"></div><div class="line">    docker swarm join \</div><div class="line">    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \</div><div class="line">    192.168.99.100:2377</div><div class="line"></div><div class="line">To add a manager to this swarm, run <span class="string">'docker swarm join-token manager'</span> and follow the instructions.</div></pre></td></tr></table></figure>
<p>如果你的 Docker 主机有多个网卡，拥有多个 IP，必须使用 <code>--advertise-addr</code>指定 IP。</p>
<p>执行 docker swarm init 命令的节点自动成为管理节点。</p>
<h3 id="添加节点-swarm-join"><a href="#添加节点-swarm-join" class="headerlink" title="添加节点 (swarm join)"></a>添加节点 (swarm join)</h3><p>向集群中添加一个工作节点/管理节点</p>
<p>格式： <code>docker swarm join [OPTIONS] HOST:PORT</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker@worker1:~$ docker swarm join \</div><div class="line">    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \</div><div class="line">    192.168.99.100:2377</div></pre></td></tr></table></figure>
<h3 id="查看节点-node-ls"><a href="#查看节点-node-ls" class="headerlink" title="查看节点 (node ls)"></a>查看节点 (node ls)</h3><p>使用 <code>docker node ls</code> 查看集群</p>
<h3 id="新建服务-service-create"><a href="#新建服务-service-create" class="headerlink" title="新建服务 (service create)"></a>新建服务 (service create)</h3><p>命令格式：<code>docker service create [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker service create --replicas 3 -p 80:80 --name nginx nginx:1.13.7-alpine</div></pre></td></tr></table></figure></p>
<p><code>--replicas</code> 表示创建多少任务</p>
<h3 id="查看服务信息-service-ls"><a href="#查看服务信息-service-ls" class="headerlink" title="查看服务信息 (service ls)"></a>查看服务信息 (service ls)</h3><p>使用 <code>docker service ls</code> 来查看当前 Swarm 集群运行的服务</p>
<p>想要查看其中某一个服务的详细信息，可以使用 <code>service inspect</code>命令: <code>docker service inspect [OPTIONS] SERVICE [SERVICE...]</code></p>
<h3 id="查看服务中的任务详情-service-ps"><a href="#查看服务中的任务详情-service-ps" class="headerlink" title="查看服务中的任务详情 (service ps)"></a>查看服务中的任务详情 (service ps)</h3><p>使用 <code>docker service ps</code> 来查看某个服务中的任务(Task)的详情 <code>docker service ps [OPTIONS] SERVICE [SERVICE...]</code></p>
<h3 id="查看服务日志-service-logs"><a href="#查看服务日志-service-logs" class="headerlink" title="查看服务日志 (service logs)"></a>查看服务日志 (service logs)</h3><p>使用 <code>docker service logs</code> 来查看某个服务的日志</p>
<h3 id="删除服务-service-rm"><a href="#删除服务-service-rm" class="headerlink" title="删除服务 (service rm)"></a>删除服务 (service rm)</h3><p>使用 <code>docker service rm</code> 来从 Swarm 集群移除某个服务。</p>
<h3 id="服务伸缩-service-scale"><a href="#服务伸缩-service-scale" class="headerlink" title="服务伸缩 (service scale)"></a>服务伸缩 (service scale)</h3><p>使用 <code>docker service scale</code>调整服务中的任务数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker service scale backend=10</div></pre></td></tr></table></figure>
<h2 id="使用Stack部署服务"><a href="#使用Stack部署服务" class="headerlink" title="使用Stack部署服务"></a>使用Stack部署服务</h2><p>Stack是一组相互关联的服务，它们可以共享依赖关系，并且可以进行协调和缩放。 单个Stack能够定义和协调整个应用程序的功能（尽管非常复杂的应用程序可能需要使用多个Stack）</p>
<p>正如之前使用 docker-compose.yml 来一次配置、启动多个容器，在 Swarm 集群中也可以使用 compose 文件 （docker-compose.yml） 来配置、启动多个服务。</p>
<p>我们使用 docker service create 一次只能部署一个服务，使用 docker-compose.yml 我们可以一次启动多个关联的服务。我们在此以 Swarm 集群中部署 WordPress 为例进行说明。</p>
<p>docker-compose.yml 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">version: &quot;3&quot;</div><div class="line"></div><div class="line">services:</div><div class="line">  wordpress:</div><div class="line">    image: wordpress</div><div class="line">    ports:</div><div class="line">      - 80:80</div><div class="line">    networks:</div><div class="line">      - overlay</div><div class="line">    environment:</div><div class="line">      WORDPRESS_DB_HOST: db:3306</div><div class="line">      WORDPRESS_DB_USER: wordpress</div><div class="line">      WORDPRESS_DB_PASSWORD: wordpress</div><div class="line">    deploy:</div><div class="line">      mode: replicated</div><div class="line">      replicas: 3</div><div class="line"></div><div class="line">  db:</div><div class="line">    image: mysql</div><div class="line">    networks:</div><div class="line">       - overlay</div><div class="line">    volumes:</div><div class="line">      - db-data:/var/lib/mysql</div><div class="line">    environment:</div><div class="line">      MYSQL_ROOT_PASSWORD: somewordpress</div><div class="line">      MYSQL_DATABASE: wordpress</div><div class="line">      MYSQL_USER: wordpress</div><div class="line">      MYSQL_PASSWORD: wordpress</div><div class="line">    deploy:</div><div class="line">      placement:</div><div class="line">        constraints: [node.role == manager]</div><div class="line"></div><div class="line">  visualizer:</div><div class="line">    image: dockersamples/visualizer:stable</div><div class="line">    ports:</div><div class="line">      - &quot;8080:8080&quot;</div><div class="line">    stop_grace_period: 1m30s</div><div class="line">    volumes:</div><div class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</div><div class="line">    deploy:</div><div class="line">      placement:</div><div class="line">        constraints: [node.role == manager]</div><div class="line"></div><div class="line">volumes:</div><div class="line">  db-data:</div><div class="line">networks:</div><div class="line">  overlay:</div></pre></td></tr></table></figure></p>
<p>在 Swarm 集群管理节点新建该文件，其中的 visualizer 服务提供一个可视化页面，我们可以从浏览器中很直观的查看集群中各个服务的运行节点。</p>
<h3 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h3><p>部署服务使用 <code>docker stack deploy</code>，其中 -c 参数指定 compose 文件名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker stack deploy -c docker-compose.yml wordpress</div></pre></td></tr></table></figure></p>
<h3 id="查看服务"><a href="#查看服务" class="headerlink" title="查看服务"></a>查看服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker stack ls</div><div class="line">NAME                SERVICES</div><div class="line">wordpress           3</div></pre></td></tr></table></figure>
<h3 id="移除服务"><a href="#移除服务" class="headerlink" title="移除服务"></a>移除服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">要移除服务，使用 docker stack down</div><div class="line"></div><div class="line">$ docker stack down wordpress</div><div class="line">Removing service wordpress_db</div><div class="line">Removing service wordpress_visualizer</div><div class="line">Removing service wordpress_wordpress</div><div class="line">Removing network wordpress_overlay</div><div class="line">Removing network wordpress_default</div></pre></td></tr></table></figure>
<p>该命令不会移除服务所使用的 数据卷，如果你想移除数据卷请使用 docker volume rm</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://0x9.me/WYIcD" target="_blank" rel="external">https://0x9.me/WYIcD</a></li>
<li><a href="https://0x9.me/Woidc" target="_blank" rel="external">https://0x9.me/Woidc</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode Next Permutation 题解]]></title>
      <url>/2018/02/25/LeetCode-Next-Permutation-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>LeetCode Next Permutation 题解</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目的意思就是求给定序列的下一个字典序</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们要了解什么是字典序，这里参考wiki的解释：</p>
<blockquote>
<p>设想一本英语字典里的单词，何者在前何者在后？</p>
<p>显然的做法是先按照第一个字母、以 a、b、c……z 的顺序排列；如果第一个字母一样，那么比较第二个、第三个乃至后面的字母。如果比到最后两个单词不一样长（比如，sigh 和 sight），那么把短者排在前。</p>
<p>通过这种方法，我们可以给本来不相关的单词强行规定出一个顺序。“单词”可以看作是“字母”的字符串，而把这一点推而广之就可以认为是给对应位置元素所属集合分别相同的各个有序多元组规定顺序</p>
</blockquote>
<p>我的理解是：<strong>把一组数的所有排列情况按照字母顺序进行一次排序得到的就是一个字典序</strong></p>
<p>在这道题中要求给定排列的下一个字典序，可以知道把一个大一点的数往前移动这个序列的字典序一定会变大，那么就要从后往前找到第一个能变大的数（变大指和它后面的某个数互换以后），找到这个数以后把他和比他大的“第一个”数互换获得最小的增量，然后把这个数后面的数字按照从小到大的顺序重新排列。</p>
<p>举个例子：</p>
<p><img src="https://leetcode.com/media/original_images/31_Next_Permutation.gif" alt="enter description here"></p>
<h2 id="代码-C"><a href="#代码-C" class="headerlink" title="代码(C++)"></a>代码(C++)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int first = nums.size(), len = nums.size();</div><div class="line">        // 倒序查找第一个升序数</div><div class="line">        for(int i=len-1; i&gt;0;--i)</div><div class="line">        &#123;</div><div class="line">            if(nums[i] &gt; nums[i-1])</div><div class="line">            &#123;</div><div class="line">                first = i-1;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if(first == len)</div><div class="line">            reverse(nums.begin(), nums.end());</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            int second = len-1;</div><div class="line">            // 在后面找一个刚好比这个数大一点的数和其互换</div><div class="line">            for(int i=first + 1;i&lt;len;++i)</div><div class="line">            &#123;</div><div class="line">                if(nums[i]&lt;=nums[first])</div><div class="line">                &#123;</div><div class="line">                    second = i-1;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            swap(nums[first], nums[second]);</div><div class="line">            // 反转后面的部分</div><div class="line">            reverse(nums.begin()+first+1, nums.end());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker Machine 简介]]></title>
      <url>/2018/02/16/Docker-Machine-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>Docker 继续探索</p>
<a id="more"></a>
<h2 id="什么是Docker-Machine"><a href="#什么是Docker-Machine" class="headerlink" title="什么是Docker Machine"></a>什么是Docker Machine</h2><p>Docker Machine 是一种可让您在虚拟主机上安装 <code>Docker Engine</code> 并使用docker-machine命令管理主机的工具。你能使用Docker Machine 工具在你的本地 Mac 或 Windows boxs，公司网络，数据中心或 Azure 提供商（如 Azure，AWS 或 Digital Ocean）上创建 Docker 主机。</p>
<p>使用 <code>docker-machine</code> 命令，你能够开始、插入、停止和重启一个你所管理的主机、更新Docker的客户端和守护进程、并配置Docker配置以便和主机进行通信。</p>
<p>将Machine CLI指向一个正在运行并且托管的主机，你能够直接使用<code>docker</code>直接命令该主机。比如说，运行<code>docker-machine env default</code>指向一个名为<code>defaule</code>的主机，按照屏幕上的指令完成<code>env</code>的配置，并运行<code>docker ps</code> ，<code>docker run hello-world</code>等等</p>
<p>在Docker v1.12版本之前，Machine是在Mac和Window上运行Docker的唯一方法。从 Beta 版程序和 Docker v1.12 开始，Docker for Mac 和 Docker for Windows 可作为本地应用程序使用，并且是在在较新的台式机和笔记本电脑上的更好选择。我们鼓励您尝试这些新应用。 Docker for Mac 和Docker for Windows 的安装程序包括 Docker Machine，以及 Docker Compose。</p>
<h2 id="在什么情况下使用Docker-Machine"><a href="#在什么情况下使用Docker-Machine" class="headerlink" title="在什么情况下使用Docker Machine"></a>在什么情况下使用Docker Machine</h2><p>Docker Machine提供一种在各种各样的Linux主机上配置Docker的解决方案。此外Machine能够让你在老的的Mac和Windows上像上面一样运行Docker。</p>
<p>Docker有两个基本的应用场景：</p>
<ol>
<li>我有一个旧的桌面系统，并且想在Mac和Windows上运行Docker</li>
</ol>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518682583374.jpg" alt="enter description here"></p>
<p>如果你的主要工作环境是在一台旧的Mac或者Windows笔记本电脑或者台式机上，这些主机无法满足新的<code>Docker for Mac</code>和<code>Docker for Windows</code>的配置要求，那么你可以使用Docker Machine来在本地使用Docker Engine。</p>
<p>使用 Docker Toolbox 安装程序在 Mac 或 Windows box 上安装 Docker Machine 可以使用 Docker Engine 配置本地虚拟机，使您可以连接它并运行 docker 命令。</p>
<ol>
<li>我想在远程系统中配置Docker主机</li>
</ol>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518682822569.jpg" alt="enter description here"></p>
<p>Docker Engine在Linux系统上本机运行。如果有一个Linux box作为你的主系统，并且向运行<code>docker</code>命令，你需要的东西就是下载并安装Docker Engine。但是你想用一种高效的方式在网络、云端甚至本地配置多个Docker主机，你就需要Docker Machine</p>
<p>不管你的主系统是Linux、Max还是Windows，你都能够安装Docker Machine并且使用<code>docker-machine</code>去配置并管理大量的Docker主机。它会自动创建主机、安装Docker Engine并且配置docker 客户端。每个托管主机（“machine”）是 Docker 主机和配置的客户端的组合。</p>
<h2 id="Docker-Engine-和-Docker-Machine的区别"><a href="#Docker-Engine-和-Docker-Machine的区别" class="headerlink" title="Docker Engine 和 Docker Machine的区别"></a>Docker Engine 和 Docker Machine的区别</h2><p>当人们说“Docker”时，他们通常意味着 Docker Engine，即由 Docker 守护程序组成的客户端-服务器应用程序，指定用于与守护程序进行交互的接口的 REST API 以及与守护程序（通过 REST API 包装器）通信的命令行界面（CLI）客户端。<code>Docker Engine</code> 从 CLI 接受<code>docker</code>命令，例如<code>docker run &lt;image&gt;</code>，<code>docker ps</code>列出运行的容器，<code>docker images</code>以列出镜像等。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518683627228.jpg" alt="enter description here"></p>
<p>Docker Machine 是一种用于配置和管理 Docker 化的主机（Docker Engine的主机）的工具。通常，您在本地系统上安装 Docker Machine。Docker Machine 有自己的命令行客户端docker-machine和 Docker Engine 客户端docker。您可以使用 Machine 在一个或多个虚拟系统上安装 Docker Engine。这些虚拟系统可以是本地的（如当您使用 Machine 在 Mac 或 Windows 上的 VirtualBox 中安装和运行 Docker Engine）或远程（当您使用 Machine 在云提供商上配置 Docker 化主机时）。Docker 化主机本身可以被认为是有时被称为托管的“machines”。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518683773491.jpg" alt="enter description here"></p>
<h2 id="安装-Docker-Machine"><a href="#安装-Docker-Machine" class="headerlink" title="安装 Docker Machine"></a>安装 Docker Machine</h2><p>安装Docker Machine的前提是你已经安装好Docker</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -L https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-`uname <span class="_">-s</span>`-`uname -m` &gt;/usr/<span class="built_in">local</span>/bin/docker-machine &amp;&amp; \</div><div class="line"> chmod +x /usr/<span class="built_in">local</span>/bin/docker-machine</div></pre></td></tr></table></figure>
<h3 id="maxOS"><a href="#maxOS" class="headerlink" title="maxOS"></a>maxOS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> curl -L https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-`uname <span class="_">-s</span>`-`uname -m` &gt;/tmp/docker-machine &amp;&amp; \</div><div class="line">sudo install /tmp/docker-machine /usr/<span class="built_in">local</span>/bin/docker-machine</div></pre></td></tr></table></figure>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>使用GIt Bash工具安装，并且这个工具支持像<code>chmod</code>这样的Linux命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> if [[ ! -d &quot;$HOME/bin&quot; ]]; then mkdir -p &quot;$HOME/bin&quot;; fi &amp;&amp; \</div><div class="line">curl -L https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-Windows-x86_64.exe &gt; &quot;$HOME/bin/docker-machine.exe&quot; &amp;&amp; \</div><div class="line">chmod +x &quot;$HOME/bin/docker-machine.exe&quot;</div></pre></td></tr></table></figure></p>
<h2 id="普通情况使用Docker-Machine创建Machine"><a href="#普通情况使用Docker-Machine创建Machine" class="headerlink" title="普通情况使用Docker Machine创建Machine"></a>普通情况使用Docker Machine创建Machine</h2><p>假设我现在有两个主机：主机1运行Docker Machine，创建主机2为Docker 主机</p>
<h3 id="配置免交互认证登录"><a href="#配置免交互认证登录" class="headerlink" title="配置免交互认证登录"></a>配置免交互认证登录</h3><p>将主机1的公钥放入主机2的<code>~/.ssh/authorized_keys</code>文件中</p>
<p>或者使用<code>ssh-copy-id</code>完成上面的操作</p>
<h3 id="修改sudoers文件"><a href="#修改sudoers文件" class="headerlink" title="修改sudoers文件"></a>修改sudoers文件</h3><p>在主机2中的<code>/etc/sudoers</code>文件中添加<code>Defaults  visiblepw</code>一行（或者把<code>!visiblepw</code>改为<code>visiblepw</code>）</p>
<h3 id="创建一个Docker主机"><a href="#创建一个Docker主机" class="headerlink" title="创建一个Docker主机"></a>创建一个Docker主机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine create --driver generic--generic-ip-address=192.168.1.111 Ubuntu-004</div></pre></td></tr></table></figure>
<p>使用docker-machinecreate创建machine时，会检测主机是否已经安装docker，如果安装就简单做相应的检查动作即可，如果未安装，则会安装最新版的docker</p>
<h2 id="在云服务提供商平台使用Docker-Machine"><a href="#在云服务提供商平台使用Docker-Machine" class="headerlink" title="在云服务提供商平台使用Docker Machine"></a>在云服务提供商平台使用Docker Machine</h2><p>Docker Machine支持几个流行的云平台，如Digital Ocean、Amazon Web Services（AWS）、Microsoft Azure、Google Cloud Computing及其它等等，所以我们可以在不同的平台使用相同的接口来部署Docker。这里我们使用Digital Ocean驱动在Digital Ocean的服务器上部署Docker，运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker-machine create --driver digitalocean --digitalocean-access-token &lt;API-Token&gt; Linux-test</div><div class="line"></div><div class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(docker-machine env Linux-test)</span>"</span></div></pre></td></tr></table></figure>
<p><code>--driver</code>选项指定digitalocean驱动，<code>--digitalocean-access-token</code>选项指定<a href="https://cloud.digitalocean.com/settings/applications" target="_blank" rel="external">Digital Ocean Control Panel</a>提供的API Token，命令最后的是我们创建的Docker虚拟机的机器名。</p>
<p>返回的信息如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Creating CA: /root/.docker/machine/certs/ca.pem</div><div class="line">Creating client certificate: /root/.docker/machine/certs/cert.pem</div><div class="line">Running pre-create checks...</div><div class="line">Creating machine...</div><div class="line">(Linux-test) Creating SSH key...</div><div class="line">(Linux-test) Creating Digital Ocean droplet...</div><div class="line">(Linux-test) Waiting <span class="keyword">for</span> IP address to be assigned to the Droplet...</div><div class="line">Waiting <span class="keyword">for</span> machine to be running, this may take a few minutes...</div><div class="line">Detecting operating system of created instance...</div><div class="line">Waiting <span class="keyword">for</span> SSH to be available...</div><div class="line">Detecting the provisioner...</div><div class="line">Provisioning with ubuntu(systemd)...</div><div class="line">Installing Docker...</div><div class="line">Copying certs to the <span class="built_in">local</span> machine directory...</div><div class="line">Copying certs to the remote machine...</div><div class="line">Setting Docker configuration on the remote daemon...</div><div class="line">Checking connection to Docker...</div><div class="line">Docker is up and running!</div><div class="line">To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env Linux-test</div></pre></td></tr></table></figure></p>
<p>运行如上命令后，我们可以在Digital Ocean Droplet Panel中看到一个新的具有默认配置的droplet已经被创建出来了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518684941619.jpg" alt="enter description here"></p>
<p>简便起见，docker-machine会使用默认配置来部署Droplet。我们可以通过增加选项来定制我们的Droplet。这里是一些digitalocean相关的选项，我们可以使用它们来覆盖Docker Machine所使用的默认配置。</p>
<ul>
<li>–digitalocean-image “ubuntu-14-04-x64” 用于选择Droplet的镜像</li>
<li>–digitalocean-ipv6 enable 启用IPv6网络支持</li>
<li>–digitalocean-private-networking enable 启用专用网络</li>
<li>–digitalocean-region “nyc3” 选择部署Droplet的区域</li>
<li>–digitalocean-size “512mb” 选择内存大小和部署的类型</li>
</ul>
<p>如果你想在其他云服务使用docker-machine，并且想覆盖默认的配置，可以运行如下命令来获取Docker Mackine默认支持的对每种平台适用的参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine create -h</div></pre></td></tr></table></figure></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="查看主机"><a href="#查看主机" class="headerlink" title="查看主机"></a>查看主机</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine ls</div></pre></td></tr></table></figure>
<p>ACTIVE一列有“*”标记的是活跃主机，同时可以用<code>docker-machine active</code>命令来标记其他的主机为活跃主机</p>
<h3 id="使用Docker容器"><a href="#使用Docker容器" class="headerlink" title="使用Docker容器"></a>使用Docker容器</h3><p>创建主机成功后，可以通过 env 命令来让后续操作对象都是目标主机。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker-machine env <span class="built_in">test</span></div></pre></td></tr></table></figure></p>
<p>后续根据提示在命令行输入命令之后就可以操作 test 主机。</p>
<p>也可以通过 SSH 登录到主机：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh <span class="built_in">test</span></div><div class="line"></div><div class="line">docker@<span class="built_in">test</span>:~$ docker --version</div><div class="line">Docker version 17.10.0-ce, build f4ffd25</div></pre></td></tr></table></figure></p>
<p>连接到主机之后你就可以在其上使用 Docker 了。</p>
<h3 id="删除主机"><a href="#删除主机" class="headerlink" title="删除主机"></a>删除主机</h3><p>删除在运行的主机以及它的所有镜像和容器，我们可以使用<code>docker-machine rm</code>命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine rm linux-dev</div></pre></td></tr></table></figure></p>
<p>运行完以后，本地和与远端的都将删除，在云平台上的实例也会被删除</p>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><ul>
<li>active 查看活跃的 Docker 主机</li>
<li>config 输出连接的配置信息</li>
<li>create 创建一个 Docker 主机</li>
<li>env 显示连接到某个主机需要的环境变量</li>
<li>inspect 输出主机更多信息</li>
<li>ip 获取主机地址</li>
<li>kill 停止某个主机</li>
<li>ls 列出所有管理的主机</li>
<li>provision 重新设置一个已存在的主机</li>
<li>regenerate-certs 为某个主机重新生成 TLS 认证信息</li>
<li>restart 重启主机</li>
<li>rm 删除某台主机</li>
<li>ssh SSH 到主机上执行命令</li>
<li>scp 在主机之间复制文件</li>
<li>mount 挂载主机目录到本地</li>
<li>start 启动一个主机</li>
<li>status 查看主机状态</li>
<li>stop 停止一个主机</li>
<li>upgrade 更新主机 Docker 版本为最新</li>
<li>url 获取主机的 URL</li>
<li>version 输出 docker-machine 版本信息</li>
<li>help 输出帮助信息</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《C++ Primer》笔记 C++基础部分]]></title>
      <url>/2018/02/15/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-C-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/</url>
      <content type="html"><![CDATA[<p>《C++ Primer》笔记 C++基础部分</p>
<a id="more"></a>
<h1 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h1><h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><h3 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h3><p>类型char和类型signed char并不一样。尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。</p>
<p>当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）</p>
<p>与一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。把int转换成无符号数的过程和把int直接赋给无符号数—样。</p>
<h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517231165506.jpg" alt="enter description here"></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>初始化不是赋值，初始化的含义是创建一个变量的时候赋予其一个初始值，而赋值的含义是把对象的当前值删除，而以一个新值来代替</p>
<p>默认初始化：如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将不被初始化(uninitialized)。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。</p>
<p>使用未初始化的值将带来无法预计的后果</p>
<h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>变量能且只能被定义一次，但可以被声明多次</p>
<h3 id="标识符（identifier）"><a href="#标识符（identifier）" class="headerlink" title="标识符（identifier）"></a>标识符（identifier）</h3><h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>建议：当你第一次使用变量的时候再定义它</p>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用（reference）为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。</p>
<p>一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定（bind)在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此<strong>引用必须初始化</strong>。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517232990644.jpg" alt="enter description here"></p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针必须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，将拥有一个不确定的值。</p>
<p>指针的他（即地址）应属下列4种状态之一:</p>
<ol>
<li>指向一个对象。</li>
<li>指叫紧邻对象所占空间的下一个位置。</li>
<li>空指针，意味着指针没有指向任何对象。</li>
<li>无效指针，也就是上述情况之外的其他值。</li>
</ol>
<p>访问无效指针和空指针或者未知指针的后果无法预计</p>
<p><code>void*</code>指针时一种特殊的指针类型，可用于存放任意对象的地址。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象做哪些操作。</p>
<h3 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h3><p>引用本身不是对象，因此不能定义指向引用的指针。但是指针是对象，所以存在对指针的引用。</p>
<h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p>const对象被设定为仅在文件内有效</p>
<p>对const的引用可能引用一个并非const的对象：常量引用仅对引用可参与的操作做出了限定，对于引用对象本身是不是一个常量未作限定。</p>
<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p>用名词<strong>顶层const</strong>(top-levelconst)表示指针本身是个常量，而用名词<strong>底层const</strong>(low-levelconst)表示指针所指的对象是一个常量。</p>
<h3 id="constexpr-和常量表达式"><a href="#constexpr-和常量表达式" class="headerlink" title="constexpr 和常量表达式"></a>constexpr 和常量表达式</h3><p>常量表达式（constexpression)是指值不会改变而且在编译过程就能得到汁算结果的表达式。当然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。</p>
<p>C++11标准规定，允许将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量表达式。</p>
<h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h3><p>编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，C++11新标准引入了auto类型说明符，用它就能让编译器帮我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如double)不同，auto让编译器通始值来推算变量的类型。显然，auto定义的变量必须有初始值：</p>
<p>auto一般会忽略顶层const，同时底层const则会保留下来</p>
<h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h3><p>有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变蛩。为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数椐类型。在此过程中，编译器分忻表达式并得到它的类型，却不实际汁算表达式的值:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">decltype</span>(f()) sum = x;   <span class="comment">// sum的类型就是函数f的返回类型</span></div></pre></td></tr></table></figure>
<p>decltype 处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）</p>
<hr>
<h1 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a>字符串、向量和数组</h1><h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p>如果提供一个字符串字面值，则该字面值中除了最后那个空字符外其他所有字符都被拷贝新建的string对象中。</p>
<blockquote>
<p>直接初始化和拷贝初始化</p>
</blockquote>
<p>如果使用等号（=）初始化一个变量，实际上执行的是<strong>拷贝初始化</strong>（copy initialization），编译器将等号右侧的初始值拷贝到新创建的对象中去。<br>与之相反，不使用等号，则执行的是<strong>直接初始化</strong>（direct initialization）</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517572296753.jpg" alt="enter description here"></p>
<blockquote>
<p>string:size_type 类型</p>
</blockquote>
<p>string类及其他大多数标准库类型都定义了几种配套的类型。这些配套体现了标准库类型与机器无关的特性，类型size_type即是其中的一种。在具体使用的时候，通过作用域操作符表明名字size_type是在类string中定义的。</p>
<blockquote>
<p>字面值和string对象相加</p>
</blockquote>
<p>当把string对象和字符字面值以及字符串字面值混在一条语句中使用的时候，必须保证每个加法运算符的两侧至少有一个是string对象</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517572788565.jpg" alt="enter description here"></p>
<h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p>如果循环体内部包含有向 vector对象添加元元素的语句,则不能使用范 围for循环</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517659028911.jpg" alt="enter description here"></p>
<p>不能用下标形式添加元素：vector对象(以及 string对象)的下标运算符可用于访问已存在的元素, 而不能用于添加元素。</p>
<h2 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h2><p>所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符</p>
<p>类似于指针类型,迭代器也<strong>提供了对对象的间接访问</strong>。就迭代器而言,其对对象是容器中的元素或者者 string对象中的字符。使用迭代器可以访问某 个元素,迭代器也能从一个元素移动到另外一个元素。迭代器有有效和无效之分,这一点 和指针差不多。<strong>有效的迭代器或者指向某个元素,或者指向容器中尾元素的下一位置</strong>，其他所有情况都属于无效。</p>
<h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>end成员负责返回指向容器(或 string对象)“尾元素的下一位置( one past the end) 的迭代器,也就是说,该迭代器指示的是容器的一个本不存在的“尾后( off the end)”元 素。这样的迭代器没什么实际含义,仅是个标记而已,表示我们已经处理完了容器中的所 有元素。end成员返回的迭代器常被称作尾后迭代器( off-the- end iterator)或者简称为尾 迭代器( end iterator)。特殊情况下如果容器为空,则beg1n和end返回的是同一个迭 代器。（都是尾后迭代器）</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517659661001.jpg" alt="enter description here"></p>
<p>迭代器运算符</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517659702856.jpg" alt="enter description here"></p>
<blockquote>
<p>迭代器类型</p>
</blockquote>
<p>就像不知道 string和 vector的 size type成员员到底是什么类型一样,一般来说我们也不知道(其实是无须知道)迭代器的精确类型。而实际上, 那些拥有迭代器的标准库类型使用 iterator和 const iterator来表示迭代器的类型</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517659938792.jpg" alt="enter description here"></p>
<blockquote>
<p>某些对vector对象的操作会使迭代器失效</p>
</blockquote>
<p>不能在for循环范围内向vector对象添加元素；任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效</p>
<h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><p>迭代器的递增运算令迭代器每次移动一个元素,所有的标准库容器都有支持递增运算 的迭代器。类似的,也能用=和!=对任意标准库类型的两个有效迭代器进行比较</p>
<p>vector和string迭代器支持更多的迭代器运算</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517660460874.jpg" alt="enter description here"></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>不允许拷贝和赋值</p>
</blockquote>
<p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值</p>
<blockquote>
<p>理解复杂的数组声明</p>
</blockquote>
<p>类型修饰符从右向左依次绑定，就数组而言，由内向外阅读比从右向左好很多</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517660778235.jpg" alt="enter description here"></p>
<blockquote>
<p>访问数组元素</p>
</blockquote>
<p>在使用数组下标的时候,通常将其定义为size_t类型。size_t是一种机器相关的 无符号类型,它被设计得足够大以便能表示内存中任意对象的大小。</p>
<blockquote>
<p>标准库函数</p>
</blockquote>
<p>尽管能计算得到尾后指针,但这种用法极易出错。为了让指针的使用更简单、更安全, C++11新标准引引入了两个名为 begin和end的函数。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517661137672.jpg" alt="enter description here"></p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>严格来说，C++语言中没有多维数组，通常所说的的多维数组其实是数组的数组。</p>
<hr>
<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p>重载运算符</p>
</blockquote>
<p>C++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时,用户可以自行定义其含义义。因为这种自定义的过程事实 上是为已存在的运算符赋予了另外一层含义,所以称之为<strong>重載运算符</strong>( overloaded operator)。</p>
<blockquote>
<p>左值和右值</p>
</blockquote>
<p>C++的表达式要不然是右值( rvalue,读作“are- value”),要不然就是左值( lvalue, 读作“ ell-value”)。这两个名词是从C语言继承过来的,原本是为了帮助记忆:左值可以 位于赋值语句的左侧,右值则不能。</p>
<p>在C++语言中,二者的区别就没那么简单了。一个左值表达式的求值结果是一个对象 或者一个函数,然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对 象。此外,虽然某些表达式的求值结果是对象,但它们是右值而非左值。可以做一个简单 的归纳:<strong>当一个对象被用作右值的时候,用的是对象的值(内容);当对象被用作左值的 时候,用用的是对象的身份(在内存中的位置)。</strong> </p>
<p>不同的运算符对运算对象的要求各不相同,有的需要左值运算对象、有的需要右值运 算对象:返回值也有差异,有的得到左值结果、有的得到右值结果。一个重要的原则是：<strong>在需要右值的地方可以用左值来代替,但 是不能把右值当成左值(也就是位置)使用</strong>。 当一个左值被当成右值使用时,实际使用的 是它的内容(值)。</p>
<h3 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h3><p>对于那些没有指定执行顺序的运算符来说,如果表达式指向并修改了同一个对象,将会引发错误并产生<strong>未定义的行为</strong>。</p>
<p>举个简单的例子,&lt;&lt;运算符 没有明确规定何时以及如何对运算对象求值,因此下面的输出表达式是末定义的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"+"</span> &lt;&lt; ++i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 未定义的</span></div></pre></td></tr></table></figure></p>
<p>C++语言没有明确规定大多数二元运算符的求值顺序,给编译器优化留下了 余地。这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡.</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517751109803.jpg" alt="enter description here"></p>
<p>算术运算符能作用域任何算术类型以及任意能转化为算术类型的类型。</p>
<p>算术表达式有可能产生未定义的结果。一部分原因是数学性质本身:例如除数是0 的情况;另外一部分则源于计算机的特点:例如溢出,当计算的结果超出该类型所能表 示的范围时就会产生溢出。</p>
<blockquote>
<p>除法和取模运算</p>
</blockquote>
<p>在除法运算中,如果两个运算对象的符号相同则商为正(如果不为0的话),否则商 为负。C++语言的早期版本允许结果为负值的商向上或向下取整,C++11新标准则规定商 律向0取整(即直接切除小数部分) </p>
<p>根据取余运算的定义,如果m和n是整数且n非0,则表达式(m/n)*n+m%n的求值 结果与m相等。隐含的意思是,如果m%n不等于0,则它的符号和m相同。C++语言的早 期版本允许m%n的符号匹配n的符号,而且商向负无穷一侧取整,这一方式在新标准中 已经被禁止使用了。除了-m导致溢出的特殊情况,其他时候(-m)/n和m/(-n)都等于 (m/n),m%(-n)等于m%n,(-m)%n等于-(m%n)。</p>
<p>具体示例如下:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517751057230.jpg" alt="enter description here"></p>
<h2 id="逻辑运算符和关系运算符"><a href="#逻辑运算符和关系运算符" class="headerlink" title="逻辑运算符和关系运算符"></a>逻辑运算符和关系运算符</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517751134864.jpg" alt="enter description here"></p>
<p>逻辑与运算符和逻辑或运算符都是先求左側运算对象的值再求右侧运算对象的值,当 且仅当左側运算对象无法确定表达式的结果时オ会计算右侧运算对象的值。这种种策略称为 短路求值( short- circuit evaluation)。</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符的左侧运算对象必须是一个可修改的左值</p>
<h2 id="递增运算符和递减运算符"><a href="#递增运算符和递减运算符" class="headerlink" title="递增运算符和递减运算符"></a>递增运算符和递减运算符</h2><p>递增和递减运算符有两种形式:前置版本和后置版本。前置递增运算符首先将运算对象加1(或减1),然后将改变后的对象作为求 值结果。后置版本也会将运算对象加1(或减1),但是求值结果是运算对象改变之前那个 值的副本</p>
<p>建议:除非必须,否则不用递增递减运算符的后置版本：<br>有C语言背景的读者可能对优先使用前置版本递增运算符有所疑间问,其实原因非常 简单:前置版本的递增运算符避免了不必要的工作,它把值加1后直接返回改变了的运 算对象。与之相比,后置版本需要将原始值存储下来以便于返回这个未修改的内容。如 果我们不需要修改前的值,那么后置版本的操作就是一种浪费。</p>
<h2 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h2><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律,其所得得的值是一个size_t类型</p>
<p>运算符的运算对象有两种形式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">sizeof</span>(type)</div><div class="line"><span class="keyword">sizeof</span> expr</div></pre></td></tr></table></figure></p>
<p>在第二种形式中，sizeof返回的是表达式结果类型的大小。与众不同的一点是，sizeof并不实际计算其运算对象的值：</p>
<p>因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中的元素个数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(ia)/<span class="keyword">sizeof</span>(*ia);</div><div class="line"><span class="keyword">int</span> arr2[sz]; <span class="comment">// ok sizeof returns a constant expression</span></div></pre></td></tr></table></figure></p>
<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p>逗号运算符( comma operator)含有两个运算对象,按照从左向右的顺序依次求值 和逻辑与、逻辑或以及条件运算符一样,逗号运算符也规定了运算对象求值的顺序。 对于逗号运算符来说,首先对左侧的表达式求值,然后将求值结果丢弃掉。逗号运算符真正的结果是右側表达式的值。如果右侧运算对象是左值,那么最终的求值结果也是左值。</p>
<h2 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="其他隐式类型转换"><a href="#其他隐式类型转换" class="headerlink" title="其他隐式类型转换"></a>其他隐式类型转换</h3><p>数组转换为指针：在大多数用到数组的表达式中，数组自动转换为指向数组首元素的指针</p>
<p>指针的转换:C++还规定了几种其他的指针转换方式,包括常量整数值0或者者字面值 nu11ptr能转换成任意指针类型:指向任意非常量的指针能转换成void<em>;指向任意对 象的指针能转换成 const void</em>。</p>
<p>转换为布尔类型：存在一种从算术类型或指针类型向布尔类型自动转换的机制</p>
<p>转换为常量：允许将指向非常量类型的指针转换成为相应常量类型的指针，对于引用也是这样。</p>
<h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p>待整理</p>
<h2 id="运算符优先级表"><a href="#运算符优先级表" class="headerlink" title="运算符优先级表"></a>运算符优先级表</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517752932745.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517752958321.jpg" alt="enter description here"></p>
<hr>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><blockquote>
<p>悬垂else</p>
</blockquote>
<p>当一个if语句嵌套在另一个if语句内部时,很可能if分支会多于else分支。事实上,之前那个成绩转换的程序就有4个if分支,而只有2个else分支。这时候问题 出现了:我们怎么知道某个给定的else是和和哪个if匹配呢? 这个问题通常称作<strong>悬垂else</strong>( dangling else),在那些既有if语句又有if else语句的编程语言中是个普遍存在的问题。不同语言解决该问题的思路也不同,就就C++而言, 它规定else与离它最近的尚未匹配的if匹配,从而消除了程序的的二义性。</p>
<blockquote>
<p>case标签</p>
</blockquote>
<p>case关键字和它对应的值一起被称为case标签( case label)。case标签签必须是整 型常量表达式</p>
<blockquote>
<p>switch内部的变量定义</p>
</blockquote>
<p>如前所述, switch的执行流程有可能会跨过某些case标标签。如果程序跳转到了某个特定的case,则switch结构中该该case标签之前的部分会被忽略掉。这种忽略掉一 部分代码的行为引出了一个有趣的问题:如果被略过的代码中含有变量的定义该怎么办? 答案是:<strong>如果在某处一个带有初值的变量位于作用域之外,在另一处该变量位于作用域之内,则从前一处跳转到后一处的行为是非法行为。</strong></p>
<h2 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h2><h3 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h3><p>C++11新标准引入了一种更简单的for语句,这种语句可以遍历容器或其他序列的 所有元素。范围for语句( range for statement）的语法形式是: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (declaration expression) </div><div class="line">statement</div></pre></td></tr></table></figure>
<p>expression表示的必须是一个序列,比如用花括号括起来的初始值列表、数组或者 vector或string等类型的对象,这些类型的共同特点是拥有能返回迭代器的 begin和end成员。 </p>
<p>declaration定义一个变量,序列中的每个元素都得能转换成该变量的类型。确保类型相容最简单的办法是使用auto类型说明符,这个关键字可以令编译器帮助我们指定合适的类型。</p>
<p>如果需要对序列中的元素执行写操作,循环变量必须声明成引用类型 每次迭代都会重新定义循环控制变量,并将其初始化成序列中的下一个值,之后オ会 执行 statement。像往常一样, statement可以是一条单独的语句也可以是一个块。所有元素 都处理完毕后循环终止。</p>
<h2 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h2><p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。当程序的某部分检测到一个他无法处理的问题的时候，需要用到异常处理。</p>
<p>异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持。在C++语言 中,异常处理包括 </p>
<ul>
<li>throw表达式( throw expression),异常检测部分使用 throw表达式来表示它遇到 了无法处理的问题。我们说 throw引发( raise)了异常。 </li>
<li>ty语句块( try block),异常处理部分使用try语句块处理异常。try语句块以 关键字try开始,并以一个或多个 catch子句( catch clause)结束。try语句块 中代码抛出的异常通常会被某个 catch子句处理。因为 catch子句“处理”异常, 所以它们也被称作异常处理代码( exception handler)。 </li>
<li>套异常类( exception class),用于在 throw表达式和相关的 catch子句之间传 递异常的具体信息。</li>
</ul>
<h3 id="标注异常"><a href="#标注异常" class="headerlink" title="标注异常"></a>标注异常</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_7_1518014704271.jpg" alt="enter description here"></p>
<hr>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>我们通过<strong>调用运算符</strong>( call operator)来执行函数。调用运算符的形式是一对圆括물 它作用于一个表达式,该表达式是函数或者指向函数的指针:圆括号之内是一个用逗号隔 开的实参( argument)列列表,我们用实参初始化函数的形参。调调用表达式的类型就是函数 的返回类型。</p>
<p>函数的调用完成两项工作:一是用实参初始化函数对应的形参,二是将控制权转移给被调 用函数。此时,主调调函数( calling function)的执行被暂时中断,被调函数( called function) 开始执行。</p>
<blockquote>
<p>形参和实参</p>
</blockquote>
<p>实参是形参的初始值。尽管实参和形参存在对应关系，但是并没有规定实参的求值顺序。编译器能以任意可行的顺序对实参求值。</p>
<h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><p>名字有作用域，对象有生命周期（lifetime）：名字的作用域是程序文本的一部分，名字在其中可见；对象的生命周期是程序执行过程中该对象存在的一段时间。</p>
<p>如果局部静态变量没有显式的初始值，它将执行初始化：内置类型的局部静态变量初始化为0</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数的声明不包含函数体，所以也不需要形参的名字，但是加上名字能够让使用者更好地理解函数的功能。</p>
<h3 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h3><p>分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译</p>
<p>编译以后，如果我们修改了其中一个源文件，那么只需要重新编译那个改动的文件即可</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>当形参是引用类型时,我们说它对应的实参被<strong>引用传递</strong>( Dassed by reference )或者函 数被传引用週用( called by reference)。和其他引用一样,引用形参也是它绑定的对象的别 名;也就是说,引用形参是它对应的实参的别名。 </p>
<p>当实参的值被拷贝给形参时,形参和实参是两个相互独立的对象。我们们说这样的实参 被<strong>值传递</strong>( passed by value)或者者函数被传值调用( called by value)</p>
<blockquote>
<p>使用引用避免拷贝</p>
</blockquote>
<p>拷贝大的类类型对象或者容器对象比较低效,甚至有的类类型(包括括1O类型在内) 根本就不支持拷贝操作。当某种类型不支持拷贝操作时,函数只能通过引用形参访问该类 型的对象。</p>
<p>如果函数无需改变引用形参的值，最好将其声明为常量引用</p>
<h3 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h3><p><strong>当形参时const时，其为顶层const，顶层const作用于对象本身。</strong></p>
<p>和其他初始化过程一样,当用实参初始化形参时会忽略掉顶层 const。换句话说,形参的顶层 const被忽略掉了。当形参有顶层 const时,传给它常量对象或者非常量对象都是 可以的:</p>
<h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p>数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响,这两个性质分别 是:<strong>不允许拷贝数组</strong>以及<strong>使用数组时(通常)会将其转换成 指针</strong>。因为不能拷贝数组,所以我们<strong>无法以值传递的方式使用 数组参数</strong>。因为数组会被转换成指针,所以当我们为函数传递一个数组时,实际上传递的 是指向数组首元素的指针。</p>
<p>为了程序的可读性，我们可以把形参写成类似数组的形式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">( <span class="keyword">const</span> *<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">( <span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">( <span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;  <span class="comment">// 这里的维度表示我们期望有多少元素，实际不一定</span></div></pre></td></tr></table></figure></p>
<p>管理指针形参的三种常用技术：</p>
<ul>
<li>使用标记指定数组长度，要求数组本身包含一个结束标记</li>
<li>使用标准库规范，传递指向数组首元素和数组尾元素的指针</li>
<li>显式传递一个表示数组大小的形参</li>
</ul>
<blockquote>
<p>传递多维数组</p>
</blockquote>
<p>和所有数组一样,当将多维数组传递给函数时,真正传递的是指向数组首元素的指针 。因为我们处理的是数组的数组,所以首元素本身就是一个数组, 指针就是一个指向数组的指针。<strong>数组第二维(以及后面所有维度)的大小都是数组类型的 部分,不能省略</strong>:</p>
<h3 id="含有可变形参的参数"><a href="#含有可变形参的参数" class="headerlink" title="含有可变形参的参数"></a>含有可变形参的参数</h3><p>为了编写能处理不同数量实参的函数,C++11新标准提供了两种主要的方法:如如果所 有的实参类型相同,可以传递一个名为initializer_list的标准库类型:如果实参的 类型不同,我们可以编写一种特殊的函数,也就是所谓的可变参数模板,</p>
<blockquote>
<p>initializer_list 形参</p>
</blockquote>
<p>如果函数的实参数量未知但是全部实参的类型都相同,我们可以使用initializer_listt类型的形参。initializer_list是一种标准库类型,用于表示 某种特定类型的值的数组</p>
<blockquote>
<p>省略符形参</p>
</blockquote>
<p>省略符形参是为了便于C++程序访访问某些特殊的C代码而设置的,这些们代码使用了名 为 varargs的C标准库功能。</p>
<p>省略符形参只能出现在形参列表的最后一个位置,它的形式无外乎以下两种: </p>
<ul>
<li>void foo(parm list, …);</li>
<li>void foo(…)</li>
</ul>
<p>第一种形式指定了foo函数的部分形参的类型,对应于这些形参的实参将会执行正常的 类型检査。省略符形参所对应的实参无须类型检査。在第一种形式中,形参声明后面的逗 号是可选的。</p>
<h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h2><blockquote>
<p>不要返回局部对象的引用或指针</p>
</blockquote>
<p>函数完成后,它所占用的存储空间也随之被释放掉。因此, 函数终止意味着局部变量的引用将指向不再有效的内存区域。会引发未定义行为</p>
<blockquote>
<p>引用返回左值</p>
</blockquote>
<p>调用一个返回引用的函数返回左值，返回其他类型得到右值</p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>不允许两个函数除了返回类型外其他所有的要素都相同</p>
<p>一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来</p>
<blockquote>
<p>调用重载函数</p>
</blockquote>
<p>定义了一组重载函数后,我们需要以合理的实参调用它们。<strong>函数匹配</strong>( functionmatching)是指一个过程,在这个过程中我们把函数调用与一组重载函数中的某一个关联起来,函数匹配也叫做<strong>重载确定</strong>( overload resolution)。编编译器首先将调用的实参与重载集合中每一个函数的形参进行比较,然后根据比较的结果决定到底调用哪个函数。</p>
<h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><p>某些函数有这样一种形参,在函数的很多次调用中它们都被赋予一个相同的值,此时,我们把这个反复出现的值称为函数的<strong>默认实参</strong>( default argument)。调调用含有默认实参的函数时,可以包含该实参,也可以省略该实参。</p>
<p>一旦某个形参被赋予了默认值，后面所有的额形参都要赋予默认值。所以当设计含有默认实参的函数时,其中一项任务是合理设置形参的顺序,尽量让不怎么使用默认值的形参出现在前面,而让那些经常使用默认值的形参出现在后面</p>
<p>在给定的作用域中一个形参只能被赋予一次默认实参。换句句话说,函数的后续声明只能为之前那些没有默认值的形参添加默认实参,而且该形参右侧的所有形参必须都有默认值。</p>
<p>局部变量不能作为默认实参。除此之外,只要表达式的类型能转换成形参所需的类型,该表达式就能作为默认实参:</p>
<h3 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h3><p>在大多数机器上,一次次函数调用其实包含着一系列工作:调用前要先保存寄存器,并在返回时恢复;可能需要拷贝实参;程序转向一个新的位置继续执行。</p>
<h4 id="内联函数可以避免函数调用的开销"><a href="#内联函数可以避免函数调用的开销" class="headerlink" title="内联函数可以避免函数调用的开销"></a>内联函数可以避免函数调用的开销</h4><p>将函数定义为内联函数（inline），通常就是把它在每一个调用点上“内联地”展开。函数返回类型前面加上关键字inline，这样就可以将它声明为内联函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="built_in">string</span> &amp; <span class="title">shortString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> s1.size() &lt;= s2.size() ? s1 : s2;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>一般来说,内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数,而而且一个75行的函数也不大可能在调用点内联地展开。</p>
<h4 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h4><p>constexpr函数( constexpr function)是指能用于常量表达式的函数。定义 constexpr函数的方法与其他函数类似,不过要遵循几项约定:函数的返回类型及所有形参的类型都得是字面值类型,而且函数体中必须有且只有一条 return语句:</p>
<p>把內联函数和 constexpr函数放在头文件内和其他函数不一样,内联函数和 constexpr函数可以在程序中多次定义。毕竟,编译器要想展开函数仅有函数声明是不够的,还需要函数的定义。不过,对于某个给定的内联函数或者 constexpr函数来说,它的多个定义必须完全一致。基于这个原因,内联函数和 constexpr函数通常定义在头文件中。</p>
<h3 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h3><p>程序可以包含一些用于调试的代码,但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时,要先屏蔽掉调试代码。这种方法用到两项预处理功能: assert和 NDEBUG</p>
<h4 id="assert-预处理宏"><a href="#assert-预处理宏" class="headerlink" title="assert 预处理宏"></a>assert 预处理宏</h4><p>assert是一种<strong>预处理宏</strong>( preprocessor marco)。所谓预处理宏其实是一个预处理变量,它的行为有点类似于内联函数。 assert宏使用一个表达式作为它的条件:<code>assert(expr)</code> </p>
<p>首先对expr求值,如如果表达式为假(即0), assert输出信息并终止程序的执行。如果表达式为真(即非0), assert什么也不做。</p>
<p>assert宏定义在 assert头文件中。如我们所知,预处理名字由预处理器而非编译器管理,因此我们可以直接使用预处理名字而无须提供uS1ng明。也就是说,我们应该使用 assert而不是std:: assert,也不需要为 assert提供using声明。</p>
<h4 id="NDEBUG-预处理变量"><a href="#NDEBUG-预处理变量" class="headerlink" title="NDEBUG 预处理变量"></a>NDEBUG 预处理变量</h4><p>assert的行为依赖于一个名为 NDEBUG的预处理变量的状态。如果定义了 NDEBUG,则 assert什么也不做。默认状态下没有定义 NDEBUG,此时 assert将执行运行时检查。我们可以使用一个# define语句定义 NDEBUG,从而关闭调试状态。同时,很多编译器都提供了一个命令行选项使我们可以定义预处理变量</p>
<h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><h3 id="确定候选函数和可行函数"><a href="#确定候选函数和可行函数" class="headerlink" title="确定候选函数和可行函数"></a>确定候选函数和可行函数</h3><p>函数匹配的第一步是选定本次调用对应的重载函数集,集合中的函数称为<strong>候选函数</strong>( candidate function)。候选函数具备两个特征:一是与被调用的函数同名,二是其声明在调用点可见。</p>
<p>第二步考察本次调用提供的实参,然后从候选函数中选出能被这组实参调用的函数,这些新选出的函数称为<strong>可行函数数</strong>( viable function)。可行函数也有两个特征:一是其形参数量与本次调用提供的实参数量相等,二是每个实参的类型与对应的形参类型相同,或者能转换成形参的类型。</p>
<blockquote>
<p>寻找最佳匹配</p>
</blockquote>
<p>函数匹配的第三步是从可行函数中选择与本次调用最匹配的函数。实参类型与形参类型越接近，他们匹配得越好。</p>
<blockquote>
<p>含有多个形参的函数匹配</p>
</blockquote>
<p>当实参的数量有两个或更多时,函数匹配就比较复杂了。编译器依次检査每个实参以确定哪个函数是最佳匹配。如如果有且只有个函数满足下列条件,则匹配成功・该该函数每个实参的匹配都不劣于其他可行函数需要的匹配至少有一个实参的匹配优于其他可行函数提供的匹配。如果在检査了所有实参之后没有任何一个函数脱颖而出,则则该调用是错误的。</p>
<h3 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h3><p>为了确定最佳匹配,编译器将实参类型到形参类型的转換划分成儿个等级,具体排序如</p>
<ol>
<li>精确匹配,包括以下情况:实参类型和形参类型相同・实参从数组类型或函数类型转换成对应的指针类型。向实参添加顶层 const或者从实参中删除顶层 const</li>
<li>通过 const转换实现的匹配</li>
<li>通过过类型提升实现的匹配</li>
<li>通过算术类型转换或指针转换实现的匹配。</li>
<li>通过类类型转换实现的匹配配(参见14.9节</li>
</ol>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向的是函数而非对象。和其他指针一样,函数指针指向某种特定类型，函数的类型由它的返回类型和形参类型共同决定,与函数名无关。</p>
<p>想要声明一个可以指向该函数的指针，只需要用指针替换函数名即可</p>
<p>当我们把函数名作为一个值使用时，该函数自动地转换成指针。</p>
<p>此外,我们们还能直接使用指向函数的指针调用该函数,无须提前解引用指针</p>
<blockquote>
<p>函数指针形参</p>
</blockquote>
<p>和数组类似,虽然不能定义函数类型的形参,但是形参可以是指向函数的指针。此时,形参看起来是函数类型,实际上却是当成指针使用:</p>
<blockquote>
<p>返回指向函数的指针</p>
</blockquote>
<p>和数组类似,虽然不能返回一个函数,但是能返回指向函数类型的指针。然而,我们们必须把返回类型写成指针形式,编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样,要想声明一个返回函数指针的函数,最简单的办法是使用类型别名</p>
<hr>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类的基本思想是<strong>数据抽象</strong>( data abstraction)和<strong>封装</strong>( encapsulation)。<strong>数据抽象是二种依赖于接口( interface)和实现( implementation)分离的编程程(以及设计)技术。</strong>类的接口包括用户所能执行的操作;类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。</p>
<p><strong>封装实现了类的接口和实现的分离</strong>。封装后的类隐藏了它的实现细节,也就是说,类的用户只能使用接口而无法访问实现部分。</p>
<h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><h3 id="定义类的基本"><a href="#定义类的基本" class="headerlink" title="定义类的基本"></a>定义类的基本</h3><h4 id="引入-this"><a href="#引入-this" class="headerlink" title="引入 this"></a>引入 this</h4><p>成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时,用请求该函数的对象地址初始化this</p>
<p>对于我们来说,this形参是隐式定义的。实际上,任何自定义名为this的参数或变量的行为都是非法的。我们们可以在成员函数体内部使用this因此尽管没有必要,但我们还是能把isbn定义成如下的形式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; &#125;</div></pre></td></tr></table></figure>
<h4 id="引入const-成员函数"><a href="#引入const-成员函数" class="headerlink" title="引入const 成员函数"></a>引入const 成员函数</h4><p>上面的ibsn函数的另一个关键之处是紧随参数列表之后的 const关键字,这里, const的作用是修改隐式this指针的类型。</p>
<p>默认情况下,<strong>this的类型是指向类类型非常量版本的常量指针</strong>。尽管this是隐式的,但它仍然需要遵循初始化规则,意味着(在默认情况下)我们不能把this绑定到一个常量对象上。</p>
<p>C++语言的做法是允许<strong>把 const关键字放在成员函数的参数列表之后</strong>,此时,紧跟在参数列表后面的 const表示this是一个指向常量的指针。像这样使用 const的成员函数被称作<strong>常量成员函数</strong>( const member function)。</p>
<h4 id="类作用域和成员函数"><a href="#类作用域和成员函数" class="headerlink" title="类作用域和成员函数"></a>类作用域和成员函数</h4><p>编译器分两步处理类:首先编译成员的声明,然后才轮到成员函数体(如果有的话)。因此,成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p>
<h4 id="在类外部定义成员函数"><a href="#在类外部定义成员函数" class="headerlink" title="在类外部定义成员函数"></a>在类外部定义成员函数</h4><p>当我们在类的外部定义成员函数时,成员函数的定义必须与它的声明匹配。也就是说,返回类型、参数列表和函数名都得与类内部的声明保持一致。如果<strong>成员被声明成常量成员函数,那么它的定义也必须在参数列表后明确指定 const属性</strong>。同时,类外部定义的成员的名字必须包含它所属的类名</p>
<h4 id="定义一个返回this对象的函数"><a href="#定义一个返回this对象的函数" class="headerlink" title="定义一个返回this对象的函数"></a>定义一个返回this对象的函数</h4><p>一般来说,当我们定义的函数类似于某个内置运算符时,应该令该函数的行为尽量模仿这个运算符。内置的赋值运算符把它的左側运算对象当成左值返回,因此为了与它保持一致,combine函数必须返回引用类型。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>每个类都分别定义了它的对象被初始化的方式,类通过一个或几个特殊的成员函数来控制其对象的初始化过程,这些函数叫做构造函数( constructor)。<strong>构造函数的任务是初始化类对象的数据成员,无论何时只要类的对象被创建,就会执行构造函数</strong>。</p>
<p>构造函数的名字和类名相同。和其他函数不一样的是,构造函数没有返回类型;除此之外类似于其他的函数,构造函数也有一个(可能为空的)参数列表和一个(可能为空的)函数体。类可以包含多个构造函数,和其他重载函数差不多,不同的构造函数之间必须在参数数量或参数类型上有所区别。</p>
<p>不同于其他成员函数,构造函数不能被声明成 const的</p>
<h4 id="合成的默认构造函数"><a href="#合成的默认构造函数" class="headerlink" title="合成的默认构造函数"></a>合成的默认构造函数</h4><p>我们没有为这些对象提供初始值,因此我们知道它们执行了默认初始化。<strong>类通过一个特殊的构造函数来控制默认初始化过程,这个函数叫做默认构造函数( default constructor）</strong>默认构造函数无须任何实参。</p>
<p>如我们所见,默认构造函数在很多方面都有其特殊性。其中之一是,<strong>如果我们的类没有显式地定义构造函数,那么编译器就会为我们隐式地定义一个默认构造函数</strong>。编译器创建的构造函数又被称为合成的默认构造函数( synthesized defaultconstructor)。对于大多数类来说,这个合成的默认构造函数将按照如下规则初始化类的数据成员:</p>
<ul>
<li>如果存在类内的初始值,用它来初始化成员</li>
<li>否则,默认初始化该成员。</li>
</ul>
<h4 id="某些类不能依赖于合成的默认构造函数"><a href="#某些类不能依赖于合成的默认构造函数" class="headerlink" title="某些类不能依赖于合成的默认构造函数"></a>某些类不能依赖于合成的默认构造函数</h4><p>对于一个普通的类来说,必须定义它自己的默认构造函数,原因有三:</p>
<p>第一个原因也是最容易理解的一个原因就是编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。</p>
<p>第二个原因是对于某些类来说,<strong>合成的默认构造函数可能执行错误的操作</strong>。回忆我们之前介绍过的,如果定义在块中的内置类型或复合类型(比如数组和指针)的对象被默认初始化,则它们的值将是未定义的。该准则则同样适用于默认初始化的内置类型成员。因此,含有内置类型或复合类型成员的类应该在类的内部初始化这些成员,或者定义一个自己的默认构造函数。否则,用户在创建类的对象时就可能得到未定义的值。</p>
<p>第三个原因是有的时候编译器不能为某些类合成默认的构造函数</p>
<h4 id="default的含义"><a href="#default的含义" class="headerlink" title="=default的含义"></a>=default的含义</h4><p>在C++11标准中，如果我们需要默认行为，那么可以通过在参数列表后面写上<code>=default</code>来要求编译器生成构造函数</p>
<h4 id="构造函数的初始值列表"><a href="#构造函数的初始值列表" class="headerlink" title="构造函数的初始值列表"></a>构造函数的初始值列表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>: <span class="built_in">string</span> &amp;s): bookno(s) &#123; &#125; ;</div><div class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>: <span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p):bookno(s), units_sold(n), revenue(p*n) &#123; &#125; ;</div></pre></td></tr></table></figure>
<p>这两个定义中出现了新的部分,即冒号以及冒号和花括号之间的代码,其中花括号定义了函数体。我们把新出现的部分称为<strong>构造函数初始值列表</strong>( constructor initialize list),它负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表,每个名学后面紧跟括号括起来的(或者在花括号内的)成员初始值。不同成员的初始化通过逗号分隔开来</p>
<h3 id="拷贝、赋值和析构"><a href="#拷贝、赋值和析构" class="headerlink" title="拷贝、赋值和析构"></a>拷贝、赋值和析构</h3><h4 id="某些类不能依赖于合成的版本"><a href="#某些类不能依赖于合成的版本" class="headerlink" title="某些类不能依赖于合成的版本"></a>某些类不能依赖于合成的版本</h4><p>尽管编译器能替我们合成拷贝、赋值和销毁的操作,但是必须要清楚的一点是,对于某些类来说合成的版本无法正常工作。特別是,<strong>当类需要分配类对象之外的资源时,合成的版本常常会失效</strong>。</p>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>定义在public说明符之后的成员在整个程序内可被访问,public成员定义类的接口。</p>
<p>定义在 private说明符之后的成员可以被类的成员函数访问,但是不能被使用该类的代码访问, private部分封装了(即隐藏了)类的实现细节。</p>
<blockquote>
<p>使用class 和struct关键字</p>
</blockquote>
<p>我们可以使用class和struct这两个关键字中的任何一个定义类。唯一的一点区别是, struct和class的默认访问权限不太一样。类可以在它的第一个访问说明符之前定义成员,对这种成员的访问权限依赖于类定义。<strong>如果我们使用 struct关键字,则定义在第一个访问说明符之前的成员是public的</strong>;相反,如果<strong>我们使用class关键字,则这些成员是private的</strong>。</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类可以允许其他类或者函数访问它的非公有成员,方法是令其他类或者函数成为它的友元( friend)。如果类想把一个函数作为它的友元,只需要增加一条以friend关键字开始的函数声明语句即可:</p>
<p>友元的声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类成员也不受它所在区域访问控制级别的约束</p>
<blockquote>
<p>封装有两个重要的优点<br>确保用户代码不会无意间破坏封装对象的状态。<br>被封装的类的具体实现细节可以随时改变,而无须调整用户级别的代码。</p>
</blockquote>
<p>友元的声明仅仅指定了访问的权限,而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数,那么我们就必须在友元声明之外再专门对函数进行一次声明</p>
<h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><h3 id="类成员再探"><a href="#类成员再探" class="headerlink" title="类成员再探"></a>类成员再探</h3><p>除了定义数据和函数成员之外,类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制,可以是public或者private中的一种</p>
<blockquote>
<p>令成员函数作为内联函数</p>
</blockquote>
<p>在类中,常有一些规模较小的函数适合于被声明成内联函数。如我们之前所见的,定义在类内部的成员函数是自动inline的。</p>
<p>我们可以在类的内部把inline作为声明的一部分显式地声明成员函数,同样的,也能在类的外部用inline关键字修饰函数的定义</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_13_1518491517567.jpg" alt="enter description here"></p>
<blockquote>
<p>可变数据成员</p>
</blockquote>
<p>有时(但并不频繁)会发生这样一种情况,我们希望能<strong>修改类的某个数据成员</strong>,即使是在一个 const成员函数内。可以通过在变量的声明中加入 mutable关键字做到这点</p>
<p>一个<strong>可変数据成员</strong>( mutable data member)永远不会是 const,即使它是 const对象的成员。因此,一个 const成员函数可以改变一个可变成员的值。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_13_1518491662122.jpg" alt="enter description here"></p>
<h3 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回*this的成员函数</h3><p>返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本</p>
<blockquote>
<p>基于const的重载</p>
</blockquote>
<p>通过区分成员函数是否是 const的,我们可以对其进行重载,其原因与我们之前根据指针参数是否指向 const而重载函数的原因差不多。具体说</p>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>每个类定义了唯一的类型。对于两个类来说,即使它们的成员完全一样,这两个类也是两个不同的类型。</p>
<blockquote>
<p>类的声明</p>
</blockquote>
<p>就像可以把函数的声明和定义分离开来一样,我们也能仅仅声明类而暂时不定义它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Screen;   // screen类的声明</div></pre></td></tr></table></figure></p>
<p>这种声明有时被称作<strong>前向声明</strong>( forward declaration),它向程序中引入了名字 Screen并且指明 Screen是一种类类型。对于类型 Screen来说,在它声明之后定义之前是一个不完全类型( incomplete type),也就是说,此时我们已知 Screen是一个类型,但是不清楚它到底包含哪些成员。</p>
<p>不完全类型只能在非常有限的情景下使用:可以定义指向这种类型的指针或引用,也可以声明(但是不能定义)以不完全类型作为参数或者返回类型的函数。</p>
<h3 id="友元再探"><a href="#友元再探" class="headerlink" title="友元再探"></a>友元再探</h3><p>类还可以把其他的类定义成友元,也可以把其他类(之前已定义过的)的成员函数定义成友元。此外,友元函数能定义在类的内部,这样的函数是隐式内联的。</p>
<p>如果一个类定义了友元类，则友元类的成员函数可以访问此类包括非公有函数在内的所有成员。</p>
<p><strong>友元不具备传递性</strong></p>
<blockquote>
<p>令成员函数作为友元</p>
</blockquote>
<p>除了令整个Window mgr作为友元之外, Screen还可以只为clear提供访问权限。当把一个成员函数声明成友元时,我们必须明确指出该成员函数属于哪个类:</p>
<blockquote>
<p>函数重载和友元</p>
</blockquote>
<p>尽管重载函数的名字相同,但它们仍然是不同的函数。因此,如果一个类想把一组重载函数声明成它的友元,它需要对这组函数中的每一个分别声明:</p>
<blockquote>
<p>友元声明和作用域</p>
</blockquote>
<p>类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在个友元声明中时,我们隐式地假定该名字在当前作用域中是可见的。</p>
<h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><p>每个类都会定义它自己的作用域。<strong>在类的作用域之外,普通的数据和函数成员只能由对象、引用用或者指针使用成员访问运算符来访问</strong>。对于类类型成员则使用作用域运算符访问。不论哪种情况,跟在运算符之后的名字都必须是对应类的成员</p>
<blockquote>
<p>作用域和定义在类外部的成员</p>
</blockquote>
<p>在类的外部,成员的名字被隐藏起来了。一旦遇到了类名,定义的剩余部分就在类的作用域之内了,这里的剩余部分包括参数列表和函数体。结果就是,我们可以直接使用类的其他成员而无须再次授权了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518603468039.jpg" alt="enter description here"></p>
<p>另一方面,函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时,返回类型中使用的名字都位于类的作用域之外。这时,返回类型必须指明它是哪个类的成员。</p>
<h3 id="名字查找和类的作用域"><a href="#名字查找和类的作用域" class="headerlink" title="名字查找和类的作用域"></a>名字查找和类的作用域</h3><p><strong>名字查找( name lookup)</strong>(寻找与所用名字最匹配的声明的过程)的过程比较直截了当:</p>
<ul>
<li>首先,在名字所在的块中寻找其声明语句,只考虑在名字的使用之前出现的声明。</li>
<li>如果没找到,继续查找外层作用域。</li>
<li>如果最终没有找到匹配的声明,则程序报错。</li>
</ul>
<p>一般来说,内层作用域可以重新定义外层作用域中的名字,即使该名字已经在内层作用域中使用过。然而在类中,如果成员使用了外层作用域中的某个名字,而该名字代表种类型,则类不能在之后重新定义该名字:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518603659447.jpg" alt="enter description here"></p>
<h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><blockquote>
<p>构造函数的初始值有时必不可少</p>
</blockquote>
<p>有时我们可以忽略数据成员初始化和赋值之间的差异,但并非总能这样。<strong>如果成员是const或者是引用的话,必须将其初始化</strong>。类似的,当成员属于某种类类型且该类没有定义默认构造函数时,也必须将这个成员初始化。</p>
<p>一些数据成员必须初始化，建议养成使用构造函数初始化值的习惯</p>
<blockquote>
<p>成员初始化的顺序</p>
</blockquote>
<p>构造函数初始值列表只说明用于初始化成员的值,而不限定初始化的具体执行顺序。</p>
<p><strong>成员的初始化顺序与它们在类定义中的出现顺序一致</strong>:第一个成员先被初始化,然后第二个,以此类推。<strong>构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序</strong>。</p>
<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>C++11新标准扩展了构造函数初始值的功能,使得我们可以定义所谓的<strong>委托构造函数</strong>( delegating constructor)。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程,或者说它把它自自己的一些(或者全部)职责委托给了其他构造函数。</p>
<p>和其他构造函数一样,一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数内,成员初始值列表只有一个唯一的入口,就是类名本身。和其他成员初始值一样,类名后面紧跟圆括号括起来的参数列表,参数列表必须与类中另外一个构造函数匹配。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518610183005.jpg" alt="enter description here"></p>
<h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><p>我们能为类定义隐式转换规则。如果<strong>构造函数只接受一个实参,则它实际上定义了转换为此类类型的隐式转换机制</strong>,有时我们]把这种构造函数称作<strong>转换构造函数</strong></p>
<blockquote>
<p>抑制构造函数定义的隐式转换</p>
</blockquote>
<p>在要求隐式转换的程序上下文中,我们们可以通过将构造函数声明为explicit加以阻止:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518610514067.jpg" alt="enter description here"></p>
<h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p>聚合类( aggregate class)使得用户可以直接访问其成员,并且具有特殊的初始化语法形式。当一个类满足如下条件时,我们说它是聚合的:</p>
<ul>
<li>所有成员都是public的</li>
<li>没有定义任何构造函数。</li>
<li>没有类内初始值</li>
<li>没有基类,也没有 virtual函数,关于这部分知识我们将在第15章详细介绍</li>
</ul>
<h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><p><strong>数据成员都是字面值类型的聚合类</strong>是字面值常量类。如果一个类不是聚合类,但它符合下述要求,则它也是一个字面值常量类</p>
<ul>
<li>数据成员都必须是字面值类型。</li>
<li>类必须至少含有一个 constexpr构造造函数。</li>
<li>如果一个数据成员含有类内初始值,则内置类型成员的初始值必须是一条常量表达式;或者如果成员属于某种类类型,则初始值必须使用成员自己的 constexpr构造函数</li>
<li>类必须使用析构函数的默认定义,该成员负责销毀类的对象</li>
</ul>
<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。</p>
<blockquote>
<p>声明静态成员</p>
</blockquote>
<p>我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员样,静态成员可以是 public的或 private的。静态数据成员的类型可以是常量、引用、指针、类型等</p>
<p>我们使用作用域运算符直接访问静态成员：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> r;</div><div class="line">r = Account::rate();</div></pre></td></tr></table></figure></p>
<blockquote>
<p>定义静态成员</p>
</blockquote>
<p>和其他的成员函数一样,我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时,不能重复 static关键字,该关键字只出现在类内部的声明语句:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Account::rate( <span class="keyword">double</span> newRate)</div><div class="line">&#123;</div><div class="line">	interesRate = newRate;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>我们不能在类的内部初始化静态成员。相反的,必须在类的外部定义和初始化每个静态成员。</p>
<blockquote>
<p>静态成员的类内初始化</p>
</blockquote>
<p>通常情况下・类的静态成员不应该在类的内部初始化。然而,我们可以为静态成员提供 const整数类型的类内初始值,不过要求静态成员必须是字面值常量类型的constexpr</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nginx 配置反向代理]]></title>
      <url>/2018/02/14/Nginx-%E9%85%8D%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<p>近段时间遇到一个问题：有多个服务要放在一个主机上，但是想用域名来区分这些服务而不是端口号（就像IP地址一样，没有人愿意记端口号）。后面找到了Nginx配置反向代理这个解决方案，这里总结一下。</p>
<a id="more"></a>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>一个Web应用的基本通信流程是：客户端（client）发送一个请求（request）给服务器（server），然后服务器根据请求返回相应的响应（response）给客户端。</p>
<p>那么代理的作用就是让一个机器来替我们发送请求或者返回响应，在客户端替我们发送请求的代理称为正向代理；在服务器替我们接受请求返回响应的代理称为反向代理。</p>
<p>正向代理：client —(send request)—&gt; clinet proxy –(send request)—&gt; server<br>反向代理：clinet –(send request)–&gt; server proxy –(send request)–&gt;other server</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518583313864.jpg" alt="正向代理和反向代理示意图"></p>
<h2 id="Nginx-配置反向代理"><a href="#Nginx-配置反向代理" class="headerlink" title="Nginx 配置反向代理"></a>Nginx 配置反向代理</h2><p>使用Nginx配置反向代理需要用到的配置模块有http模块、server模块、location模块、upstream模块</p>
<h3 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h3><p>http模块负责<strong>HTTP服务器相关属性的配置</strong>，它里面有server和upstream子模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">	# include用来设定文件的mime类型,类型在配置文件目录下的mime.type文件定义，来告诉nginx来识别文件类型。</div><div class="line">    include mime.types;</div><div class="line">    </div><div class="line">	# default_type 设定了默认的类型为二进制流，也就是当文件类型未定义时使用这种方式</div><div class="line">	default_type application/octet-stream;</div><div class="line">	</div><div class="line">	# log_format 用于设置日志的格式，和记录哪些参数</div><div class="line">    log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</div><div class="line">                    &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</div><div class="line">                    &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</div><div class="line">					</div><div class="line">	# 纪录每次的访问日志的文件地址，后面的main是日志的格式样式，对应于log_format的main。</div><div class="line">    access_log /usr/local/var/log/nginx/access.log  main;</div><div class="line">	</div><div class="line">	# sendfile开启高效文件传输模式。将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞。</div><div class="line">    sendfile on;</div><div class="line">    tcp_nopush on;</div><div class="line">    tcp_nodelay on;</div><div class="line">	</div><div class="line">	# keepalive设置客户端连接保持活动的超时时间。在超过这个时间之后，服务器会关闭该连接。</div><div class="line">    keepalive_timeout 10;</div><div class="line">    #gzip on;</div><div class="line">    upstream myproject &#123;</div><div class="line">        .....</div><div class="line">    &#125;</div><div class="line">    server &#123;</div><div class="line">        ....</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="server模块"><a href="#server模块" class="headerlink" title="server模块"></a>server模块</h3><p>为http模块的子模块，定义一个虚拟主机。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">	# listen 指定虚拟主机监听的服务端口</div><div class="line">    listen 8080;</div><div class="line">	</div><div class="line">	# server_name 用来指定IP地址或者域名，多个域名之间用空格分开</div><div class="line">    server_name localhost 192.168.12.10 www.yangyi.com;</div><div class="line">    </div><div class="line">	# 全局定义，如果都是这一个目录，这样定义最简单。</div><div class="line">    # root 表示在这整个server虚拟主机内，全部的root web根目录。</div><div class="line">	root   /Users/yangyi/www;</div><div class="line">	# index 全局定义访问的默认首页地址。</div><div class="line">    index  index.php index.html index.htm; </div><div class="line">	# charset 用于设置网页的默认编码格式。</div><div class="line">    charset utf-8;</div><div class="line">	# access_log 用来指定此虚拟主机的访问日志存放路径，最后的main用于指定访问日志的输出格式。</div><div class="line">    access_log  usr/local/var/log/host.access.log  main;</div><div class="line">    error_log  usr/local/var/log/host.error.log  error;</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="upstream模块"><a href="#upstream模块" class="headerlink" title="upstream模块"></a>upstream模块</h3><p>负责负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">upstream iyangyi.com&#123;</div><div class="line">    ip_hash;</div><div class="line">    server 192.168.12.1:80;</div><div class="line">    server 192.168.12.2:80 down;</div><div class="line">    server 192.168.12.3:8080  max_fails=3  fail_timeout=20s;</div><div class="line">    server 192.168.12.4:8080;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>通过upstream指令指定了一个负载均衡器的名称iyangyi.com。这个名称可以任意指定，在后面需要的地方直接调用即可。</li>
<li>ip_hash这是其中的一种负载均衡调度算法，下面会着重介绍。</li>
<li>紧接着就是各种服务器了。用server关键字表识，后面接ip。</li>
</ul>
<p>Nginx负载均衡模块支持的4种调度算法：</p>
<ul>
<li><strong>weight 轮询</strong>（默认）。每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。weight。指定轮询权值，weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。</li>
<li><strong>ip_hash</strong>。每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。</li>
<li><strong>fair（第三方）</strong>。比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。</li>
<li><strong>url_hash（第三方）</strong>。按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx的hash软件包。</li>
</ul>
<h3 id="location模块"><a href="#location模块" class="headerlink" title="location模块"></a>location模块</h3><p>location模块使用来定位URL、解析URL的，指明定位到的URL的功能是什么。提供了强大的正则匹配功能，也支持条件判断匹配，用户可以通过location指令实现Nginx对动、静态网页进行过滤处理。</p>
<p>最简单的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    root   /Users/yangyi/www;</div><div class="line">    index  index.php index.html index.htm;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>location / 表示匹配根目录</li>
<li>root 指令用于指定访问根目录时，虚拟主机的web目录</li>
<li>index 用于设定我们只输入域名后访问的默认首页地址</li>
</ul>
<p>当我们需要进行反向代理的时候，主要配置也是在这里的，其使用的是location模块下的proxy_pass选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">	proxy_pass          https://gist.github.com;</div><div class="line">	proxy_cache_valid   200 302 1h;</div><div class="line">	proxy_cache_valid   404 1m;</div><div class="line">	proxy_cache_use_stale error timeout invalid_header updating</div><div class="line">		http_500 http_502 http_503 http_504;</div><div class="line">	proxy_set_header    Accept-Encoding &quot;&quot;;</div><div class="line">	proxy_set_header    Accept-Language &quot;zh-CN&quot;;</div><div class="line">	proxy_set_header    User-Agent $http_user_agent;</div><div class="line">	sub_filter  https://gist-assets.github.com/ http://gist.example.com;</div><div class="line">	sub_filter  https://gist.github.com/ http://gist.example.com;</div><div class="line">	sub_filter_once     off;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>proxy_pass 指定反向代理的地址</li>
<li>proxy_set_header 设置 HTTP 请求头，Accept-Encoding “” 表示拒绝任何压缩，这保证了服务器返回给反向代理的内容是未经压缩的，以便进行 URL 替换</li>
<li>proxy_set_header 设置 HTTP 请求头，语言设置</li>
<li>proxy_set_header 设置 HTTP 请求头，设置 UA</li>
<li>sub_filter URL 替换</li>
<li>sub_filter_once 被关闭，替换所有可替换的内容</li>
</ul>
<h2 id="反向代理作用"><a href="#反向代理作用" class="headerlink" title="反向代理作用"></a>反向代理作用</h2><ul>
<li>保护了真实的web服务器，web服务器对外不可见，外网只能看到反向代理服务器，而反向代理服务器上并没有真实数据，因此，保证了web服务器的资源安全</li>
<li>负载均衡，最大化服务器集群的效率</li>
<li>请求的统一控制，包括设置权限、过滤规则等；</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>配置本地主机<code>gist.example.com</code>到github的<code>gist.github.com</code>的server模块配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen  80;</div><div class="line">    server_name gist.example.com;</div><div class="line">    access_log  off;</div><div class="line">    resolver    8.8.8.8;</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass          https://gist.github.com;</div><div class="line">        proxy_cache_valid   200 302 1h;</div><div class="line">        proxy_cache_valid   404 1m;</div><div class="line">        proxy_cache_use_stale error timeout invalid_header updating</div><div class="line">            http_500 http_502 http_503 http_504;</div><div class="line">        proxy_set_header    Accept-Encoding &quot;&quot;;</div><div class="line">        proxy_set_header    Accept-Language &quot;zh-CN&quot;;</div><div class="line">        proxy_set_header    User-Agent $http_user_agent;</div><div class="line">        sub_filter  https://gist-assets.github.com/ http://gist.example.com;</div><div class="line">        sub_filter  https://gist.github.com/ http://gist.example.com;</div><div class="line">        sub_filter_once     off;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>井号开头的行是注释</li>
<li>server 开始了 server 块</li>
<li>listen 表明 Nginx 将会在 80 端口监听</li>
<li>server_name 是我们给反向代理配置的域名，访问这个域名就相当于访问 Gist</li>
<li>access_log 是日志文件的配置，这里为了简化我将它关掉了</li>
<li>resolver 是 DNS 服务器</li>
<li>location 块具体配置反向代理的行为</li>
<li>proxy_pass 说明将会将请求转发至 Gist</li>
<li>proxy_cache_valid 配置缓存</li>
<li>proxy_cache_valid 同上</li>
<li>proxy_cache_use_stale 同上</li>
<li>proxy_set_header 设置 HTTP 请求头，Accept-Encoding “” 表示拒绝任何压缩，这保证了服务器返回给反向代理的内容是未经压缩的，以便进行 URL 替换</li>
<li>proxy_set_header 设置 HTTP 请求头，语言设置</li>
<li>proxy_set_header 设置 HTTP 请求头，设置 UA</li>
<li>sub_filter URL 替换</li>
<li>sub_filter 同上</li>
<li>sub_filter_once 被关闭，替换所有可替换的内容</li>
</ul>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://liam0205.me/2015/09/07/reverse-proxy-to-get-access-to-gist/" target="_blank" rel="external">https://liam0205.me/2015/09/07/reverse-proxy-to-get-access-to-gist/</a></li>
<li><a href="https://www.jianshu.com/p/bed000e1830b" target="_blank" rel="external">https://www.jianshu.com/p/bed000e1830b</a></li>
<li><a href="http://blog.csdn.net/physicsdandan/article/details/45667357" target="_blank" rel="external">http://blog.csdn.net/physicsdandan/article/details/45667357</a></li>
<li><a href="https://paste.ubuntu.com/p/jZ8tBwGYcM/" target="_blank" rel="external">nginx配置整理（含注释）</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《C++ Primer》 笔记目录]]></title>
      <url>/2018/02/13/%E3%80%8AC-Primer%E3%80%8B-%E7%AC%94%E8%AE%B0%E7%9B%AE%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>《C++ Primer》 笔记目录</p>
<a id="more"></a>
<p>第一部分 <a href="/2018/02/15/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-C-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/">C++ 基础</a></p>
<p>第二部分 <a href="/2018/03/04/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-C-%E6%A0%87%E5%87%86%E5%BA%93%E9%83%A8%E5%88%86/">C++ 标准库</a></p>
<p>第三部分 <a href="/2018/03/11/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7%E9%83%A8%E5%88%86/">类设计者的工具</a></p>
<p>第四部分 <a href="/2018/03/18/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98%E9%83%A8%E5%88%86/">高级主题</a></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Git 内部原理]]></title>
      <url>/2018/02/11/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>《Pro Git》读书笔记</p>
<a id="more"></a>
<p>从根本上来讲 Git 是一个内容寻址（content-addressable）文件系统</p>
<h2 id="底层命令和高层命令"><a href="#底层命令和高层命令" class="headerlink" title="底层命令和高层命令"></a>底层命令和高层命令</h2><p>由于 Git 最初是一套面向版本控制系统的工具集，而不是一个完整的、用户友好的版本控制系统，所以它还包含了一部分用于完成底层工作的命令。这些命令被设计成能以 UNIX 命令行的风格连接在一起，抑或藉由脚本调用，来完成工作。这部分命令一般被称作“<strong>底层（plumbing）”命令</strong>，而那些更友好的命令则被称作“高层（porcelain）”命令。</p>
<p>当在一个新目录或已有目录执行 git init 时，Git 会创建一个 .git 目录。这个目录包含了几乎所有 Git 存储和操作的对象。如若想备份或复制一个版本库，只需把这个目录拷贝至另一处即可。</p>
<p>目录结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ ls -F1</div><div class="line">index				# 保存暂存区信息</div><div class="line">HEAD				# 指示目前被检出的分支</div><div class="line">config*				# 包含项目特有的配置项</div><div class="line">description			# 仅供GitWeb使用</div><div class="line">hooks/				# 包含hook钩子脚本</div><div class="line">info/				# 包含全局性排除（global exclude）文件</div><div class="line">objects/			# 存储所有的数据内容</div><div class="line">refs/				# 存储指向数据（分支）的提交对象的指针</div></pre></td></tr></table></figure></p>
<h2 id="Git-对象"><a href="#Git-对象" class="headerlink" title="Git 对象"></a>Git 对象</h2><p>Git 是一个内容寻址文件系统。Git 的核心部分是一个简单的键值对数据库（key-value data store）。你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。</p>
<h3 id="树对象"><a href="#树对象" class="headerlink" title="树对象"></a>树对象</h3><p>树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起。Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。所有内容均以树对象和数据对象的形式存储，其中<strong>树对象对应了 UNIX 中的目录项</strong>，<strong>数据对象则大致上对应了 inodes 或文件内容</strong>。一个树对象包含了一条或多条树对象记录（tree entry），<strong>每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息</strong>。</p>
<p>通常，Git 根据某一时刻暂存区（即 index 区域，下同）所表示的状态创建并记录一个对应的树对象，如此重复便可依次记录（某个时间段内）一系列的树对象。因此，为创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。</p>
<h3 id="提交对象"><a href="#提交对象" class="headerlink" title="提交对象"></a>提交对象</h3><p>提交对象的格式很简单：它先指定一个顶层树对象，代表当前项目快照；然后是作者/提交者信息（依据你的user.name 和 user.email 配置来设定，外加一个时间戳）；留空一行，最后是提交注释</p>
<p>每次我们运行 git add 和 git commit 命令时， Git 所做的实质工作——<strong>将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。</strong>这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 .git/objects 目录下。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_11_1518354037927.jpg" alt="enter description here"></p>
<h3 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h3><p>在存储内容时，会有个头部信息一并被保存。让我们略花些时间来看看 Git 是如何存储其对象的。</p>
<p>所有的 Git 对象均以这种方式存储，区别仅在于类型标识——另两种对象类型的头部信息以字符串“commit”或“tree”开头，而不是“blob”。另外，虽然数据对象的内容几乎可以是任何东西，但提交对象和树对象的内容却有各自固定的格式。</p>
<h2 id="Git-引用"><a href="#Git-引用" class="headerlink" title="Git 引用"></a>Git 引用</h2><p>为了能遍历那段历史从而找到所有相关对象，你仍须记住 1a410e 是最后一个提交。我们需要一个文件来保存 SHA-1 值，并<strong>给文件起一个简单的名字，然后用这个名字指针来替代原始的 SHA-1 值</strong>。在 Git 里，这样的文件被称为“引用（references，或缩写为 refs）”；你可以在 .git/refs 目录下找到这类含有 SHA-1 值的文件。</p>
<p> <strong>Git 分支的本质：一个指向某一系列提交之首的指针或引用</strong>。</p>
<h3 id="HEAD引用"><a href="#HEAD引用" class="headerlink" title="HEAD引用"></a>HEAD引用</h3><p> HEAD 文件是一个符号引用（symbolic reference），指向目前所在的分支。所谓符号引用，意味着它并不像普通引用那样包含一个 SHA-1 值——它是一个<strong>指向其他引用的指针</strong>。</p>
<p>当我们执行 git commit 时，该命令会创建一个提交对象，并用 HEAD 文件中那个引用所指向的 SHA-1 值设置其父提交字段</p>
<h3 id="标签引用"><a href="#标签引用" class="headerlink" title="标签引用"></a>标签引用</h3><p>前文我们刚讨论过 Git 的三种主要对象类型，事实上还有第四种。标签对象（tag object）非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。主要的区别在于，<strong>标签对象通常指向一个提交对象，而不是一个树对象</strong>。它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。</p>
<p>存在两种类型的标签：附注标签和轻量标签。轻量标签的全部内容——一个固定的引用。一个附注标签则更复杂一些。若要创建一个附注标签，Git 会创建一个标签对象，并记录一个引用来指向该标签对象，而不是直接指向提交对象。</p>
<h3 id="远程引用"><a href="#远程引用" class="headerlink" title="远程引用"></a>远程引用</h3><p>第三种引用类型是远程引用（remote reference）。如果你添加了一个远程版本库并对其执行过推送操作，Git 会记录下最近一次推送操作时每一个分支所对应的值，并保存在 refs/remotes 目录下</p>
<p>远程引用和分支（位于 refs/heads 目录下的引用）之间最主要的区别在于，远程引用是只读的。虽然可以git checkout 到某个远程引用，但是 Git 并不会将 HEAD 引用指向该远程引用。</p>
<h2 id="包文件"><a href="#包文件" class="headerlink" title="包文件"></a>包文件</h2><p>Git 最初向磁盘中存储对象时所使用的格式被称为<strong>“松散（loose）”对象格式</strong>。但是，Git 会时不时地<strong>将多个这些对象打包成一个称为“包文件（packfile）</strong>”的二进制文件，以节省空间和提高效率。当版本库中有太多的松散对象，或者你手动执行 git gc 命令，或者你向远程服务器执行推送时，Git 都会这样做。</p>
<p>包文件包含了刚才从文件系统中移除的所有对象的内容。索引文件包含了包文件的偏移信息，我们通过索引文件就可以快速定位任意一个指定对象。</p>
<p>同样有趣的地方在于，最新版本完整保存了文件内容，而原始的版本反而是以差异方式保存的——这是因为大部分情况下需要快速访问文件的最新版本。</p>
<h2 id="引用规格"><a href="#引用规格" class="headerlink" title="引用规格"></a>引用规格</h2><p>我们已经使用过一些诸如远程分支到本地引用的简单映射方式，但这种映射可以更复杂。</p>
<p>添加一个远程版本库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[remote &quot;origin&quot;]</div><div class="line">url = https://github.com/schacon/simplegit-progit</div><div class="line">fetch = +refs/heads/*:refs/remotes/origin/*</div></pre></td></tr></table></figure></p>
<p>引用规格的格式由一个可选的 + 号和紧随其后的 \<src>:\<dst> 组成，其中 \<src> 是一个模式（pattern），代表远程版本库中的引用；\<dst> 是那些远程引用在本地所对应的位置。+ 号告诉 Git 即使在不能快进的情况下也要（强制）更新引用</dst></src></dst></src></p>
<h3 id="引用规格推送"><a href="#引用规格推送" class="headerlink" title="引用规格推送"></a>引用规格推送</h3><p>如果 QA 团队想把他们的 master 分支推送到远程服务器的 qa/master 分支上，可以运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin master:refs/heads/qa/master</div></pre></td></tr></table></figure></p>
<p>如果他们希望 Git 每次运行 git push origin 时都像上面这样推送，可以在他们的配置文件中添加一条 push值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[remote &quot;origin&quot;]</div><div class="line">url = https://github.com/schacon/simplegit-progit</div><div class="line">fetch = +refs/heads/*:refs/remotes/origin/*</div><div class="line">push = refs/heads/master:refs/heads/qa/master</div></pre></td></tr></table></figure></p>
<h3 id="删除引用"><a href="#删除引用" class="headerlink" title="删除引用"></a>删除引用</h3><p>你还可以借助类似下面的命令通过引用规格从远程服务器上删除引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin :topic</div></pre></td></tr></table></figure></p>
<p>因为引用规格（的格式）是 \<src>:\<dst>，所以上述命令把 \<src> 留空，意味着把远程版本库的 topic 分支<br>定义为空值，也就是删除它。</src></dst></src></p>
<h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h2><p>Git 可以通过两种主要的方式在版本库之间传输数据：“哑（dumb）”协议和“智能（smart）”协议。</p>
<h3 id="哑协议"><a href="#哑协议" class="headerlink" title="哑协议"></a>哑协议</h3><p>如果你正在架设一个基于 HTTP 协议的只读版本库，一般而言这种情况下使用的就是哑协议。</p>
<h3 id="智能协议"><a href="#智能协议" class="headerlink" title="智能协议"></a>智能协议</h3><p>智能协议是更常用的传送数据的方法，但它需要在服务端运行一个进程，而这也是 Git 的智能之处——它可以读取本地数据，理解客户端有什么和需要什么，并为它生成合适的包文件。总共有两组进程用于传输数据，它们分别负责上传和下载数据。</p>
<h2 id="维护与数据恢复"><a href="#维护与数据恢复" class="headerlink" title="维护与数据恢复"></a>维护与数据恢复</h2><h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><p>Git 会不定时地自动运行一个叫做 “auto gc” 的命令。大多数时候，这个命令并不会产生效果。然而，如果有太多松散对象（不在包文件中的对象）或者太多包文件，Git 会运行一个完整的 git gc 命令。“gc” 代表垃圾回收，这个命令会做以下事情：收集所有松散对象并将它们放置到包文件中，将多个包文件合并为一个大的包文件，移除与任何提交都不相关的陈旧对象。</p>
<h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>在你使用 Git 的时候，你可能会意外丢失一次提交。通常这是因为你强制删除了正在工作的分支，但是最后却发现你还需要这个分支；亦或者硬重置了一个分支，放弃了你想要的提交。如果这些事情已经发生，该如何找回你的提交呢？</p>
<p>最方便，也是最常用的方法，是使用一个名叫 <code>git reflog</code> 的工具。当你正在工作时，Git 会默默地记录每一次你改变 HEAD 时它的值。每一次你提交或改变分支，引用日志都会被更新。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自定义 Git]]></title>
      <url>/2018/02/10/%E8%87%AA%E5%AE%9A%E4%B9%89-Git/</url>
      <content type="html"><![CDATA[<p>《Pro Git》读书笔记</p>
<a id="more"></a>
<h2 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h2><p>Git使用一系列配置来保存你自定义的行为：</p>
<ul>
<li>它首先会查找 /etc/gitconfig 文件，该文件含有系统里每位用户及他们所拥有的仓库的配置值。如果你传递 –system 选项给 git config，它就会读写该文件</li>
<li>接下来 Git 会查找每个用户的 ~/.gitconfig 文件（或者 ~/.config/git/config 文件）。你可以传递–global 选项让 Git 读写该文件。</li>
<li>最后 Git 会查找你正在操作的版本库所对应的 Git 目录下的配置文件（.git/config）。这个文件中的值只对该版本库有效。</li>
</ul>
<p>以上三个层次中每层的配置（系统、全局、本地）都会覆盖掉上一层次的配置，所以 .git/config 中的值会覆盖掉 /etc/gitconfig 中所对应的值。</p>
<h3 id="客户端基本配置"><a href="#客户端基本配置" class="headerlink" title="客户端基本配置"></a>客户端基本配置</h3><ul>
<li>core.editor</li>
</ul>
<p>默认情况下，Git 会调用环境变量（$VISUAL 或 $EDITOR）设置的任意文本编辑器，如果没有设置，会调用 vi来创建和编辑你的提交以及标签信息。你可以使用 core.editor 选项来修改默认的编辑器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global core.editor emacs</div></pre></td></tr></table></figure></p>
<ul>
<li>commit.tmplate</li>
</ul>
<p>如果把此项指定为你的系统上某个文件的路径，当你提交的时候， Git 会使用该文件的内容作为提交的默认信息。</p>
<ul>
<li>core.pager</li>
</ul>
<p>该配置项指定 Git 运行诸如 log 和 diff 等命令所使用的分页器。你可以把它设置成用 more 或者任何你喜欢的分页器（默认用的是 less），当然也可以设置成空字符串，关闭该选项</p>
<ul>
<li>user.signingkey</li>
</ul>
<p>如果你要创建经签署的含附注的标签（正如 签署工作 所述），那么把你的 GPG 签署密钥设置为配置项会更好。</p>
<ul>
<li>core.excludesfile</li>
</ul>
<p>正如 忽略文件 所述，你可以在你的项目的 .gitignore 文件里面规定无需纳入 Git 管理的文件的模板，这样它们既不会出现在未跟踪列表，也不会在你运行 git add 后被暂存。不过有些时候，你想要在你所有的版本库中忽略掉某一类文件。</p>
<ul>
<li>help.autocorrect</li>
</ul>
<p>Git 会尝试猜测你的意图，但是它不会越俎代庖。如果你把 help.autocorrect 设置成 1，那么只要有一个命令被模糊匹配到了，Git 会自动运行该命令。</p>
<blockquote>
<p>Git 中的着色</p>
</blockquote>
<p>Git 充分支持对终端内容着色，对你凭肉眼简单、快速分析命令输出有很大帮助。你可以设置许多的相关选项来满足自己的偏好。</p>
<ul>
<li>color.ui </li>
</ul>
<p>Git 会自动着色大部分输出内容，但如果你不喜欢花花绿绿，也可以关掉。这个设置的默认值是 auto。</p>
<ul>
<li>color.*</li>
</ul>
<p>要想具体到哪些命令输出需要被着色以及怎样着色，你需要用到和具体命令有关的颜色配置选项。它们都能被置为 true、false 或 always：</p>
<blockquote>
<p>格式化和多余空白字符</p>
</blockquote>
<p>格式化与多余的空白字符是许多开发人员在协作时，特别是在跨平台情况下，不时会遇到的令人头疼的琐碎的问题。由于编辑器的不同或者文件行尾的换行符在 Windows 下被替换了，一些细微的空格变化会不经意地混入提交的补丁或其它协作成果中。不用怕，Git 提供了一些配置项来帮助你解决这些问题。</p>
<ul>
<li>core.autocrlf</li>
</ul>
<p>Git 可以在你提交时自动地把回车和换行转换成换行，而在检出代码时把换行转换成回车和换行。你可以用core.autocrlf 来打开此项功能。如果是在 Windows 系统上，把它设置成 true，这样在检出代码时，换行会被转换成回车和换行：</p>
<p>如果使用以换行作为行结束符的 Linux 或 Mac，你不需要 Git 在检出文件时进行自动的转换；然而当一个以回车加换行作为行结束符的文件不小心被引入时，你肯定想让 Git 修正。你可以把 core.autocrlf 设置成 input 来告诉 Git 在提交时把回车和换行转换成换行，检出时不转换：</p>
<ul>
<li>core.whitespace</li>
</ul>
<p>Git 预先设置了一些选项来探测和修正多余空白字符问题。它提供了六种处理多余空白字符的主要选项 —— 其中三个默认开启，另外三个默认关闭，不过你可以自由地设置它们。</p>
<p>默认被打开的三个选项是：blank-at-eol，查找行尾的空格；blank-at-eof，盯住文件底部的空行；space-before-tab，警惕行头 tab 前面的空格。</p>
<p>默认被关闭的三个选项是：indent-with-non-tab，揪出以空格而非 tab 开头的行（你可以用 tabwidth 选项控制它）；tab-in-indent，监视在行头表示缩进的 tab；cr-at-eol，告诉 Git 忽略行尾的回车。</p>
<h3 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h3><ul>
<li>receive.fsckObjects</li>
</ul>
<p>Git 能够确认每个对象的有效性以及 SHA-1 检验和是否保持一致。但 Git 不会在每次推送时都这么做。设置 receive.fsckObjects 为 true 来强迫它这么做</p>
<ul>
<li>receive.denyNonFastForwards</li>
</ul>
<p>如果你变基已经被推送的提交，继而再推送，又或者推送一个提交到远程分支，而这个远程分支当前指向的提交不在该提交的历史中，这样的推送会被拒绝。这通常是个很好的策略，但有时在变基的过程中，你确信自己需要更新远程分支，可以在 push 命令后加 -f 标志来强制更新（force-update）。</p>
<p>要禁用这样的强制更新推送（force-pushes），可以设置 receive.denyNonFastForwards：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --system receive.denyNonFastForwards true</div></pre></td></tr></table></figure></p>
<ul>
<li>receive.denyDeletes</li>
</ul>
<p>有一些方法可以绕过 denyNonFastForwards 策略。其中一种是先删除某个分支，再连同新的引用一起推送回该分支。把 receive.denyDeletes 设置为 true 可以把这个漏洞补上：</p>
<h2 id="Git-属性"><a href="#Git-属性" class="headerlink" title="Git 属性"></a>Git 属性</h2><p>你也可以针对特定的路径配置某些设置项，这样 Git 就只对特定的子目录或子文件集运用它们。这些基于路径的设置项被称为 Git 属性，可以在你的目录下的 .gitattributes 文件内进行设置（通常是你的项目的根目录）。如果不想让这些属性文件与其它文件一同提交，你也可以在 .git/info/attributes 文件中进行设置。</p>
<p>通过使用属性，你可以对项目中的文件或目录单独定义不同的合并策略，让 Git 知道怎样比较非文本文件，或者让 Git 在提交或检出前过滤内容。</p>
<h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><p>你可以用 Git 属性让 Git 知道哪些是二进制文件（以防它没有识别出来），并指示其如何处理这些文件。</p>
<blockquote>
<p>识别二进制文件</p>
</blockquote>
<p>要让 Git 把所有 pbxproj 文件当成二进制文件，在 .gitattributes 文件中如下设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*.pbxproj binary</div></pre></td></tr></table></figure></p>
<p>现在，Git 不会尝试转换或修正回车换行（CRLF）问题，当你在项目中运行 git show 或 git diff 时，Git 也不会比较或打印该文件的变化</p>
<blockquote>
<p>比较二进制文件</p>
</blockquote>
<p>可以使用 Git 属性来有效地比较两个二进制文件。秘诀在于，告诉 Git 怎么把你的二进制文件转化为文本格式，从而能够使用普通的 diff 方式进行对比。</p>
<p>把下面这行文本加到你的 .gitattributes 文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*.docx diff=word</div></pre></td></tr></table></figure></p>
<p>这告诉 Git 当你尝试查看包含变更的比较结果时，所有匹配 .docx 模式的文件都应该使用“word”过滤器。“word”过滤器是什么？我们现在就来设置它。我们会对 Git 进行配置，令其能够借助 docx2txt 程序将Word 文档转为可读文本文件，这样不同的文件间就能够正确比较了。</p>
<h3 id="关键字展开"><a href="#关键字展开" class="headerlink" title="关键字展开"></a>关键字展开</h3><p>Git 属性提供了另一种方法：我们可以编写自己的过滤器来实现文件提交或检出时的关键字替换。</p>
<h3 id="导出版本库"><a href="#导出版本库" class="headerlink" title="导出版本库"></a>导出版本库</h3><p>当归档的时候，可以设置 Git 不导出某些文件和目录。如果你不想在归档中包含某个子目录或文件，但想把它们纳入项目的版本管理中，你可以在 export-ignore 属性中指定它们。</p>
<p>例如，假设你在 test/ 子目录下有一些测试文件，不希望它们被包含在项目导出的压缩包（tarball）中。你可以增加下面这行到 Git 属性文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test/ export-ignore</div></pre></td></tr></table></figure>
<h3 id="合并策略"><a href="#合并策略" class="headerlink" title="合并策略"></a>合并策略</h3><p>你还能对项目中的特定文件指定不同的合并策略。一个非常有用的选项就是，告诉 Git 当特定文件发生冲突时不要尝试合并它们，而是直接使用你这边的内容</p>
<h2 id="Git-钩子"><a href="#Git-钩子" class="headerlink" title="Git 钩子"></a>Git 钩子</h2><p>Git 能在<strong>特定的重要动作发生时触发自定义脚本</strong>。有两组这样的钩子：客户端的和服务器端的。客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。</p>
<h3 id="安装一个钩子"><a href="#安装一个钩子" class="headerlink" title="安装一个钩子"></a>安装一个钩子</h3><p>钩子都被存储在 Git 目录下的 hooks 子目录中。也即绝大部分项目中的 .git/hooks 。当你用 git init 初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。这些脚本除了本身可以被调用外，它们还透露了被触发时所传入的参数。所有的示例都是 shell 脚本，其中一些还混杂了 Perl 代码，不过，<strong>任何正确命名的可执行脚本都可以正常使用</strong> —— 你可以用 Ruby 或 Python，或其它语言编写它们。这些示例的名字都是以.sample 结尾，如果你想启用它们，得先移除这个后缀</p>
<p>把一个正确命名且可执行的文件放入 Git 目录下的 hooks 子目录中，即可激活该钩子脚本。</p>
<h3 id="客户端钩子"><a href="#客户端钩子" class="headerlink" title="客户端钩子"></a>客户端钩子</h3><p>克隆某个版本库时，它的客户端钩子 并不 随同复制。如果需要靠这些脚本来强制维持某种策略，建议你在服务器端实现这一功能。</p>
<h4 id="提交工作流钩子"><a href="#提交工作流钩子" class="headerlink" title="提交工作流钩子"></a>提交工作流钩子</h4><p><code>pre-commit</code> 钩子在<strong>键入提交信息前运行</strong>。它用于检查即将提交的快照，例如，检查是否有所遗漏，确保测试运行，以及核查代码。如果该钩子以非零值退出，Git 将放弃此次提交，不过你可以用 git commit –no-verify 来绕过这个环节。你可以利用该钩子，来检查代码风格是否一致（运行类似 lint 的程序）、尾随空白字符是否存在（自带的钩子就是这么做的），或新方法的文档是否适当。</p>
<p><code>prepare-commit-msg</code>钩子在<strong>启动提交信息编辑器之前，默认信息被创建之后运行</strong>。它允许你编辑提交者所看到的默认信息。该钩子接收一些选项：存有当前提交信息的文件的路径、提交类型和修补提交的提交的 SHA-1校验。它对一般的提交来说并没有什么用；然而对那些会自动产生默认信息的提交，如提交信息模板、合并提交、压缩提交和修订提交等非常实用。你可以结合提交模板来使用它，动态地插入信息。</p>
<p><code>commit-msg</code> 钩子接收一个参数，此参数即上文提到的，存有当前提交信息的临时文件的路径。如果该钩子脚本以非零值退出，Git 将放弃提交，因此，可以用来在提交通过前验证项目状态或提交信息。在本章的最后一节，我们将展示如何使用该钩子来核对提交信息是否遵循指定的模板。</p>
<p><code>post-commit</code> 钩子在<strong>整个提交过程完成后运行</strong>。它不接收任何参数，但你可以很容易地通过运行 git log -1HEAD 来获得最后一次的提交信息。该钩子一般用于通知之类的事情。</p>
<h4 id="电子邮件工作流钩子"><a href="#电子邮件工作流钩子" class="headerlink" title="电子邮件工作流钩子"></a>电子邮件工作流钩子</h4><p>可以给电子邮件工作流设置三个客户端钩子。它们都是由 git am 命令调用的</p>
<p>第一个运行的钩子是 <code>applypatch-msg</code> 。它接收单个参数：包含请求合并信息的临时文件的名字。如果脚本返回非零值，Git 将放弃该补丁。你可以用该脚本来确保提交信息符合格式，或直接用脚本修正格式错误。</p>
<p>下一个在 git am 运行期间被调用的是 <code>pre-applypatch</code> 。有些难以理解的是，它正好运行于应用补丁 之后，产生提交之前，所以你可以用它在提交前检查快照。你可以用这个脚本运行测试或检查工作区。如果有什么遗漏，或测试未能通过，脚本会以非零值退出，中断 git am 的运行，这样补丁就不会被提交。</p>
<p><code>post-applypatch</code> 运行于提交产生之后，是在 git am 运行期间最后被调用的钩子。你可以用它把结果通知给一个小组或所拉取的补丁的作者。但你没办法用它停止打补丁的过程。</p>
<h4 id="其他钩子"><a href="#其他钩子" class="headerlink" title="其他钩子"></a>其他钩子</h4><p><code>pre-rebase</code> 钩子运行于变基之前，以非零值退出可以中止变基的过程。你可以使用这个钩子来禁止对已经推送的提交变基。Git 自带的 pre-rebase 钩子示例就是这么做的，</p>
<p><code>post-rewrite</code> 钩子被那些会<strong>替换提交记录的命令调用</strong>，比如 git commit –amend 和 git rebase（不过不包括 git filter-branch）。它唯一的参数是触发重写的命令名，同时从标准输入中接受一系列重写的提交记录。这个钩子的用途很大程度上跟 post-checkout 和 post-merge 差不多。</p>
<p>在 git checkout 成功运行后，<code>post-checkout</code> 钩子会被调用。你可以根据你的项目环境用它调整你的工作目录。其中包括放入大的二进制文件、自动生成文档或进行其他类似这样的操作。</p>
<p>在 git merge 成功运行后，<code>post-merge</code> 钩子会被调用。你可以用它恢复 Git 无法跟踪的工作区数据，比如权限数据。这个钩子也可以用来验证某些在 Git 控制之外的文件是否存在，这样你就能在工作区改变时，把这些文件复制进来。</p>
<p><code>pre-push</code> 钩子会在 git push 运行期间， 更新了远程引用但尚未传送对象时被调用。它接受远程分支的名字和位置作为参数，同时从标准输入中读取一系列待更新的引用。你可以在推送开始之前，用它验证对引用的更新操作（一个非零的退出码将终止推送过程）。</p>
<p>Git 的一些日常操作在运行时，偶尔会调用 git gc –auto 进行垃圾回收。<code>pre-auto-gc</code> 钩子会在垃圾回收开始之前被调用，可以用它来提醒你现在要回收垃圾了，或者依情形判断是否要中断回收。</p>
<h3 id="服务端钩子"><a href="#服务端钩子" class="headerlink" title="服务端钩子"></a>服务端钩子</h3><ul>
<li>pre-receive</li>
</ul>
<p>处理来自客户端的推送操作时，最先被调用的脚本是 pre-receive。它从标准输入获取一系列被推送的引用。如果它以非零值退出，所有的推送内容都不会被接受。你可以用这个钩子阻止对引用进行非快进（non-fastforward）的更新，或者对该推送所修改的所有引用和文件进行访问控制。</p>
<ul>
<li>update</li>
</ul>
<p>update 脚本和 pre-receive 脚本十分类似，不同之处在于它会为每一个准备更新的分支各运行一次。假如推送者同时向多个分支推送内容，pre-receive 只运行一次，相比之下 update 则会为每一个被推送的分支各运行一次。</p>
<ul>
<li>post-receive</li>
</ul>
<p>post-receive 挂钩在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。它接受与 prereceive 相同的标准输入数据。它的用途包括给某个邮件列表发信，通知持续集成（continous integration）的服务器，或者更新问题追踪系统（ticket-tracking system） —— 甚至可以通过分析提交信息来决定某个问题（ticket）是否应该被开启，修改或者关闭。该脚本无法终止推送进程，不过客户端在它结束运行之前将保持连接状态，所以如果你想做其他操作需谨慎使用它，因为它将耗费你很长的一段时间。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git 工具]]></title>
      <url>/2018/02/08/Git-%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<p>《Pro Git》读书笔记</p>
<a id="more"></a>
<h2 id="选择修改版本"><a href="#选择修改版本" class="headerlink" title="选择修改版本"></a>选择修改版本</h2><p>Git 允许你通过几种方法来指明特定的或者一定范围内的提交。</p>
<h3 id="单个修订版本"><a href="#单个修订版本" class="headerlink" title="单个修订版本"></a>单个修订版本</h3><p>Git 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交，当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义</p>
<blockquote>
<p>分支引用</p>
</blockquote>
<p>指明一次提交最直接的方法是有一个指向它的分支引用。这样你就可以在任意一个 Git 命令中使用这个分支名来代替对应的提交对象或者 SHA-1 值。</p>
<blockquote>
<p>引用日志</p>
</blockquote>
<p>当你在工作时， Git 会在后台保存一个引用日志(reflog)，引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史。</p>
<p>你可以使用 git reflog 来查看引用日志</p>
<p>详情可以查看<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%80%89%E6%8B%A9%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC" target="_blank" rel="external">这里</a></p>
<blockquote>
<p>祖先引用</p>
</blockquote>
<p>祖先引用是另一种指明一个提交的方式。如果你在引用的尾部加上一个 ^， Git 会将其解析为该引用的上一个提交。</p>
<p>另一种指明祖先提交的方法是 ~。同样是指向第一父提交，因此 HEAD~ 和 HEAD^ 是等价的</p>
<h3 id="提交区间"><a href="#提交区间" class="headerlink" title="提交区间"></a>提交区间</h3><p>最常用的指明提交区间语法是<strong>双点</strong>。这种语法可以让 Git 选出在一个分支中而不在另一个分支中的提交。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_7_1518003024258.jpg" alt="enter description here"></p>
<p>你想要查看 experiment 分支中还有哪些提交尚未被合并入 master 分支。你可以使用 master..experiment来让 Git 显示这些提交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log master..experiment</div></pre></td></tr></table></figure></p>
<p>双点语法很好用，但有时候你可能需要两个以上的分支才能确定你所需要的修订，比如查看哪些提交是被包含在某些分支中的一个，但是不在你当前的分支上。你想查所有被refA 或 refB 包含的但是不被 refC 包含的提交，你可以输入下面中的任意一个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git log refA refB ^refC</div><div class="line">$ git log refA refB --not refC</div></pre></td></tr></table></figure></p>
<h2 id="交互式暂存"><a href="#交互式暂存" class="headerlink" title="交互式暂存"></a>交互式暂存</h2><p>本节的几个互交命令可以帮助你将文件的特定部分组合成提交。当你修改一组文件后，希望这些改动能放到若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。</p>
<p>通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。如果运行 git add 时使用 -i 或者 –interactive 选项，Git 将会进入一个交互式终端模式</p>
<h2 id="储藏与清理"><a href="#储藏与清理" class="headerlink" title="储藏与清理"></a>储藏与清理</h2><p>有时，当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态，而这时你想要切换到另一个分支做一点别的事情。问题是，你不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交。针对这个问题的答案是 git stash 命令。</p>
<h3 id="储藏工作"><a href="#储藏工作" class="headerlink" title="储藏工作"></a>储藏工作</h3><ul>
<li>将新的储藏推送栈上：<code>git stash</code> 或者<code>git stash save</code></li>
<li>查看栈上的储藏：<code>git stash list</code></li>
<li>将栈顶的储藏应用：<code>git stash apply</code></li>
<li>丢弃指定储藏 <code>git stash drop {name}</code></li>
<li>应用栈顶储藏并弹出 <code>git stash pop</code></li>
</ul>
<h3 id="创造性储藏"><a href="#创造性储藏" class="headerlink" title="创造性储藏"></a>创造性储藏</h3><p>有几个储藏的变种可能也很有用。第一个非常流行的选项是 <code>stash save</code>命令的 <code>--keep-index</code> 选项。它告诉Git 不要储藏任何你通过 git add 命令已暂存的东西。</p>
<p>另一个经常使用储藏来做的事情是像储藏跟踪文件一样储藏未跟踪文件。默认情况下，git stash 只会储藏已经在索引中的文件。如果指定 <code>--include-untracked</code> 或 -u 标记，Git 也会储藏任何创建的未跟踪文件。</p>
<h3 id="从储藏创建一个分支"><a href="#从储藏创建一个分支" class="headerlink" title="从储藏创建一个分支"></a>从储藏创建一个分支</h3><p>如果储藏了一些工作，将它留在那儿了一会儿，然后继续在储藏的分支上工作，在重新应用工作时可能会有问题。如果应用尝试修改刚刚修改的文件，你会得到一个合并冲突并不得不解决它。如果想要一个轻松的方式来再次测试储藏的改动，可以运行 <code>git stash branch</code> 创建一个新分支，检出储藏工作时所在的提交，重新在那应用工作，然后在应用成功后扔掉储藏</p>
<h3 id="清理工作目录"><a href="#清理工作目录" class="headerlink" title="清理工作目录"></a>清理工作目录</h3><p>对于工作目录中一些工作或文件，你想做的也许不是储藏而是移除。git clean 命令会帮你做这些事</p>
<h2 id="签署工作"><a href="#签署工作" class="headerlink" title="签署工作"></a>签署工作</h2><p>Git 虽然是密码级安全的，但它不是万无一失的。如果你从因特网上的其他人那里拿取工作，并且想要验证提交是不是真正地来自于可信来源，Git 提供了几种通过 GPG 来签署和验证工作的方式。</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>无论仓库里的代码量有多少，你经常需要查找一个函数是在哪里调用或者定义的，或者一个方法的变更历史。Git 提供了两个有用的工具来快速地从它的数据库中浏览代码和提交。</p>
<h3 id="Git-Grep"><a href="#Git-Grep" class="headerlink" title="Git Grep"></a>Git Grep</h3><p>Git 提供了一个 grep 命令，你可以很方便地从提交历史或者工作目录中查找一个字符串或者正则表达式。</p>
<p>默认情况下 Git 会查找你工作目录的文件。你可以传入 -n 参数来输出 Git 所找到的匹配行行号。你可以使用 –count 选项来使 Git 输出概述的信息，仅仅包括哪些文件包含匹配以及每个文件包含了多少个匹配。如果你想看匹配的行是属于哪一个方法或者函数，你可以传入 -p 选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ git grep -n gmtime_r</div><div class="line">compat/gmtime.c:3:#undef gmtime_r</div><div class="line">compat/gmtime.c:8: return git_gmtime_r(timep, &amp;result);</div><div class="line">compat/gmtime.c:11:struct tm *git_gmtime_r(const time_t *timep, struct tm</div><div class="line">*result)</div><div class="line">compat/gmtime.c:16: ret = gmtime_r(timep, result);</div><div class="line">compat/mingw.c:606:struct tm *gmtime_r(const time_t *timep, struct tm</div><div class="line">*result)</div><div class="line">compat/mingw.h:162:struct tm *gmtime_r(const time_t *timep, struct tm</div><div class="line">*result);</div><div class="line">date.c:429: if (gmtime_r(&amp;now, &amp;now_tm))</div><div class="line">date.c:492: if (gmtime_r(&amp;time, tm)) &#123;</div><div class="line">    git-compat-util.h:721:struct tm *git_gmtime_r(const time_t *, struct tm</div><div class="line">    *);</div><div class="line">    git-compat-util.h:723:#define gmtime_r git_gmtime_r</div></pre></td></tr></table></figure>
<h3 id="Git-日志搜索"><a href="#Git-日志搜索" class="headerlink" title="Git 日志搜索"></a>Git 日志搜索</h3><p>或许你不想知道某一项在 哪里 ，而是想知道是什么 时候 存在或者引入的。git log 命令有许多强大的工具可以通过提交信息甚至是 diff 的内容来找到某个特定的提交。</p>
<p>例如，如果我们想找到 ZLIB_BUF_MAX 常量是什么时候引入的，我们可以使用 -S 选项来显示新增和删除该字符串的提交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git log -SZLIB_BUF_MAX --oneline</div><div class="line">e01503b zlib: allow feeding more than 4GB in one go</div><div class="line">ef49a7a zlib: zlib can only process 4GB at a time</div></pre></td></tr></table></figure></p>
<h2 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重写历史</h2><p>许多时候，在使用 Git 时，可能会因为某些原因想要修正提交历史。Git 很棒的一点是它允许你在最后时刻做决定。你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 stash 命令来决定不与某些内容工作，也可以重写已经发生的提交就像它们以另一种方式发生的一样。</p>
<h3 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h3><p>修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。对于你的最近一次提交，你往往想做两件事情：修改提交信息，或者修改你添加、修改和移除的文件的快照。</p>
<p>如果，你只是想修改最近一次提交的提交信息，那么很简单：<code>git commit --amend</code></p>
<h3 id="修改多个提交信息"><a href="#修改多个提交信息" class="headerlink" title="修改多个提交信息"></a>修改多个提交信息</h3><p>Git 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 HEAD 而不是将其移动到另一个新的上面。可以通过给 git rebase 增加 -i选项来交互式地运行变基。<code>git rebase -i HEAD~3</code></p>
<blockquote>
<p>重新排序提交</p>
</blockquote>
<p>修改交互式变基中的各个提交的顺序即可</p>
<blockquote>
<p>压缩提交</p>
</blockquote>
<p>通过交互式变基工具，也可以将一连串提交压缩成一个单独的提交。在变基信息中脚本给出了有用的指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Commands:</div><div class="line"># p, pick = use commit</div><div class="line"># r, reword = use commit, but edit the commit message</div><div class="line"># e, edit = use commit, but stop for amending</div><div class="line"># s, squash = use commit, but meld into previous commit</div><div class="line"># f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</div><div class="line"># x, exec = run command (the rest of the line) using shell</div></pre></td></tr></table></figure></p>
<h3 id="核武器级选项：filter-branch"><a href="#核武器级选项：filter-branch" class="headerlink" title="核武器级选项：filter-branch"></a>核武器级选项：filter-branch</h3><p>有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它 - 例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。这个命令是 filter-branch，它可以改写历史中大量的提交，<strong>除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，你不应当使用它</strong>。</p>
<blockquote>
<p>从每一个提交移除一个文件</p>
</blockquote>
<p>这经常发生。有人粗心地通过 git add . 提交了一个巨大的二进制文件，你想要从所有地方删除它。然而你想要开源项目。filter-branch 是一个可能会用来擦洗整个提交历史的工具。为了从整个提交历史中移除一个叫做 passwords.txt 的文件，可以使用 –tree-filter 选项给filter-branch：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git filter-branch --tree-filter &apos;rm -f passwords.txt&apos; HEAD</div></pre></td></tr></table></figure></p>
<p><code>--tree-filter</code> 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。</p>
<blockquote>
<p>使一个子目录做为新的根目录</p>
</blockquote>
<p>假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（trunk、tags 等等）。如果想要让trunk 子目录作为每一个提交的新的项目根目录，filter-branch 也可以帮助你那么做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git filter-branch --subdirectory-filter trunk HEAD</div></pre></td></tr></table></figure></p>
<h2 id="重置揭秘"><a href="#重置揭秘" class="headerlink" title="重置揭秘"></a>重置揭秘</h2><p>这里将讨论reset与checkout</p>
<h3 id="三棵树"><a href="#三棵树" class="headerlink" title="三棵树"></a>三棵树</h3><p>理解 reset 和 checkout 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。“树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构</p>
<p>Git 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：</p>
<table>
<thead>
<tr>
<th>树</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>HEAD</td>
<td>上一次提交的快照，下一次提交的父结点</td>
</tr>
<tr>
<td>Index</td>
<td>预期的下一次提交的快照</td>
</tr>
<tr>
<td>Working Directory</td>
<td>沙盒</td>
</tr>
</tbody>
</table>
<blockquote>
<p>HEAD</p>
</blockquote>
<p>HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。这表示 HEAD 将是下一次提交的父结点。通常，理解 HEAD 的最简方式，就是将它看做 <strong>你的上一次提交</strong> 的快照。</p>
<blockquote>
<p>Index</p>
</blockquote>
<p>索引是你的 <strong>预期的下一次提交</strong>。我们也会将这个概念引用为 Git 的 “暂存区域”，这就是当你运行 git commit 时 Git 看起来的样子。</p>
<blockquote>
<p>工作流程</p>
</blockquote>
<p>参考<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86" target="_blank" rel="external">这里</a></p>
<h3 id="重置的作用（reset）"><a href="#重置的作用（reset）" class="headerlink" title="重置的作用（reset）"></a>重置的作用（reset）</h3><ul>
<li>第一步：移动HEAD</li>
<li>第二步：更新索引（–mixed）</li>
<li>第三步：更新工作目录（–hard）</li>
</ul>
<p>reset 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：</p>
<ol>
<li>移动 HEAD 分支的指向 （若指定了 –soft，则到此停止）</li>
<li>使索引看起来像 HEAD   （默认执行到这一步）</li>
<li>使工作目录看起来像索引  （指定了 –hard ，才执行这一步）</li>
</ol>
<blockquote>
<p>通过路径来重置</p>
</blockquote>
<p>若指定了一个路径，reset 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。</p>
<blockquote>
<p>压缩</p>
</blockquote>
<p>我们来看看如何利用这种新的功能来做一些有趣的事情 - 压缩提交</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git reset --soft HEAD~2</div><div class="line">git commit</div></pre></td></tr></table></figure>
<h3 id="检出（checkout）"><a href="#检出（checkout）" class="headerlink" title="检出（checkout）"></a>检出（checkout）</h3><p>运行 <code>git checkout [branch]</code>与运行<code>git reset --hard [branch]</code>非常相似，它会更新所有三棵树使其看起来像 [branch]，不过有两点重要的区别。</p>
<p>首先不同于 reset –hard，checkout 对工作目录是安全的，它会通过检查来确保不会将已更改的文件吹走。其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有<em>还未修改过的</em>文件都会被更新。而 reset –hard 则会不做检查就全面地替换所有东西。</p>
<p>第二个重要的区别是如何更新 HEAD。reset 会移动 HEAD 分支的指向，而 checkout 只会移动 HEAD 自身来指向另一个分支。</p>
<blockquote>
<p>带路径情况</p>
</blockquote>
<p>运行 checkout 的另一种方式就是指定一个文件路径，这会像 reset 一样不会移动 HEAD。它就像是 <code>git reset --hard [branch] file</code>（如果 reset 允许你这样运行的话）- 这样对工作目录并不安全，它也不会移动 HEAD。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_7_1518007500384.jpg" alt="enter description here"></p>
<h2 id="高级合并"><a href="#高级合并" class="headerlink" title="高级合并"></a>高级合并</h2><p>Git 并不会尝试过于聪明的合并冲突解决方案。Git的哲学是聪明地决定无歧义的合并方案，但是如果有冲突，它不会尝试智能地自动解决它。</p>
<h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><p>首先，在做一次可能有冲突的合并前尽可能保证工作目录是干净的。</p>
<p>在遇到冲突的时候，你可以有以下几种解决方案：</p>
<blockquote>
<p>中断一次合并</p>
</blockquote>
<p>你可能不想处理冲突这种情况，完全可以通过 <code>git merge --abort</code> 来简单地退出合并。他会会尝试恢复到你运行合并前的状态。但当运行命令前，在工作目录中有未储藏、未提交的修改时它不能完美处理，除此之外它都工作地很好。</p>
<blockquote>
<p>忽略空白</p>
</blockquote>
<p>如果你看到在一次合并中有大量的空白问题，你可以简单地中止它并重做一次，这次使用<code>-Xignore-all-space</code>或 <code>-Xignore-space-change</code>选项。第一个选项忽略任意 数量 的已有空白的修改，第二个选项忽略所有空白修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge -Xignore-space-change whitespace</div></pre></td></tr></table></figure></p>
<blockquote>
<p>手动文件再合并</p>
</blockquote>
<p>首先，我们进入到了合并冲突状态。然后我们想要我的版本的文件，他们的版本的文件（从我们将要合并入的分支）和共同的版本的文件（从分支叉开时的位置）的拷贝。</p>
<p>然后我们想要修复任何一边的文件，并且为这个单独的文件重试一次合并。获得这三个文件版本实际上相当容易。Git 在索引中存储了所有这些版本，在 “stages” 下每一个都有一个数字与它们关联。Stage 1 是它们共同的祖先版本，stage 2 是你的版本，stage 3 来自于 MERGE_HEAD，即你将要合并入的版本（“theirs”）</p>
<p>如果你想要在最终提交前看一下我们这边与另一边之间实际的修改，你可以使用 <code>git diff</code></p>
<p>要在合并前比较结果与在你的分支上的内容，换一句话说，看看合并引入了什么，可以运行 <code>git diff --ours</code> ； 如果我们想要查看合并的结果与他们那边有什么不同，可以运行 <code>git diff --theirs</code></p>
<h3 id="子树合并"><a href="#子树合并" class="headerlink" title="子树合并"></a>子树合并</h3><p>子树合并的思想是你有两个项目，并且其中一个映射到另一个项目的一个子目录，或者反过来也行。</p>
<p>我们希望将 Rack 项目拉到 master 项目中作为一个子目录。我们可以在 Git 中执行 <code>git read-tree</code> 来实现。它会读取一个分支的根目录树到当前的暂存区和工作目录里。先切回你的 master 分支，将 rack_back 分支拉取到我们项目的 master 分支中的 rack 子目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git read-tree --prefix=rack/ -u rack_branch</div></pre></td></tr></table></figure></p>
<p>当 Rack 项目有更新时，我们可以切换到那个分支来拉取上游的变更。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout rack_branch</div><div class="line">git pull</div></pre></td></tr></table></figure></p>
<p>接着，我们可以将这些变更合并回我们的 master 分支。使用 –squash 选项和使用 -Xsubtree 选项（它采用递归合并策略），都可以用来可以拉取变更并且预填充提交信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line">git merge --squash -s recursive -Xsubtree=rack rack_branch</div></pre></td></tr></table></figure></p>
<h2 id="Rerere"><a href="#Rerere" class="headerlink" title="Rerere"></a>Rerere</h2><p>git rerere 功能是一个隐藏的功能。正如它的名字 “reuse recorded resolution” 所指，它允许你<strong>让 Git 记住解决一个块冲突的方法，这样在下一次看到相同冲突时，Git 可以为你自动地解决它</strong>。</p>
<p>有几种情形下这个功能会非常有用。在文档中提到的一个例子是如果你想要保证一个长期分支会干净地合并，但是又不想要一串中间的合并提交。将 rerere 功能打开后偶尔合并，解决冲突，然后返回到合并前。如果你持续这样做，那么最终的合并会很容易，因为 rerere 可以为你自动做所有的事情。</p>
<p>可以将同样的策略用在维持一个变基的分支时，这样就不用每次解决同样的变基冲突了。或者你将一个分支合并并修复了一堆冲突后想要用变基来替代合并 - 你可能并不想要再次解决相同的冲突。</p>
<p>另一个情形是当你偶尔将一堆正在改进的特性分支合并到一个可测试的头时，就像 Git 项目自身经常做的。如果测试失败，你可以倒回合并之前然后在去除导致测试失败的那个特性分支后重做合并，而不用再次重新解决所有的冲突。</p>
<p>启用rerere功能的方法：</p>
<ol>
<li><code>git config --global rerere.enabled true</code></li>
<li>在特定的仓库中创建<code>.git/rr-cache</code>目录</li>
</ol>
<p>更多使用方法可以查看<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-Rerere" target="_blank" rel="external">这里</a></p>
<h2 id="Git-调试"><a href="#Git-调试" class="headerlink" title="Git 调试"></a>Git 调试</h2><p>Git 提供两个工具来辅助你调试项目中的问题</p>
<h3 id="文件标注"><a href="#文件标注" class="headerlink" title="文件标注"></a>文件标注</h3><p><strong>如果你在追踪代码中的一个 bug，并且想知道是什么时候以及为何会引入，文件标注通常是最好用的工具。它</strong>展示了文件中每一行最后一次修改的提交。所以，如果你在代码中看到一个有问题的方法，你可以使用 gitblame 标注这个文件，查看这个方法每一行的最后修改时间以及是被谁修改的。这个例子使用 -L 选项来限制输出范围在第12至22行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git blame -L 12,22 simplegit.rb</div></pre></td></tr></table></figure>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>当你知道问题是在哪里引入的情况下文件标注可以帮助你查找问题。如果你不知道哪里出了问题，并且自从上次可以正常运行到现在已经有数十个或者上百个提交，这个时候你可以使用 git bisect 来帮助查找。bisect命令会<strong>对你的提交历史进行二分查找来帮助你尽快找到是哪一个提交引入了问题</strong>。</p>
<p>首先执行 <code>git bisect start</code> 来启动，接着执行<code>git bisect bad</code>来告诉系统当前你所在的提交是有问题的。然后你必须告诉 bisect 已知的最后一次正常状态是哪次提交，使用<code>git bisect good [good_commit]</code></p>
<p>在测试过程中可以通过 <code>git bisect good</code> 来告诉 Git 当前的提交没有问题，通过<code>git bisect bad</code>来告诉Git当前的提交有问题</p>
<h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><p>子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。</p>
<h3 id="开始使用子模块"><a href="#开始使用子模块" class="headerlink" title="开始使用子模块"></a>开始使用子模块</h3><p>你可以通过在 git submodule add 命令后面加上想要跟踪的项目 URL 来添加新的子模块。在本例中，我们将会添加一个名为 “DbConnector” 的库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git submodule add https://github.com/chaconinc/DbConnector</div></pre></td></tr></table></figure></p>
<p>Git首先会生成新的 <code>.gitmodules</code>文件。该置文件保存了项目 URL 与已经拉取的本地目录之间的映射。如果有多个子模块，该文件中就会有多条记录。要重点注意的是，该文件也像 .gitignore 文件一样受到（通过）版本控制。它会和该项目的其他部分一同被拉取推送。</p>
<h3 id="克隆含有子模块的项目"><a href="#克隆含有子模块的项目" class="headerlink" title="克隆含有子模块的项目"></a>克隆含有子模块的项目</h3><p>你必须运行两个命令：<code>git submodule init</code>用来初始化本地配置文件，而 <code>git submodule update</code> 则从该项目中抓取所有数据并检出父项目中列出的合适的提交。</p>
<p>如果给 git clone 命令传递 –recursive 选项，它就会自动初始化并更新仓库中的每一个子模块。</p>
<h3 id="在包含子模块的项目上工作"><a href="#在包含子模块的项目上工作" class="headerlink" title="在包含子模块的项目上工作"></a>在包含子模块的项目上工作</h3><p>在项目中使用子模块的最简模型，就是只使用子项目并不时地获取更新，而并不在你的检出中进行任何更改。</p>
<p>当我们运行 git submodule update 从子模块仓库中抓取修改时，Git 将会获得这些改动并更新子目录中的文件，但是会将子仓库留在一个称作 “游离的 HEAD” 的状态。</p>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>Git 可以将它的数据 “打包” 到一个文件中。这在许多场景中都很有用。有可能你的网络中断了，但你又希望将你的提交传给你的合作者们。可能你不在办公网中并且出于安全考虑没有给你接入内网的权限。</p>
<p>bundle 命令会<strong>将 git push 命令所传输的所有内容打包成一个二进制文件</strong>，你可以将这个文件通过邮件或者闪存传给其他人，然后解包到其他的仓库中。</p>
<p>如果你想把这个仓库发送给其他人但你没有其他仓库的权限，或者就是懒得新建一个仓库，你就可以用 gitbundle create 命令来打包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git bundle create repo.bundle HEAD master</div></pre></td></tr></table></figure></p>
<p>然后你就会有一个名为 repo.bundle 的文件，该文件包含了所有重建该仓库 master 分支所需的数据。</p>
<p>假设别人传给你一个 repo.bundle 文件并希望你在这个项目上工作。你可以从这个二进制文件中克隆出一个目录，就像从一个 URL 克隆一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone repo.bundle repo</div></pre></td></tr></table></figure></p>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>Git 对象是不可改变的，但它提供一种有趣的方式来用其他对象假装替换数据库中的 Git 对象。</p>
<p><code>replace</code>命令可以让你在 Git 中指定一个对象并可以声称“每次你遇到这个 Git 对象时，假装它是其他的东西”。在你用一个不同的提交替换历史中的一个提交时，这会非常有用。</p>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E6%9B%BF%E6%8D%A2" target="_blank" rel="external">详情</a></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[服务器上的Git && 分布式Git]]></title>
      <url>/2018/02/07/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84Git-%E5%88%86%E5%B8%83%E5%BC%8FGit/</url>
      <content type="html"><![CDATA[<p>《Pro Git》读书笔记</p>
<a id="more"></a>
<h1 id="服务器上的Git"><a href="#服务器上的Git" class="headerlink" title="服务器上的Git"></a>服务器上的Git</h1><p>一个远程仓库通常只是一个裸仓库（bare repository）— 即一个没有当前工作目录的仓库。因为该仓库仅仅作为合作媒介，不需要从磁碟检查快照；存放的只有 Git 的资料。简单的说，裸仓库就是你专案目录内的 .git 子目录内容，不包含其他资料</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>Git 可以使用四种主要的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git协议。</p>
<h3 id="本地协议"><a href="#本地协议" class="headerlink" title="本地协议"></a>本地协议</h3><p>最基本的就是 本地协议（Local protocol） ，其中的<strong>远程版本库就是硬盘内的另一个目录</strong>。这常见于团队每一个成员都对一个共享的文件系统（例如一个挂载的 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。后者并不理想，因为你的所有代码版本库如果长存于同一台电脑，更可能发生灾难性的损失。</p>
<p>优点</p>
<ul>
<li>简单，并且直接使用了现有的文件权限和网络访问权限</li>
</ul>
<p>缺点：</p>
<ul>
<li>通常共享文件系统比较难配置，并且比起基本的网络连接访问，这不方便从多个位置访问</li>
<li>在同一个服务器上，如果允许 Git 访问本地硬盘，一般的通过 NFS 访问版本库要比通过 SSH 访问慢。</li>
<li>这个协议并不保护仓库避免意外的损坏。每一个用户都有“远程”目录的完整 shell 权限，没有方法可以阻止他们修改或删除 Git 内部文件和损坏仓库。</li>
</ul>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>智能” HTTP 协议的运行方式和 SSH 及 Git 协议类似，只是运行在标准的 HTTP/S 端口上并且可以使用各种HTTP 验证机制，这意味着使用起来会比 SSH 协议简单的多，比如可以使用 HTTP 协议的用户名／密码的基础授权，免去设置 SSH 公钥。</p>
<p>哑 HTTP 协议里 web 服务器仅把裸版本库当作普通文件来对待，提供文件服务。哑 HTTP 协议的优美之处在于设置起来简单。基本上，只需要把一个裸版本库放在 HTTP 跟目录，设置一个叫做 post-update 的挂钩就可以了</p>
<p>优点（只关注智能“HTTP”协议）：</p>
<ul>
<li>不同的访问方式只需要一个 URL 以及服务器只在需要授权时提示输入授权信息，这两个简便性让终端用户使用Git 变得非常简单。</li>
<li>可以在 HTTPS 协议上提供只读版本库的服务，如此你在传输数据的时候就可以加密数据；或者，你甚至可以让客户端使用指定的 SSL 证书。</li>
<li>HTTP/S 协议被广泛使用，一般的企业防火墙都会允许这些端口的数据通过。</li>
</ul>
<p>缺点：</p>
<ul>
<li>在一些服务器上，架设 HTTP/S 协议的服务端会比 SSH 协议的棘手一些</li>
</ul>
<h3 id="SSH协议"><a href="#SSH协议" class="headerlink" title="SSH协议"></a>SSH协议</h3><p>架设 Git 服务器时常用 SSH 协议作为传输协议。因为大多数环境下已经支持通过 SSH 访问 —— 即时没有也比较很容易架设。SSH 协议也是一个验证授权的网络协议；并且，因为其普遍性，架设和使用都很容易。</p>
<p>优点：</p>
<ul>
<li>SSH 架设相对简单 —— SSH 守护进程很常见，多数管理员都有使用经验，并且多数操作系统都包含了它及相关的管理工具。</li>
<li>通过 SSH 访问是安全的 —— 所有传输数据都要经过授权和加密。</li>
<li>与 HTTP/S 协议、Git 协议及本地协议一样，SSH 协议很高效，在传输前也会尽量压缩数据。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能通过他实现匿名访问。即便只要读取数据，使用者也要有通过 SSH 访问你的主机的权限，这使得 SSH 协议不利于开源的项目。</li>
</ul>
<h3 id="Git协议"><a href="#Git协议" class="headerlink" title="Git协议"></a>Git协议</h3><p>包含在 Git 里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于 SSH服务，但是访问无需任何授权。</p>
<p>优点：</p>
<ul>
<li>Git 协议是 Git 使用的网络传输协议里最快的。</li>
</ul>
<p>缺点：</p>
<ul>
<li>缺乏授权机制。把 Git 协议作为访问项目版本库的唯一手段是不可取的</li>
</ul>
<h2 id="在服务器上搭建Git"><a href="#在服务器上搭建Git" class="headerlink" title="在服务器上搭建Git"></a>在服务器上搭建Git</h2><h3 id="SSH连接"><a href="#SSH连接" class="headerlink" title="SSH连接"></a>SSH连接</h3><p>如果你有一台所有开发者都可以用 SSH 连接的服务器，架设你的第一个仓库就十分简单了，因为你几乎什么都不用做（正如我们上一节所说的）。如果你想在你的仓库上设置更复杂的访问控制权限，只要使用服务器操作系统的普通的文件系统权限就行了。</p>
<p>如果需要团队里的每个人都对仓库有写权限，又不能给每个人在服务器上建立账户，那么提供 SSH 连接就是唯一的选择了。一下提供几种方法：</p>
<ul>
<li>第一个就是给团队里的每个人创建账号，这种方法很直接但也很麻烦。或许你不会想要为每个人运行一次 adduser 并且设置临时密码。</li>
<li>第二个办法是在主机上建立一个 git 账户，让每个需要写权限的人发送一个 SSH 公钥，然后将其加入 git 账户的~/.ssh/authorized_keys 文件。这样一来，所有人都将通过 git 账户访问主机。这一点也不会影响提交的数据——访问主机用的身份不会影响提交对象的提交者信息。</li>
<li>另一个办法是让 SSH 服务器通过某个 LDAP 服务，或者其他已经设定好的集中授权机制，来进行授权。只要每个用户可以获得主机的 shell 访问权限，任何 SSH 授权机制你都可视为是有效的。</li>
</ul>
<h2 id="GitWeb"><a href="#GitWeb" class="headerlink" title="GitWeb"></a>GitWeb</h2><p>如果你对项目有读写权限或只读权限，你可能需要建立起一个基于网页的简易查看器。Git 提供了一个叫做GitWeb 的 CGI 脚本来做这项工作</p>
<p>如果你想要查看 GitWeb 如何展示你的项目，并且在服务器上安装了轻量级网络服务器比如 lighttpd 或webrick， Git 提供了一个命令来让你启动一个临时的服务器。在 Linux 系统的电脑上，lighttpd 通常已经安装了，所以你只需要在项目目录里执行 git instaweb 命令即可。</p>
<h1 id="分布式Git"><a href="#分布式Git" class="headerlink" title="分布式Git"></a>分布式Git</h1><h2 id="分布式工作流程"><a href="#分布式工作流程" class="headerlink" title="分布式工作流程"></a>分布式工作流程</h2><p>在集中式系统中，每个开发者就像是连接在集线器上的节点，彼此的工作方式大体相像。而在 Git 中，<strong>每个开发者同时扮演着节点和集线器的角色</strong>——也就是说，每个开发者既可以将自己的代码贡献到其他的仓库中，同时也能维护自己的公开仓库，让其他人可以在其基础上工作并贡献代码。</p>
<h3 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="集中式工作流"></a>集中式工作流</h3><p>集中式系统中通常使用的是单点协作模型——集中式工作流。</p>
<p>这意味着如果两个开发者从中心仓库克隆代码下来，同时作了一些修改，那么只有第一个开发者可以顺利地把数据推送回共享服务器。第二个开发者在推送修改之前，必须先将第一个人的工作合并进来，这样才不会覆盖第一个人的修改。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517834128254.jpg" alt="enter description here"></p>
<h3 id="集成管理者工作流"><a href="#集成管理者工作流" class="headerlink" title="集成管理者工作流"></a>集成管理者工作流</h3><p>Git 允许多个远程仓库存在，使得这样一种工作流成为可能：每个开发者拥有自己仓库的写权限和其他所有人仓库的读权限。这种情形下通常会有个代表‘官方’’项目的权威的仓库。要为这个项目做贡献，你需要从该项目克隆出一个自己的公开仓库，然后将自己的修改推送上去。接着你可以请求官方仓库的维护者拉取更新合并到主项目。维护者可以将你的仓库作为远程仓库添加进来，在本地测试你的变更，将其合并入他们的分支并推送回官方仓库。</p>
<p>这是 GitHub 和 GitLab 等集线器式（hub-based）工具最常用的工作流程。</p>
<p>这么做最主要的优点之一是你可以持续地工作，而主仓库的维护者可以随时拉取你的修改。贡献者不必等待维护者处理完提交的更新——每一方都可以按照自己节奏工作</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517834212479.jpg" alt="enter description here"></p>
<h3 id="司令官与副官工作流"><a href="#司令官与副官工作流" class="headerlink" title="司令官与副官工作流"></a>司令官与副官工作流</h3><p>这其实是多仓库工作流程的变种。一般拥有数百位协作开发者的超大型项目才会用到这样的工作方式，例如著名的 Linux 内核项目。被称为副官（lieutenant）的各个集成管理者分别负责集成项目中的特定部分。所有这些副官头上还有一位称为司令官（dictator）的总集成管理者负责统筹。司令官维护的仓库作为参考仓库，为所有协作者提供他们需要拉取的项目代码。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517834259058.jpg" alt="enter description here"></p>
<h2 id="向一个项目贡献"><a href="#向一个项目贡献" class="headerlink" title="向一个项目贡献"></a>向一个项目贡献</h2><p>提交准则：</p>
<ul>
<li>你不会想要把空白错误提交上去</li>
<li>尝试让每一个提交成为一个逻辑上的独立变更集。</li>
<li>最后一件要牢记的事是提交信息。有一个创建优质提交信息的习惯会使 Git 的使用与协作容易的多。</li>
</ul>
<h2 id="维护项目"><a href="#维护项目" class="headerlink" title="维护项目"></a>维护项目</h2><h3 id="在特性分支中工作"><a href="#在特性分支中工作" class="headerlink" title="在特性分支中工作"></a>在特性分支中工作</h3><p>如果你想向项目中整合一些新东西，最好将这些尝试局限在特性分支——一种通常用来尝试新东西的临时分支中</p>
<h3 id="应用来自邮件的补丁"><a href="#应用来自邮件的补丁" class="headerlink" title="应用来自邮件的补丁"></a>应用来自邮件的补丁</h3><p>如果你通过电子邮件收到了一个需要整合进入项目的补丁，你需要将其应用到特性分支中进行评估。有两种应用该种补丁的方法：使用 git apply，或者使用 git am。</p>
<p>具体详情可以参考<a href="https://git-scm.com/book/zh/v2/%E5%88%86%E5%B8%83%E5%BC%8F-Git-%E7%BB%B4%E6%8A%A4%E9%A1%B9%E7%9B%AE" target="_blank" rel="external">这里</a></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[APUE Unix 基础知识]]></title>
      <url>/2018/02/06/APUE-Unix-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>《UNIX环境高级编程》第1章笔记</p>
<a id="more"></a>
<h2 id="Unix-体系结构"><a href="#Unix-体系结构" class="headerlink" title="Unix 体系结构"></a>Unix 体系结构</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_6_1517920273064.jpg" alt="enter description here"></p>
<p>可以将操作系统定义为一种软件，其控制计算机硬件资源，提供程序运行环境。我们通常将这种软件称为<strong>内核</strong>( kemel),因为它相对较小, 而且位于环境的核心。</p>
<p>内核的接口被称为<strong>系统调用</strong>( system call)。公用函数库构建在系统调用接口之上,应用程序既可使用公用函数库,也可使用系统调用。</p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>口令文件（通常是/etc/passwd文件）中查看登录名。口令文件中的登录项由7个以冒号分隔的字段组成,依次是:<br><code>登录名、加密口令、数字用户ID(205)、数字组TD(105)、注释字段、起始目录(/home/sar)以及 shel程序(/bin/ksh)</code></p>
<p>shell是一个命令行解释器,它读取用户输入,然后执行命令。 shell的用户输入通常来自 于终端(交互式 shell),有时则来自于文件(称为 shell i脚本)。</p>
<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>UNX文件系统是<strong>目录和文件的一种层次结构</strong>,所有东西的起点是称为根(root)的目录,这个目录的名称是一个字符“/”。 目录( directory)是一个包含目录项的文件。</p>
<h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><p>目录中的各个名字称为文件名( filename)。只有斜线线(/)和空字符这两个字符不能出现在 文件名中。斜线用来分隔构成路径名的各文件名,空字符则用来终止一个路径名。</p>
<h3 id="路径名"><a href="#路径名" class="headerlink" title="路径名"></a>路径名</h3><p>由斜线分隔的一个或多个文件名组成的序列(也可以斜线开头)构成路径名( pathname),以斜线 开头的路径名称为<strong>绝对路径名</strong>( absolute pathname),否则称为<strong>相对路径名</strong>( relative pathname)。</p>
<h3 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h3><p>每个进程都有一个工作目录( working directory),有时称其为当前工作目录( current working directory)。所有相对路径名名都从工作目录开始解释。</p>
<h3 id="起始目录"><a href="#起始目录" class="headerlink" title="起始目录"></a>起始目录</h3><p>登录时，工作目录设置为起始目录（home directory）</p>
<blockquote>
<p>ls(l) 命令的简要实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span>  <span class="comment">//用于本书各个实例 包含某些标准头文件，定义了很多常量和函数模型</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt; // 使用opendir和readdir的函数原型，以及dirent结构的定义</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></div><div class="line">&#123;</div><div class="line">	DIR				*dp;</div><div class="line">	<span class="keyword">struct</span> dirent	*dirp;</div><div class="line"></div><div class="line">	<span class="comment">// 给出的参数不符</span></div><div class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</div><div class="line">		err_quit(<span class="string">"usage: ls directory_name"</span>);</div><div class="line">	<span class="comment">// 获取命令行的第一个参数，	打开目录，返回一个DIR结构指针</span></div><div class="line">	<span class="keyword">if</span> ((dp = opendir(argv[<span class="number">1</span>])) == <span class="literal">NULL</span>)</div><div class="line">		err_sys(<span class="string">"can't open %s"</span>, argv[<span class="number">1</span>]);</div><div class="line">	<span class="comment">// 读取目录并输出目录名</span></div><div class="line">	<span class="keyword">while</span> ((dirp = readdir(dp)) != <span class="literal">NULL</span>)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, dirp-&gt;d_name);</div><div class="line">	<span class="comment">// 关闭目录</span></div><div class="line">	closedir(dp);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>文件描述符( file descriptor)通常是一个小的非负整数,内核用以标识一个特定进程正在访 问的文件。当内核打开一个现有文件或创建一个新文件时,它都返回一个文件描述符。</p>
<h3 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h3><p> 按惯例,每当运行一个新程序时,所有的 shell i都为其打开3个文件描述符,即标准输入 standard input.)、标准输出( Istandard output)以及标准錯误( standard error)</p>
<h3 id="不带缓冲I-O"><a href="#不带缓冲I-O" class="headerlink" title="不带缓冲I/O"></a>不带缓冲I/O</h3><p> 函数open、read、write、lseek以及close提供了不带缓冲的I/O</p>
<p> 复制任意Unix普通文件</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	BUFFSIZE	4096</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span>		n;</div><div class="line">	<span class="keyword">char</span>	buf[BUFFSIZE];</div><div class="line"></div><div class="line">	<span class="comment">// STDIN_FILENO 和 STDOUT_FILENO指定标准输入输出的文件描述符 在POSIX标准，他们分别是0和1</span></div><div class="line">	<span class="comment">// read函数返回读取的字节数，此值作为写入的字节数传入write函数中</span></div><div class="line">	<span class="keyword">while</span> ((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">if</span> (write(STDOUT_FILENO, buf, n) != n)</div><div class="line">			err_sys(<span class="string">"write error"</span>);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</div><div class="line">		err_sys(<span class="string">"read error"</span>);</div><div class="line"></div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h3><p> 标准U/O函数为那些不带缓冲的I/O函数提供了一个带缓冲的接口。使用标准I/O函数无需 担心如何选取最佳的缓冲区大小</p>
<h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p> 程序（program）是存储在磁盘上某个目录中的一个可执行文件</p>
<h3 id="进程和进程ID"><a href="#进程和进程ID" class="headerlink" title="进程和进程ID"></a>进程和进程ID</h3><p> 程序执行实例被称为进程（process），Unix系统确保每一个进程都有唯一一个数字标识符，称为进程ID（process ID）</p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p> 有3个用于控制进程的主要函数：fork、exec和waitpid</p>
<h3 id="线程和线程ID"><a href="#线程和线程ID" class="headerlink" title="线程和线程ID"></a>线程和线程ID</h3><blockquote>
<p>shell 基本实施程序</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span>	buf[MAXLINE];	<span class="comment">/* from apue.h */</span></div><div class="line">	<span class="keyword">pid_t</span>	pid;</div><div class="line">	<span class="keyword">int</span>		status;</div><div class="line"></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%% "</span>);	<span class="comment">/* print prompt (printf requires %% to print %) */</span></div><div class="line"></div><div class="line">	<span class="comment">// 用标准I/O函数fgets从标准输入中读取一行</span></div><div class="line">	<span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</div><div class="line">		<span class="comment">// 因为fgets返回的每一行中都以换行符终止，但是execlp函数要求参数以null结束，所以用null替代每一行后面的换行符</span></div><div class="line">		<span class="keyword">if</span> (buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">'\n'</span>)</div><div class="line">			buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">/* replace newline with null */</span></div><div class="line"></div><div class="line">		<span class="comment">// fork创建子进程失败</span></div><div class="line">		<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</div><div class="line">			err_sys(<span class="string">"fork error"</span>);</div><div class="line">			<span class="comment">// 子进程处理：调用execlp从命令行输入读入命令，用新的程序文件替换子进程原来执行的程序文件</span></div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;		<span class="comment">/* child */</span></div><div class="line">			execlp(buf, buf, (<span class="keyword">char</span> *)<span class="number">0</span>);</div><div class="line">			err_ret(<span class="string">"couldn't execute: %s"</span>, buf);</div><div class="line">			<span class="built_in">exit</span>(<span class="number">127</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">/* parent */</span></div><div class="line">		<span class="comment">// 父进程通过waitpid等待子进程终止，指定等待的进程为参数</span></div><div class="line">		<span class="keyword">if</span> ((pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span>)</div><div class="line">			err_sys(<span class="string">"waitpid error"</span>);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%% "</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h2><p>当UINX系统函数出错时,通常会返回一个负值,而且整型变量 errno通常被设置为具有特定 信息的值。</p>
<p>对于 errno应应当注意两条规则<br>第一条规则是:如果没有出错,其值不会被例程清除。因此,仅当函数的返回值指明出错时,才检验其值。<br>第二条规则是:任何函数都不会将errn值设置为0,而且在&lt; errno.h&gt;中定义的所有常量都不为0</p>
<p>出错恢复</p>
<p>可将在&lt; errno.h&gt;中定义的各种出错分成两类:<strong>致命性的和非致命性的</strong>。对于致命性的错误, 无法执行恢复动作。最多能做的是在用户屏幕上打印出一条出错消息或者将一条出错消息写入日 志文件中,然后退出。对于非致命性的出错,有时可以较妥善地进行处理。大多数非致命性出错 是暂时的(如资源短缺),当系统中的活动较少时,这种出错很可能不会发生。</p>
<h2 id="用户标识"><a href="#用户标识" class="headerlink" title="用户标识"></a>用户标识</h2><h3 id="用户ID"><a href="#用户ID" class="headerlink" title="用户ID"></a>用户ID</h3><p>向系统标识各个不同的用户，用户ID为0的用户为根用户（root）或者超级用户（superuser）</p>
<h3 id="组ID"><a href="#组ID" class="headerlink" title="组ID"></a>组ID</h3><p>口令文件登录项包括用户的组ID（group ID），为一个数值。</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号( signal)用于通知进程发生了某种情况。进程有以下3种处理信号的方式。<br>(1)忽略信号。有些信号表示硬件异常,例如,除以0或访问进程地址空间以外的存储单元 等,因为这些异常产生的后果不确定,所所以不推荐使用这种处理方式。<br>(2)按系统狀认方式处理。对于除数为0,系统默认方式是终止该进程。<br>(3)提供一个函数,信号发生时调用该函数,这被称为捕捉该信号。通过提供自编的函数, 我们就能知道什么时候产生了信号,并按期望的方式处理它。</p>
<p>很多情况都会产生信号。终端键盘上有两种产生信号的方法,分别称为中断健( interrupt 通常是 Delete键或Ctl+C)和退出键( quit key,通常是Curl+4),它们被用于中断当前运行的进程。 另一种产生信号的方法是调用kill函数。在一个进程中调用此函数就可向另一个进程发送一个信 号。当然这样做也有些限制:当向一个进程发送信号时,我们必须是那个进程的所有者或者是超级 用户。</p>
<blockquote>
<p>能够处理终端的shell实例</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>	<span class="title">sig_int</span><span class="params">(<span class="keyword">int</span>)</span></span>;		<span class="comment">/* our signal-catching function */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span>	buf[MAXLINE];	<span class="comment">/* from apue.h */</span></div><div class="line">	<span class="keyword">pid_t</span>	pid;</div><div class="line">	<span class="keyword">int</span>		status;</div><div class="line"></div><div class="line">	<span class="comment">// 调用sinal函数，指定当产生SIGINT信号时，调用sig_int函数</span></div><div class="line">	<span class="keyword">if</span> (signal(SIGINT, sig_int) == SIG_ERR)</div><div class="line">		err_sys(<span class="string">"signal error"</span>);</div><div class="line"></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%% "</span>);	<span class="comment">/* print prompt (printf requires %% to print %) */</span></div><div class="line">	<span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</div><div class="line">		<span class="keyword">if</span> (buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">'\n'</span>)</div><div class="line">			buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">/* replace newline with null */</span></div><div class="line"></div><div class="line">		<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</div><div class="line">			err_sys(<span class="string">"fork error"</span>);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;		<span class="comment">/* child */</span></div><div class="line">			execlp(buf, buf, (<span class="keyword">char</span> *)<span class="number">0</span>);</div><div class="line">			err_ret(<span class="string">"couldn't execute: %s"</span>, buf);</div><div class="line">			<span class="built_in">exit</span>(<span class="number">127</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">/* parent */</span></div><div class="line">		<span class="keyword">if</span> ((pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span>)</div><div class="line">			err_sys(<span class="string">"waitpid error"</span>);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%% "</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">sig_int</span><span class="params">(<span class="keyword">int</span> signo)</span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"interrupt\n%% "</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="时间值"><a href="#时间值" class="headerlink" title="时间值"></a>时间值</h2><p>历史上,UNIX系统使用过两种不同的时间值。<br>(1)日历时间。该值是自协调世界时( Coordinated Universal Time, UTC)1970年1月1日 00\:00:00这个特定时间以来所经过的秒数累计值(早期的手册称UTC为格林尼治标准时间)。这 些时间值可用于记录文件最近一次的修改时间等。 系统基本数据类型 time_t用于保存这种时间值<br>(2)进程时间。也被称为CPU时间,用以度量进程使用的中央处理器资源。进程时间以时钟滴答计算。每秒钟曾经取为50、60或100个时钟滴答。 系统基本数据类型clock_t保存这种时间值。</p>
<p>当度量一个进程的执行时间时,UNIX系统为一个进程维护了3个进程时间值: </p>
<ul>
<li>时钟时间 ,时钟时间又称为墙上时钟时间( wall clock time),它是进程运行的时间总量,其值与系统 中同时运行的进程数有关。</li>
<li>用户CPU时间,用户CPU时间是执行用户指令所用的时间量。</li>
<li>系统CPU时间 ，系统CPU时间是为该进程执行内核程序所经 历的时间。</li>
</ul>
<p>例如,每当一个进程执行一个系统服务时,如read或wrte,在内核内执行该服务所花费的时间就计入该进程的系统CPU时间。用户CPU时间和系统CPU时间之和常被称为CPU 时间。</p>
<h2 id="系统调用和函数库"><a href="#系统调用和函数库" class="headerlink" title="系统调用和函数库"></a>系统调用和函数库</h2><p>所有的操作系统都有提供多种服务的入口点，这些入口点被称为系统调用（system call）</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_6_1517923519865.jpg" alt="enter description here"></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[APUE 笔记目录]]></title>
      <url>/2018/02/05/APUE-%E7%AC%94%E8%AE%B0%E7%9B%AE%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>APUE是《Unix环境高级编程》的简称，在此立flag：大三把这本书啃完，完成笔记</p>
<a id="more"></a>
<p>第1章 <a href="/2018/02/06/APUE-Unix-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">Unix 基础知识</a></p>
<p>第2章 <a href="">Unix 标准及实现</a>（待整理）</p>
<p>第3章 <a href="/2018/03/06/APUE-%E6%96%87%E4%BB%B6I-O/">文件 I/O</a></p>
<p>第4章 <a href="/2018/04/26/APUE-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/">文件和目录</a></p>
<p>第5章 <a href="/2018/04/27/APUE-%E6%A0%87%E5%87%86I-O%E5%BA%93/">标准I/O库</a></p>
<p>第6章 <a href="/2018/04/28/APUE-%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E4%BF%A1%E6%81%AF/">系统数据文件和信息</a></p>
<p>第7章 <a href="/2018/04/29/APUE-%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/">进程环境</a></p>
<p>第8章 <a href="/2018/04/30/APUE-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/">进程控制</a></p>
<p>第9章 <a href="/2018/05/01/APUE-%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/">进程关系</a></p>
<p>第10章 <a href="/2018/04/18/APUE-%E4%BF%A1%E5%8F%B7/">信号</a></p>
<p>第11章 <a href="/2018/05/02/APUE-%E7%BA%BF%E7%A8%8B/">线程</a></p>
<p>第12章 <a href="/2018/05/02/APUE-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/">线程控制</a></p>
<p>第13章 <a href="/2018/05/04/APUE-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/">守护进程</a></p>
<p>第14章 <a href="/2018/05/04/APUE-%E9%AB%98%E7%BA%A7I-O/">高级I/O</a></p>
<p>第15章 <a href="/2018/05/04/APUE-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">进程间通信</a></p>
<p>第16章 <a href="/2018/05/05/APUE-%E7%BD%91%E7%BB%9CIPC%EF%BC%9A%E5%A5%97%E6%8E%A5%E5%AD%97/">网络ICP：套接字</a></p>
<p>第17章 <a href="/2018/05/05/APUE-%E9%AB%98%E7%BA%A7%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">高级进程间通信</a></p>
<p>第18章 <a href="/2018/05/05/APUE-%E7%BB%88%E7%AB%AFI-O/">终端I/O</a></p>
<p>第19章 <a href="/2018/05/05/APUE-%E4%BC%AA%E7%BB%88%E7%AB%AF/">伪终端</a></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> APUE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《计算机网络——自顶向下方法》 笔记]]></title>
      <url>/2018/02/05/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B-%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>阅读《计算机网络——自顶向下方法》过程中的笔记，持续更新中。</p>
<a id="more"></a>
<h1 id="计算机网络和因特网"><a href="#计算机网络和因特网" class="headerlink" title="计算机网络和因特网"></a>计算机网络和因特网</h1><h2 id="什么是因特网"><a href="#什么是因特网" class="headerlink" title="什么是因特网"></a>什么是因特网</h2><h3 id="具体构成描述"><a href="#具体构成描述" class="headerlink" title="具体构成描述"></a>具体构成描述</h3><p>端系统通过<strong>通信链路</strong>( communication link)和和<strong>分组交换机</strong>( packet switch)连接到一 起。</p>
<p>不同的链路能够以不同的速率传输 数据,链路的传输速率以<strong>比特/秒</strong>度量(bit/s,或bps)，当一台端系统要向另一台端系统 发送数据时,发送端系统将数据分段,并为每段加上首部字节。由此形成的信息包用计算 机网络的术语来说称为<strong>分组</strong>( packet)。</p>
<p>分组交换机从它的一条入通信链路接收到达的分组,并从它的一条出通信链路转发该分组。两种最著 名的类型是<strong>路由器</strong>( router)和<strong>链路层交换机</strong>(link- layer switch)。这两种类型的交换机朝 着最终目的地转发分组。链路层交换机通常用于接入网中,而路由器通常用于网络核心 中。</p>
<p>从发送端系统到接收端系统,一个分组所经历的一系列通信链路和分组交换机称为通 过该网络的<strong>路径</strong>( route或path)。</p>
<p>端系统通过<strong>因特网服务提供商</strong>( Internet Service Provider,SP)接人因特网,每个ISP是一个由多个分组交换机和多段通信 链路组成的网络。各ISP为端系统提供了各种不同类型的网络接入</p>
<p>端系统、分组交换机和其他因特网部件都要运行一系列协议( protocol),这些协议 控制因特网中信息的接收和发送。TCP( Transmission Control Protocol,传输控制协议) 和IP( Internet Protocol,网际协议)是因特网中两个最为重要的协议。</p>
<h3 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h3><blockquote>
<p>人类活动类比</p>
</blockquote>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517720029036.jpg" alt="enter description here"></p>
<blockquote>
<p>网络协议</p>
</blockquote>
<p>协议定义了在两个或多个通信实体之间交换的报文格式和次序,以及报文发送和/或接收一条报文或其他事件所采取的动作。</p>
<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p>通常把与因特网相连的计算机和其他设备称为端系 统。如图1-3所示,因为它们位于因特网的边缘,故而被称为端端系统。</p>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>网络核心,即由互联因特网端系统的<strong>分组交换机</strong>和<strong>链路</strong>构成的网状网络</p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>在各种网络应用中,端系统彼此交换<strong>报文</strong>( message)。为了从源端系统向目 的端系统发送一个报文,源将长报文划分为较小的数据块,称之为<strong>分组</strong>( packet)。在源和 目的之间,每个分组都通过<strong>通信链路和分组交换机</strong>( packet switch)(交换机主要有两类 路由器和链路层交换机)传送。</p>
<blockquote>
<p>存储转发传输</p>
</blockquote>
<p>多数分组交换机在链路的输入端使用<strong>存储转发传输</strong>( store-and- forward transmission ）机制。存储转发机制是指在交换机能够开始向输出链路传输该分组的第一个比特之前,必 须接收到整个分组。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517733216783.jpg" alt="enter description here"></p>
<blockquote>
<p>排队时延和分组丢失</p>
</blockquote>
<p>每个分组交换机有多条链路与之相连。对于每条相连的链路,该分组交换机具有一个 <strong>输出缓存</strong>( output buffer)(也称为输出队列 output queue),它用用于存储路由器准备发往那 条链路的分组。该输出缓存在分组交换中起着重要的作用。如果到达的分组需要传输到某 条链路,但发现该链路正忙于传输其他分组,该到达分组必须在该输出缓存中等待。</p>
<p>除了存储转发时延之外，分组还要承受输出缓存的<strong>排队时延</strong>（queue delay）</p>
<p>一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。在此情况下,将出现<strong>分组丢失(丢包)</strong>( packet lost),到达的分组或已经排队的分组之一将被丢弃。</p>
<blockquote>
<p>转发表和路由选择协议</p>
</blockquote>
<p>每台路由器具有一个<strong>转发表</strong> ( forwarding table),用于将目的地址(或目的地址的一部分)映射成为输出链路。</p>
<h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>在电路交换网络中,在端系统间通信会话期间,预留了端系统间通信沿路径所需要的 资源(缓存,链路传输速率)。在分组交换网络中,这些资源则不是预留的;会话的报文 按需使用这些资源,其后果可能是不得不等待(即    排队)接入通信线路。</p>
<blockquote>
<p>电路交换网络中的复用</p>
</blockquote>
<p>链路中的电路是通过<strong>频分复用</strong>( Frequency- Division Multiplexing,FDM)或<strong>时分复用</strong> (Time- Division Multiplexing,TDM)来实现的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517733959077.jpg" alt="enter description here"></p>
<h2 id="分组交换网中的时延、丢包和吞吐量"><a href="#分组交换网中的时延、丢包和吞吐量" class="headerlink" title="分组交换网中的时延、丢包和吞吐量"></a>分组交换网中的时延、丢包和吞吐量</h2><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><blockquote>
<p>时延类型</p>
</blockquote>
<p>处理时延+排队时延+传输时延+传播时延</p>
<h3 id="计算机网络中的吞吐量"><a href="#计算机网络中的吞吐量" class="headerlink" title="计算机网络中的吞吐量"></a>计算机网络中的吞吐量</h3><p>在任何时间瞬间 的<strong>瞬时吞吐量</strong>( instantaneous throughput)是主机B接收到该文件的速率(以bps计)。</p>
<p>如果该文件由F比特组成,主机B接收到所有F比特用去T秒,则 文件传送的<strong>平均吞吐量</strong>( average throughput)是F/Tbps。</p>
<h2 id="协议层次及其服务模型"><a href="#协议层次及其服务模型" class="headerlink" title="协议层次及其服务模型"></a>协议层次及其服务模型</h2><h3 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517734508197.jpg" alt="enter description here"></p>
<h2 id="面对攻击的网络"><a href="#面对攻击的网络" class="headerlink" title="面对攻击的网络"></a>面对攻击的网络</h2><h3 id="利用网络将有害程序放入你的计算机中"><a href="#利用网络将有害程序放入你的计算机中" class="headerlink" title="利用网络将有害程序放入你的计算机中"></a>利用网络将有害程序放入你的计算机中</h3><p>今天的多数恶意软件是<strong>自我复制</strong>(self- replicating)的:一旦它感染了一台主机,就会 从那台主机寻求进入更多的主机。</p>
<p><strong>病毒</strong>(virus)是一种需要某种形式的用户交 互来感染用户设备的恶意软件。</p>
<p><strong>蠕虫</strong>(worm)是一种无需任何明显用户交互就能进 入设备的恶意软件。</p>
<h3 id="攻击服务器和网络的基础设施"><a href="#攻击服务器和网络的基础设施" class="headerlink" title="攻击服务器和网络的基础设施"></a>攻击服务器和网络的基础设施</h3><p>另一种宽泛类型的安全性威胁称为<strong>拒绝服务攻击</strong>( Denial-of- Service(DoS) attack)。 顾名思义,DoS攻击使得网络、主机或其他基础设施部分不能由合法用户所使用。</p>
<p>大多数DOS攻击属于下列三种类型之一：</p>
<ul>
<li>弱点攻击</li>
<li>带宽洪泛</li>
<li>连接洪泛</li>
</ul>
<p>分布式DoS( Distributed Dos,DDoS)中,攻击者 控制多个源并让每个源向目标猛烈发送流量。使用这种方法,为了削弱或损坏服务器,遍 及所有受控源的聚合流量速率需要大约R的能力。</p>
<h3 id="嗅探分组"><a href="#嗅探分组" class="headerlink" title="嗅探分组"></a>嗅探分组</h3><p>记录每个流经的分组的副本的被动接收机成为<strong>分组嗅探器</strong>（packer sniffer）</p>
<hr>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><p>网络核心设备并不在应用层上 起作用,而仅在较低层起作用,特别是位于网络层及下面层次。这种基本设计,也即将应用软件限制在端系统的方法,促进了大量的网络应用程序的迅速研发和部署。</p>
<h3 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h3><p>应用程序体系结构( application architecture)由应用程序研发者设计, 规定了如何在各种端系统上组织该应用程序。在选择应用用程序体系结构时,应用程序研发 者很可能利用现代网络应用程序中所使用的两种主流体系结构之一:<strong>客户-服务器体系结 构</strong>或<strong>对等(P2P)体系结构</strong>。 </p>
<p>在客戶-服务器体系结构( client- server architecture)中,有一个总是打开的主机称为 服务器,它服务于来自许多其他称为客户的的主机的请求。一个经典的例子是Web应用程序。在一个客户-服务器应用中,常常会出现一台单独的服务器主机跟不上它所有客户请 求的情况。例如,一个流行的社交网络站点如果仅有一台服务器来处理所有请求,将很快 变得不堪重负。为此,配备大量主机的<strong>数据中心</strong>常被用于创建强大的虚拟服务器。</p>
<p>在一个P2P体系结构(P2 2 architecture)中,对位于数据中心的专用服务器有最小 的(或者没有)依赖。相反,应用程序在间断连接的主机对之间使用直接通信,这些 主机对被称为对等方。这些对等方并不为服务提供商所有,相反却为用户控制的桌面机 和膝上机所有,大多数对等方驻留在家庭、大学和办公室。P2P体系结构最引人入胜的特性之一就是他的自扩展性（self-scalability）。</p>
<p>未来P2P应用面临三个主要挑战：</p>
<ul>
<li>ISP友好。大多数住宅ISP(包括DSL和电缆ISP)已经受制于“非对称的”带宽 应用,也就是说,下载比上载要多得多。但是P2P视频流和文件分发应用改变了 从服务器到住宅ISP的上载流量,因而给ISP带来了巨大压力。</li>
<li>安全性。因为它们的高度分布和开放特性,P2P应用给安全带来挑战</li>
<li>激励。未来P2P应用的成功也取决于说服用户自愿向应用提供带宽、存储和计算 资源,这对激励设计带来挑战</li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>在操作系统的术语中,进行通信的实际上是进程( process)而不是程 序。一个进程可以被认为是运行在端系统中的一个程序。</p>
<p>在两个不同端系统上的进程,通过跨越计算机网络交换报文( message)而相互通信。 发送进程生成并向网络中发送报文;接收进程接收这些报文并可能通过将报文发送回去进 行响应。</p>
<blockquote>
<p>客户和服务器进程</p>
</blockquote>
<p>对每对通信进程, 我们通常将这两个进程之一标识为客户( cient),而另一个进程标识为服务器( server) 。</p>
<p>在P2P文件共享的某些应用中,一个进程能够既是客户又是服 务器。在P2P文件共享系统中,一个进程的确既能上载文件又能下载文件。</p>
<blockquote>
<p>进程与计算机网络之间的接口 </p>
</blockquote>
<p>多数应用程序是由通信进程对组成,每对中的两个进程互相发送报文。从 一个进程向另一个进程发送的报文必须通过下面的网络。进程通过一个称为套接字( socket) 的软件接口向网络发送报文和从网络接收报文。</p>
<p>由于该套接字是建立网络应用程序的可编程接口,因此套接字也 称为应用程序和网络之间的应用程序编程接口( Application Programming Interface,API)。</p>
<blockquote>
<p>进程寻址</p>
</blockquote>
<p>为了标识接受进程，需要两种信息：主机地址；定义在目的主机中的接收进程的标识符</p>
<p>在因特网中，主机由其IP地址标识，端口号用于标识后者。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517797198782.jpg" alt="enter description here"></p>
<h3 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h3><blockquote>
<p>可靠数据传输</p>
</blockquote>
<p>需要可靠数据传输的应用,必须做一些工作以确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端 ，如果一个协议提供了这样的确保数据交付服务,就认为提供了可靠数据传输( reliable data transfer)。</p>
<p> 当一个运输层协议不提供可靠数据传输时,由发送进程发送的某些数据可能不能够到 达接收进程。这可能能被容忍丢失的应用(los- tolerant application)所接受,最值得注意 的是多媒体应用,如交谈式音频/视频,它们能够承受一定量的数据丢失。</p>
<blockquote>
<p>吞吐量</p>
</blockquote>
<p>具有吞吐量要求的应用程序被称为 <strong>带宽敏感的应用</strong>( bandwidth- sensitive application)。许多当前的多媒体应用是带宽敏感的 尽管某些多媒体应用程序可能采用自适应编码技术对数字语音或视频以与当前可用带宽相 匹配的速率进行编码。</p>
<p>带宽敏感的应用具有特定的吞吐量要求,而而<strong>弹性应用</strong>( elastic application)能够根据 情况或多或少地利用可供使用的吞吐量。</p>
<blockquote>
<p>定时</p>
</blockquote>
<p>运输层协议能提供定时保证，</p>
<blockquote>
<p>安全性</p>
</blockquote>
<p>运输协议能够为应用程序提供一种或者多种安全性服务</p>
<h3 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h3><p>因特网(更一般的是TCP/P网络络)为应用程序 提供两个运输层协议,即UDP和TCP。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517797561137.jpg" alt="enter description here"></p>
<blockquote>
<p>TCP服务</p>
</blockquote>
<p>TCP服务模型包括面向连接服务和可靠数据传输服务：</p>
<ul>
<li>面向连接的服务:在应用层层数据报文开始流动之前,TCP让客户和服务器互相交 换运输层控制信息。这条连接是全双工的,即连接双方的进程可以在此连接 上同时进行报文收发。当应用程序结束报文发送时,必须拆除该连接。</li>
<li><p>可靠的数据传送服务:通信进程能够依靠TCP,<strong>无差错、按适当顺序交付</strong>所有发 送的数据。</p>
<p>TCP协议还具有拥塞控制机制,这种服务不一定能为通信进程带来直接好处,但能为 因特网带来整体好处。</p>
</li>
</ul>
<blockquote>
<p>TCP 安全</p>
</blockquote>
<p>无论TCP还是UDP都没有提供任何加密机制,这就是说发送进程传进其套接字的 数据,与经网络传送到目的进程的数据相同。</p>
<p>因特网界已经经研制了TCP的加强版 本,称称为安全套接字层( Secure Sockets Layer,SSL)。用SSL加强后的TCP不仅能够做 传统的TCP所能做的一切,而且提供了关键的进程到进程的安全性服务,包括加密、数 据完整性和端点鉴别。</p>
<blockquote>
<p>UDP 服务</p>
</blockquote>
<p>UDP是一种不提供不必要服务的轻量级运输协议,它仅提供最小服务。UDP是无连 接的,因此在两个进程通信前没有握手过程。UDP协议提供一种不可靠数据传送服务,也 就是说,当进程将一个报文发送进UDP套接字时,UDP协议并不保证该报文将到达接收 进程。不仅如此,到达接收进程的报文也可能是乱序到达的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517798026139.jpg" alt="enter description here"></p>
<h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p>应用层协议( application- layer protocol)定义了运行在不同 端系统上的应用程序进程如何相互传递报文。有些应用层协议是由RFC文档定义的,因此它们位于公共域中。例如,Web的应用</p>
<h2 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h2><p>Web是一个引起公众注意的因特网应用,它极大地改变了人们与工作环境内外交流的方式。它将因特网从只是很多数据网之一的地位提升为仅有的一个数据网。 也许对大多数用户来说,最具有吸引力的就是Web的按需操作。</p>
<h3 id="HTTP-概况"><a href="#HTTP-概况" class="headerlink" title="HTTP 概况"></a>HTTP 概况</h3><p>Web的应用层协议是超文本传输协议( Hypertext Transfer Protocol,HTTP),它是Web 的核心。HTTP由两个程序实现:一个客户程序和一个服务器程序。</p>
<p>HTTP使用TCP作为它的支撑运输协议 (而不是在UDP上运行)。HTTP客户首先发起 个与服务器的TCP连接。</p>
<p>因为HTP服务器并不保存关于客户的任何信息,所 以我们说HTTP是一个无状态协议议( stateless protocol)。</p>
<h3 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h3><p>每个请求/响应对是经一个单独的TCP连接发送,还是所有的请求及其响应经相同的TCP连接发送 ?采用前一种方法,该应用程序被称为使用<strong>非持续连接</strong>(non- persistent connection);采用后一种方法,该应用程序被称为使用<strong>持续连接</strong>( persistent connection)。</p>
<p>HTTP在其默认方式下使用持续连接，HTTP客户和服务器也能配置成使用非持续连接</p>
<p>非持续连接有一些缺点。首先,必须为每一个请求的对象建立和维护一个全新的对于每个这样的连接,在客户和服务器中都要分配TCP的缓冲区和保持TCP变量, 这给Web服务器带来了严重的负担,因为一台Web服务器可能同时服务于数以百计不同 的客户的请求。第二,每一个对象经受两倍RTT的交付时延, 即一个RTT用于创建TCP,另一个RTT用于请求和接收一个对象 </p>
<p>在采用持续连接的情况下,服务器在发送响应后保持该TCP连接打开。在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传送。</p>
<h3 id="HTTP-报文格式"><a href="#HTTP-报文格式" class="headerlink" title="HTTP 报文格式"></a>HTTP 报文格式</h3><blockquote>
<p>请求报文</p>
</blockquote>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517802240900.jpg" alt="enter description here"></p>
<blockquote>
<p>响应报文</p>
</blockquote>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517802525968.jpg" alt="enter description here"></p>
<h3 id="用户和服务器的交互：cookie"><a href="#用户和服务器的交互：cookie" class="headerlink" title="用户和服务器的交互：cookie"></a>用户和服务器的交互：cookie</h3><p>HTTP服务器是无状态的。这简化了服务器的设计,并且允许工程师 们去开发可以同时处理数以千计的TCP连接的高性能Web服务器。然而一个Web站点通 常希望能够识別用户,可能是因为服务器希望限制用户的访回,或者因为它希望把内容与 用户身份联系起来。为此,HTTP使用了 cookie。 它允许 站点对用户进行跟踪。目前大多数商务Web站点都使用了 cookie。</p>
<p> cookie技术有4个组件:<br> ①在HTTP响应报文中的一个 cookie首部 行;<br> ②在HTTP请求报文中的一个 cookie首部行;<br> ③在用户端系统中保留有一个 cookie文 件,并由用户的测览器进行管理;<br> ④位于Web站点的一个后端数据库。</p>
<p> <img src="https://data2.liuin.cn/story-writer/2018_2_5_1517802781498.jpg" alt="enter description here"></p>
<h3 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h3><p> Web缓存器( Web cache)也叫代理服务器( proxy server),它是能够代表 初始Web服务器来满足HTTP请求的网络实体。</p>
<p> <img src="https://data2.liuin.cn/story-writer/2018_2_5_1517802879780.jpg" alt="enter description here"></p>
<h3 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h3><p> HTTP协议有一种机制,允许缓存器证实它的对象是最新的。这种机制就是条件 GET( conditional GET)方法法。如果:①请求报文使用GET方法;并且(②请求报文中包 含一个“If- Modified- Since:”首部行。那么,这个HTTP请求报文就是一个条件GET请 求报文</p>
<h2 id="文件传输协议：FTP"><a href="#文件传输协议：FTP" class="headerlink" title="文件传输协议：FTP"></a>文件传输协议：FTP</h2><p>HTTP和FTP都是文件传输协议,并且有很多共同的特点,例如,它们都运行在TCP 上。然而,这两个应用层协议也有一些重要的区别。其中最显著的就是FTP使用了两个并行的TCP连接来传输文件,一个是<strong>控制连接</strong>( control connection),一个是<strong>数据连接</strong>(data connecton)。</p>
<p>控制连接用于在两主机之间传输控制信息,如用户标识、口令、改变远程目 录的命令以及“存放(put)”和和“获取(get)”文件的命令。数据据连接用于实际发送一个 文件。因为FTP协议使用一个独立的控制连接,所以我们也称FTP的控制信息是带外 (om-oand)传送的。</p>
<p>FTP服务器必须在整个会话期间保留用户的状态（state）</p>
<h2 id="因特网中的电子邮件"><a href="#因特网中的电子邮件" class="headerlink" title="因特网中的电子邮件"></a>因特网中的电子邮件</h2><p>因特网电子邮件系统由3个部分组成：用户代理、邮件服务器和简单邮件传输协议</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517826852365.jpg" alt="enter description here"></p>
<p>邮件服务器形成了电子邮件体系结构的核心。每个接收方(如Bob)在其中的某个邮 件服务器上有一个邮箱( mailbox)。</p>
<p>SMTP是因特网电子邮件中主要的应用层协议</p>
<h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>SMTP是因特网电子邮件应用的核心。如前所述, SMTP用于从发送方的邮件服务器发送报文到接收方的邮件服务器。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517827171046.jpg" alt="enter description here"></p>
<h3 id="与HTTP对比"><a href="#与HTTP对比" class="headerlink" title="与HTTP对比"></a>与HTTP对比</h3><p>这两个协议都用于从一台主机向另一台主机传 送文件:HTTP从Web服务器向Web客户(通常是一个测览器)传送文件(也称为对 象);SMTP从一个邮件服务器向另一个邮件服务器传送文件(即电子邮件报文)。当进行 文件传送时,持续的HTTP和SMTP都使用持续连接。因此,这两个协议有一些共同特征。 然而,两者之间也有一些重要的区别。</p>
<p>首先,<strong>HTTP主要是一个拉协议</strong>( pull protocol), 即在方便的时候,某些人在Web服务器上装载信息,用户使用HTTP从该服务器拉取这些 信息。特别是TCP连接是由想接收文件的机器发起的。另一方面,<strong>SMTP基本上是一个推 协议</strong>( push protocol),即发送邮件服务器把文件推向接收邮件服务器。特别是,这个TCP 连接是由要发送该文件的机器发起的。</p>
<p> 第二个区别就是我们前面间接地提到过的,<strong>SMTP要求每个报文(包括它们的体)使 用7比特ASC2码格式</strong>。如果某报文包含了非7比特ASCⅡ字符(如具有重音的法文 符)或二进制数据(如图形文件),则该报文必须按照7比特ASCⅡ码进行编码。HTP数 据则不受这种限制。 </p>
<p> 第三个重要区别是如何处理一个既包含文本又包含图形(也可能是其他媒体类型)的 文档。HTTP把每个对象封装到它自己的HTP响应报文中 而SMTP则把所有报文对象放在一个报文之中。</p>
<h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><p> 邮件访问使用了一种客户-服务器体系结构，即典型的用户通过在用户端系统上运行的客户程序来阅读电子邮件。</p>
<p> 目前有一些流行的的邮件访问协议,包括第三版的邮局协议( Post Offfice Protocol– Version3,POP3)、因特网邮件访问协议( Internet Mail Access Protocol,IMAP) 以及HTTP。</p>
<p> <img src="https://data2.liuin.cn/story-writer/2018_2_5_1517827622320.jpg" alt="enter description here"></p>
<h2 id="DNS：因特网的目录服务"><a href="#DNS：因特网的目录服务" class="headerlink" title="DNS：因特网的目录服务"></a>DNS：因特网的目录服务</h2><p> 因特网上的主机和人类一样,可以使用多种方式进行标识。主机的一种标识方法是用它 的<strong>主机名</strong>( hostname),这些名字便于记忆也乐于被人们接受。然而,主机名几平没有提供，况且,因为主机名可能由不定长的字母数字 组成,路由器难以处理。由于这些原因,主机也可以使用所谓<strong>IP地址</strong>( IP address)进行</p>
<h3 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h3><p>主机名到IP地址转换的目录服务——域名系统 ( Domain Name System,DNS)。</p>
<p>DNS是:</p>
<ul>
<li>①一个由分层的DNS服务器(DN server)实现的分布式数据库;</li>
<li><p>②一个使得主机能够査询分布式数据库的应用层协议。</p>
<p>DNS通常是由其他应用层协议所使用的,包括HTP、SMTP和FTP,将用户提供的主 机名解析为IP地址。</p>
<p>除了进行主机到IP地址的转换，DNS还提供了一些重要的服务：</p>
<ul>
<li>主机别名</li>
<li>邮件服务器别名</li>
<li>负载分配</li>
</ul>
</li>
</ul>
<h3 id="DNS工作原理概述"><a href="#DNS工作原理概述" class="headerlink" title="DNS工作原理概述"></a>DNS工作原理概述</h3><p>DNS的一种简单设计是在因特网上只使用一个DNS服务器,该服务器包含所有的映 射。在这种集中式设计中,客户直接将所有查询直接发往单一的DNS服务器,同时该 DNS服务器直接对所有的查询客户做出响应。尽管这种设计的简单性非常具有吸引力,但 它不适用于当今的因特网,因为因特网有着数量巨大(并持续增长)的主机这种集中式 设计的问题包括：</p>
<ul>
<li>单点故障( a single point of failure)，如果该DNS服务器崩溃,整个因特网随之 瘫痪! </li>
<li>通信容量( traffic volume)。单个DNS服务器不得不处理所有的DNS查询(用于为 上亿台主机产生的所有HTTP请求报文和电子邮件报文服务)</li>
<li>远距离的集中式数据库( distant centralized database)。单个DNS服务器不可能 “邻近”所有查询客户。如果我们将单台DNS服务器放在纽约市,那那么所有来自 澳大利亚的查询必须传播到地球的另一边边,中间也许还要经过低速和拥塞的链路。 这将导致严重的时延。</li>
<li>维护( maintenance)。单个DNS服务器将不得不为所有的因特网主机保留记录。</li>
</ul>
<p>在单一DNS服务器上运行集中式数据库完全没有可扩展能力。因此，DNS采用了分布式的设计方案：</p>
<ol>
<li>分布式，层次数据库</li>
</ol>
<p>为了处理扩展性问题,DNS使用了大量的DNS服务器,它们以层次方式组织,并且 分布在全世界范围内。没有一台DNS服务器拥有因特网上所有主机的映射。相反,该映射分布在所有的DNS服务器上。大致说来,有3种类型的DNS服务器:<strong>根DNS服务器、 顶级域DNS服务器和权威DNS服务器</strong>。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517829730009.jpg" alt="enter description here"></p>
<p>DNS查询有<strong>递归查询</strong>（recursive query）和<strong>迭代查询</strong>（iterative query）。</p>
<ol>
<li>DNS缓存</li>
</ol>
<p>为了改善时延性能并减 少在因特网上到处传输的DNS报文数量 DNS广泛使用了缓存技术。DNS缓存的原 理非常简单。在一个请求链中,当某DNS服务器接收一个DNS回答(例如,包含主 机名到IP地址的映射)时,它能将该回答 中的信息缓存在本地存储器中</p>
<p>由于主机和IP之间的映射并不是永久的，DNS服务器在一段时间将丢弃缓存信息。</p>
<h3 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h3><p>共同实现DNS分布式数据库的所有DNS服务器存储了<strong>资源记录</strong>( Resource Record, RR),RR提供了主机名到IP地址的映射。每个DNS回答报文包含了一条或多条资源记 录。</p>
<p>资源记录是一个包含了下列字段的4元组：<code>(Name, Value, Type, TTL)</code></p>
<p>TTL是该记录的生存时间,它决定了资源记录应当从缓存中删除的时间。</p>
<p>Name和 Value的值取决于Type: </p>
<ul>
<li>如果Type=A,则Name是主机名, Value是该主机名对应的P地址。因此,一条类型为A的资源记录提供了标准的主机名到IP地址的映射。</li>
<li>如果Type=NS,则Name是个域(如foo.com),而Vaue是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。</li>
<li>如果Type= CNAME,则 Value是别名为Name的主机对应的规范主机名。该记录 能够向查询的主机提供一个主机名对应的规范主机名</li>
<li>如果Type=MX,则 Value是个别名为Name的邮件服务器的规范主机名。</li>
</ul>
<blockquote>
<p>DNS 报文</p>
</blockquote>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517830574331.jpg" alt="enter description here"></p>
<h2 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h2><p>使用P2P体系结 构,对总是打开的基础设施服务器有最小的的(或者没有)依赖。与之相反,成对间歇连接 的主机(称为对等方)彼此直接通信。这些对等方并不为服务提供商所拥有,而是受用户 控制的桌面计算机和膝上计算机</p>
<h3 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h3><p>在客户-服务器文件分发中,该服务器必须向每个对等方发送该文件的一个副本,即服务 器承受了极大的负担,并且消消耗了大量的服务器带宽。在P2P文件分发中,每个对等方能 够重新分发它所有的该文件的任何部分,从而在分发过程程中协助该服务器。</p>
<p>到2012年止, 最为流行的P2P文件共享协议是 Bit Torrent。</p>
<blockquote>
<p>P2P体系结构的扩展性</p>
</blockquote>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517830919354.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517830933673.jpg" alt="enter description here"></p>
<blockquote>
<p>BitTorrent</p>
</blockquote>
<p>Bit Torrent是一种用于文件分发的流行P2P协议。用 Bittorrent的术语来 讲,参与一个特定文件分发的所有对等方的集合被称为一个<strong>洪流</strong>( torrent)。在一个洪流 中的对等方彼此下载等长度的<strong>文件块</strong>( chunk),典型的块长度为256KB。当一个对等方首次加入一个洪流时,它没有块。随着时间的流逝,它累积了越来越多的块。当它下载块 时,也为其他对等方上载了多个块。一旦某对等方获得了整个文件,它也许(自私地)离 开洪流,或(大公无私地)留在该洪流中并继续向其他对等方上载块。</p>
<p>每个洪流具有一个基础设施结点,称为<strong>追踪器</strong>( tracker)。当一个对等方加入 某洪流时,它向追踪器注册自己,并周期性地通知追踪器它仍在该洪流中。以这种方式, 追踪器跟踪正参与在洪流中的对等方。</p>
<p>对等方会周期性的询问每个邻近的对等方他们所具有的块列表。同时还要解决一些问题：第一,她应当从她的邻居请求哪些块呢?第二,她 应当向哪些向她请求块的邻居发送?</p>
<p>在决定请求哪些块的过程中,每一个对等方使用一种称为<strong>最稀缺优先</strong>( rarest first)的技术。这种技术的思路是,针对她没有的块在她的邻居中决定最 稀缺的块(最稀缺的块就是那些在她的邻居中副本数量最少的块),并首先请求那些最稀 缺的块。这样,最稀缺块得到更为迅速的重新分发,其目标是(大致地)均衡每个块在洪流中的副本数量。</p>
<h2 id="TCP-套接字编程"><a href="#TCP-套接字编程" class="headerlink" title="TCP 套接字编程"></a>TCP 套接字编程</h2><h3 id="UDP套接字编程"><a href="#UDP套接字编程" class="headerlink" title="UDP套接字编程"></a>UDP套接字编程</h3><p>发送进程为分组附上的目的地址是由目的主机的IP地址和目的套接字的端口号组成。</p>
<p>发送方的源地址也是由源主机的IP地址和源套接字的端口号组成</p>
<p>示例程序：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_7_1517978583354.jpg" alt="enter description here"></p>
<p>UDPclient.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 引入socket包，python网络通信的基础</span></div><div class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</div><div class="line"></div><div class="line"><span class="comment"># 提供IP地址（域名）和端口号</span></div><div class="line">serverName = <span class="string">'hostname'</span></div><div class="line">serverPort = <span class="number">12000</span></div><div class="line"></div><div class="line"><span class="comment"># 创建客户套接字，AF_INET表示底层网络使用IPv4，SOCK_DGRAM表示为UDP套接字</span></div><div class="line">clientSocket = socket(AF_INET, SOCK_DGRAM)</div><div class="line">message = raw_input(<span class="string">'Input lowercase sentence'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 向目的套接字发送</span></div><div class="line">clientSocket.sendto(message,(serverName,serverPort))</div><div class="line"></div><div class="line"><span class="comment"># 接收分组，取2048作为缓存输入</span></div><div class="line">modifiedMessage, serverAddress = clientSocket.recvform(<span class="number">2048</span>)</div><div class="line"></div><div class="line">print(modifiedMessage)</div><div class="line">clientSocket.close()</div></pre></td></tr></table></figure></p>
<p>UDPserver.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</div><div class="line"></div><div class="line">serverPort = <span class="number">12000</span></div><div class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</div><div class="line"></div><div class="line"><span class="comment"># 将服务器端口和套接字绑定在一起</span></div><div class="line">serverSocket.bind(<span class="string">''</span>, serverPort)</div><div class="line"></div><div class="line">print(<span class="string">"The server is ready to receive"</span>)</div><div class="line"><span class="keyword">while</span> ture:</div><div class="line">    message, clientAddress = serverSocket.recvform(<span class="number">2048</span>)</div><div class="line">    modifiedMessage = message.upper()</div><div class="line">    serverSocket.sendto(modifiedMessage, clientAddress)</div></pre></td></tr></table></figure></p>
<h3 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h3><p>与UDP不同，TCP是一个面向连接的协议。这意味着客户和服务器能够相互发送数据之前，他们要先握手创建一个TCP连接。</p>
<p>注意两点：<br>第一,与在UDP中的情况一样,TCP服务器在客户试图发起接触前必须作 为进程运行起来。<br>第二,服务器程序必须具有一扇特殊的门,更精确地说是一个特殊的套 接字,该门门欢迎来自运行在任意主机上的客户进程的某些初始接触。使用房子/门来比喻 进程/套接字,有时我们将客户的初始接触称为“敲欢迎之门”。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_7_1517979977215.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_7_1517980098223.jpg" alt="enter description here"></p>
<p>TCPclient.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</div><div class="line"></div><div class="line">serverName = <span class="string">'servername'</span></div><div class="line">serverPort = <span class="number">12000</span></div><div class="line"></div><div class="line">clientSocket = socket(AF_INET, SOCK_STREAM)</div><div class="line"><span class="comment"># 不同之处，传输数据之前要先进行连接</span></div><div class="line">clientSocket.connect((serverName, serverPort))</div><div class="line"></div><div class="line">sentence = raw_input(<span class="string">'Input lowercase sentence'</span>)</div><div class="line">clientSocket.send(sentence)</div><div class="line">modifiedSentence = clientSocket.recv(<span class="number">1024</span>)</div><div class="line"></div><div class="line">print(<span class="string">"From server:"</span>, modifiedSentence)</div><div class="line">clientSocket.close()</div></pre></td></tr></table></figure></p>
<p>TCPserver.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</div><div class="line"></div><div class="line">serverPort = <span class="number">12000</span></div><div class="line"><span class="comment"># 创建TCP套接字</span></div><div class="line">serverSocket = socket(AF_INET, SOCK_STREAM)</div><div class="line"></div><div class="line"><span class="comment"># serverSocket 是我们的欢迎套接字</span></div><div class="line">serverSocket.bind(<span class="string">''</span>, serverPort)</div><div class="line">serverSocket.lisetn(<span class="number">1</span>)</div><div class="line">print(<span class="string">"The server is ready to receive"</span>)</div><div class="line"></div><div class="line"><span class="keyword">while</span> ture:</div><div class="line">    <span class="comment"># 当客户端敲门时，创建一个服务的新套接字</span></div><div class="line">    connectionSocket ,addr = serverSocket.accept()</div><div class="line">    sentence = connectionSocket.recv(<span class="number">1024</span>)</div><div class="line">    capitalizedSentence = sentence.upper()</div><div class="line">    connectionSocket.sendto(capitalizedSentence)</div><div class="line">    connectionSocket.close()</div></pre></td></tr></table></figure></p>
<h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="概述和运输层服务"><a href="#概述和运输层服务" class="headerlink" title="概述和运输层服务"></a>概述和运输层服务</h2><p>运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信( logic communication)功能。从应用程序的角度看,通过逻辑通信,运行不同进程的主机好像直接相连一样;实际上,这些主机也许位于地球的两侧,通过很多路由器及多种不同类型的链路相连。</p>
<h3 id="运输层和网络层之间的关系"><a href="#运输层和网络层之间的关系" class="headerlink" title="运输层和网络层之间的关系"></a>运输层和网络层之间的关系</h3><p>前面讲过,在协议栈中,运输层刚好位于网络层之上。网络层提供了主机之间的逻辑通信,而运输层为运行在不同主机上的进程之间提供了逻辑通信。</p>
<h3 id="因特网运输层概述"><a href="#因特网运输层概述" class="headerlink" title="因特网运输层概述"></a>因特网运输层概述</h3><p>前面讲过因特网(更一般地讲是一个TCP/IP网络)为应用层提供了两种截然不同的可用运输层协议。这些协议一种是UDP(用户数据报协议),它为调用它的应用程序提供了一种<strong>不可靠、无连接</strong>的服务。另一种是TCP(传输控制协议),它为调用它的应用程序提供了一种<strong>可靠的、面向连接</strong>的服务。当设计一个网络应用程序时,该应用程序的开发人员必须指定使用这两种运输协议中的哪一种。</p>
<p>有些文献中将TCP的运输层分组成为报文段，而讲UDP的分组称为数据报</p>
<p>UDP和TCP最基本的责任是,将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机间交付扩展到进程间交付被称为运输层的多路复用(transport-layer multiplexing)与多路分解( demultiplexing)</p>
<p>TCP为应用程序提供了几种附加服务。首先,它提供可靠数据传输(reliable data transfer)。通过使用流量控制、序号、确认和定时器,TCP确保<strong>正确地、按序地将数据从发送进程交付给接收进程</strong>。这样,TCP就将两个端系统间的不可靠IP服务转换成了一种进程间的可靠数据传输服务。TCP还提供<strong>拥塞控制</strong>( congestion control)。拥塞控制与其说是一种提供给调用它的应用程序的服务,不如说是一种提供给整个因特网的服务,这是一种带来通用好处的服务。</p>
<h2 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h2><p>我们考虑接收主机怎样将一个到达的运输层报文段定向到适当的套接字。为此目的,每个运输层报文段中具有几个字段。在接收端,<strong>运输层检查这些字段,标识出接收套接字,进而将报文段定向到该套接字</strong>。将运输层报文段中的数据交付到正确的套接字的工作称为<strong>多路分解</strong>( demultiplexing)。</p>
<p>在源主机从不同套接字中收集数据块,并为每个数据块封装上首部信息(这将在以后用于分解)从而生成报文段,然后将报文段传递到网络层,所有这些工作称为多路复用( multiplexing)。</p>
<h2 id="无连接运输：UDP"><a href="#无连接运输：UDP" class="headerlink" title="无连接运输：UDP"></a>无连接运输：UDP</h2><p>有的时候我们需要将上层交给运输层的数据直接交付给下面的网络层，运输层最低限度必须提供一种复用/分解服务,以便在网络层与正确的应用级进程之间传递数据。事实上UDP只是做了运输层协议能够做的最少的事情。</p>
<p>如果应用程序开发人员选择UDP而不是TCP,则该应用程序差不多就是直接与I打交道。</p>
<p>DNS服务就是一个运用咋UDP上的一个应用层的例子，很明显，有些应用更加适用于UDP，原因主要有以下几点：</p>
<ul>
<li>关于何时、发送什么数据的应用层控制更为精细</li>
<li>无需建立连接，这样就不会引入连接的时延，这样就能够达到更快的速度</li>
<li>无连接状态。相比而言，TCP需要在端系统中维护连接状态。此连接状态包括接收和发送缓存、拥塞控制参数以及序号与确认号的参数。所以对数据的利用率将会更高</li>
<li>分组首部开销小。每个TCP报文段都有20字节的首部开销,而UDP仅有8字节的开销。</li>
</ul>
<p>使用UDP也可以进行可靠的数据传输，只不过需要在上层自己进行协议的制定。</p>
<h3 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h3><p><img src="https://data2.liuin.cn/2018-05-12-15261144807382.jpg" alt=""></p>
<h3 id="UDP检验和"><a href="#UDP检验和" class="headerlink" title="UDP检验和"></a>UDP检验和</h3><p>UDP检验和提供了差错检测功能。发送方的UDP对报文段中的所有16比特字的和进行反码运算,求和时遇到的任何溢出都被回卷。得到的结果被放在UDP报文段中的检验和字段。（所有比特字进行求和然后取反码）</p>
<h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p>可靠数据传输这个需求不仅仅在传输层需要，在链路层和应用层同样也需要。</p>
<p>通过可靠数据传输我们要做到的是：传输的数据比特不会受到损坏或者丢失，所有顺序都是按照发送的顺序进行交付的。</p>
<h3 id="构造可靠数据传输协议"><a href="#构造可靠数据传输协议" class="headerlink" title="构造可靠数据传输协议"></a>构造可靠数据传输协议</h3><blockquote>
<p>经完全可靠信道的可靠数据传输: rdt1.0</p>
</blockquote>
<p>考虑最简单的情况，底层的通信是完全可靠的，这个时候就非常简单了。</p>
<p><img src="https://data2.liuin.cn/2018-05-12-15261152126867.jpg" alt=""></p>
<blockquote>
<p>经具有比特差错信道的可靠数据传输: rdt2.0</p>
</blockquote>
<p>底层信道更为实际的模型是分组中的比特可能受损。一般情况下，接收方在接到可能出错的数据的时候使用到的是肯定确认（ACK）或者否定确认（NAK）的机制。这些控制报文使得接收方可以让发送方知道哪些内容被正确接收,哪些内容接收有误并因此需要重复。在计算机网络环境中,基于这样重传机制的可靠数据传输协议称为<strong>自动重传请求（ARQ）协议</strong></p>
<p>ARQ协议还需要另外三种协议来一起协同处理比特差错的情况：</p>
<ul>
<li>差错检测</li>
<li>接受方反馈，接收方发现差错以后要想发送方进行反馈</li>
<li>重传，发送方重传有错误的分组</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-05-12-15261155756074.jpg" alt=""></p>
<p>rdt2.0协议看起来似乎可以运行了,但遗憾的是,它存在一个致命的缺陷。尤其是我们没有考虑到ACK或NAK分组受损的可能性!</p>
<p>考虑到处理ACK或NAK分组受损的3种可能：</p>
<ol>
<li>收到受损的信息以后，返回信息表示信息受损，但是这个返回的信息也可能受损，这样就出现了死循环</li>
<li>增强差错编码，不仅仅能检查错误还能够修复错误，这种情况只能解决只会产生差错不会丢失分组的信道中</li>
<li>第三种方法是,当发送方收到含糊不清的ACK或NAK分组时,只需重传当前数据分组即可。但是这种方法会导致接受方不知道重传的分组是新的还是重传的</li>
</ol>
<p>解决这个新问题的一个简单方法(几乎所有现有的数据传输协议中,包括TCP,都采用了这种方法)是在数据分组中添加一新字段,让发送方对其数据分组编号,即将发送数据分组的序号(sequence number)放在该字段。于是,接收方只需要检查序号即可确定收到的分组是否一次重传。（通过给分组添加需要判断新的分组是否是重传过来的分组）</p>
<blockquote>
<p>经具有比特差错的丢包信道的可靠数据传输: rdt3.0</p>
</blockquote>
<p>现在假定除了比特受损外,<strong>底层信道还会丢包</strong>,这在今天的计算机网络(包括因特网)中并不罕见。协议现在必须处理另外两个关注的问题:怎样检测丢包以及发生丢包后如何进行处理</p>
<p>有很多可能的方法用于解决丢包问题。这里,我们让发送方负责检测和恢复丢包工作。假定发送方传输一个数据分组,该分组或者接收方对该分组的ACK发生了丢失。在这两种情况下,发送方都收不到应当到来的接收方的响应。如果发送方愿意等待足够长的时间以便确定分组已丢失,则它只需重传该数据分组即可。</p>
<p>我们需要确定的是这个等待时间需要多长？一种方案是使用最坏情况下的最大时延，但是在很多网络中,最坏情况下的最大时延是很难估算的,确定的因素非常少。因此另外一种方案是发送方明智的选择一个比较少的时间，用来判断可能发生了丢包，这种情况下可能产生冗余数据分组，不过rdt2.2已经能够通过序号的方案对这种情况进行处理</p>
<p><img src="https://data2.liuin.cn/2018-05-12-15261167621172.jpg" alt=""></p>
<h3 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h3><p>rdt3.0是一个功能正确的协议，但是它的性能不是很让人满意，这个性能的核心问题在于它是一个停等协议。</p>
<p>解决这种特殊的性能问题的一个简单方法是:不使用停等方式运行,允许<strong>发送方发送多个分组而无需等待确认</strong>。如果发送方可以在等待确认之前发送3个报文,其利用率也基本上提高3倍。因为许多从发送方向接收方输送的分组可以被看成是填充到一条流水线中,故这种技术被称为流水线(pipelining)。</p>
<p>流水线技术对可靠数据传输协议可带来如下影响</p>
<ul>
<li>必须增加序号范围，每个输送中的分组必须有唯一的一个序号</li>
<li>协议的发送方和接受方必须缓存多个分组</li>
<li>所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是:<strong>回退N步</strong>(Go-Back-NGBN)和<strong>选择重传</strong>( Selective Repeat,SR）</li>
</ul>
<h3 id="回退N步"><a href="#回退N步" class="headerlink" title="回退N步"></a>回退N步</h3><p>在回退N步(GBN)协议中,允许发送方发送多个分组(当有多个分组可用时)而不需等待确认,但它也受限于在流水线中未确认的分组数不能超过某个最大允许数N。</p>
<p>发送方的数据可以划分成4类：已经发送并且已经确认的分组、发送了但是未确认的分组、分配需要即将被发送的分组和没有分配序号的将要发送的分组。</p>
<p>那些已被发送但还未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为N的窗口。随着协议的运行,该窗口在序号空间向前滑动。因此,N常被称为窗口长度( window size),GBN协议也常被称为<strong>滑动窗口协议</strong>(sliding- window protocol)。限制长度的原因是为了流量控制和拥塞控制</p>
<p>GBN发送方必须响应三种类型的事件:</p>
<ol>
<li>上层的调用</li>
<li>收到一个ACK。在GBN协议中,对序号为n的分组的确认采取<strong>累积确认</strong>(cumlative acknowledgment)的方式,表明接收方已正确接收到序号为n的以前且包括n在内的所有分组。</li>
<li>超时事件。协议的名字“回退N步”来源于出现丢失和时延过长分组时发送方的行为。如果出现超时,发送方重传所有已发送但还未被确认过的分组。</li>
</ol>
<p>在GBN协议中,接收方丢弃所有失序分组。尽管丢弃一个正确接收(但失序)的分组有点愚蠢和浪费,但这样做是有理由的。因为数据必须按序交付,接收方可能缓存(保存)分组n+1,然后,在它收到并交付分组n后,再将该分组交付到上层。如果一个分组出现问题，其后面的分组一定都会重传。所以不需要担心这个浪费。</p>
<h3 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h3><p>GBN协议潜在地允许发送方用多个分组“填充流水线”,因此避免了停等协议中所提到的信道利用率问题。然而,GBN本身也有一些情况存在着性能问题。尤其是当窗口长度和带宽时延积都很大时,在流水线中会有很多分组更是如此。<strong>单个分组的差错会导致GBN重传大量分组</strong></p>
<p>顾名思义,选择重传(SR)协议通过让发送方<strong>仅重传那些它怀疑在接收方出错</strong>(即丢失或受损)的分组而避免了不必要的重传。这种个别的、按需的重传要求接收方逐个地确认正确接收的分组。再次用窗口长度N来限制流水线中未完成、未被确认的分组数。</p>
<p><img src="https://data2.liuin.cn/2018-05-12-15261258215113.jpg" alt=""></p>
<p>发送方做的事情：</p>
<ul>
<li>从上层接受数据</li>
<li>超时，定时器再次被用来防止丢失分组。然而,现在每个分组必须拥有其自己的逻辑定时扌器,因为超时发生后只能发送一个分组。</li>
<li>收到ACK，如果收到ACK,倘若该分组序号在窗口内,则SR发送方将那个被确认的分组标记为已接收。如果该分组的序号等于 send base,则窗口基序号向前移动到具有最小序号的未确认分组处。</li>
</ul>
<p>SR接收方将确认一个正确接收的分组而不管其是否按序。失序的分组将被缓存直到所有丢失分组(即序号更小的分组)皆被收到为止,这时才可以将一批分组按序交付给上层。</p>
<h2 id="面向连接的运输：TCP"><a href="#面向连接的运输：TCP" class="headerlink" title="面向连接的运输：TCP"></a>面向连接的运输：TCP</h2><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>TCP被称为是面向连接的( connection- oriented),这是因为在一个应用进程可以开始向另一个应用进程发送数据之前,这两个进程必须先相互“握手”,即它们必须相互发送某些预备报文段,以建立确保数据传输的参数</p>
<p>TCP连接提供的是全双工服务(full-duplex service):如果一台主机上的进程A与另台主机上的进程B存在一条TCP连接,那么应用层数据就可在从进程B流向进程A的同时,也从进程A流向进程B。TCP连接也总是点对点( point-to-point)的,即在单个发送方与单个接收方之间的连接。所谓“多播”,即在一次发送操作中,从个发送方将数据传送给多个接收方,对TCP来说这是不可能的。对于TCP而言,两台主机是一对,而3台主机则太多!</p>
<p>TCP可从缓存中取出并放入报文段中的数据数量受限于最大报文段长度( Maximum Segment Size,MSS)。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度(即所谓的最大传输单元( Maximum transmissionUnit,MTU))来设置。</p>
<p>TCP为每块客户数据配上一个TCP首部,从而形成多个TCP报文段</p>
<h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><p>TCP报文段由首部字段和数据字段组成，数据字段包含的是上层的应用数据。当TCP发送一个大文件时候，会将文件拆分成长度为MSS的若干块。</p>
<p><img src="https://data2.liuin.cn/2018-05-12-15261264828134.jpg" alt=""></p>
<p>上图显示了TCP报文段的结构。与UDP一样,首部包括源端口号和目的端口号,它被用于多路复用/分解来自或送到上层应用的数据。另外,同UDP一样,TCP首部也包括检验和字段( checksum field)</p>
<p>TCP首部还包含以下字段：</p>
<ul>
<li>32比特的序号字段和32比特的确认号字段，用于实现可靠数据传输</li>
<li>16比特的接收窗口字段,该字段用于流量控制</li>
<li>4比特的首部长度字段,该字段指示了以32比特的字为单位的TCP首部长度。</li>
<li>可选与变长的选项字段,该字段用于发送方与接收方协商最大报文段长度(MSS)时,或在高速网络环境下用作窗口调节因子时使用。</li>
<li>6比特的标志字段(flag field)。ACK比特用于指示确认字段中的值是有效的,即该报文段包括一个对已被成功接收报文段的确认。RST、SYN和FIN比特用于连接建立和拆除。当PSH比特被设置的时候,就指示接收方应立即将数据交给上层。最后,URG比特用来指示报文段里存在着被发送端的上层实体置为“紧急”的数据。紧急数据的最后一个字节由16比特的紧急数据指针字段指出。当紧急数据存在并给出指向紧急数据尾的指针的时候,TCP必须通知接收端的上层实体。</li>
</ul>
<blockquote>
<p>序号和确认号</p>
</blockquote>
<p>一个报文段的序号因此是该报文段首字节的字节流编号。TCP采取的是累计确认的机制，发送一个确认号码表示这个序号之前的报文段都收到了</p>
<p>对于失序的报文段有两个选择：①接收方立即丢弃失序报文段(如前所述,这可以简化接收方的设计);②接收方保留失序予的字节,并等待缺少的字节以填补该间隔。后面一种对网络带宽更加有效，所以也应用于实践中。</p>
<h3 id="往返时间估计与超时"><a href="#往返时间估计与超时" class="headerlink" title="往返时间估计与超时"></a>往返时间估计与超时</h3><p>TCP采用超时/重传机制来处理报文段的丢失问题。显然,超时间隔必须大于该连接的往返时间(RTT),即从一个报文段发出到它被确认的时间。否则会造成不必要的重传。</p>
<p>TCP是如何估计发送方与接收方之间往返时间的。这是通过如下方法完成的。报文段的样本RTT(表示为 Samplertt)就是从某报文段被发出(即交给IP)到对该报文段的确认被收到之间的时间量。</p>
<h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><p>TCP在IP不可靠的尽力而为服务之上创建了一种可靠数据传输服务( reliable datatransfer service)。TCP的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏、无间隔、非冗余和按序的数据流;即该字节流与连接的另一方端系统发送出的字节流是完全相同。</p>
<p>TCP发送方主要处理3个事件：</p>
<ol>
<li>从上层应用程序接受数据，将数据封装到一个报文段中，然后交给IP，同时启动定时器</li>
<li>定时器超时，TCP通过重传引起超时的报文段来响应超时事件。然后重启定时器</li>
<li>接受到来自接收方的确认报文段（ACK），TCP采用累积确认</li>
</ol>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>一条TCP连接每一侧主机都为该连接设置了接收缓存。当该TCP连接收到正确、按序的字节后,它就将数据放入接收缓存。相关联的应用进程会从该缓存中读取数据,但不必是数据刚一到达就立即读取。</p>
<p>TCP为它的应用程序提供了流量控制服务(flow-control service)以消除发送方使接收方缓存溢出的可能性。流量控制因此是一个速度匹配服务,即发送方的发送速率与接收方应用程序的读取速率相匹配。</p>
<p>TCP通过让发送方维护一个称为接收窗口( receive window)的变量来提供流量控制通俗地说,接收窗口用于<strong>给发送方一个指示—该接收方还有多少可用的缓存空间</strong>。因为TCP是全双工通信,在连接两端的发送方都各自维护一个接收窗口。</p>
<h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><p>TCP建立连接的三次握手：</p>
<p><img src="https://data2.liuin.cn/2018-05-12-15261279776956.jpg" alt=""></p>
<p>三次握手的原因：</p>
<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
<p>失效的连接请求是指，客户端发送的连接请求在网络中滞留，客户端因为没及时收到服务器端发送的连接确认，因此就重新发送了连接请求。滞留的连接请求并不是丢失，之后还是会到达服务器。如果不进行第三次握手，那么服务器会误认为客户端重新请求连接，然后打开了连接。但是并不是客户端真正打开这个连接，因此客户端不会给服务器发送数据，这个连接就白白浪费了。</p>
<p>TCP断开连接的四次挥手：</p>
<p><img src="https://data2.liuin.cn/2018-05-12-15261285324920.jpg" alt=""></p>
<p>四次挥手的原因：</p>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<blockquote>
<p>TIME_WAIT</p>
</blockquote>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<p>确保最后一个确认报文段能够到达。如果 B 没收到 A 发送来的确认报文段，那么就会重新发送连接释放请求报文段，A 等待一段时间就是为了处理这种情况的发生。</p>
<p>等待一段时间是为了让本连接持续时间内所产生的所有报文段都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文段。</p>
<h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接受，而拥塞控制是为了降低整个网络的拥塞程度。</p>
<p><img src="https://data2.liuin.cn/2018-05-12-15261286729783.jpg" alt=""></p>
<p>TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量。注意拥塞窗口与发送方窗口的区别，拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>
<p><img src="https://data2.liuin.cn/2018-05-12-15261287184076.jpg" alt=""></p>
<blockquote>
<p>慢开始与拥塞避免</p>
</blockquote>
<p>发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p>
<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
<p>如果出现了超时，则令 ssthresh = cwnd/2，然后重新执行慢开始。</p>
<blockquote>
<p>快重传与快恢复</p>
</blockquote>
<p>在接收方，要求每次接收到报文段都应该发送对已收到有序报文段的确认，例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p>
<p>在发送方，如果收到三个重复确认，那么可以确认下一个报文段丢失，例如收到三个 M2 ，则 M3 丢失。此时执行快重传，立即重传下一个报文段。</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行快恢复，令 ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p>
<p><img src="https://data2.liuin.cn/2018-05-12-15261288469140.jpg" alt=""></p>
<hr>
<p># </p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Network </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git 分支]]></title>
      <url>/2018/02/04/Git-%E5%88%86%E6%94%AF/</url>
      <content type="html"><![CDATA[<p>《Pro Git》读书笔记</p>
<p>接触Git这个工具已经很长一段时间了，用起来也是一直是半生不熟的状态，索性寒假有时间就系统的学习一下。选择的是《Pro Git》，讲解得非常详细的。</p>
<a id="more"></a>
<hr>
<p>几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。</p>
<p>Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。</p>
<h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><p>Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。</p>
<p>首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在Git 仓库中这些校验和保存为树对象。</p>
<p>Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。</p>
<p><strong>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。</strong></p>
<p>Git 又是怎么知道当前在哪一个分支上呢？也很简单，它有一个<strong>名为 HEAD 的特殊指针</strong>。请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 HEAD 概念完全不同。在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517735734642.jpg" alt="enter description here"></p>
<blockquote>
<p>分支切换会改变你工作目录中的文件</p>
</blockquote>
<p>在切换分支时，一定要注意你工作目录里的文件会被改变。如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。</p>
<p>由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。</p>
<h2 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h2><p>在切换分支的时候，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。最好的方法是，在你切换分支之前，保持好一个干净的状态。</p>
<p>请牢记：<strong>当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。</strong></p>
<p>在合并的时候，你应该注意到了”快进（fast-forward）”这个词。由于当前 master 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。</p>
<p>另外一种更加普遍的合并情况是：Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的工作祖先（C2），做一个简单的三方合并。</p>
<h3 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h3><p>如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。此时 Git 做了合并，但是没有自动地创建一个新的合并提交。Git 会暂停下来，等待你去解决合并产生的冲突。你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并</p>
<h2 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h2><h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p>在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517736327603.jpg" alt="enter description here"></p>
<h3 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517736357963.jpg" alt="enter description here"></p>
<h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p>在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517736500075.jpg" alt="enter description here"></p>
<p>如上图所示，提取在 C4 中引入的补丁和修改，然后在 C3 的基础上再应用一次。在 Git 中，这种操作就叫做 变基。</p>
<p>它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master）的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。</p>
<h3 id="更有趣的变基例子"><a href="#更有趣的变基例子" class="headerlink" title="更有趣的变基例子"></a>更有趣的变基例子</h3><p>在对两个分支进行变基时，所生成的“重演”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。就像 <strong>从一个特性分支里再分出一个特性分支</strong>的提交历史 中的例子这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rebase --onto master server client</div></pre></td></tr></table></figure>
<p>以上命令的意思是：“取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然后把它们在 master 分支上重演一遍”。这理解起来有一点复杂，不过效果非常酷。</p>
<p>使用 git rebase [basebranch] [topicbranch] 命令可以直接将特性分支（即本例中的 server）变基到目标分支（即 master）上。这样做能省去你先切换到server 分支，再对其执行变基命令的多个步骤。</p>
<h3 id="变基的风险"><a href="#变基的风险" class="headerlink" title="变基的风险"></a>变基的风险</h3><p>奇妙的变基也并非完美无缺，要用它得遵守一条准则：<strong>不要对在你的仓库外有副本的分支执行变基</strong>。</p>
<p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。</p>
<p>只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，你就不会有事。</p>
<h3 id="变基vs合并"><a href="#变基vs合并" class="headerlink" title="变基vs合并"></a>变基vs合并</h3><p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。它是针对历史的文档，本身就有价值，不能乱改。从这个角度看来，改变提交历史是一种亵渎，你使用<em>谎言</em>掩盖了实际发生过的事情。如果由合并产生的提交历史是一团糟怎么办？既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅</p>
<p>。另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的故事</strong>。没人会出版一本书的第一批草稿，软件维护手册也是需要反复修订才能方便使用。持这一观点的人会使用 rebase 及 filter-branch等工具来编写故事，怎么方便后来的读者就怎么写。</p>
<p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 并发编程]]></title>
      <url>/2018/02/03/CSAPP-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第12章笔记</p>
<a id="more"></a>
<p>如果逻辑流在时间上重叠，那么它们就是并发（concurrent）的。并发性不仅仅局限于内核，他也可以在应用中也扮演着重要的角色：</p>
<ul>
<li>在多处理器上进行并行计算</li>
<li>访问慢速I/O设备</li>
<li>与人交互</li>
<li>通过推迟工作以减少执行时间</li>
<li>服务多个网络客户端</li>
</ul>
<p>现代操作系统提供了三种基本的构造并发程序的方法：</p>
<ul>
<li>进程。用这种方法，每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显式的进程间通信(interprocess communication, IPC)机制。</li>
<li>I/O 多路复用。在这种形式的并发编程中，应用程序在一个进程的上下文中显式地调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一个状态。因为程序是一个单独的进程，所以所有的流都共享同一个地址空间。</li>
<li>线程。线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。你可以把线程看成是其他两种方式的混合体，像进程流一样由内核进行调度，而像 I/O 多路复用一样共享同一个虚拟地址空间。</li>
</ul>
<h2 id="基于线程的并发编程"><a href="#基于线程的并发编程" class="headerlink" title="基于线程的并发编程"></a>基于线程的并发编程</h2><p>构造并发程序最简单的方法就是用进程，使用那些大家都很熟悉的函数，像 fork, exec 和 waitpid。</p>
<p>对于在父、子进程间共享状态信息，进程有一个非常清晰的模型：<strong>共享文件表，但是不共享用户地址空间</strong>。进程有独立的地址空间既是优点也是缺点。这样一来，一个进程不可能不小心覆盖另一个进程的虚拟存储器，这就消除了许多令人迷惑的错误。</p>
<p>另一方面，<strong>独立的地址空间使得进程共享状态信息变得更加困难</strong>。为了共享信息，它们必须使用显式的 IPC 机制。基于进程的设计的另一个缺点是，它们往往比较慢，因为进程控制和 IPC 的开销很高。</p>
<h2 id="基于I-O多路复用的并发编程"><a href="#基于I-O多路复用的并发编程" class="headerlink" title="基于I/O多路复用的并发编程"></a>基于I/O多路复用的并发编程</h2><p>I/O 多路复用可以用作并发<strong>事件驱动</strong>(event-driven)程序的基础，在事件驱动程序中，流是因为某种事件而前进的。一般概念是将逻辑流模型化为<strong>状态机</strong>。不严格地说，一个状态机(state machine)就是一组状态(state)、输入事件(input event)和转移(transition)，其中转移就是将状态和输入事件映射到状态。每个状态都将一个(输入状态，输入事件)对映射到一个输出状态。自循环(self-loop)是同一组输入和输出状态之间的转移。通常把状态机花城有向图，其中节点表示状态，有向弧表示转移，而弧上的标号表示输入事件。一个状态机从某种初始状态开始执行。每个输入事件都会引发一个从当前状态到下一状态的转移。</p>
<p>事件驱动设计的一个优点是，它比基于进程的设计给了程序员更多的对程序行为的控制。另一个优点是在流之间共享数据变得很容易，而且事件驱动设计常常比基于进程的设计要高效得多，因为它们不需要进程上下文切换来调度新的流。</p>
<p>事件驱动设计的一个明显的缺点就是编码复杂，另一重大缺点时它们不能充分利用多核处理器。</p>
<h2 id="基于线程的并发编程-1"><a href="#基于线程的并发编程-1" class="headerlink" title="基于线程的并发编程"></a>基于线程的并发编程</h2><p>一个线程（thread）就是运行在一个进程上下文中的一个逻辑流。每个线程都有它自己的<strong>线程上下文</strong>(thread context)，包括一个唯一的整数线程ID(Thread ID, TID)、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。</p>
<p>基于线程的逻辑流结合了基于进程和基于I/O多路复用的流的特点</p>
<h3 id="线程执行模型"><a href="#线程执行模型" class="headerlink" title="线程执行模型"></a>线程执行模型</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517653797354.jpg" alt="enter description here"></p>
<h2 id="多线程程序中的共享变量"><a href="#多线程程序中的共享变量" class="headerlink" title="多线程程序中的共享变量"></a>多线程程序中的共享变量</h2><p>线程很有吸引力的一个方面就是多个线程很容易共享相同的程序变量</p>
<h3 id="线程存储器模型"><a href="#线程存储器模型" class="headerlink" title="线程存储器模型"></a>线程存储器模型</h3><p>一组并发线程运行在一个进程的上下文中。每个线程都有它自己独立的线程上下文，包括线程 ID、栈、栈指针、程序计数器、条件码和通用目的寄存器。每个线程和其他线程一个共享进程上下文的剩余部分。这包括整个用户虚拟地址空间，它是由只读文本(代码)、读/写数据、堆以及所有的共享库代码和数据区域组成的。</p>
<p>从实际操作的角度来说，让一个线程去读写另一个线程的寄存器是不可能的。寄存器不是共享的，而虚拟存储器是共享的。</p>
<h3 id="将变量映射到存储器"><a href="#将变量映射到存储器" class="headerlink" title="将变量映射到存储器"></a>将变量映射到存储器</h3><p>线程化的 C 程序中变量根据它们的存储类型被映射到虚拟存储器：</p>
<ul>
<li>全局变量：在运行时，虚拟存储器的读/写区域只包含每个全局变量的一个实例，任何线程都可以引用</li>
<li>本地自动变量：定义在函数内部但是没有 static 属性的变量。在运行时，每个线程的栈都包含它自己的所有本地自动变量的实例</li>
<li>本地静态变量：定义在函数内部并有 static 属性的变量，和全局变量一样</li>
</ul>
<h2 id="用信号量同步线程"><a href="#用信号量同步线程" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h2><p>共享变量十分方便，但是它们也引入了同步错误（synchronization error）的可能性。</p>
<h3 id="进度图"><a href="#进度图" class="headerlink" title="进度图"></a>进度图</h3><p>一个进度图( progress graph)将个并发线程的执行模型化为一条维笛卡儿空间中的轨线。 每条轴k对应于线程k的进度。每个点(1,2…,n)代表线程k(k=1,,n)已经完成了指令I(k)这一个状态</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517654269007.jpg" alt="enter description here"></p>
<p>一个进度图将指令执行模型化为一个从一种状态到另一种状态的转換( transition)。一个转换被 表示为一条从一点到相邻点的有向边。合法的转换是向右(线程1中的一条指令完成)或者向上(线 程2中的一条指令完成)的。两个指令不能在同一时刻完成一一对角线转換是不允许的。程序决不 会反向运行,所以向下或者向左移动的转换也是不合法的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517654474783.jpg" alt="enter description here"></p>
<p>环绕不安全区的轨线叫做<strong>安全轨线</strong>( safe trajectory)。相反,接触任何不安全区的轨线就叫做<strong>不安全轨线</strong>( unsafe trajectory)。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517654599444.jpg" alt="enter description here"></p>
<p>任何安全轨迹都将正确地更新共享计数器。</p>
<h3 id="利用信号量访问共享变量"><a href="#利用信号量访问共享变量" class="headerlink" title="利用信号量访问共享变量"></a>利用信号量访问共享变量</h3><p>一种经典的解决同步不同执行线程问题的方法：基于一种叫做信号量( semaphore)的特殊类型变量的。信号量s是具有非负整数值的全局变量,只能由两种特殊的操作来处理,这两种操作称为P和V。</p>
<ul>
<li>P(s):如果s是非零的,那么P将s减1,并且立即返回。如如果s为零,那么就挂起进程, 直到s变为非零,并且该进程被一个V操作重启。在重启之后,P操作将s减1,并将控制 返回给调用者。 </li>
<li>V(s):操作将s加1。如果有任何进程阻塞在P操作等待s变成非零,那么V操作会重启 这些进程中的一个,然后该进程将s减1,完成它的P操作</li>
</ul>
<p>P和和V的定义确保了一个运行程序绝不可能进入这样一种状态,也就是一个正确初始化了的信 号量有一个负值。这个属性称为信号量不变性( semaphore invariant),为控制并发程序的轨线而避 免不安全区提供了强有力的工具。 </p>
<p>基本的思想是将每个共享变量(或者相关共享变量集合)与一个信号量s(初始为1)联系起来, 然后用P(s)和W(s)操作将相应的临界区包围起来。以这种方式来保护共享变量的信号量叫做二进制 信号量( binary semaphore),因为它的值总是0或者1。</p>
<h3 id="利用信号量来调度共享资源"><a href="#利用信号量来调度共享资源" class="headerlink" title="利用信号量来调度共享资源"></a>利用信号量来调度共享资源</h3><p>信号量另一个重要的作用是调度对共享资源的访问，一个线程用信号量来通知另一个线程，程序状态中的某个量已经为真了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517654937600.jpg" alt="enter description here"></p>
<h2 id="其他并发性问题"><a href="#其他并发性问题" class="headerlink" title="其他并发性问题"></a>其他并发性问题</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>当我们用线程编写程序时,我们必须小心地编写那些具有称为线程安全性( thread safety)属性 的函数。一个函数被称为线程安全的( thread- safe),当且仅当被<strong>多个并发线程反复地调用时,它会 一直产生正确的结果</strong>。如果一个函数不是线程安全的,我们就说它是线程不安全的( thread-unsafe)。 我们能够定义出四类(有相交的)线程不安全函数:</p>
<ul>
<li>不保护共享变量的函数</li>
<li>保持跨越多个调用的状态的函数</li>
<li>返回指向静态变量的指针函数</li>
<li>调用线程不安全函数的函数</li>
</ul>
<h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>有一类重要的线程安全函数,叫做<strong>可重入函数</strong>( reentrant function),其特点在于它们具有这样 种属性:<strong>当它们被多个线程调用时,不会引用任何共享数据。</strong></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517655306363.jpg" alt="enter description here"></p>
<h3 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h3><p>当一个程序的正确性依赖于一个线程要在另一个线程到达y点之前到达它的控制流中的x点时, 就会发生<strong>竞争</strong>(race)。通常发生竟争是因为程序员假定线程将按照某种特殊的轨线穿过执行状态空 间,而忘记了另一条准则规定定:多线程程序必须对任何可行的轨线都正确工作。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>一组线程被阻塞了，等待一个永远也不会为真的条件</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517655428227.jpg" alt="enter description here"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>无论哪种并发机制，同步对于共享数据的并发访问都是一个困难的问题。提出对信号的 P 和 V 操作就是为了帮助解决这个问题。信号量操作可以用来提供对共享数据的互斥访问，也对诸如生产者-消费者程序中有限缓冲区和读者-写者系统中的共享对象这样的资源访问进行调度。</p>
<p>并发也引入了其他一些困难的问题。被线程调用的函数必须具有一种称为线程安全的属性。竞争和死锁是并发程序中出现的另一些困难的问题。当程序员错误地假设逻辑流该如何调度时，就会发生竞争。当一个流等待一个永远不会发生的事件时，就会产生死锁。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 网络编程]]></title>
      <url>/2018/02/02/CSAPP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第11章笔记</p>
<a id="more"></a>
<p>网络应用随处可见。有趣的是，所有的网络应用都是基于相同的基本编程模型，有着相似的整体逻辑结构，并且一来相同的编程接口。</p>
<p>网络应用依赖于很多在系统研究正已经学习过的概念，例如，进程、信号、字节顺序、存储器映射以及动态存储分配，都扮演着重要的角色。</p>
<h2 id="客户端-服务器编程模型"><a href="#客户端-服务器编程模型" class="headerlink" title="客户端-服务器编程模型"></a>客户端-服务器编程模型</h2><p>每一个网络应用都是基于<code>客户端-服务器模型</code>的，采用这个模型，一个应用是由一个服务器进程和一个或者多个客户端进程组成。服务器管理某种资源，并且通过操作这种资源来为它的客户端提供某种服务。</p>
<p>客户端-服务器模型中的基本操作时<strong>事务（ttansaction）</strong>。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540316932.jpg" alt="enter description here"></p>
<p>认识到客户端和服务器是进程，而不是机器或者主机，这一点很重要。</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>客户端和服务器通常运行在不同的主机上，并且通过<strong>计算机网络</strong>的硬件和软件资源来通信。对于一台主机而言，网络只是又一种 I/O 设备，作为数据源和数据接收方，如下图所示。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540421619.jpg" alt="enter description here"></p>
<p>物理上而言，网络是一个按照地理远近组成的层次系统。最底层是 LAN(Local Area Network, 局域网)，在一个建筑或者校园范围内。迄今为止，最流行的局域网技术是以太网(Ethernet)。</p>
<p>每个以太网适配器都有一个全球唯一的 48 位地址，一台主机可以发送一段位，称为帧(frame)，到这个网段内的其他任何主机。每个帧包括一些固定数量的头部(header)位，用来标识此帧的源和目的地址以及此帧的长度，伺候紧随的就是数据位的有效载荷。每个主机适配器都能看到这个帧，但是只有目的主机实际读取它。</p>
<p>使用一些电缆和叫做网桥(bridge)的小盒子，多个以太网段可以连接成较大的局域网，称为<strong>桥接以太网</strong>(bridged Ethernet)，如下图所示：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540470497.jpg" alt="enter description here"></p>
<p>在层次更高的级别中，多个不兼容的局域网可以通过叫做<strong>路由器</strong>(router)的忒书计算机连接起来，组成一个internet(互联网络)。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540536223.jpg" alt="enter description here"></p>
<p>internet（互联网络）至关重要的特性是，它能采用完全不同和不兼容技术的各种局域网和广域网组成。</p>
<p>在互联网中，数据是如何从一台主机传送到另一台主机的：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540792401.jpg" alt="enter description here"></p>
<h2 id="全球IP因特网"><a href="#全球IP因特网" class="headerlink" title="全球IP因特网"></a>全球IP因特网</h2><p>协议软件消除了不同网络之间的差异，必须具备两种基本能力：命名机制和传送机制。</p>
<p>每台因特网主机都运行实现 <strong>TCP/IP 协议</strong>(Transmission Control Protocol/Internet Protocol)的软件，几乎每个现代计算机系统都支持这个协议。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540858886.jpg" alt="enter description here"></p>
<p>TCP/IP 实际上是一个协议族，其中每一个都提供不同的功能。从程序员角度，我们可以把因特网看做一个世界范围的主机集合，满足以下特性：</p>
<ul>
<li>主机集合被映射为一组 32 位的 IP 地址</li>
<li>这组 IP 地址被映射为一组称为因特网域名(Internet domain name)的标识符</li>
<li>因特网主机上的进程能够通过连接(connection)和任何其他因特网主机上的进程通信</li>
</ul>
<h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p> 一个 IP 地址就是一个 32 位无符号整数。IP 地址通常是以一种称为点分十进制表示法来表示的，这里，每个字节由它的十进制值表示，并且用句点和其他字节间分开。</p>
<h3 id="因特网域名"><a href="#因特网域名" class="headerlink" title="因特网域名"></a>因特网域名</h3><p>域名集合形成了一个层次结构，每个域名编码了它在这个层次中的位置。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540938762.jpg" alt="enter description here"></p>
<p>因特网定义了域名集合和IP地址集合之间的映射，这个映射是通过分布世界范围内的数据库——DNS（域名系统）来维护的。</p>
<h3 id="因特网连接"><a href="#因特网连接" class="headerlink" title="因特网连接"></a>因特网连接</h3><p>因特网客户端和服务器通过在连接上发送和接收字节流来通信。从连接一对进程的意义上而言，连接是点对点的。从数据可以同时双向流动的角度来说，它是全双工的。并且由源进程发出的字节流最终被目的进程以它发出的顺序收到它的角度来说，它是可靠的。</p>
<p><strong>一个套接字是连接的一个端点</strong>。每个套接字都有相应的套接字地址，是由一个因特网地址和一个 16 位的整数端口组成的，用地址:端口来表示。当客户端发起一个连接请求时，客户端套接字地址中的端口是由内核自动分配的，称为临时端口(ephemeral port)。然而，服务器套接字地址中的端口通常是某个知名的端口，是和这个服务相对应的。例如，Web 服务器通常使用端口 80，而电子邮件服务器使用端口 25。在 Unix 机器上，文件 /etc/services 包含一张这台机器提供的服务以及它们的知名端口号的综合列表。</p>
<p>一个连接由它两端的套接字地址唯一确定。这对套接字地址叫做套接字对(socket pair)，由下列元组来表示：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517541075440.jpg" alt="enter description here"></p>
<h2 id="套接字接口"><a href="#套接字接口" class="headerlink" title="套接字接口"></a>套接字接口</h2><p><strong>套接字接口</strong>(socket interface)是一组函数，它们和 Unix I/O 函数结合起来，用以创建网络应用。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517541130564.jpg" alt="enter description here"></p>
<h2 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h2><h3 id="Web基础"><a href="#Web基础" class="headerlink" title="Web基础"></a>Web基础</h3><p>Web 客户端和服务器之间的交互用的是一个基于文本的应用级协议，叫做 HTTP(Hypertext Transfer Protocol)。HTTP 是一个简单的协议。一个 Web客户端打开一个到服务器的因特网连接，并且请求某些内容。服务器响应所请求的内容，然后关闭连接。浏览器读取这些内容，并把它显示在屏幕上。</p>
<h3 id="Web内容"><a href="#Web内容" class="headerlink" title="Web内容"></a>Web内容</h3><p>对于 Web 客户端和服务器而言，内容是一个与 MIME(Multipurpose Internet Mail Extensions)类型相关的字节序列。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517541249812.jpg" alt="enter description here"></p>
<p>Web 服务器以两种不同的方式向客户端提供内容：</p>
<ul>
<li>取一个磁盘文件，并将它的内容返回给客户端。磁盘文件称为静态内容(static content)，而返回文件给客户端的过程称为服务静态内容(serving static content)。</li>
<li>运行一个可执行文件，并将它的输出返回给客户端。运行时可执行文件产生的输出称为动态内容(dynamic content)，而运行程序并返回它的输出到客户端的过程称为服务动态内容(serving dynamic content)。</li>
</ul>
<p>每条由 Web 服务器返回的内容都是和它管理的某个文件相关联的。这些文件中的每一个都有一个唯一的名字，叫做 URL(Universal Resource Locator)。</p>
<p>关于服务器如何解释一个 URL 的后缀，以下几点需要理解：</p>
<ul>
<li>确定一个 URL 指向的是静态内容还是动态内容没有标准的规则。每个服务器对它所管理的文件都有自己的规则。一种常见方法是，确定一组目录，例如 cgi-bin，所有的可执行文件都必须存放这些目录中。</li>
<li>后缀中的最开始的那个 / 不表示 Unix 的根目录。相反，它表示的是被请求内容类型的主目录。例如，可以将一个服务器配置成这样：所有的静态内容存放在目录 /usr/httpd/html 下。</li>
<li>最小的 URL 后缀是 / 字符，所有服务器将其扩展为某个默认的主页，例如 /index.html。这解释了为什么在浏览器中键入一个域名就可以取出一个网站的主页。浏览器在 URL 后添加缺失的 /，之后服务器把 / 扩展到某个默认的文件名。</li>
</ul>
<h3 id="HTTP事务"><a href="#HTTP事务" class="headerlink" title="HTTP事务"></a>HTTP事务</h3><p>因为 HTTP 是基于在因特网连接上传送的文本行的，我们可以使用 Unix 的 TELNET 程序来和因特网上的任何 Web 服务器执行事务。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Web 服务器使用 HTTP 协议和它们的客户端彼此通信。浏览器向服务器请求静态或者动态内容。CGI 标准提供了一组规则，来管理客户端如何将程序参数传递给服务器，服务器如何将这些参数以及其他信息传递给子进程，以及子进程如何将它的输出发送会客户端</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 系统级I/O]]></title>
      <url>/2018/02/01/CSAPP-%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第10章笔记</p>
<a id="more"></a>
<p>输入/输出（I/O）是在主存（memory）和外部设备之间拷贝数据的过程。输入数据是从I/O设备拷贝数据到主存，输出数据是从主存拷贝数据到I/O设备。</p>
<h2 id="Unix-I-O"><a href="#Unix-I-O" class="headerlink" title="Unix I/O"></a>Unix I/O</h2><p>所有的的I/O设备都模型化为文件，而所有的输入和输出都当作相应文件的读和写来执行。</p>
<p>所有的输入输出都以一种统一且一致的方式来执行：</p>
<ul>
<li>打开文件</li>
<li>改变当前的文件位置</li>
<li>读写文件</li>
<li>关闭文件</li>
</ul>
<h2 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h2><p>open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符</p>
<h2 id="读和写文件"><a href="#读和写文件" class="headerlink" title="读和写文件"></a>读和写文件</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_1_1517479720893.jpg" alt="enter description here"></p>
<p><code>read</code>函数从描述符为fd的当前文件位置拷贝至多n个字节到存储器位置buf。</p>
<p><code>write</code> 函数从存储器位置拷贝至多n个字节到描述符fd的当前文件位置</p>
<p>通过调用<code>lseek</code>函数，应用程序能够显式地修改当前文件的位置</p>
<h2 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h2><p>可以用许多不同的方式来共享 Unix 文件。内核用三个相关的数据结构来表示打开的文件：</p>
<ul>
<li><strong>描述符表</strong>(descriptor table)。每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表指向文件表中的一个表项。</li>
<li><strong>文件表</strong>(file table)。打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项包括当前的文件位置、引用计数(reference count)，以及一个指向 v-node 表中对应表项的指针。</li>
<li><strong>v-node 表</strong>(v-node table)。同文件表一样，所有的进程共享这张表。每个表项包含 stat 结构中的大多数信息。</li>
</ul>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_1_1517479945102.jpg" alt="典型的打开文件的内核数据结构"></p>
<p>多个描述符也可以通过不同的文件表表项来引用同一个文件</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_1_1517480013346.jpg" alt="enter description here"></p>
<p>子进程继承父进程打开文件</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_1_1517480058326.jpg" alt="enter description here"></p>
<h2 id="I-O重定向"><a href="#I-O重定向" class="headerlink" title="I/O重定向"></a>I/O重定向</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_1_1517480099251.jpg" alt="enter description here"></p>
<h2 id="我们该使用哪些I-O函数"><a href="#我们该使用哪些I-O函数" class="headerlink" title="我们该使用哪些I/O函数"></a>我们该使用哪些I/O函数</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_1_1517480139110.jpg" alt="enter description here"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Unix 提供了少量的系统级函数，它们允许应用程序打开、关闭、读和写文件，提取文件的元数据，以及执行 I/O 重定向。 Unix 的读和写操作会出现不足值，应用程序必须能正确地预计和处理这种情况。应用程序不应直接调用 Unix I/O 函数，而应该使用 RIO 包，RIO 包通过反复执行读写操作，直到传送完所有的请求数据，自动处理不足值。</p>
<p>Unix 内核使用三个相关的数据结构来表示打开的文件。描述符表中的表项指向打开文件表中的表项，而打开文件表中的表项又指向 v-node 表中的表项。</p>
<p>标准 I/O 库是基于 Unix I/O 实现的，并提供了一组强大的高级 I/O 例程。对于大多数应用程序而言，标准 I/O 更简单，是优于 Unix I/O 的选择。然而，因为对标准 I/O 和网络文件的一些相互不兼容的限制，Unix I/O 比标准 I/O 更适用于网络应用程序。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 虚拟存储器]]></title>
      <url>/2018/01/31/CSAPP-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第9章笔记</p>
<a id="more"></a>
<p>一个系统中的进程是与其他进程共享 CPU 和主存资源的。然而，共享主存会形成一些特殊的挑战。随着对 CPU 需求的增长，进程以某种合理的平滑方式慢了下来。但是如果太多的进程需要太多的存储器，那么它们中的一些就根本无法运行。当一个程序没有空间可用时，那就是它运气不好了。存储器还很容易被破坏。如果某个进程不小心写了另一个进程使用的存储器，它就可能以某种完全和程序逻辑无关的令人迷惑的方式失败。</p>
<p>为了更加有效地管理存储器并且少出错，现代系统提供了一种对主存的抽象概念，叫做<strong>虚拟存储器</strong>(VM)。虚拟存储器是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟存储器提供了三个重要的能力：1）它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。2）它为每个进程提供了一致的地址空间，从而简化了存储器管理。3）它保护了每个进程的地址空间不被其他进程破坏。</p>
<p>虚拟存储器是计算机系统最重要的概念之一。它成功的一个主要原因就是因为它是沉默地、自动地工作的，不需要应用程序员的任何干涉。</p>
<h2 id="物理和虚拟寻址"><a href="#物理和虚拟寻址" class="headerlink" title="物理和虚拟寻址"></a>物理和虚拟寻址</h2><p>计算机系统的主存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的<strong>物理地址</strong>(Physical Address, PA)。第一个字节的地址为 0，接下来的字节地址为 1，再下一个为 2，以此类推。给定这种简单的结构，CPU 访问存储器的最自然的方式就是使用物理地址。我们把这种方式称为<strong>物理寻址</strong>(physical addressing)。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403129993.jpg" alt="enter description here"></p>
<p>现代处理器使用的是一种称为<strong>虚拟寻址</strong>(virtual addressing)的寻址形式</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403182759.jpg" alt="enter description here"></p>
<h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p><strong>地址空间</strong>(address space)是一个非负整数地址的有序集合：{0, 1, 2, …}。如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间(linear address space)。</p>
<p>地址空间的概念是很重要的，因为它清楚地区分了数据对象(字节)和它们的属性(地址)。</p>
<p>允许每个数据对象有多个独立的地址，其中每一个地址都选自一个不同的地址空间。这就是虚拟存储器的基本思想</p>
<h2 id="虚拟存储器作为缓存的工具"><a href="#虚拟存储器作为缓存的工具" class="headerlink" title="虚拟存储器作为缓存的工具"></a>虚拟存储器作为缓存的工具</h2><p>概念上而言，虚拟存储器(VM)被组织为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，这个唯一的虚拟地址是作为到数组的索引的。VM 系统通过将虚拟存储器分割为虚拟页(Virtual Page, VP)的大小固定的块来处理这个问题。每个虚拟页的大小为 P=2^p 字节。类似地，物理存储器被分割为物理页(Physical Page, PP)，大小也为 P 字节(物理页也称为页帧(page frame))。</p>
<p>在任意时刻，虚拟页面的集合部分都分为三个不相交的子集：</p>
<ul>
<li>未分配的：VM 系统还未分配(或者创建)的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。</li>
<li>缓存的：当前缓存在物理存储器中的已分配页。</li>
<li>未缓存的：没有缓存在物理存储器中的已分配页。</li>
</ul>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403393083.jpg" alt="enter description here"></p>
<h3 id="DRAM高速缓存的组织结构"><a href="#DRAM高速缓存的组织结构" class="headerlink" title="DRAM高速缓存的组织结构"></a>DRAM高速缓存的组织结构</h3><p>在存储层次结构中，DRAM缓存的位置对于他的组织结构有很大的影响。DRAM 缓存的组织结构完全是由巨大的不命中开销驱动的。因为大的不命中处罚和访问第一字节的开销，虚拟页往往很大，典型地是4KB-2MB。由于大的不命中处罚，DRAM 缓存是全相连的，也就是说，任何虚拟页都可以放置在任何的物理页中。不命中时的替换策略也很重要，因为替换错了虚拟页的出发也非常高。因此，与硬件对 SRAM 缓存相比，操作系统对 DRAM 缓存使用了更复杂精密的替换算法。最后，因为对磁盘的访问时间很长，DRAM 缓存总是使用写回(write back)，而不是直写。</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>同任何缓存一样，虚拟存储器系统必须有某种方法来判定一个虚拟页是否存放在 DRAM 中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理存储器中选择一个牺牲页，并将虚拟页从磁盘拷贝到 DRAM 中，替换这个牺牲页。</p>
<p>这些功能是由许多软硬件联合提供的，包括操作系统软、MMU(存储器管理单元)中的地址翻译硬件和一个存放在物理存储器中叫做<strong>页表</strong>(page table)的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时都会读取页表。操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。</p>
<p>下图展示了一个页表的基本组织结构。页表就是一个页表条目(Page Table Entry, PTE)的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403685361.jpg" alt="enter description here"></p>
<h3 id="页命中"><a href="#页命中" class="headerlink" title="页命中"></a>页命中</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403740507.jpg" alt="enter description here"></p>
<h3 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h3><p>在虚拟存储器的习惯说法中，DRAM不命中称为<strong>缺页</strong>（page fault）。缺页异常调用内核中缺页异常处理程序，该程序会选择一个牺牲页。在磁盘和存储器之间传送页的活动叫做<strong>交换</strong>(swapping)或者<strong>页面调度</strong>(paging)。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403893776.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403911509.jpg" alt="enter description here"></p>
<h3 id="分配页面"><a href="#分配页面" class="headerlink" title="分配页面"></a>分配页面</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403947855.jpg" alt="enter description here"></p>
<h3 id="局部性再次搭救"><a href="#局部性再次搭救" class="headerlink" title="局部性再次搭救"></a>局部性再次搭救</h3><p>尽管在整个运行过程中程序引用的不同页面的总数可能超出物理存储器总的大小，但是局部性原则保证了在任意时刻，程序往往在一个较小的活动页面(active page)集合上工作，这个集合叫做<strong>工作集</strong>(working set)或者<strong>常驻集</strong>(resident set)。</p>
<p>如果工作集的大小超出了物理存储器的大小，那么程序将产生一种不幸的状态，叫做颠簸（thrashing），这时页面将不断的换进换出。</p>
<h2 id="虚拟存储器作为存储管理的工具"><a href="#虚拟存储器作为存储管理的工具" class="headerlink" title="虚拟存储器作为存储管理的工具"></a>虚拟存储器作为存储管理的工具</h2><p>OS为每个进程提供一个独立的页表，就是一个独立的虚拟地址空间。多个虚拟页面可以映射到同一个共享物理页面上。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404196815.jpg" alt="enter description here"></p>
<h2 id="虚拟存储器作为存储器保护的工具"><a href="#虚拟存储器作为存储器保护的工具" class="headerlink" title="虚拟存储器作为存储器保护的工具"></a>虚拟存储器作为存储器保护的工具</h2><p>任何现代计算机系统都必须为操作系统提供手段来控制对存储器系统的访问。提供独立地址空间使得分离不同进程私有存储器变得容易。地址翻译机制可以以一种自然的方式扩展到提供更好的访问控制。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404420646.jpg" alt="enter description here"></p>
<h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>地址翻译的基础知识：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404559355.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404669578.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404692161.jpg" alt="enter description here"></p>
<h3 id="结合高速缓存和虚拟存储器"><a href="#结合高速缓存和虚拟存储器" class="headerlink" title="结合高速缓存和虚拟存储器"></a>结合高速缓存和虚拟存储器</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404781626.jpg" alt="enter description here"></p>
<h3 id="利用TLB加速地址翻译"><a href="#利用TLB加速地址翻译" class="headerlink" title="利用TLB加速地址翻译"></a>利用TLB加速地址翻译</h3><p>TLB是一个小的、虚拟地址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常有高度的相连性。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404914871.jpg" alt="enter description here"></p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404952385.jpg" alt="enter description here"></p>
<h2 id="存储器映射"><a href="#存储器映射" class="headerlink" title="存储器映射"></a>存储器映射</h2><p>Linux通过将一个 虚拟存储器区域与一个磁盘上的对象关联起来，以初始化这个虚拟存储器区域的内容，这个过程叫存储器映射（memory mapping）<br>虚拟存储器区域可以映射到两种类型的对象：</p>
<ol>
<li>Unix文件系统的普通文件</li>
<li>匿名文件</li>
</ol>
<h3 id="再看共享对象"><a href="#再看共享对象" class="headerlink" title="再看共享对象"></a>再看共享对象</h3><p>存储器映射的概念来源于一个聪明的发现：如果虚拟存储器系统可以集成到传统的文件系统中，那么就能提供一种简单而高效的把程序和数据加载到存储器中的方法。</p>
<p>一个对象可以被映射到虚拟存储器中的一个区域，要么作为共享对象，要么作为私有对象。另一个方面，对于一个映射到私有对象的区域所做的改变，对于其他进程来说是不可见的，而且进程对这个区域所做的任何写操作都不会反映在磁盘的对象中。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517405449818.jpg" alt="enter description here"></p>
<p>私有对象是使用一种写时拷贝（copy-on-write）的巧妙技巧被映射虚拟存储器中的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517405536089.jpg" alt="enter description here"></p>
<h2 id="动态存储器分配"><a href="#动态存储器分配" class="headerlink" title="动态存储器分配"></a>动态存储器分配</h2><p>一个动态存储器分配器维护着一个进程的虚拟存储器区域，称为堆（heap）。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517405624725.jpg" alt="enter description here"></p>
<p>显式分配器要求应用显式地释放任何已经分配的块</p>
<p>隐式分配器要求检测何时一个已分配块不再被使用，然后就释放这个块。隐式分配器也叫做垃圾收集器（garbage collector）</p>
<h3 id="为什么要使用动态存储器分配"><a href="#为什么要使用动态存储器分配" class="headerlink" title="为什么要使用动态存储器分配"></a>为什么要使用动态存储器分配</h3><p>经常直到程序运行时，才知道某些数据结构的大小</p>
<h3 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h3><p>造成堆利用率低的主要原因是碎片（fragmentation），当虽然有未使用的存储器但是不能用来满足分配请求时，就发生这种现象。有两种碎片形式：<strong>内部碎片</strong>（internal fragmentation）和<strong>外部碎片</strong>（external fragmentation）：</p>
<ul>
<li>内部碎片是在一个已分配块比有效载荷大时发生的。</li>
<li>外部碎片是当空闲存储器合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生的。</li>
</ul>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>垃圾收集器（garbage collector）是一种动态存储分配器，它自动释放程序不在需要的已分配块。</p>
<h3 id="垃圾收集器的基本要素"><a href="#垃圾收集器的基本要素" class="headerlink" title="垃圾收集器的基本要素"></a>垃圾收集器的基本要素</h3><p>垃圾收集器将存储器视为一张有向可达图（reachability graph）</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517406251592.jpg" alt="enter description here"></p>
<h2 id="C程序中常见的与存储器相关的错误"><a href="#C程序中常见的与存储器相关的错误" class="headerlink" title="C程序中常见的与存储器相关的错误"></a>C程序中常见的与存储器相关的错误</h2><ul>
<li>间接引用坏指针</li>
<li>读未初始化的存储器</li>
<li>允许栈缓冲区溢出</li>
<li>假设指针和他们指向的对象是相同大小的</li>
<li>造成错位错误</li>
<li>引用指针而不是他们指向的对象</li>
<li>误解指针运算</li>
<li>引用不存在的变量</li>
<li>引用空闲堆块中的数据</li>
<li>引起存储器泄露</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虚拟存储器是对主存的一个抽象，支持虚拟存储器的处理器通过一种叫做虚拟寻址的间接引用来引用主存</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 异常控制流]]></title>
      <url>/2018/01/30/CSAPP-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第8章笔记</p>
<a id="more"></a>
<p>处理器按照一定的序列的地址执行对应的指令，从这一个地址过渡到下一个地址成为控制转移，这样的控制转移序序列称为处理器的控制流（flow control）</p>
<p>系统必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。当子进程终止时，创造这些子进程的父进程必须得到通知。</p>
<p>线代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为<strong>异常控制流</strong>(Exceptional Control Flow, ECF)。异常控制流发生在计算机系统的各个层次。比如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文转换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送信号到另一个进程，而接受者会将控制突然转移到它的一个信号处理程序。一个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常是异常控制流的一种形式，它一部分是由硬件实现的，一部分是由操作系统实现的。因为它们有一部分是由硬件实现的，所以具体细节将随系统的不同而有所不同。然而，对于每个系统而言，基本的思想都是相同的。</p>
<p>异常(exception)就是控制流中的突变，用来响应处理器状态中的某些变化。如下图所示：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517298145936.jpg" alt="enter description here"></p>
<p>在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做<strong>异常表</strong>(exception table)的跳转表，进行一个间接过程调用(异常)，到一個专门设计用来处理这类事件的操作系统子程序(异常处理程序, exception handler)</p>
<p>当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下三种情况中的一种：</p>
<ul>
<li>处理程序将控制返回给当前指令 I(curr)，即当事件发生时正在执行的指令。</li>
<li>处理程序将控制返回给 I(next)，即如果没有发生异常将会执行的下一条指令。</li>
<li>处理程序被中断的程序</li>
</ul>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>系统中可能的每种类型的异常都分配了一个唯一的非负整数的<strong>异常号</strong>(exception number)。其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核的设计者分配的。前者的示例包括被零除、缺页、存储器访问违例以及算术溢出。后者的示例包括系统调用和来自外部 I/O 设备的信号。</p>
<p>在系统启动时，操作系统分配和初始化一张称为异常表的跳转表，使得条目 k 包含异常 k 的处理程序的地址。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517299098759.jpg" alt="enter description here"></p>
<p>异常号是到异常表中的索引，异常表的起始地址放在一个叫做<strong>异常表基址寄存器</strong>(exception table base register)的特殊 CPU 寄存器里。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517299181611.jpg" alt="enter description here"></p>
<h3 id="异常的类别"><a href="#异常的类别" class="headerlink" title="异常的类别"></a>异常的类别</h3><p>异常可以分为四类：中断（interrupt）、陷阱（trap）、故障（fault）和终止（abort）</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517299300222.jpg" alt="enter description here"></p>
<blockquote>
<p>中断</p>
</blockquote>
<p>中断是异步发生的，是来自处理器外部的 I/O 设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序通常称为中断处理程序(interrupt handler)</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517299374198.jpg" alt="enter description here"></p>
<p>剩下的异常类型(陷阱、故障和终止)是同步发生的，是执行当前指令的结果。我们把这类指令叫做故障指令(faulting instruction)。</p>
<blockquote>
<p>陷阱</p>
</blockquote>
<p>陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做<strong>系统调用</strong>。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517299528855.jpg" alt="enter description here"></p>
<blockquote>
<p>故障</p>
</blockquote>
<p>故障由错误情况引起，它可能被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的 abort 例程，abort 例程会终止引起故障的应用程序</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517299611720.jpg" alt="enter description here"></p>
<p>一个经典的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在存储器中，因此必须从磁盘中取出时，就会发生故障。就像我们将在第 9 章中看到的那样，一个页面就是虚拟存储器的一个连续的块。缺页处理程序从磁盘加载适当的页面，然后将控制返回给引起故障的指令。当指令再次执行时，相应的物理页面已经驻留在存储器中了，指令就可以没有故障地运行完成了。</p>
<blockquote>
<p>终止</p>
</blockquote>
<p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 DRAM 或者 SRAM 位被损坏时发生的奇偶错误。终止程序从不将控制返回给应用程序。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517299685578.jpg" alt="enter description here"></p>
<h3 id="Intel处理器中的异常"><a href="#Intel处理器中的异常" class="headerlink" title="Intel处理器中的异常"></a>Intel处理器中的异常</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517299747975.jpg" alt="enter description here"></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>异常是允许操作系统提供<strong>进程</strong>(process)的概念所需要的基本构造块，进程是计算机可续重最深刻最成功的概念之一。当我们在一个现代系统上运行一个程序时，会得到一个假象，就好像我们的程序是系统中当前运行着的唯一的程序。</p>
<p>进程的经典定义就是一个<strong>执行中的程序的实例</strong>。系统中的每个程序都是运行在某个进程的<strong>上下文</strong>(context)中的。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在存储器中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p>
<p>每次用户通过向外壳输入一个可执行目标文件的名字，并运行一个程序时，shell 就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，且在这个新进程的上下文中运行它们自己的代码或其他应用程序。</p>
<h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><p>即使在系统中通常有许多其他程序在运行，进程也可以向每个程序提供一种假象，好像它在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器(PC)的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或者是包含在运行时动态链接到程序的共享对象的指令。这个 PC 值的序列叫做<strong>逻辑控制流</strong>。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517299971390.jpg" alt="enter description here"></p>
<p>进程是轮流使用处理器的，每个进程执行它流中的一部分，然后被抢占（preempted）（暂时挂起），与此同时其他进程开始执行。</p>
<h3 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h3><p>一个逻辑流的执行在时间上与另一个流重叠，称为并发流(concurrent flow)，这两个流被称为并发地运行。更准确地说，流 X 和 Y 互相并发，当且仅当 X 在 Y 开始之后和 Y 结束之前开始，或者 Y 在 X 开始之后和 X 结束之前开始。</p>
<p>多个流并发地执行的一般现象称为<strong>并发</strong>(concurrency)。一个进程和其他进程轮流运行的概念称为<strong>多任务</strong>(multitasking)。一个进程执行它的控制流的一部分的每一时间段叫做<strong>时间片</strong>(time slice)。因此，多任务也叫做时间分片(time slicing)</p>
<p>注意，并发的思想与流运行的处理器核数或者计算机无关。如果两个流再时间上重叠，那么它们就是并发的，即使它们是运行在同一个处理器上的。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为并行流(parallel flow)。</p>
<h3 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h3><p>进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。尽管和每个私有地址空间相关联的存储器的内容一般是不同的，但是每个这样的空间都有相同的通用结构，如下图所示。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517300174690.jpg" alt="enter description here"></p>
<h3 id="用户模式和内核模式"><a href="#用户模式和内核模式" class="headerlink" title="用户模式和内核模式"></a>用户模式和内核模式</h3><p>为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。</p>
<p>处理器通常是用某个控制寄存器中的一个<strong>模式位</strong>(mode bit)来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了模式位，进程就运行在内核模式(超级用户模式)。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中任何存储器位置。</p>
<p>没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行<strong>特权指令</strong>(priviledged instruction)，比如停止处理器、改变位模式，或者发起一个 I/O 操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。</p>
<p>Linux 提供了一种聪明的机制，叫做 /proc 文件系统，它允许用户模式进程访问内核数据结构的内容。/proc文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构。</p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>操作系统内核使用一种称为<strong>上下文切换</strong>(context switch)的较高层形式的异常控制流来实现多任务。上下文切换机制是建立在8.1节中那些较低层异常机制之上的。</p>
<p>内核为每个进程维持一个<strong>上下文</strong>(context)。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描绘地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。</p>
<p>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程。这种决定就叫做<strong>调度</strong>(schedule)，是由内核中称为<strong>调度器</strong>(scheduler)的代码处理的。当内核选择一个新的进程运行时，我们就说内核调度了这个进程。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517300757505.jpg" alt="enter description here"></p>
<h2 id="系统调用和错误处理"><a href="#系统调用和错误处理" class="headerlink" title="系统调用和错误处理"></a>系统调用和错误处理</h2><p>Unix提供大量的系统调用，当应用程序想向内核请求服务时，可以使用这些系统调用。</p>
<p>标准C库提供一组针对最常用系统调用的方便的包装（wrapper）函数。</p>
<p>通过使用错误处理包装（error-handling wrapper）函数，我们可以进一步简化我们的代码。</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="获取进程"><a href="#获取进程" class="headerlink" title="获取进程"></a>获取进程</h3><p>每个进程都有一个唯一的正数进程 ID(PID)。<code>getpid</code> 函数返回调用进程的 PID。<code>getppid</code> 函数返回它的父进程的 PID。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>);</div><div class="line"><span class="keyword">pit_t</span> getppid(<span class="keyword">void</span>);</div></pre></td></tr></table></figure>
<h3 id="创建和终止进程"><a href="#创建和终止进程" class="headerlink" title="创建和终止进程"></a>创建和终止进程</h3><p>从程序员的角度，我们可以认为进程总是处于下面三种状态之一：</p>
<ul>
<li>运行。进程要么在 CPU 上执行，要么在等待被执行且最终会被内核调度。</li>
<li>停止。进程的执行被挂起(suspend)，且不会被调度。当收到 SIGSTOP、SIGTSTP、SIDTTIN 或者 SIGTTOU 信号时，进程就停止，并且保持停止直到它收到一个 SIGCONT 信号，在这个时刻，进程再次开始运行。</li>
<li>终止。进程永远地停止了。进程会因为三种原因终止：1）收到一个默认行为是终止进程的信号，2）从主程序返回，3）调用 exit 函数</li>
</ul>
<p>该程序无返回值，<code>exit</code> 函数以 status 退出来终止进程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</div></pre></td></tr></table></figure>
<p>父进程通过调用 <code>fork</code> 函数创建一个新的运行子进程，子进程返回0，父进程返回子进程的 PID，如果出错则为 -1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</div></pre></td></tr></table></figure>
<p>新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份拷贝，包括文本、数据和 bss 段、以及用户栈。子进程还获得与父进程任何打开文件描述符相同的拷贝。父进程和新创建的子进程最大的区别在于他们有不同的 PID。</p>
<p><code>fork</code> 函数只被调用一次，却会返回两次(父进程与子进程)。因为子进程的 PID 总是非零的，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。</p>
<p>使用<code>fork</code>创建一个新进程：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"csapp.h"</span></span></div><div class="line"><span class="number">2</span> </div><div class="line"><span class="number">3</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">4 &#123;</div><div class="line"><span class="number">5</span> <span class="keyword">pid_t</span> pid;</div><div class="line"><span class="number">6</span> <span class="keyword">int</span> x = <span class="number">1</span>;</div><div class="line"><span class="number">7</span> </div><div class="line"><span class="number">8</span> pid = Fork();</div><div class="line"><span class="number">9</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* Child */</span></div><div class="line"><span class="number">10</span> <span class="built_in">printf</span>(<span class="string">"child : x=%d\n"</span>, ++x);</div><div class="line"><span class="number">11</span> <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line"><span class="number">12</span> &#125;</div><div class="line"><span class="number">13</span></div><div class="line"><span class="number">14</span> <span class="comment">/* Parent */</span></div><div class="line"><span class="number">15</span> <span class="built_in">printf</span>(<span class="string">"parent: x=%d\n"</span>, --x);</div><div class="line"><span class="number">16</span> <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line"><span class="number">17</span> &#125;</div></pre></td></tr></table></figure></p>
<p>这个例子有一些微妙的方面：</p>
<ul>
<li>调用一次，返回两次</li>
<li>并发执行。顺序不能保证</li>
<li>相同但是独立的地址空间，所以变量是分别独立的</li>
<li>共享文件，输出是指向同一个地方</li>
</ul>
<h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一中已终止的状态中，直到被它的父进程回收(reap)。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个终止了但还未被回收的进程称为<strong>僵死进程</strong>(zombie)。</p>
<p>如果父进程没有回收它的僵死子进程就终止了，那么内核就会安排 init 进程来回收它们。init 进程的 PID 为 1，并且是在系统初始化时由内核创建的。长时间运行的程序，比如 shell 或者服务器，总是应该回收它们的僵死子进程。即使僵死子进程没有运行，它们仍然小号系统的存储器资源。</p>
<p>一个进程可以通过调用 <code>waitpid</code> 函数来等待它的子进程终止或者停止。如果成功，则返回子进程的 PID，如果 WHOHANG ，则为 0，如果其他错误，则为 -1。</p>
<h3 id="让进程休眠"><a href="#让进程休眠" class="headerlink" title="让进程休眠"></a>让进程休眠</h3><p><code>sleep</code> 函数让一个进程挂起一段指定的时间。返回还要休眠的秒数。</p>
<p>如果请求的时间量已经到了，<code>sleep</code>返回 0，否则返回还剩下要休眠的秒数。我们会发现很有用的另一个函数是 <code>pause</code> 函数，该函数让调用函数休眠，直到该进程收到一个信号。总是返回 -1。</p>
<h3 id="加载并运行程序"><a href="#加载并运行程序" class="headerlink" title="加载并运行程序"></a>加载并运行程序</h3><p><code>execve</code> 函数在当前进程的上下文中加载并运行一个新程序。如果成功则不返回，如果错误，则返回 -1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *argv[], <span class="keyword">const</span> <span class="keyword">char</span> *envp[])</span></span>;</div></pre></td></tr></table></figure>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_30_1517301875073.jpg" alt="enter description here"></p>
<h3 id="信号术语"><a href="#信号术语" class="headerlink" title="信号术语"></a>信号术语</h3><p>传送一个信号到目的进程是由两个不同步骤组成的：</p>
<ul>
<li><strong>发送信号</strong>。内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。发送信号可以用如下两个原因：1）内核检测到一个系统事件，比如被零除错误或者子进程终止。2）一个进程调用 kill 函数，显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。</li>
<li><strong>接收信号</strong>。当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序(signal handler)的用户层函数捕获这个信号。如下图所示</li>
</ul>
<p>一个只发出而没有被接收的信号叫做待处理信号(pending signal)。在任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为 k 的待处理信号，那么任何接下来发送到这个进程的类型为 k 的信号都不会排队等待，它们只是被简单地丢弃。一个进程可以有选择地阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。</p>
<p>一个待处理信号最多只能被接收一次。内核为每个进程在 pending 位向量中维护着待处理信号的集合，而在 blocked 位向量中维护着被阻塞的信号集合。只要传送了一个类型为 k 的信号，内核就会设置 pending 中的第 k 位，而只要接收了一个类型为 k 的信号，内核就会清除 pending 中的第 k 位。</p>
<h3 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h3><p>Unix 系统提供了大量向进程发送信号的机制。所有这些机制都是基于进程组(process group)这个概念的。</p>
<p>进程组：每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的。<code>getpgrp</code> 函数返回当前进程的进程组 ID。</p>
<p>默认的，一个子进程和它的父进程同属一个进程组。一个进程可以通过使用 <code>setpgid</code> 函数来改变自己或者其他进程的进程组，成功则返回 0，否则返回 -1。</p>
<p>用 /bin/kill 程序发送信号</p>
<p>从键盘发送信号</p>
<p>用 kill 函数发送信号</p>
<p>用 alarm 函数发送信号</p>
<h3 id="接受信号"><a href="#接受信号" class="headerlink" title="接受信号"></a>接受信号</h3><p>当内核从一个异常处理程序返回，准备将控制传递给进程 p 时，它会检查进程 p 的未被阻塞的待处理信号的集合(pending&amp;~blocked)。如果这个集合为空(通常情况下)，那么内核将控制传递到 p 的逻辑控制流中的下一条指令</p>
<h3 id="信号处理问题"><a href="#信号处理问题" class="headerlink" title="信号处理问题"></a>信号处理问题</h3><p>当一个程序要补货多个信号时，一些细微的问题就产生了：</p>
<ul>
<li>待处理信号被阻塞</li>
<li>待处理信号不会排队等待</li>
<li>系统调用可以被中断</li>
</ul>
<p>不可以用信号来对其他进程中发生的事件计数。</p>
<h3 id="可移植的信号处理"><a href="#可移植的信号处理" class="headerlink" title="可移植的信号处理"></a>可移植的信号处理</h3><p>不同系统之间，信号处理语义的差异是 Unix 信号处理的一个缺陷。为了处理这个问题，Posix 标准定义了<code>sigaction</code> 函数，它允许用户明确指定他们想要的信号处理语义。</p>
<h3 id="显式地阻塞信号"><a href="#显式地阻塞信号" class="headerlink" title="显式地阻塞信号"></a>显式地阻塞信号</h3><p>使用 <code>sigprocmask</code> 函数</p>
<h2 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h2><p>C 语言提供了一种用户级一场控制流形式，称为<strong>非本地跳转</strong>(nonlocal jump)，它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用——返回序列，通过 <code>setjmp</code> 和 <code>longjmp</code> 函数来提供的。</p>
<p>非本地跳转的另一个重要应用是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。</p>
<h2 id="操作进程的工具"><a href="#操作进程的工具" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h2><p>Linux 系统提供了大量的监控和操作进程的有用工具：</p>
<ul>
<li>STRACE：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。用 -static 编译你的程序，能得到一个更干净的、不带有大量与共享库相关的输出的 trace</li>
<li>PS：列出当前系统中的进程(包括僵死进程)</li>
<li>TOP：打印出关于当前进程资源使用的信息</li>
<li>PMAP：显示进程的存储器映射</li>
<li>/proc：一个虚拟文件系统，以 ASCII 文本格式输出大量内核数据结构的内容，用户可以读取这些内容</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>异常控制流(ECF)发生在计算机系统的各个层次，是计算机系统中提供并发的基本机制。</p>
<p>在硬件层，异常是由处理器中的事件触发的控制流中的突变。控制流传递给一个软件处理程序，该处理程序进行一些处理，然后返回控制给被中断的控制流。</p>
<p>有四种不同类型的异常：中断、故障、终止和陷阱。</p>
<p>在操作系统层，内核用 ECF 提供进程的基本概念。进程提供给应用两个重要的抽象：1）逻辑控制流，它提供给每个程序一个假象，好像它是在独占地使用处理器，2）私有地址空间，它提供给每个程序一个假象，好像它是在独占地使用主存。</p>
<p>在操作系统和应用程序之间的接口处，应用程序可以创建子进程，等待它们的子进程停止或者终止，运行新的程序，以及不活来自其他进程的信号。信号处理的语义是微妙的，并且随着系统不同而不同。然而，在与 Posix 兼容的系统上存在着一些机制，允许程序清楚地指定期望的信号处理语义。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 链接]]></title>
      <url>/2018/01/29/CSAPP-%E9%93%BE%E6%8E%A5/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第7章笔记</p>
<a id="more"></a>
<p>链接(linking)是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载到存储器并执行。链接可以执行于编译时(compile time)，也可以执行于加载时(load time)，甚至执行于运行时(run time)。</p>
<p>链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译(separate compilation)成为可能。</p>
<h2 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h2><p>大多数编译系统提供<strong>编译驱动程序</strong>（compiler driver），为用户根据需求调用语言预处理器、编译器、汇编器和链接器</p>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517214954215.jpg" alt="enter description here"></p>
<p>为了创建可执行文件，链接器必须完成两个主要任务：</p>
<ul>
<li>符号解析（symbol resolution），将一个符号引用和一个符号定义结合起来</li>
<li>重定位（relocation），编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把每个符号定义域一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而重定位这些节。</li>
</ul>
<p>目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包含指导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。</p>
<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><p>目标文件有三种形式：</p>
<ul>
<li>可重定位目标文件，包含二进制文件和代码，其形式在编译时和其他可重定位目标文件合并起来，创建一个可执行目标文件</li>
<li>可执行目标文件，其形式可被拷贝到存储器并执行</li>
<li>共享目标文件，一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载到存储器并链接。</li>
</ul>
<p>编译器和汇编器生成可重定位目标文件（包括共享目标文件），链接器生成可执行目标文件</p>
<h2 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h2><p>典型的 ELF 可重定位目标文件的格式。ELF 头(ELF header)以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517215240554.jpg" alt="enter description here"></p>
<h2 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h2><p>每个重定位的目标模块m都有一个符号表，包含m所定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：</p>
<ol>
<li>有m定义并能够被其他模块引用的全局符号</li>
<li>由其他模块定义并被m所引用的全局符号</li>
<li>只被m定义和引用的本地符号</li>
</ol>
<p>C 程序员使用 static 属性在模块内部隐藏变量和函数声明。</p>
<h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><p>链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义联系起来。</p>
<p>当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，它会假设符号是在其他模块中定义的，生成一个链接器符号表表目，并把它交给链接器处理。</p>
<h3 id="链接器如何解析多处定义的全局符号"><a href="#链接器如何解析多处定义的全局符号" class="headerlink" title="链接器如何解析多处定义的全局符号"></a>链接器如何解析多处定义的全局符号</h3><p>编译器输出每个全局符号给汇编器，或者是强（stong），或者是弱（week），而汇编器把这些信息隐含得编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。</p>
<p>根据强弱符号的定义，Unix使用一下规则来处理多处定义的符号：</p>
<ol>
<li>不允许有多个强符号</li>
<li>如果有一个强符号和多个弱符号，则选择强符号</li>
<li>如果有多个弱符号，则从中随机选择一个</li>
</ol>
<h3 id="与静态库链接"><a href="#与静态库链接" class="headerlink" title="与静态库链接"></a>与静态库链接</h3><p>所有编译系统都提供了一种机制，将所有相关的目标模块打包成一个单独的文件，成为静态库（static library），它也可以作为链接器的输入。</p>
<p>在Unix系统中，静态库以一种存档（archive）的特殊文件格式存储在磁盘中。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517216233165.jpg" alt="enter description here"></p>
<h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>一旦链接器完成符号解析这一步，就把代码中每一个符号的引用和确定的一个符号定义结合起来。链接器就知道他输入目标模块中的代码节和数据节的确定大小。后面就是重定位的步骤了，</p>
<p>重定位由两个部分组成：</p>
<ol>
<li>重定位节和符号定义</li>
<li>重定义节中的符号引用，链接器修改代码节和数据节中的每一个符号引用，使得他们指向正确的地址</li>
</ol>
<h3 id="重定向表目"><a href="#重定向表目" class="headerlink" title="重定向表目"></a>重定向表目</h3><p>无论何时汇编器遇到对最终位置未知的目标引用，他就会生成一个重定位表目（relocation entry），告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。</p>
<p>有两种最基本的重定位类型：</p>
<ul>
<li>R_386_PC32 ： 重定位一个使用32位PC相关的地址引用</li>
<li>R_386_32 ： 重定位一个使用32位绝对地址的引用</li>
</ul>
<h3 id="重定位符号表引用"><a href="#重定位符号表引用" class="headerlink" title="重定位符号表引用"></a>重定位符号表引用</h3><h2 id="可执行目标文件"><a href="#可执行目标文件" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h2><p>一个典型的ELF可执行文件中的各类信息：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517217108531.jpg" alt="enter description here"></p>
<h2 id="加载可执行文件"><a href="#加载可执行文件" class="headerlink" title="加载可执行文件"></a>加载可执行文件</h2><p>每个Unix程序都有一个运行时的存储器映像：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517217187444.jpg" alt="enter description here"></p>
<h2 id="动态链接共享库"><a href="#动态链接共享库" class="headerlink" title="动态链接共享库"></a>动态链接共享库</h2><p>共享库(shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行时，可以加载到任意的存储器地址，并和一个在存储器中的程序链接起来。这个过程称为动态链接(dynamic linking)，是由一个叫做动态链接器的程序来执行的。</p>
<p>共享库也称为共享目标(shared object)，在 Unix 系统中通常用 .so 后缀来表示。微软的操作系统大量地利用了共享库，它们称为 DLL。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517217296974.jpg" alt="使用共享库来动态链接"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>链接可以在编译时由静态编译器来完成，也可以在加载时和运行时由动态链接器来完成。链接器处理称为目标文件的二进制文件，它又三种不同的形式：可重定位的、可执行的和共享的。可重定位的目标文件由静态链接器合并成一个可执行的目标文件，它可以加载到存储器中并执行。共享目标文件(共享库)是在运行时由动态链接器链接和加载的，或者隐含地在调用程序被加载和开始执行时，或者根据需要在程序调用 dlopen 库的函数时。</p>
<p>链接器的两个主要任务是符号解析和重定位，符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义，而重定位确定每个符号的最终存储器地址，并修改对那些目标的引用。</p>
<p>静态链接器是由像 GCC 这样的编译驱动器调用的。它们将多个可重定位目标文件合并成一个单独的可执行目标文件。多个目标文件可以定义相同的符号，而链接器用来悄悄地解析这些多重定义的规则可能在用户程序中引入的微妙错误。</p>
<p>多个目标文件可以被连接到一个单独的静态库中。链接器用库来解析其他目标模块中的符号引用。许多链接器通过从左到右的顺序扫描来解析符号引用，这是另一个引起迷惑的链接时错误来源。</p>
<p>加载器将可执行文件的内容映射到存储器，并运行这个程序。链接器还可能生成部分链接的可执行目标文件，这样的文件中有对定义在共享库中的程序和数据的未解析的引用。在加载时，加载器将部分链接的可执行文件映射到存储器，然后调用动态链接器，它通过加载共享库和重定位程序中的引用来完成链接任务。</p>
<p>被编译为位置无关代码的共享库可以加载到任何地方，也可以在运行时被多个进程共享。为了加载、链接和访问共享库的函数和数据，应用程序还可以在运行时使用动态链接器。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 3Sum & 3Sum Closest 题解]]></title>
      <url>/2018/01/28/LeetCode-3Sum-3Sum-Closest-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>LeetCode 3Sum &amp; 3Sum Closest 题解</p>
<a id="more"></a>
<h2 id="3Sum"><a href="#3Sum" class="headerlink" title="3Sum"></a>3Sum</h2><p>给出一个数组，找出所有三个数的和为零的组合</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>最暴力的方法就是枚举所有的三个数的组合，这样的时间复杂度是O（n^3）</p>
<p>另外一种比较优化的方法就是，先排序，枚举第一个数，后面两个数通过双指针确定。因为已经排序好的，后面两个数从两边向中间靠近进行枚举，这一部分的时间复杂度是O（n）。所以整个的时间复杂度就到了O（n^2）</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        vector&lt;vector&lt;int&gt;&gt; res;</div><div class="line">        </div><div class="line">        sort(nums.begin(),nums.end());</div><div class="line">        </div><div class="line">        int len = nums.size();</div><div class="line">        </div><div class="line">        for(int i=0;i&lt;len;i++)</div><div class="line">        &#123;</div><div class="line">            if(i==0 || nums[i]!=nums[i-1]) // 去重</div><div class="line">            &#123;</div><div class="line">                for(int j=i+1,k=len-1;j&lt;k;)</div><div class="line">                &#123;</div><div class="line">                    if(nums[i]+nums[j]+nums[k] == 0)</div><div class="line">                    &#123;</div><div class="line">                        vector&lt;int&gt; tmp = &#123;nums[i],nums[j],nums[k]&#125;;</div><div class="line">                        res.push_back(tmp);</div><div class="line">                        j++;</div><div class="line">                        while(j&lt;k &amp;&amp; nums[j]==nums[j-1]) j++;</div><div class="line">                        k=len-1;</div><div class="line">                    &#125;</div><div class="line">                    else if(nums[j]+nums[k]+nums[i]&gt;0)</div><div class="line">                    &#123;</div><div class="line">                        k--;</div><div class="line">                        while(j&lt;k &amp;&amp; nums[k]==nums[k+1]) k--;</div><div class="line">                    &#125;</div><div class="line">                    else</div><div class="line">                    &#123;</div><div class="line">                        j++;</div><div class="line">                         while(j&lt;k &amp;&amp; nums[j]==nums[j-1]) j++;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="3Sum-Closest"><a href="#3Sum-Closest" class="headerlink" title="3Sum Closest"></a>3Sum Closest</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>方法和上面的题目一样，同样是通过双指针来降低时间复杂度</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class="line">        int res = nums[0]+nums[1]+nums[2],len = nums.size();</div><div class="line">        int minv = abs(res - target);</div><div class="line">        </div><div class="line">        sort(nums.begin(),nums.end());</div><div class="line">        </div><div class="line">        for(int i=0;i&lt;len;i++)</div><div class="line">        &#123;</div><div class="line">            for(int j=i+1,k=len -1;j&lt;k;)</div><div class="line">            &#123;</div><div class="line">                int tmp = abs(nums[i]+nums[j]+nums[k]-target);</div><div class="line">                if(tmp&lt;minv)</div><div class="line">                &#123;</div><div class="line">                    minv = tmp;</div><div class="line">                    res = nums[i]+ nums[j] + nums[k];</div><div class="line">                &#125;</div><div class="line">                if(nums[i]+nums[j]+nums[k]&gt;=target)</div><div class="line">                    k--;</div><div class="line">                else</div><div class="line">                    j++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 存储器层次结构]]></title>
      <url>/2018/01/28/CSAPP%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第6章笔记</p>
<a id="more"></a>
<p>存储器系统(memory system)是一个具有不同容量、成本和访问时间的存储设备的层次结构。CPU 寄存器保存着最常用的数据。靠近 CPU 的晓得、快速的高速缓存存储器(cache memory)作为一部分存储在相对慢速的主存储器(main memory)中的数据和指令的缓冲区域。主存暂时存放在容量较大的、慢速磁盘上的数据，而这些磁盘常常又作为存储在通过网络连接的其他机器的磁盘或磁带上的区域的缓冲区域。</p>
<p>具有良好局部性的程序倾向于一次又一次地访问相同的数据项集合，或者是倾向于访问邻近的数据项集合</p>
<h2 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h2><h3 id="随机访问存储器"><a href="#随机访问存储器" class="headerlink" title="随机访问存储器"></a>随机访问存储器</h3><p>随机访问存储器 (Random-Access Memory, RAM)分为两类：静态的和动态的。SRAM 比 DRAM 更快，但也贵得多。SRAM 用来作为高速缓存存储器，既可以在 CPU 芯片上，也可以在片下。DRAM 用来作为主存以及图形系统的帧缓冲区。</p>
<h3 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h3><p>磁盘构造</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517109327779.jpg" alt="enter description here"></p>
<p>磁盘容量：一个磁盘能够存储的最大位数，由以下因素决定：</p>
<ul>
<li>记录密度（recoding density），磁道一英寸的段可以放入的位数</li>
<li>磁道密度</li>
<li>面密度</li>
</ul>
<p>磁盘操作：用一个连接到传动臂的读写头来读写存储在磁性表面的位</p>
<p>对扇区的访问时间由三个部分组成：寻道时间（seek time）、旋转时间（rotational latency）、传送时间（transfer time）</p>
<h3 id="固态硬盘（Solid-State-Disks）"><a href="#固态硬盘（Solid-State-Disks）" class="headerlink" title="固态硬盘（Solid State Disks）"></a>固态硬盘（Solid State Disks）</h3><p>基于闪存（flash memory）的存储技术</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517110224118.jpg" alt="enter description here"></p>
<h3 id="存储技术趋势"><a href="#存储技术趋势" class="headerlink" title="存储技术趋势"></a>存储技术趋势</h3><ul>
<li>不同的存储技术有不同的价格和性能的折中</li>
<li>不同存储技术的价格和性能属性以截然不同的速率变化着</li>
<li>DRAM和磁盘访问的时间滞后于CPU时钟周期时间</li>
</ul>
<h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p>一个编写良好的计算机程序常常具有良好的局部性(locality)。也就是说，它们倾向于引用临近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。这种倾向性，被称为局部性原理(principle of locality)，是一个持久的概念，对硬件和软件系统的设计和性能都有着极大的影响。</p>
<p>局部性通常有两种不同的形式：时间局部性(temporal locality)和空间局部性(spatial locality)。有良好局部性的程序比局部性差的程序运行得更快。</p>
<ul>
<li>重复引用同一个变量的程序有良好的时间局部性</li>
<li>对于具有步长为 k 的引用模式的程序，步长越小，空间局部性越好</li>
<li>对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好</li>
</ul>
<h2 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h2><p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517110431384.jpg" alt="enter description here"></p>
<h3 id="在存储器层次结构中的缓存"><a href="#在存储器层次结构中的缓存" class="headerlink" title="在存储器层次结构中的缓存"></a>在存储器层次结构中的缓存</h3><p>一般而言，高速缓存(cache)是一个小而快速的存储设备。使用高速缓存的过程称为缓存(caching)。</p>
<p>存储器层次结构的中心思想是，对于每个 k，位于 k 层的更快更小的存储设备作为位于 k+1 层的更大更慢的存储设备的缓存。换句话说，层次结构中的每一次都缓存来自较低一层的数据对象。</p>
<p>数据总是以块大小为传送单元(transfer unit)在第 k 层和第 k+1 层之间来回拷贝的。虽然在层次结构中任何一对相邻的层次之间块大小是固定的，但是其他的层次对之间可以用不同的块大小。一般而言，层次结构较低的层(离 CPU 较远)的设备访问时间较长，因此为了补偿这些较长的访问时间，倾向于使用较大的块。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517110523087.jpg" alt="enter description here"></p>
<p>缓存命中： 当程序需要第 k+1 层的某个数据对象 d 时，它首先在当前存储的第 k 层的一个块中查找 d。如果 d 刚好缓存在第 k 层中，那么就是<strong>缓存命中</strong>(cache hit)。</p>
<p>缓存不命中：如果第 k 层中没有缓存数据对象 d，那么就是缓存不命中(cache miss)。当发生 cache miss 时，会从下一次取出包含 d 的那个块，如果第 k 层的缓存已经满了的话，可能就会覆盖现存的一个块。</p>
<p>覆盖一个现存的块的过程称为替换(replacing)或驱逐(evicting)。被驱逐的看这个块有时也称为牺牲块(victim block)。决定该替换那个块是由缓存的替换策略(replacement policy)来控制的。(LRU, LFU 等等替换策略在这里可以使用)</p>
<p>缓存不命中的种类： 一个空的缓存有时称为冷缓存(cold cache)，此类不命中称为compulsory miss 或 cold miss。</p>
<h3 id="存储器层次结构概念小结"><a href="#存储器层次结构概念小结" class="headerlink" title="存储器层次结构概念小结"></a>存储器层次结构概念小结</h3><p>存储器层次结构行之有效，因为较慢的设备比较快的设备更便宜，还因为程序偏向于展示局部性：</p>
<ul>
<li>利用时间局部性，同一数据对象可能会被多次使用</li>
<li>利用空间局部性，块通常包含有多个数据对象</li>
</ul>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517110831456.jpg" alt="enter description here"></p>
<h2 id="高速缓存存储器"><a href="#高速缓存存储器" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h2><p>早期计算机系统的存储器结构只有三层：CPU 寄存器、DRAM 主存储器和磁盘存储。不过，由于 CPU 和主存之间逐渐增大的差距，系统设计者被迫在 CPU 寄存器文件和主存之间插入了一个小的 SRAM 高速缓存存储器，称为 L1 高速缓存。之后又插入了一个更大的高速缓存，称为 L2 高速缓存，之后还有 L3 高速缓存。周期数：L1(2~4), L2(~10), L3(~30~40)</p>
<h3 id="通用的高速缓存存储结构"><a href="#通用的高速缓存存储结构" class="headerlink" title="通用的高速缓存存储结构"></a>通用的高速缓存存储结构</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517111205440.jpg" alt="enter description here"></p>
<h3 id="直接映射高速缓存"><a href="#直接映射高速缓存" class="headerlink" title="直接映射高速缓存"></a>直接映射高速缓存</h3><p>每个组只有一行（E=1）的高速缓存被称为直接映射高速缓存</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517111234451.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517111247641.jpg" alt="enter description here"></p>
<h3 id="组相联高速缓存"><a href="#组相联高速缓存" class="headerlink" title="组相联高速缓存"></a>组相联高速缓存</h3><p>直接映射高速缓存中冲突不命中造成的问题是源于每一个组只有一行，组相联高速缓存（set associative cache）放松了这条限制，所以每个组都保存了有多于一行的高速缓存</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517111425945.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517111461520.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517111477325.jpg" alt="enter description here"></p>
<h3 id="全相联高速缓存"><a href="#全相联高速缓存" class="headerlink" title="全相联高速缓存"></a>全相联高速缓存</h3><p>由一个包含所有高速缓存行的组（E =  C/B）组成</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517111577074.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517111592957.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517111605869.jpg" alt="enter description here"></p>
<h3 id="有关写的问题"><a href="#有关写的问题" class="headerlink" title="有关写的问题"></a>有关写的问题</h3><p>更新写命中的缓存的方法：</p>
<ol>
<li>直写（write-throuth），立即将w的高速缓存块写回到存储器中，优点是简单，缺点是每条存储指令都会引起总线上面的一个写事务</li>
<li>写回（write-back），尽可能推迟存储器的更新，只有当替换算法要驱逐已更新块时，才写入存储器中，优点是能够显著减少总线事务的数量，缺点是增加复杂性，需要额外维护一个修改位（dirty bit）</li>
</ol>
<p>处理写不命中的方法：</p>
<ol>
<li>写分配（write-allocate），加载相应的存储器块到高速缓存中，然后更新这个高速缓存块</li>
<li>非写分配（not-write-allocate），避开高速缓存，直接把字写到存储器中</li>
</ol>
<h3 id="指令高速缓存和统一高速缓存"><a href="#指令高速缓存和统一高速缓存" class="headerlink" title="指令高速缓存和统一高速缓存"></a>指令高速缓存和统一高速缓存</h3><p>只保存指令的高速缓存成为i-cache，只保存程序数据的高速缓存称为d-cache，即保存指令又保存程序数据的高速缓存称为统一的高速缓存（unified cache）</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517112120679.jpg" alt="enter description here"></p>
<h3 id="高速缓存参数的性能影响"><a href="#高速缓存参数的性能影响" class="headerlink" title="高速缓存参数的性能影响"></a>高速缓存参数的性能影响</h3><p>衡量性能的指标：</p>
<ul>
<li>不命中率</li>
<li>命中率</li>
<li>命中时间</li>
<li>不命中处罚</li>
</ul>
<p>影响：</p>
<ol>
<li>高速缓存大小</li>
<li>块大小</li>
<li>相联度</li>
<li>写策略</li>
</ol>
<h2 id="编写高速缓存友好的代码"><a href="#编写高速缓存友好的代码" class="headerlink" title="编写高速缓存友好的代码"></a>编写高速缓存友好的代码</h2><ol>
<li>让最常见的情况运行得快</li>
<li>在每个循环内部使缓存不命中数量小</li>
</ol>
<h2 id="综合：高速缓存对程序性能的影响"><a href="#综合：高速缓存对程序性能的影响" class="headerlink" title="综合：高速缓存对程序性能的影响"></a>综合：高速缓存对程序性能的影响</h2><p>存储器山（memory mountain）<br><img src="https://data2.liuin.cn/story-writer/2018_1_28_1517112396218.jpg" alt="enter description here"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>程序员可以通过编写有良好空间和时间局部性的程序来显著地改进程序的运行时间。利用基于 SRAM 的高速缓存存储器特别重要。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 优化程序性能]]></title>
      <url>/2018/01/27/CSAPP-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第5章笔记</p>
<a id="more"></a>
<p>编写高效程序可以考虑两个方面：选择好的算法和数据结构；编写编译器能够有效优化以转换为高效可执行代码的源码。</p>
<p>程序员通常需要在实现和维护程序的简单性与他的运行速度之间做出权衡折中。</p>
<p>程序优化的第一步就是消除不必要的内容，让代码尽可能有效地执行它期望的工作。这包括消除不必要的函数调用、条件测试和存储器引用。这些优化不依赖于目标机器的任何具体属性。</p>
<p>研究程序的汇编代码表示，是理解编译器，以及产生的代码如何运行的最有效的手段之一。仔细研究内循环的代码是一个很好的开端。</p>
<h2 id="优化编译器的能力和局限性"><a href="#优化编译器的能力和局限性" class="headerlink" title="优化编译器的能力和局限性"></a>优化编译器的能力和局限性</h2><p>编译器优化程序的能力受到几个因素的制约：</p>
<ol>
<li>要求决不能改变正确程序的行为</li>
<li>对程序的行为、使用的环境有所了解</li>
<li>需要很快地完成编译工作</li>
</ol>
<p>阻碍优化的几个因素：</p>
<ul>
<li>存储器别名的使用，编译器必须假设不同的指针可能会指向存储器中的同一个位置</li>
<li>函数调用，函数可能会有副作用（改变全局程序状态的一部分）</li>
</ul>
<h2 id="表示程序性能"><a href="#表示程序性能" class="headerlink" title="表示程序性能"></a>表示程序性能</h2><p>我们引入度量标准每元素的周期数(Cycles Per Element, CPE)作为一种表示性能并指导我们改进代码的方法。处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用千兆赫兹(GHz)，即十亿周期每秒来表示。CPE 越小越好。</p>
<h2 id="消除循环的低效率"><a href="#消除循环的低效率" class="headerlink" title="消除循环的低效率"></a>消除循环的低效率</h2><p>优化前</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_27_1517062357118.jpg" alt="enter description here"></p>
<p>优化后</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_27_1517062333115.jpg" alt="enter description here"></p>
<p>以上的代码移动(code motion)是一种优化。这类优化包括识别要执行多次(例如在循环里)但是计算结果不会改变的计算。因而可以将计算移动到代码前面不会被多次求值的部分。</p>
<p>编程时一个常见的问题就是一个看上去无足轻重的代码片段有隐藏的渐进低效率(asymptotic inefficiency)</p>
<h2 id="减少过程调用"><a href="#减少过程调用" class="headerlink" title="减少过程调用"></a>减少过程调用</h2><p>过程调用会代码相当大的开销，而且妨碍大多数形式的程序优化。我们可以直接访问数组，而不是利用函数调用并加上边界检查：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_27_1517062508161.jpg" alt="enter description here"></p>
<p>对于性能至关重要的程序来说，为了速度，可能需要损害一些对象的模块性和抽象性</p>
<h2 id="消除不必要的存储器引用"><a href="#消除不必要的存储器引用" class="headerlink" title="消除不必要的存储器引用"></a>消除不必要的存储器引用</h2><p>累加过程中其实没有必要每次都把结果写入到 dest 中，可以使用一个临时变量，消除不必要的存储器引用：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_27_1517062838432.jpg" alt="enter description here"></p>
<h2 id="理解现代处理器"><a href="#理解现代处理器" class="headerlink" title="理解现代处理器"></a>理解现代处理器</h2><p>不依赖目标机器的优化，只能简单通过降低过程调用开销、以及消除一些重大的“妨碍优化因素”来实现。</p>
<p>要想获得充分提高的性能，需要仔细地分析程序，同时代码的生成也要针对目标处理器进行调整。在实际的处理器中，是同时对多条指令求值，这个现象称为指令级并行。现代微处理器取得的了不起的功绩之一是：它们采用复杂而奇异的微处理器结构，其中，多条指令可以并行地执行，同时又呈现一种简单地顺序执行指令的表象。</p>
<p>两种下界描述了程序的最大性能。当一系列操作必须按照严格顺序执行时，就会遇到延迟界限(latency bound)，因为在下一条指令开始之前，这条指令必须结束。当代码中的数据相关限制了处理器利用指令级并行的能力时，延迟界限能够限定程序性能。吞吐量界限(throughput bound)刻画了处理器功能单元的原始计算能力。这个界限是程序性能的终极限制。</p>
<h3 id="整数操作"><a href="#整数操作" class="headerlink" title="整数操作"></a>整数操作</h3><p>Nehalem 微体系结构是 20 世纪 90 年代以来，许多制造商生产的典型的高端处理器。在工业界称为超标量(superscalar)，意思是可以在每个时钟周期执行多个操作，而且是乱序的(out-of-order)，意思就是指令执行的顺序不一定要与它们在机器级程序中的顺序一致。整个设计有两个主要部分：指令控制单元(Instruction Control Unit, ICU)和执行单元(Execution Unit, EU)。前者负责从存储器中读出指令序列，并根据这些指令序列生成一组针对程序数据的基本操作；而后执行这些操作。</p>
<p>ICU 从指令高速缓存(instruction cache)中读取指令。指令高速缓存是一个特殊的高速缓存存储器，它包含最近访问的指令。通常，ICU 会在当前正在的指令很早之前取指，这样它才有足够的时间对指令译码，并把操作发送到 EU。不过，一个问题是党程序遇到分支时，程序有两个可能的前进方向。一种可能会选择分支，控制被传递到分支目标。另一种可能是，不选择分支，控制被传递到指令序列的下一条指令。现代处理器采用了一种称为<strong>分支预测(branch prediction)的技术，处理区会猜测是否会选择分支，同时还预测分支的目标地址</strong>。使用投机执行(speculative execution)的技术，处理器会开始取出位于它预测的分支会跳到的地方的指令，并对指令译码，甚至在它确定分支预测是否正确之前就开始执行这些操作。如果过后确定分支预测错误，会将状态重新设置到分支点的状态，并开始取出和执行另一个方向上的指令。</p>
<h3 id="功能单元的性能"><a href="#功能单元的性能" class="headerlink" title="功能单元的性能"></a>功能单元的性能</h3><p>每个运算都是由两个周期计数值来刻画的：一个是延迟(latency)，它表示完成运算所需要的总时间；另一个是发射时间(issue time)，它表示两个连续的同类型运算之间需要的最小时钟周期数。随着字长的增加，对于更复杂的数据类型，对于更复杂的运算，延迟也会增加。</p>
<h3 id="处理器操作的抽象模型"><a href="#处理器操作的抽象模型" class="headerlink" title="处理器操作的抽象模型"></a>处理器操作的抽象模型</h3><p>我们会使用程序的数据流(data-flow)表示，作为分析在现代处理器上执行的机器级程序性能的一个工具，这是一种图形化的表示方法，展现了不同操作之间的数据相关是如何限制它们的执行顺序的。这种限制形成了图中的<strong>关键路径</strong>(critical path)，这是执行一组机器指令所需时钟周期数的一个下界。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_27_1517063266274.jpg" alt="enter description here"></p>
<h2 id="循环展开（loop-unrolling）"><a href="#循环展开（loop-unrolling）" class="headerlink" title="循环展开（loop unrolling）"></a>循环展开（loop unrolling）</h2><p>循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。其思想是在一次迭代中访问数组并做乘法，这样得到的程序需要更少的迭代，从而降低循环的开销。</p>
<p>循环展开能够从两个方面改善程序的性能。首先，它减少了不直接有助于程序结果的操作的数量，例如循环索引计算和条件分支。其次，它提供了一些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。</p>
<h2 id="提高并行性"><a href="#提高并行性" class="headerlink" title="提高并行性"></a>提高并行性</h2><h3 id="循环分割（loop-splitting）"><a href="#循环分割（loop-splitting）" class="headerlink" title="循环分割（loop splitting）"></a>循环分割（loop splitting）</h3><p>对于一个可结合可交换的合并操作来说，比如说整数的乘法和加法，我们可以通过将一组数据合并分割成两个或者更多部分，并在最后合并结果来提高性能</p>
<h3 id="寄存器溢出（register-spilling）"><a href="#寄存器溢出（register-spilling）" class="headerlink" title="寄存器溢出（register spilling）"></a>寄存器溢出（register spilling）</h3><p>循环并行性的好处就是受描述计算的汇编代码的能力限制，如果我们有并行度p超过了可用的寄存器数量，这种情况性能就会急剧下降。</p>
<p>作为一条通用原则，无论何时当一个编译了的程序显示出来在某个频繁使用的内循环中有寄存器溢出的迹象时，都会偏向于重写代码，使之需要较少的临时值。</p>
<h2 id="确定和消除性能瓶颈"><a href="#确定和消除性能瓶颈" class="headerlink" title="确定和消除性能瓶颈"></a>确定和消除性能瓶颈</h2><p>Amdahl定律</p>
<p>当我们加快系统一部分的速度时，对系统整体性能的影响依赖于这个部分有多重要和速度提高了多少。</p>
<p>主要观点：想要大幅度提高整个系统的速度，我们必须提高系统很大一部分的速度。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>没有任何编译器能用一个好的算法或数据结构代替低效率的算法或数据结构，因此程序设计时的这些方面仍然应该是程序员主要关心的。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 处理器体系结构]]></title>
      <url>/2018/01/26/CSAPP-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第4章笔记</p>
<a id="more"></a>
<p>一个处理器支持的指令和指令字节编码称为它的ISA（Instruction-set Architecture）。这一章主要讲以Y86指令集体系结构为例讲了处理器中指令的执行流程以及流水的原理和实现。</p>
<h2 id="Y86指令集体系结构"><a href="#Y86指令集体系结构" class="headerlink" title="Y86指令集体系结构"></a>Y86指令集体系结构</h2><p>Y86 程序中的每条指令都会读取或修改处理器状态的某些部分，这称为程序员（用汇编代码写程序的人或机器级代码的编译器）可见状态：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_26_1516971186027.jpg" alt="enter description here"></p>
<p>Y86指令集</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_26_1516971281093.jpg" alt="enter description here"></p>
<p>指令编码：每条指令的第一个字节表示指令的类型，这个字节分为两个部分，每个部分四位：高四位是代码（code）部分，低四位是功能（function）部分。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_26_1516971475052.jpg" alt="enter description here"></p>
<p>CISC vs RISC</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_26_1516971547830.jpg" alt="enter description here"></p>
<h2 id="逻辑设计和硬件控制语言HCL"><a href="#逻辑设计和硬件控制语言HCL" class="headerlink" title="逻辑设计和硬件控制语言HCL"></a>逻辑设计和硬件控制语言HCL</h2><p>硬件设计中，电子电路是用来计算位的函数（function on bits），以及在各种存储器元素中存储位。实现一个数字系统主要有三个部分：计算位的函数的组合逻辑、存储位的存储元素，以及控制存储元素更新的时钟信号。</p>
<h3 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a>逻辑门</h3><p>逻辑门是数字电路的基本计算元素。它们产生的输出，等于它们输入位值的某个布尔函数</p>
<h3 id="组合电路和HCL布尔表达式"><a href="#组合电路和HCL布尔表达式" class="headerlink" title="组合电路和HCL布尔表达式"></a>组合电路和HCL布尔表达式</h3><p>很多的逻辑门组合成一个网，就能构建计算块(computational block)，称为组合电路(combinational circuits)。构建这些网有两条限制：</p>
<ul>
<li>两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障</li>
<li>这个网必须是无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，这样的回路会导致该网络计算的函数有歧义。</li>
</ul>
<h3 id="字级的组合电路和HCL整数表达式"><a href="#字级的组合电路和HCL整数表达式" class="headerlink" title="字级的组合电路和HCL整数表达式"></a>字级的组合电路和HCL整数表达式</h3><p>字级的组合电路： 对数据字（data word）进行操作的电路，在HCL中，将所有的字级的信号都声明为int，而不指定字的大小</p>
<h3 id="集合关系（set-membership）"><a href="#集合关系（set-membership）" class="headerlink" title="集合关系（set membership）"></a>集合关系（set membership）</h3><p>实现将一个信号和众多可能的信号做比较，判断正在处理的某些指令是否属于一类指令代码</p>
<h3 id="存储器和时钟控制"><a href="#存储器和时钟控制" class="headerlink" title="存储器和时钟控制"></a>存储器和时钟控制</h3><p>为了产生时序电路，必须引入按位存储信息的设备，考虑两种：</p>
<ul>
<li>时钟寄存器存储单个位或字</li>
<li>随机访问存储器存储多个字</li>
</ul>
<h2 id="Y86的顺序（sequential）实现"><a href="#Y86的顺序（sequential）实现" class="headerlink" title="Y86的顺序（sequential）实现"></a>Y86的顺序（sequential）实现</h2><h3 id="将处理组织成阶段"><a href="#将处理组织成阶段" class="headerlink" title="将处理组织成阶段"></a>将处理组织成阶段</h3><p>处理一条指令包含很多操作，我们把其组织成某些特殊的阶段序列，使得即使指令的动作差异很大，但是所有的指令都遵守统一的序列：</p>
<ul>
<li>取指（fetch），取指阶段，从存储器中读入指令，地址为程序计数器（PC）的值</li>
<li>解码（decode），解码阶段从寄存器中读入最多两个操作数，得到其值</li>
<li>执行（execute），算术逻辑单元（ALU）要么执行指令指明的操作，计算存储器引用的有效地址，要么增加或者减少栈指针。</li>
<li>访存（memory），可以将数据写入存储器，或者从存储器中读入数据</li>
<li>写回（write back），最多可以写两个结果到寄存器文件</li>
<li>更新PC（update PC），将PC设置为下一条PC的地址</li>
</ul>
<p>SEQ的硬件结构、时序、阶段实现 因为比较复杂，可以参考书上的内容</p>
<h2 id="流水线的通用原理"><a href="#流水线的通用原理" class="headerlink" title="流水线的通用原理"></a>流水线的通用原理</h2><p>流水线化的系统有一些通用的属性和原理，在流水线系统中，待执行的任务被划分成若干个相互独立的阶段。</p>
<h3 id="计算流水线"><a href="#计算流水线" class="headerlink" title="计算流水线"></a>计算流水线</h3><p>由一些执行计算的逻辑以及保存计算结果的寄存器组成。时钟信号控制在每个特定的时间间隔加载寄存器。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_26_1516973076361.jpg" alt="enter description here"></p>
<h3 id="流水线操作的详细说明"><a href="#流水线操作的详细说明" class="headerlink" title="流水线操作的详细说明"></a>流水线操作的详细说明</h3><p>三段流水线的时序</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_26_1516973204553.jpg" alt="enter description here"></p>
<p>流水线操作的一个时钟周期</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_26_1516973260280.jpg" alt="enter description here"></p>
<h3 id="流水线的局限性"><a href="#流水线的局限性" class="headerlink" title="流水线的局限性"></a>流水线的局限性</h3><ul>
<li>不一致的划分</li>
<li>流水线过深，收益反而下降（由寄存器延迟造成的）</li>
</ul>
<h3 id="带反馈的流水线系统"><a href="#带反馈的流水线系统" class="headerlink" title="带反馈的流水线系统"></a>带反馈的流水线系统</h3><p>可能产生的相关：数据相关（data dependency）、顺序相关（sequential dependency）、控制相关（control dependency）</p>
<h2 id="Y86的流水线实现"><a href="#Y86的流水线实现" class="headerlink" title="Y86的流水线实现"></a>Y86的流水线实现</h2><h3 id="插入流水线寄存器"><a href="#插入流水线寄存器" class="headerlink" title="插入流水线寄存器"></a>插入流水线寄存器</h3><p>在SEQ+的各个阶段之间插入流水线寄存器，并对信号重新做排列</p>
<h3 id="对信号做重新排列和标号"><a href="#对信号做重新排列和标号" class="headerlink" title="对信号做重新排列和标号"></a>对信号做重新排列和标号</h3><p>在流水线化的设计中，对应正在进过系统的各个指令，对指令中处理的值进行重新排列和标号</p>
<h3 id="预测下一个PC"><a href="#预测下一个PC" class="headerlink" title="预测下一个PC"></a>预测下一个PC</h3><h3 id="流水先冒险（hazard）"><a href="#流水先冒险（hazard）" class="headerlink" title="流水先冒险（hazard）"></a>流水先冒险（hazard）</h3><p>数据相关和控制相关导致的流水线产生的计算错误，成为冒险（hazard）。同样，冒险也分为数据冒险和控制冒险两大部分。</p>
<h3 id="用暂停（stalling）来避免数据冒险"><a href="#用暂停（stalling）来避免数据冒险" class="headerlink" title="用暂停（stalling）来避免数据冒险"></a>用暂停（stalling）来避免数据冒险</h3><p>暂停时，处理器会停止流水线中一条或多条指令，知道冒险不再满足</p>
<h3 id="用转发（forwarding）来避免数据冒险"><a href="#用转发（forwarding）来避免数据冒险" class="headerlink" title="用转发（forwarding）来避免数据冒险"></a>用转发（forwarding）来避免数据冒险</h3><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>指令集体系结构（ISA）在处理器行为（就指令集合以及其编码而言）和如何实现处理器之间提供了一层抽象。</p>
<p>流水线化通过让不同的阶段并行操作，改进系统的吞吐量性能。</p>
<p>处理器设计的几个重要经验：</p>
<ul>
<li>管理复杂性是首要问题</li>
<li>我们不需要直接实现ISA</li>
<li>硬件设计人员必须谨慎小心，一旦芯片被制造出来，就几乎不可能改正任何错误了。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode Merge k Sorted Lists 题解]]></title>
      <url>/2018/01/26/LeetCode%20Merge%20k%20Sorted%20Lists%20%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>LeetCode Merge k Sorted Lists 题解</p>
<a id="more"></a>
<h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p>使用之前合并两个lists的方法，重复调用k次</p>
<h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>从lists中找到前面一个元素最小的list，将这个list的首个node加入到要返回的list中的末尾中去，不断循环，直到lists中所有的node都取出来为止</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinIndex</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> minVal = <span class="number">2147483647</span> ,minIndex = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lists.size();i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(lists[i] != <span class="literal">NULL</span> &amp;&amp; minVal &gt; lists[i]-&gt;val)</div><div class="line">            &#123;</div><div class="line">                minVal = lists[i]-&gt;val;</div><div class="line">                minIndex = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minIndex;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</div><div class="line">        ListNode* res =<span class="literal">NULL</span>, *p =<span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">int</span> len = lists.size();</div><div class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> ind = getMinIndex(lists);</div><div class="line">        <span class="keyword">while</span>(ind != <span class="number">-1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// node 移植</span></div><div class="line">            <span class="keyword">if</span>(res ==<span class="literal">NULL</span>)</div><div class="line">            &#123;</div><div class="line">                res = p  = lists[ind];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                p-&gt;next = lists[ind];</div><div class="line">                p = p-&gt;next;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// 删除list中的node</span></div><div class="line">            </div><div class="line">            lists[ind] = lists[ind]-&gt;next;</div><div class="line">            </div><div class="line">            ind = getMinIndex(lists);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h2><p>将所有的node都加入到一个最小堆中，不断从这个最小堆中取出最小的一个node形成一个list</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</div><div class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</div><div class="line">        <span class="keyword">auto</span> *cur = &amp;dummy;</div><div class="line"></div><div class="line">        <span class="keyword">struct</span> Compare &#123;</div><div class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> ListNode *a, <span class="keyword">const</span> ListNode *b)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">// Use min heap to keep the smallest node of each list</span></div><div class="line">        priority_queue&lt;ListNode *, <span class="built_in">vector</span>&lt;ListNode *&gt;, Compare&gt; min_heap;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; n : lists) &#123;</div><div class="line">            <span class="keyword">if</span> (n) &#123;</div><div class="line">                min_heap.emplace(n);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!min_heap.empty()) &#123;</div><div class="line">            <span class="comment">// Get min of k lists.</span></div><div class="line">            <span class="keyword">auto</span> *node = min_heap.top();</div><div class="line">            min_heap.pop();</div><div class="line">            cur-&gt;next = node;</div><div class="line">            cur = cur-&gt;next;</div><div class="line">            <span class="keyword">if</span> (node-&gt;next) &#123;</div><div class="line">                min_heap.emplace(node-&gt;next);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="思路四"><a href="#思路四" class="headerlink" title="思路四"></a>思路四</h2><p>归并排序的思想，不断拆分成两个list的合并，最后合并的次数只有logk次，所以整体的时间复杂为O(n*logk)</p>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 程序的机器级表示]]></title>
      <url>/2018/01/25/CSAPP-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第3章笔记</p>
<a id="more"></a>
<p>高级语言通过编译变成汇编语言，汇编代码则与特定的机器密切相关。汇编代码中包含了管理存储器（memory）和执行计算的低级指令的一些细节（写高级程序的人员一般不需要考虑的）。编译器基于编程语言的原则、目标机器的指令集和操作系统遵循的规则，经过一系列的阶段产生机器代码。</p>
<h2 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h2><p>正如之前所说的，从源代码到机器可执行代码会经过以下几个过程：预处理-&gt; 编译器-&gt; 汇编器 -&gt; 链接器</p>
<h3 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h3><p>对于机器级代码来说，有两种抽象非常重要。第一种是机器级程序的格式和行为，定义为<strong>指令集体系结构</strong>(Instruction set architecture, ISA)，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。第二种抽象是，机器级程序使用的存储器地址是虚拟地址，提供的存储器模型看上去是一个非常大的字节数组。</p>
<p>汇编代码和原始的C代码相差比较大，一些通常对C语言程序员隐蔽的处理器状态是可见的：</p>
<ul>
<li>程序计数器(PC，用 %eip 表示)指示将要执行的下一条指令在存储器中的地址。</li>
<li>整数寄存器文件包含 8 个命名的位置，分别存储 32 位的值。这些寄存器可以存储地址(对应于 C 语言的指针)或证书数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器则用来保存临时数据。</li>
<li>条件码(codition code)寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化。</li>
<li>一组浮点寄存器存放浮点数据。</li>
</ul>
<p>C语言中的聚焦数据类型，例如数组和结构，在汇编中是用连续的字节表示的。汇编代码不区分有符号或无符号整数，不区分各种类型的指针，甚至不区分指针和整数。</p>
<p>程序存储器(program memory)包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的存储器块。同时OS负责管理虚拟地址空间，将虚拟地址转换为物理地址。</p>
<p>一条指令只执行一个非常基本的操作。例如，将存放在寄存器中的两个数字相加，在存储器和寄存器之间传送数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列，从而实现(像算术表达式求值、循环或过程调用和返回这样的)程序结构。</p>
<h3 id="关于格式的注解"><a href="#关于格式的注解" class="headerlink" title="关于格式的注解"></a>关于格式的注解</h3><p>所有以 . 开头的行都是指导汇编器和链接器的命令（对程序的解释），我们通常可以忽略这些行。</p>
<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516882675143.jpg" alt="enter description here"></p>
<h2 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h2><p>一个IA32的CPU中有8个32位的寄存器用来存储整数数据和指针，在过程（procedures）处理中，对前三个寄存器(%eax, %ecx, %edx)的保存和恢复惯例不同于接下来的三个寄存器(%ebx, %edi, %esi)。最后两个寄存器(%ebp, %esp)保存着指向程序栈中重要位置的指针。只有根据栈管理的标准惯例才能修改这两个寄存器中的值。</p>
<h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p>大多数指令有一个或多个操作数(operand)，指示出执行一个操作中要引用的源数据值，以及放置结果的目标位置。操作数可能被分为三种类型：</p>
<ul>
<li>立即数(immediate)，也就是常数值</li>
<li>寄存器(register)，表示某个寄存器的内容</li>
<li>存储器(memory)引用，它会根据计算出来的地址访问某个存储器位置</li>
</ul>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516883245706.jpg" alt="enter description here"></p>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516883311416.jpg" alt="enter description here"></p>
<h2 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h2><p>给出的每个指令类都有对字节、字和双字数据进行操作的指令。这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。</p>
<h3 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h3><p>加载有效地址(load effective address)指令 leal 实际上是 movl 指令的变形。它的指令形式是从存储器读数据到寄存器，但实际上它根本就没有引用存储器。它的第一个操作数看上去是一个存储器引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516883471796.jpg" alt="enter description here"></p>
<h3 id="一元和二元操作"><a href="#一元和二元操作" class="headerlink" title="一元和二元操作"></a>一元和二元操作</h3><p>一元操作：一个操作数既是源又是目的</p>
<p>二元操作：第二个操作数既是源又是目的</p>
<h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><p>先给出移位的量，然后是待移位的值</p>
<h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p>CPU 维护着一组单个 bit 的条件码(condition code) 寄存器，他们描述了最近的算术或逻辑操作的属性</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516883691695.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516883745587.jpg" alt="enter description here"></p>
<h3 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h3><p>两种最常见的访问条件码的方法不是直接读取，常用的使用方法有三种：</p>
<ul>
<li>可以根据条件码的某个组合，将一个字节设置为 0 或者 1</li>
<li>可以条件跳转到程序的某个其他的部分</li>
<li>可以有条件地传送数据</li>
</ul>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516883932824.jpg" alt="enter description here"></p>
<h3 id="跳转指令和他们的编码"><a href="#跳转指令和他们的编码" class="headerlink" title="跳转指令和他们的编码"></a>跳转指令和他们的编码</h3><p>跳转指令会导致执行切换到程序中的一个全新的位置</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516884044007.jpg" alt="enter description here"></p>
<h3 id="翻译条件分支"><a href="#翻译条件分支" class="headerlink" title="翻译条件分支"></a>翻译条件分支</h3><p>将条件表达式和语句从 C 语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516884153857.jpg" alt="enter description here"></p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>汇编中没有相应的循环指令，将条件测试和跳转组合起来可以实现循环的效果</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516884258395.jpg" alt="enter description here"></p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>通过一种称为跳转表（jump table）的数据结构使得实现更加高效，相比使用一组很长的if-else语句，使用跳转表的优点是执行开关语句的时间和开关情况（switch cases）的数量无关。</p>
<p>一般在开关情况数量比较多，并且值的范围跨度比较小的时候使用跳转表</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>一个过程调用包括将数据和控制从代码的一部分传递到另一部分。另外，它还必须在进入时为过程的局部变量分配空间，并在退出时释放这些空间。大多数机器，包括 IA32，只提供转移控制到过程和从过程转移出控制这种简单的指令。数据传递、局部变量的分配和释放通过操纵程序栈来实现。</p>
<h3 id="栈帧结构"><a href="#栈帧结构" class="headerlink" title="栈帧结构"></a>栈帧结构</h3><p>IA32 程序用程序栈来支持过程调用。机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后回复，以及本地存储。为单个过程分配的那部分栈称为<strong>栈帧</strong>(stack frame)。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516884747521.jpg" alt="enter description here"></p>
<h3 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_25_1516884832280.jpg" alt="enter description here"></p>
<h3 id="寄存器使用惯例"><a href="#寄存器使用惯例" class="headerlink" title="寄存器使用惯例"></a>寄存器使用惯例</h3><p>程序寄存器组是唯一能够被所有过程共享的资源。虽然在给定时刻只能有一个过程是活动的，但是我们必须保证当一个过程调用另一个过程时，被调用者不会覆盖某个调用者稍后会使用的寄存器的值。</p>
<p>根据惯例，寄存器 %eax、%edx、%ecx 被划分为<strong>调用者保存寄存器</strong>（caller save）。当过程 P 调用 Q 时，Q 可以覆盖这些寄存器，而不会破坏任何 P 所需要的数据。另一方面， 寄存器 %ebx、%esi、%edi 被划分为<strong>被调用者保存寄存器</strong>（callee save）。</p>
<h2 id="数组的分配和访问"><a href="#数组的分配和访问" class="headerlink" title="数组的分配和访问"></a>数组的分配和访问</h2><p>C 语言一个不同寻常的特点是可以产生指向数组中元素的指针，并对这些指针进行运算。在机器代码中，这些指针会被翻译成地址计算。</p>
<p>优化编译器非常善于简化数组索引所使用的地址计算。不过这使得 C 代码和它机器代码的翻译之间的对应关系有些难以理解。</p>
<h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><p>C 语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。也就是说，如果 p 是一个指向类型为 T 的数据的指针，p 的值为 xp，那么表达式 p+i 的值为 xp+L*i，这里 L 是数据类型 T 的大小。</p>
<h3 id="数组与循环"><a href="#数组与循环" class="headerlink" title="数组与循环"></a>数组与循环</h3><p>在循环代码中，对数组的引用通常有非常规则的模式，优化编译器会使用这些模式</p>
<h3 id="嵌套数组"><a href="#嵌套数组" class="headerlink" title="嵌套数组"></a>嵌套数组</h3><blockquote>
<p>int A[5][3];</p>
</blockquote>
<p>等价于下面的声明</p>
<blockquote>
<p>typedef int row3_t[3];<br>row3_t A[5];</p>
</blockquote>
<h3 id="固定大小的数组"><a href="#固定大小的数组" class="headerlink" title="固定大小的数组"></a>固定大小的数组</h3><h3 id="动态分配的数组"><a href="#动态分配的数组" class="headerlink" title="动态分配的数组"></a>动态分配的数组</h3><h2 id="异类的数据结构"><a href="#异类的数据结构" class="headerlink" title="异类的数据结构"></a>异类的数据结构</h2><h3 id="结构（structure）"><a href="#结构（structure）" class="headerlink" title="结构（structure）"></a>结构（structure）</h3><p>将可能不同类型的对象聚合到一个对象中。结构的各个组成部分用名字来引用。类似于数组的实现，结构的所有组成部分都存放在存储器中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段(field)的字节偏移。它以这些偏移作为存储器引用指令中的位移，从而产生对结构元素的引用。</p>
<h3 id="联合（union）"><a href="#联合（union）" class="headerlink" title="联合（union）"></a>联合（union）</h3><p>提供了一种方式，能够规避 C 语言的类型系统，允许以多种类型来引用一个对象。联合声明的语法与结构的语法一样，只不过语义相差比较大。它们是用不同的字段来引用相同的存储器块。</p>
<h2 id="对齐（alignment）"><a href="#对齐（alignment）" class="headerlink" title="对齐（alignment）"></a>对齐（alignment）</h2><p>许多计算机系统对基本数据类型合法地址做出了一些限制，要求某种类型对象的地址必须是某个值 K(通常是 2、4、8)。这种对齐限制简化了形成处理器和存储器系统之间接口的硬件设计</p>
<h2 id="综合：理解指针"><a href="#综合：理解指针" class="headerlink" title="综合：理解指针"></a>综合：理解指针</h2><p>指针是 C 语言的一个重要特征。它们以一种统一方式，对不同数据结构中的元素产生引用。这里介绍一些指针和它们映射到机器代码的关键原则：</p>
<ul>
<li>每个指针都对应一个类型。这个类型表明指针指向哪一类对象。</li>
<li>每个指针都有一个值。这个值是某个指定类型对象的地址。特殊的 NULL(0) 值表示该指针没有指向任何地方</li>
<li>指针用 &amp; 运算符创建。这个运算符可以应用到任何 lvalue 类的 C 表达式上。</li>
<li>操作符用于指针的间接引用。其结果是一个值，它的类型与该指针的类型相关。间接引用是通过存储器引用来实现的，要么是存储到一个指定的地址，要么是从指定的地址读取。</li>
<li>数组与指针紧密联系。一个数组的名字可以像一个指针变量一样引用(但是不能修改)。数组引用与指针运算和间接引用有一样的效果。数组引用和指针运算都需要用对象大小对偏移量进行伸缩。</li>
<li>将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。强制类型转换的一个效果是改变指针运算的伸缩。来看一个例子，如果 p 是一个 char* 类型的指针，那么表达式(int)p+7 计算为 p+28, 而(int)(p+7)计算为 p+7。</li>
<li>指针也可以指向函数。这提供了一个很强大的存储和向代码传递引用的功能，这些引用可以被程序的某个其他部分调用。</li>
</ul>
<h2 id="存储器的越界引用和缓冲区溢出"><a href="#存储器的越界引用和缓冲区溢出" class="headerlink" title="存储器的越界引用和缓冲区溢出"></a>存储器的越界引用和缓冲区溢出</h2><p>C 对于数组引用不进行任何边界检查，而局部变量和状态信息，都存放在栈中。这两种情况结合到一起就可能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行 ret 指令时，就会出现很严重的错误。</p>
<p>缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的通过计算机网络攻击系统安全的方法。通常，输入和程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为攻击代码(exploit code)，另外还有一些字节会用一个指向攻击代码的指针覆盖返回地址。那么执行 ret 指令的效果就是跳转到攻击代码。</p>
<p>一种攻击形式，攻击代码会使用系统调用启动一个外壳程序，给攻击者提供一组操作系统函数。另一种攻击形式是，攻击代码会执行一些未授权的任务，修复对栈的破坏，然后第二次执行 ret 指令，(表面上)正常返回给调用者。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>机器级程序和它们的汇编代码表示，与 C 程序的差别很大。在汇编语言程序中，各种数据类型之间的差别很小。程序是以指令序列来表示的，每条指令都完成一个单独的操作。部分程序状态，如寄存器和运行时栈，对程序员来说是直接可见的。</p>
<p>C 语言中缺乏边界检查，使得许多程序容易出现缓冲区溢出。虽然最近的运行时系统提供了安全保护，而且编译器帮助使得程序更加安全，但是这已经使许多系统容易收到入侵者的恶意攻击。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 信息的表示和处理]]></title>
      <url>/2018/01/24/CSAPP-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第2章笔记</p>
<a id="more"></a>
<h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><p>大部分计算机使用8位的块（或者字节）来作为最小的可寻址的存储器单元。机器级程序将存储器视为一个非常大的字节数组，称之为虚拟存储器。存储器中的每一个字节由唯一的一个地址（address）来标识，所有可能地址的集合称之为虚拟地址空间（virtual address space）</p>
<h3 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h3><p>一个字节有8位，用二进制表示就是 \00000000(2)-11111111(2) ，用十进制表示是0(10)-256(10)，用十六进制表示是00(16)-FF(16)</p>
<h3 id="字"><a href="#字" class="headerlink" title="字"></a>字</h3><p>每台计算机都有一个字长（word size），指明整数和指针数据的标称大小（nominal size），字长决定系统中最重要的参数就是虚拟地址空间的最大大小</p>
<h3 id="数据大小"><a href="#数据大小" class="headerlink" title="数据大小"></a>数据大小</h3><p>计算机和编译器使用不同的方式来编码数字，比如说不同长度的整数和浮点数，从而支持多种数据格式<br><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516797063776.jpg" alt="enter description here"></p>
<p>程序员应该力图使他们的程序在不同的计算机和编译器上可移植，可移植的其中一个方面就是<strong>使程序对不同的数据类型的确切大小不那么敏感</strong></p>
<h3 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h3><p>对于跨多个字节的程序对象，我们必须建立两个规则：这个对象的地址是什么；我们怎样在存储器中对这些字节进行排序</p>
<blockquote>
<p>小端法<br>从低有效字节到高有效字节的顺序存储对象</p>
<p>大端法<br>从高有效字节到低有效字节的顺序存储对象</p>
</blockquote>
<p>对于一个十六进制的数0x01234567：<br><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516797382468.jpg" alt="enter description here"></p>
<p>几种机器所使用的字节顺序会成为问题的情况：</p>
<ul>
<li>在不同类型的机器之间通过网络传送二进制数据。</li>
<li>当阅读表示整数数据的字节序列时，字节顺序也很重要。</li>
<li>当编写规避正常的类型的系统时。</li>
</ul>
<h3 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h3><p>C中的字符串被编码为一个以null（其值为0）字符结尾的字符数组</p>
<h3 id="表示代码"><a href="#表示代码" class="headerlink" title="表示代码"></a>表示代码</h3><p>不同的机器类型使用的是不同的并且不兼容的指令和编码方式，所以最后的二进制代码是有很强的平台依赖性的，其很少能够在不同的操作系统和机器之间进行移植</p>
<h3 id="C中的位级运算"><a href="#C中的位级运算" class="headerlink" title="C中的位级运算"></a>C中的位级运算</h3><p>包括按位与、按位或、异或运算，位运算的一个常见应用就是实现掩码运算（从一个字中选出一个组位）</p>
<h3 id="C中的逻辑运算"><a href="#C中的逻辑运算" class="headerlink" title="C中的逻辑运算"></a>C中的逻辑运算</h3><p>包括逻辑或、逻辑与、逻辑非<br>逻辑运算表达式中，第一个参数能够确定表达式的结果的时候，逻辑运算表达式就不会计算第二个参数的值</p>
<h3 id="C中的移位运算"><a href="#C中的移位运算" class="headerlink" title="C中的移位运算"></a>C中的移位运算</h3><p>向左移位运算右端补0<br>向右移位运算包含两种形式：逻辑移位（左端补0）和算数移位（左端补最高有效位）</p>
<h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2><h3 id="整型数据类型"><a href="#整型数据类型" class="headerlink" title="整型数据类型"></a>整型数据类型</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516799034435.jpg" alt="enter description here"></p>
<h3 id="无符号和二进制补码编码"><a href="#无符号和二进制补码编码" class="headerlink" title="无符号和二进制补码编码"></a>无符号和二进制补码编码</h3><p>假设一共有 w 位，每个介于 0 ~ 2^w -1 之间的数都有唯一一个 w 位的值编码，即这个函数映射是一个双射。</p>
<p>补码表示的是字的最高有效位解释为负权(negative weight)。</p>
<h3 id="有符号数和无符号数之间的转换"><a href="#有符号数和无符号数之间的转换" class="headerlink" title="有符号数和无符号数之间的转换"></a>有符号数和无符号数之间的转换</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516799175770.jpg" alt="enter description here"></p>
<h3 id="C中的有符号数和无符号数"><a href="#C中的有符号数和无符号数" class="headerlink" title="C中的有符号数和无符号数"></a>C中的有符号数和无符号数</h3><p>C 语言允许无符号数和有符号数之间的转换。转换的原则是底层的位表示保持不变。</p>
<h3 id="扩展一个数字的位表示"><a href="#扩展一个数字的位表示" class="headerlink" title="扩展一个数字的位表示"></a>扩展一个数字的位表示</h3><p>零扩展： 将一个无符号数转换为一个更大的数据类型，在开头加0<br>符号扩展： 将一个二进制补码转化为一个更大的数据类型，在开头加最高有效位</p>
<h3 id="截断数字"><a href="#截断数字" class="headerlink" title="截断数字"></a>截断数字</h3><p>截断一个数字可能会改变它的值——溢出的一种形式</p>
<h3 id="有关有符号数和无符号数的建议"><a href="#有关有符号数和无符号数的建议" class="headerlink" title="有关有符号数和无符号数的建议"></a>有关有符号数和无符号数的建议</h3><p>有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为。而这些非直观的特性经常导致程序错误，并且这种包含隐式强制类型转换细微差别的错误很难被发现。因为这种强制类型转换是在代码中没有明确指示的情况下发生的，程序员经常忽视了它的影响。</p>
<p>避免这类错误的一种方法就是绝<strong>不使用无符号数</strong>。实际上，除了 C 以外，很少有语言支持无符号整数。</p>
<h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><h3 id="无符号加法"><a href="#无符号加法" class="headerlink" title="无符号加法"></a>无符号加法</h3><p>每个数都能表示为 w 位无符号数字。如果计算它们的和，表示这个和可能需要 w + 1位。无符号运算可以被视为一种模运算形式。<br><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516800136471.jpg" alt="enter description here"></p>
<h3 id="二进制补码加法"><a href="#二进制补码加法" class="headerlink" title="二进制补码加法"></a>二进制补码加法</h3><p>必须确定当结果太大(为正)或者太小(为负)时，应该做些什么。<br><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516800211055.jpg" alt="enter description here"></p>
<h3 id="二进制补码的乘法"><a href="#二进制补码的乘法" class="headerlink" title="二进制补码的乘法"></a>二进制补码的乘法</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516800273052.jpg" alt="enter description here"></p>
<h3 id="乘以2的幂"><a href="#乘以2的幂" class="headerlink" title="乘以2的幂"></a>乘以2的幂</h3><p>在大多数机器上，整数乘法指令相当慢，需要 10 个或者更多的时钟周期，然而其他整数运算(例如加法、减法、位级运算和移位)只需要 1 个时钟周期。因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。</p>
<h3 id="除以2的幂"><a href="#除以2的幂" class="headerlink" title="除以2的幂"></a>除以2的幂</h3><p>在大多数机器上，整数除法要比整数乘法更慢——需要 30 个或者更多的周期。除以 2 的幂也可以用移位运算右移来实现，无符号和补码数分别使用逻辑移位和算术移位来达到目的。</p>
<h2 id="浮点"><a href="#浮点" class="headerlink" title="浮点"></a>浮点</h2><h3 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516800421224.jpg" alt="enter description here"></p>
<h3 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h3><p>用 V = (-1)^s <em> M </em> 2^E 的形式来表示一个数：</p>
<ul>
<li>符号(sign) s决定这个数是负数(s=1)还是正数(s=0)，对于数值 0 的符号位解释作为特殊情况处理。</li>
<li>尾数(significand) M 是一个二进制小数，它的范围是 1 ~ 2 - ε，或者是 0 ~ 1 - ε。</li>
<li>阶码(exponent) E 的作用是对浮点数加权，这个权重是 2 的 E 次幂(可能是负数)</li>
</ul>
<p>将浮点数的位表示划分为三个字段，分别对这些值进行编码：</p>
<ul>
<li>一个单独的符号位 s 直接编码符号 s。</li>
<li>k 位的阶码字段 exp = e(k-1)…e(1)e(0) 编码阶码 E。</li>
<li>n 位小数字段 frac = f(n-1)…f(1)f(0) 编码尾数 M，但是编码出来的值也依赖于阶码字段的值是否等于 0。</li>
</ul>
<h3 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h3><p>因为表示方法限制类浮点数的范围和精度，浮点运算只能近似地表示实数运算。因此，对于值 x，我们一般想用一种系统的方法，能够找到“最接近的”匹配值，这就是舍入运算的任务。</p>
<p>常见的舍入方式有：向偶数舍入、向零舍入、向下舍入、向上舍入<br><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516800599058.jpg" alt="enter description here"></p>
<h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>浮点加法不具有结合性。浮点乘法在加法上不具备分配性。对于科学计算程序员和编译器编写者来说，这是很严重的问题，即使为了在三维空间中确定两条线是否交叉而写代码这样看上去很简单的任务，也可能成为一个很大的挑战。</p>
<h3 id="C语言的浮点数"><a href="#C语言的浮点数" class="headerlink" title="C语言的浮点数"></a>C语言的浮点数</h3><p>float 和 double。在 int、float 和 double 格式之间进行强制类型转换时，程序改变数值和位模式的原则如下(假设 int 是 32 位的)：</p>
<ul>
<li>从 int 转换成 float，不会溢出，可能被舍入。</li>
<li>从 int 或 float 转换成 double，能够保留精确的数值。</li>
<li>从 double 转换成 float，可能溢出成为正无穷或负无穷，也可能被舍入。</li>
<li>从 float 或者 double 转换成 int，值会向零舍入。例如 1.999 将被转换成 1。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP 计算机系统漫游]]></title>
      <url>/2018/01/23/CSAPP%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</url>
      <content type="html"><![CDATA[<p>《深入理解计算机系统》第1章笔记</p>
<a id="more"></a>
<h2 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位+上下文"></a>信息就是位+上下文</h2><p>整个计算机系统中的所有信息都可以用一串比特串的形式表示，区分不同的数据对象的唯一方法就是我们读到的这些对象时的上下文（context）</p>
<h2 id="程序被其他程序翻译成不同的格式"><a href="#程序被其他程序翻译成不同的格式" class="headerlink" title="程序被其他程序翻译成不同的格式"></a>程序被其他程序翻译成不同的格式</h2><p>一个高级语言写的程序（这里以C语言为例），从源代码到最终的机器中的可执行文件会经过一下几个阶段：</p>
<ol>
<li>预处理阶段，处理源码的中的预处理语句（比如说#include）</li>
<li>编译阶段，将c语言编译成汇编语言</li>
<li>汇编阶段，把汇编语言翻译成机器指令</li>
<li>链接阶段，把在程序中调用的库函数的相关文件引入</li>
</ol>
<h2 id="了解编译系统如何工作室大有益处的"><a href="#了解编译系统如何工作室大有益处的" class="headerlink" title="了解编译系统如何工作室大有益处的"></a>了解编译系统如何工作室大有益处的</h2><p>促使程序员要知道编译系统是如何工作的原因：</p>
<ol>
<li>优化程序性能，我们需要对汇编语言以及编译器如何将不同的C语句转化为汇编语言有基本的了解</li>
<li>理解链接时出现的错误</li>
<li>避免安全漏洞，其中一个比较典型的是缓冲区溢出错误</li>
</ol>
<h2 id="处理器读并解释存储在存储器中的指令"><a href="#处理器读并解释存储在存储器中的指令" class="headerlink" title="处理器读并解释存储在存储器中的指令"></a>处理器读并解释存储在存储器中的指令</h2><p>一个计算机系统的硬件主要由以下几个部分组成：</p>
<ol>
<li>总线，负责携带信息字节并在各个部件之间进行传输</li>
<li>I/O设备，负责系统和外界的联系</li>
<li>主存，运行程序时存放程序以及程序中含有的数据</li>
<li>处理器，解释（或执行）存储在主存中的指令</li>
</ol>
<p>执行一个hello程序的过程有一下几部：</p>
<ul>
<li>shell程序执行其指令，等待我们输入命令</li>
<li>我们输入完命令以后，shell执行一系列指令，将hello程序的代码以及其数据加载到主存中</li>
<li>处理器开始执行hello程序中的机器指令，将“hello world”输出到屏幕上</li>
</ul>
<h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><p>我们使用的存储设备通常是较大的存储设备比较小的存储设备运行地要慢，所以就使用一个较小的速度较快的存储设备作为CPU和Main Memory交换数据的桥梁，这个设备就是高速缓存（cache memories）</p>
<h2 id="形成层次结构的存储结构"><a href="#形成层次结构的存储结构" class="headerlink" title="形成层次结构的存储结构"></a>形成层次结构的存储结构</h2><p>在计算机系统的存储设备被组织成了一个金字塔形的存储层次模型，其中从上到下，设备速度越来越慢，空间越来越大，每字节的造价越来越便宜。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516786032387.jpg" alt="enter description here"></p>
<h2 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h2><p>操作系统可以看成是一个应用程序和硬件之间的一个软件，其有两个基本功能： 防止硬件被失控的程序滥用； 为应用程序提供控制硬件的简单一致的方法</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程可以看成是操作系统对正在运行的程序的一种抽象，在一个系统中可以运行多个进程，这些进程对外表现好像是独占硬件，实际上是通过不同进程之间进程的交互执行实现的，这个过程叫上下文切换（context switch）</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程可以由多个线程组成，运行在一个上下文环境中，共享代码以及全局数据。因为共享数据，使得其比一般的进程更加高效（花在context switch的时间少）。</p>
<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p>给进程提供的一个好像自己独占主存的假象，对于进程的所使用的虚拟存储器可以分成一下几个部分：</p>
<ul>
<li>程序代码和数据</li>
<li>堆，可以动态扩展或者收缩，供像malloc和free这样的C语言中的库进行调用</li>
<li>共享库</li>
<li>栈，可以动态扩展或者收缩，用于编译器的函数调用</li>
<li>内核虚拟存储器</li>
</ul>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_24_1516786535550.jpg" alt="enter description here"></p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件可以看成字节序列，每一个I/O设备从本质上来看都可以看成是文件</p>
<h2 id="利用网络系统和其他系统进行通信"><a href="#利用网络系统和其他系统进行通信" class="headerlink" title="利用网络系统和其他系统进行通信"></a>利用网络系统和其他系统进行通信</h2><h2 id="导图"><a href="#导图" class="headerlink" title="导图"></a>导图</h2><p><img src="https://data2.liuin.cn/story-writer/2018_1_24_A%20Tour%20of%20Computer%20System.png" alt="enter description here"></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode Reverse Integer & Palindrome Number 题解]]></title>
      <url>/2018/01/22/LeetCode-Reverse-Integer-Palindrome-Number-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>LeetCode 题解</p>
<a id="more"></a>
<h2 id="Reverse-Integer"><a href="#Reverse-Integer" class="headerlink" title="Reverse Integer"></a>Reverse Integer</h2><p>题目的意思就是翻转一个整数（其中可能是负数），一开始想到的方案是分正数和负数进行讨论：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int reverse(int x) &#123;</div><div class="line">        int cnt=0,negative_flag = 0;</div><div class="line">        long long res =0;</div><div class="line">        if(x&lt;0)</div><div class="line">        &#123;</div><div class="line">            x = -x;</div><div class="line">            negative_flag = 1;</div><div class="line">        &#125;</div><div class="line">        while(x&gt;0)</div><div class="line">        &#123;</div><div class="line">            res = res*10 + x%10;</div><div class="line">            x/=10;</div><div class="line">        &#125;</div><div class="line">        if(res&gt;INT_MAX) return 0;</div><div class="line">        if(negative_flag)</div><div class="line">            return -res;</div><div class="line">        else</div><div class="line">            return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>其实是可以不用处理负数的问题的，更加简洁的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int reverse(int x) &#123;</div><div class="line">        int res =0;</div><div class="line">        while(x)</div><div class="line">        &#123;</div><div class="line">            if(abs(res)&gt;INT_MAX/10) return 0;</div><div class="line">            res = res*10 + x%10;</div><div class="line">            x/=10;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>其中涉及到C++的负数的除法和取余问题，在后面会讲到</p>
<h2 id="Palindrome-Number"><a href="#Palindrome-Number" class="headerlink" title="Palindrome Number"></a>Palindrome Number</h2><p>判断一个数是不是回文数，不可以使用额外的空间</p>
<p>一开始考虑将数进行翻转然后确定是否相等进行判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isPalindrome(int x) &#123;</div><div class="line">        int y = x,res = 0;</div><div class="line">        if(x&lt;0) return false;</div><div class="line">        while(y)</div><div class="line">        &#123;</div><div class="line">            res = res *10 + y%10;</div><div class="line">            y/=10;</div><div class="line">        &#125;</div><div class="line">        if(res == x)</div><div class="line">            return true ;</div><div class="line">        else</div><div class="line">            return false ;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>结果：<br>Your runtime beats 22.66 % of cpp submissions</p>
<p>另外一种方案就是先计算出这个数的位数，然后从两边开始判断，但是好像也没有优化多少。<br>还有可以通过转化为String进行判断，一开始以为这种方案不满足题目的“不可以使用额外的空间”的要求，但是还是能够通过，只不过时间比前面两种方案多很多。</p>
<h2 id="C-负数的除法和取余问题"><a href="#C-负数的除法和取余问题" class="headerlink" title="C++负数的除法和取余问题"></a>C++负数的除法和取余问题</h2><p>C++ 的除法和取余问题：（C++11标准）</p>
<ul>
<li>商一律向0取整（即直接切除小数部分）</li>
<li>对于m/n，如果m和n的符号相同，则结果为正</li>
<li>m%n不等于0，则其结果的符号的m相同</li>
<li>(-m)/n = m/(-n) = -(m/n)  ； m%(-n) = m%n  ； (-m)%n = -(m%n)</li>
</ul>
<p>示例：</p>
<ul>
<li>(-21)%(-8) = (-21)%8 = - (21%8) = -5</li>
<li>-21/-8 = 21/8 = 2</li>
<li>21%(-5) = 21%5 = 1</li>
<li>21/(-5) = -(21/5) = -4</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法技巧 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[读书笔记汇总]]></title>
      <url>/2018/01/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<p>对在读、已读的书籍相关笔记的汇总，持续更新中。</p>
<a id="more"></a>
<p>读书到底有多重要？我找不到一个合适的词汇来形容。人是非常渺小的生物，在世不过百年，每个人都不得不遵循这个恒定的时间限制，但，读书也许是超越这个限制的方法。</p>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><ol>
<li>《深入理解计算机系统》CSAPP | <a href="/tags/CSAPP/">笔记</a></li>
<li>《计算机网络——自顶向下方法》 | <a href="/2018/02/05/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B-%E7%AC%94%E8%AE%B0/">笔记</a></li>
</ol>
<h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><ol>
<li>《C++ Primer》 | <a href="/2018/02/13/%E3%80%8AC-Primer%E3%80%8B-%E7%AC%94%E8%AE%B0%E7%9B%AE%E5%BD%95/">笔记</a></li>
<li>《Effective C++》 | <a href="/2018/04/19/%E3%80%8AEffective-C-%E3%80%8B-%E7%AC%94%E8%AE%B0/">笔记</a></li>
<li>《STL 源码剖析》 | <a href="/2018/05/20/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B-%E7%AC%94%E8%AE%B0/">笔记</a></li>
</ol>
<h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><ol>
<li>《Go 语言圣经》 | <a href="https://github.com/Sixzeroo/Golang-tutorial" target="_blank" rel="external">笔记</a></li>
</ol>
<h2 id="Unix-Linux"><a href="#Unix-Linux" class="headerlink" title="Unix/Linux"></a>Unix/Linux</h2><ol>
<li>《Unix环境高级编程》 APUE | <a href="/2018/02/05/APUE-%E7%AC%94%E8%AE%B0%E7%9B%AE%E5%BD%95/">笔记</a></li>
<li>《UNIX网络编程卷1》 UNP | 笔记 <a href="/2018/05/15/%E3%80%8AUNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B71%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AE%80%E4%BB%8B%E9%83%A8%E5%88%86/">第一部分</a> <a href="/2018/05/23/%E3%80%8AUNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B71%E3%80%8B%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%E9%83%A8%E5%88%86/">第二部分</a> <a href="">第三部分</a></li>
</ol>
<h2 id="技艺磨练"><a href="#技艺磨练" class="headerlink" title="技艺磨练"></a>技艺磨练</h2><ol>
<li>《Pro Git》 | <a href="/tags/Git/">笔记</a></li>
<li>《大型网站技术架构》| <a href="/2018/06/18/%E3%80%8A%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E3%80%8B-%E7%AC%94%E8%AE%B0/">笔记</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Java servlet 结合Bootstrap-table 展示表格数据]]></title>
      <url>/2018/01/16/Java-servlet-%E7%BB%93%E5%90%88Bootstrap-table-%E5%B1%95%E7%A4%BA%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<p>近期做数据库课设，用到的一个前端展示Table的工具——bootstrap-table，在这里记录一下其用法</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Bootstrap-Table是一个Boostrap的表格插件，能够将JSON数据直接显示在表格中。官方<a href="http://bootstrap-table.wenzhixin.net.cn/" target="_blank" rel="external">网址</a>。里面可以下载使用所需的JS和CSS文件，以及参考文档和例子。</p>
<p>Bootstrap-Table显示数据到表格的方式有两种，一种是客户端（client）模式，一种是服务器（server）模式。</p>
<p>所谓客户端模式，指的是在服务器中把要显示到表格的数据一次性加载出来，然后转换成JSON格式传到要显示的界面中，在JavaWeb中可以保存在request中，然后转发到指定界面，在界面初始化的时候使用EL表达式获取，然后调用相关初始化的函数，将JSON字符串传进去即可显示。客户端模式较为简单，它是把数据一次性加载出来放到界面上，然后根据你设置的每页记录数，自动生成分页。当点击第二页时，会自动加载出数据，不会再向服务器发送请求。同时用户可以使用其自带的搜索功能，可以实现全数据搜索。对于数据量较少的时候，可以使用这个方法。但是对于数据量大的系统，使用该方法会造成加载出一些很久之前的，用户不在关注的数据，使得加载速度变慢，增加了服务器的负担，浪费了资源。这时应该采用服务器模式。</p>
<p>所谓服务器模式，指的是根据设定的每页记录数和当前要显示的页码，发送数据到服务器进行查询，然后再显示到表格中。该方法可以根据用户的需要动态的加载数据，节省了服务器的资源，但是不能使用其自带的全数据搜索功能。因为你加载的数据只是一页的数据，所以全数据搜索的范围也只在一页之中。</p>
<p>这篇文章就以客户端模式为例，服务器模式在客户端模式的基础要多做一个后端分页的处理。</p>
<p>最终做到效果如下：<br>![enter description here][1]</p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>HTML文件中引入相关的JS和CSS，定义一个表格标签，配置相关的boostrap-table属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=utf-8"</span></span></div><div class="line">    <span class="attr">pageEncoding</span>=<span class="string">"utf-8"</span>%&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">%@taglib</span> <span class="attr">uri</span>=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> <span class="attr">prefix</span>=<span class="string">"c"</span>%&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>课程<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">	 <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/styleCourse.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/stylelittle.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></div><div class="line"> 	<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/bootstrap-table.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></div><div class="line"> 	<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/font-awesome.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>  <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"css/jquery-3.2.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>  <span class="attr">src</span>=<span class="string">"css/bootstrap.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"css/jquery.validate.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">script</span>  <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"css/bootstrap-table.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">" line-height:6em;"</span>&gt;</span> <span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></div><div class="line">	<span class="comment">&lt;!--网页中间内容--&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"panelBody"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel panel-default"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel-heading"</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">"panel-title"</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>课程<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel-body"</span>&gt;</span></div><div class="line"></div><div class="line">				<span class="comment">&lt;!--</span></div><div class="line">					here 第一块</div><div class="line">					search</div><div class="line">				--&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"searchArea"</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-4"</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input-group"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"input-group-addon"</span>&gt;</span></div><div class="line">                  Name</div><div class="line">                <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span>  <span class="attr">placeholder</span>=<span class="string">".."</span> <span class="attr">aria-label</span>=<span class="string">".."</span>&gt;</span></div><div class="line">              <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-4"</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input-group"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"input-group-addon"</span>&gt;</span></div><div class="line">                  ID</div><div class="line">                <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span>  <span class="attr">placeholder</span>=<span class="string">"null means all"</span> <span class="attr">aria-label</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">              <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">span</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-default btn-outline"</span>&gt;</span></div><div class="line">                  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"searchText"</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-search"</span> <span class="attr">id</span>=<span class="string">"searchBtn"</span>&gt;</span>  search<span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">                  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">              <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tableShow"</span> <span class="attr">id</span>=<span class="string">"courseTable"</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"table-hover"</span> <span class="attr">id</span>=<span class="string">"productTable"</span>&gt;</span></div><div class="line"></div><div class="line">          <span class="tag">&lt;/<span class="name">table</span>&gt;</span></div><div class="line">       	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在js代码中，使用bootstarpTable对id为productTable的表格进行初始化，其中url参数为请求发送的地址，method为请求发送的方法，dataField为返回的json数据中table要展示的数据在是哪个key对应的value，columns为Table的栏位的定义，也对应的返回的json数据中的各个栏位。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#productTable'</span>).bootstrapTable(&#123;</div><div class="line">    <span class="attr">striped</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">clickToSelect</span>: <span class="literal">true</span>, <span class="comment">//点击行就选中</span></div><div class="line">    silent: <span class="literal">true</span>,</div><div class="line">    <span class="attr">showPaginationSwitch</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">showToggle</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">showColumns</span>: <span class="literal">true</span>,  <span class="comment">//显示隐藏列</span></div><div class="line">    showRefresh: <span class="literal">true</span>,  <span class="comment">//显示刷新按钮</span></div><div class="line">    singleSelect: <span class="literal">true</span>, <span class="comment">//复选框只能选择一条记录</span></div><div class="line">    url: <span class="string">'/course/list'</span>, <span class="comment">//servlet地址</span></div><div class="line">    method: <span class="string">'get'</span>,</div><div class="line">    <span class="attr">dataField</span> : <span class="string">"data"</span>,</div><div class="line">    <span class="attr">queryParams</span>: queryParams, <span class="comment">//查询参数</span></div><div class="line">    locale:<span class="string">'zh-CN'</span>, <span class="comment">//国际化</span></div><div class="line">    pagination: <span class="literal">true</span>, <span class="comment">//开启分页</span></div><div class="line">    sidePagination: <span class="string">'client'</span>, <span class="comment">//服务端分页</span></div><div class="line">    pageSize: <span class="number">10</span>,    <span class="comment">//分页条数</span></div><div class="line">    pageList: [<span class="number">10</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">200</span>],</div><div class="line">    <span class="attr">search</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">idField</span>: <span class="string">'ID'</span>,</div><div class="line">    <span class="attr">columns</span>:[</div><div class="line">    &#123;<span class="attr">field</span>:<span class="string">''</span>,<span class="attr">title</span>:<span class="string">''</span>,<span class="attr">checkbox</span>:<span class="literal">true</span>&#125;, <span class="comment">//复选框</span></div><div class="line">    &#123;<span class="attr">field</span>:<span class="string">'id'</span>,<span class="attr">title</span>:<span class="string">'课程ID'</span>,<span class="attr">align</span> : <span class="string">'center'</span>&#125;,</div><div class="line">    &#123;<span class="attr">field</span>:<span class="string">'name'</span>,<span class="attr">title</span>:<span class="string">'课程名称'</span>,<span class="attr">align</span> : <span class="string">'center'</span>&#125;,</div><div class="line">    &#123;<span class="attr">field</span>:<span class="string">'type'</span>,<span class="attr">title</span>:<span class="string">'类型'</span>,<span class="attr">align</span> : <span class="string">'center'</span>&#125;,</div><div class="line">    &#123;<span class="attr">field</span>:<span class="string">'credit'</span>,<span class="attr">title</span>:<span class="string">'学分'</span>,<span class="attr">align</span> : <span class="string">'center'</span>&#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">title</span> : <span class="string">'操作'</span>,</div><div class="line">            <span class="attr">field</span> : <span class="string">'id'</span>,</div><div class="line">            <span class="attr">align</span> : <span class="string">'center'</span>,</div><div class="line">            <span class="attr">formatter</span> : <span class="function"><span class="keyword">function</span>(<span class="params">value, row, index</span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> e = <span class="string">'&lt;a href="#" mce_href="#" onclick="edit(\''</span></div><div class="line">                    + row.id + <span class="string">'\',\''</span>+row.name+<span class="string">'\')"&gt;编辑&lt;/a&gt; '</span>;</div><div class="line">                <span class="keyword">var</span> d = <span class="string">'&lt;a href="#" mce_href="#" onclick="del(\''</span></div><div class="line">                    + row.id + <span class="string">'\')"&gt;删除&lt;/a&gt; '</span>;</div><div class="line">                <span class="keyword">var</span> f = <span class="string">'&lt;a href=/course/detail?course_id='</span>+row.id+<span class="string">'&gt;详情&lt;/a&gt;'</span>;</div><div class="line">                <span class="keyword">return</span> e + d + f;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryParams</span>(<span class="params">params</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">NAME</span>:params.search, <span class="comment">//开启自带查询后输入的值</span></div><div class="line">        ISDEL:<span class="number">0</span>,</div><div class="line">        <span class="attr">pageSize</span>: params.limit, <span class="comment">//分页条数</span></div><div class="line">        pageNumber: params.pageNumber <span class="comment">//当前页数</span></div><div class="line">    &#125;;</div><div class="line">&#125; <span class="comment">//在这里你可以自己定义查询的参数</span></div></pre></td></tr></table></figure>
<p>json 数据实例：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"data"</span>:</div><div class="line">  [</div><div class="line">    &#123;</div><div class="line">    <span class="attr">"id"</span>:<span class="string">"XXXXXX"</span>,</div><div class="line">    <span class="attr">"name"</span>: <span class="string">"语文"</span>,</div><div class="line">    <span class="attr">"type"</span>: <span class="string">"必修"</span>,</div><div class="line">    <span class="attr">"credit"</span>: <span class="number">4.0</span></div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>后端要做的事情就是接受前端发来的请求，返回要展示的table数据就行了（按照相应的格式）</p>
<p>主要处理代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@WebServlet</span>(<span class="string">"/course/list"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetCourselistServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException,IOException </span>&#123;</div><div class="line"></div><div class="line">        response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</div><div class="line">        response.setContentType(<span class="string">"application/json; charset=utf-8"</span>);</div><div class="line"></div><div class="line">        CourseDaoImpl c = <span class="keyword">new</span> CourseDaoImpl();</div><div class="line">        List&lt;Course&gt; res = c.getAllCourse();</div><div class="line">        String jsonStr = Obj2Json.Course2Json(res);    <span class="comment">// 将获得Course List数据转化为json格式</span></div><div class="line"></div><div class="line">        PrintWriter out = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            out = response.getWriter();</div><div class="line">            out.write(jsonStr);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</div><div class="line">                out.close();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException,IOException</span>&#123;</div><div class="line">        doGet(request,response);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h2><p>首先就是要在前端加两个输入表单的table：（这里只放修改的div代码，增加表单的代码类似）<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal fade"</span> <span class="attr">id</span>=<span class="string">"updateModal"</span> <span class="attr">tabindex</span>=<span class="string">"-1"</span> <span class="attr">role</span>=<span class="string">"dialog"</span></span></div><div class="line">     <span class="attr">aria-labelledby</span>=<span class="string">"myModalLabel"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-dialog"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-content"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-header"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"close"</span> <span class="attr">data-dismiss</span>=<span class="string">"modal"</span></span></div><div class="line">                        <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;×<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"modal-title"</span> <span class="attr">id</span>=<span class="string">"myModalLabel"</span>&gt;</span>修改课程<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-body"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">form</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">label</span>&gt;</span>课程ID<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span></span></div><div class="line">                                                   <span class="attr">id</span>=<span class="string">"updateId"</span>&gt;</div><div class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">label</span>&gt;</span>课程名称<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span></span></div><div class="line">                                                   <span class="attr">id</span>=<span class="string">"updateName"</span>&gt;</div><div class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">label</span>&gt;</span>课程类型<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"updateType"</span> <span class="attr">class</span>=<span class="string">"form-control"</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">0</span>&gt;</span>必修<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">1</span>&gt;</span>选修<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">label</span>&gt;</span>学分<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">class</span>=<span class="string">"form-control"</span></span></div><div class="line">                                                 <span class="attr">id</span>=<span class="string">"updateCredit"</span>&gt;</div><div class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-footer"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span> <span class="attr">data-dismiss</span>=<span class="string">"modal"</span>&gt;</span>关闭</div><div class="line">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span> <span class="attr">id</span>=<span class="string">"updateConfirmBtn"</span>&gt;</span>提交更改<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- /.modal-content --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- /.modal-dialog --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后就是JavaScript对增删改的处理了，这个应该是这个里面最关键的东西：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 单独删除按键</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">del</span>(<span class="params">id</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (confirm(<span class="string">"是否删除?"</span>)) &#123;</div><div class="line">        $.ajax(&#123;</div><div class="line">            <span class="attr">url</span> : <span class="string">"/course/delete"</span>,</div><div class="line">            <span class="attr">method</span>: <span class="string">"post"</span>,</div><div class="line">            <span class="attr">data</span> : &#123;</div><div class="line">                <span class="string">"id"</span> : id</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">success</span> : <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">                alert(<span class="string">"删除成功！"</span>);</div><div class="line">                <span class="comment">//重新加载表格</span></div><div class="line">                $(<span class="string">"#table"</span>).bootstrapTable(<span class="string">"refresh"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//编辑按钮点击事件</span></div><div class="line"><span class="keyword">var</span> idGlobal = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">edit</span>(<span class="params">id,name</span>) </span>&#123;</div><div class="line">    $(<span class="string">"#updateModal"</span>).modal(<span class="string">'show'</span>);</div><div class="line">    idGlobal = id;</div><div class="line">    <span class="comment">//信息</span></div><div class="line">    $(<span class="string">"#updateId"</span>).val(id);</div><div class="line">    $(<span class="string">"#updateName"</span>).val(name);</div><div class="line">    $(<span class="string">"#updateType"</span>).val(<span class="number">0</span>);</div><div class="line">    $(<span class="string">"#updateCredit"</span>).val(<span class="string">""</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//编辑模态框下确认按钮的点击事件</span></div><div class="line">$(<span class="string">"#updateConfirmBtn"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $(<span class="string">"#updateModal"</span>).modal(<span class="string">'hide'</span>);</div><div class="line">    $.ajax(&#123;</div><div class="line">        <span class="attr">url</span> : <span class="string">"/course/update"</span>,</div><div class="line">        <span class="attr">method</span> : <span class="string">'post'</span>,</div><div class="line">        <span class="attr">data</span> : &#123;</div><div class="line">            <span class="attr">id</span> : idGlobal,</div><div class="line">            <span class="attr">name</span> : $(<span class="string">"#updateName"</span>).val(),</div><div class="line">            <span class="attr">type</span>: $(<span class="string">"#updateType"</span>).val(),</div><div class="line">            <span class="attr">credit</span>: $(<span class="string">"#updateCredit"</span>).val()</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">success</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            alert(<span class="string">"修改成功！"</span>);</div><div class="line">            <span class="comment">//重新加载表格</span></div><div class="line">            $(<span class="string">"#table"</span>).bootstrapTable(<span class="string">"refresh"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//添加按钮点击事件</span></div><div class="line">$(<span class="string">"#btn_save"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//借用修改的模态框</span></div><div class="line">    $(<span class="string">"#saveModal"</span>).modal(<span class="string">'show'</span>);</div><div class="line">    <span class="comment">//清楚输入框信息</span></div><div class="line">    $(<span class="string">"#saveId"</span>).val(<span class="string">""</span>);</div><div class="line">    $(<span class="string">"#saveName"</span>).val(<span class="string">""</span>);</div><div class="line">    $(<span class="string">"#saveType"</span>).val(<span class="number">0</span>);</div><div class="line">    $(<span class="string">"#saveCredit"</span>).val(<span class="string">""</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//添加用户模态框下的确认按钮点击事件</span></div><div class="line">$(<span class="string">"#saveConfirmBtn"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $(<span class="string">"#saveModal"</span>).modal(<span class="string">'hide'</span>);</div><div class="line">    $.ajax(&#123;</div><div class="line">        <span class="attr">url</span> : <span class="string">"/course/add"</span>,</div><div class="line">        <span class="attr">method</span> : <span class="string">'post'</span>,</div><div class="line">        <span class="attr">datatype</span>:<span class="string">'json'</span>,</div><div class="line">        <span class="attr">data</span> : &#123;</div><div class="line">            <span class="attr">id</span> : $(<span class="string">"#saveId"</span>).val(),</div><div class="line">            <span class="attr">name</span> : $(<span class="string">"#saveName"</span>).val(),</div><div class="line">            <span class="attr">type</span>: $(<span class="string">"#saveType"</span>).val(),</div><div class="line">            <span class="attr">credit</span>: $(<span class="string">"#saveCredit"</span>).val()</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">success</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            alert(<span class="string">"添加成功！"</span>);</div><div class="line">            <span class="comment">//重新加载表格</span></div><div class="line">            $(<span class="string">"#productTable"</span>).bootstrapTable(<span class="string">"refresh"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>后端代码就是常规的处理逻辑，根据get请求的参数实施对数据库的操作</p>
<hr>
<p><a href="http://blog.csdn.net/lzx_longyou/article/details/50563907" target="_blank" rel="external">参考1</a></p>
<p>  [1]: <a href="https://data2.liuin.cn/story-writer/2018_1_19_1516292440320.jpg" target="_blank" rel="external">https://data2.liuin.cn/story-writer/2018_1_19_1516292440320.jpg</a> “效果”</p>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[台湾交换总结]]></title>
      <url>/2018/01/15/%E5%8F%B0%E6%B9%BE%E4%BA%A4%E6%8D%A2%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>131天，在湾湾的这些时候一定会是我人生中最难忘的记忆。感受到的东西、收获到的东西实在是太多了。如果回到当初做决定的那个时刻，我还会选台湾！</p>
<a id="more"></a>
<h2 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴"></a>时间轴</h2><ul>
<li>2017.9.5 到达台湾第一天，等房东，打扫房间到很晚</li>
<li>2017.9.8 台科大召开说明会，正式开启交换生活</li>
<li>2017.9.9 第一次出游——淡水之行，红毛城、小白宫、渔人码头</li>
<li>2017.9.10 第一次逛三校（台大、台科大、台师大）</li>
<li>2017.9.12 上的第一堂课，资讯安全导论，但是老师不给加签</li>
<li>2017.9.14 第一堂台大的课，Compiler，成为我交换的这一个学期里面最有挑战的课</li>
<li>2017.9.16 总统府、中正纪念堂、国家图书馆、101夕阳与夜景、象山，这一天去的地方有点多，遇见了好哥们——祥哥</li>
<li>2017.9.23 十分、九份、看阿妹茶楼，买到了一个“十分幸福”的纪念品</li>
<li>2017.9.29 师大的第一堂游泳课</li>
<li>2017.10.4 独自一人跑去故宫博物馆、国父纪念馆，依然记得当时天气是小雨，我在故宫博物馆前拍了好久的延时摄影</li>
<li>2017.10.7 联假开始，到达花莲，游玩鲤鱼潭，一路风雨相伴，偶尔有点小太阳，遇见张阿姨，入住超赞的海景民宿</li>
<li>2017.10.8 一日太鲁阁包车游，清水断崖的美景依旧在我的脑海中，还有七星潭的浪和突如其来的大雨</li>
<li>2017.10.9 骑电动机车绕花莲耍，又到了一次七星潭，晚上在罗东夜市看了难忘的烟火表演</li>
<li>2017.10.10 兰阳博物馆，超赞的建筑</li>
<li>2017.10.19 第一次进台大图书馆，感觉是自己见过的最赞的图书馆，之后每个周末必来</li>
<li>2017.10.21 动物园+猫空缆车，门票超便宜</li>
<li>2017.10.26 Compiler期中考试，考得极差，在椰林大道坐了很久，考虑要不要放弃，最后还好坚持了下来</li>
<li>2017.10.28 祥哥陪我看午夜电影，在网吧玩了一个通宵，见识了凌晨四点的台北，迎来了我的第20岁生日，晚上的party很开心</li>
<li>2017.11.11 台湾社会变迁老师带领参观景美人权文化园区，学习许多台湾的历史</li>
<li>2017.11.18 在台北捷运上待了一天，集了44个台北捷运站纪念章，晚上累趴</li>
<li>2017.11.25 凌晨和祥哥爬剑潭山，走了一段伸手不见五指的山路，从不同的角度见识了台北的夜景。回家的时候为了省钱骑Ubike，半路雨越下越大，到家的时候已经是凌晨四点，全身湿透</li>
<li>2017.11.26 台湾科技馆，当了一回小朋友</li>
<li>2017.12.2 台中玩耍，高美湿地的风真心大，晚上第一次住上下铺的民宿，一起的马拉西亚小伙和湾湾国中老师讲了很多我不曾了解的事情</li>
<li>2017.12.3 打卡路思义教堂，台湾美术馆看了很美的但是看不懂的东西</li>
<li>2017.12.9 和台陆会的小伙伴一起骑行湾湾极东</li>
<li>2017.12.16 和小姐姐们一起去了阿里山看日出，冬季在台北待久了只要能看到太阳就美滋滋，晚上感受了演唱会的那种热情</li>
<li>2017.12.21 凌晨一点搭最后一班捷运去官渡大桥看日出</li>
<li>2017.12.23 和祥哥屁颠屁颠跑到日月潭，坐船绕日月潭玩了一圈</li>
<li>2017.12.24 看了一场美到爆的日出，环日月潭骑行</li>
<li>2017.12.30 台北2018世界新车大展（其实是去看车模的）</li>
<li>2018.1.1 两个大男生爬剑南山被两只流浪狗吓跑；四四南村，台北101的烟火带着我们一行四人走进2018的大门</li>
<li>2018.1.5 晚上爬金面山，最后看一眼台北夜景</li>
<li>2018.1.12 考完最后一门考试，舍不得离开</li>
<li>2018.1.13 填完自己挖的坑，又在台北捷运上待了半天，集齐想要的捷运纪念章</li>
<li>2018.1.14 再见了，湾湾</li>
</ul>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>从湾湾这边课程专业知识方面来说我还是学到很多的，个人觉得台湾的老师能够更多的结合实际的应用，课堂上老师能够带来当下最新的技术的一些介绍和讲解。台科大这边的有些专业课会有一个业界讲师演讲的部分，请到IT领域的从业者来从他们的角度讲我们学的东西以及行业中要用到的东西，这可能会使得我们更有参与感（感觉我们学的东西就是身边用的）。可能以上的这些差别跟湾湾这边更加注重产学结合有关吧，台科大和台大貌似每个系都有产学结合办公室负责这一块的东西。</p>
<p>还有一个原因我觉得是老师方面的，我在台科大和台大修的课有一半的老师的经历是在行业内的一些知名的公司就职了一段时间以后转到高校来任教的，所以自然课堂上的内容就会和实际业界使用的东西结合起来。</p>
<p>但是时间是有限的，如果花了很多的时间花在讲解介绍最新应用和技术上面，在课堂教学的时候花在专业知识的详细讲解上面的经历就会减少，所以想要学到东西很多时候就需要自学了，就像OS课一样，课堂上看起来很有趣，本身课程也非常有意义，要我们去trace一个操作系统的代码然后增加一些system call，但是这个是要我们课后花非常多的时间的，如果一开始没有做好的话后面就会妥协，最后做出来的东西的质量学到的东西的质量自然也会大打折扣。</p>
<p>这一点做得非常好的是我在台大所学的Compiler的老师，老师之前是美国HP里面的资深Compiler工程师，他能够把Compiler的基本知识讲清楚，又能够带来最新的一些资讯（比如台大和ARM公司合作的什么内容），通过有难度的作业让学生做一个基础的Compiler，感受Compiler从设计到细节实现的各方面的东西。之前看过一篇关于中美大学教育差异的文章，其中讲到一点是美国的课程少而精而中国的课程比较多，个人感觉这门Compiler课是和美国教育最像的一门课，每周上课3个学时，课外至少要花6个学时以上（可能也是我不太适应英文环境的原因吧），还有小班讨论、助教制度等等都和美国那边挺像的。</p>
<p>资料库的老师本身是软件公司的架构师转过来的，能够从数据库的角度更多得带来程序开发与服务架构方面的东西，这些可能就是台湾那边科技大学的特色吧。感觉老师能够用白话的形式把一些比较难的概念讲得比较清楚，或许这就是真正的大佬吧。</p>
<p>总之各个专业课的教授方式和我在大陆学校还是有蛮大的区别的，可以说各有各的优点吧。</p>
<h2 id="课外活动"><a href="#课外活动" class="headerlink" title="课外活动"></a>课外活动</h2><p>课外活动方面感觉差别不是很大，专业方面湾湾这边有各种专业社团的社课（有各种干货），大陆这边我所在学校好像实验室的大佬貌似也有这种分享活动。差不多是一种性质的吧。</p>
<p>能够感受到的一点差别就是湾湾这边公司和大师的讲座相对丰富一些，专业方面有很多知名企业和人物来办讲座（我了解到的有Intel的AI讲座、微软亚洲研究院院长的讲座等等），非专业方面的讲座一般是由学生组织请的比较有名的任务来演讲，每周在Facebook上有很多各个学校的这种类型讲座宣传，所以只要你想听，基本上周一到周五的晚上都能够排满。</p>
<h2 id="生活方式"><a href="#生活方式" class="headerlink" title="生活方式"></a>生活方式</h2><p>可以说在台北和在宣城完全是两种不同的生活方式，在宣城感觉更像是高三的时候在一个封闭刻苦的环境下钻研学习的那种模式，三点一线：学校、食堂、教室（实验室），唯一多了的就是能够使用网络。周末能够去市区玩一下，但是除了看电影吃饭感觉就没有什么东西能够玩的了。除了网络感觉没有什么能够点缀我们的生活的了。生活的便利性全部靠网购来维持。</p>
<p>而在台湾则是另外一种比较不同的生活方式，更像是一个上班族的一种生活方式或者是影视作品里面大学生的那种生活方式。早上起床，坐公交车去学校上课，上课的地点分布在不同的教学楼间（有的时候还要跨校上课），晚上想自习到几点都有地方能够给你待，公交车最晚能够到凌晨，不行还有Ubike可以骑。在学校的晚上会去健身房转一圈，每个星期安排两次游泳练习。周末感觉有永远玩不完的地方，放长一点的假期还能够去远一点的地方玩一下。因为是在一个比较大的城市里面，各种设施都非常全，不管几点只要你带钱了，你就饿不着（遍地的711和全家）。</p>
<p>当然以上的这些差别有很大一部分因素是主观意愿导致的，在大陆可能更加注重学习所以没有关注相关的活动，在台湾则希望能够多玩一会多体验一下湾湾的特色生活，所以会关注甚至发起一些活动。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>湾湾交换生涯带给我的除了这些东西，我想还有的就是人生路上这段难忘的经历吧。</p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从零开始配置Ubuntu基本开发环境]]></title>
      <url>/2018/01/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AEUbuntu%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<p>最近要配置一个能够进行轻度开发的Ubuntu虚拟机，在这里记录一下从零开始配置的过程，持续更新</p>
<a id="more"></a>
<h2 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><h3 id="设置UTC"><a href="#设置UTC" class="headerlink" title="设置UTC"></a>设置UTC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/default/rcS</div></pre></td></tr></table></figure>
<p>将UTC=no改为UTC=yes</p>
<h3 id="设置apt源代理"><a href="#设置apt源代理" class="headerlink" title="设置apt源代理"></a>设置apt源代理</h3><p>编辑<code>/etc/apt/sources.list</code>，添加以下内容，用以添加阿里的apt源代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">deb http://mirrors.cloud.aliyuncs.com/ubuntu/ trusty main restricted universe multiverse</div><div class="line">deb http://mirrors.cloud.aliyuncs.com/ubuntu/ trusty-security main restricted universe multiverse</div><div class="line">deb http://mirrors.cloud.aliyuncs.com/ubuntu/ trusty-updates main restricted universe multiverse</div><div class="line">deb http://mirrors.cloud.aliyuncs.com/ubuntu/ trusty-proposed main restricted universe multiverse</div><div class="line">deb http://mirrors.cloud.aliyuncs.com/ubuntu/ trusty-backports main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</div></pre></td></tr></table></figure>
<h3 id="生成公钥私钥"><a href="#生成公钥私钥" class="headerlink" title="生成公钥私钥"></a>生成公钥私钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygon</div></pre></td></tr></table></figure>
<p>然后可以将公钥加入到github、bitbucket、gitlab等代码托管平台中，方便将仓库中的代码克隆到本地</p>
<h2 id="必备软件配置"><a href="#必备软件配置" class="headerlink" title="必备软件配置"></a>必备软件配置</h2><h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><p>必备编辑器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install vim</div></pre></td></tr></table></figure></p>
<h3 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h3><p>必备浏览器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">13  sudo wget http://www.linuxidc.com/files/repo/google-chrome.list -P /etc/apt/sources.list.d/</div><div class="line">14  wget -q -O - https://dl.google.com/linux/linux_signing_key.pub  | sudo apt-key add -</div><div class="line">15  sudo apt-get update</div><div class="line">16  sudo apt-get install google-chrome-stable</div><div class="line">17  /usr/bin/google-chrome-stable</div></pre></td></tr></table></figure></p>
<p>安装完成以后锁定Chrome到Launcher就行了<br><a href="http://www.linuxidc.com/Linux/2016-05/131096.htm" target="_blank" rel="external">参考</a></p>
<h3 id="Shadowsocks-qt5"><a href="#Shadowsocks-qt5" class="headerlink" title="Shadowsocks-qt5"></a>Shadowsocks-qt5</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>查看<a href="https://appimage.org/" target="_blank" rel="external">Appimage</a>介绍<br>到<a href="https://github.com/shadowsocks/shadowsocks-qt5/releases" target="_blank" rel="external">这里</a>下载最新的发布版本<br>运行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod a+x Shadowsocks-Qt5-x86_64.AppImage</div><div class="line">./Shadowsocks-Qt5-x86_64.AppImage</div></pre></td></tr></table></figure></p>
<p>为了避免每次开ss的时候都要开一个终端，可以使用nohup让其在后台运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">echo &quot;nohup /home/sixzeroo/ss/Shadowsocks-Qt5-3.0.0-x86_64.AppImage &amp;&quot; &gt;&gt; ~/ss/start.sh</div><div class="line">sudo chmod +x start.sh</div><div class="line">sudo ln -s /home/sixzeroo/ss/start.sh /usr/local/bin/ss_start</div></pre></td></tr></table></figure></p>
<p>这样以后只要运行ss_start然后关掉terminal就能够运行了<br><a href="https://github.com/shadowsocks/shadowsocks-qt5/wiki/Installation" target="_blank" rel="external">参考</a></p>
<h4 id="Chrome-代理配置"><a href="#Chrome-代理配置" class="headerlink" title="Chrome 代理配置"></a>Chrome 代理配置</h4><p>除了安装ss，还需要配置下浏览器到指定到代理端口比如1080才可以正式上网。这里使用SwitchyOmega插件，下载<a href="https://github.com/FelisCatus/SwitchyOmega/releases/" target="_blank" rel="external">https://github.com/FelisCatus/SwitchyOmega/releases/</a> ，然后打开 chrome://extensions ,将下载的插件拖入浏览器中</p>
<p>配置一个代理到你ss设置的端口就完成了连接。</p>
<p><a href="https://www.sundabao.com/ubuntu%E4%BD%BF%E7%94%A8shadowsocks/" target="_blank" rel="external">参考</a></p>
<h3 id="Google-拼音输入法"><a href="#Google-拼音输入法" class="headerlink" title="Google 拼音输入法"></a>Google 拼音输入法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install fcitx fcitx-googlepinyin im-config</div><div class="line">im-config</div></pre></td></tr></table></figure>
<p>参照<a href="https://www.linuxdashen.com/ubuntu%E5%AE%89%E8%A3%85%E8%B0%B7%E6%AD%8C%E6%8B%BC%E9%9F%B3%E8%BE%93%E5%85%A5%E6%B3%95%EF%BC%88fcitx%E8%BE%93%E5%85%A5%E6%B3%95%E6%A1%86%E6%9E%B6%EF%BC%89" target="_blank" rel="external">这里</a>进行配置，需要注意的是Text Entry可能在System setting里面</p>
<h2 id="可选软件配置"><a href="#可选软件配置" class="headerlink" title="可选软件配置"></a>可选软件配置</h2><h3 id="Axel"><a href="#Axel" class="headerlink" title="Axel"></a>Axel</h3><p>Axel 命令行多线程下载工具，在命令行指定多个线程同时下载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install axel</div></pre></td></tr></table></figure></p>
<h3 id="thefuck"><a href="#thefuck" class="headerlink" title="thefuck"></a>thefuck</h3><p>命令行一件纠错软件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt update</div><div class="line">sudo apt install python3-dev python3-pip</div><div class="line">sudo pip3 install thefuck</div></pre></td></tr></table></figure></p>
<h2 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h2><h3 id="zsh配置"><a href="#zsh配置" class="headerlink" title="zsh配置"></a>zsh配置</h3><p>首先安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install zsh</div><div class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</div></pre></td></tr></table></figure></p>
<p>修改系统默认的shell：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chsh -s /bin/zsh</div></pre></td></tr></table></figure></p>
<p>主题配置：<br>安装bullet-train 主题：<br>下载<a href="https://raw.githubusercontent.com/caiogondim/bullet-train-oh-my-zsh-theme/master/bullet-train.zsh-theme" target="_blank" rel="external">配置文件</a>，放置到$ZSH_CUSTOM/themes/ 目录下<br>.zshrc 配置文件见github<br>可能会遇到的问题：提示没有node命令，安装nodejs npm，ls更改bullet-train 中的配置node为nodejs</p>
<p>安装主题相关字体：<br>因为主题中一些三角形的符号需要powerline字体，所以要进行安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install fonts-powerline</div></pre></td></tr></table></figure></p>
<h3 id="Vim配置"><a href="#Vim配置" class="headerlink" title="Vim配置"></a>Vim配置</h3><p>可以参考<a href="https://www.jianshu.com/p/a0b452f8f720" target="_blank" rel="external">这里</a></p>
<p>我是直接用原来电脑的.vimrc替换.vimrc文件然后通过vunble进行安装的</p>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用 Docker Compose 构建复杂应用]]></title>
      <url>/2018/01/07/%E7%94%A8-Docker-Compose-%E6%9E%84%E5%BB%BA%E5%A4%8D%E6%9D%82%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>本文介绍Docker三剑客之一的Compose的一些基本使用方法。</p>
<a id="more"></a>
<p>cker Compose</p>
<p>Compose 是运行多个Docker容器的工具，可以在一个文件中定义一个多容器的应用，然后使用一条命令来启动你的应用，然后所有相关的操作都会被自动完成。使用Compose的一个比较直观的好处就是在构建一个多个容器组成的应用的时候少打Docker的命令</p>
<p>Compose的特性有如下几个：</p>
<ul>
<li>在单个主机上建立多个独立的环境</li>
<li>创建容器的时候保护数据卷</li>
<li>只有在容器改变的时候才重新创建</li>
<li>将变量和环境结合</li>
</ul>
<p>在<code>docker-compose.yml</code>配置文件中，主要配置四个方面的东西：version、service、network、volumes</p>
<p>version 是表示Compose file的版本，与其对应的是Docker的发布版本，一般使用的version是3.0</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>service定义构建整个应用的每一个容器，相当于给出命令<code>docker container create</code>的参数，然后创建相关的容器。以下是一些常用的配置标签：</p>
<h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>指定构建容器的镜像名称或者镜像ID<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">image: redis</div><div class="line">image: ubuntu:14.04</div><div class="line">image: tutum/influxdb</div><div class="line">image: example-registry.com:4000/postgresql</div><div class="line">image: a4bc65fd</div></pre></td></tr></table></figure></p>
<h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>容器的构建参数配置，可以指定为一个构建上下文的路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">version: &apos;3&apos;</div><div class="line">services:</div><div class="line">  webapp:</div><div class="line">    build: ./dir</div></pre></td></tr></table></figure></p>
<h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><p>可以使用command重写容器启动后默认执行的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">command: bundle exec thin -p 3000</div><div class="line">或</div><div class="line">command: [&quot;bundle&quot;, &quot;exec&quot;, &quot;thin&quot;, &quot;-p&quot;, &quot;3000&quot;]</div></pre></td></tr></table></figure></p>
<h3 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h3><p>不使用默认生成的容器名称（默认是&lt;项目名称&gt;&lt;服务名称&gt;&lt;序号&gt;），自己定义名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">container_name: app</div></pre></td></tr></table></figure></p>
<h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h3><p>配置两个容器之间的依赖关系，也决定了构建顺序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">version: &apos;3&apos;</div><div class="line">services:</div><div class="line">  web:</div><div class="line">    build: .</div><div class="line">    depends_on:</div><div class="line">      - db</div><div class="line">      - redis</div><div class="line">  redis:</div><div class="line">    image: redis</div><div class="line">  db:</div><div class="line">    image: postgres</div></pre></td></tr></table></figure></p>
<h3 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h3><p>制定DNS服务器，可以是一个单一的值也可以是一个列表<br><figure class="highlight plain"><figcaption><span>8.8.8.8</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dns:</div><div class="line">  - 8.8.8.8</div><div class="line">  - 9.9.9.9</div></pre></td></tr></table></figure></p>
<h3 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h3><p>临时挂载目录到容器内<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tmpfs: /run</div><div class="line">tmpfs:</div><div class="line">  - /run</div><div class="line">  - /tmp</div></pre></td></tr></table></figure></p>
<h3 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h3><p>重写容器的进入点，可以是单一的值或者是list<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">entrypoint:</div><div class="line">    - php</div><div class="line">    - -d</div><div class="line">    - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so</div><div class="line">    - -d</div><div class="line">    - memory_limit=-1</div><div class="line">    - vendor/bin/phpunit</div><div class="line"> 或者</div><div class="line"> entrypoint: /code/entrypoint.sh</div></pre></td></tr></table></figure></p>
<h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>添加环境变量，可以用dict或者list，但是boolean值要使用单引号括起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">environment:</div><div class="line">  RACK_ENV: development</div><div class="line">  SHOW: &apos;true&apos;</div><div class="line">  SESSION_SECRET:</div><div class="line"></div><div class="line">environment:</div><div class="line">  - RACK_ENV=development</div><div class="line">  - SHOW=true</div><div class="line">  - SESSION_SECRET</div></pre></td></tr></table></figure></p>
<h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h3><p>用于暴露指定的端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">expose:</div><div class="line"> - &quot;3000&quot;</div><div class="line"> - &quot;8000&quot;</div></pre></td></tr></table></figure></p>
<h3 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h3><p>映射指定的端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ports:</div><div class="line"> - &quot;3000&quot;</div><div class="line"> - &quot;8000:8000&quot;</div><div class="line"> - &quot;49100:22&quot;</div><div class="line"> - &quot;127.0.0.1:8001:8001&quot;</div></pre></td></tr></table></figure></p>
<h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p>挂载主机目录或者命名卷到service的容器中，如果使用命名卷必须要在top-level中的volumes定义这个命名卷</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">version: &quot;3.2&quot;</div><div class="line">services:</div><div class="line">  web:</div><div class="line">    image: nginx:alpine</div><div class="line">    volumes:</div><div class="line">      - type: volume</div><div class="line">        source: mydata</div><div class="line">        target: /data</div><div class="line">        volume:</div><div class="line">          nocopy: true</div><div class="line">      - type: bind</div><div class="line">        source: ./static</div><div class="line">        target: /opt/app/static</div><div class="line"></div><div class="line">  db:</div><div class="line">    image: postgres:latest</div><div class="line">    volumes:</div><div class="line">      - &quot;/var/run/postgres/postgres.sock:/var/run/postgres/postgres.sock&quot;</div><div class="line">      - &quot;dbdata:/var/lib/postgresql/data&quot;</div><div class="line"></div><div class="line">volumes:</div><div class="line">  mydata:</div><div class="line">  dbdata:</div></pre></td></tr></table></figure>
<h3 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h3><p> 指定加入的网络，这个网络必须在top-level的Network中定义：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">services:</div><div class="line"> some-service:</div><div class="line">   networks:</div><div class="line">    - some-network</div><div class="line">    - other-network</div></pre></td></tr></table></figure></p>
<p> 也可以使用ALIASES来为这个容器在不同的网络中使用不同的名字，使得其在不同的网络中可以发挥不同的作用</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"> version: &apos;2&apos;</div><div class="line"></div><div class="line">services:</div><div class="line">  web:</div><div class="line">    build: ./web</div><div class="line">    networks:</div><div class="line">      - new</div><div class="line"></div><div class="line">  worker:</div><div class="line">    build: ./worker</div><div class="line">    networks:</div><div class="line">      - legacy</div><div class="line"></div><div class="line">  db:</div><div class="line">    image: mysql</div><div class="line">    networks:</div><div class="line">      new:</div><div class="line">        aliases:</div><div class="line">          - database</div><div class="line">      legacy:</div><div class="line">        aliases:</div><div class="line">          - mysql</div><div class="line"></div><div class="line">networks:</div><div class="line">  new:</div><div class="line">  legacy:</div></pre></td></tr></table></figure>
<h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><p>重启配置，默认值为“no”在任何环境下都不重启，<code>always</code>指定其在任何时候都进行重启，<code>on-failure</code>只有在返回值表明是error的时候才重启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">restart: &quot;no&quot;</div><div class="line">restart: always</div><div class="line">restart: on-failure</div><div class="line">restart: unless-stopped</div></pre></td></tr></table></figure></p>
<h2 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h2><p>volumes是Docker应用首选的一种机制，其具体的模式可以看<a href="https://docs.docker.com/engine/admin/volumes/volumes/" target="_blank" rel="external">这里</a>，下面这一张图表示了Volumes的三种模式的差异：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_21_1516522519598.jpg" alt="enter description here"></p>
<p>Compose的配置文件中使用<code>volumes</code>定义应用中用到的数据卷容器，使得各个容器之间能够共用数据。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">version: &quot;3&quot;</div><div class="line"></div><div class="line">services:</div><div class="line">  db:</div><div class="line">    image: db</div><div class="line">    volumes:</div><div class="line">      - data-volume:/var/lib/db</div><div class="line">  backup:</div><div class="line">    image: backup-service</div><div class="line">    volumes:</div><div class="line">      - data-volume:/var/lib/backup/data</div><div class="line"></div><div class="line">volumes:</div><div class="line">  data-volume:</div></pre></td></tr></table></figure></p>
<h3 id="external"><a href="#external" class="headerlink" title="external"></a>external</h3><p>如果定义为<code>true</code>，表示这个数据卷已经被外部应用创建过了，使用<code>docker-compose up</code>构建应用的时候将不会创建这个数据卷</p>
<h2 id="子命令"><a href="#子命令" class="headerlink" title="子命令"></a>子命令</h2><p>下面介绍一个常用的Compose子命令的用法，其中大部分命令的用法和docker的用法是一致的。</p>
<h3 id="up"><a href="#up" class="headerlink" title="up"></a>up</h3><p>构建（或者重新构建）<code>docker-compose.yml</code>中定义的相关服务。<br>用法：<code>up [options] [--scale SERVICE=NUM...] [SERVICE...]</code><br>常用启动命令：<code>docker-compose up -d</code> 让容器默认在后台运行</p>
<h3 id="build-1"><a href="#build-1" class="headerlink" title="build"></a>build</h3><p>单独构建一个services中的容器，常用在改变一个容器的Dockerfile或者build的内容的时候，使用这个命令重新构建<br>用法：<code>build [options] [--build-arg key=val...] [SERVICE...]</code></p>
<h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>查看Compose信息，可以指定services或者volumes</p>
<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p>单独创建services列表中的一个容器，常用用在需要事先进行配置的应用构造场景中</p>
<h3 id="down"><a href="#down" class="headerlink" title="down"></a>down</h3><p>停止并删除一个contains , networks 或者volumes</p>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>相当于<code>docker exec</code>，在指定的容器中运行命令<br>用法：<code>exec [options] SERVICE COMMAND [ARGS...]</code></p>
<h3 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h3><p>暂停正在运行的service，使用<code>docker-compose unpause</code>恢复</p>
<h3 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h3><p>展示service的输出日志</p>
<h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><p>拉取一个在<code>docker-compose.yml</code>中关联的镜像到本地，但是不运行</p>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>同<code>docker push</code>，只不过push的是一个servi的image</p>
<h3 id="restart-1"><a href="#restart-1" class="headerlink" title="restart"></a>restart</h3><p>重启所有停止的或者正在运行的service，如果你改变了你的<code>docker-compose.yml</code> 配置文件，使用这个命令之后配置将不会更新</p>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>删除已经停止的容器</p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[日月潭游记]]></title>
      <url>/2017/12/27/%E6%97%A5%E6%9C%88%E6%BD%AD%E6%B8%B8%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>湾湾交换期间最后一次南下浪。见识了有生以来见过的最美的曙光，骑了体验超赞的环湖自行车线路。日月潭，我还会再来的！</p>
<a id="more"></a>
<h2 id="乘船游湖"><a href="#乘船游湖" class="headerlink" title="乘船游湖"></a>乘船游湖</h2><p>来了日月潭想必都会坐这边的游艇在湖面上逛一逛。这里有很多家游船的公司，价格也不是很贵，每个人150TWD就能够拿下。乘船游湖主要就会游玩三个景点：水社码头、玄光寺、依达邵码头。那个玄光寺就是曾经供奉玄奘部分顶骨的地方。<br>湖面上的景色一般，主要还是游客比较多，湖面上的船非常多，显得很杂乱。坐船在这三个景点之间绕一圈应该两个小时能够搞定。会看到很多大陆来的旅行团。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_9_WechatIMG2.jpeg" alt="enter description here" title="打卡图片"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_9_WechatIMG1.jpeg" alt="enter description here" title="风景还不错"></p>
<h2 id="民宿"><a href="#民宿" class="headerlink" title="民宿"></a>民宿</h2><p>为了省钱，这次选的民宿离日月潭有点远，大概有20km距离的水里乡。第一天坐公交去坐了半个小时，接待我们的是一个和蔼的老爷爷，一整栋房子都只有这个老爷爷在照看（想想也觉得挺孤单的），而Airbnb上住宿信息的发布是他女儿弄的。水里乡这里应该真的是台湾这边乡下的代表了，街道上就火车站周围人比较多（火车站里面一天只通过五六趟火车），其他地方基本上很少有人。711便利店也只有一家，在火车站旁边。</p>
<p>因为我们来的这几天日月潭周围在举行祈安清醮祭典，除了711周围都吃不到荤的。晚上饿了出门逛了半天最后还是回到711吃泡面。</p>
<h2 id="日月潭日出"><a href="#日月潭日出" class="headerlink" title="日月潭日出"></a>日月潭日出</h2><p>为了看日出，早上4点半起床，老爷爷很辛苦那么早起来给我们做早餐，然后5点我们就出发去日月潭了。</p>
<p>到日月潭的时候天还没亮，天上的星星还是非常亮。因为没有一点云，所以看到整个星空还是很震撼的。看日出的点我们选在朝暮码头，到达那里的时候早就已经有人架好三脚架了。</p>
<p>随着天一点一点变亮，我敢说这是我有生以来见过的最好看的曙光了。太阳没出来，但是太阳带来的光从山的后面发出，然后被大山挡住展示出整个山的轮廓，加上湖面作用，呈现的就是一个非常美的水平对称的画面。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_9_WechatIMG3.jpeg" alt="enter description here" title="太阳还未出来1"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_9_WechatIMG4.jpeg" alt="enter description here" title="太阳还未出来2"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_9_WechatIMG5.jpeg" alt="enter description here" title="太阳还未出来"></p>
<p>然后还看到了出来冬泳的大爷大妈，还有带着狗和鸭子划赛艇的老人。生活在这里的人太幸福了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_9_WechatIMG6.jpeg" alt="enter description here" title="溜了溜了"></p>
<h2 id="环湖骑行"><a href="#环湖骑行" class="headerlink" title="环湖骑行"></a>环湖骑行</h2><p>等太阳出来以后船和人就逐渐多了起来，打破了一开始的平静。我们前往了水社码头，准备租个小自行车骑车环湖。</p>
<p>不得不说因为环境实在是太美了，在这里骑车真的是一种享受。一开始骑的是自行车专用道，相比旁边的公路更加接近湖面人比较少，有些时候能够看见一些观湖非常好的角度。后面一段因为没有自行车专用道转到公路上，能够加速奔驰也是挺爽的。</p>
<p>中间一段路要爬一座比较少的山，上坡会比较累，到达最顶端的有一个“玄奘寺”的地方能够买点东西补给一下，然后就是几公里的下坡了，下坡的速度基本上能够达到30码以上。</p>
<p>总体来说是我骑过体验最好的自行车线路，就是车子还不是很好，以后希望能够换一个更好的装备再来一次。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_9_WechatIMG7.jpeg" alt="enter description here" title="环湖骑行"></p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker容器操作]]></title>
      <url>/2017/12/22/Docker%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>前面两篇文章整理了Docker创建时候的一些配置，这篇文章整理了Docker容器操作的一些常用命令</p>
<a id="more"></a>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>Docker容器太轻量级了，使得我们可以随时创建和新建容器，启动容器可以分成两种：基于image新建一个容器并启动；启动在终止状态的容器</p>
<h3 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h3><p>命令格式：<code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p>
<p>常用选项：</p>
<ul>
<li><code>-it</code> -i 打开容器的标准输入  -t 分配一个pseudo-TTY</li>
<li><code>-e</code> 设置环境变量</li>
<li><code>-d</code> 守护态运行容器</li>
<li><code>-p</code> 指定开放端口</li>
<li><code>--name</code> 为容器命名</li>
</ul>
<p>如果使用了 -d 参数运行容器，容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 docker logs 查看)。</p>
<p>Docker在后台运行的标准操作包括:</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<h3 id="启动已经终止的容器"><a href="#启动已经终止的容器" class="headerlink" title="启动已经终止的容器"></a>启动已经终止的容器</h3><p>命令格式： <code>docker contain start</code></p>
<p>将一个已经终止运行的容器重新启动</p>
<p><code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>命令格式：<code>docker container stop</code></p>
<p>对于只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。</p>
<p>容器状态（包括正在运行的和终止的）可以用 <code>docker container ls -a</code> 命令看到。</p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>进入容器可以使用两个命令： <code>docker attach</code> 和 <code>docker exec</code></p>
<p>前者不需要加参数（自动分配伪终端），但是退出以后便终止容器；后者需要加<code>-it</code>选项以及指定shell类似<code>docker exec -it 69d1 bash</code></p>
<h2 id="导入导出容器"><a href="#导入导出容器" class="headerlink" title="导入导出容器"></a>导入导出容器</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p>导出容器到本地容器</p>
<p>命令格式： <code>docker export [OPTIONS] CONTAINER</code></p>
<p>实例：<code>docker export 7691a814370e &gt; ubuntu.tar</code></p>
<h3 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h3><p>可以使用<code>docker import</code>从快照文件中导入为镜像</p>
<blockquote>
<p>用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
</blockquote>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>删除一个处于终止状态的容器:<br><code>docker container rm</code><br>可以添加<code>-f</code>选项来发送SIGNKILL信号给容器关闭正在运行的容器</p>
<p>清理所有处于终止状态的容器<br><code>docker container prune</code></p>
<hr>
<p>参考：<br><a href="https://www.gitbook.com/book/yeasy/docker_practice/details?spm=5176.100239.blogcont40494.64.FKbhBf" target="_blank" rel="external">Docker — 从入门到实践</a></p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[阿里山游记]]></title>
      <url>/2017/12/17/%E9%98%BF%E9%87%8C%E5%B1%B1%E6%B8%B8%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>老一辈想到台湾马上就会想到阿里山，都说是这是宝岛台湾必去的景点。这周末就造访了阿里山森林公园，这应该也是台湾倒数第二次出游了吧。</p>
<a id="more"></a>
<h2 id="交通方式"><a href="#交通方式" class="headerlink" title="交通方式"></a>交通方式</h2><p>因为阿里山的住宿偏贵（大概三百RMB每人每晚），所以我们选择的交通方式是客运，这样一晚上加一天就可以玩完。第一天晚上从台北出发坐6个小时的客运到阿里山，然后第二天中午再做客运回台北。</p>
<p>从台北到阿里山的路总共应该有320km左右，前面一大段是高速，后面一小段（大约一个小时）时盘山公路，后面一段山路各种180度的湾，所以有晕车的要提前准备好措施。中间会休息两个地方，一个是嘉义转运站，另一个是天长地久桥景区。车子到达阿里山的时间大概是凌晨两三点左右，休息一会就可以准备上山看日出了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_20_1513699348982.jpg" alt="enter description here" title="路程"></p>
<p>总体来说客运的这种交通方式比较经济而且节省时间，缺点就是会有点辛苦，毕竟凌晨三点多到阿里山的半山腰而且还要坐6个小时的车。</p>
<h2 id="祝山日出"><a href="#祝山日出" class="headerlink" title="祝山日出"></a>祝山日出</h2><p>看日出有两种方式，一种是搭阿里山游乐区里面的红色小火车去祝山观日平台看日出，另外一种是在阿里山游乐区门口有私人的接你上山看日出的巴士，去的是一个更高的平台。我们选择的是第一种，这个要在四点多的时候就到阿里山火车站买票，人很多但是只要不是去太晚应该都能够买到票。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_20_WechatIMG1.jpeg" alt="enter description here" title="阿里山小火车"></p>
<p>坐小火车到达山顶以后，就能够见到一个非常大的观日平台。日出差不多是7点，我们6点到达的山顶，见证了天空由黑变蓝再变红的过程。日出很快，马上太阳就全部出来了，想拍一个延时摄影但是苦于没有架三脚架的地方。</p>
<p>山上确实很冷，比山下温度应该是低个十度左右，冷风吹来冻得人直打哆嗦。不过不一会太阳出来以后感觉就暖起来了，可能是在台北没见过什么太阳，见到太阳就兴奋吧。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_20_WechatIMG2.jpeg" alt="enter description here" title="阿里山日出"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_20_WechatIMG3.jpeg" alt="enter description here" title="山上的云"></p>
<h2 id="漫步森林"><a href="#漫步森林" class="headerlink" title="漫步森林"></a>漫步森林</h2><p>看完日出以后，坐火车到沼平车站，开始漫步森林。看到太阳打在对面的山上，那景色就像电脑壁纸里面的一样。</p>
<p>阿里山游乐园里面真的是很有意境，树都是笔直的而且非常高，几乎看不到人工作用的痕迹，走在里面就像进到原始森林里面一样，非常赞。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_20_WechatIMG4.jpeg" alt="enter description here" title="漫步森林中"></p>
<p>准备回去的时候，拍了一个对面山的延时摄影。可以看到山间的“仙气”慢慢升上去，升到空中变成一朵云，非常赞。</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/8eSMokATgSA" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe>


]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[台湾大学联盟自习环境排行榜]]></title>
      <url>/2017/12/13/%E5%8F%B0%E6%B9%BE%E5%A4%A7%E5%AD%A6%E8%81%94%E7%9B%9F%E8%87%AA%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%8E%92%E8%A1%8C%E6%A6%9C/</url>
      <content type="html"><![CDATA[<p>台湾大学联盟指台湾大学、台湾科技大学、台湾师范大学组成的大学系统，允许各校学生跨校选课，共用图书馆等资源。作为一个经常去台大、台师大蹭课自习的台科大学生，今天就来总结一下我心目中台湾大学联盟的自习环境排行榜。</p>
<a id="more"></a>
<h2 id="No-4-台科大图书馆"><a href="#No-4-台科大图书馆" class="headerlink" title="No.4 台科大图书馆"></a>No.4 台科大图书馆</h2><blockquote>
<p>环境：三星<br>便利性：四星</p>
</blockquote>
<p>台科大图书馆应该是我自习来过最多的地方了，来自习的主要也是台科大的学生。自习的桌子不是很大，阅览区的自习位没有插座，图书馆里面的自习位一般是两个自习位共用一个插座。<br>一楼有一个休闲的杂志阅览区，旁边有一台自动咖啡机，学累了可以来这里坐一会喝杯咖啡提提神，超赞。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20180111_092603.jpg" alt="enter description here" title="图书馆大门"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20180111_092857.jpg" alt="enter description here" title="书架"></p>
<p>  <img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171225_224156.jpg" alt="enter description here" title="阅览区自习位"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20180111_092637.jpg" alt="enter description here" title="休闲杂志区"></p>
<h2 id="No-3-台师大图书馆"><a href="#No-3-台师大图书馆" class="headerlink" title="No.3 台师大图书馆"></a>No.3 台师大图书馆</h2><blockquote>
<p>环境：四星<br>便利性：三星</p>
</blockquote>
<p>师大图书馆在师大的图书馆校区，距离台科大比较远，所以去得也不多，一般是在游泳课前有时间的时候就去那里自习一会儿。师大图书馆还是很有特色的，建筑整体是一个半圆形的，在图书馆里面看会感觉非常特别。<br>自习区域也很赞，有讨论区开放给团队讨论，就是校园网有的时候使用不了漫游账号。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171229_095420.jpg" alt="enter description here" title="师大图书馆大门"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171229_095635.jpg" alt="enter description here" title="自习区"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171229_095753.jpg" alt="enter description here" title="半圆形建筑"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171229_095822.jpg" alt="enter description here" title="讨论区"></p>
<h2 id="No-2-台大图书馆总馆"><a href="#No-2-台大图书馆总馆" class="headerlink" title="No.2 台大图书馆总馆"></a>No.2 台大图书馆总馆</h2><blockquote>
<p>环境：五星<br>便利性：三星</p>
</blockquote>
<p>台大图书馆总馆应该是我在台湾交换去的第二多的图书馆了，周四下午又台大的课，上午一般就在台大图书馆待着，周末如果学习的话也会选择这里。在这里正很有学习的氛围。加上也是台大的标志性建筑，也是台大的几何中心，算得上是台大的一个标志了。</p>
<p>因为图书馆里面大部分区域是地毯，所以里面非常安静，每层楼的中间和最边上是自习区域，另外的地方是藏书的书架。不过有一点便利性的不足就是没有插座，有的时候电脑没电了就很头疼。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171205_133521.jpg" alt="enter description here" title="台大地标——图书总馆"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171205_133217.jpg" alt="enter description here" title="自习位"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171205_133149.jpg" alt="enter description here" title="自习区域"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171019_180724.jpg" alt="enter description here" title="多媒体借阅区"></p>
<h2 id="No-1-台大社科院图书馆"><a href="#No-1-台大社科院图书馆" class="headerlink" title="No.1 台大社科院图书馆"></a>No.1 台大社科院图书馆</h2><blockquote>
<p>环境：五星<br>便利性：五星</p>
</blockquote>
<p>台大社科院图书馆是有个非常有名的建筑作品，由伊东丰雄设计。相关的介绍可以看<a href="http://www.archcollege.com/archcollege/2016/04/25481.html" target="_blank" rel="external">这里</a>。很喜欢对这个图书馆的一个评价：</p>
<blockquote>
<p>树干般的柱子，是借由具备自我衍生规则的设计算法配置而成。看起来如植物般的双重螺旋，在保持彼此距离的同时也长出复数的节点，而两个螺旋的交汇之处变成了柱子的基点。然后再将基点间做柏洛诺伊分割，进一步决定出个别的屋顶板材的形状。柱子的形状则随着跨距的不同，以大、中、小三个模式加以重复排列</p>
</blockquote>
<p>社科院里面的环境可以说是超级棒，每一个自习位上面也有台灯和插座，真的是进去能够待上一整天。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171205_091823.jpg" alt="enter description here" title="社科院图书馆门口"></p>
<p>  <img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171205_091910.jpg" alt="enter description here" title="辜振甫先生像"></p>
<p>  <img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171205_092008.jpg" alt="enter description here" title="自习环境1"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171205_092129.jpg" alt="enter description here" title="自习环境2"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_15_IMG_20171205_092201.jpg" alt="enter description here" title="自习位"></p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 排行榜 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Dockerfile定制Docker镜像]]></title>
      <url>/2017/12/10/%E4%BD%BF%E7%94%A8Dockerfile%E5%AE%9A%E5%88%B6Docker%E9%95%9C%E5%83%8F/</url>
      <content type="html"><![CDATA[<p>本文讲解了使用Dockerfile 构建Docker镜像的一些常用指令和注意事项</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么很多无法重复的问题、镜像构建透明性的问题、体积的问题就能够轻松得到解决。</p>
<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>构建镜像命令的格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</div></pre></td></tr></table></figure></p>
<h3 id="上下文概念"><a href="#上下文概念" class="headerlink" title="上下文概念"></a>上下文概念</h3><p>Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p>
<p>当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<h3 id="规范做法"><a href="#规范做法" class="headerlink" title="规范做法"></a>规范做法</h3><p>一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p>
<p>在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。</p>
<p>这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。</p>
<p>当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>Dockerfile 中每一个指令都会建立一层，因此尽量将指令融合在一起（特别注意的是RUN指令）</p>
<h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h3><p>以一个镜像为基础，在其之上进行定制。</p>
<p>语法格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FROM &lt;image&gt;:&lt;tag&gt; 或者</div><div class="line">FROM &lt;image&gt;@&lt;digest&gt;</div></pre></td></tr></table></figure></p>
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><p>用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<ul>
<li><code>shell</code>格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。</li>
<li><code>exec</code>格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li>
</ul>
<h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><p>CMD 指令就是用于指定默认的容器主进程的启动命令的。也是两种格式：</p>
<ul>
<li>shell 格式：CMD &lt;命令&gt;</li>
<li>exec 格式：CMD [“可执行文件”, “参数1”, “参数2”…]</li>
<li>参数列表格式：CMD [“参数1”, “参数2”…]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。</li>
</ul>
<p>在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 “，而不要使用单引号。如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。</p>
<p>提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。<br>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。所以<code>systemctl</code>和<code>service</code> 这些命令就不起作用了。<br>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p>ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。</p>
<p>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 –entrypoint 来指定。</p>
<p>当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令</p>
<h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>两种格式：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>对于如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的，比如说<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ENV VERSION=1.0 DEBUG=on \</div><div class="line">    NAME=&quot;Happy Feet&quot;</div></pre></td></tr></table></figure></p>
<h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><p>格式： <code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>
<p>构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。</p>
<h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>格式：</p>
<ul>
<li><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>
</ul>
<p>&lt;源路径&gt; 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match" target="_blank" rel="external">filepath.Match</a> 规则</p>
<p>&lt;目标路径&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p>
<h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。给出的源路径可以是一个URL地址Docker 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去。</p>
<p>另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>
<p>因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。</p>
<h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>两种格式：</p>
<ul>
<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
<h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h3><p>格式：<code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p>
<p>声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</p>
<h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式： <code>WORKDIR &lt;工作目录路径&gt;</code></p>
<p>使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</p>
<h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h3><p>格式： <code>USER &lt;用户名&gt;</code></p>
<p>USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。</p>
<p>当然，和 WORKDIR 一样，USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<h3 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h3><p>两种格式：</p>
<ul>
<li>HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</li>
<li>HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li>
</ul>
<p>HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。</p>
<p>具体使用可参考<a href="https://docs.docker.com/engine/reference/builder/#healthcheck" target="_blank" rel="external">这里</a></p>
<h3 id="ONBUILD-定义触发器"><a href="#ONBUILD-定义触发器" class="headerlink" title="ONBUILD 定义触发器"></a>ONBUILD 定义触发器</h3><p>格式：<code>ONBUILD &lt;其它指令&gt;</code></p>
<p>ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
<h3 id="MAINTAINER-提供信息"><a href="#MAINTAINER-提供信息" class="headerlink" title="MAINTAINER 提供信息"></a>MAINTAINER 提供信息</h3><p>格式：<code>MAINTAINER &lt;author&#39;s detail&gt;</code></p>
<p>用于提供信息的指令，用于让作者提供本人的信息；不限制其出现的位置，但建议跟在FROM之后。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">FROM ubuntu</div><div class="line">MAINTAINER Kimbro Staken</div><div class="line"></div><div class="line">RUN apt-get install -y software-properties-common python</div><div class="line">RUN add-apt-repository ppa:chris-lea/node.js</div><div class="line">RUN echo &quot;deb http://us.archive.ubuntu.com/ubuntu/ precise universe&quot; &gt;&gt; /etc/apt/sources.list</div><div class="line">RUN apt-get update</div><div class="line">RUN apt-get install -y nodejs</div><div class="line">#RUN apt-get install -y nodejs=0.6.12~dfsg1-1ubuntu1</div><div class="line">RUN mkdir /var/www</div><div class="line"></div><div class="line">ADD app.js /var/www/app.js</div><div class="line"></div><div class="line">CMD [&quot;/usr/bin/node&quot;, &quot;/var/www/app.js&quot;]</div></pre></td></tr></table></figure>
<h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><h3 id="从rootfs文件导入镜像"><a href="#从rootfs文件导入镜像" class="headerlink" title="从rootfs文件导入镜像"></a>从rootfs文件导入镜像</h3><p>格式：<code>docker import [选项] &lt;文件&gt;|&lt;URL&gt;|- [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></p>
<p>压缩包可以是本地文件、远程 Web 文件，甚至是从标准输入中得到。压缩包将会在镜像 / 目录展开，并直接作为镜像第一层提交。</p>
<h3 id="保存和加载镜像"><a href="#保存和加载镜像" class="headerlink" title="保存和加载镜像"></a>保存和加载镜像</h3><p>Docker 还提供了 docker load 和 docker save 命令，用以将镜像保存为一个 tar 文件，然后传输到另一个位置上，再加载进来。这是在没有 Docker Registry 时的做法，现在已经不推荐，镜像迁移应该直接使用 Docker Registry，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以。</p>
<p>如果我们结合这两个命令以及 ssh 甚至 pv 的话，利用 Linux 强大的管道，我们可以写一个命令完成从一个机器将镜像迁移到另一个机器，并且带进度条的功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker save &lt;镜像名&gt; | bzip2 | pv | ssh &lt;用户名&gt;@&lt;主机名&gt; &apos;cat | docker load&apos;</div></pre></td></tr></table></figure></p>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>格式：<code>$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</code></p>
<p>Untagged</p>
<p>有些时候我们删除一个镜像的时候，可能会出现Untagged。这是因为镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变动非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 docker pull 看到的层数不一样的源。</p>
<p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p>
<p>参考：<br><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="external">https://docs.docker.com/engine/reference/builder/</a><br><a href="https://www.gitbook.com/book/yeasy/docker_practice/details?spm=5176.100239.blogcont40494.64.FKbhBf" target="_blank" rel="external">电子书</a></p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识Docker]]></title>
      <url>/2017/12/10/%E5%88%9D%E8%AF%86Docker/</url>
      <content type="html"><![CDATA[<p>本文是我初步了解Docker技术的笔记<br><img src="https://data2.liuin.cn/story-writer/2017_12_10_2333.png" alt=""></p>
<a id="more"></a>
<h2 id="什么是Docker？"><a href="#什么是Docker？" class="headerlink" title="什么是Docker？"></a>什么是Docker？</h2><p>Docker 是能够对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_10_1512908235159.jpg" alt="enter description here" title="传统虚拟机"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_10_1512908269821.jpg" alt="enter description here" title="Docker"></p>
<p>相比传统的虚拟化技术Docker有许多的优点：更高效的利用系统资源；更快速的启动时间；一致的运行环境；持续交付和部署；更轻松的迁移；更轻松的维护和扩展</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="镜像-Image"><a href="#镜像-Image" class="headerlink" title="镜像(Image)"></a>镜像(Image)</h3><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</p>
<p>镜像是分层存储的，构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。这样使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<h3 id="容器-Container"><a href="#容器-Container" class="headerlink" title="容器(Container)"></a>容器(Container)</h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p>
<p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。</p>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<h3 id="仓库-Repository"><a href="#仓库-Repository" class="headerlink" title="仓库(Repository)"></a>仓库(Repository)</h3><p>和GitHub中的仓库类似，Docker中的仓库也是展现不同版本的镜像的地方。一个仓库包含一个软件（或者开发环境）的不同版本的镜像，标签就是对应着这些镜像的版本号。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。</p>
<p>与Github这种代码托管平台一样，仓库我们可以放在公共的Docker Registry中（最常用的是 Docker Hub，国内有许多高质量的镜像服务），也可以放在私有的Docker Registry中。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官方安装指南在<a href="https://docs.docker.com/engine/installation/#prior-releases" target="_blank" rel="external">这里</a></p>
<h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><h4 id="加载可选模块"><a href="#加载可选模块" class="headerlink" title="加载可选模块"></a>加载可选模块</h4><p>从 Ubuntu 14.04 开始，一部分内核模块移到了可选内核模块包。AUFS 内核驱动属于可选内核模块的一部分，作为推荐的 Docker 存储层驱动，一般建议安装可选内核模块包以使用 AUFS。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line"></div><div class="line">sudo apt-get install \</div><div class="line">    linux-image-extra-$(uname -r) \</div><div class="line">    linux-image-extra-virtual</div></pre></td></tr></table></figure>
<h4 id="向APT中添加源"><a href="#向APT中添加源" class="headerlink" title="向APT中添加源"></a>向APT中添加源</h4><p>添加使用 HTTPS 传输的软件包以及 CA 证书:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install \</div><div class="line">    apt-transport-https \</div><div class="line">    ca-certificates \</div><div class="line">    curl \</div><div class="line">    software-properties-common</div></pre></td></tr></table></figure></p>
<p>添加软件源的 GPG 密钥（因为国内的网络问题，可以使用国内的源）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</div><div class="line"></div><div class="line"># 官方源</div><div class="line"># curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</div></pre></td></tr></table></figure></p>
<p>向<code>source.list</code>中加入Docker软件源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ sudo add-apt-repository \</div><div class="line">    &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \</div><div class="line">    $(lsb_release -cs) \</div><div class="line">    stable&quot;</div><div class="line"></div><div class="line"></div><div class="line"># 官方源</div><div class="line"># $ sudo add-apt-repository \</div><div class="line">#    &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</div><div class="line">#    $(lsb_release -cs) \</div><div class="line">#    stable&quot;</div></pre></td></tr></table></figure>
<h4 id="安装Docker-CE"><a href="#安装Docker-CE" class="headerlink" title="安装Docker CE"></a>安装Docker CE</h4><p>更新apt，并安装`Docker CE’:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get update</div><div class="line"></div><div class="line">$ sudo apt-get install docker-ce</div></pre></td></tr></table></figure>
<h3 id="使用脚本自动安装"><a href="#使用脚本自动安装" class="headerlink" title="使用脚本自动安装"></a>使用脚本自动安装</h3><p>官方版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -sSL https://get.docker.com/ | sh</div></pre></td></tr></table></figure></p>
<p>阿里云安装脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</div></pre></td></tr></table></figure></p>
<p>DaoCloud安装脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -sSL https://get.daocloud.io/docker | sh</div></pre></td></tr></table></figure></p>
<h3 id="镜像加速器"><a href="#镜像加速器" class="headerlink" title="镜像加速器"></a>镜像加速器</h3><p><a href="https://cloud.tencent.com/document/product/457/9113?!preview=true&amp;lang=zh" target="_blank" rel="external">腾讯云</a>官方给出的配置方法：<br>修改 Docker 配置文件 <code>/etc/default/docker</code>，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DOCKER_OPTS=&quot;--registry-mirror=https://mirror.ccs.tencentyun.com&quot;</div></pre></td></tr></table></figure></p>
<p>更高效的配置：</p>
<p>通过修改daemon配置文件<code>/etc/docker/daemon.json</code>来使用加速器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sudo mkdir -p /etc/docker</div><div class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;</div><div class="line">&#123;</div><div class="line">  &quot;registry-mirrors&quot;: [&quot;https://mirror.ccs.tencentyun.com&quot;]</div><div class="line">&#125;</div><div class="line">EOF</div><div class="line">sudo systemctl daemon-reload</div><div class="line">sudo systemctl restart docker</div></pre></td></tr></table></figure></p>
<p>用<code>docker info</code>测试是否配置好，查看是否有以下的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Registry Mirrors:</div><div class="line"> https://mirror.ccs.tencentyun.com</div></pre></td></tr></table></figure></p>
<h3 id="Docker-compose-安装"><a href="#Docker-compose-安装" class="headerlink" title="Docker-compose 安装"></a>Docker-compose 安装</h3><p>可以参考<a href="https://docs.docker.com/compose/install/" target="_blank" rel="external">官方文档</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo curl -L https://github.com/docker/compose/releases/download/1.18.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</div><div class="line">sudo chmod +x /usr/local/bin/docker-compose</div></pre></td></tr></table></figure>
<p>但是我在操作上面的命令的时候会出现下载不了的错误，所以我就从<a href="https://github.com/docker/compose/releases" target="_blank" rel="external">官方的Github</a>下载了最新的realease，然后复制到<code>/usr/local/bin/</code>中</p>
<h3 id="创建docker用户组"><a href="#创建docker用户组" class="headerlink" title="创建docker用户组"></a>创建docker用户组</h3><p>Docker守候进程绑定的是一个unix socket，而不是TCP端口。这个套接字默认的属主是root，其他是用户可以使用sudo命令来访问这个套接字文件。因为这个原因，docker服务进程都是以root帐号的身份运行的。</p>
<p>为了避免每次运行docker命令的时候都需要输入sudo，可以创建一个docker用户组，并把相应的用户添加到这个分组里面。当docker进程启动的时候，会设置该套接字可以被docker这个分组的用户读写。这样只要是在docker这个组里面的用户就可以直接执行docker命令了。</p>
<p>警告：该dockergroup等同于root帐号，具体的详情可以参考这篇文章：<a href="https://docs.docker.com/engine/security/" target="_blank" rel="external">Docker Daemon Attack Surface</a></p>
<p><code>sudo usermod -aG docker your_username</code></p>
<h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>获取镜像的格式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</div></pre></td></tr></table></figure></p>
<p>具体的帮助文档可以通过<code>docker pull --help</code>查看<br>参数解释：</p>
<ul>
<li>Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。</li>
<li>仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。</li>
</ul>
<p>运行测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run -it --rm ubuntu:16.04 bash</div></pre></td></tr></table></figure></p>
<p>参数解释：</p>
<ul>
<li>-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li>–rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。</li>
<li>ubuntu:16.04：这是指用 ubuntu:16.04 镜像为基础来启动容器。</li>
<li>bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。</li>
</ul>
<h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><p>一般使用的使用的是<code>docker image ls</code>或者<code>docker images</code> 指令<br>可以使用相应的<code>--help</code>查看帮助</p>
<h3 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h3><p>当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 docker commit 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p>
<p><code>docker commit</code>语法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</div><div class="line"></div><div class="line"># 例子</div><div class="line">$ docker commit \</div><div class="line">    --author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; \</div><div class="line">    --message &quot;修改了默认网页&quot; \</div><div class="line">    webserver \</div><div class="line">    nginx:v2</div></pre></td></tr></table></figure></p>
<p>可以搭配<code>docker diff</code>查看容器当前的修改和<code>docker history</code>查看镜像的相关历史记录</p>
<p>注意：慎用<code>docker commit</code>操作：</p>
<blockquote>
<p>使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 docker diff 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。</p>
</blockquote>
<h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><p>当你需要把本地制作的镜像推送到远端仓库中，你就可以使用<code>docker push</code>命令，这个命令默认推送到的是Docker的官方镜像仓库：Docker Hub。</p>
<p>在推送之前，你需要在Docker Hub中创建好相应的image并登录：<code>docker login [OPTIONS] [SERVER]</code></p>
<p>然后使用<code>push</code>命令推送：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker push [OPTIONS] NAME[:TAG]</div></pre></td></tr></table></figure></p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ docker commit c16378f943fe rhel-httpd</div><div class="line"></div><div class="line">$ docker tag rhel-httpd registry-host:5000/myadmin/rhel-httpd</div><div class="line"></div><div class="line">$ docker push registry-host:5000/myadmin/rhel-httpd</div></pre></td></tr></table></figure></p>
<p>参考：<br><a href="http://aleonchen.com/2017/02/07/qcloud-docker/" target="_blank" rel="external">博客1</a></p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[湾湾极东之行]]></title>
      <url>/2017/12/09/%E6%B9%BE%E6%B9%BE%E6%9E%81%E4%B8%9C%E4%B9%8B%E8%A1%8C/</url>
      <content type="html"><![CDATA[<p>这个周末台科大台陆会说了一个月的活动终于举办了，福隆骑行，打卡台湾极东点，过一把骑行的瘾。</p>
<a id="more"></a>
<h2 id="线路"><a href="#线路" class="headerlink" title="线路"></a>线路</h2><p>台北出发，坐一个半小时的区间车到福隆车站，买便当、借车，沿着小路骑到旧草岭隧道，然后骑过旧草岭隧道。过了旧草岭隧道就能远眺龟山岛了，然后沿着环岛一号线骑行到台湾极东点——三貂角灯塔，最后再沿着环岛一号线骑行回到福隆车站，还车坐区间车回台北。</p>
<p>区间车来回150TWD，福隆便当60TWD，借车100TWD，共计花费才310TWD。超赞的物美价廉的周末出游路线！</p>
<h2 id="旧草岭隧道"><a href="#旧草岭隧道" class="headerlink" title="旧草岭隧道"></a>旧草岭隧道</h2><p>旧草岭隧道在日治大正10~13年建造（西元1921~1924年），工程费时三年，是当时台湾最长的隧道。隧道的工程质量不得不说还是蛮好的，差不多有百年历史，隧道里面还是没有漏水什么的。因为是单线铁路，后面在旁边建了一个新的双线铁路这条隧道就废弃了，改成一个供观光客骑行的景点。<br>一排路灯照着不是很黑，地下铺了铁轨形状的瓷砖。路上碰到大妈团让我们带路😂</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_9_IMG_20171209_171226.jpg" alt=" " title="旧草岭隧道 入口"></p>
<h2 id="三貂角灯塔"><a href="#三貂角灯塔" class="headerlink" title="三貂角灯塔"></a>三貂角灯塔</h2><p>三貂角灯塔就是台湾的极东点了，经度东经120度，刚好是太平洋和东海分界的地方。公元1929年及1931年，日本船舶抚顺丸及华南丸，先后于三貂角附近海域遭遇海难沉没，台湾总督府因此于此地筹建此灯塔。</p>
<p>向东眺望就是广袤的太平洋了，美不胜收！</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_9_IMG_20171209_203930.jpg" alt=" " title="三貂角灯塔"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_9_IMG_20171209_204012.jpg" alt=" " title="台湾极东点观景台"></p>
<h2 id="骑行感受"><a href="#骑行感受" class="headerlink" title="骑行感受"></a>骑行感受</h2><p>今天一共骑行应该是20公里左右，因为团队里面有小伙伴体能不是很好，所以骑行的速度不是很快，平均速度大概在10km/h。这条线路的总体感受应该是非常好的，依山傍水，左边高山，右边太平洋。</p>
<p>环岛一号线上大部分道路都是有自行车专用道，不用太担心安全的问题。周末没事花个一天半天的时间来玩玩挺好的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_9_Screenshot_2017-12-09-16-57-48-223_com.xiaomi.hm.health.png" alt=" " title="骑行轨迹"></p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从台大Compiler的学习中看自己在台湾学习的局限性]]></title>
      <url>/2017/12/09/%E4%BB%8E%E5%8F%B0%E5%A4%A7Compiler%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9C%8B%E8%87%AA%E5%B7%B1%E5%9C%A8%E5%8F%B0%E6%B9%BE%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7/</url>
      <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>
function doDecrypt(pwd, onError) {
	console.log("in doDecrypt");
	var txt = document.getElementById("enc_content").innerHTML;
	var plantext;
	try {
	  	var bytes = CryptoJS.AES.decrypt(txt, pwd);
		plaintext = bytes.toString(CryptoJS.enc.Utf8);
	} catch(err) {
		if(onError) {onError(err);}
		return;
	}
	document.getElementById("enc_content").innerHTML = plaintext;
	document.getElementById("enc_content").style.display = "block";
   document.getElementById("enc_passwd").style.display = "none";
}
</script>
<div id="enc_content" style="display:none">U2FsdGVkX1+eaDHfw1AooZ+YcGlxePcjAaSLZEuQu9LFFNU4kkY+UAPWOvCROvyoPFEfDtxcSFxogqMr12oQ18W87RloTww2Z4WtowhoWX9lY8QoOnN2DwJobVHkFcAUxSApnHuyCmud/ZHEQ0SgyPlGb9yt1FccX83+wA1bqkyy6EHawHoqr5+xb+hzD7e4k7OD9IENDs5IRMYj1nCDXXp6MGYO5H7G9d21nVoSfeN67C9jMkRDf5twgUllWVsJfINEkhXAvznnlvFBw93HLaOFYOhn3Qdz7LYz/x+HCDrTPz00LjIbk9F49Yo7SqLHpF+FkS6ngYvxktOEnGwu8PvNbwcDRuo5ugo/8l8OVVPJRYifCJt8w9B9Zf+GMbh1veY9wNuPfCv3vPTzSrf44WoFDykuERAA6//C7PaaPP7FT8EusLQ4aM82/OSHHviN14fkF9Awfl51rToUCVEPetnX8NpSCf98YAGMnBxs/vcaWTRqxOkGnmmCUaXJR95IMhUf50BemPQHIRFEnm9twoBE3jSVzmc7L8v3otKImDoXRn2bPQ/LiALIcg87hWYwvZt82vbhnB5PruRO5tJY2IxFKUpIK2i1CsFa28XyaBI37LPw8LYB7OWbbCmkbzKBmMDDnCXCdFP3UMGwC9F/T9jxKJyqDoUoZPB5StTCHW/9gyuy72TiqKWx+sLVx0XxRgkLKzLoab1lrvcP0ddgKiWB5+IBB02E6gdWlFTbKb+7+9cqXXWfRpbeWL5rWlHwLAtSZHAT5pqUciMRBCaPnShduEWCnBrwy6Xa1/0ApkWLEjmBvZZQw8s0XyWEIw3VG8+U1BP9nJOLElOFYz/2LETrX094t1onFNDQdiHMyE+G+9e7h4F2VjYnQqsCYdmxKB7QSutOl/nikzsN+9apfoEBwZnquaZAVQFM6oQATgq4wwgJlrLpCDw6S5QlQWqfK0+0Fo2zzYSf//oiG94SFMQhMUaQhqte2BtQtxwqHfN2oe+FxCo/hdTo8e2knW/oqx2jjJHHMxSk0hGqyQK4dD6ddxj7XYE79lvXJFyeLy5ipr96z/LjofnAwrGZMqHYMhxCd28y0WcyrhWCqJd2aPaBLh3Fe0eJfnsc8A2AChyJvc6QRqzHP/ZILkczZ3S2Zn09q1bt3/e/sMdsgsEWWOi7jSHxLPT4OICpPa2xiXXFEHUlKE9ndLdOf3o95s8e8FvmfQTjhNlCXqGy90p1DP8RCfu5LdZlL3AerOXMkuPdXSTDZJtyc1E5aq7kA2yY4i/WKzH3MiZkRL3YJZqhpHW3Mbj7ZzYx5IEsORC4hB/UH+6MvNTN8uxwqg63m05iSu/ny2NrSZAGroe6tdMh+389PMrXS2Ss2yxFwZqHvjTFfxLRGkpzhDSyPkAIrbwf/OcKNMgPKYhOmfltqpOmJHOM3cFlo2AoLypUPaTdLcmWYpn5YGcZeRnmYnxuHyTFfEM0OoaMW+9HqjzSS1IcV6x1vBIQvHzbrf0qdLcsAY/e8kj6ZfeeONFRzJ69Rsv4YvpwSuE7JFq+BiKWfc1fniAAKJGAxbI4RMPo79yCX2kNLlUWo6MxcaZNLBS6IOezJPu4aeJqJhPWjtzvOyBk1MCaAe6YMUgQcIKcsGgKlzsdr+LktdrH3iEU+UyKfBcXIxLFYTc8cI7MlcDFpwHUz51zmUNWiU3ytLlsVzhgQndoVhz/bQWpsDHjlcRbepJ6EttflilEOPFJq0nFK+HlEInnxYKh1oiK5e3nIQLdQiqmWBvJANplmg/JUdcgab/wQieaD7JzVuDM4smdEVAfabfxVv5bpCVYaJbohKHwrXfiVmdZGF0QwLPTveLrWGY5SiyA0UaTA+bLME8uA9AbYRQEE96jeRrwGmstclQHt9UZtN5LdIVq7eGbSE6Kt/a3fqdsmKffKU51wm1ZFRZWALG5xdfYVbVi60LDLsJHaFquzguLh1AjC5/lds5YKNgzkwFUWQbsk5XUQjsTXa1B9+2m2zehCumm1K9lKqEf72HJ8UEuG5QsnrBpBZmhi24aMPqC9tJa+q6x31pP/6XEj0/U+s0zj0RTCJ1z7uKy2oR1M41lGBk19JWdp3IXa1r3T0T5z/QNjFUkTZYgByZcTdYFIFY+1Bh8thlYaHBdMxl3rt8JKdqMKquiS+Ag/x409pqwZQXCuT+oZAvrcutL8fwjwY+4g0ZchouenSV8YJA6gUuess2LZ3jh2yFdUHgezVnETl5ed3+tEyfkd5KpelXZD5NrcLnQrfA83ed772pTvWK0gj5Sssr7S1/PH0aY0LL0nvXEnUHNOqT/wW3RdgtHLzRkbvxzjBKa2p3dL7RtyQV3CDP7lzw+znhk7Oh5vh2+T+SxZSod2repjHj2ynoqVF4TgSjx4eJDk+j635gmlo1pFnx3N6eKlvLXqfFAk9x4iv+KDfWl3nbboeRtZsW/GPsUzdDWAhV77d51bTm2RdNH0lF3e8uQMVkkktWxUAzkvz3KXlbaut8ZT5dPwxs1akKzv64IOnoaIEa6aO2FIeTzlqec86vChFUM8BC59xLM9Pbc0rZjKw6VssKtFPcIIYLD1O0mLRxZkalpoO+F2xSZGhTxl6iuMlNk9mPzEUT243ytmo00xTy935IrBfzUwFk47zGWOKUfG8UUDaw10IVjALIJ34kEx0KOepc/sYHCS2HiOf9/4RTxSQSQkGbA67h58Jf7jJCxeCtO5FHmp1vUAoD+T+cxdtOheo2nFLKD1cB/wO3gg29gKOBQAs2dEoAtggwKqUlaVF3WrFeQlLfOG9R1owRa/f4YGyOPRV82VT5s0nKOI5Upl/tAhu9W8wezHKi3zQ0jJcXTq45GUNgvQYTPhbbF8CTSyxjz4nTT+cMvIGMN57Px5HnhwvaNuHE7a8XTSuynXmP29B4QRKTKJ8wz+zlaMp7LT8Np/nwV99JP4FefraDE+JxQEW8H75ZePqKGMTiAcUEk9YO3HiaMYE+LdH6pyVnOawhdnJl5CZwn5ufs6kh3gHYgVh4Ca/04TcSIprYSZnvLC7/t9jVAmZN+NP0gF82tjTjZ0uhWD6L//kQ6C9igVNg2NgQx6nbtbs3reTHTgXSuVAuljb93ZqhBFVCnZBS67dR41Bn2hWYPrZPUNx4Qz/2sNRaougXGZoNF/nK7i6Q82ezbLSU72HzQf/DrXZnQLVqVQphrWHAQgPIcl8CDBMTGpclHQr14Afp9tjvzXYXrSvUEZLQcJZ1SW0TK7wYDZN1iDOvKh0zgTWCdGX+Kh8P7XenpajcmTWBGvWj7DpILluSjYSATBaF5Ny5tRWVHPUDbJtvbgKCk1UGzIridzf3FQgF/AIqr5etMpEopBUBnAL2+JvLYGm5qaVmIfx22QOHmmS5ldTvryQX7LZpWZnEJGSWRnFMDcQDjvJnzFH5KRSkWbtg5gSMnwJmOTI4L5Y1HuJ4gXDejbLiQDi/z6kq6RZnWpyUI7VN1/u0OYjE144w/gekBQyoxIOltvZocCbBNcPIAxFBZmfmt0yDveENBerggZCwRMJBwxvCFR8shTl7tvgiVuWNdhj0YPGHUGjrF3FF1nZDYUUJ6eFyw0Esvi4+ak91ikD1pBO6kRVWWRpbChqhpAXb5xRI0eGlU0j4x2F0654Y6MSp5OXBD6Nwr3j6d5BpGxHxMnTtWL7etKABMiz2zDEI4nPGWWl4YG3GHPYnBRySgScXcmECZJrWOhIflXd0Dx5gzNaGMACF23hn6byj0FuTPJ6zVnBgYamUUcI37Rv8AKZg20gePXB+cpWEaA0kjVa7x3hmpeIRdUhBgX8Rkqv0uRrduonyXLaFpiSVYPBF/PFDHrE0WEYwxWjV9tqRKAK5F1y4AkpSGBdOBd4S4v7vpjAKTY31dIyw8HlHtHehofqkR+qEUR1kYSmo4U2Ze6tl3J1La7mA93vIbpzuohahLEhLJi2WriGvoSUM3gDdpOLK7mU6+W/Dhj7d+3k+rUbNBd1KXTT0pOSSZhZ66BcGkdTZbMmsn5CfvmJ2nPzhri/pwoJ0NlAwKAdKyvcbEFulJnv6aVplWm3C1hJxTE7VpasGkRE2N3mwCZiagcSgKmZqYd0M4EQ9eSd+gVTRRoyiC7ZsRxLxBgvSlyKdLFD03mQeqJCGFSBfhS+xrx1P7MFib0bbIy/VKrYVxHuv4UjT62Jm8gJmy8MgZChax8Kd9bCPCAdzHvvC2j7W5eiPPsRiN0dAdBL+oLs7AfycNn/ZR0r26N1+AtMS/ISXNZ1EcTlxxD2MdO+S5N3m5qDO+QnXz57UCy88rr2M/vVePiGLhzeGGqvCH1umq33Z/szKLq9NtfG+LsSIo/vi039UI9/pH56d/jlzOwx/k/6jVLdBfbt7P+gp3n7Y4RfnqtIo8KZX6yqBSFpysPws7hp9Waf1f9Z82HZ3uCDq4HfcqqhiYMnIvX8Wx8iGqb0JxyrLo3+5bk2gZjv08QKx1ouNJSsOjaedMpU6Kj/nfWK9NOh+6WA59WU1SbgG1H/erL6QmOo0/kmGX7Gvr9X3YRt4wYlIafwIj5b3h5ELV2lIyFeXQmsry5A4XUvG5h+yJYPUNw2OiYq4e9QSbfx2osxsKbbFwUfft3DCD5PvAFSwAw8ee0XzLOZxU+Hh7M2baIgMNJ0U419F956l6e2FgU0Doz78Yadhl654D6vUYZzbaqwhm0HFvC7IGw9MJ5nYG8JrrhYCVWuMvQpme6dThohjcuK4v9pCUuZY0k1lRX0JPQ0rX1SQqrjv30EdOA7uYihOekM+UhUTQYL49p1jrYbx0sOsls4903YtV6Pl1GQ/uHTm+Tjw9GyCwGlxc+RdFSU4s2MOpAZEUYRXO4ZCc2iS8FygH1X147admEPdvmylw91r2bbfz7fuL5m/9vA8NY5wthgaPJ1mKtawArwBXjU9iVBbclu+sygFnQV/OOSqSitD9ULxZ/+Hvjt0Knc0zeFG4hJM2sK73H9EcQ2ag2pt5BY6LSDRYk6QXynrhcB1b0sFSOcM37HgH7OdCRkmQ9e2FP0OdnM20drD7bN6uBEuacTt2om68L0B9LSOzOKY6Xt+Y1EHJl4AGkDSBBPKuqc9wHiiHFsoPcmjk8B+AQmIaBr62Fq1LlvW6d/2PJbmylvNW2edkT7+awljzooalSp6b5iEeUBzFPcBWRu4/vBZudUlC1Sm9td8yoqhgwszxFXo1Yuy4msHBuhc3eHConVIHgeHMEhQFj+1lPVmZsmd91DZawj6pvfIVC1X9vdIoGX66wwVYbDNgoHTMDkYeioM+itHFvk2XK5dmDHeFC8Os2ZhLV9n/S9+9ud7f1CW59HV3ogLVNYVRkfbMVbM8Jal6oqtK8QFe7J0Bk+BR1fvYEWjq0wIV/5Rs0lq23uHPC7Ze29FM0j/VjvsZwW23k+60fIam+aoPGLsHHeWwxQ8auIabyu0ghf49GZIkStj73uZnPefBVXVrBhLkKktXDUTzLqz8Jhz5T0cOsFMgyT/EQGm9lfOOD4oq7CAN/bwLMnrURpTyJCu71hiGyzNjNv20ZEsWGI2ZhmN9PGRlJ2agWFEMGQJNEdQ3oFE3mtYFX3oe3KScB62IsUvHonOy6f6xMtxwqc2OkdGcomUf+3uSE0kL9BYSv0v2q39EuN9D81nPgzdoqgx7wzcgUkMkSOvM5UpxLMR7yu+hXDCL0IPgMqSh8SE3R+6QLawe+i4KnpzdtrPp5hT/AkZZhviFtpiEHqV9NMf8Bt8v90LVCuzR6COphBvNx4qhmmBnTs+rWIoZC0KcY3ZT2rqTl6QifpRzLpvkzsOwXqefcMRNJCK5Z74GBLTiP5FZdMbgucDt8wvikdZjXZ6fRMeLQ6TF9dnWEu2oRhIuTCPOfYVOJXnH+Fb+vw8JUooXCtD/gOMZ0xsiCB5w/zggLaoXehBgrM5Wy9MO+gcqBC/zVMzDcFydAOZfwS/2rcPxySOzbwvd4pJLF7ISSApmaf+KR115hsJrDdUN6lJgOdVTjO2zOe6gx9V+HmEqkbj5e3OADju3YpBhINUUDpHFJ49y6WWkkI+avQPFYvTUEm4a3zW4ltuBL2n8X+g9i/+DeOfXYmHj8Iyyrn4tis5TgYD6JOkxVA7o2dBD52NI+ez0YWPlba6tFASGsw+xYIKltVi2nsa3xWVq1ETQ80QLh7Q+9J2d9pMggCVWweO5eAu4O0YPvgzEEpsL1Z7d2I41E8pCqiUueSs3dX3M+vFbDcv44Rr8cvwT/45e+84cDVU7R6ECMq/Y5T/sSyslVwR4b5DNtdY+X+uH6Tdwez3wHeuQuslxvfmU18RQjLZtBh74kZ5q+uI6Y9u04RkOnfwJfYF+xJsKaNji950pDv+/X0s/ZPP/3j/Cn/1Dg+WU6a3SXvRXfTCu1n8pl4ECtgmJ51aFBcTpIqd4GbtMlUmPQRTtSfuvz8kgi71wPHqL1G2zhwVKy2CHKb/lBY97xosEVc220LVyKIDr7D/MYcR/frK6LbikPRwEWp/4KdceU8dVYqMk1gFIUfq794fN1b86alvy6EECWzTEBQ+DN1SNkay9DKi45vmDcduig1sY/OESkZ5GtJ+REWUoPkSEIorPb4fByjqVV++rrhzvLeYm9w2fNlHH5QJMMASKuZXRDedJs6E0djWyi+AsUzrVNZh/fOoz/6p4N8SCqnrT/8PNVSKVbMFmUyCpg20rd0hKylHuy5PbQVC63OlOiq5YpbMVyXquYsqxq+J5GzYqXoNtkPWyn81NK5WK5V4f6FqJx4a0lGZ45Xbj1jMd7Il9NHeFsZLD0oMCbeQ8K/u0RGEwTXZFsMTyldnV6Zy/SmXo6VV5ghoWXnkGb1/hPoH8q3JXk+4PVMSl1r5EF62q29Qn1xVmFqJdZKmx1I4+9cYPFPZH0cWyx3djj86rIvM42vsSY04roqcIpuaJpsUHcLx+apbLTxnc3eiy247Ur9BXAqXPXGsW76r9154JSTyPvR5VJkPdc+N7WsS0rl4ZAhPsCVuyfyq+mbbuexXILsuQ9ZRiU++gsB+QOizYtUFMI7eHfw9bG7WfeJQXzEjj6NlfwdsZo9XFcbSBt/MdkREMeFzu0zJQJBffwnfXfK3Oi88syVsCyliUEaBCECvysgiqhb8ws03QJPJYyaq4NblgFenSoaXq0V5XhUW7bowUkZ8PpJQvIJkFXdHqZRos3Jt1gUHlF5up5TF1WI3tjCn1D2GomzpvucShACVkOsHn2cD2Y3Lv+0ZeXXrBhXRKACj+7PRthh5eXtcKC+7C7XwBf928+ZFBTtGHz4uKOnIme6LXKMNWl7j47IZvWgXeNPXq9sA5nKESkPsh8D3OPAEsZfwAVlmj3H9POxUUy22q6FMEE+45iykeY4weGko0C4thF9sIuwDmHt9BIu28XesooY3rqMwYJsNRT9mTr7GZicX1HwhdkBTKtYyhgor55W7R/yZUm8uqTXw/70r/4Cb/V6jn8oB1Dk3jERQR0SHf+zTFCL/1bF1i+F9O/G40/nWmO1ffbT4B74/fMPJSPioWaG0Kzc8FCGQGjat6N85x6Y6B6H6VkoN+Ic0s5wvvvGTtJYe3QmvpcQmeVYBuDpIb7cPuRB5NEt6ko70gOJiv6iipchNEBOaShCAm+Ge2RtaZEcAaI6cItA/baMgKMp78ov2DqEo9OJRFrOROTq79ZH8xpeYDBFNaRJNg8u4i0LyGyBzprLqHOx8C+ZI1afYXUZzQgrUNlyu9mEQIvBA/kciNotScJ5pJO4tAlTt87Txz+CUUIsfnRHyt4ATaFGLnfN5A+HtyE4rFm6HACPIoFDKaaXazxVBo9orCPolGPsIjhpG9scMF7e5a3haMpTscntGUQqKaDsmA5VrjPr9zOCynHft4u79SgWehO92XuYiVPI3pWl/drHs8EDPKush5ZfhvDG8hvakLLIPZBMpFlQWvvI+DzUXsTej0zbWgZ2OC3/grMUNUEJ+zJjzq25hiU4qmJMePZLtdAzR9P+fDJQgyZ9okzCoueiN1wIv2VM9yhrn5e+fPgEEOiE0Z8sfjQrHsbv/LkGcVOvQ4xcDwk064eFlky2itpxLNQjmE6rhZtQyvvcSxMA103bl33239vl6tDiX9PeYmQdx3S3VfU2u7bKTBFFh0ZUFSuRwEspE6Vdm4Y7lMOl4Dbv0CVru2Z1sUb2jmQwoCSDjdCWL5QtkRuPZ6enOTywVneB5qfYUWfkh/kTcqnTUaPaLrrprFDkeCCqp0GkBKkq/SrkYUTwej37h0SaSdm/Xq5OGvUOlqXxUeeOcen7w8xbREt75+/1BykrwM1uv6iHu9EHRtUh5MhtpvhmRhJvVC38OakBfyFoqv+9R9syRvDL2OlbjZ6lnAhuaHI96QkjCBIBeuL4g+78T3GcG8o2Ie0j3YeejAgbCzzFZz7ldAW1yLQmhXPMUh+mr7M/Wa6GL5LBg1WC9ixB0yz38KgU3xhmugzQwp2wIvZbngXFQR2kCWo9UmJ9MkzNwxXN6lbKJ+mCznxtUfpND1AZdLABxYNKjIghs7JpFidY73D7KSAHxEbgqIuz1fBP0kQr27ZqSS5KDCisJgWnT414EW3pV7paC9qVLPQkKyoJ/W9xJr31FU2OD4idEMjadxmky3Y9pYTdj8at5aPl5mOoLJyrRd5oOAZhYuqWG08fSVaiKs5UnrPdievGH4XuYrUTYoDPPboPgsqjIb8IyRoX1YLlDTouMlqCj0IAlkrbLgOrfjdLG7TeFkIvy9FNPth1blAPGLibjdKliV1P1RSLHm8fYKauUmR7OeyAvPiNoeGuLs0t03l3eh7VZx5y0Bays1FMAZW+jJCvpe6v4mb4rMG594rDjPxSE7jYHr3S+TGhOM8aySxbMw5Zdco+/lel02daHmzsA/rPHdjklALIs6pZi5hnffqpaxLFgY/qDcK599FhKrEHMerDWcX8K0JU6cRgxXzDKbzNpXWJ/IeJAOrVwIunvKZouNB7msDJdyNVPyBGlWrFh463YfK9oZqvb8YbfD7p9Y8HR3QJJP3hqxLyKxP3xc4MOpcNz0HBetwEJR4WDFQFy/LdOei1uUgWhg2d7PpyezI90T/QKTYlT/t8cNJt29zYrJqQFbql6GOkK8CrBx2qeTuGTCKat6SJARc7Dn1QYT/RPnyegNFxKAIkROfZzaT7JI7N6AhI8ErFzQBs9a5rISFOfj3gnGvO/ectq4VeguLP6o6ET8T7IC+uxHd9VQrR5zWIXcc8omxSxufDKsiC5pV3WOYy6jdqsi1/ZBdeIeEiH7Ii3x2wKRuRX3Zk+b7gj/T6iBhDluxj1drBd7pzbjOUY6ho1iXyL4VZc+fatKfVYi8NF3pgdG48o5MBSexoSENnc/X7d6Cf6kNl0F3XpcVSGHvTzj0VXv/g817P4tjqxDQlfubHr7kxF9wbPYAZWKx9AsO72cyIY5C+8pYeL179qeX8VhLUfxhEnQ3faP7Ja1lGyF7FDYtKHEUzrYnw3o5i3co1y30LY+BuX7VC4sUZq6MS3y/vIlFXJuE6ZGGXhBq+VNNX/Up51ubT37q+DQT9NXmAiMlxdVWYX6XK0GI3SM</div><div id="enc_passwd"> <input id="enc_pwd_input" type="password" style="border-radius: 5px;border-style: groove;height: 30px;width: 50%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;padding-left: 5px;" onkeydown="if (event.keyCode == 13) { decrypt(); return false;}"> <input type="submit" value="解&nbsp;密" onclick="decrypt()" style="width: 58px;height: 34px;border-radius: 5px;background-color: white;border-style: solid;color: currentColor;"><div id="enc_error" style="display: inline-block;color: #d84527;margin-left: 10px"></div>
<script>
var onError = function(error) {
	document.getElementById("enc_error").innerHTML = "password error!"
};
function decrypt() {
var passwd = document.getElementById("enc_pwd_input").value;
console.log(passwd);
doDecrypt(passwd, onError);
}
</script>
</div>]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 文章加密方案]]></title>
      <url>/2017/12/07/Hexo-%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<p>使用Hexo搭建静态博客有时候有些想给文章加上一些权限，只有指定的人才可以看，这里提供一种通过<code>hexo-encrypt</code>插件实现的Hexo文章的加密方案</p>
<a id="more"></a>
<h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><p><code>hexo-encrypt</code>的详细介绍在<a href="https://github.com/edolphin-ydf/hexo-encrypt" target="_blank" rel="external">这里</a></p>
<p>本地安装插件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-encrypt --save</div></pre></td></tr></table></figure></p>
<p>配置：<br>全站文章默认不加密，只有指定的文章加密</p>
<p>修改站点配置文件<code>_config.yml</code>，在末尾添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">encrypt:</div><div class="line">    enable: true</div><div class="line">	password: 2333</div></pre></td></tr></table></figure></p>
<p>其中2333为默认密码，如果在文章中没有使用新密码，默认使用这个密码</p>
<p>文章头部的添加说明说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">encrypt: true</div><div class="line">enc_pwd: 123456</div></pre></td></tr></table></figure></p>
<p>这篇文章使用新的指定的密码</p>
<h2 id="进阶优化"><a href="#进阶优化" class="headerlink" title="进阶优化"></a>进阶优化</h2><h3 id="替换文本框为密码框"><a href="#替换文本框为密码框" class="headerlink" title="替换文本框为密码框"></a>替换文本框为密码框</h3><p>输入密码默认是明文显示的，把源码中的文本框改为密码框即可：</p>
<p>编辑文件<code>node_modules\hexo-encrypt\lib\conf_post.js</code>，找到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.template = &apos; &lt;input id=&quot;enc_pwd_input&quot; type=&quot;text&quot; style=&quot;&apos; +</div></pre></td></tr></table></figure></p>
<p>替换成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.template = &apos; &lt;input id=&quot;enc_pwd_input&quot; type=&quot;password&quot; style=&quot;&apos; +</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识iptables]]></title>
      <url>/2017/12/04/%E5%88%9D%E8%AF%86iptables/</url>
      <content type="html"><![CDATA[<p><a href="https://www.wikiwand.com/zh-cn/Iptables" target="_blank" rel="external">iptables</a> 可以简单理解为 Linux 系统内核级防火墙 netfilter 的用户态客户端。<br>Linux 管理员通过调用 iptables 命令，配置 Linux 内核 netfilter 模块规则，对网络数据包的流动进行管理。</p>
<a id="more"></a>
<h4 id="iptables-基本命令"><a href="#iptables-基本命令" class="headerlink" title="iptables 基本命令"></a>iptables 基本命令</h4><h5 id="iptables-语法帮助"><a href="#iptables-语法帮助" class="headerlink" title="iptables 语法帮助"></a>iptables 语法帮助</h5><p>可以使用<code>iptables</code>查看iptables的帮助文档</p>
<h5 id="查看-iptables-表的规则"><a href="#查看-iptables-表的规则" class="headerlink" title="查看 iptables 表的规则"></a>查看 iptables 表的规则</h5><p>iptables 有[表 (tables)] 的概念，每张表又包含不同[链 (chains)]，大部分情况下我们仅需要使用 filter 和 nat 两张表的链就可以完成功能。</p>
<p>使用以下命令可以查看 filter 表中的规则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo iptables -L -n</div></pre></td></tr></table></figure></p>
<p>参数解析 -L 列出规则， -n 不显示域名，命令默认显示的是 filter 表，可以通过 -t 参数来指定其他表</p>
<p>可以看到目前 filter 表中有 3 条链: INPUT, FORWARD, OUTPUT。 3 条链都没有任何规则存在，因此通过网卡的网络数据包不会受到任何影响。</p>
<blockquote>
<p>iptables 包含 5 张表（tables）：<br> raw 用于配置数据包，raw 中的数据包不会被系统跟踪。<br> filter 是用于存放所有与防火墙相关操作的默认表。<br> nat 用于网络地址转换（例如：端口转发）。<br> mangle 用于对特定数据包的修改。<br> security 用于强制访问控制网络规则。</p>
<p>链可以看作是一系列规则集合，默认的链被用于不同的场景，用户也可以创建自定义的链。例如：<br>filter 表的 INPUT 链用于进入网卡的数据包过滤<br>filter 表的 OUTPUT 链用于过滤网卡对外发送的数据包过滤 一条链中的规则从上自下顺序执行。<br>实验</p>
</blockquote>
<h4 id="禁止访问目的地址"><a href="#禁止访问目的地址" class="headerlink" title="禁止访问目的地址"></a>禁止访问目的地址</h4><h5 id="添加一条规则到-Filter-表"><a href="#添加一条规则到-Filter-表" class="headerlink" title="添加一条规则到 Filter 表"></a>添加一条规则到 Filter 表</h5><p>在没有任何防火墙规则时，尝试 ping 百度的服务器，ping 是可以正常返回的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ping -c 4 www.baidu.com</div><div class="line">PING qcloud.com (119.29.47.192) 56(84) bytes of data.</div><div class="line">64 bytes from 119.29.47.192: icmp_seq=1 ttl=58 time=3.11 ms</div><div class="line">64 bytes from 119.29.47.192: icmp_seq=2 ttl=58 time=3.10 ms</div><div class="line">64 bytes from 119.29.47.192: icmp_seq=3 ttl=58 time=3.17 ms</div></pre></td></tr></table></figure></p>
<p>假设我们作为 Linux 管理员，不希望有人从本机 ping 百度的服务器，那么就可以用到如下的 iptables 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo iptables -I OUTPUT -p icmp -d www.baidu.com -j DROP</div></pre></td></tr></table></figure></p>
<p>参数解析 -I 添加规则到链的最前面， -p 匹配协议， -d 匹配目的地址， -j DROP 将匹配的数据包实施丢掉动作</p>
<blockquote>
<p>重要:<br>因为在 iptables 一个链中的规则是从上到下依次执行的，因此一条规则在链中的位置十分重要。<br>例如一条拒绝全部连接的规则 -j REJECT 一定要放在链的最后，而允许通行的规则要放在这条规则之前。<br>否则所有网络数据包进入链后直接匹配到这条规则，将导致所有连接被拒绝。</p>
</blockquote>
<p>现在我们可以用 <code>sudo iptables -L -n</code> 命令看到 filter 表的 OUTPUT 链中新增了两条记录，其中 destination 地址是 DNS 返回的百度服务器 IP 地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Chain OUTPUT (policy ACCEPT)</div><div class="line">target     prot opt source               destination</div><div class="line">DROP       icmp --  0.0.0.0/0            220.181.112.244</div><div class="line">DROP       icmp --  0.0.0.0/0            220.181.111.188</div></pre></td></tr></table></figure></p>
<p>这时再 ping 百度服务器会发现无法 ping 通了，因为访问百度服务器 IP 地址的数据包已经被防火墙过滤丢掉了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ping -c 4 www.baidu.com</div><div class="line">PING www.a.shifen.com (220.181.111.188) 56(84) bytes of data.</div><div class="line">ping: sendmsg: Operation not permitted</div><div class="line">ping: sendmsg: Operation not permitted</div></pre></td></tr></table></figure></p>
<h4 id="导出、编辑、导入规则"><a href="#导出、编辑、导入规则" class="headerlink" title="导出、编辑、导入规则"></a>导出、编辑、导入规则</h4><p>在进行一系列复杂的防火墙配置时，大多数时候不建议直接调用 iptables 做规则修改。 因为任何一条错误的配置或者一个 typo （输入错误）都有可能导致严重的网络问题。</p>
<p>一个最佳实践是导出现有规则到文本文件，对该文本文件进行编辑，进行检查无误后再将其导入。</p>
<h5 id="导出规则"><a href="#导出规则" class="headerlink" title="导出规则"></a>导出规则</h5><p>通过如下命令导出所有规则到文本文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo iptables-save &gt; /home/ubuntu/iptables_rules</div></pre></td></tr></table></figure></p>
<h5 id="编辑规则"><a href="#编辑规则" class="headerlink" title="编辑规则"></a>编辑规则</h5><p>在新标签页打开 iptables_rules，在 filter 表的 :OUTPUT ACCEPT 链下面添加一条规则的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-A OUTPUT -p icmp -d 114.114.114.114 -j DROP</div></pre></td></tr></table></figure></p>
<h5 id="导入规则"><a href="#导入规则" class="headerlink" title="导入规则"></a>导入规则</h5><p>使用命令将编辑过的规则重新导入 iptables<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo iptables-restore /home/ubuntu/iptables_rules</div></pre></td></tr></table></figure></p>
<p>使用 sudo iptables -L -n 查看是否有禁止 ping 114.114.114.114 的新增规则</p>
<h5 id="清除全部规则"><a href="#清除全部规则" class="headerlink" title="清除全部规则"></a>清除全部规则</h5><p>现在我们清除上一小节中增加的规则，还原到没有任何规则的初始状态。</p>
<p>Note：当你因为错误的配置 iptables 导致自己无法远程访问的时候，从 console 执行这条命令可以快速修复状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo iptables -F</div></pre></td></tr></table></figure>
<p>iptables 还提供 -X 参数清除[自定义链]， -Z 参数重置计数器</p>
<h4 id="黑-白名单"><a href="#黑-白名单" class="headerlink" title="黑/白名单"></a>黑/白名单</h4><p>某公司禁止特定的 PC 设备访问和工作无关的网站，而其他设备则不受限制。</p>
<p>分析：</p>
<p>1.首先明确是对外访问限制，所以应该编辑 iptables OUTPUT 链进行限制</p>
<p>2.其次，由于目的地址可能是数百个网站，针对每一台PC配置数百条规则是不可接受的，因此我们选择使用自建一条链来实现。</p>
<p>3.公司只限制部分 PC 访问，因此对 PC 的匹配最好使用 IP 地址匹配，不匹配的设备则不受限制。</p>
<p>Note: 对于进入 INPUT 链的入站规则还可以采用 mac 匹配。</p>
<h5 id="查看本机-IP-地址。"><a href="#查看本机-IP-地址。" class="headerlink" title="查看本机 IP 地址。"></a>查看本机 IP 地址。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ip a show eth0</div></pre></td></tr></table></figure>
<p>在 inet 之后的就是本机网口的 IP 地址，例如 10.135.166.86</p>
<p>查看公网IP也可以使用一些IP工具进行查看</p>
<h5 id="编辑-iptables-规则："><a href="#编辑-iptables-规则：" class="headerlink" title="编辑 iptables 规则："></a>编辑 iptables 规则：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//清除已有规则</div><div class="line"></div><div class="line">sudo iptables -F</div><div class="line">//清除自建链</div><div class="line"></div><div class="line">sudo iptables -X</div><div class="line">//新建一个叫做 BLACKLIST 的链</div><div class="line"></div><div class="line">sudo iptables -N BLACKLIST</div><div class="line">//当访问的源 IP 地址是本机的时候进入 BLACKLIST 链</div><div class="line"></div><div class="line">sudo iptables -A OUTPUT -s 10.135.166.86 -j BLACKLIST</div><div class="line">//向 BLACKLIST 链添加 2 条规则</div><div class="line"></div><div class="line">sudo iptables -A BLACKLIST -d 114.114.114.114 -j DROP</div><div class="line">sudo iptables -A BLACKLIST -d 220.181.111.188 -j DROP</div></pre></td></tr></table></figure>
<p>如上配置后，会发现本机已经无法 ping BLACKLIST 中的目的地址了。</p>
<p>如果后续要增加新的禁止访问的目的地址，则只需向 BLACKLIST 链添加新规则。<br>如果需要限制另一台 PC 通过本网关转发访问外网，则只需添加一条 OUTPUT 链的源 IP 匹配规则并指向 -j BLACKLIST。</p>
<h4 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h4><p>分析： 通常来讲应该首先考虑程序本身能否配置监听多个端口，或者使用负载均衡器作为代理程序。 但在本次实验中我们将使用 iptables 监听 8080 端口并将网络数据包转发给本地80端口</p>
<p>首先测试 <code>telnet 0 80</code> 和 <code>telnet 0 8080</code> 可以看到 80 和 8080 端口都是不通的。</p>
<p>接下来我们用 netcat 监听 80 端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nc -k -l 80 &amp;</div></pre></td></tr></table></figure></p>
<p>这时候 telnet 0 80 发现 80 端口可以工作了。</p>
<p>下面我们用 iptables 做一个端口映射<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo iptables -t nat -A OUTPUT -p tcp -d 127.0.0.1 --dport 8080 -j DNAT --to 127.0.0.1:80</div></pre></td></tr></table></figure></p>
<p>这里我们用到了 -t nat 参数，表示我们使用了 netfilter 的 nat 表。在 nat 表的 OUTPUT 链上做了一个 -j DNAT 转发，将访问内网 8080 端口的数据包转向了 80 端口。</p>
<p>这时候 telnet 0 8080 发现 8080 端口也可以工作了。</p>
<p>如果是监听外网的 8080 端口转发到 80 端口，则需要执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo iptables -t nat -A PREROUTING -p tcp --dport 8080 -j REDIRECT --to-ports 80</div></pre></td></tr></table></figure></p>
<p>通过使用 PREROUTING 链直接将访问 8080 端口的数据包转发到 80 端口</p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iptables </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[台中两日游]]></title>
      <url>/2017/12/04/%E5%8F%B0%E4%B8%AD%E4%B8%A4%E6%97%A5%E6%B8%B8/</url>
      <content type="html"><![CDATA[<p>又到周末，看天气预报台北这个周末还是下雨，这次下定决心要南下避雨。早上做的决定，然后查火车时间、定民宿九点才从家里出发，也算是一个说走就走的旅行吧。</p>
<a id="more"></a>
<h2 id="台铁网络"><a href="#台铁网络" class="headerlink" title="台铁网络"></a>台铁网络</h2><p>早上在家查火车时间的时候已经没有对号列车，想要有座位只能做区间车，还好从台北车站上车的时候还有一些座位。</p>
<p>到台中已经是下午一点了，然后继续坐区间车到清水车站，转一次公交车到高美湿地，中间换乘公交的时候等了很久。最后到高美湿地的时候已经是下午四点了。</p>
<p>其中区间车从台中到清水事实上是北上的，按理说如果北上的话我在从台北到台中的车上到清水停下来就行了。之前我一直以为台湾的铁路网络就是绕着台湾转一个圈圈，其实除了台铁在这个圆圈中生出一些短的分支以外，还有一段是两条线平行的。具体可以看台铁的<a href="https://www.railway.gov.tw/Upload/UserFiles/tr_line.pdf" target="_blank" rel="external">线路图</a>。这一段大致就是从新竹到台中一段，分成了山线和海线两条平行线，台中在山线的一段，清水在海线的一段，所以才要坐区间车绕到海线然后北上。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-160347.png" alt="台中车站"></p>
<h2 id="高美湿地"><a href="#高美湿地" class="headerlink" title="高美湿地"></a>高美湿地</h2><p>高美湿地之前其实不是湿地是对外开放的<a href="https://www.wikiwand.com/zh-cn/%E6%B5%B7%E6%B0%B4%E6%B5%B4%E5%A0%B4" target="_blank" rel="external">海水浴场</a>，湿地也是这几十年形成的。主要的原因是旁边建了一个台中港导致泥沙淤积。后面又建了一组风力发电站，才有了今天照片中的这番景色。</p>
<p>到了高美湿地以后第一个感受就是风大，到桥的边上感觉都能够被吹起来。第二感觉就是这“风扇叶子”好大啊，站在发电机组旁边想着这玩意要是砸下来不就GG了。高美湿地一直是以夕阳的美景著称，但是我去的那天天上全都是云，偶尔有几个“窟窿”还不是在海的那一边，可能是我来得太早了吧。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_1512374762267.jpg" alt="别人拍的高美湿地"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-160712.png" alt="我拍的高美湿地"></p>
<h2 id="台中公共交通"><a href="#台中公共交通" class="headerlink" title="台中公共交通"></a>台中公共交通</h2><p>台中的公交交通一个比较有特点的地方就是前十公里免费，这种优惠政策在台湾只有台中有，在世界上应该也是蛮罕见的。至于为什么台中会实施这种优惠政策，看网上说的好像是市长选举的时候为了拉选票推出的。另外台中的iUbike前30分钟也是免费的，这福利真是太好了，我在台中的这两天我坐公交一共只花了10+TWD。</p>
<p>不过还是要吐槽一下台中的公交车，发车间隔太长了。除了由之前的快速公交改过来的300路，其他公交线路发车间隔时间都在20分钟以上。去高美湿地的时候来回差不多都等了半个小时的公交，还是台北的公交系统发达啊。</p>
<h2 id="逢甲夜市"><a href="#逢甲夜市" class="headerlink" title="逢甲夜市"></a>逢甲夜市</h2><p>逢甲夜市号称是台湾最大的夜市，这个看他们的牌子就看得出来，别的夜市一般都只加上“观光夜市”的字样，逢甲霸气的加上了“国际观光夜市”。</p>
<p>东西的确挺多的，占了两条街，我选了两个队排得比较长的吃了一下，感觉还行。</p>
<p>旁边隔着的就是逢甲大学了，外面人潮涌动，逢甲大学里面却只有稀稀疏疏几个人。学校旁边是台湾最大的夜市，一定能够换着花样吃。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-160837.png" alt="逢甲夜市"></p>
<h2 id="民宿体验"><a href="#民宿体验" class="headerlink" title="民宿体验"></a>民宿体验</h2><p>民宿因为是当天才找的，所以能够选择的余地并不过。不过总体的体验还好，民宿小姐姐特意来新光三越接我。我住的是8人混住房实际住的只有4个人，高中之后第一次睡上下铺。地点在台中市的市中心，旁边就是新光三越和市政府。卫生情况也还可以，比较特别的就是认识两个小伙伴，一个是在世新大学读传媒的马来西亚交换生；另一个是台湾这边的一个老师。</p>
<p>和他们聊的时候也收获到了蛮多的东西，比如说为什么马拉西亚人的中文那么好、台北冬天为什么一直下雨。其实想想，一个人出来玩有一个人出来玩的好处吧，如果结伴出行可能就不一定会认识到这些人有这些收获。</p>
<h2 id="东海大学"><a href="#东海大学" class="headerlink" title="东海大学"></a>东海大学</h2><p>东海大学是台中的一个有基督教背景的私立大学，台中非常有名的路思义教堂就在东海大学里面。有人评价路思义教堂是中华文化与西方相遇而产生的最佳作品。对建筑风格没什么了解，不过觉得还是挺有特色的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-160942.png" alt="东海大学"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-160940.png" alt="路思义教堂"></p>
<h2 id="台中歌剧院"><a href="#台中歌剧院" class="headerlink" title="台中歌剧院"></a>台中歌剧院</h2><p>台中歌剧院的建筑非常有特色，位于台湾市中心。歌剧院由钢筋混沙土构造，部分为钢构造；建筑师伊东丰雄的设计，以人类最原始的“树屋”、“洞窟”的概念设计出美声国栋（Sexy guy），内部墙面均为曲面。共有58面曲墙，兴建难度极高。</p>
<p>比较感兴趣的时候楼顶的空中花园，但是因为修养关闭没能够上去，可惜了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-162744.png" alt="台中歌剧院"></p>
<h2 id="台湾美术馆"><a href="#台湾美术馆" class="headerlink" title="台湾美术馆"></a>台湾美术馆</h2><p>前面的歌剧院因为11：30才开馆，所以也没能够进去参观，台湾美术馆应该是这次台中之行在室内看的最受震撼的地方吧。里面各种艺术展品都挺震撼的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-163955.png" alt="enter description here" title="美术馆外景-1"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-164107.png" alt="enter description here" title="美术馆外景-2"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-163957.png" alt="enter description here" title="美术馆内景-1"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-163959.png" alt="enter description here" title="美术馆内景-2"></p>
<h2 id="静宜大学"><a href="#静宜大学" class="headerlink" title="静宜大学"></a>静宜大学</h2><p>前面的东海大学是基督教大学，而静宜大学是一所天主教大学。之前一直是一所女子大学，从1993年开始才开始招收男生。校园里面环境挺好的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-164806.png" alt="enter description here" title="静宜大学校门"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-164735.png" alt="enter description here" title="静宜大学图书馆"></p>
<h2 id="宫原眼科"><a href="#宫原眼科" class="headerlink" title="宫原眼科"></a>宫原眼科</h2><p>当我第一次看到这个景点名的时候，我一直以为是一个医院，看他的<a href="http://www.miyahara.com.tw/" target="_blank" rel="external">官网</a>也不知道具体是干啥的。</p>
<p>后来才知道是一个甜品店，建造於西元1927年，是由日本眼科博士宫原武熊所兴建，也是日治时代台中规模最大的眼科诊所。后来成了危楼，被「日出」团队重新复原成现在颇具特色的宫原眼科。</p>
<p>听说里面的冰淇淋和凤梨酥比较有名，尝了一下冰淇淋，还不错。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_4_171204-165730.png" alt="enter description here" title="宫原眼科"></p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[士林半日游]]></title>
      <url>/2017/11/28/%E5%A3%AB%E6%9E%97%E5%8D%8A%E6%97%A5%E6%B8%B8/</url>
      <content type="html"><![CDATA[<p>周末在家瘫了一天，另一天不想浪费了。刚好最近看了一个体验东京科技馆的视频，就想看看台湾科技馆里面有什么有趣的东西。</p>
<a id="more"></a>
<h2 id="台湾科教馆"><a href="#台湾科教馆" class="headerlink" title="台湾科教馆"></a>台湾科教馆</h2><p>台湾科教馆在台北捷运红线士林站附近，不过离捷运站还是有一点距离，推荐骑Ubike过去。旁边是台北天文馆和台北新儿童乐园。这一带还是挺适合亲子周末游玩了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_2_001.jpg" alt="外景（我去的时候装修，没拍到）"></p>
<p>科教馆里面3楼到7楼是常设展厅，需要购票。价格是100TWD，学生优惠价70TWD。另外还有一些项目，立体剧院、地震剧场啥的，我也花了20TWD体验了一把地震剧场。</p>
<p>3楼到7楼的常设展厅还是挺有意思的，有许多学习互动的设备。涉及的知识差不多就是初中高中所学的生物、物理、化学和数学的相关知识（哈哈，感觉回到了高中课堂）。正常速度走走看看能够看两三个小时。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_2_WechatIMG2.jpeg" alt="模型"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_2_WechatIMG3.jpeg" alt="馆内的科普讲座"></p>
<p>参观完常设展厅，我也体验了一下地震剧场。就是一个比较大的圆盘里面坐十个人左右，然后模拟4-5级的地震，然后屏幕上播放<a href="https://www.wikiwand.com/zh-hans/921%E5%A4%A7%E5%9C%B0%E9%9C%87" target="_blank" rel="external">921地震</a>的纪录片。地震体验效果一般，但是屏幕上播放的纪录片挺震撼的。</p>
<h2 id="士林夜市"><a href="#士林夜市" class="headerlink" title="士林夜市"></a>士林夜市</h2><p>到了士林，自然要来这里有名的士林夜市逛一逛了。因为来得太早了，之前得到的逛夜市经验（哪里排队多哪里好吃）也派不上用场。于是就在网上找了推荐比较多的两家店平吃了一下。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_2_WechatIMG4.jpeg" alt="士林市场大门"></p>
<p>1972年就开业的忠诚号蚵仔煎应该是士林夜市最具代表性的小吃了，上次吃蚵仔煎还是在花莲的东门夜市，不过上次因为是带回民宿吃的，所以最后吃到的东西是凉的。这次的蚵仔煎感觉就跟上次的大不一样了，非常好吃。<br>注意台湾这边蚵仔煎的叫法是从闽南话音译过来的，叫（ǒu ā jīan）</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_2_WechatIMG1.jpeg" alt="忠诚号"></p>
<p>士林夜市大门旁边的十全排骨也不错，份量很足，吃起来很带劲。</p>
<p>十全排骨 照片</p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[夜登剑潭山]]></title>
      <url>/2017/11/26/%E5%A4%9C%E7%99%BB%E5%89%91%E6%BD%AD%E5%B1%B1/</url>
      <content type="html"><![CDATA[<p>看台北夜景一般的选择都是象山，那边有台北的地标建筑——101大楼。除了象山，剑潭山也是看台北夜景的一个不错的选择，人少而且能够换一个角度看台北。</p>
<a id="more"></a>
<h2 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h2><p>剑潭山在士林夜市旁边，能够在士林夜市吃饱喝足再上山。不过我最近迷恋金拱门，这次是吃了两包大暑才上山的。</p>
<p>我们上山的线路大致是<a href="https://www.google.com/maps/dir/%E6%8D%B7%E9%81%8B%E5%8A%8D%E6%BD%AD%E7%AB%99+111%E5%8F%B0%E5%8C%97%E5%B8%82%E5%A3%AB%E6%9E%97%E5%8D%80/104%E5%8F%B0%E5%8C%97%E5%B8%82%E4%B8%AD%E5%B1%B1%E5%8C%BA%E8%80%81%E5%9C%B0%E6%96%B9%E8%A7%82%E6%99%AF%E5%B9%B3%E5%8F%B0/@25.0834816,121.5280835,15.63z/data=!4m24!4m23!1m15!1m1!1s0x3442aeb1dc51736b:0xba7e1559c66ed90f!2m2!1d121.525077!2d25.084873!3m4!1m2!1d121.5249269!2d25.0796471!3s0x3442aeb29b137353:0xc81fe0fdb900019a!3m4!1m2!1d121.5297702!2d25.0831486!3s0x3442aeae847cf9f3:0x8ad42cd31d0e8b6a!1m5!1m1!1s0x3442aea758724e3b:0x6f606638fbaff219!2m2!1d121.536965!2d25.0904047!3e2" target="_blank" rel="external">这样</a>的：</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_2_1512191397180.jpg" alt="登山路线"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_12_2_WechatIMG5.jpeg" alt="登山，出发！"></p>
<h2 id="爬山"><a href="#爬山" class="headerlink" title="爬山"></a>爬山</h2><p>我们上山的时候刚好是晚上十二点，山上几乎是一个人都没有，遇到的唯一一对外国情侣还是我们刚上去他们从山上下来的时候遇到了。</p>
<p>想想半夜如果你爬山爬着爬着发现后面有两个人其实也蛮恐怖的。</p>
<p>上山道路的前一半是有路灯的，而且这些路灯是通宵开着的，所以前面一段路还是不用怕的。途中也能够遇到一些寺庙、亭子，甚至还有羽毛球场（在山上打羽毛球就不怕球掉书上吗）。下雨的时候还能够遇到一些动物，大型的蜗牛啥的。</p>
<p>不过有路灯的登山道到的观景平台能够看到的景色就有限了，在剑潭山看台北夜景最好的地方就是老地方观景平台了。</p>
<p>晚上想要到老地方观景平台就必须要走一段没有路灯的山路，就是上面的路线图中的标出来比较大的路。一开始我们以为是公路，结果就是比前面的登山道大一点点。凌晨一点，两个大老爷们纠结了十多分钟走不走这个没有路灯的路，各种想象什么土狗、浪、蛇什么的。最后还是鼓起勇气走了，一开始走的时候有点害怕，一篇漆黑，但是走到后面习惯了也就不那么怕了。</p>
<p>没有路灯的路走个半个小时应该就到了剑潭山看夜景最好的位置——老地方观景平台了，能够望见远处的101大楼和松山机场，晚上的景色十分美丽。</p>
<p>由于晚上手机照相的质量实在是太差了，照片可以参考<a href="http://hx271.pixnet.net/blog/post/61096888-%E3%80%90%E5%8F%B0%E5%8C%97%E5%8D%81%E5%A4%A7%E5%A4%9C%E6%99%AF%E3%80%91%E9%98%BF%E5%AE%8F%E9%81%94%E4%BA%BA%E7%B2%BE%E9%81%B8~%E5%A4%9C%E6%99%9A%E5%BF%85%E7%9C%8B%E7%9A%84" target="_blank" rel="external">这里</a></p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[台湾延时摄影集合]]></title>
      <url>/2017/11/21/%E5%8F%B0%E6%B9%BE%E5%BB%B6%E6%97%B6%E6%91%84%E5%BD%B1%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<p>我在台湾交换期间拍摄的延时摄影的集合，没有专业设备，大家看看就好</p>
<a id="more"></a>
<h2 id="捷运文湖线"><a href="#捷运文湖线" class="headerlink" title="捷运文湖线"></a>捷运文湖线</h2><p>因为文湖线的列车都是自动驾驶的，所以才能够有机会拍出这些片子</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/OYMoRU74TuA" frameborder="0" gesture="media" allowfullscreen></iframe>

<h2 id="高美湿地"><a href="#高美湿地" class="headerlink" title="高美湿地"></a>高美湿地</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/w2I4JOnycek" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe>

<h2 id="阿里山"><a href="#阿里山" class="headerlink" title="阿里山"></a>阿里山</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/8eSMokATgSA" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe>

<iframe width="560" height="315" src="https://www.youtube.com/embed/A_Kyl8niz6k" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe>

<h2 id="台北-官渡大桥"><a href="#台北-官渡大桥" class="headerlink" title="台北 官渡大桥"></a>台北 官渡大桥</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/lyk9iq5TAnc" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[台北捷运集章第一弹]]></title>
      <url>/2017/11/19/%E5%8F%B0%E5%8C%97%E6%8D%B7%E8%BF%90%E9%9B%86%E7%AB%A0%E7%AC%AC%E4%B8%80%E5%BC%B9/</url>
      <content type="html"><![CDATA[<p>这是我完成集齐捷运纪念章章计划第一天。</p>
<a id="more"></a>
<h2 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h2><p>先放一张台北整体的捷运图吧。<br><img src="https://data2.liuin.cn/story-writer/2017_11_12_1510496480309.jpg" alt="enter description here" title="台北捷运路线图"><br>计划一天完成线路：<br>永安市场（黄线）–&gt; 南势角（黄线）–&gt; 忠孝新生 –&gt; 顶埔（蓝线） –&gt; 南港展览馆 –&gt;  动物园（棕线） –&gt; 南京复兴 –&gt; 松山（绿线）–&gt; 新店（绿线） –&gt; 公馆（绿线）–&gt; 回家<br>将蓝线、棕线和绿线的所有捷运站的纪念章都集齐</p>
<p>实际完成的情况是这样的：<br>永安市场（黄线）–&gt; 南势角（黄线）–&gt; 忠孝新生 –&gt; 顶埔（蓝线） –&gt; 南港展览馆 –&gt; 南京复兴 –&gt; 松山（路线） –&gt; 大安森林公园（红线）–&gt; 回家<br>只完成了蓝线的集章任务</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG4.jpeg" alt="enter description here" title="出发"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG1-1.jpeg" alt="enter description here" title="捷运一日票"></p>
<h2 id="台北捷运“观光线”——棕线"><a href="#台北捷运“观光线”——棕线" class="headerlink" title="台北捷运“观光线”——棕线"></a>台北捷运“观光线”——棕线</h2><h2 id="大湖公园"><a href="#大湖公园" class="headerlink" title="大湖公园"></a>大湖公园</h2><p>今天一天中比较好玩的景点差不多都在棕线上，大湖公园本来不是计划游玩的景点，但是却花了一个小时在里面逛。主要是捷运一转弯就看到了这个非常美丽的湖，忍不住下去看两眼。<br> “大湖”旧名十四份埤（陂），因白鹭成群又称白鹭湖，采用中国园林式设计。其实这个湖的名气不是很大，只是台北的一个区域性公园。但是风景是相当的好，公园里面的小动物也挺多的，是一个踏青的好地方。</p>
<p> <img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG9.jpeg" alt="enter description here" title="大湖湖面"></p>
<p> <img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG11.jpeg" alt="enter description here" title="大湖风景"></p>
<h2 id="松山机场"><a href="#松山机场" class="headerlink" title="松山机场"></a>松山机场</h2><p>松山机场应该是台湾的第三大机场，仅次于桃园机场和高雄机场。是一个军民合用机场，民用部分为台北国际航空站，主要负责的是台晚本地的航线以及两岸航线，最远的也只是到韩国；军用部分为空军松山基地。<br>松山机场开放了一个观景平台供游客参观，在第一航厦和第二航厦之间。机场里面有明显的指示牌，非常容易找到。装饰非常棒，就是今天一直是阴雨天气，看到的是灰蒙蒙的一片，或许以后天气好的时候可以再来一次。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG10.jpeg" alt="enter description here" title="观景台指引"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG3.jpeg" alt="enter description here" title="台北国际航空站"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG5.jpeg" alt="enter description here" title="观景平台"></p>
<h2 id="饶河夜市"><a href="#饶河夜市" class="headerlink" title="饶河夜市"></a>饶河夜市</h2><p>来之前听说松山捷运站有一个花一千五百万新台币修建的叫“河流彎曲之處”的捷运艺术还不错，趁今天买了捷运一日票特地去看看。到了现场感受没有图片中那么好看，可能是图片修过吧。<br>饶河夜市就在松山捷运站的出口处，是台北一个比较有名的观光夜市。逛夜市就要找人多的地方，这次花了半个小时在两个地方吃了点东西，都非常好吃，一个是爆浆鸡翅另一个是进夜市口能够看到的福州世祖胡椒饼</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG7.jpeg" alt="enter description here" title="松山捷运站艺术"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG2.jpeg" alt="enter description here" title="饶河观光夜市"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG6.jpeg" alt="enter description here" title="福州世祖胡椒饼"></p>
<h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>这一天一共集章44块，台北的捷运站一共有117个。现在的进度是44/117，看来还要两次才能够完成台北捷运全制霸的计划。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_27_WechatIMG12.jpeg" alt="enter description here" title="成果"></p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git 停止追踪文件]]></title>
      <url>/2017/11/16/Git-%E5%81%9C%E6%AD%A2%E8%BF%BD%E8%B8%AA%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>平时在使用Git的时候，大多会有这种情况：因为在初始化git的时候没有考虑周全导致有些不需要的文件已经被被追踪，或者想不让在某次提交以后一些文件不被追踪（比如说一些涉及隐私的配置文件）。这里提供一些解决方案</p>
<a id="more"></a>
<h2 id="Git中忽略某些文件"><a href="#Git中忽略某些文件" class="headerlink" title="Git中忽略某些文件"></a>Git中忽略某些文件</h2><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p>在一开始git进行初始化的时候我们可以通过修改配置文件.gitignore来指定哪些文件是不需要被追踪的。<br>文件 .gitignore 的格式规范如下：</p>
<ul>
<li>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。(glob 模式是指 shell 所使用的简化了的正则表达式)</li>
<li>匹配模式最后跟反斜杠（/）说明要忽略的是目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li>
</ul>
<h3 id="快捷设置-gitignore"><a href="#快捷设置-gitignore" class="headerlink" title="快捷设置.gitignore"></a>快捷设置.gitignore</h3><p>一般我们在项目中会有超多不需要放到git上面的东西，但是一个一个加入到.gitignore中是非常麻烦的。可以使用gitignore.io提供的API快速创建<br>设置别名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global alias.ignore &apos;!gi() &#123; curl -L -s https://www.gitignore.io/api/$@ ; &#125;; gi&apos;</div></pre></td></tr></table></figure></p>
<p>这样以后创建项目的时候只需要结合你的开发环境通过关键进行快捷创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git ignore macOS &gt;&gt; .gitignore</div></pre></td></tr></table></figure></p>
<h2 id="忽略未追踪文件"><a href="#忽略未追踪文件" class="headerlink" title="忽略未追踪文件"></a>忽略未追踪文件</h2><p>在项目开发中可能会有一些新的不想追踪的文件生成，这个时候有两种处理方法：</p>
<ol>
<li>更新.gitignore 文件，这种操作能够使得其他人也忽略对这些文件的追踪</li>
<li>将忽略的文件加到项目文件夹中的 .git/Info/exclude文件中，这种操作只对本地起作用。</li>
</ol>
<h2 id="停止追踪某些文件"><a href="#停止追踪某些文件" class="headerlink" title="停止追踪某些文件"></a>停止追踪某些文件</h2><p>如果文件已经被git追踪，不想在后面的开发中提交这些文件的修改，这里有两个方案：</p>
<ol>
<li>删除文件以后再加到.gitignore 中，这种方案会使得原来那个可能有用的文件就丢失了。</li>
<li>使用<code>git update-index --assume-unchanged [filename]</code> 来忽略某些文件的修改, 这种修改只能再本地起作用，当别人使用这个项目的时候并不会起作用。</li>
<li>使用<code>git rm --cached filename</code>把文件从暂存里移除掉，之后的修改就不会追踪这些文件了。这种方案能够同步到远程，但是别人在拉取你的更新时也要消除对这些文件的追踪。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux中搭建FTP文件服务器]]></title>
      <url>/2017/11/12/Linux%E4%B8%AD%E6%90%AD%E5%BB%BAFTP%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>这篇文章对在Linux中使用VSFTPD部署FTP文件服务器做了一个简单的介绍。<br>使用的是VSFTPD，vsftpd 是“very secure FTP damon”的缩写，vsftpd的一个最大的特点是它的安全性。</p>
<a id="more"></a>
<h2 id="安装并启动FTP服务器"><a href="#安装并启动FTP服务器" class="headerlink" title="安装并启动FTP服务器"></a>安装并启动FTP服务器</h2><h3 id="安装VSFTPD"><a href="#安装VSFTPD" class="headerlink" title="安装VSFTPD"></a>安装VSFTPD</h3><p>使用 <code>apt-get</code> 安装 vsftpd：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install vsftpd -y</div></pre></td></tr></table></figure></p>
<p><code>-y</code> 参数表示对所有问题用yes来回答</p>
<h3 id="启动VSFTPD"><a href="#启动VSFTPD" class="headerlink" title="启动VSFTPD"></a>启动VSFTPD</h3><p>安装完成后 VSFTPD 会自动启动，通过 netstat 命令可以看到系统已经监听了 21 端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo netstat -nltp | grep 21</div></pre></td></tr></table></figure></p>
<p>如果没有启动，可以手动开启 VSFTPD 服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl start vsftpd.service</div></pre></td></tr></table></figure></p>
<h2 id="配置用户访问目录"><a href="#配置用户访问目录" class="headerlink" title="配置用户访问目录"></a>配置用户访问目录</h2><h3 id="新建用户主目录"><a href="#新建用户主目录" class="headerlink" title="新建用户主目录"></a>新建用户主目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo mkdir /home/uftp</div></pre></td></tr></table></figure>
<p>创建登录欢迎文件用来测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo touch /home/uftp/welcome.txt</div></pre></td></tr></table></figure></p>
<h3 id="新建用户-uftp-并设置密码"><a href="#新建用户-uftp-并设置密码" class="headerlink" title="新建用户 uftp 并设置密码"></a>新建用户 uftp 并设置密码</h3><p>创建一个用户 uftp :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo useradd -d /home/uftp -s /bin/bash uftp</div></pre></td></tr></table></figure></p>
<p>为用户 uftp 设置密码 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo passwd uftp</div></pre></td></tr></table></figure></p>
<p>删除掉 pam.d 中 vsftpd，因为该配置文件会导致使用用户名登录 ftp 失败：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo rm /etc/pam.d/vsftpd</div></pre></td></tr></table></figure></p>
<h3 id="限制该用户仅能通过-FTP-访问"><a href="#限制该用户仅能通过-FTP-访问" class="headerlink" title="限制该用户仅能通过 FTP 访问"></a>限制该用户仅能通过 FTP 访问</h3><p>限制用户 uftp 只能通过 FTP 访问服务器，而不能直接登录服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo usermod -s /sbin/nologin uftp</div></pre></td></tr></table></figure></p>
<h3 id="修改-vsftpd-配置"><a href="#修改-vsftpd-配置" class="headerlink" title="修改 vsftpd 配置"></a>修改 vsftpd 配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chmod a+w /etc/vsftpd.conf</div></pre></td></tr></table></figure>
<p>修改 /etc/vsftpd.conf 文件中的配置（直接将如下配置添加到配置文件最下方）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># 限制用户对主目录以外目录访问</div><div class="line">chroot_local_user=YES</div><div class="line"></div><div class="line"># 指定一个 userlist 存放允许访问 ftp 的用户列表</div><div class="line">userlist_deny=NO</div><div class="line">userlist_enable=YES</div><div class="line"></div><div class="line"># 记录允许访问 ftp 用户列表</div><div class="line">userlist_file=/etc/vsftpd.user_list</div><div class="line"></div><div class="line"># 不配置可能导致莫名的530问题</div><div class="line">seccomp_sandbox=NO</div><div class="line"></div><div class="line"># 允许文件上传</div><div class="line">write_enable=YES</div><div class="line"></div><div class="line"># 使用utf8编码</div><div class="line">utf8_filesystem=YES</div></pre></td></tr></table></figure></p>
<p>新建文件 /etc/vsftpd.user_list，用于存放允许访问 ftp 的用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo touch /etc/vsftpd.user_list</div><div class="line">sudo chmod a+w /etc/vsftpd.user_list</div></pre></td></tr></table></figure></p>
<p>修改 /etc/vsftpd.user_list ，加入刚刚创建的用户：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uftp</div></pre></td></tr></table></figure>
<h3 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a>设置访问权限</h3><p>设置主目录访问权限（只读）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chmod a-w /home/uftp</div></pre></td></tr></table></figure></p>
<p>新建公共目录，并设置权限（读写）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo mkdir /home/uftp/public &amp;&amp; sudo chmod 777 -R /home/uftp/public</div></pre></td></tr></table></figure></p>
<p>重启vsftpd 服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo systemctl restart vsftpd.service</div></pre></td></tr></table></figure></p>
<p>也可以多创建几个用户来实现对主目录的不同读写权限的管理</p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 结构解析]]></title>
      <url>/2017/11/09/Hexo-%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>对Hexo 的配置文件夹进行分析。</p>
<a id="more"></a>
<h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><p>在hexo的主目录下有一下文件和文件夹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">├── _config.yml	    #站点配置文件</div><div class="line">├── db.json            #缓存文件</div><div class="line">├── debug.log       #hexo s --debug 产生的日志文件</div><div class="line">├── node_modules    #nodejs 本地包</div><div class="line">├── package.json    #nodejs 本地配置信息</div><div class="line">├── public               #生成的静态文件所在的文件夹</div><div class="line">├── scaffolds          #新生成page的模板</div><div class="line">├── source             #文章所在文件夹</div><div class="line">└── themes           #主题所在文件夹</div><div class="line"></div><div class="line">5 directories, 4 files</div></pre></td></tr></table></figure></p>
<h2 id="主题文件结构"><a href="#主题文件结构" class="headerlink" title="主题文件结构"></a>主题文件结构</h2><p>一个主题的大致结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── _config.yml   # 主题配置文件</div><div class="line">├── languages     #语言文件夹</div><div class="line">├── layout            # 布局文件夹。用于存放主题的模板文件，决定了网站内容的呈现方式</div><div class="line">├── scripts        # 脚本文件夹</div><div class="line">└── source       # 资源文件夹，除了模板以外的 Asset，例如 CSS、JavaScript 文件等，都应该放在这个文件夹中。</div></pre></td></tr></table></figure></p>
<h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><p>布局文件夹。用于存放主题的模板文件，决定了网站内容的呈现方式。Hexo 默认使用的Swig模板引擎。使用语法和Jinja2、Django模板引擎类似。</p>
<p>文件或文件夹开头名称为 _（下划线线）或隐藏的文件会被忽略。</p>
<p>每个模板都默认使用 layout 布局，实际对应的文件是_layout.swig 文件。下面是各个页面所对应的模板的名称：</p>
<table>
<thead>
<tr>
<th>模板</th>
<th>用途</th>
<th>回调</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>首页</td>
</tr>
<tr>
<td>post</td>
<td>文章</td>
<td>index</td>
</tr>
<tr>
<td>page</td>
<td>分页</td>
<td>index</td>
</tr>
<tr>
<td>archive</td>
<td>归档</td>
<td>index</td>
</tr>
<tr>
<td>category</td>
<td>分类归档</td>
<td>archive</td>
</tr>
<tr>
<td>tag</td>
<td>标签归档</td>
<td>archive</td>
</tr>
</tbody>
</table>
<p>局部模版（Partial）<br>局部模板让您在不同模板之间共享相同的组件，例如页首（Header）、页脚（Footer）或侧边栏（Sidebar）等，可利用局部模板功能分割为个别文件，让维护更加便利。</p>
<h3 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h3><p>只需要把 JavaScript 文件放到 scripts 文件夹，在启动时就会自动载入。</p>
]]></content>
      
        <categories>
            
            <category> 开发随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux cd后追加ls]]></title>
      <url>/2017/11/04/Linux-cd%E5%90%8E%E8%BF%BD%E5%8A%A0ls/</url>
      <content type="html"><![CDATA[<p>不知道你们在使用命令行的时候有没有这种体验：就是每次到一个新的目录下就会追加一个命令ls看看该目录下面有什么。这里提供一个在cd后自动追加ls的解决方案。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>查看了一下经常使用的电脑的输入指令统计：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1	740  33.3634%    ls</div><div class="line">2	372  16.7719%    cd</div><div class="line">3	273  12.3084%    git</div><div class="line">4	177  7.98016%    vim</div></pre></td></tr></table></figure></p>
<p>发现排在前两位的是ls和cd，而且每次cd以后必然会ls一次。所以何必不把这两个东西合在一起呢。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在环境变量的配置文件（.zshrc或者.bashrc）中加入一小段脚本即可:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">cdl</span></span>()</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> [ -n <span class="variable">$1</span> ] ; <span class="keyword">then</span></div><div class="line">		<span class="built_in">cd</span> <span class="variable">$1</span></div><div class="line">		ls</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="built_in">cd</span></div><div class="line">		ls</div><div class="line">	<span class="keyword">fi</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">alias</span> <span class="built_in">cd</span>=cdl</div></pre></td></tr></table></figure></p>
<p>这段脚本应该都看得懂吧。</p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Bandit 通关题解]]></title>
      <url>/2017/11/01/Bandit-%E9%80%9A%E5%85%B3%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>Bandit 是一个适合学习Linux指令的游戏吧，规则是每一关利用提供的hostname:port和上一关的password（第一关提供password）通过ssh进入到给定的环境中，按照题目要求拿到指定的Key作为下一关的password。挺好玩的，目前尚未通关，在此挖个坑</p>
<a id="more"></a>
<p>网址：<a href="http://overthewire.org/wargames/bandit/" target="_blank" rel="external">http://overthewire.org/wargames/bandit/</a></p>
<p>通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh bandit0@bandit.labs.overthewire.org -p 2220</div></pre></td></tr></table></figure></p>
<p>开玩吧！</p>
<h2 id="Level-0-→-Level-1"><a href="#Level-0-→-Level-1" class="headerlink" title="Level 0 → Level 1"></a>Level 0 → Level 1</h2><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat readme</div></pre></td></tr></table></figure>
<h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><p>boJ9jbbUNNfktd78OOpsqOltutMc3MY1</p>
<h2 id="Level-1-→-Level-2"><a href="#Level-1-→-Level-2" class="headerlink" title="Level 1 → Level 2"></a>Level 1 → Level 2</h2><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>在Linux中含有特殊字符的文件名可能和shell的一些语法向冲突，比如这一道题目中的“-”，shell就认定其之后的内容为参数。所以我们要通过./-表示文件来消除这种歧义。</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat ./-</div></pre></td></tr></table></figure>
<h3 id="Key-1"><a href="#Key-1" class="headerlink" title="Key"></a>Key</h3><p>CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9</p>
<h2 id="Level-2-→-Level-3"><a href="#Level-2-→-Level-3" class="headerlink" title="Level 2 → Level 3"></a>Level 2 → Level 3</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>文件名中含有空格可以用反斜杠+空格表示</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat spaces\ in\ this\ filename</div></pre></td></tr></table></figure>
<h3 id="Key-2"><a href="#Key-2" class="headerlink" title="Key"></a>Key</h3><p>UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK</p>
<h2 id="Level-3-→-Level-4"><a href="#Level-3-→-Level-4" class="headerlink" title="Level 3 → Level 4"></a>Level 3 → Level 4</h2><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat inhere/.inhere</div></pre></td></tr></table></figure>
<h3 id="Key-3"><a href="#Key-3" class="headerlink" title="Key"></a>Key</h3><p>pIwrPrtPN36QITSp3EQaw936yaFoFgAB</p>
<h2 id="Level-4-→-Level-5"><a href="#Level-4-→-Level-5" class="headerlink" title="Level 4 → Level 5"></a>Level 4 → Level 5</h2><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>通过file 列出文件属性来查看那些文件是ASCII编码（人类可读的）</p>
<h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">cd inhere/</div><div class="line">file ./*</div><div class="line"></div><div class="line">./-file00: data</div><div class="line">./-file01: data</div><div class="line">./-file02: data</div><div class="line">./-file03: data</div><div class="line">./-file04: data</div><div class="line">./-file05: data</div><div class="line">./-file06: data</div><div class="line">./-file07: ASCII text</div><div class="line">./-file08: data</div><div class="line">./-file09: data</div><div class="line"></div><div class="line">cat ./-file07</div></pre></td></tr></table></figure>
<h3 id="Key-4"><a href="#Key-4" class="headerlink" title="Key"></a>Key</h3><p>koReBOKuIDDepwhWk7jZC0RTdopnAYKh</p>
<h2 id="Level-5-→-Level-6"><a href="#Level-5-→-Level-6" class="headerlink" title="Level 5 → Level 6"></a>Level 5 → Level 6</h2><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>和上一题一样通过文件属性进行查找，用到find指令，只需要通过文件大小就能够确定文件位置了</p>
<h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cd inhere/</div><div class="line">find . -size 1033c</div><div class="line"></div><div class="line">./maybehere07/.file2</div><div class="line"></div><div class="line">cat ./maybehere07/.file2</div></pre></td></tr></table></figure>
<h3 id="Key-5"><a href="#Key-5" class="headerlink" title="Key"></a>Key</h3><p>DXjZPULLxYr17uwoI01bNLQbtFemEgo7</p>
<h2 id="Level-6-→-Level-7"><a href="#Level-6-→-Level-7" class="headerlink" title="Level 6 → Level 7"></a>Level 6 → Level 7</h2><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>考察使用find指令查找文件，用到了-user、-group、-size参数。同时使用 /dev/null 来过滤多余的错误信息</p>
<h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">find / -user bandit7 -group bandit6 -size 33c 2&gt;/dev/null</div><div class="line"></div><div class="line">cat /var/lib/dpkg/info/bandit7.password</div></pre></td></tr></table></figure>
<h3 id="Key-6"><a href="#Key-6" class="headerlink" title="Key"></a>Key</h3><p>HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs</p>
<h2 id="Level-7-→-Level-8"><a href="#Level-7-→-Level-8" class="headerlink" title="Level 7 → Level 8"></a>Level 7 → Level 8</h2><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>使用grep指令在文件中查找指定字符串</p>
<h3 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep millionth ./data.txt</div></pre></td></tr></table></figure>
<h3 id="Key-7"><a href="#Key-7" class="headerlink" title="Key"></a>Key</h3><p>cvX2JJa4CFALtqS87jk27qwqGhBM9plV</p>
<h2 id="Level-8-→-Level-9"><a href="#Level-8-→-Level-9" class="headerlink" title="Level 8 → Level 9"></a>Level 8 → Level 9</h2><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><p>uniq 指令能够找出文件中相邻的重复的或者不重复的行，key是所给的文件中只出现一次的行，所以要先进行排序，然后再用uniq找出不重复的行</p>
<h3 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sort data.txt | uniq -u</div></pre></td></tr></table></figure>
<h3 id="Key-8"><a href="#Key-8" class="headerlink" title="Key"></a>Key</h3><p>UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR</p>
<h2 id="Level-9-→-Level-10"><a href="#Level-9-→-Level-10" class="headerlink" title="Level 9 → Level 10"></a>Level 9 → Level 10</h2><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><p>strings 指令能够找出所给文件中可以打印的字符串，然后再使用grep查找key所在的位置</p>
<h3 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strings data.txt | grep ==</div></pre></td></tr></table></figure>
<h3 id="Key-9"><a href="#Key-9" class="headerlink" title="Key"></a>Key</h3><p>truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk</p>
<h2 id="Level-10-→-Level-11"><a href="#Level-10-→-Level-11" class="headerlink" title="Level 10 → Level 11"></a>Level 10 → Level 11</h2><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><p>使用base64指令对以base64编码的文本进行解码</p>
<h3 id="Code-10"><a href="#Code-10" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat data.txt | base64 --decode</div></pre></td></tr></table></figure>
<h3 id="Key-10"><a href="#Key-10" class="headerlink" title="Key"></a>Key</h3><p>IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR</p>
<h2 id="Level-11-→-Level-12"><a href="#Level-11-→-Level-12" class="headerlink" title="Level 11 → Level 12"></a>Level 11 → Level 12</h2><h3 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h3><p>所给的文本中的字符都被旋转了13个位置，所以我们使用tr命令将这些字符全部旋转回来</p>
<h3 id="Code-11"><a href="#Code-11" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat data.txt | tr &apos;A-Za-z&apos; &apos;N-ZA-Mn-za-m&apos;</div></pre></td></tr></table></figure>
<h3 id="Key-11"><a href="#Key-11" class="headerlink" title="Key"></a>Key</h3><p>5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu</p>
<h2 id="Level-12-→-Level-13"><a href="#Level-12-→-Level-13" class="headerlink" title="Level 12 → Level 13"></a>Level 12 → Level 13</h2><h3 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h3><p>所给的文件是一个经过多重压缩以后的二进制文件，首先使用xxd指令将二进制文件进行反转。然后不断使用file指令得到文件信息再调用相应的解压缩指令进行解压缩。其中用到的压缩指令有：gzip、bzip2、tar </p>
<h3 id="Code-12"><a href="#Code-12" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">xxd -r data.txt data2</div><div class="line">file data2</div><div class="line">data2: gzip compressed data, was &quot;data2.bin&quot;, from Unix, last modified: Thu Jun 6 13:59:44 2013, max compression</div><div class="line">mv data2 data.gz</div><div class="line">gzip -d data.gz</div><div class="line">file data</div><div class="line">data: bzip2 compressed data, block size = 900k</div><div class="line">bzip2 -d data</div><div class="line">bzip2: Can&apos;t guess original name for data -- using data.out</div><div class="line">file data.out</div><div class="line">data.out: gzip compressed data, was &quot;data4.bin&quot;, from Unix, last modified: Thu Jun 6 13:59:43 2013, max compression</div><div class="line">zcat data.out &gt; data3</div><div class="line">file data3</div><div class="line">data3: POSIX tar archive (GNU)</div><div class="line">tar -xvf data3</div><div class="line">data5.bin</div><div class="line">file data5.bin</div><div class="line">data5.bin: POSIX tar archive (GNU)</div><div class="line">tar -xvf data5.bin</div><div class="line">data6.bin</div><div class="line">file data6.bin</div><div class="line">bzip2 -d data6.bin</div><div class="line">bzip2: Can&apos;t guess original name for data6.bin -- using data6.bin.out</div><div class="line">file data6.bin.out</div><div class="line">data6.bin.out: POSIX tar archive (GNU)</div><div class="line">tar -xvf data6.bin.out</div><div class="line">data8.bin</div><div class="line">file data8.bin</div><div class="line">data8.bin: gzip compressed data, was &quot;data9.bin&quot;, from Unix, last modified: Thu Jun  6 13:59:43 2013, max compression</div><div class="line">zcat data8.bin &gt; data9.bin</div><div class="line">file data9.bin</div><div class="line">data9.bin: ASCII text</div><div class="line">cat data9.bin</div><div class="line">8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL</div></pre></td></tr></table></figure>
<h3 id="Key-12"><a href="#Key-12" class="headerlink" title="Key"></a>Key</h3><p>8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL</p>
<h2 id="Level-13-→-Level-14"><a href="#Level-13-→-Level-14" class="headerlink" title="Level 13 → Level 14"></a>Level 13 → Level 14</h2><h3 id="Solution-11"><a href="#Solution-11" class="headerlink" title="Solution"></a>Solution</h3><p>给出的是bandit14的私钥，要求使用这个私钥登录bandit14获取Key，这里用到了ssh -i 指令</p>
<h3 id="Code-13"><a href="#Code-13" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /etc/bandit_pass/bandit14</div><div class="line">ssh -i sshkey.private bandit14@localhost</div><div class="line">cat /etc/bandit_pass/bandit14</div></pre></td></tr></table></figure>
<h3 id="Key-13"><a href="#Key-13" class="headerlink" title="Key"></a>Key</h3><p>4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e</p>
<p>#Bandit Level 14 → Level 15</p>
<h3 id="Solution-12"><a href="#Solution-12" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Code-14"><a href="#Code-14" class="headerlink" title="Code"></a>Code</h3><h3 id="Key-14"><a href="#Key-14" class="headerlink" title="Key"></a>Key</h3>]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux中 ps 配合 kill 的操作]]></title>
      <url>/2017/10/25/Linux%E4%B8%AD-ps-%E9%85%8D%E5%90%88-kill-%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>有的时候我们想要关掉一些程序的一系列进程，又不想一个一个通过ps找到pid，再一个一个kill这些进程，这个时候用ps配合kill就是最好的选择了。</p>
<a id="more"></a>
<h2 id="使用到的命令"><a href="#使用到的命令" class="headerlink" title="使用到的命令"></a>使用到的命令</h2><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>ps(process status)命令用来列出系统中当前运行的那些进程。常常使用的形式有：</p>
<ul>
<li>ps aux 列出目前所有的正在内存当中的程序</li>
<li>ps -ef 显示所有进程信息，连同命令行<br><a href="http://www.cnblogs.com/peida/archive/2012/12/19/2824418.html" target="_blank" rel="external">更多参考</a>]</li>
</ul>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>kill 命令能够发送指定的信号到相应进程。</p>
<p>命令参数如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-l</td>
<td>信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称</td>
</tr>
<tr>
<td style="text-align:center">-a</td>
<td>当处理当前进程时，不限制命令名和进程号的对应关系</td>
</tr>
<tr>
<td style="text-align:center">-p</td>
<td>指定kill 命令只打印相关进程的进程号，而不发送任何信号</td>
</tr>
<tr>
<td style="text-align:center">-s</td>
<td>指定发送信号</td>
</tr>
<tr>
<td style="text-align:center">-u</td>
<td>指定用户</td>
</tr>
</tbody>
</table>
<p>使用参数-s 指定发送信号。如果要无条件终止进程，就要发送第九种信号SIGKILL。以下是常用的信号：</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>表示</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>HUP</td>
<td>1</td>
<td>终端断线</td>
</tr>
<tr>
<td>INT</td>
<td>2</td>
<td>中断（同 Ctrl + C）</td>
</tr>
<tr>
<td>QUIT</td>
<td>3</td>
<td>退出（同 Ctrl + \）</td>
</tr>
<tr>
<td>TERM</td>
<td>15</td>
<td>终止</td>
</tr>
<tr>
<td>KILL</td>
<td>9</td>
<td>强制终止</td>
</tr>
<tr>
<td>CONT</td>
<td>18</td>
<td>继续（与STOP相反， fg/bg命令）</td>
</tr>
<tr>
<td>STOP</td>
<td>19</td>
<td>暂停（同 Ctrl + Z）</td>
</tr>
</tbody>
</table>
<p><a href="http://www.cnblogs.com/peida/archive/2012/12/20/2825837.html" target="_blank" rel="external">更多参考</a></p>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>grep 是一种强大的文本搜索工具。grep 也是一个管道命令，接受standard output 作为查找的文本。不作为管道命令的时候后面接文件名作为参数。</p>
<h3 id="pgrep"><a href="#pgrep" class="headerlink" title="pgrep"></a>pgrep</h3><p>pgrep程序检查在系统的中活动进程，报告进程属性匹配命令行上指定条件的进程的ID。相当于命令 ps aux | grep XXX<br><a href="http://www.ha97.com/2523.html" target="_blank" rel="external">更多参考</a></p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -ef | grep chrome | grep -v grep | cut -c 10-14 | xargs kill -s 9</div></pre></td></tr></table></figure>
<ul>
<li>” grep chrome “输出所有含有关键字“chrome”的进程信息</li>
<li>” grep -v grep “ 除去含有关键字”grep“的进程信息，因为grep会产生一个进程里面含有 chrome 关键字</li>
<li>” cut -c 10-14 “ 截取输入行的第9个字符到第15个字符，而这正好是进程号PID</li>
<li>” xargs kill -s 9 “ 终止相关进程</li>
</ul>
<h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -ef | grep chrome | awk &apos;&#123;print $2&#125;&apos; | xargs kill -9</div></pre></td></tr></table></figure>
<ul>
<li>“awk ‘awk{ print $2 }’ “使用awk 代替cut ，不用一个一个数PID在什么位置</li>
</ul>
<h3 id="方案3"><a href="#方案3" class="headerlink" title="方案3"></a>方案3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pgrep chrome | xargs kill -s 9</div></pre></td></tr></table></figure>
<ul>
<li>” pgrep chrome “列出含有关键字”chrome“的相关进程</li>
<li>” xargs kill -s 9 “ 终止相关进程</li>
</ul>
<h3 id="方案4"><a href="#方案4" class="headerlink" title="方案4"></a>方案4</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">killall -9 chrome</div></pre></td></tr></table></figure>
<ul>
<li>终止进程名为chrome的进程，注意要给进程的全名</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[花莲之旅]]></title>
      <url>/2017/10/20/%E8%8A%B1%E8%8E%B2%E4%B9%8B%E6%97%85/</url>
      <content type="html"><![CDATA[<p>距离从花莲回来差不多有一个星期了，心态也逐渐调整过来了，现在也能够静下心来记录这一路的所见所想。花莲的确是一座非常美的城市，一座有故事的城市。<br><a id="more"></a></p>
<h2 id="行程规划"><a href="#行程规划" class="headerlink" title="行程规划"></a>行程规划</h2><p>我们行程是安排在台湾这边的联假（就是台湾这边的国庆），所以火车票和民宿都非常紧张。我们没有买到火车坐票，最后只能够采用买客运和铁路的联票到花莲（坐客运到罗东，再坐区间车到花莲）。车程还算比较长，总共四天假可能我们花在路上的时间就占了大半天吧。到花莲基本上是订民宿，这边的民宿做得口碑都比较好，大部分民宿都是来了以后都会推荐给朋友来的那种（事实证明我们住的民宿也是）。<br>我们大致的行程安排是第一天在花东纵谷线上玩鲤鱼潭和复兴糖厂，第二天清水断崖-太鲁阁-七星潭，第三天滑翔-几米公园，第四天兰阳博物馆+礁溪温泉公园。因为花莲这一带的景点都是分布在比较狭长的区域内，所以最好的交通工具就是包车出游。我们也是吃了这个亏，第一天下午在交通上面花了非常多的时间导致只玩了一个景点。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_WechatIMG13.jpeg" alt="enter description here" title="花连狭长的景点分布"></p>
<h2 id="鲤鱼潭"><a href="#鲤鱼潭" class="headerlink" title="鲤鱼潭"></a>鲤鱼潭</h2><p>从花莲火车站到鲤鱼潭大概二十多分钟的车程，我们去的时候天下着小雨，计程车行驶在盘旋的山路上别有一番意境。<br>“鲤鱼潭”的得名说法有二：一是因为侧边山岳形似鲤鱼，故山与湖同齐名为鲤鱼，有“鲤鱼山上有鲤鱼，鲤鱼潭里水中游。”俚语的称呼。另一种说法源于最早活动于此处的台湾原住民太鲁阁族，因为登至山顶往下看，潭的形状就像是一只刚捕获的鲤鱼在跳跃，所以以此名之。<br>鲤鱼潭周围的风光的确还不错，挺适合骑自行车慢慢玩的，但是天杀的我们去的那天下雨，没办法我们只能够等中间雨停的时候租条脚踏船玩完。<br>鲤鱼潭风光还是不错的，同行的一直在华北平原的小伙伴对这样的山还是蛮有好感的。但是对于我这种在雪峰山脉长大的孩子来说我还是觉得没有什么特色，不怎么推荐。<br>后面因为我们没有赶上公交车，多等了一个小时，到达复兴糖厂的时候差不多商家都打烊了，唯一一个能够玩的文物馆也已经关门了。不过在复兴糖厂吃到感觉有生以来最好吃的烤肠，烤肠里面有些许的酒味，还是挺满足的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_WechatIMG10.jpeg" alt="enter description here" title="鲤鱼潭"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_WechatIMG9.jpeg" alt="enter description here" title="鲤鱼潭潭面"></p>
<h2 id="超赞的民宿"><a href="#超赞的民宿" class="headerlink" title="超赞的民宿"></a>超赞的民宿</h2><p>在复兴糖厂完了一小会，我们就急忙赶到到复兴车站坐区间车去民宿了。其实之前对这个民宿有很大的期待的，因为介绍里说地址在海边而且有一间房是海景房。<br>来到民宿以后老板张阿姨很热情地接待我们，民宿老板之前是幼儿园的园长现在退休了。她给我们讲了他的民宿名字——花莲你来 的来历还有她同学为她的民宿写的歌。这个民宿其实是张阿姨为了能让她父亲更好地看海而建的，为了方便她父亲能够去顶楼看海还特别修建了电梯（整个房子只有7楼）。<br>进到房间以后感觉真的是超赞，装修非常精致，特别是阳台的装扮。整个阳台是面朝大海的，面积比较大，铺了草坪种了树，布置得很好。特别是阳台旁边的透明玻璃栏杆，刚看的时候给人的视觉冲击非常大。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_WechatIMG7.jpeg" alt="enter description here" title="从民宿看到的海边"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_WechatIMG8.jpeg" alt="enter description here" title="为民宿写的歌"></p>
<h2 id="清水断崖-太鲁阁-七星潭"><a href="#清水断崖-太鲁阁-七星潭" class="headerlink" title="清水断崖-太鲁阁-七星潭"></a>清水断崖-太鲁阁-七星潭</h2><p>第二天我们是包车前往太鲁阁那一片景点的，司机是一个叫阿靖的小伙，一路为我们讲解各个景点以及他们背后的故事。<br>清水断崖是来花莲必去的景点，台湾八景之一。一边是几近垂直、陡峭壁立的山壁，一遍是蓝蓝的大海，景色不要太美。不说了，上图吧。。。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_WechatIMG6.jpeg" alt="enter description here" title="清水断崖"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_WechatIMG5.jpeg" alt="enter description here" title="石头和狗"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_WechatIMG3.jpeg" alt="enter description here" title="太鲁阁"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_WechatIMG4.jpeg" alt="enter description here" title="七星潭的海-1"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_WechatIMG2.jpeg" alt="enter description here" title="七星潭的海-2"></p>
<p><img src="https://data2.liuin.cn/story-writer/2017_11_1_%E6%9C%80%E5%90%8E%E6%9D%A5%E4%B8%80%E5%BC%A0%E8%83%8C%E5%BD%B1.jpeg" alt="enter description here" title="最后来一张背影"></p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[十分九份一日游]]></title>
      <url>/2017/09/25/%E5%8D%81%E5%88%86%E4%B9%9D%E4%BB%BD%E4%B8%80%E6%97%A5%E6%B8%B8/</url>
      <content type="html"><![CDATA[<p>还记得《那些年，我们一起追的女孩》里面柯景腾和沈佳宜一起走铁道，放天灯的场景吗？那里面的场景就是在十分附近拍摄的，第二周我选择来这里浪，顺便拜访旁边传说《千与千寻》的取景地——九份</p>
<a id="more"></a>
<h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><p>我们大致的行程是从台北车站随便坐一辆区间车能够到瑞芳，然后转平溪线到十分。在十分玩完十分瀑布和十分老街之后，坐平溪线回到瑞芳，然后再坐公交车去九份。<br>这也是我第一次体验台湾的火车，感受到这边的铁路跟大陆那边还是一些不同的： 这边有一种区间车，运营就像国内的地铁（车内长得也像地铁）。买票的时候只要选择起点站和终点站，然后进站以后可以随便上一辆区间车到达目的地。普通车的站票也是这样。<br>顺便吐槽一句：铁路订票系统做得太烂了，页面UI差就算了，还查不了余票，必须要把所有的信息输进去验证以后才能够得到订票失败的提示。。。</p>
<p>车内长得像地铁的区间车：</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_25_QQ20170925-0.jpg" alt="enter description here"></p>
<h2 id="十分老街"><a href="#十分老街" class="headerlink" title="十分老街"></a>十分老街</h2><p>从十分车站出来以后就是十分老街了，整个十分老街是在火车铁轨两旁，算是有一点特色。两边的店铺主要经营的是小吃、纪念品还有天灯。旁边有个静安吊桥，也有许多人在那拍照。铁轨上许多人在放天灯，不过大多数都是韩国人日本人。</p>
<p>十分车站</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_25_QQ20170925-0-3.jpg" alt="enter description here"></p>
<p>放天灯的游客</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_25_QQ20170925-0-1.jpg" alt="enter description here"></p>
<h2 id="十分瀑布"><a href="#十分瀑布" class="headerlink" title="十分瀑布"></a>十分瀑布</h2><p>十分老街不是很长，如果不吃什么东西的话，一会就逛完了。走到老街的尽头就可以看到有很多租电动车的店铺，主要提供给去十分瀑布的游客。价格不算贵，一般是一个小时一百新台币。<br>我们两人小分队也租了一辆小电动，说实话骑着电动在山间穿梭还是蛮爽的，就是距离能够再长一点就好了。从老街到瀑布只用了十分钟左右。<br>十分瀑布景色还行，旁边有一道彩虹。</p>
<p>十分瀑布</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_25_QQ20170925-0-2.jpg" alt="enter description here"></p>
<h2 id="九份"><a href="#九份" class="headerlink" title="九份"></a>九份</h2><p>九份是一座坐落在台湾东北部的小城，三面环山，一面临海。整个小镇座落于山坡地上，也因此形成了独特的山坡和阶梯式建筑景观。早期因为开采金矿而闻名，后面慢慢没落。1990年代后，因电影《悲情城市》于九份取景，九份的独特旧式建筑、坡地及风情透过此片吸引国内外的注目，使得来九份的人越来越多。</p>
<p>依山而建的九份小城</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_25_QQ20170925-0-4.jpg" alt="enter description here"></p>
<p>阿妹茶楼</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_25_QQ20170925-0-5.jpg" alt="enter description here"></p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[打卡台北101]]></title>
      <url>/2017/09/17/%E6%89%93%E5%8D%A1%E5%8F%B0%E5%8C%97101/</url>
      <content type="html"><![CDATA[<p>台北101是台湾的第一高楼，也曾经有五年多的时间是世界第一高楼，旁边紧邻着台北市政府。现在是世界第十高楼（七年时间从第一变成第十），也是很多有名的跨国公司（比如说Google）的在台湾地区的办公地。</p>
<a id="more"></a>
<h2 id="交通与门票"><a href="#交通与门票" class="headerlink" title="交通与门票"></a>交通与门票</h2><p>台北101大楼位于台北市信义区，紧邻台北市政府大楼，是台北市的新地标。离101比较近的捷运站有市政府站和101站，坐捷运到这两个捷运站去101都可以。</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_17_1505628281374.jpg" alt="enter description here"></p>
<p>我的话因为是游玩完上一个景点才去的，远处看起来比较近，所以我和我的小伙伴就选择了脚踏车作为交通工具。因为101实在是太高了，看着不远，但是实际骑起来还真是有点距离的。</p>
<p>到达101脚下</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_17_QQ20170917-0.jpg" alt="到达101脚下"></p>
<p>上观景台参观的门票在5F卖，有两种：一种是全票600NTD；另外一种是优惠票540NTD，学生还有台湾地区的军警能够购买。我们买的是优惠票，使用支付宝支付，差不多花了120人民币。</p>
<h2 id="夕阳"><a href="#夕阳" class="headerlink" title="夕阳"></a>夕阳</h2><p>上面供游客玩的地方就三层：88F、89F和91F。88F展示的是全球第二大的开放游客观赏的巨型阻尼器；89F是一个环形的带玻璃的观景平台，还想着能够有那种伸出空中全是玻璃的刺激的地方，结果没有；91F是一个露天的观景平台，只不过只开放一小部分区域，还有特别高的栅栏。比较欣慰的是，栅栏的间隙不是很小，手可以伸出去拍照。</p>
<p>我们上去的时间是下午五点到五点半的场次，刚好是黄昏的时候，从观景平台俯瞰下面，有种玩天际线（模拟城市类的游戏）的既视感。感觉特别爽。</p>
<p>从101俯瞰台北</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_17_WechatIMG11.jpeg" alt="从101俯瞰台北"></p>
<p>101上的黄昏</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_17_WechatIMG12.jpeg" alt="101上的黄昏"></p>
<h2 id="夜景"><a href="#夜景" class="headerlink" title="夜景"></a>夜景</h2><p>本着不浪费这120门票的原则，我们硬是在上面待到了晚上。其实上面还是有很多东西可以逛的，纪念品商店有很多东西可以看看；有邮箱可以寄明信片。随便逛逛天就黑了。</p>
<p>晚上在101看到的又是另一番景色了，很赞。</p>
<p>俯瞰夜景（手机拍出来的效果实在是太差了，还是用同学的图吧）</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_17_WechatIMG2.jpeg" alt="enter description here"></p>
<h2 id="象山上看到的101"><a href="#象山上看到的101" class="headerlink" title="象山上看到的101"></a>象山上看到的101</h2><p>下来以后差不多是8点，感觉还早，就跑到旁边的象山区浪了，因为那里可以看到晚上的101外景。一开始一位晚上没什么人，结果上登山道的时候有点吃惊，原来这么多人都在晚上爬象山。</p>
<p>其实象山蛮大的，我们没有爬到山顶，只爬到了半山腰的一个摄影平台（一天奔波实在是有点累了）。</p>
<p>101外景（同学的图）</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_17_WechatIMG9.jpeg" alt="101外景"></p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[淡水 一日游]]></title>
      <url>/2017/09/11/%E6%B7%A1%E6%B0%B4-%E4%B8%80%E6%97%A5%E6%B8%B8/</url>
      <content type="html"><![CDATA[<p>淡水是台湾北部比较有名的一个景点，被称为<a href="https://zh.wikipedia.org/wiki/%E5%8F%B0%E7%81%A3%E5%85%AB%E6%99%AF" target="_blank" rel="external">台湾八景</a>。在历史上曾经是台湾第一大港，也是西方文明在台湾北部散播的起点。</p>
<a id="more"></a>
<h2 id="淡水老街"><a href="#淡水老街" class="headerlink" title="淡水老街"></a>淡水老街</h2><p>从淡水捷运站出来以后走不久就是淡水老街了，这里集美食、小吃、老街为一身，近年来更因不少古董店及民艺品店进驻，营造出更浓郁的民俗色彩与怀旧风味。邻近淡水捷运站，应该是游客到这里来必游的景点，人比较多。</p>
<p>在淡水老街上尝了一些小吃：鐵蛋、酸梅湯，鐵蛋很硬，酸梅汤很正宗</p>
<p>淡水街头</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_11_QQ20170911-0.jpg" alt=""></p>
<h2 id="阿给"><a href="#阿给" class="headerlink" title="阿给"></a>阿给</h2><p>阿给可以说是淡水最有名的小吃了。为什么叫“阿给”呢？其实它是日本语“油炸豆腐皮”的音译简称。阿给的做法是将油豆腐的中间挖空，然后填充炒过的冬粉（有些店家使用的是没有炒过的冬粉）、浸泡过卤汁，以鱼浆封口，加以蒸熟，食用前淋上甜辣酱或其他特殊酱汁。</p>
<p>我们逛到阿给的小吃店的时候刚好是中午午餐的时候，还是蛮好吃的，唯一不足的地方就是中午的气温有点高吃起来非常热。</p>
<p>网上的阿给图片</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_11_1024px-Agei.JPG" alt=""></p>
<h2 id="淡江中学"><a href="#淡江中学" class="headerlink" title="淡江中学"></a>淡江中学</h2><p>淡水中学中学是周杰伦还有前台湾地区领导人李登辉的母校，也因为周杰伦的《不能说的秘密》，而被众人所知（怪不得同行的女生听到淡水中学这么兴奋）。这所学校全名私立淡江高级中学，是台湾省比较著名的中学，已经有近100年的历史了。台湾这边公立的中学叫国民高中（国中），旁边的淡水国中就是的。门口贴着不允许参观的标志，但是可能是我们来的时候是周末，门卫放我们进去了。进去以后看到台湾这边的高三学生也补课（按理说他们读大学的压力比大陆小很多），看来高三逃脱不了补课的命运。</p>
<p>淡水中学历史比较久，所以里面的建筑还是很有特色的。</p>
<p>淡江高级中学埔顶钟声</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_11_QQ20170911-0-1.jpg" alt=""></p>
<h2 id="真理大学"><a href="#真理大学" class="headerlink" title="真理大学"></a>真理大学</h2><p>真理大学为北部台湾基督长老教会所创办之大学，是一所历史渊远的私立大学。以“追求真理、爱与服务”为校务发展宗旨。源自1872年3月9日加拿大基督长老教会宣教师马偕登陆淡水，选定现址（今真理大学淡水校区）兴建校舍以作传道、教育及医疗之用。</p>
<p>校园里面游客比较多，建筑比较有特色的就是旁边的大礼拜堂。校园风景非常优美，建筑物主要以红色为主。刚进去的时候能够看到许多的鸽子，它们不怎么怕游客，可能是习惯了吧。也有很多游客给一些事物给他们吃。</p>
<p>真理大学大门</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_11_QQ20170911-0-2.jpg" alt=""></p>
<h2 id="红毛城"><a href="#红毛城" class="headerlink" title="红毛城"></a>红毛城</h2><p>红毛城，西班牙人1692年建造，荷兰人打败西班牙人占领此城。为啥叫红毛城呢，以前咱管俄国人叫“老毛子、白毛”，称荷兰人为“红毛”，因此得名。里面的东西感觉也没什么特点就是一些那个时候办公用的东西。</p>
<p>不过这里要说的是台湾在景点上面对学生的优惠力度还是很大的，一般的景点只要你凭学生证就不要门票，在淡水两个景点要收费，小白宫和这个红毛城，一个地方80新台币，想想赚了160新台币心里还是美滋滋的。</p>
<p>红毛城照片</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_11_QQ20170911-0-3.jpg" alt=""></p>
<h2 id="渔人码头-情人桥"><a href="#渔人码头-情人桥" class="headerlink" title="渔人码头/情人桥"></a>渔人码头/情人桥</h2><p>淡水的最后一个景点就是渔人码头了，位于淡水河出海口右岸。《命中注定我爱你》陈欣怡和纪存希生日那天，纪存希陪陈欣怡买船回姜母岛吃姜军包，纪念品号停靠那个码头哦，就是渔人码头，后面就是情人桥。</p>
<p>传说情人桥暗藏“玄机”，恋人来此，如果没有走过情人桥，可能很快就会分手，如果只走过了奇数，而不是偶数，也会分手。由于那天太阳比较大，所以情人桥也没有待太久，不然真的会被热化的。</p>
<p>情人桥（同学的照片）：</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_11_QQ20170911-0-4.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>淡水还是一个景色优美，有好吃的好玩的，能看海的好去处。趁手里还在台湾而且有学生证，赶紧多玩几个景点。</p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[台湾，我来了]]></title>
      <url>/2017/09/07/%E5%8F%B0%E6%B9%BE%EF%BC%8C%E6%88%91%E6%9D%A5%E4%BA%86/</url>
      <content type="html"><![CDATA[<p>期待了许久，终于等到了去台湾的日子。9.5从上海出发，乘坐吉祥航空飞台北。正式开始我131天的台湾交换之旅。</p>
<a id="more"></a>
<h2 id="台湾初感受"><a href="#台湾初感受" class="headerlink" title="台湾初感受"></a>台湾初感受</h2><p>飞机刚降落，开了数据流量以后马上用Google 随便搜了点东西，直连谷歌，哈哈，肉身翻墙就是爽。<br>抵达桃园机场后，找到了台科大接机的同学把我们送到了台科大。然后我们就去找我们租房子的地方了，我们租房子的地方位于新北市，但是学校是在台北市，中间隔着一条河，坐公交应该是20分钟左右。看来在宣区从寝室到教室5分钟搞定的事情成了一种奢望。<br>在找租房子的地址的时候，感觉台湾各种小巷子太多了、红路灯太多了、机车太多了、便利店太多了。</p>
<p>从地图可以出道路基本上都是这种小巷子:</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_7_1504772211813.jpg" alt="从地图可以出道路基本上都是这种小巷子"></p>
<p>之前一直听说台湾这边的人非常热情，来到这里以后真的是深刻体会到了。在路上问路他们一定会说得非常详细，居委会的阿姨看到我们来了以后跟我们说了一大堆东西，这种感觉真好。</p>
<p>大陆和台湾的一些用词习惯是不一样的，比如我们的网络他们叫网路，计算机专业他们一般叫资讯工程。有几次去便利店买东西，店员听了我说的东西以后都是一脸懵逼，要我详细解释这个东西是用来干什么的，他们才清楚。看来还得慢慢适应。</p>
<h2 id="机车"><a href="#机车" class="headerlink" title="机车"></a>机车</h2><p>台湾这边的机车就是一般大陆说的摩托车，说真的这边的机车真的不要太多。过红绿灯的时候，机车引擎的声音那叫一个大呀，特别是在刚刚转绿灯的时候堪比赛车比赛开始的场面。</p>
<p>台湾的机车为什么这么多呢？原因应该是多方面的，人口多、道路窄是一个方面的原因。在台北，骑机车的大多是在市区周围上班族（就像我住的地方一样），把机车作为一种通勤工具，相比地铁公交的拥挤，开车要找车位开销大，骑机车成为了这些人的首选。当然还有一个更重要的原因就是台湾这边不禁摩，如果北上广深也不禁摩，可能机车的规模比台北还要多。</p>
<p>台湾街头的机车大军:</p>
<p><img src="https://data2.liuin.cn/story-writer/2017_9_7_1504773955984.jpg" alt="台湾街头的机车大军"></p>
<h2 id="next"><a href="#next" class="headerlink" title="next"></a>next</h2><p>接下来希望自己能够好好把握好台湾交换的时间，博客中的台湾游记系列也要定时进行更新。加油吧！</p>
]]></content>
      
        <categories>
            
            <category> 台湾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PyCharm 使用技巧汇总]]></title>
      <url>/2017/09/03/PyCharm-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<p>俗话说的好，磨刀不误砍柴工，写代码也一样，在工具上面花的时间是非常值得的。对于Python语言的编程而言，Pycharm是一个非常好用的集成开发环境，虽然Vim能够做到轻巧，但是功能始终是做不到IDE那么强大，所以对于Python代码的编程后期还是主要以Pycharm为工具，今天在这里收集一些Pycharm的使用技巧，有一些来源于网上，有一些也来源本身Pycharm的教程。（以下技巧适用于macOS系统）</p>
<a id="more"></a>
<h2 id="教程中的快捷键"><a href="#教程中的快捷键" class="headerlink" title="教程中的快捷键"></a>教程中的快捷键</h2><ul>
<li>“⇧⌘O ”能够快速查找相关文件和类</li>
<li>Command+B 跳转到原码，看到里面的类和方法</li>
<li>Command+Option+L  一键实现PEP8规范</li>
<li>Command + Shift + O  查找文件、类和方法</li>
<li>Command + Option + Shift + [     光标放在函数的前面快速选中这个函数中的所有内容</li>
<li>Command + J   快速插入常用代码</li>
<li>Command + Shift + -    展开收缩你的代码块</li>
<li>Command+P  显示当前函数需要的参数</li>
<li>F1     可以调出光标处函数文档</li>
</ul>
<h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><ul>
<li>能够在下面的状态栏中看到当前使用换行符情况（是”\r\n”  “\n”  还是”\r”），多选文件在File | Line Separators 中选择适当的换行符就可以切换了</li>
<li>在Preference -&gt; Editor -&gt; File and Code Template 中设置代码模板</li>
</ul>
<h2 id="分屏操作"><a href="#分屏操作" class="headerlink" title="分屏操作"></a>分屏操作</h2><p>鼠标放到当前导航处的文件名，然后右键 Split Vertically 或者 Split Horizontally 就可以啦<br><img src="https://data2.liuin.cn/story-writer/2017_11_28_11%E6%9C%88-28-2017%2003-26-43.gif" alt="enter description here" title="分屏操作"></p>
<h2 id="添加Vim插件"><a href="#添加Vim插件" class="headerlink" title="添加Vim插件"></a>添加Vim插件</h2><p>在偏好设置里面Plugins中添加新的Plugin插件，搜索IdeaVIm添加就可以了</p>
]]></content>
      
        <categories>
            
            <category> 软件使用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SQLAchemy 学习(2)]]></title>
      <url>/2017/08/30/SQLAchemy-%E5%AD%A6%E4%B9%A0-2/</url>
      <content type="html"><![CDATA[<p>接着上一篇SQLAlchemy学习<br><a id="more"></a></p>
<h2 id="relationship"><a href="#relationship" class="headerlink" title="relationship"></a>relationship</h2><p>relationship函数是sqlalchemy对关系之间提供的一种便利的调用方式, backref参数则对关系提供反向引用的声明<br>通过relationship我们可以轻松在实现嵌套将一个实例的属性转换成另一个类的实例。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_addresses_from_user</span><span class="params">(user_name)</span>:</span></div><div class="line">    user = session.query(User).filter_by(name=user_name).first()</div><div class="line">    <span class="keyword">return</span> user.addresses   <span class="comment">#返回的是Adresses的一个对象</span></div></pre></td></tr></table></figure></p>
<p>back_populates参数和backref参数功能类似，只是前者提供单向的关系引用，且必须成对存在，但是完成的功能和backref是一样的</p>
<h2 id="定义1-1-1-n-m-n-关系"><a href="#定义1-1-1-n-m-n-关系" class="headerlink" title="定义1:1 1:n m:n 关系"></a>定义1:1 1:n m:n 关系</h2><h3 id="1-n"><a href="#1-n" class="headerlink" title="1:n"></a>1:n</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'parent'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    children = relationship(<span class="string">"Child"</span>, back_populates=<span class="string">"parent"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'child'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    parent_id = Column(Integer, ForeignKey(<span class="string">'parent.id'</span>))</div><div class="line">    parent = relationship(<span class="string">"Parent"</span>, back_populates=<span class="string">"children"</span>)</div><div class="line">    <span class="comment"># 子表类中附加一个 relationship() 方法</span></div><div class="line">    <span class="comment"># 并且在(父)子表类的 relationship() 方法中使用 relationship.back_populates 参数</span></div></pre></td></tr></table></figure>
<h3 id="1-1"><a href="#1-1" class="headerlink" title="1:1"></a>1:1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'parent'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    child = relationship(<span class="string">"Child"</span>, uselist=<span class="keyword">False</span>, back_populates=<span class="string">"parent"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'child'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    parent_id = Column(Integer, ForeignKey(<span class="string">'parent.id'</span>))</div><div class="line">    parent = relationship(<span class="string">"Parent"</span>, back_populates=<span class="string">"child"</span>)</div></pre></td></tr></table></figure>
<p>和1:n的不同在于，在父表上用uselist参数进行了限定</p>
<h3 id="m-n"><a href="#m-n" class="headerlink" title="m:n"></a>m:n</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">association_table = Table(<span class="string">'association'</span>, Base.metadata,</div><div class="line">    Column(<span class="string">'left_id'</span>, Integer, ForeignKey(<span class="string">'left.id'</span>)),</div><div class="line">    Column(<span class="string">'right_id'</span>, Integer, ForeignKey(<span class="string">'right.id'</span>))</div><div class="line">)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'left'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    children = relationship(</div><div class="line">        <span class="string">"Child"</span>,</div><div class="line">        secondary=association_table,</div><div class="line">        back_populates=<span class="string">"parents"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'right'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    parents = relationship(</div><div class="line">        <span class="string">"Parent"</span>,</div><div class="line">        secondary=association_table,</div><div class="line">        back_populates=<span class="string">"children"</span>)</div></pre></td></tr></table></figure>
<h2 id="SQLAlchemy-数据表结构改变（数据迁移）方法"><a href="#SQLAlchemy-数据表结构改变（数据迁移）方法" class="headerlink" title="SQLAlchemy 数据表结构改变（数据迁移）方法"></a>SQLAlchemy 数据表结构改变（数据迁移）方法</h2><p>在使用Django的ORM的时候我们可以轻易地通过<strong>python manage.py makemigration </strong> 和 <strong> python manage.py migrate </strong>实现数据表结构的改变<br>但是在SQLAlchemy这个工具中似乎不支持数据迁移，所以在这里使用到一个另外一个库：SQLAlchemy-migrate<br>使用这个库我们可以分别写两个文件表示创建数据库的时候和修改数据库的时候：</p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> migrate.versioning <span class="keyword">import</span> api</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="keyword">from</span> model <span class="keyword">import</span> Base</div><div class="line"><span class="keyword">from</span> parse <span class="keyword">import</span> engine</div><div class="line"><span class="keyword">from</span> config <span class="keyword">import</span> *</div><div class="line"></div><div class="line">Base.metadata.create_all(bind=engine)</div><div class="line"></div><div class="line"><span class="comment"># 创建表结构</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> (os.path.exists(sqlachemy_migrate_repo)):</div><div class="line">    api.create(sqlachemy_migrate_repo,<span class="string">'database repository'</span>)</div><div class="line">    api.version_control(postgresql_url,sqlachemy_migrate_repo)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    api.version_control(postgresql_url,sqlachemy_migrate_repo)</div></pre></td></tr></table></figure>
<h3 id="修改数据表的结构"><a href="#修改数据表的结构" class="headerlink" title="修改数据表的结构"></a>修改数据表的结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> migrate.versioning <span class="keyword">import</span> api</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> imp</div><div class="line"></div><div class="line"><span class="keyword">from</span> model <span class="keyword">import</span> Base</div><div class="line"><span class="keyword">from</span> parse <span class="keyword">import</span> engine</div><div class="line"><span class="keyword">from</span> config <span class="keyword">import</span> *</div><div class="line"></div><div class="line">Base.metadata.create_all(bind=engine)</div><div class="line"></div><div class="line"><span class="comment"># 迁移表结构</span></div><div class="line">migration = sqlachemy_migrate_repo + <span class="string">'/versions/%03d_migration.py'</span> % (api.db_version(postgresql_url, sqlachemy_migrate_repo) + <span class="number">1</span>)</div><div class="line">tmp_module = imp.new_module(<span class="string">'old_model'</span>)</div><div class="line">old_model = api.create_model(postgresql_url, sqlachemy_migrate_repo)</div><div class="line">exec(old_model, tmp_module.__dict__)</div><div class="line">script = api.make_update_script_for_model(postgresql_url, sqlachemy_migrate_repo, tmp_module.meta, Base.metadata)</div><div class="line">open(migration, <span class="string">'wt'</span>).write(script)</div><div class="line">api.upgrade(postgresql_url, sqlachemy_migrate_repo)</div><div class="line"></div><div class="line">print(<span class="string">'New migration saved as '</span> + migration)</div><div class="line">print(<span class="string">'Current database version: '</span> + str(api.db_version(postgresql_url, sqlachemy_migrate_repo)))</div></pre></td></tr></table></figure>
<p>但是当修改的东西过多的时候，这个时候会报错</p>
<h2 id="Django-中get-or-create-方法的实现"><a href="#Django-中get-or-create-方法的实现" class="headerlink" title="Django 中get_or_create 方法的实现"></a>Django 中get_or_create 方法的实现</h2><p>和上面一样在SQLAlchemy中也不存在非常方便的get_or_create的方法，用的比较多的时候，应该有必要重新写一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_or_create</span><span class="params">(session, model, defaults=None, **kwargs)</span>:</span></div><div class="line">    instance = session.query(model).filter_by(**kwargs).first()</div><div class="line">    <span class="keyword">if</span> instance:</div><div class="line">        <span class="keyword">return</span> instance, <span class="keyword">False</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        params = dict((k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.iteritems() <span class="keyword">if</span> <span class="keyword">not</span> isinstance(v, ClauseElement))</div><div class="line">        params.update(defaults <span class="keyword">or</span> &#123;&#125;)</div><div class="line">        instance = model(**params)</div><div class="line">        session.add(instance)</div><div class="line">        <span class="keyword">return</span> instance, <span class="keyword">True</span></div></pre></td></tr></table></figure></p>
<p>参考：<a href="https://codeday.me/bug/20170612/24948.html" target="_blank" rel="external">https://codeday.me/bug/20170612/24948.html</a></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SQLAchemy 学习(1)]]></title>
      <url>/2017/08/17/SQLAchemy-%E5%AD%A6%E4%B9%A0-1/</url>
      <content type="html"><![CDATA[<p>SQLAchemy 是Python操纵数据库的一个常用的第三方ORM框架，我将通过几篇文章总结一下对SQLAlchemy的学习。</p>
<a id="more"></a>
<h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>ORM全称是Object-relational mapping，他将关系数据库中表中的记录映射成为对象，以对象的形式展现，程序员可以把对数据库的操作转化为对对象的操作。<br>它的作用是在关系型数据库和业务实体对象之间作一个映射，这样，我们在具体的操作业务对象的时候，就不需要再去和复杂的SQL语句打交道，只要像平时操作对象一样操作它就可以了。<br>因此ORM的目的是为了方便开发人员以面向对象的思想来实现对数据库的操作。</p>
<p>python中最流行的ORM库就是SQLAlchemy</p>
<h2 id="SQLAchemy-架构"><a href="#SQLAchemy-架构" class="headerlink" title="SQLAchemy 架构"></a>SQLAchemy 架构</h2><p>SQLAcheemy两个层次的关系图<br><img src="https://data2.liuin.cn/story-writer/2017_7_27_1501156105658.jpg" alt=""><br>SQLAchemy方言系统核心类的关系图<br><img src="https://data2.liuin.cn/story-writer/2017_7_27_1501156198516.jpg" alt=""></p>
<h2 id="Connecting"><a href="#Connecting" class="headerlink" title="Connecting"></a>Connecting</h2><p>通过create_engine()方法创建一个Engine对象实现连接：<code>engine = create_engine(&quot;mysql://scott:tiger@hostname/dbname&quot;,encoding=&#39;latin1&#39;, echo=True)</code><br>数据库URL的格式为：dialect[+driver]://user:password@host/dbname[?key=value..]，其中dialect为使用的数据库名字，driver为驱动器（比如说mysql的pymysql或者psycopg2）</p>
<h2 id="Declare-a-Mapping（声明映射）"><a href="#Declare-a-Mapping（声明映射）" class="headerlink" title="Declare a Mapping（声明映射）"></a>Declare a Mapping（声明映射）</h2><p>我们要定义关系类的时候要依据一个基类，这个基类是维系类和数据表关系的目录，我们使用<strong>declarative_base()</strong>函数创建基类，<br>如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Base = declarative_base()</div></pre></td></tr></table></figure></p>
<p>后面所有定义的映射的类将继承这个类进行创建</p>
<h2 id="Create-a-Schema（创建模式）"><a href="#Create-a-Schema（创建模式）" class="headerlink" title="Create a Schema（创建模式）"></a>Create a Schema（创建模式）</h2><p>我们可以通过定义映射类类来创建相关的模式（ORM的特点），比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'users'</span></div><div class="line">    id = Column(Integer, Sequence(<span class="string">'user_id_seq'</span>), primary_key=<span class="keyword">True</span>)</div><div class="line">    name = Column(String(<span class="number">50</span>))</div><div class="line">    fullname = Column(String(<span class="number">50</span>))</div><div class="line">    password = Column(String(<span class="number">12</span>))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"&lt;User(name='%s', fullname='%s', password='%s')&gt;"</span> % (</div><div class="line">                                self.name, self.fullname, self.password)</div></pre></td></tr></table></figure></p>
<h2 id="Create-an-Instance-of-the-Mapped-Class"><a href="#Create-an-Instance-of-the-Mapped-Class" class="headerlink" title="Create an Instance of the Mapped Class"></a>Create an Instance of the Mapped Class</h2><p>实例化一个映射类，同样也支持使用<strong><strong>init</strong>()</strong>方法进行构造<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>ed_user = User(name=<span class="string">'ed'</span>, fullname=<span class="string">'Ed Jones'</span>, password=<span class="string">'edspassword'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ed_user.name</div><div class="line"><span class="string">'ed'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ed_user.password</div><div class="line"><span class="string">'edspassword'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str(ed_user.id)</div><div class="line"><span class="string">'None'</span></div></pre></td></tr></table></figure></p>
<h2 id="Adding-and-Updating-Objects"><a href="#Adding-and-Updating-Objects" class="headerlink" title="Adding and Updating Objects"></a>Adding and Updating Objects</h2><p>通过Session和数据库进行对话，通过<strong>sessionmaker()</strong> 利用之前创建的Engine上创建一个会话类，每次进行修改的时候都要由这个类生成一个实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Session = sessionmaker(bind=engine)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>session = Session()</div></pre></td></tr></table></figure></p>
<p>我们对对象进行修改以后，通过创建的这个session实例对象来进行提交<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>ed_user = User(name=<span class="string">'ed'</span>, fullname=<span class="string">'Ed Jones'</span>, password=<span class="string">'edspassword'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>session.add(ed_user)</div></pre></td></tr></table></figure></p>
<h2 id="Querying"><a href="#Querying" class="headerlink" title="Querying"></a>Querying</h2><p>Query通过Session中的query()方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> instance <span class="keyword">in</span> session.query(User).order_by(User.id):</div><div class="line"><span class="meta">... </span>    print(instance.name, instance.fullname)</div><div class="line">ed Ed Jones</div><div class="line">wendy Wendy Williams</div><div class="line">mary Mary Contrary</div><div class="line">fred Fred Flinstone</div></pre></td></tr></table></figure></p>
<p>Query提供多种筛选filter操作，在数据库中的相关基本运算</p>
<h2 id="常用的一些方法"><a href="#常用的一些方法" class="headerlink" title="常用的一些方法"></a>常用的一些方法</h2><ul>
<li>Base.metadata.create_all(engine) 常用于正常使用的时候创建表，自动建立表结构。优点是省时；缺点是风险高，只有在内测环境且数据量已经备份的前提下方可使用。是一种修改表结构的方法，但是风险比较高。还可以使用其他的库（如openstack/sqlalchemy-migrate)</li>
</ul>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识Scrapy 爬虫框架]]></title>
      <url>/2017/08/08/%E5%88%9D%E8%AF%86Scrapy-%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<p>之前写的爬虫差不多都是用requests发出请求然后通过BeautifulSoup进行解析获取数据，最近接触到了一个python的爬虫框架Scrapy。前后者的区别有点组装机和品牌机之间的区别。</p>
<a id="more"></a>
<h2 id="为什么要爬虫框架"><a href="#为什么要爬虫框架" class="headerlink" title="为什么要爬虫框架"></a>为什么要爬虫框架</h2><ul>
<li>将精力更多放在提取数据上，很多其他的模块（比如下载模块）不需要自己写</li>
<li>使用异步模式，提高速度，不要自己去实现异步框架</li>
<li>使用已有的轮子，大量减少代码量</li>
</ul>
<h2 id="框架架构"><a href="#框架架构" class="headerlink" title="框架架构"></a>框架架构</h2><p><img src="http://ot40h275y.bkt.clouddn.com/story-writer/2017_7_25_1500991351462.jpg" alt="架构图"><br>Scrapy Engine: 这是引擎，负责Spiders、ItemPipeline、Downloader、Scheduler中间的通讯，信号、数据传递等等！</p>
<p>Scheduler(调度器): 它负责接受引擎发送过来的requests请求，并按照一定的方式进行整理排列，入队、并等待Scrapy Engine(引擎)来请求时，交给引擎</p>
<p>Downloader（下载器）：负责下载Scrapy Engine(引擎)发送的所有Requests请求，并将其获取到的Responses交还给Scrapy Engine(引擎)，由引擎交给Spiders来处理</p>
<p>Spiders：它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给引擎，再次进入Scheduler(调度器)，业务逻辑的主要部分</p>
<p>Item Pipeline：它负责处理Spiders中获取到的Item，并进行处理，比如去重，持久化存储（存数据库，写入文件，总之就是保存数据用的）</p>
<p>Downloader Middlewares（下载中间件）：你可以当作是一个可以自定义扩展下载功能的组件</p>
<p>Spider Middlewares（Spider中间件）：你可以理解为是一个可以自定扩展和操作引擎和Spiders中间‘通信‘的功能组件（比如进入Spiders的Responses;和从Spiders出去的Requests）</p>
<h2 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>通过以下命令创建一个tutorial项目<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy startproject tutorial</div></pre></td></tr></table></figure></p>
<p>运行以后，将产生一个tutorial文件夹，含有以下的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">tutorial/</div><div class="line">    scrapy.cfg            # deploy configuration file</div><div class="line"></div><div class="line">    tutorial/             # project&apos;s Python module, you&apos;ll import your code from here</div><div class="line">        __init__.py</div><div class="line"></div><div class="line">        items.py          # project items definition file</div><div class="line"></div><div class="line">        pipelines.py      # project pipelines file</div><div class="line"></div><div class="line">        settings.py       # project settings file</div><div class="line"></div><div class="line">        spiders/          # a directory where you&apos;ll later put your spiders</div><div class="line">            __init__.py</div></pre></td></tr></table></figure></p>
<h3 id="创建第一个Spider"><a href="#创建第一个Spider" class="headerlink" title="创建第一个Spider"></a>创建第一个Spider</h3><ul>
<li>通过一个继承scrapy.Spider的类实现主要的功能，名字通过name定义</li>
<li>定义一个start_requests函数（返回iterable of Requests），提供给Spider爬取的URL</li>
<li>以上的start_request有一个快捷方式：直接指出start_urls需要爬取的URL lists</li>
<li>response是通过下载器在所给的URL中下载的内容</li>
<li>定义一个parse 函数对响应（response）进行处理解析</li>
<li>通过response.urljoin方法找到下一个URL链接，通过response.follow 方法使用快捷方式直接发出新的请求</li>
<li>在parse方法中返回数据，或者在启动爬虫的时候加上参数，使得数据得到保存</li>
</ul>
<h3 id="Selectors"><a href="#Selectors" class="headerlink" title="Selectors"></a>Selectors</h3><p>取出response中的内容</p>
<ul>
<li>通过css方法找到指定的标签或者模块</li>
<li>extract()取出response中的内容</li>
<li>也可以使用xpath方法找到想要找的模块</li>
<li>通过scrapy shell + 网址 可以在shell中对response进行处理（常用于测试）</li>
</ul>
<h3 id="Item类"><a href="#Item类" class="headerlink" title="Item类"></a>Item类</h3><p>在Scrapy爬虫框架中，Item类的作用是帮助我们把爬取的数据结构化表示<br>向前承接爬虫爬取的数据，向后为后面的数据持久化做准备<br>在project目录下默认创建的item.py文件可能无法引入到我们的爬虫文件中来，我们可以将这个item.py文件移动到项目根目录下</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python实现进度条显示]]></title>
      <url>/2017/08/02/Python%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%98%BE%E7%A4%BA/</url>
      <content type="html"><![CDATA[<p>运行程序的时候，即不想看那些快速飘过的日志信息，又不想只让光标在那闪，怎么办呢？加个进度条吧</p>
<a id="more"></a>
<h2 id="tqdm"><a href="#tqdm" class="headerlink" title="tqdm"></a>tqdm</h2><p>tqdm是Python的一个进度条库，使用起来非常方便，上手十分容易</p>
<p><img src="http://ot40h275y.bkt.clouddn.com/story-writer/2017_7_31_1501480765636.jpg" alt="运行效果"></p>
<p>最简单的方式是使用tqdm包裹一个迭代器，迭代器现在所处的进度就是后面显示的进度。</p>
<h2 id="基于迭代的使用"><a href="#基于迭代的使用" class="headerlink" title="基于迭代的使用"></a>基于迭代的使用</h2><p>tqdm可以包裹任何迭代器，显示的进度就是当前迭代的进度<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">text = <span class="string">""</span></div><div class="line"><span class="keyword">for</span> char <span class="keyword">in</span> tqdm([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]):</div><div class="line">    text = text + char</div></pre></td></tr></table></figure></p>
<h2 id="手动操作"><a href="#手动操作" class="headerlink" title="手动操作"></a>手动操作</h2><p>通过with来控制tqdm()的更新：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> tqdm(total=<span class="number">100</span>) <span class="keyword">as</span> pbar:</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">        pbar.update(<span class="number">10</span>)</div></pre></td></tr></table></figure></p>
<p>或者不使用with，使用一个变量来表示，但是最后不要忘了撤销close()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pbar = tqdm(total=<span class="number">100</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    pbar.update(<span class="number">10</span>)</div><div class="line">pbar.close()</div></pre></td></tr></table></figure></p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>tqdm还可以使用在shell的管道命令中，在标准输入和标准输出中添加<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ time find . -name <span class="string">'*.py'</span> -exec cat \&#123;&#125; \; | wc <span class="_">-l</span></div><div class="line">857365</div><div class="line"></div><div class="line">real    0m3.458s</div><div class="line">user    0m0.274s</div><div class="line">sys     0m3.325s</div><div class="line"></div><div class="line">$ time find . -name <span class="string">'*.py'</span> -exec cat \&#123;&#125; \; | tqdm | wc <span class="_">-l</span></div><div class="line">857366it [00:03, 246471.31it/s]</div><div class="line">857365</div><div class="line"></div><div class="line">real    0m3.585s</div><div class="line">user    0m0.862s</div><div class="line">sys     0m3.358s</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux中查找目录下的文件是否含有某个字符串]]></title>
      <url>/2017/07/28/Linux%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%90%AB%E6%9C%89%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<p>在日常开发中，我们常常有这样的需求：想要在一个都是文本文件的文件夹中查找文件中含有某些字符串的文件。这篇文章给出了一种解决方案：通过find、xargs和grep三个命令实现。</p>
<a id="more"></a>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>查找目录下的所有文件中是否含有某个字符串”Ali”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find .|xargs grep -ri &quot;Ali&quot;</div></pre></td></tr></table></figure></p>
<p>查找目录下的所有文件中是否含有某个字符串,并且只打印出文件名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find .|xargs grep -ri &quot;Ali&quot; -l</div></pre></td></tr></table></figure></p>
<p>如果是在一个Git 项目中进行查找，可以使用git的grep命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git grep -n hello_world</div></pre></td></tr></table></figure></p>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find 是一个利用正则表达式查找当前目录下的文件及子目录中文件的命令，查找的根据可以是文件名，也可以是文件从属关系等等<br>同时结合-exec选项和其他命令结合使用<br>在这里find的作用是将查找范围定在当前的目录下的所有文本展现出来通过xargs 提供给grep 作为参数</p>
<p>参考：<a href="http://man.linuxde.net/find" target="_blank" rel="external">http://man.linuxde.net/find</a></p>
<h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>xargs 是一个给其他命令传递参数的一个过滤器，它擅长将标准输入数据转换成命令行参数，xargs能够处理管道或者stdin并将其转换成特定命令的命令参数。<br>在这里xargs 为后面的grep 提供查找的内容</p>
<p>参考：<a href="http://man.linuxde.net/xargs" target="_blank" rel="external">http://man.linuxde.net/xargs</a></p>
<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep 是一种强大的文本搜索工具。grep 也是一个管道命令，接受standard output 作为查找的文本。不作为管道命令的时候后面接文件名作为参数。<br>这里使用到了三个选项：-r 递归搜索   -i 忽略大小写   -l  仅显示文件名</p>
<p>参考：<a href="http://man.linuxde.net/grep" target="_blank" rel="external">http://man.linuxde.net/grep</a></p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 中的语言设置问题]]></title>
      <url>/2017/07/21/Linux-%E4%B8%AD%E7%9A%84%E8%AF%AD%E8%A8%80%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>语言问题是在Linux系统中经常遇到的问题，有的时候在使用数据库的时候，会出现编码不支持导致无法进行中文操作的情况。这篇文章是我在整理了一些Linux的编码相关的资料和查看了相关的博客以后，对Linux语言设置做的一个总结。</p>
<a id="more"></a>
<h2 id="locale-查看当前系统编码设置情况"><a href="#locale-查看当前系统编码设置情况" class="headerlink" title="locale 查看当前系统编码设置情况"></a>locale 查看当前系统编码设置情况</h2><p>使用locale命令以后，我们可以看到当前语言环境的一些配置，出现字段的含义分别是：<br>1、 语言符号及其分类(LC_CTYPE)<br>2、 数字(LC_NUMERIC)<br>3、 比较和排序习惯(LC_COLLATE)<br>4、 时间显示格式(LC_TIME)<br>5、 货币单位(LC_MONETARY)<br>6、 信息主要是提示信息,错误信息, 状态信息, 标题, 标签, 按钮和菜单等(LC_MESSAGES)<br>7、 姓名书写方式(LC_NAME)<br>8、 地址书写方式(LC_ADDRESS)<br>9、 电话号码书写方式(LC_TELEPHONE)<br>10、度量衡表达方式(LC_MEASUREMENT)<br>11、默认纸张尺寸大小(LC_PAPER)<br>12、对locale自身包含信息的概述(LC_IDENTIFICATION)。</p>
<p>设定locale就是设定12大类的locale分类属性，即 12个LC_*。除了这12个变量可以设定以外，为了简便起见，还有两个变量：LC_ALL和LANG。<br>它们之间有一个优先级的关系：LC<em>ALL &gt; LC\</em>* &gt; LANG<br>可以这么说，LC_ALL是最上级设定或者强制设定，而LANG是默认设定值。</p>
<p><strong>LANG和LANGUAGE的区别</strong>：<br>LANGUAGE是设置应用程序的界面语言。而LANG是优先级很低的一个变量，它指定所有与locale有关的变量的默认值</p>
<h2 id="安装相应的语言包"><a href="#安装相应的语言包" class="headerlink" title="安装相应的语言包"></a>安装相应的语言包</h2><p>有些系统一开始是不带有中文的语言包的，需要自己进行安装。<br>在Ubuntu系统中，安装中文语言包：<br><code>sudo apt-get install language-pack-zh-hans</code><br>再使用locale -a 查看是否有zh_CN.*这样的语言环境</p>
<h2 id="修改系统locale-设置"><a href="#修改系统locale-设置" class="headerlink" title="修改系统locale 设置"></a>修改系统locale 设置</h2><p>可以通过修改LC<em>ALL、LC\</em>*、LANG这三种变量的值来更改使用的语言（修改前，必须确定已经安装好相应的语言包，通过 <code>locale -a</code>命令进行查看已经安装的语言包）</p>
<ol>
<li>如果需要一个纯中文的系统的话，设定LC_ALL= zh_CN.XXXX，或者LANG=zh_CN.XXXX都可以</li>
<li>如果只想要一个可以输入中文的环境，而保持菜单、标题，系统信息等等为英文界面，那么只需要设定 LC_CTYPE＝zh_CN.XXXX，LANG=en_US.XXXX就可以</li>
</ol>
<p>具体方法：<br>在系统中修改 <strong>/etc/default/local</strong> 中的LANG和LANGUAGE(如果需要修改其他语言设置变量的值，列出即可) 的设置以后进行重启即可</p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Leetcode] Longest Substring Without Repeating Characters 题解]]></title>
      <url>/2017/07/15/Leetcode-Longest-Substring-Without-Repeating-Characters-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>题目链接:<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/#/description" target="_blank" rel="external">https://leetcode.com/problems/longest-substring-without-repeating-characters/#/description</a></p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个字符串，求出其中最长的不重复字符串的长度</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul>
<li>用一个数组记录每个字符出现的索引值，没有出现的为零</li>
<li>设定一个开始指针表示计算字符开始的地方（初始值为0），这样每次扫描到一个字符的时候，先更新这个指针。然后计算开始指针到扫描的地方的字符串长度更新结果值。</li>
<li>最后更新字符出现的索引值</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> a[<span class="number">256</span>];</div><div class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</div><div class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,num=<span class="number">0</span>,start=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.size();i++)</div><div class="line">        &#123;</div><div class="line">            start=start&gt;a[s[i<span class="number">-1</span>]]?start:a[s[i<span class="number">-1</span>]];</div><div class="line">            num=i-start;</div><div class="line">            ans=ans&gt;num?ans:num;</div><div class="line">            a[s[i<span class="number">-1</span>]]=i;</div><div class="line">        &#125;</div><div class="line">        ans=ans&gt;num?ans:num;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识 Git hook钩子]]></title>
      <url>/2017/06/12/%E5%88%9D%E8%AF%86-Git-hook%E9%92%A9%E5%AD%90/</url>
      <content type="html"><![CDATA[<p>之前使用git一直停留在比较浅的层面，最近涉及部署的相关东西的时候接触到了Git的hook，感觉这个东西非常有趣，下面总结一下我对Git中hook的认识以及分享一下我使用git的hook部署hexo博客到服务器上的过程。</p>
<a id="more"></a>
<h2 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Git钩子是仓库中特定事件发生时Git自动运行的普通脚本。每当我们创建一个仓库的时候，我们仓库的.git/hooks目录中有一些示例脚本。<br>这些脚本可以是任何脚本语言编写的，只要它们最后能编译到可执行文件。每次脚本中的#!/bin/sh定义了你的文件将被如何解释。</p>
<h3 id="pre-receive"><a href="#pre-receive" class="headerlink" title="pre-receive"></a>pre-receive</h3><p>git有非常多的本地钩子和服务端钩子，因为这次我使用的主要是pre-receive来部署博客，所以介绍一下pre-receive钩子,更多的钩子信息可以在文章最后的参考信息中查看<br>pre-receive钩子在有人用git push向仓库推送代码时被执行。它只存在于远端仓库中，而不是原来的仓库中。<br>所以我们可以用来在hexo提交更新的时候对服务器上的相关资源进行更新</p>
<h2 id="使用-Git-hook-自动部署-Hexo博客"><a href="#使用-Git-hook-自动部署-Hexo博客" class="headerlink" title="使用 Git hook 自动部署 Hexo博客"></a>使用 Git hook 自动部署 Hexo博客</h2><h3 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h3><p>首先我们要在服务器器创建一个管理内容的仓库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo mkdir /var/repo</div><div class="line"><span class="built_in">cd</span> /var/repo</div><div class="line">sudo git init --bare blog.git</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这里使用了 –bare 参数，是为了创建一个裸仓库，没有工作区。我们不会在裸仓库上进行操作，它只为共享而存在。<br>后面在hook的设置中会讲到工作区的设置</p>
</blockquote>
<h3 id="配置hook"><a href="#配置hook" class="headerlink" title="配置hook"></a>配置hook</h3><p>因为是在push操作时才发生的事件所以使用post-receive钩子，钩子将在git操作完以后运行<br>在blog.git/hooks 目录下新建一个post-receive文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /var/repo/blog.git/hooks</div><div class="line">vim post-reveive</div></pre></td></tr></table></figure></p>
<p>在post-receive中写入以下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line">git --work-tree=/var/www/hexo --git-dir=/var/repo/blog.git checkout <span class="_">-f</span></div></pre></td></tr></table></figure>
<p>注意，/var/www/hexo 要换成你自己的部署目录，一般可能都是 /var/www/html。上面那句 git 命令可以在我们每次 push 完之后，把部署目录更新到博客的最新生成状态。这样便可以完成达到自动部署的目的了。<br>同时加上可执行权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x post-receive</div></pre></td></tr></table></figure></p>
<h3 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h3><p>修改 hexo 目录下的 _config.yml 文件 ，使得hexo博客可以自动deploy到服务器上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  <span class="built_in">type</span>: git</div><div class="line">  repo: git@www.example.com:/var/repo/blog.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p>
<p>切换服务器地址和目录为你自己的服务器的地址和目录</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>此时你创建新的文章的时候就可以通过git hook来进行自动部署了，而不需要使用GitHub page的相关服务了</p>
<hr>
<p>参考：<br><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.4-Git%E9%92%A9%E5%AD%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81" target="_blank" rel="external">https://github.com/geeeeeeeeek/git-recipes/wiki/5.4-Git%E9%92%A9%E5%AD%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法模板总结——图论部分]]></title>
      <url>/2017/05/28/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%BA%E9%83%A8%E5%88%86/</url>
      <content type="html"><![CDATA[<p>为省赛整理的常用算法模板，图论部分</p>
<a id="more"></a>
<h2 id="最短路-Bellman-Ford-算法"><a href="#最短路-Bellman-Ford-算法" class="headerlink" title="最短路 Bellman-Ford 算法"></a>最短路 Bellman-Ford 算法</h2><p><a href="http://baike.baidu.com/link?url=b46lqwDdTXIvuJw756-BhMPvMdDYMTMp5EBz0oEhT6oQ944kEGCTKZFoQIoN2zrNIWHPz1WddKCoxAwFHmI-MilYJi2J4-DTQweDS1HsUFsw-c17KFmhcwone1VUo2aE" target="_blank" rel="external">松弛操作</a><br>从起始点开始对图中的每一条边进行一次松弛操作，重复这样的操作直到所有的点都达到最小的路径值</p>
<p>Bellman-Ford算法中判断是否有负圈</p>
<p>在上述算法中，最多更新V-1次就可以算出每一个结点的最短路径，如果更新超过V-1次，就说明有负圈</p>
<p>kuangbin模板：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> dist[MAXN];</div><div class="line"><span class="keyword">struct</span> Edge</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> u,v;</div><div class="line">    <span class="keyword">int</span> cost;</div><div class="line">    Edge(<span class="keyword">int</span> _u=<span class="number">0</span>,<span class="keyword">int</span> _v=<span class="number">0</span>,<span class="keyword">int</span> _cost=<span class="number">0</span>):u(_u),v(_v),cost(_cost)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">vector</span>&lt;Edge&gt;E;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bellman_ford</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> n)</span><span class="comment">//点的编号从1开始</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)dist[i]=INF;</div><div class="line">    dist[start]=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">//最多做n-1次</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;E.size();j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> u=E[j].u;</div><div class="line">            <span class="keyword">int</span> v=E[j].v;</div><div class="line">            <span class="keyword">int</span> cost=E[j].cost;</div><div class="line">            <span class="keyword">if</span>(dist[v]&gt;dist[u]+cost)</div><div class="line">            &#123;</div><div class="line">                dist[v]=dist[u]+cost;</div><div class="line">                flag=<span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!flag)<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//没有负环回路</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;E.size();j++)</div><div class="line">        <span class="keyword">if</span>(dist[E[j].v]&gt;dist[E[j].u]+E[j].cost)</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//有负环回路</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//没有负环回路</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="最短路-Dijkstra-算法"><a href="#最短路-Dijkstra-算法" class="headerlink" title="最短路 Dijkstra 算法"></a>最短路 Dijkstra 算法</h2><p>将结点分成两大类，一类已经确定最短路的，一类还没有确定最短路的。每次从没有确定最短路的结点集当中取出一个‘距离’已经确定最短路的结点集中最小的点，加入。<br>不能够处理负边的问题，遇到负边结果出错</p>
<h3 id="邻接矩阵表示"><a href="#邻接矩阵表示" class="headerlink" title="邻接矩阵表示"></a>邻接矩阵表示</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> cost[maxn][maxn];  <span class="comment">//邻接矩阵建图</span></div><div class="line"><span class="keyword">int</span> d[maxn];</div><div class="line"><span class="keyword">bool</span> used[maxn];  <span class="comment">//表示是否被收录</span></div><div class="line"><span class="keyword">int</span> V,E;</div><div class="line"></div><div class="line"><span class="comment">//建图</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">memset</span>(d,INF,<span class="keyword">sizeof</span>(d));</div><div class="line">	<span class="built_in">memset</span>(cost,INF,<span class="keyword">sizeof</span>(cost));    <span class="comment">//初始化邻接矩阵</span></div><div class="line">	<span class="keyword">int</span> u,v,w;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;E;i++)</div><div class="line">	&#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;w);</div><div class="line">        cost[u][v]=cost[v][u]=min(cost[v][u],w);  <span class="comment">//去重边操作</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></div><div class="line">&#123;</div><div class="line">    fill(d,d+V,INF);</div><div class="line">    fill(used,used+V,<span class="literal">false</span>);</div><div class="line">    d[s]=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> v=<span class="number">-1</span>;</div><div class="line">        <span class="comment">//从未被收录的点中找出一个距离最小的点</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;V;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(!used[j]&amp;&amp;(v==<span class="number">-1</span>||d[j]&lt;d[v]))v=j;  <span class="comment">//v==-1设置哨兵，确定有没有没被收录的点</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(v==<span class="number">-1</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        used[v]=<span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;i++)</div><div class="line">            d[i]=min(d[i],d[v]+cost[v][i]);  <span class="comment">//松弛操作</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度为O(V^2)</p>
<h3 id="邻接链表-未验证，慎用）"><a href="#邻接链表-未验证，慎用）" class="headerlink" title="邻接链表(未验证，慎用）"></a>邻接链表(未验证，慎用）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> <span class="keyword">struct</span> edge</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> to,cost;</div><div class="line">&#125;;    <span class="comment">//边属性</span></div><div class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p;    <span class="comment">//dist值扩展</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> V;</div><div class="line"><span class="built_in">vector</span>&lt;edge&gt; G[MAX_V];</div><div class="line"><span class="keyword">int</span> d[MAX_V];</div><div class="line"></div><div class="line"><span class="function">coid <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//使得堆从小到大取出值</span></div><div class="line">    priority_queue&lt;p,<span class="built_in">vector</span>&lt;p&gt;,greater&lt;p&gt; &gt; que;   </div><div class="line"></div><div class="line">    fill(d,d+V,INF);</div><div class="line">    d[s]=<span class="number">0</span>;</div><div class="line">    que.push(p(<span class="number">0</span>,s));</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(!que.empty())</div><div class="line">    &#123;</div><div class="line">        p tem=que.top();  <span class="comment">//取出dist最小的一条边</span></div><div class="line">        que.pop();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> v=tem.first;</div><div class="line">        <span class="keyword">if</span>(d[v]&lt;tem.second)<span class="keyword">continue</span>;  <span class="comment">//之前已经更新过了</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[v].size();i++)</div><div class="line">        &#123;</div><div class="line">            edge e=G[v][i];</div><div class="line">            <span class="keyword">if</span>(d[e.to]&gt;d[v]+e.cost)  <span class="comment">//松弛操作</span></div><div class="line">            &#123;</div><div class="line">                d[e.to]=d[v]+e.cost;</div><div class="line">                que.push(p(d[e.to],e.to));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>时间复杂度就变成了：O(ElogV)</p>
<hr>
<h3 id="最短路-SPFA算法"><a href="#最短路-SPFA算法" class="headerlink" title="最短路 SPFA算法"></a>最短路 SPFA算法</h3><h4 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h4><p>链式前向星是一种保存图的非常好用的方法，他实际上是一个边的集合，在这个集合的基础上利用head数组来记录每个点的第一条边的信息，添加边的时候是逆序添加的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//链式前向星建图</span></div><div class="line"><span class="keyword">struct</span> Node</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> v,w,next;</div><div class="line">&#125;edges[maxm];</div><div class="line"><span class="keyword">int</span> head[maxn]; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span>   <span class="comment">//u到v的权值为w的边</span></span></div><div class="line">&#123;</div><div class="line">	edges[id].v=v;</div><div class="line">	edges[id].w=w;</div><div class="line">	edges[id].next=head[u];    <span class="comment">//把之前的第一条边作为当前边的最后一条边</span></div><div class="line">	head[u]=id++;              <span class="comment">//id为从0开始的标号</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//建图</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</div><div class="line">	<span class="keyword">int</span> u,v,w;</div><div class="line">	id=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;w);</div><div class="line">		addedge(u,v,w);</div><div class="line">		addedge(v,u,w);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="SPFA-算法"><a href="#SPFA-算法" class="headerlink" title="SPFA 算法"></a>SPFA 算法</h4><p>SPFA算法实在Bellman-Ford算法的基础上加了一个队列优化，用来减少冗余的松弛操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> visit[maxn],dist[maxn];</div><div class="line"><span class="keyword">int</span> n,m,id;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> st)</span></span></div><div class="line">&#123;</div><div class="line">    fill(visit,visit+maxn,<span class="number">0</span>);   <span class="comment">//标记所有节点未被访问</span></div><div class="line">    fill(dist,dist+maxn,INF);   <span class="comment">//求最短路，初始化最大值</span></div><div class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</div><div class="line">    visit[st]=<span class="number">1</span>;</div><div class="line">    dist[st]=<span class="number">0</span>;</div><div class="line">    Q.push(st);</div><div class="line">    <span class="keyword">while</span> (!Q.empty())</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> now=Q.front();</div><div class="line">        Q.pop();</div><div class="line">        visit[now]=<span class="number">0</span>;           <span class="comment">//注意此处将该点标记为未访问</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i!=<span class="number">-1</span>;i=edges[i].next)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> v=edges[i].v;</div><div class="line">            <span class="keyword">int</span> w=edges[i].w;</div><div class="line">            <span class="keyword">if</span>(dist[v]&gt;dist[now]+w)   <span class="comment">//最短路松弛</span></div><div class="line">            &#123;</div><div class="line">                dist[v]=dist[now]+w;</div><div class="line">                <span class="keyword">if</span>(!visit[v])</div><div class="line">                &#123;</div><div class="line">                    Q.push(v);</div><div class="line">                    visit[v]=<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="判断负环用SPFA"><a href="#判断负环用SPFA" class="headerlink" title="判断负环用SPFA"></a>判断负环用SPFA</h4><p>kuangbinp判断负环SPFA：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1010</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</div><div class="line"><span class="keyword">struct</span> Edge</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> v;</div><div class="line">    <span class="keyword">int</span> cost;</div><div class="line">    Edge(<span class="keyword">int</span> _v=<span class="number">0</span>,<span class="keyword">int</span> _cost=<span class="number">0</span>):v(_v),cost(_cost)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">vector</span>&lt;Edge&gt;E[MAXN];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></div><div class="line">&#123;</div><div class="line">    E[u].push_back(Edge(v,w));</div><div class="line">&#125;</div><div class="line"><span class="keyword">bool</span> vis[MAXN];</div><div class="line"><span class="keyword">int</span> cnt[MAXN];</div><div class="line"><span class="keyword">int</span> dist[MAXN];</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)dist[i]=INF;</div><div class="line">    dist[start]=<span class="number">0</span>;</div><div class="line">    vis[start]=<span class="literal">true</span>;</div><div class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;que;</div><div class="line">    <span class="keyword">while</span>(!que.empty())que.pop();</div><div class="line">    que.push(start);</div><div class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</div><div class="line">    cnt[start]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(!que.empty())</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> u=que.front();</div><div class="line">        que.pop();</div><div class="line">        vis[u]=<span class="literal">false</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;E[u].size();i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> v=E[u][i].v;</div><div class="line">            <span class="keyword">if</span>(dist[v]&gt;dist[u]+E[u][i].cost)</div><div class="line">            &#123;</div><div class="line">                dist[v]=dist[u]+E[u][i].cost;</div><div class="line">                <span class="keyword">if</span>(!vis[v])</div><div class="line">                &#123;</div><div class="line">                    vis[v]=<span class="literal">true</span>;</div><div class="line">                    que.push(v);</div><div class="line">                    <span class="keyword">if</span>(++cnt[v]&gt;n)<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                    <span class="comment">//有负环回路</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="多源最短路-Floyd算法"><a href="#多源最短路-Floyd算法" class="headerlink" title="多源最短路 Floyd算法"></a>多源最短路 Floyd算法</h2><p>动态规划思想，不断考虑每一个结点，其状态转移方程为：</p>
<blockquote>
<p>map[i,j]:=min{map[i,k]+map[k,j],map[i,j]}；<br>map[i,j]表示i到j的最短距离，K是穷举i,j的断点，map[n,n]初值应该为0，或者按照题目意思来做。<br>当然，如果这条路没有通的话，还必须特殊处理，比如没有map[i,k]这条路。</p>
</blockquote>
<p>代码；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> d[MAX_V][MAX_V];</div><div class="line"><span class="keyword">int</span> V;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;V;k++)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;i++)</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;V;j++)</div><div class="line">            d[i][j]=max(d[i][j],d[i][k]+d[k][j]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="最小生成树问题"><a href="#最小生成树问题" class="headerlink" title="最小生成树问题"></a>最小生成树问题</h2><h3 id="从点出发的Prim算法"><a href="#从点出发的Prim算法" class="headerlink" title="从点出发的Prim算法"></a>从点出发的Prim算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> cost[maxn][maxn];</div><div class="line"><span class="keyword">int</span> dist[maxn];  <span class="comment">//到已经确定的点的最短距离</span></div><div class="line"><span class="keyword">bool</span> used[maxn];</div><div class="line"><span class="keyword">int</span> V;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    fill(dist,dist+V+<span class="number">1</span>,INF);  <span class="comment">//注意建图方式,不包括0</span></div><div class="line">    fill(used,used+V+<span class="number">1</span>,<span class="literal">false</span>);   <span class="comment">//注意建图方式</span></div><div class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;        <span class="comment">//注意建图方式</span></div><div class="line">    <span class="comment">//used[0]=true;     不在这里初始初始化</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span></div><div class="line"> res=<span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> v=<span class="number">-1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++) <span class="comment">//注意建图组织方式</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">//在这里对收录一号元素，因为要遍历一号元素的相邻结点</span></div><div class="line">            <span class="keyword">if</span>(!used[i]&amp;&amp;((v==<span class="number">-1</span>)||dist[i]&lt;dist[v]))v=i;   </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(v==<span class="number">-1</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        used[v]=<span class="literal">true</span>;</div><div class="line">        res+=dist[v];</div><div class="line">		<span class="comment">//cout&lt;&lt;v&lt;&lt;" "&lt;&lt;res&lt;&lt;endl;</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++)    <span class="comment">//注意建图方式</span></div><div class="line">            dist[i]=min(dist[i],cost[v][i]);  <span class="comment">//不判断是否相邻</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="从边出发的Kruskal算法"><a href="#从边出发的Kruskal算法" class="headerlink" title="从边出发的Kruskal算法"></a>从边出发的Kruskal算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> pre[maxn];</div><div class="line"><span class="keyword">int</span> n,m;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> edge</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> u,v,w;</div><div class="line">&#125;es[maxm];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">		pre[i]=i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(pre[x]==x) <span class="keyword">return</span> x;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="keyword">return</span> pre[x]=find(pre[x]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></div><div class="line">&#123;</div><div class="line">	x=find(x);</div><div class="line">	y=find(y);</div><div class="line">	<span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</div><div class="line">	pre[x]=y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> edge&amp; e1,<span class="keyword">const</span> edge &amp; e2)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> e1.w&lt;e2.w;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Krustral</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	sort(es,es+m,comp);    <span class="comment">//从小到大排序</span></div><div class="line">	init();</div><div class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">	&#123;</div><div class="line">		edge e=es[i];</div><div class="line">		<span class="keyword">if</span>(find(e.u)!=find(e.v))</div><div class="line">		&#123;</div><div class="line">			unite(e.u,e.v);</div><div class="line">			ret+=e.w;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>给出各个节点的先后顺序，输出一个拓扑序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> head[maxn],ip,indegree[maxn];   <span class="comment">//indegree为入度数组，ip为边计数变量 </span></div><div class="line"><span class="keyword">int</span> n,m,seq[maxn],k;  <span class="comment">//seq记录输出数组，k为数组中元素个数</span></div><div class="line"></div><div class="line"><span class="comment">//链式前向星建图  </span></div><div class="line"><span class="keyword">struct</span> note  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> v,next;  </div><div class="line">&#125; edge[maxn*maxn];  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));  </div><div class="line">    ip=<span class="number">0</span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span>  </span></div><div class="line">&#123;  </div><div class="line">    edge[ip].v=v,edge[ip].next=head[u],head[u]=ip++;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">topo</span><span class="params">()</span><span class="comment">///拓扑，可做模板  </span></span></div><div class="line">&#123;  </div><div class="line">    priority_queue&lt;<span class="keyword">int</span>&gt;q;         <span class="comment">//如果结果需要排序，则使用优先队列先进行排序</span></div><div class="line">    <span class="keyword">int</span> indeg[maxn];  </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)       <span class="comment">//注意是否包括0点</span></div><div class="line">    &#123;  </div><div class="line">        indeg[i]=indegree[i];  </div><div class="line">        <span class="keyword">if</span>(indeg[i]==<span class="number">0</span>)  </div><div class="line">            q.push(i);  </div><div class="line">    &#125;  </div><div class="line">    k=<span class="number">0</span>;  </div><div class="line">    <span class="keyword">bool</span> res=<span class="literal">false</span>;  </div><div class="line">    <span class="keyword">while</span>(!q.empty())        <span class="comment">//维护入度为0的数组</span></div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">if</span>(q.size()!=<span class="number">1</span>)res=<span class="literal">true</span>;  </div><div class="line">        <span class="keyword">int</span> u=q.top();  </div><div class="line">        q.pop();  </div><div class="line">        seq[k++]=u;  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i!=<span class="number">-1</span>; i=edge[i].next)  </div><div class="line">        &#123;  </div><div class="line">            <span class="keyword">int</span> v=edge[i].v;  </div><div class="line">            indeg[v]--;  </div><div class="line">            <span class="keyword">if</span>(indeg[v]==<span class="number">0</span>)  </div><div class="line">                q.push(v);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">if</span>(k&lt;n)<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">///存在有向环，总之不能进行拓扑排序  </span></div><div class="line">    <span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">///可以进行拓扑排序，并且只有唯一一种方式，seq数组即是排序完好的序列  </span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">///可以进行拓扑排序，有多种情况，seq数组是其中一种序列(排序好的)  </span></div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">//建图</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span>    <span class="comment">//写在主函数里面</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">memset</span>(indegree,<span class="number">0</span>,<span class="keyword">sizeof</span>(indegree));</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</div><div class="line">    <span class="keyword">int</span> _u,_v;</div><div class="line">    init();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;_u,&amp;_v);</div><div class="line">        indegree[_v]++;</div><div class="line">        addedge(_u,_v);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="最小树型图——朱刘算法"><a href="#最小树型图——朱刘算法" class="headerlink" title="最小树型图——朱刘算法"></a>最小树型图——朱刘算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> edge</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> u,v;</div><div class="line">    <span class="keyword">double</span>  w;</div><div class="line">    edge(<span class="keyword">int</span> uu,<span class="keyword">int</span> vv, <span class="keyword">double</span> ww):u(uu),v(vv),w(ww)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;edge&gt; g;</div><div class="line"></div><div class="line"><span class="keyword">int</span> id[maxn],pre[maxn],v[maxn];</div><div class="line"><span class="keyword">double</span> inw[maxn],ans;</div><div class="line"><span class="keyword">int</span> n,m;</div><div class="line"><span class="keyword">int</span> xx[maxn],yy[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">double</span> ret= <span class="built_in">sqrt</span>(<span class="keyword">double</span>((yy[b]-yy[a])*(yy[b]-yy[a])+(xx[b]-xx[a])*(xx[b]-xx[a])));</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> s)</span>      <span class="comment">//存在最小树型图时，返回TRUE，ans；不存在的时候，返回FALSE</span></span></div><div class="line">&#123;</div><div class="line">    ans=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            inw[i]=INF;</div><div class="line">            id[i]=<span class="number">-1</span>;</div><div class="line">            v[i]=<span class="number">-1</span>;</div><div class="line">            pre[i]=<span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//找到每个点的最小入边</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g.size();i++)</div><div class="line">            <span class="keyword">if</span>(g[i].w &lt;=inw[g[i].v] &amp;&amp; g[i].v!=g[i].u)</div><div class="line">            &#123;</div><div class="line">                inw[g[i].v]=g[i].w;</div><div class="line">                pre[g[i].v]=g[i].u;</div><div class="line">            &#125;</div><div class="line">        pre[s]=s;</div><div class="line">        inw[s]=<span class="number">0</span>;       <span class="comment">//根节点没有入边</span></div><div class="line">        <span class="comment">//计算总的权重和</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(inw[i]==INF)</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">//没有找到最小的入边的时候，返回错误</span></div><div class="line">            ans+=inw[i];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//判断有没有环</span></div><div class="line">        <span class="keyword">int</span> idx=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(v[i]==<span class="number">-1</span>)     <span class="comment">//v[]作用是判断有没有环</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> t=i;</div><div class="line">                <span class="keyword">while</span> (v[t]==<span class="number">-1</span>)</div><div class="line">                &#123;</div><div class="line">                    v[t]=i;</div><div class="line">                    t=pre[t];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(v[t]!=i || t==s)</div><div class="line">                    <span class="keyword">continue</span>;      <span class="comment">//没有环的时候</span></div><div class="line">                id[t]=idx++;      <span class="comment">//重构图中新的点</span></div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=pre[t];j!=t;j=pre[j])id[j]=idx<span class="number">-1</span>;     <span class="comment">//缩点操作，确定前后点的关系</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(idx==<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="comment">//为不在环中的点建立图之间点的关系</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">            <span class="keyword">if</span>(id[i]==<span class="number">-1</span>)id[i]=idx++;</div><div class="line">        <span class="comment">//重新构图,改变边连接的两个点的关系</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g.size();i++)</div><div class="line">        &#123;</div><div class="line">            g[i].w-=inw[g[i].v];</div><div class="line">            g[i].u=id[g[i].u];</div><div class="line">            g[i].v=id[g[i].v];</div><div class="line">        &#125;</div><div class="line">        n=idx<span class="number">-1</span>;</div><div class="line">        s=id[s];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="二分图的匹配问题（匈牙利算法）"><a href="#二分图的匹配问题（匈牙利算法）" class="headerlink" title="二分图的匹配问题（匈牙利算法）"></a>二分图的匹配问题（匈牙利算法）</h2><p>给出一个二分图，求出这个二分图的最大匹配数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* ************************************************************************** </span></div><div class="line">//二分图匹配（匈牙利算法的DFS实现） </div><div class="line">//初始化：g[][]两边顶点的划分情况 </div><div class="line">//建立g[i][j]表示i-&gt;j的有向边就可以了，是左边向右边的匹配 </div><div class="line">//g没有边相连则初始化为0 </div><div class="line">//L是匹配左边的顶点数，R是匹配右边的顶点数 </div><div class="line">//调用：res=hungary();输出最大匹配数 </div><div class="line">//优点：适用于稠密图，DFS找增广路，实现简洁易于理解 </div><div class="line">//时间复杂度:O(VE) </div><div class="line">// ***************************************************************************/  </div><div class="line"><span class="comment">//顶点编号从1开始的  </span></div><div class="line"><span class="keyword">int</span> LN,RN;<span class="comment">//L,R数目  </span></div><div class="line"><span class="keyword">int</span> g[maxn][maxn], linker[maxn];    <span class="comment">//所连得边直接从做到右</span></div><div class="line"><span class="keyword">bool</span> used[maxn];  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> L)</span><span class="comment">//从左边开始找增广路径  </span></span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> R;  </div><div class="line">    <span class="keyword">for</span>(R = <span class="number">1</span>; R &lt;= RN; R++)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">if</span>(g[L][R]!=<span class="number">0</span> &amp;&amp; !used[R])  </div><div class="line">        &#123;  </div><div class="line">            <span class="comment">//找增广路，反向  </span></div><div class="line">            used[R]=<span class="literal">true</span>;  </div><div class="line">            <span class="keyword">if</span>(linker[R] == <span class="number">-1</span> || dfs(linker[R]))  </div><div class="line">            &#123;  </div><div class="line">                linker[R]=L;  </div><div class="line">                <span class="keyword">return</span> <span class="number">1</span>;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//这个不要忘了，经常忘记这句  </span></div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span> ;  </div><div class="line">    <span class="keyword">int</span> L;  </div><div class="line">    <span class="built_in">memset</span>(linker,<span class="number">-1</span>,<span class="keyword">sizeof</span>(linker));  </div><div class="line">    <span class="keyword">for</span>( L = <span class="number">1</span>; L &lt;= LN; L++)  </div><div class="line">    &#123;  </div><div class="line">        <span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span>(used));  </div><div class="line">        <span class="keyword">if</span>(dfs(L) != <span class="number">0</span>)  </div><div class="line">            res++;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> res;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="二分图的完备匹配问题-（KM算法）"><a href="#二分图的完备匹配问题-（KM算法）" class="headerlink" title="二分图的完备匹配问题 （KM算法）"></a>二分图的完备匹配问题 （KM算法）</h2><p>如果二分图的每条边都有一个权（可以是负数），要求一种完备匹配方案，使得所有匹配边的权和最大，记做最佳完美匹配。（特殊的，当所有边的权为1时，就是最大完备匹配问题）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">iint nx,ny;  <span class="comment">//两边的点数</span></div><div class="line"><span class="keyword">int</span> g[maxn][maxn];   <span class="comment">//建图</span></div><div class="line"><span class="keyword">int</span> linker[maxn],lx[maxn],ly[maxn];     <span class="comment">//y中欧各个点的匹配状态,x y 中各个点的标号</span></div><div class="line"><span class="keyword">int</span> slack[maxn];        <span class="comment">//松弛量数组</span></div><div class="line"><span class="keyword">bool</span> visx[maxn],visy[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line">&#123;</div><div class="line">    visx[x]=<span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;ny;y++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(visy[y]) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">int</span> tmp=lx[x]+ly[y]-g[x][y];</div><div class="line">        <span class="keyword">if</span>(tmp==<span class="number">0</span>)    <span class="comment">//顶标符合要求，匈牙利算法寻找完备匹配</span></div><div class="line">        &#123;</div><div class="line">            visy[y]=<span class="literal">true</span>;</div><div class="line">            <span class="keyword">if</span>(linker[y]==<span class="number">-1</span> || dfs(linker[y]))</div><div class="line">            &#123;</div><div class="line">                linker[y]=x;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(slack[y]&gt;tmp)</div><div class="line">            slack[y] =tmp;        <span class="comment">//更新松弛量</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">KM</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">memset</span>(linker,<span class="number">-1</span>,<span class="keyword">sizeof</span>(linker));     <span class="comment">//初始化一开始匹配的点</span></div><div class="line">    <span class="built_in">memset</span>(ly,<span class="number">0</span>,<span class="keyword">sizeof</span>(ly));      <span class="comment">//y的顶标先全部变成0</span></div><div class="line">    <span class="comment">//初始化顶标</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nx;i++)</div><div class="line">    &#123;</div><div class="line">        lx[i]= -INF;            <span class="comment">//求最大值，首先初始化为最小值</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ny;j++)</div><div class="line">            <span class="keyword">if</span>(g[i][j]&gt;lx[i]) lx[i]=g[i][j];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;nx;x++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ny;i++)</div><div class="line">            slack[i]=INF;</div><div class="line">        <span class="comment">//算法核心部分</span></div><div class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">memset</span>(visx,<span class="literal">false</span>,<span class="keyword">sizeof</span>(visx));</div><div class="line">            <span class="built_in">memset</span>(visy,<span class="literal">false</span>,<span class="keyword">sizeof</span>(visy));</div><div class="line">            <span class="keyword">if</span>(dfs(x)) <span class="keyword">break</span>;        <span class="comment">//找到完备匹配，退出</span></div><div class="line">            <span class="comment">//没有找到完备匹配，在交错树中更改相关节点的顶标值</span></div><div class="line">            <span class="keyword">int</span> d= INF;</div><div class="line">            <span class="comment">//修改顶标，增加相等子图中的边</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ny;i++)</div><div class="line">                <span class="keyword">if</span>(!visy[i] &amp;&amp; d&gt;slack[i])</div><div class="line">                    d=slack[i];          <span class="comment">//求出最小一个slack值</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nx;i++)     <span class="comment">//在交错树中的x的节点减少d</span></div><div class="line">                <span class="keyword">if</span>(visx[i])</div><div class="line">                    lx[i]-=d;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ny;i++)        <span class="comment">//在交错树中的y的节点增加d</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(visy[i]) ly[i]+=d;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    slack[i] -=d;          <span class="comment">//x值减小，则相对的slack的值就会增大</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ny;i++)</div><div class="line">        <span class="keyword">if</span>(linker[i]!=<span class="number">-1</span>)</div><div class="line">            res+=g[linker[i]][i];</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="最大图问题"><a href="#最大图问题" class="headerlink" title="最大图问题"></a>最大图问题</h2><p>通俗来讲最大团问题就是在一个无向图中找出一个点数最多的完全图。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> G[maxn][maxn];</div><div class="line"><span class="keyword">int</span> Max[maxn],Alt[maxn][maxn],ans,n;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> tot)</span>     <span class="comment">//cur 当前层次集合大小  tot 所在的层次</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(cur==<span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(tot&gt;ans)</div><div class="line">		&#123;</div><div class="line">			ans=tot;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(cur-i+tot&lt;=ans) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">//剪枝1</span></div><div class="line">		<span class="keyword">int</span> u=Alt[tot][i];    <span class="comment">//选取当前考虑的点</span></div><div class="line">		<span class="keyword">if</span>(Max[u]+tot&lt;=ans) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> next=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;cur;j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(G[u][Alt[tot][j]])  Alt[tot+<span class="number">1</span>][next++]=Alt[tot][j];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(dfs(next,tot+<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>  <span class="title">MaxClique</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ans=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(Max,<span class="number">0</span>,<span class="keyword">sizeof</span>(Max));</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)    <span class="comment">//逆向构建Max</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> cur=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++) </div><div class="line">			<span class="keyword">if</span>(G[i][j]) Alt[<span class="number">1</span>][cur++]=j;</div><div class="line">		dfs(cur,<span class="number">1</span>);</div><div class="line">		Max[i]=ans;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="最大流问题"><a href="#最大流问题" class="headerlink" title="最大流问题"></a>最大流问题</h2><p>给定指定的一个有向图,其中有两个特殊的点源S(Sources)和汇T(Sinks),每条边有指定的容量(Capacity),求满足条件的从S到T的最大流(MaxFlow).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> G[SIZE_V][SIZE_V];</div><div class="line"><span class="keyword">int</span> prev[SIZE_V];  <span class="comment">//每个结点对应的前驱结点</span></div><div class="line"><span class="keyword">bool</span> visited[SIZE_V];</div><div class="line"><span class="keyword">int</span> V,E;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Augment</span><span class="params">()</span>  <span class="comment">//使用bfs一次找出一条增广路</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> v,i;</div><div class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</div><div class="line">    <span class="built_in">memset</span>(prev,<span class="number">0</span>,<span class="keyword">sizeof</span>(prev));</div><div class="line">    <span class="built_in">memset</span>(visited,<span class="number">0</span>,<span class="keyword">sizeof</span>(visited));</div><div class="line">    prev[<span class="number">1</span>]=<span class="number">0</span>;</div><div class="line">    visited[<span class="number">1</span>]=<span class="number">1</span>;</div><div class="line">    q.push(<span class="number">1</span>);</div><div class="line">    <span class="keyword">bool</span> bfindpath=<span class="number">0</span>; <span class="comment">//标识是否找到增广路</span></div><div class="line">    <span class="keyword">while</span>(!q.empty())</div><div class="line">    &#123;</div><div class="line">        v=q.front();</div><div class="line">        q.pop();</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=V;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(G[v][i]&gt;<span class="number">0</span>&amp;&amp;!visited[i]) <span class="comment">//边上依然有容量可以走</span></div><div class="line">            &#123;</div><div class="line">                prev[i]=v;</div><div class="line">                visited[i]=<span class="number">1</span>;</div><div class="line">                <span class="keyword">if</span>(i==V)  <span class="comment">//找到一条增广路</span></div><div class="line">                &#123;</div><div class="line">                    bfindpath=<span class="literal">true</span>;</div><div class="line">                    q=<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; ();  <span class="comment">//清空队列</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    q.push(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(!bfindpath)  <span class="comment">//没有找到增广路</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">//找出这条流的流量，即增广路上的最小边</span></div><div class="line">    <span class="keyword">int</span> minflow=INF;</div><div class="line">    v=V;</div><div class="line">    <span class="keyword">while</span>(prev[v])</div><div class="line">    &#123;</div><div class="line">        minflow=min(minflow,G[prev[v]][v]);    <span class="comment">//注意是正向流量</span></div><div class="line">        v=prev[v];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//改变流量，添加反向边</span></div><div class="line">    v=V;</div><div class="line">    <span class="keyword">while</span>(prev[v])</div><div class="line">    &#123;</div><div class="line">        G[prev[v]][v]-=minflow;</div><div class="line">        G[v][prev[v]]+=minflow;</div><div class="line">        v=prev[v];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> minflow;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> maxflow=<span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> aug;</div><div class="line"><span class="keyword">while</span>(aug=Augment())  <span class="comment">//不断寻找增广路，直到找不到为止</span></div><div class="line">    maxflow+=aug;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法模板 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法模板总结——DP部分]]></title>
      <url>/2017/05/25/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94DP%E9%83%A8%E5%88%86/</url>
      <content type="html"><![CDATA[<p>为省赛整理的常用算法模板，动态规划部分</p>
<a id="more"></a>
<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p><img src="https://data2.liuin.cn/2018-03-26-15220418620657.jpg" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> dp[MAX_W + <span class="number">1</span>];</div><div class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; ++i)</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=W; j&gt;=w[i]; --j) <span class="comment">// 注意逆序，保证前面的是未使用的 </span></div><div class="line">		dp[j] = max(dp[j], dp[j-w[i]]+v[i]);</div></pre></td></tr></table></figure>
<hr>
<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>N 种物品重量和价值和个数分别为 wi, vi, ni，从这些物品中挑出总重量不超过 W 的物品，求所有挑选方案中价值总和最大。<br>dp[i + 1][j] = max(dp[i][j − k × w[i]] + k × v[i]|0 ≤ k ≤ ni&amp;&amp;k × w[i] ≤ j)<br>相当于 ni 个 01 背包。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> dp[MAX_W + <span class="number">1</span>];</div><div class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; ++i)</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n[i]; ++j) <span class="comment">// n[i]个01背包 </span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=W; k&gt;=w[i]; --k)</div><div class="line">        	 dp[k] = max(dp[k], dp[k-w[i]]+v[i]);</div></pre></td></tr></table></figure>
<p>经过二进制优化后<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span> dp[MAX_W + <span class="number">1</span>];</div><div class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; ++i) &#123;</div><div class="line">	<span class="keyword">int</span> num = n[i];</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=num; j&lt;&lt;=<span class="number">1</span>) &#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=W; k&gt;=j*w[i]; --k)</div><div class="line">		dp[k] = max(dp[k], dp[k-j*w[i]]+j*v[i]);</div><div class="line">		num-=j;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(num)</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=W; k&gt;=num*w[i]; --k)</div><div class="line">			dp[k] = max(dp[k], dp[k-num*w[i]]+num*v[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>N 种物品重量和价值分别为 w i , v i ，每种物品无限个，从这些物品中挑出总重量不超过 W 的物品，求所有挑选方案中价值总和最大。</p>
<p><img src="https://data2.liuin.cn/2018-03-26-15220419119244.jpg" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span> dp[MAX_W + <span class="number">1</span>];</div><div class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; ++i)</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=w[i]; j&lt;=W; ++j) <span class="comment">// 正序</span></div><div class="line">		dp[j] = max(dp[j], dp[j-w[i]]+v[i]);</div></pre></td></tr></table></figure>
<hr>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p><img src="https://data2.liuin.cn/2018-03-26-15220419263598.jpg" alt=""></p>
<p>二维简单版：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> dp[maxn][maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCS</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span> </span>&#123;</div><div class="line">	<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length(); ++i)  <span class="comment">// a</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;b.length(); ++j) &#123; <span class="comment">// b</span></div><div class="line">			<span class="keyword">if</span>(a[i] == b[j])</div><div class="line">				dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</div><div class="line">			<span class="keyword">else</span></div><div class="line">				dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = max(dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j]);</div><div class="line">		&#125;</div><div class="line">	<span class="keyword">return</span> dp[a.length()][b.length()];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><p><img src="https://data2.liuin.cn/2018-03-26-15220419398472.jpg" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a[maxn], dp[maxn]; <span class="comment">// a为序列， dp[i]为以a[i]为结尾的最长上升子序列长度</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> Maxlis = <span class="number">0</span>; <span class="comment">// 最长上升子序列长度</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</div><div class="line">		dp[i] = <span class="number">1</span>; <span class="comment">// 记得初始化为1</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; ++j)</div><div class="line">			<span class="keyword">if</span>(a[i] &gt; a[j])</div><div class="line">				dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</div><div class="line">		Maxlis = max(Maxlis, dp[i]); <span class="comment">// 记得更新Maxlis</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> Maxlis;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优化后，O(nlog(n)) 算法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a[maxn], dp[maxn]; <span class="comment">// a为序列， dp[i]为以a[i]为结尾的最长上升子序列长度</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">	&#123;</div><div class="line">        *lower_bound(dp,dp+i,a[i])=a[i];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> lower_bound(dp,dp+n,INF)-dp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>其中：<br>upper_bound，表示使用二分查找返回排序好的数组中值&gt;k的最小的那个元素的指针<br>lower_bound，表示使用二分查找返回排序好的数组中值&gt;=k的第一个元素的指针</p>
</blockquote>
<hr>
<h2 id="多重部分和"><a href="#多重部分和" class="headerlink" title="多重部分和"></a>多重部分和</h2><p>问题描述：有 n 种大小不同的数字 ai，每种 mi 个，判断是否可以从这些数字中选出若干个使他们的和恰好为 K<br>设 dp[i+1][j] 为前 i 种数加和为 j 时第 i 种数最多能剩余多少个。（不能得到为-1）</p>
<p><img src="https://data2.liuin.cn/2018-03-26-15220419669135.jpg" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a[maxn],m[maxn],dp[maxm];    <span class="comment">//a表示数，m表示数的个数，dp范围是所有数的和的范围</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> K)</span> <span class="comment">//n表示数字种类,K表示组成的和</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</div><div class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;    <span class="comment">//根据存储方式作出改变</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=K; ++j) &#123;</div><div class="line">			<span class="keyword">if</span>(dp[j] &gt;= <span class="number">0</span>) dp[j] = m[i]; <span class="comment">// 前i-1个数已经能凑成j了</span></div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(j &lt; a[i] || dp[j-a[i]] &lt;= <span class="number">0</span>) dp[j] = <span class="number">-1</span>; <span class="comment">// 否则，凑不成j或者a[i]已经用完，则无法满足</span></div><div class="line">			<span class="keyword">else</span> dp[j] = dp[j-a[i]] - <span class="number">1</span>; <span class="comment">// 否则可以凑成</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> dp[K]&gt;=<span class="number">0</span>;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://blog.csdn.net/qq_22902423/article/details/48012633" target="_blank" rel="external">博客理解</a></p>
<hr>
<h2 id="多重集的组合数"><a href="#多重集的组合数" class="headerlink" title="多重集的组合数"></a>多重集的组合数</h2><p>问题描述：有 n 种物品，第 i 种有 ai 个。不同种类的物品可以相互区分但相同种类的物品无法区分。从这些物品中取出 m 个的话，有多少种取法。结果取 Mod。<br>设 dp[i + 1][j] 为从前 i 个物品取出 j 个的组合数</p>
<p><img src="https://data2.liuin.cn/2018-03-26-15220419814119.jpg" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a[maxn],dp[maxn][maxm];  <span class="comment">//dp[i+1][j]  表示从i种物品中取出j个的组合数</span></div><div class="line"><span class="keyword">int</span> T,B;   <span class="comment">//T表示种类数，B表示取得数目</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=T+<span class="number">1</span>; ++i) dp[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 一个都不取</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=T; ++i) &#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=B; ++j) &#123;</div><div class="line">			<span class="keyword">if</span>(j<span class="number">-1</span>-a[i] &gt;= <span class="number">0</span>)</div><div class="line">				dp[i+<span class="number">1</span>][j] = (dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + dp[i][j] - dp[i][j<span class="number">-1</span>-a[i]] + MOD) % MOD;</div><div class="line">			<span class="keyword">else</span></div><div class="line">				dp[i+<span class="number">1</span>][j] = (dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + dp[i][j]) % MOD;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://blog.csdn.net/viphong/article/details/48110525" target="_blank" rel="external">博客理解</a></p>
<hr>
<h2 id="划分数问题"><a href="#划分数问题" class="headerlink" title="划分数问题"></a>划分数问题</h2><p>有n个无区别的物体，将他们划分成m组，问有多少种划分方法：<br>定义dp[i][j]为i个物体进行j组划分的方法数，则有：</p>
<blockquote>
<p>dp[i][j]=dp[i-1][j]+dp[i][j-1]</p>
</blockquote>
<hr>
<h2 id="数位DP模板"><a href="#数位DP模板" class="headerlink" title="数位DP模板"></a>数位DP模板</h2><p>一般是求小于等于数字N的某些特征数字个数，或者是区间[L,R]的之间的某些特征数字个数，后者一般可以转换成求差的方式来做。</p>
<p>数字处理函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> ans;</div><div class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(num)&#123;</div><div class="line">        digit[++pos]=num%<span class="number">10</span>;</div><div class="line">        num=num/<span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dfs( pos, s , <span class="literal">true</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中：<br>digit为处理串的每个数位的数值。<br>s为初始的状态。<br>如果有其他限定条件，dfs中可以增加参数。</p>
<p>DFS函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> s,<span class="keyword">bool</span> jud)</span>  <span class="comment">//l表示当前处理的位置，s表示状态，jud表示是否是上界的前缀</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(l==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">//l是0还是-1取决于怎样存储数</span></div><div class="line">	<span class="keyword">if</span>(!jud &amp;&amp; dp[l][s]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[l][s];   <span class="comment">//排除上界的前缀情况</span></div><div class="line">	<span class="keyword">int</span> len=jud?digit[l]:<span class="number">9</span>;</div><div class="line">	ll ans=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len;i++)</div><div class="line">	&#123;</div><div class="line">		dosomething    <span class="comment">//表示其他处理条件,比如剔除不符合的部分数  if(i==9 &amp;&amp; fo)continue;</span></div><div class="line">		ans+=dfs(l<span class="number">-1</span>,new_s(s,d),jud &amp;&amp; i==len);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> jud ? ans : dp[l][s] = ans;   <span class="comment">//排除上界前缀和的情况</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中：<br>dp为记忆化数组；<br>l为当前处理串的第l位（权重表示法，也即后面剩下l+1位待填数）；<br>s为之前数字的状态（如果要求后面的数满足什么状态，也可以再记一个目标状态t之类，for的时候枚举下t）；<br>jud表示之前的数是否是上界的前缀（即后面的数能否任意填）。<br>for循环枚举数字时，要注意是否能枚举0，以及0对于状态的影响，有的题目前导0和中间的0是等价的，但有的不是，对于后者可以在dfs时再加一个状态变量z，表示前面是否全部是前导0，也可以看是否是首位，然后外面统计时候枚举一下位数。It depends.<br>于是关键就在怎么设计状态。当然做多了之后状态一眼就可以瞄出来。</p>
<p>前导零的判断：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int dfs(bool zero)</div><div class="line">......</div><div class="line">ans+=dfs(zero&amp;&amp;i==0)//不区分前导零与零</div><div class="line">ans+=dfs(zero&amp;&amp;i==0&amp;&amp;l&gt;1)//区分前导零与零</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法模板 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法模板总结——数学部分]]></title>
      <url>/2017/05/22/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6%E9%83%A8%E5%88%86/</url>
      <content type="html"><![CDATA[<p>为省赛整理的常用算法模板，数学部分</p>
<a id="more"></a>
<h2 id="0-20的阶乘"><a href="#0-20的阶乘" class="headerlink" title="0-20的阶乘"></a>0-20的阶乘</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> fac[<span class="number">21</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">120</span>,<span class="number">720</span>,<span class="number">5040</span>,<span class="number">40320</span>,<span class="number">362880</span>,</div><div class="line"><span class="number">3628800</span>,<span class="number">39916800</span>,<span class="number">479001600</span>,<span class="number">6227020800</span>,</div><div class="line"><span class="number">87178291200</span>,<span class="number">1307674368000</span>,<span class="number">20922789888000</span>,</div><div class="line"><span class="number">355687428096000</span>,<span class="number">6402373705728000</span>,<span class="number">121645100408832000</span>,</div><div class="line"><span class="number">2432902008176640000</span>&#125;;</div></pre></td></tr></table></figure>
<hr>
<h2 id="错排公式"><a href="#错排公式" class="headerlink" title="错排公式"></a>错排公式</h2><p>有n个元素组成的排列，若所有的元素都不在自己原来的位置上，这样的排列记为D(n)，有</p>
<blockquote>
<p>D(n)=(n-1)[D(n-1)+D(n-2)]<br>理解<a href="http://blog.csdn.net/liwen_7/article/details/7646451" target="_blank" rel="external">博客</a></p>
</blockquote>
<hr>
<h2 id="最小公倍数lcm-a-b-和最大公因数gcd-a-b"><a href="#最小公倍数lcm-a-b-和最大公因数gcd-a-b" class="headerlink" title="最小公倍数lcm(a,b)和最大公因数gcd(a,b)"></a>最小公倍数lcm(a,b)和最大公因数gcd(a,b)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> a*b/gcd(a,b);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="扩展欧几里得原理"><a href="#扩展欧几里得原理" class="headerlink" title="扩展欧几里得原理"></a>扩展欧几里得原理</h2><p>求解 ax + by = gcd(a; b) 这里得到的是一组 (x, y) 的可行解，(x + kb, y - ka) 为解集<br>如果是ax + by = d，这样的话得到的解就是 x0=x*(d/gcd(a,b) )  y0=y*(d/gcd(a,b) )<br>最后的解集就是：(x0 + k*(b/gcd(a,b) ), y0 - k*(a/gcd(a,b) ) )<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">e_gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> d=a;</div><div class="line">    <span class="keyword">if</span>(!b)</div><div class="line">    &#123;</div><div class="line">        x=<span class="number">1</span>;</div><div class="line">        y=<span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        d=e_gcd(b,a%b,y,x);</div><div class="line">        y-=(a/b)*x;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> d;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="快速幂取模算法"><a href="#快速幂取模算法" class="headerlink" title="快速幂取模算法"></a>快速幂取模算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">ll <span class="title">quick_mod</span><span class="params">(ll a,ll b,ll c)</span></span></div><div class="line">&#123;</div><div class="line">	ll ans=<span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(b&gt;<span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=(ans*a)%c;</div><div class="line">		a=(a*a)%c;</div><div class="line">		b&gt;&gt;=<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="高精度问题"><a href="#高精度问题" class="headerlink" title="高精度问题"></a>高精度问题</h2><p>充分利用整数的取值范围，每4位进行处理，减小时间复杂度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> BigInt</div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> nlen=<span class="number">4</span>;  <span class="comment">//控制数组中的每一个数字的长度，为了乘法运算不溢出设定为4</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> mod=<span class="number">10000</span>;    <span class="comment">//每个数字大小设定</span></div><div class="line">    <span class="keyword">short</span> n[<span class="number">1000</span>],len;  <span class="comment">//存放数字的数组以及数组的长度</span></div><div class="line">    BigInt()<span class="comment">//没有赋值时初始化为0</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">memset</span>(n,<span class="number">0</span>,<span class="keyword">sizeof</span>(n));</div><div class="line">        len=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    BigInt(<span class="keyword">int</span> num)<span class="comment">//数字为其赋值时，将数字4位4位存放在数组当中</span></div><div class="line">    &#123;</div><div class="line">        len=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            n[len++]=num%mod;</div><div class="line">            num/=mod;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    BigInt(<span class="keyword">const</span> <span class="keyword">char</span> *s)  <span class="comment">//字符串赋值时</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> l=<span class="built_in">strlen</span>(s);</div><div class="line">        len=l%nlen==<span class="number">0</span>?l/nlen:l/nlen+<span class="number">1</span>;<span class="comment">//确定数组长度</span></div><div class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-=nlen)<span class="comment">//每次处理数组中的一位</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> tmp=<span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> j=i-nlen+<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>(j&lt;<span class="number">0</span>) j=<span class="number">0</span>;<span class="comment">//最后面数字的处理</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;=i;k++)</div><div class="line">                tmp=tmp*<span class="number">10</span>+s[k]-<span class="string">'0'</span>;</div><div class="line">            n[index++]=tmp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    BigInt <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInt &amp;b)<span class="keyword">const</span> <span class="comment">//加法操作</span></div><div class="line">    &#123;</div><div class="line">        BigInt res;</div><div class="line">        res.len=max(len,b.len);  <span class="comment">//确定位数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++)</div><div class="line">        &#123;</div><div class="line">            res.n[i]+=(i&lt;len?n[i]:<span class="number">0</span>)+(i&lt;b.len?b.n[i]:<span class="number">0</span>); <span class="comment">//对象位置相加</span></div><div class="line">            res.n[i+<span class="number">1</span>]+=res.n[i]/mod; <span class="comment">//进位处理</span></div><div class="line">            res.n[i]=res.n[i]%mod;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(res.n[res.len]&gt;<span class="number">0</span>)res.len++;  <span class="comment">//最后的结果多出一位时</span></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    BigInt <span class="keyword">operator</span>*(<span class="keyword">const</span> BigInt &amp;b)<span class="keyword">const</span>  <span class="comment">//乘法操作</span></div><div class="line">    &#123;</div><div class="line">        BigInt res;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)  <span class="comment">//模拟过程</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> up=<span class="number">0</span>;  <span class="comment">//进位存储</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b.len;j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> tmp=n[i]*b.n[i]+up+res.n[i+j];</div><div class="line">                res.n[i+j]=tmp%mod;</div><div class="line">                up=tmp/mod;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(up!=<span class="number">0</span>)  <span class="comment">//处理一遍以后还有进位</span></div><div class="line">                res.n[i+b.len]=up;</div><div class="line">        &#125;</div><div class="line">        res.len=len+b.len;  <span class="comment">//先取到位数可能最大的值</span></div><div class="line">        <span class="keyword">while</span>(res.n[res.len<span class="number">-1</span>]==<span class="number">0</span>&amp;&amp;res.len&gt;<span class="number">1</span>)res.len--;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span>  <span class="comment">//输出时的逆序输出</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,n[len<span class="number">-1</span>]);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%04d"</span>,n[i]);   <span class="comment">//注意一定要加04,确保输出四位</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<hr>
<h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><h3 id="埃式筛选法"><a href="#埃式筛选法" class="headerlink" title="埃式筛选法"></a>埃式筛选法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> is_prime[MAXSIZE];</div><div class="line"><span class="keyword">int</span> prime[MAXSIZE]; <span class="comment">//收集素数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</div><div class="line">    <span class="built_in">memset</span>(is_prime,<span class="number">0</span>,<span class="keyword">sizeof</span>(is_prime));</div><div class="line">    is_prime[<span class="number">0</span>]=is_prime[<span class="number">1</span>]=<span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(is_prime[i])</div><div class="line">        &#123;</div><div class="line">            prime[p++]=i;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;n;j+=i)</div><div class="line">                is_prime[j]=<span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="欧拉筛法"><a href="#欧拉筛法" class="headerlink" title="欧拉筛法"></a>欧拉筛法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> prime[maxn];</div><div class="line"><span class="keyword">bool</span> is_prime[maxn];</div><div class="line"><span class="keyword">int</span> num;    <span class="comment">//表示素数个数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	num=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(is_prime,<span class="literal">true</span>,<span class="keyword">sizeof</span>(is_prime));</div><div class="line">	is_prime[<span class="number">0</span>]=is_prime[<span class="number">1</span>]=<span class="literal">false</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAX;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(is_prime[i])prime[num++]=i;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num &amp;&amp; i*prime[j]&lt;MAX;j++)</div><div class="line">		&#123;</div><div class="line">			is_prime[i*prime[j]]=<span class="literal">false</span>;</div><div class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;  <span class="comment">//保证每一个合数都被他的最小质因数排除</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="区间筛法"><a href="#区间筛法" class="headerlink" title="区间筛法"></a>区间筛法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> is_prime[maxp];</div><div class="line"><span class="keyword">int</span> prime[maxp],num;</div><div class="line"><span class="keyword">bool</span> is_prime2[maxn];    <span class="comment">//大区间内的素数集合</span></div><div class="line">ll prime2[maxn],num2;   <span class="comment">//大区间内的素数集合</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime_init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	num=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(is_prime,<span class="literal">true</span>,<span class="keyword">sizeof</span>(is_prime));</div><div class="line">	is_prime[<span class="number">0</span>]=is_prime[<span class="number">1</span>]=<span class="literal">false</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxp;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(is_prime[i]) prime[num++]=i;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num &amp;&amp; i*prime[j]&lt;maxp;j++)</div><div class="line">		&#123;</div><div class="line">			is_prime[i*prime[j]]=<span class="literal">false</span>;</div><div class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bigger_prime</span><span class="params">(ll L,ll R)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">memset</span>(is_prime2,<span class="number">1</span>,<span class="keyword">sizeof</span>(is_prime2));</div><div class="line">    ll mul;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num &amp;&amp; prime[i]&lt;=R;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(prime[i]&lt;=L)</div><div class="line">            mul=(L-prime[i])/prime[i];           <span class="comment">//获得相差的倍数</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            mul=<span class="number">2</span>;</div><div class="line">		<span class="keyword">while</span>(mul*prime[i]&lt;L || mul&lt;=<span class="number">1</span>) mul++;     <span class="comment">//修正倍数值,不能够等于一</span></div><div class="line">		<span class="keyword">for</span>(ll j=mul*prime[i];j&lt;=R;j+=prime[i])</div><div class="line">			<span class="keyword">if</span>(j&gt;=L)</div><div class="line">                is_prime2[j-L]=<span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">    num2=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=R-L;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(is_prime2[i])</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i+L==<span class="number">1</span>) <span class="keyword">continue</span>;   <span class="comment">//注意要排除1这个不是素数的数</span></div><div class="line">            prime2[num2++]=i+L;</div><div class="line">        &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="大素数判断和分解（Miller-Rabin素数测试和Pollard-Rho-大整数分解）"><a href="#大素数判断和分解（Miller-Rabin素数测试和Pollard-Rho-大整数分解）" class="headerlink" title="大素数判断和分解（Miller-Rabin素数测试和Pollard Rho 大整数分解）"></a>大素数判断和分解（Miller-Rabin素数测试和Pollard Rho 大整数分解）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Miller_Rabin 算法进行素数测试</span></div><div class="line"><span class="comment">//速度快，而且可以判断 &lt;2^63的数</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> S=<span class="number">20</span>; <span class="comment">//随机算法判定次数</span></div><div class="line"></div><div class="line"><span class="comment">//计算 (a*b)%c  加法快速幂</span></div><div class="line"><span class="function">ll <span class="title">mul_mod</span><span class="params">(ll a,ll b,ll c)</span></span></div><div class="line">&#123;</div><div class="line">	a%=c;</div><div class="line">	b%=c;</div><div class="line">	ll ret=<span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(b)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)</div><div class="line">			ret+=a,ret%=c;</div><div class="line">		a&lt;&lt;=<span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span>(a&gt;=c)a%=c;</div><div class="line">		b&gt;&gt;=<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 计算x^n %c</span></div><div class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll x,ll n,ll mod)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> x%mod;</div><div class="line">	x%=mod;</div><div class="line">	ll tmp=x;</div><div class="line">	ll ret=<span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(n)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) ret=mul_mod(ret,tmp,mod);</div><div class="line">		tmp=mul_mod(tmp,tmp,mod);</div><div class="line">		n&gt;&gt;=<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//以a为基,n-1=x*2^t      a^(n-1)=1(mod n)  验证n是不是合数</span></div><div class="line"><span class="comment">//一定是合数返回true,不一定返回false</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll a,ll n,ll x,ll t)</span></span></div><div class="line">&#123;</div><div class="line">	ll ret=pow_mod(a,x,n);</div><div class="line">	ll last=ret;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</div><div class="line">	&#123;</div><div class="line">		ret=mul_mod(ret,ret,n);</div><div class="line">		<span class="keyword">if</span>(ret==<span class="number">1</span> &amp;&amp; last!=<span class="number">1</span> &amp;&amp; last!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		last=ret;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(ret!=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Miller_Rabin()算法素数判定</span></div><div class="line"><span class="comment">//是素数返回true.(可能是伪素数，但概率极小)</span></div><div class="line"><span class="comment">//合数返回false;</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(ll n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//偶数</span></div><div class="line">	ll x=n<span class="number">-1</span>,t=<span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(!(x&amp;<span class="number">1</span>)) </div><div class="line">	&#123;</div><div class="line">		x&gt;&gt;=<span class="number">1</span>;</div><div class="line">		t++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S;i++)</div><div class="line">	&#123;</div><div class="line">		ll a=rand()%(n<span class="number">-1</span>)+<span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span>(check(a,n,x,t))</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// pollard_rho 算法进行质因数分解</span></div><div class="line">ll factor[<span class="number">100</span>];   <span class="comment">//分解结果</span></div><div class="line"><span class="keyword">int</span> tol;    <span class="comment">//分解个数</span></div><div class="line"></div><div class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(a==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span>(a&lt;<span class="number">0</span>) <span class="keyword">return</span> gcd(-a,b);</div><div class="line">	<span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">Pollard_rho</span><span class="params">(ll x,ll c)</span></span></div><div class="line">&#123;</div><div class="line">	ll i=<span class="number">1</span>,k=<span class="number">2</span>;</div><div class="line">	ll x0=rand()%x;</div><div class="line">	ll y=x0;</div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		i++;</div><div class="line">        x0=(mul_mod(x0,x0,x)+c)%x;</div><div class="line">        ll d=gcd(y-x0,x);</div><div class="line">        <span class="keyword">if</span>(d!=<span class="number">1</span>&amp;&amp;d!=x) <span class="keyword">return</span> d;</div><div class="line">        <span class="keyword">if</span>(y==x0) <span class="keyword">return</span> x;</div><div class="line">        <span class="keyword">if</span>(i==k)&#123;y=x0;k+=k;&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//对n进行素因子分解</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">findfac</span><span class="params">(ll n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(Miller_Rabin(n))</div><div class="line">	&#123;</div><div class="line">		factor[tol++]=n;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	ll p=n;</div><div class="line">    <span class="keyword">while</span>(p&gt;=n)p=Pollard_rho(p,rand()%(n<span class="number">-1</span>)+<span class="number">1</span>);</div><div class="line">    findfac(p);</div><div class="line">    findfac(n/p);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="素性测试"><a href="#素性测试" class="headerlink" title="素性测试"></a>素性测试</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; divisor(<span class="keyword">int</span> n)  <span class="comment">//枚举约数及其个数</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            res.push_back(i);</div><div class="line">            <span class="keyword">if</span>(n/i!=i)res.push_back(n/i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; prime_factor(<span class="keyword">int</span> n)   <span class="comment">//整数分解</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; res;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(n%i==<span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            res[i]++;</div><div class="line">            n/=i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(n!=<span class="number">0</span>)res[n]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="求一个数的因子个数"><a href="#求一个数的因子个数" class="headerlink" title="求一个数的因子个数"></a>求一个数的因子个数</h2><p>原理：<br>若一个整型数能够分解质因数<code>!$ M=p_1^{X_1}*p_2^{X_2}*...*p_n^{X_n} $</code><br>则这个数的因子个数为 <code>!$ W=(x_1+1)(x_2+1)...(x_n+1) $</code><br>根据这个原理我们就可以快速得到数的因子数表</p>
<p>模板：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_factor_table</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">	fill(factor_table, factor_table + n + <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (factor_table[i] == <span class="number">1</span>)   <span class="comment">//从最小的素数开始计算</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> m = j; m % i == <span class="number">0</span>; m /= i, ++k);     <span class="comment">//确定当前i的指数</span></div><div class="line">				factor_table[j] *= k + <span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p>给出一个数被三个数取摸后的余数，求这个数。设这三个数为a,b,c；取摸之后的余数为a1,b1,c1。求解步骤：</p>
<ol>
<li>对于每一个除数a，找出另两个数b,c的一个最小的满足<em>m%a=1</em>的公倍数m</li>
<li>用这个每个除数对应的余数乘以刚才得到的m，得到的三个数相加得到M</li>
<li>再用M除以a,b,c的最小公倍数，得到的结果就是想要的结果</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">CRT</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> a[],<span class="keyword">int</span> mod[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> tem=<span class="number">1</span>,ret=<span class="number">0</span>,t,y;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">        tem*=mod[i];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> w=tem/mod[i];</div><div class="line">        t=e_gcd(mod[i],w,t,y);      <span class="comment">//计算出t  w模mi下的的逆元</span></div><div class="line">        ret=(ret+y*a[i]*w)%tem;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(ret&lt;=<span class="number">0</span>)</div><div class="line">        ret+=tem;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><p><a href="http://blog.csdn.net/u010182633/article/details/45225179" target="_blank" rel="external">原理解释</a></p>
<p>模板初级版本<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swaprow</span><span class="params">(<span class="keyword">double</span> a[][MAX],<span class="keyword">int</span> m,<span class="keyword">int</span> maxrowe,<span class="keyword">int</span> n)</span>  <span class="comment">//交换m和主元行maxrowe</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=m;k&lt;=n+<span class="number">1</span>;k++)</div><div class="line">	&#123;</div><div class="line">		swap(a[m][k],a[maxrowe][k]);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectcole</span><span class="params">(<span class="keyword">double</span> a[][MAX],<span class="keyword">int</span> n)</span> <span class="comment">//选择列主元并进行消元</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i,j,k,maxrowe;</div><div class="line">	<span class="keyword">double</span> temp;</div><div class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</div><div class="line">	&#123;</div><div class="line">		maxrowe=j;</div><div class="line">		<span class="keyword">for</span>(i=j;i&lt;=n;i++)</div><div class="line">			<span class="keyword">if</span>(<span class="built_in">abs</span>(a[i][j])&gt;<span class="built_in">abs</span>(a[maxrowe][j]))</div><div class="line">				maxrowe=i;</div><div class="line">		<span class="keyword">if</span>(maxrowe!=j)</div><div class="line">			swaprow(a,j,maxrowe,n);   <span class="comment">//与最大主元所在的行进行交换</span></div><div class="line">		<span class="comment">//消元,构成三角形矩阵</span></div><div class="line">		<span class="keyword">for</span>(i=j+<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">		&#123;</div><div class="line">			temp=a[i][j]/a[j][j];</div><div class="line">			<span class="keyword">for</span>(k=j;k&lt;=n+<span class="number">1</span>;k++)</div><div class="line">				a[i][k]-=a[j][k]*temp;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">gauss</span><span class="params">(<span class="keyword">double</span> a[][MAX] ,<span class="keyword">int</span> n)</span>  <span class="comment">//最后的答案为a[][n+1]</span></span></div><div class="line">&#123;</div><div class="line">	selectcole(a,n);   <span class="comment">//构成上三角</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</div><div class="line">			a[i][n+<span class="number">1</span>]-=a[i][j]*a[j][n+<span class="number">1</span>];</div><div class="line">		a[i][n+<span class="number">1</span>]/=a[i][i];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a数组为构成的增广矩阵，最后的解集为a[][n+<span class="number">1</span>]</div><div class="line">``` </div><div class="line"></div><div class="line">***</div><div class="line"></div><div class="line">## 欧拉函数</div><div class="line">小于n且与n互质的数的个数=n*(<span class="number">1</span><span class="number">-1</span>/P1)*(<span class="number">1</span><span class="number">-1</span>/P2)….*(<span class="number">1</span><span class="number">-1</span>/Pn)，其中Pn为不同的质因数</div><div class="line">``` cpp</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"><span class="built_in">map</span>&lt;ll,ll&gt; prime_factor(ll t)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">map</span>&lt;ll,ll&gt; ret;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=t;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">while</span>(t%i==<span class="number">0</span>) &#123; ++ret[i];t/=i; &#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(t!=<span class="number">1</span>) ret[t]=<span class="number">1</span>;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"><span class="function">ll <span class="title">Euler</span> <span class="params">(ll t)</span></span></div><div class="line">&#123;</div><div class="line">	ll ret=t;</div><div class="line">	<span class="built_in">map</span>&lt;ll,ll&gt; fac=prime_factor(t);</div><div class="line">	<span class="keyword">for</span>(<span class="built_in">map</span>&lt;ll,ll&gt;::iterator i=fac.begin();i!=fac.end();i++)</div><div class="line">		ret=ret*(i-&gt;first<span class="number">-1</span>)/i-&gt;first;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="Graham扫描法求凸包"><a href="#Graham扫描法求凸包" class="headerlink" title="Graham扫描法求凸包"></a>Graham扫描法求凸包</h3><p>从最左下方的开始，沿图的边界进行扫描，然后进行取舍<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">struct</span> point</div><div class="line">&#123;</div><div class="line">	<span class="keyword">double</span> x,y;</div><div class="line">&#125;p[maxn],t[maxn];</div><div class="line"><span class="keyword">int</span> n;    <span class="comment">//点的个数</span></div><div class="line"></div><div class="line"><span class="comment">//得到相应的叉乘</span></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_X</span><span class="params">(point a,point b,point c)</span>        <span class="comment">//ab到ac的叉乘计算</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">(point a,point b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(point &amp;a,point &amp;b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">double</span> pp=get_X(p[<span class="number">0</span>],a,b);</div><div class="line">	<span class="keyword">if</span>(pp&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">if</span>(pp&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	<span class="keyword">return</span> len(p[<span class="number">0</span>],a)&lt;len(p[<span class="number">0</span>],b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Graham</span><span class="params">()</span>     <span class="comment">//返回凸包所含有的点的个数</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)     <span class="comment">//找到起始点</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(p[i].x&lt;p[<span class="number">0</span>].x) swap(p[i],p[<span class="number">0</span>]);</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(p[i].x==p[<span class="number">0</span>].x &amp;&amp; p[i].y&lt;p[<span class="number">0</span>].y) swap(p[i],p[<span class="number">0</span>]);</div><div class="line">		&#125;</div><div class="line">		sort(p+<span class="number">1</span>,p+n,cmp);</div><div class="line">		t[<span class="number">0</span>]=p[<span class="number">0</span>];</div><div class="line">		t[<span class="number">1</span>]=p[<span class="number">1</span>];</div><div class="line">		<span class="keyword">int</span> top=<span class="number">1</span>;    <span class="comment">//栈顶位置</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">while</span>(t&gt;<span class="number">0</span> &amp;&amp; get_X(t[top<span class="number">-1</span>],t[top],p[i])&lt;=<span class="number">0</span>) top--;    <span class="comment">//考虑的点在右侧的时候将栈顶的点弹出</span></div><div class="line">			top++;</div><div class="line">			t[top]=p[i];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> top;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法模板 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法模板总结——数据结构]]></title>
      <url>/2017/05/20/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>为省赛整理的常用算法模板，数据结构部分</p>
<a id="more"></a>
<h2 id="字符串相关算法"><a href="#字符串相关算法" class="headerlink" title="字符串相关算法"></a>字符串相关算法</h2><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len = p.size();</div><div class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">// 生成next数组</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(len, <span class="number">0</span>);</div><div class="line">    getNext(next, p);</div><div class="line">    <span class="comment">// 两个数组的遍历指针</span></div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; j &lt; len)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(s[i] == p[j])</div><div class="line">        &#123;</div><div class="line">            i++;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>) i++;</div><div class="line">            <span class="comment">// 根据next数组中的信息进行重新指向</span></div><div class="line">            <span class="keyword">else</span> j = next[j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> j == len ? i - j : <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;next, <span class="built_in">string</span> p)</span></span></div><div class="line">&#123;</div><div class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</div><div class="line">    <span class="comment">// k表示最长前缀后缀的长度</span></div><div class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>, i = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 计算到最后一位</span></div><div class="line">    <span class="keyword">while</span>(i &lt; p.size() - <span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 相匹配的时候对next数组赋值</span></div><div class="line">        <span class="keyword">if</span>(k == <span class="number">-1</span> || p[i] == p[k])</div><div class="line">            next[++i] = ++k;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            k = next[k];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h3><p>求字符串的最大回文子串问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Manacher 算法</span></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">    <span class="comment">// 添加辅助字符#</span></div><div class="line">    <span class="built_in">string</span> new_s;</div><div class="line">    new_s.push_back(<span class="string">'#'</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</div><div class="line">    &#123;</div><div class="line">        new_s.push_back(s[i]);</div><div class="line">        new_s.push_back(<span class="string">'#'</span>);</div><div class="line">    &#125;</div><div class="line">    s = new_s;</div><div class="line">    <span class="keyword">int</span> len = s.size();</div><div class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">// 回文半径数组</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pArr(len, <span class="number">0</span>);</div><div class="line">    <span class="comment">// C表示回文中心， R表示回文右边界</span></div><div class="line">    <span class="keyword">int</span> C = <span class="number">-1</span>, R = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">int</span> maxv = INT_MIN, maxi = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 在回文右边界里面与否的区分</span></div><div class="line">        <span class="comment">// 此时pArr表示的是起码不用验的区域 </span></div><div class="line">        pArr[i] = R &gt; i ? min(pArr[<span class="number">2</span>*C - i], R - i) : <span class="number">1</span>;</div><div class="line">        <span class="comment">// 区域没有越界</span></div><div class="line">        <span class="keyword">while</span>(i + pArr[i] &lt; len &amp;&amp; i - pArr[i] &gt; <span class="number">-1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 情况1+4 扩充</span></div><div class="line">            <span class="keyword">if</span>(s[i + pArr[i]] == s[i - pArr[i]])</div><div class="line">                pArr[i]++;</div><div class="line">            <span class="comment">// 情况2+3</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(i + pArr[i] &gt; R)</div><div class="line">        &#123;</div><div class="line">            R = i + pArr[i];</div><div class="line">            C = i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(maxv &lt; pArr[i])</div><div class="line">        &#123;</div><div class="line">            maxv = pArr[i];</div><div class="line">            maxi = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">string</span> res;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = maxi - maxv + <span class="number">1</span>; i &lt;= maxi + maxv - <span class="number">1</span>; i++)</div><div class="line">        <span class="keyword">if</span>(s[i] != <span class="string">'#'</span>) res.push_back(s[i]);</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> par[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;     <span class="comment">//注意数据范围</span></div><div class="line">        par[i]=i;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(par[x]==x)</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> par[x]=find(par[x]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</div><div class="line">    x=find(x);</div><div class="line">    y=find(y);</div><div class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</div><div class="line">    par[x]=y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=SIZE;i++)</div><div class="line">    &#123;</div><div class="line">        fa[i]=i;</div><div class="line">        son[i]=<span class="number">1</span>;</div><div class="line">        rm[i]=<span class="number">0</span>;   <span class="comment">//初始情况下每个结点下面的结点数目为0</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(fa[x]==x)</div><div class="line">        <span class="keyword">return</span> fa[x];</div><div class="line">    <span class="keyword">int</span> t=fa[x];</div><div class="line">    fa[x]=Find(fa[x]);     <span class="comment">//压缩路径</span></div><div class="line">    rm[x]+=rm[t];       <span class="comment">//压住的结点数相加</span></div><div class="line">    <span class="keyword">return</span> fa[x];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>  <span class="comment">//x放在y上</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> fx=Find(x);</div><div class="line">    <span class="keyword">int</span> fy=Find(y);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(fx!=fy)</div><div class="line">    &#123;</div><div class="line">        fa[fx]=fy;</div><div class="line">        rm[fx]=son[fy];    <span class="comment">//加上的结点压住的结点数目刚好是y结点的子结点数目</span></div><div class="line">        son[fy]+=son[fx];   <span class="comment">//更新子结点的数目</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>解决查询区间和线段树类似可解的问题，注意数组从1开始计数，初始化的时候要注意第一个元素（可以在代码中考虑）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> N,c[maxn+<span class="number">1</span>];    <span class="comment">//树状数组</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> i)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> i&amp;(-i);   <span class="comment">//得到最高位1以后的剩下的数的二进制数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//修改节点操作（添加值）</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> value)</span>  <span class="comment">//i表示序号</span></span></div><div class="line">&#123;</div><div class="line">   i++;</div><div class="line">	<span class="keyword">while</span>(i&lt;=N)</div><div class="line">	&#123;</div><div class="line">		c[i]+=value;</div><div class="line">		i+=lowbit(i);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 初始化</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)</div><div class="line">        add(i, t[i])</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//求和操作</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span></div><div class="line">&#123;</div><div class="line">   i++;</div><div class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(i&gt;<span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		sum+=c[i];</div><div class="line">		i-=lowbit(i);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="左偏树"><a href="#左偏树" class="headerlink" title="左偏树"></a>左偏树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> r1,<span class="keyword">int</span> r2)</span>  <span class="comment">//合并操作，所有左偏树的基础</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(r1==<span class="number">0</span>)<span class="keyword">return</span> r2;</div><div class="line">    <span class="keyword">if</span>(r2==<span class="number">0</span>)<span class="keyword">return</span> r1;</div><div class="line">    <span class="keyword">if</span>(heap[r2].val&gt;heap[r1].val)swab(r1,r2);</div><div class="line">    heap[r1].r=merge(heap[r1].r,r2);   </div><div class="line">    heap[heap[r1].r].par=r1;  <span class="comment">//向下进行合并</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span>(heap[heap[r1].l].dis</div><div class="line">        swap(heap[r1].l,heap[r2].r);     <span class="comment">//回溯保证左偏树的性质</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        heap[r1].dis=heap[heap[r1].r].dis+<span class="number">1</span>;    <span class="comment">//距离值进行更新</span></div><div class="line">    <span class="keyword">return</span> r1;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> push(<span class="keyword">int</span> x,<span class="keyword">int</span> y) <span class="comment">// 将y插入x左偏树中</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> merge(x,y);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> pop(<span class="keyword">int</span> &amp;x) <span class="comment">//在左偏树中删除x</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> l=heap[x].l;</div><div class="line">    <span class="keyword">int</span> r=heap[x].r;</div><div class="line">    <span class="comment">//heap[l].par=l;</span></div><div class="line">    <span class="comment">//heap[r].par=r;</span></div><div class="line">    <span class="comment">//heap[x].l=heap[x].r=heap[x].dis=0;</span></div><div class="line">    merge(l,r);    <span class="comment">//删除的核心步骤</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>所谓线段树就是利用树中的结点来维护一段区间的相应的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">#define lson l,m,rt&lt;&lt;1</div><div class="line">#define rson m+1,r,rt&lt;&lt;1|1</div><div class="line">const int maxn=20000;</div><div class="line"></div><div class="line">int MAX[max&lt;&lt;2];  //开四倍的空间</div><div class="line">int MIN[max&lt;&lt;2];</div><div class="line">int SUM[max&lt;&lt;2];</div><div class="line"></div><div class="line">void PushUP(int rt)  //向下更新</div><div class="line">&#123;</div><div class="line">	MAX[rt]=max(MAX[rt&lt;&lt;1],MAX[rt&lt;&lt;1|1]);</div><div class="line">	MIN[rt]=min(MIN[rt&lt;&lt;1],MIN[rt&lt;&lt;1|1]);</div><div class="line">	SUM[rt]=SUM[rt&lt;&lt;1]+SUM[rt&lt;&lt;1|1];</div><div class="line">&#125;</div><div class="line"></div><div class="line">void build(int l,int r,int ru)  //建立线段树</div><div class="line">&#123;</div><div class="line">	if(l==r)</div><div class="line">	&#123;</div><div class="line">		int x;</div><div class="line">		scanf(&quot;%d&quot;,&amp;x);</div><div class="line">		MAX[rt]=MIN[rt]=SUM[rt]=x;</div><div class="line">		return;		</div><div class="line">	&#125;</div><div class="line">	int m=(r+l)&gt;&gt;1;</div><div class="line">	build(lson);</div><div class="line">	build(rson);</div><div class="line">	PushUP(rt);   //递归建立两个子树以后更新当前结点维护的线段值</div><div class="line">&#125;</div><div class="line"></div><div class="line">void update(int p,int tem,int l,int r,int rt)   //实现单点替换</div><div class="line">&#123;</div><div class="line">	if(l==r)</div><div class="line">	&#123;</div><div class="line">		MAX[rt]=MIN[rt]=SUM[rt]=tem; //tem为替换值</div><div class="line">	&#125;</div><div class="line">	int m=(r+l)&gt;&gt;1;</div><div class="line">	if(p&lt;=m) update(p,tem,lson);</div><div class="line">	else update(p,tem,rson);   //找到替换的点</div><div class="line">	PushUP(rt);  //替换之后的更新</div><div class="line">&#125;</div><div class="line"></div><div class="line">void update1(int p,int add,int l,int r,int rt)  //添加点</div><div class="line">&#123;</div><div class="line">	if(l==r)</div><div class="line">	&#123;</div><div class="line">		SUM[rt]+=add;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">	int m=(l+r)&gt;&gt;1;</div><div class="line">	if(p&lt;=m) update1(p,add,lson);</div><div class="line">	else update1(p,add,rson);  //找到要添加的点</div><div class="line">	PushUP(rt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int quety(int L,int R,int l,int r,int rt)    //查找最大值</div><div class="line">&#123;</div><div class="line">	if(L&lt;=l &amp;&amp; r&lt;=R)</div><div class="line">	&#123;</div><div class="line">		return MAX[rt];</div><div class="line">	&#125;</div><div class="line">	int m=(l+r)&gt;&gt;1;</div><div class="line">	int ret=-1;   //初始值的设置</div><div class="line">	if(L&lt;m) ret=max(ret,quety(L,R,lson));  分开查找</div><div class="line">	if(R&gt;m) ret=max(ret,quety(L,R,rson));</div><div class="line">	return ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int quety1(int L,int R,int l,int r,int rt)     //查找和</div><div class="line">&#123;</div><div class="line">	if(L&lt;=l &amp;&amp; r&lt;=R)</div><div class="line">	&#123;</div><div class="line">		return	SUM[rt];</div><div class="line">	&#125;</div><div class="line">	int m=(l+r)&gt;&gt;1;</div><div class="line">	int ret=0;</div><div class="line">	if(L&lt;=m) ret+=quety1(L,R,lson);  //左半部分相加</div><div class="line">	if(R&gt;m) ret+=quety1(L,R,rson);   //注意等于号只取一次</div><div class="line">	return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>线段树中区间替换和区间增减<br>lazy思想：对于一个结点进行操作，先记录下来一开始不操作，直到要查询某个结点的值时，再进行更新，查询某一个结点区间时，先对左右结点的值进行更新，再确定具体的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div></pre></td><td class="code"><pre><div class="line">//区间替换 lazy思想</div><div class="line"></div><div class="line">int lazy[max&lt;&lt;2];</div><div class="line">int sum[max&lt;&lt;2];</div><div class="line"></div><div class="line">viod PushUP(int rt)   //有由左右子结点向上更新结点</div><div class="line">&#123;</div><div class="line">	sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];</div><div class="line">&#125;</div><div class="line"></div><div class="line">void pushdonw(int ln,int rn,int rt)  //确定左右结点维护的区间大小进行向下更新</div><div class="line">&#123;</div><div class="line">    if(lazy[rt])</div><div class="line">    &#123;</div><div class="line">        lazy[rt&lt;&lt;1]+=lazy[rt];</div><div class="line">        lazy[rt&lt;&lt;1|1]+=lazy[rt];</div><div class="line">        sum[rt&lt;&lt;1]+=(ll)ln*lazy[rt];</div><div class="line">        sum[rt&lt;&lt;1|1]+=(ll)rn*lazy[rt];</div><div class="line">        lazy[rt]=0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void build(int l,int r,int rt)   //建树</div><div class="line">&#123;</div><div class="line">	lazy[rt]=0;</div><div class="line">	if(l==r)</div><div class="line">	&#123;</div><div class="line">		scanf(&quot;%d&quot;,&amp;sum[rt]);</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">	int m=(l+r)&gt;&gt;1;</div><div class="line">	build(lson);</div><div class="line">	build(rson);</div><div class="line">	PushUP(rt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void update(int L,int R,int c,int l,int r,int rt)  //更新</div><div class="line">&#123;</div><div class="line">	if(L&lt;=l &amp;&amp;　r&lt;=R)</div><div class="line">	&#123;</div><div class="line">		lazy[rt]=c;</div><div class="line">		sum[rt]=c*(r-l+1);</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">	PushDown(rt,r-l+1);   //处理当前结点的懒惰结点</div><div class="line">	int m=(l+r)&gt;&gt;1;</div><div class="line">	if(L&lt;=m) update(L,R,c,lson);</div><div class="line">	if(R&gt;m) update(L,R,c,rson);</div><div class="line">	PushUP(rt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ll query(int L,int R,int l,int r,int rt)   //区间查询</div><div class="line">&#123;</div><div class="line">	if(L&lt;=l &amp;&amp; r&lt;=R)</div><div class="line">	&#123;</div><div class="line">		return sum[rt];</div><div class="line">	&#125;</div><div class="line">	PushDown(rt,r-l+1);</div><div class="line">	int m=(l+r)&gt;&gt;1;</div><div class="line">	ll ret=0;</div><div class="line">	if(L&lt;=m) ret+= query(L,R,lson);</div><div class="line">	if(m</div><div class="line">	return ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//区间增减</div><div class="line"></div><div class="line">ll lazy[max&lt;&lt;2];</div><div class="line">ll sum[max&lt;&lt;2];</div><div class="line"></div><div class="line">void PushUP(int rt)   //向上更新</div><div class="line">&#123;</div><div class="line">	sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];</div><div class="line">&#125;</div><div class="line"></div><div class="line">void pushdonw(int ln,int rn,int rt)  //确定左右结点维护的区间大小进行向下更新</div><div class="line">&#123;</div><div class="line">    if(lazy[rt])</div><div class="line">    &#123;</div><div class="line">        lazy[rt&lt;&lt;1]+=lazy[rt];</div><div class="line">        lazy[rt&lt;&lt;1|1]+=lazy[rt];</div><div class="line">        sum[rt&lt;&lt;1]+=(ll)ln*lazy[rt];</div><div class="line">        sum[rt&lt;&lt;1|1]+=(ll)rn*lazy[rt];</div><div class="line">        lazy[rt]=0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void build(int l,int r,int rt)   //建树</div><div class="line">&#123;</div><div class="line">	lazy[rt]=0;</div><div class="line">	if(l=r)</div><div class="line">	&#123;</div><div class="line">		scanf(&quot;I64%d&quot;,&amp;sum[rt]);</div><div class="line">	&#125;</div><div class="line">	int m=(l+r)&gt;&gt;1;</div><div class="line">	build(lson);</div><div class="line">	build(rson);</div><div class="line">	PushUp(rt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void update(int L,int R,int c,int l,int r,int rt)  //更新</div><div class="line">&#123;</div><div class="line">	if(L&lt;=l &amp;&amp; r&lt;=R)</div><div class="line">	&#123;</div><div class="line">		lazy[rt]+=c;</div><div class="line">		sum[rt]+=(ll)c*(r-l+1);</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">	int m=(l+r)&gt;&gt;1;</div><div class="line">	pushdown(m-l+1,r-m,rt);</div><div class="line">	if(L&lt;=m) update(L,R,c,lson);</div><div class="line">	if(m</div><div class="line">	PushUp(rt);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ll quety(int L,int R,int l,int r,int rt)  //查询</div><div class="line">&#123;</div><div class="line">	if(L&lt;=l &amp;&amp; r&lt;=R)</div><div class="line">	&#123;</div><div class="line">		return sum[rt];</div><div class="line">	&#125;</div><div class="line">	int m=(l+r)&gt;&gt;1;</div><div class="line">	pushdown(m-l+1,r-m,rt);</div><div class="line">	ll ret=0;</div><div class="line">	if(L&lt;=m) ret+=quety(L,R,lson);</div><div class="line">	if(m</div><div class="line">	return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="可持续化线段树（主席树）"><a href="#可持续化线段树（主席树）" class="headerlink" title="可持续化线段树（主席树）"></a>可持续化线段树（主席树）</h2><p>在普通的线段树的基础上记录了历史版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">struct segnode</div><div class="line">&#123;</div><div class="line">    int lt,rt,lv,rv;     //左右孩子结点的位置，维护的区间值</div><div class="line">    ll sum,lazy;      //lazy思想，在查询的时候再进行修改</div><div class="line">&#125;tree[maxn&lt;&lt;4];</div><div class="line">int cnt,now,a[maxn],root[maxn];</div><div class="line">void build(int &amp;id,int l,int r)</div><div class="line">&#123;</div><div class="line">    tree[++cnt]=tree[id];</div><div class="line">    id=cnt;</div><div class="line">    tree[id].lv=l;</div><div class="line">    tree[id].rv=r;</div><div class="line">    if(l==r)</div><div class="line">    &#123;</div><div class="line">        tree[id].sum=a[l];</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    int mid=(l+r)&gt;&gt;1;</div><div class="line">    build(tree[id].lt,l,mid);   //引用的妙处</div><div class="line">    build(tree[id].rt,mid+1,r);</div><div class="line">    tree[id].sum=tree[tree[id].lt].sum+tree[tree[id].rt].sum;</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line">void update(int &amp;id,int l,int r,int v)</div><div class="line">&#123;</div><div class="line">    tree[++cnt]=tree[id];</div><div class="line">    id=cnt;</div><div class="line">    tree[id].sum+=(min(r,tree[id].rv)-max(l,tree[id].lv)+1)*v;</div><div class="line">    if(l&lt;=tree[id].lv &amp;&amp; tree[id].rv&lt;=r)</div><div class="line">    &#123;</div><div class="line">        if(tree[id].lv!=tree[id].rv)</div><div class="line">            tree[id].lazy+=v;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    int mid=(tree[id].lv+tree[id].rv)&gt;&gt;1;</div><div class="line">    if(r&lt;=mid)</div><div class="line">        update(tree[id].lt,l,r,v);    //引用的妙用</div><div class="line">    else if(l&gt;mid)</div><div class="line">        update(tree[id].rt,l,r,v);</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        update(tree[id].lt,l,r,v);</div><div class="line">        update(tree[id].rt,l,r,v);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">ll query(int id,int l,int r)</div><div class="line">&#123;</div><div class="line">    if(l&lt;=tree[id].lv &amp;&amp; tree[id].rv&lt;=r)</div><div class="line">        return tree[id].sum;</div><div class="line">    ll ret=(min(r,tree[id].rv)-max(l,tree[id].lv)+1)*tree[id].lazy;</div><div class="line">    int mid=(tree[id].lv+tree[id].rv)&gt;&gt;1;</div><div class="line">    if(r&lt;=mid)</div><div class="line">        ret+=query(tree[id].lt,l,r);</div><div class="line">    else if(l&gt;mid)</div><div class="line">        ret+=query(tree[id].rt,l,r);</div><div class="line">    else</div><div class="line">        ret+=query(tree[id].lt,l,r)+query(tree[id].rt,l,r);</div><div class="line">    return ret;</div><div class="line">&#125;</div><div class="line">void solve()</div><div class="line">&#123;</div><div class="line">    int n,m,l,r,t,d;</div><div class="line">    char op;</div><div class="line">    bool hh=0;</div><div class="line">    while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF)</div><div class="line">    &#123;</div><div class="line">        if(hh)</div><div class="line">            printf(&quot;\n&quot;);</div><div class="line">        else</div><div class="line">            hh=1;</div><div class="line">        for(int i=1;i&lt;=n;i++)</div><div class="line">            scanf(&quot;%d&quot;,&amp;a[i]);</div><div class="line">        now=cnt=0;</div><div class="line">        build(root[0],1,n);</div><div class="line">        for(int i=0;i&lt;m;i++)</div><div class="line">        &#123;</div><div class="line">            scanf(&quot; %c&quot;,&amp;op);    //注意前面要加一个空格</div><div class="line">            if(op==&apos;C&apos;)</div><div class="line">            &#123;</div><div class="line">                now++; //时间增加</div><div class="line">                scanf(&quot;%d %d %d&quot;,&amp;l,&amp;r,&amp;d);</div><div class="line">                update(root[now]=root[now-1],l,r,d);</div><div class="line">            &#125;</div><div class="line">            if(op==&apos;Q&apos;)</div><div class="line">            &#123;</div><div class="line">                scanf(&quot;%d %d&quot;,&amp;l,&amp;r);</div><div class="line">                printf(&quot;%lld\n&quot;,query(root[now],l,r));</div><div class="line">            &#125;</div><div class="line">            if(op==&apos;H&apos;)</div><div class="line">            &#123;</div><div class="line">                scanf(&quot;%d %d %d&quot;,&amp;l,&amp;r,&amp;t);</div><div class="line">                printf(&quot;%lld\n&quot;,query(root[t],l,r));</div><div class="line">            &#125;</div><div class="line">            if(op==&apos;B&apos;)</div><div class="line">            &#123;</div><div class="line">                scanf(&quot;%d&quot;,&amp;now);</div><div class="line">                cnt=root[now+1]-1;   //释放结点</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过代码我们可以发现，充分利用已有数据生成新的线段树的关键在于生成节点的函数中引用&amp;</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法模板 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDU 3092 Least common multiple 素数打表+ 完全背包]]></title>
      <url>/2017/05/18/HDU-3092-Least-common-multiple-%E7%B4%A0%E6%95%B0%E6%89%93%E8%A1%A8-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3092" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=3092</a></p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出两个数S和M，让你将S分解成多个整数的和，使得这些整数的最小公倍数最大，输出这个最小公倍数（对M取模以后）</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul>
<li>首先在S的范围内进行素数打表，这样就可以看成取出这么多个素数进行相加的完全背包问题（因为同一个可以取多次，相乘以后照样和其他素数互质）</li>
<li>与我们平常见到的完全背包不同的是，如果一个素数取多次，他的代价和收益都是相乘的，而不是相加，所以写法应该在01背包的基础上进行改进，枚举可能相乘的个数</li>
<li>因为相乘一定会溢出，同时取模会影响到比较大小，所以采取取对数的方法来对dp数组进行操作，同时另外开一个数组ans[]来记录答案</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">3005</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">10005</span>; </div><div class="line"></div><div class="line"><span class="keyword">bool</span> is_prime[maxn];</div><div class="line"><span class="keyword">int</span> prime[maxn],num;</div><div class="line"><span class="keyword">double</span> dp[maxn];</div><div class="line">ll ans[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime_init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	num=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(is_prime,<span class="literal">true</span>,<span class="keyword">sizeof</span>(is_prime));</div><div class="line">	is_prime[<span class="number">0</span>]=is_prime[<span class="number">1</span>]=<span class="literal">false</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(is_prime[i])prime[num++]=i;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num &amp;&amp; i*prime[j]&lt;maxn;j++)</div><div class="line">		&#123;</div><div class="line">			is_prime[i*prime[j]]=<span class="literal">false</span>;</div><div class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;  <span class="comment">//保证每一个合数都被他的最小质因数排除</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> S,M;</div><div class="line">	prime_init();</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;S,&amp;M)!=EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">		fill(ans,ans+num,<span class="number">1</span>);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num &amp;&amp; prime[i]&lt;S ;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">double</span> tmp=<span class="built_in">log</span>(prime[i]*<span class="number">1.0</span>);</div><div class="line">			<span class="keyword">for</span>(ll j=S;j&gt;=prime[i];j--)</div><div class="line">				<span class="keyword">for</span>(ll k=prime[i],q=<span class="number">1</span>;k&lt;=j;k*=prime[i],q++)  <span class="comment">//可以重复，q表示重复次数</span></div><div class="line">					<span class="keyword">if</span>(dp[j-k]+q*tmp&gt;dp[j])</div><div class="line">					&#123;</div><div class="line">						dp[j]=dp[j-k]+q*tmp;</div><div class="line">						ans[j]=ans[j-k]*k%M;</div><div class="line">					&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[S]);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">	solve();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Educational Codeforces Round 21 题解]]></title>
      <url>/2017/05/17/Educational-Codeforces-Round-21-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>比赛链接：<a href="http://codeforces.com/contest/808" target="_blank" rel="external">http://codeforces.com/contest/808</a></p>
<a id="more"></a>
<h2 id="A-Lucky-Year"><a href="#A-Lucky-Year" class="headerlink" title="A Lucky Year"></a>A Lucky Year</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>定义一个幸运数字：有且只含有一个非零数字。给出一个数n，求这个增加多少个数以后才能够成为一个幸运数字</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>数据范围比较小，求出位数，得到最高位大1后面全是0的数，拿这个数去减原来的数就行了</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n,i;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;n/(i*<span class="number">10</span>);i*=<span class="number">10</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,n/i*i+i-n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="B-Average-Sleep-Time"><a href="#B-Average-Sleep-Time" class="headerlink" title="B Average Sleep Time"></a>B Average Sleep Time</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出一个包含n个元素的序列，表示每天的睡眠时间，同时给出一个k，表示相邻k天是一个周期，总共有n-k+1个周期，求周期平均睡眠时间</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>根据公式直接进行求解，输出的时候多输出几位，保证精度</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n,k,r;</div><div class="line">	<span class="keyword">double</span> ans;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">double</span> tmp=<span class="number">0</span>;</div><div class="line">		ans=<span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> weeks=n-k+<span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cin</span>&gt;&gt;a[i];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</div><div class="line">			tmp+=a[i];</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&lt;n;i++)</div><div class="line">		&#123;</div><div class="line">			ans+=tmp/weeks;</div><div class="line">			tmp+=a[i+<span class="number">1</span>];</div><div class="line">			tmp-=a[i-k+<span class="number">1</span>];</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%.12lf\n"</span>,ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="C-Tea-Party"><a href="#C-Tea-Party" class="headerlink" title="C Tea Party"></a>C Tea Party</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出n个人的杯子的容量，以及你所含有的水的量，要求给n个人倒茶，必须满足以下条件：1.每个人的杯子必须至少倒一半的茶  2.每个人的杯子中含有的茶的量是一个整数  3.所有的茶都要倒完  4.所有人都要满意（不存在有的人杯子大但是茶少的情况）<br>判断是否存在满足上述条件的倒茶方法</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><ul>
<li>首先判断能够给每个人至少倒一半的茶</li>
<li>根据总量推算出倒茶的比例，再按照杯子的容量进行排序，按照比例向下取整进倒茶，多出来的部分分给杯子容量最大的人，以此类推</li>
<li>注意取整操作，以及满足至少倒一半的操作</li>
</ul>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">100005</span>; </div><div class="line"><span class="keyword">int</span> ans[maxn];</div><div class="line"></div><div class="line"><span class="keyword">struct</span> node</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> v,u,id;</div><div class="line">&#125;a[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Cmp1</span><span class="params">(<span class="keyword">const</span> node &amp;a,<span class="keyword">const</span> node &amp;b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> a.v&lt;b.v;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Cmp2</span><span class="params">(<span class="keyword">const</span> node &amp;a,<span class="keyword">const</span> node &amp;b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> a.id&lt;b.id;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n,w;</div><div class="line">	<span class="keyword">int</span> sum;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;w)</div><div class="line">	&#123;</div><div class="line">		sum=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cin</span>&gt;&gt;a[i].v;</div><div class="line">			a[i].id=i;</div><div class="line">			sum+=a[i].v;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">double</span> rate=<span class="number">1.0</span>*w/sum;</div><div class="line">		<span class="keyword">if</span>(rate&lt;<span class="number">0.5</span>) </div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> last=w,tmp;</div><div class="line">		<span class="keyword">bool</span> endflag=<span class="number">0</span>;</div><div class="line">		sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,Cmp1);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">		&#123;</div><div class="line">			tmp=<span class="built_in">floor</span>(a[i].v*rate);</div><div class="line">			<span class="keyword">if</span>(<span class="number">2</span>*tmp&lt;a[i].v) tmp++; <span class="comment">//防止在一半以下</span></div><div class="line">            a[i].u=tmp;</div><div class="line">			last-=a[i].u;</div><div class="line">			<span class="keyword">if</span>(last&lt;<span class="number">0</span>) endflag=<span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(endflag)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n;last&gt;<span class="number">0</span>;i--)</div><div class="line">		&#123;</div><div class="line">			tmp=a[i].v-a[i].u;</div><div class="line">			<span class="keyword">if</span>(last&gt;=tmp) </div><div class="line">			&#123;</div><div class="line">				last-=tmp;</div><div class="line">				a[i].u=a[i].v;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span></div><div class="line">			&#123;</div><div class="line">                a[i].u+=last;</div><div class="line">				last=<span class="number">0</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,Cmp2);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;a[i].u&lt;&lt;<span class="string">" "</span>;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="D-Array-Division"><a href="#D-Array-Division" class="headerlink" title="D Array Division"></a>D Array Division</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出一个序列，允许将两个数相互交换一次或者不交换，问是否能够将两个数分成相等的两个部分</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>先求出前缀和，再用Set维护两个集合，前面的集合/后面的集合，从1开始将序列分成两半，判断两者差的一半是否在集合中能够找到</p>
<h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>使用二分，求出前缀和，从前向后枚举交换的元素，用二分向前向后查找是否能够找到交换以后形成总数的一半的部分</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><h4 id="思路一-1"><a href="#思路一-1" class="headerlink" title="思路一"></a>思路一</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">100005</span>; </div><div class="line"><span class="keyword">int</span> a[maxn],n;</div><div class="line">ll s[maxn],tot;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</div><div class="line">	&#123;</div><div class="line">		tot=<span class="number">0</span>;</div><div class="line">		s[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line">		<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s1,s2;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">			s2.insert(a[i]);</div><div class="line">			tot+=a[i];</div><div class="line">			s[i]=s[i<span class="number">-1</span>]+a[i];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(tot&amp;<span class="number">1</span>) </div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		ll A,B,tmp;</div><div class="line">		<span class="keyword">bool</span> endflag=<span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">		&#123;</div><div class="line">			A=s[i],B=s[n]-s[i];</div><div class="line">			<span class="keyword">if</span>(A==B)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">				endflag=<span class="number">0</span>;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			tmp=A-B;</div><div class="line">			s2.erase(s2.find(a[i]));</div><div class="line">			s1.insert(a[i]);</div><div class="line">			<span class="keyword">if</span>(tmp&gt;<span class="number">0</span> &amp;&amp; tmp%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; tmp&lt;=MAXX)  <span class="comment">//差值为偶数</span></div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span>(s1.find(tmp/<span class="number">2</span>)!=s1.end())</div><div class="line">				&#123;</div><div class="line">					<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">					endflag=<span class="number">0</span>;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span>(tmp&lt;<span class="number">0</span> &amp;&amp; tmp%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; tmp&gt;=-MAXX)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span>(s2.find(-tmp/<span class="number">2</span>)!=s2.end())</div><div class="line">				&#123;</div><div class="line">					<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">					endflag=<span class="number">0</span>;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(endflag) <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="思路二-1"><a href="#思路二-1" class="headerlink" title="思路二"></a>思路二</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">100005</span>; </div><div class="line"></div><div class="line"><span class="keyword">int</span> a[maxn];</div><div class="line">ll s[maxn];</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    ll tot=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</div><div class="line">        tot += a[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(tot%<span class="number">2</span>!=<span class="number">0</span> || n==<span class="number">1</span>)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    tot/=<span class="number">2</span>;</div><div class="line">    s[<span class="number">0</span>]=a[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)&#123;</div><div class="line">        s[i]=s[i<span class="number">-1</span>]+a[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</div><div class="line">        <span class="keyword">if</span>(a[i]==tot)&#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//正二分</span></div><div class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=i<span class="number">-1</span>;</div><div class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</div><div class="line">            <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">            ll temp=s[mid]+a[i];</div><div class="line">            <span class="keyword">if</span>(temp==tot)&#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(temp&lt;tot)  l=mid+<span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        l=i+<span class="number">1</span>,r=n;</div><div class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</div><div class="line">            <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">            ll temp=s[n]-s[mid]+a[i];</div><div class="line">            <span class="keyword">if</span>(temp==tot)&#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(temp&lt;tot) r=mid<span class="number">-1</span>;</div><div class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDU 1868 Consecutive sum 数学+枚举]]></title>
      <url>/2017/05/16/HDU-1868-Consecutive-sum-%E6%95%B0%E5%AD%A6-%E6%9E%9A%E4%B8%BE/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1868" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=1868</a></p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个数n，求出这个数被分解成连续多个数之和的方案数</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>连续多个数之和可以看成等差数列，得到公式：x(i+i+x-1)/2=n。这样我们可以枚举x，在根号n的复杂度下将问题求解</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">100005</span>; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ll x;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x)!=EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=<span class="number">2</span>*x;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>((<span class="number">2</span>*x)%i) <span class="keyword">continue</span>;</div><div class="line">			<span class="keyword">int</span> tmp=<span class="number">2</span>*x/i+<span class="number">1</span>-i;</div><div class="line">			<span class="keyword">if</span>(tmp%<span class="number">2</span>) <span class="keyword">continue</span>;</div><div class="line">			ans++;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">	solve();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDU 1083 Courses 匈牙利算法模板题]]></title>
      <url>/2017/05/15/HDU-1083-Courses-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1083" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=1083</a></p>
<a id="more"></a>
<h2 id="题意-amp-题解"><a href="#题意-amp-题解" class="headerlink" title="题意&amp;题解"></a>题意&amp;题解</h2><p>给出一个二分图求最大匹配个数，判断时候和一边的数相等，以此题当做匈牙利算法模板</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">100005</span>; </div><div class="line">  </div><div class="line"><span class="comment">/* ************************************************************************** </span></div><div class="line">//二分图匹配（匈牙利算法的DFS实现） </div><div class="line">//初始化：g[][]两边顶点的划分情况 </div><div class="line">//建立g[i][j]表示i-&gt;j的有向边就可以了，是左边向右边的匹配 </div><div class="line">//g没有边相连则初始化为0 </div><div class="line">//L是匹配左边的顶点数，R是匹配右边的顶点数 </div><div class="line">//调用：res=hungary();输出最大匹配数 </div><div class="line">//优点：适用于稠密图，DFS找增广路，实现简洁易于理解 </div><div class="line">//时间复杂度:O(VE) </div><div class="line">// ***************************************************************************/  </div><div class="line"><span class="comment">//顶点编号从1开始的  </span></div><div class="line"><span class="keyword">int</span> LN,RN;<span class="comment">//L,R数目  </span></div><div class="line"><span class="keyword">int</span> g[maxn][maxn], linker[maxn];    <span class="comment">//所连得边直接从做到右</span></div><div class="line"><span class="keyword">bool</span> used[maxn];  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> L)</span><span class="comment">//从左边开始找增广路径  </span></span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> R;  </div><div class="line">    <span class="keyword">for</span>(R = <span class="number">1</span>; R &lt;= RN; R++)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">if</span>(g[L][R]!=<span class="number">0</span> &amp;&amp; !used[R])  </div><div class="line">        &#123;  </div><div class="line">            <span class="comment">//找增广路，反向  </span></div><div class="line">            used[R]=<span class="literal">true</span>;  </div><div class="line">            <span class="keyword">if</span>(linker[R] == <span class="number">-1</span> || dfs(linker[R]))  </div><div class="line">            &#123;  </div><div class="line">                linker[R]=L;  </div><div class="line">                <span class="keyword">return</span> <span class="number">1</span>;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//这个不要忘了，经常忘记这句  </span></div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> res = <span class="number">0</span> ;  </div><div class="line">    <span class="keyword">int</span> L;  </div><div class="line">    <span class="built_in">memset</span>(linker,<span class="number">-1</span>,<span class="keyword">sizeof</span>(linker));  </div><div class="line">    <span class="keyword">for</span>( L = <span class="number">1</span>; L &lt;= LN; L++)  </div><div class="line">    &#123;  </div><div class="line">        <span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span>(used));  </div><div class="line">        <span class="keyword">if</span>(dfs(L) != <span class="number">0</span>)  </div><div class="line">            res++;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> res;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> t;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</div><div class="line">	<span class="keyword">while</span>(t--)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;LN,&amp;RN);</div><div class="line">		<span class="keyword">int</span> num,tmp;</div><div class="line">		<span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span>(g));</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=LN;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num;j++)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tmp);</div><div class="line">                g[i][tmp]=<span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> ans=hungary();</div><div class="line">		<span class="keyword">if</span>(ans==LN) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">	solve();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDU 1162 Eddy's picture 最小生成树 Prim模板]]></title>
      <url>/2017/05/15/HDU-1162-Eddy-s-picture-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-Prim%E6%A8%A1%E6%9D%BF/</url>
      <content type="html"><![CDATA[<p>算法链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1162" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=1162</a></p>
<a id="more"></a>
<h2 id="题意-amp-题解"><a href="#题意-amp-题解" class="headerlink" title="题意&amp;题解"></a>题意&amp;题解</h2><p>裸的最小生成树，先计算出各个点的距离，跑一遍Prime。以此题记录Prime算法模板</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">205</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">2005</span>;</div><div class="line"></div><div class="line"><span class="keyword">double</span> cost[maxn][maxn];</div><div class="line"><span class="keyword">double</span> mincost[maxn];  <span class="comment">//到已经确定的点的最短距离</span></div><div class="line"><span class="keyword">bool</span> used[maxn];</div><div class="line"><span class="keyword">int</span> V;</div><div class="line"><span class="keyword">double</span> xx[maxn],yy[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_dist</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((xx[a]-xx[b])*(xx[a]-xx[b])+(yy[a]-yy[b])*(yy[a]-yy[b]));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++)</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;xx[i],&amp;yy[i]);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++)</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=V;j++)</div><div class="line">		&#123;</div><div class="line">			cost[i][j]=cost[j][i]=get_dist(i,j);</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">prim</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    fill(mincost,mincost+V+<span class="number">1</span>,INF);  <span class="comment">//注意建图方式</span></div><div class="line">    fill(used,used+V+<span class="number">1</span>,<span class="literal">false</span>);   <span class="comment">//注意建图方式</span></div><div class="line">    mincost[<span class="number">1</span>]=<span class="number">0</span>;        <span class="comment">//注意建图方式</span></div><div class="line">    <span class="comment">//used[0]=true;     不在这里初始初始化</span></div><div class="line"></div><div class="line">    <span class="keyword">double</span> res=<span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> v=<span class="number">-1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++) <span class="comment">//注意建图组织方式</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">//在这里对收录一号元素，因为要遍历一号元素的相邻结点</span></div><div class="line">            <span class="keyword">if</span>(!used[i]&amp;&amp;((v==<span class="number">-1</span>)||mincost[i]&lt;mincost[v]))v=i;   </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(v==<span class="number">-1</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        used[v]=<span class="literal">true</span>;</div><div class="line">        res+=mincost[v];</div><div class="line">		<span class="comment">//cout&lt;&lt;v&lt;&lt;" "&lt;&lt;res&lt;&lt;endl;</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++)    <span class="comment">//注意建图方式</span></div><div class="line">            mincost[i]=min(mincost[i],cost[v][i]);  <span class="comment">//不判断是否相邻</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;V)!=EOF)</div><div class="line">	&#123;</div><div class="line">		build();</div><div class="line">		<span class="keyword">double</span> ans=prim();</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">	solve();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2017 CCPC 中南地区邀请赛 E Strange Optimization]]></title>
      <url>/2017/05/15/2017-CCPC-%E4%B8%AD%E5%8D%97%E5%9C%B0%E5%8C%BA%E9%82%80%E8%AF%B7%E8%B5%9B-E-Strange-Optimization/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://202.197.224.59/OnlineJudge2/index.php/Contest/read_problem/cid/43/pid/1268" target="_blank" rel="external">http://202.197.224.59/OnlineJudge2/index.php/Contest/read_problem/cid/43/pid/1268</a></p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>定义一个函数：f(t)=min(i,j∈ℤ)|i/n−j/m+t|，给出n和m，求使得f(t)最大的t的取值。（式子可以查看原网页中的式子）</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>因为i,j都是可以取任意整数的，所以进行式子中的前两个部分进行通分以后就是(im-jn)/mn。<br>观察我们可以得到要得到最大值<strong>t的值就是上述式子的最小精度的一半</strong>，求最小精度就是要求分子(im-jn)能表示的数的间隔<br>这个间隔我用一个比较巧妙的方法求得，用一个优先队列来存放这两个数，不断从优先队列中取出两个最小的数做差，然后再放入优先队列中，直到取出的这两个最小的数是相同的。<br>最后对得到的分数进行化简就是最后的答案了</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">15</span>;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">llc</span><span class="params">(ll a,ll b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> a*b/gcd(a,b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ll n,m;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</div><div class="line">	&#123;</div><div class="line">		priority_queue&lt;ll,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; Q;</div><div class="line">		Q.push(n);</div><div class="line">		Q.push(m);</div><div class="line">		ll s1,s2,tmp;</div><div class="line">		s1=Q.top(),Q.pop(),s2=Q.top(),Q.pop();</div><div class="line">		<span class="keyword">while</span>(s1!=s2)</div><div class="line">		&#123;</div><div class="line">			<span class="comment">//cout&lt;&lt;s1&lt;&lt;s2&lt;&lt;endl;</span></div><div class="line">			tmp=<span class="built_in">abs</span>(s1-s2);</div><div class="line">			Q.push(s1),Q.push(s2),Q.push(tmp);</div><div class="line">            s1=Q.top(),Q.pop(),s2=Q.top(),Q.pop();</div><div class="line">		&#125;</div><div class="line">		ll p=s1,q=<span class="number">2</span>*m*n;</div><div class="line">		tmp=gcd(p,q);</div><div class="line">		<span class="keyword">while</span>(tmp!=<span class="number">1</span>)</div><div class="line">		&#123;</div><div class="line">			p/=tmp,q/=tmp;</div><div class="line">			tmp=gcd(p,q);</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">"/"</span>&lt;&lt;q&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">	solve();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>做出这道题的时候还是有些激动的，因为在现场赛上两题如果罚时不多的话就是铜牌。哈哈，如果我去打这场比赛就能够拿一个铜牌。<br>好好努力，提升实力，以后在区域赛上拿牌就美滋滋了。</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDU 1874 畅通工程续 最短路Dijkstra模板题]]></title>
      <url>/2017/05/15/HDU-1874-%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E7%BB%AD-%E6%9C%80%E7%9F%AD%E8%B7%AFDijkstra%E6%A8%A1%E6%9D%BF%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1874" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=1874</a></p>
<a id="more"></a>
<h2 id="题意-amp-题解"><a href="#题意-amp-题解" class="headerlink" title="题意&amp;题解"></a>题意&amp;题解</h2><p>裸的最短路，注意重边问题。以此题来代表Dijkstra模板（邻接矩阵）</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">205</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">2005</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> cost[maxn][maxn];  <span class="comment">//邻接矩阵建图</span></div><div class="line"><span class="keyword">int</span> d[maxn];</div><div class="line"><span class="keyword">bool</span> used[maxn];  <span class="comment">//表示是否被收录</span></div><div class="line"><span class="keyword">int</span> V,E;</div><div class="line"></div><div class="line"><span class="comment">//建图</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">memset</span>(d,INF,<span class="keyword">sizeof</span>(d));</div><div class="line">	<span class="built_in">memset</span>(cost,INF,<span class="keyword">sizeof</span>(cost));    <span class="comment">//初始化邻接矩阵</span></div><div class="line">	<span class="keyword">int</span> u,v,w;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;E;i++)</div><div class="line">	&#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;w);</div><div class="line">        cost[u][v]=cost[v][u]=min(cost[v][u],w);  <span class="comment">//去重边操作</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></div><div class="line">&#123;</div><div class="line">    fill(d,d+V,INF);</div><div class="line">    fill(used,used+V,<span class="literal">false</span>);</div><div class="line">    d[s]=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> v=<span class="number">-1</span>;</div><div class="line">        <span class="comment">//从未被收录的点中找出一个距离最小的点</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;V;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(!used[j]&amp;&amp;(v==<span class="number">-1</span>||d[j]&lt;d[v]))v=j;  <span class="comment">//v==-1设置哨兵，确定有没有没被收录的点</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(v==<span class="number">-1</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        used[v]=<span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;i++)</div><div class="line">            d[i]=min(d[i],d[v]+cost[v][i]);  <span class="comment">//松弛操作</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> S,T;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;V,&amp;E)!=EOF)</div><div class="line">	&#123;</div><div class="line">		build();</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;S,&amp;T);</div><div class="line">		dijkstra(S);</div><div class="line">		<span class="keyword">int</span> ans=d[T];</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans==INF?<span class="number">-1</span>:ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">	solve();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDU 2544 最短路 SPFA模板题]]></title>
      <url>/2017/05/14/HDU-2544-%E6%9C%80%E7%9F%AD%E8%B7%AF-SPFA%E6%A8%A1%E6%9D%BF%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2544" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=2544</a></p>
<a id="more"></a>
<h2 id="题意-amp-题解"><a href="#题意-amp-题解" class="headerlink" title="题意&amp;题解"></a>题意&amp;题解</h2><p>最短路模板题，以此题记录SPFA模板</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">10005</span>;</div><div class="line"><span class="keyword">int</span> visit[maxn],dist[maxn];</div><div class="line"><span class="keyword">int</span> n,m,id;</div><div class="line"></div><div class="line"><span class="comment">//链式前向星建图</span></div><div class="line"><span class="keyword">struct</span> Node</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> v,w,next;</div><div class="line">&#125;edges[maxm];</div><div class="line"><span class="keyword">int</span> head[maxn]; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span>   <span class="comment">//u到v的权值为w的边</span></span></div><div class="line">&#123;</div><div class="line">	edges[id].v=v;</div><div class="line">	edges[id].w=w;</div><div class="line">	edges[id].next=head[u];    <span class="comment">//把之前的第一条边作为当前边的最后一条边</span></div><div class="line">	head[u]=id++;              <span class="comment">//id为从0开始的标号</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//建图</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</div><div class="line">	<span class="keyword">int</span> u,v,w;</div><div class="line">	id=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;w);</div><div class="line">		addedge(u,v,w);</div><div class="line">		addedge(v,u,w);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> st)</span></span></div><div class="line">&#123;</div><div class="line">    fill(visit,visit+maxn,<span class="number">0</span>);   <span class="comment">//标记所有节点未被访问</span></div><div class="line">    fill(dist,dist+maxn,INF);   <span class="comment">//求最短路，初始化最大值</span></div><div class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</div><div class="line">    visit[st]=<span class="number">1</span>;</div><div class="line">    dist[st]=<span class="number">0</span>;</div><div class="line">    Q.push(st);</div><div class="line">    <span class="keyword">while</span> (!Q.empty())</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> now=Q.front();</div><div class="line">        Q.pop();</div><div class="line">        visit[now]=<span class="number">0</span>;           <span class="comment">//注意此处将该点标记为未访问</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i!=<span class="number">-1</span>;i=edges[i].next)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> v=edges[i].v;</div><div class="line">            <span class="keyword">int</span> w=edges[i].w;</div><div class="line">            <span class="keyword">if</span>(dist[v]&gt;dist[now]+w)   <span class="comment">//最短路松弛</span></div><div class="line">            &#123;</div><div class="line">                dist[v]=dist[now]+w;</div><div class="line">                <span class="keyword">if</span>(!visit[v])</div><div class="line">                &#123;</div><div class="line">                    Q.push(v);</div><div class="line">                    visit[v]=<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m)!=EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(n==<span class="number">0</span> &amp;&amp;m==<span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">		init();</div><div class="line">		spfa(<span class="number">1</span>);</div><div class="line">		<span class="keyword">int</span> ans=dist[n];</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">	solve();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Codeforces 391 题解]]></title>
      <url>/2017/05/14/Codeforce-391-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>非常常规的一套Codeforces题解<br><a id="more"></a></p>
<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个字符串，求出其中最多能够组成单词“Bulbasaur”的个数（可以将字符串中的字母拆散）</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>用一个数组记录单词中各个字母的出现次数，出现次数最小的值就是能够组成的单词数</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span> s)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(s==<span class="string">'B'</span>)con[<span class="number">0</span>]++;</div><div class="line">    <span class="keyword">if</span>(s==<span class="string">'u'</span>)con[<span class="number">1</span>]++;</div><div class="line">    <span class="keyword">if</span>(s==<span class="string">'l'</span>)con[<span class="number">2</span>]++;</div><div class="line">    <span class="keyword">if</span>(s==<span class="string">'b'</span>)con[<span class="number">3</span>]++;</div><div class="line">    <span class="keyword">if</span>(s==<span class="string">'a'</span>)con[<span class="number">4</span>]++;</div><div class="line">    <span class="keyword">if</span>(s==<span class="string">'s'</span>)con[<span class="number">5</span>]++;</div><div class="line">    <span class="keyword">if</span>(s==<span class="string">'r'</span>)con[<span class="number">6</span>]++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">string</span> s;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s)</div><div class="line">    &#123;</div><div class="line">        fill(con,con+<span class="number">7</span>,<span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</div><div class="line">            judge(s[i]);</div><div class="line">        <span class="keyword">int</span> res=INF;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>||i==<span class="number">4</span>)</div><div class="line">                res=min(res,con[i]/<span class="number">2</span>);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                res=min(res,con[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出n个数，从这n个数中取出一个组合，使得这个组合中的最大公因子不为1，同时要组合中的数的个数要最大，输出这个组合中的数的个数</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><ul>
<li>首先求出范围内的素数集，然后把每一个素数当成组合中的最大公因子，看这个组合能够有大（看给出的这些数中有多少能够整除当前素数），最后取所有组合的模的最大值</li>
<li>对每一个数进行判断他是否是当前这个素数的倍数这样会造成时间超限，因此采用空间换时间的策略，为数据范围内的每一个数记录其出现次数，然后再将所有能够整除当前素数的值的出现次数进行相加（类似与埃式素数筛选法）</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> con[MAX];</div><div class="line"><span class="keyword">bool</span> is_prime[MAX];</div><div class="line"><span class="keyword">int</span> prime[MAX];</div><div class="line"><span class="keyword">int</span> num;</div><div class="line"></div><div class="line"><span class="comment">//素数筛选</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_pri</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    num=<span class="number">0</span>;</div><div class="line">    <span class="built_in">memset</span>(is_prime,<span class="number">1</span>,<span class="keyword">sizeof</span>(is_prime));</div><div class="line">    is_prime[<span class="number">0</span>]=is_prime[<span class="number">1</span>]=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAX;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(is_prime[i])</div><div class="line">        &#123;</div><div class="line">            prime[num++]=i;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;MAX;j+=i)</div><div class="line">                is_prime[j]=<span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    init_pri();</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">memset</span>(con,<span class="number">0</span>,<span class="keyword">sizeof</span>(con));</div><div class="line">        <span class="keyword">int</span> x;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;x;</div><div class="line">            con[x]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> tem=<span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=prime[i];j&lt;MAX;j+=prime[i])</div><div class="line">                tem+=con[j];     <span class="comment">//求出当前组合的模</span></div><div class="line">            res=max(res,tem);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ACM中常用的STL（二）]]></title>
      <url>/2017/05/13/ACM%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84STL%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>上一篇文章讲了STL里面常用容器的用法，这一篇文章将主要讲一场常用函数的用法以及后期补充的一些注意事项</p>
<a id="more"></a>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="next-permutation-prev-permutation-first-last"><a href="#next-permutation-prev-permutation-first-last" class="headerlink" title="next_permutation/prev_permutation(first,last)"></a>next_permutation/prev_permutation(first,last)</h3><p>转换所给区间内的元素到下一个字典序，成功返回TRUE，不成功返回FALSE（不存在下一个字典序）</p>
<h3 id="sort-stable-sort-first-last"><a href="#sort-stable-sort-first-last" class="headerlink" title="sort/stable_sort(first,last)"></a>sort/stable_sort(first,last)</h3><p>对区间内的进行排序，前者为稳定排序，后者为不稳定排序</p>
<h4 id="重载operate-lt-更改排序规则"><a href="#重载operate-lt-更改排序规则" class="headerlink" title="重载operate\&lt;更改排序规则"></a>重载operate\&lt;更改排序规则</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> node</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a,b;</div><div class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp; nodeb) <span class="keyword">const</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(a==nodeb.a)         <span class="comment">//确定优先级a比bda</span></div><div class="line">			<span class="keyword">return</span> b&lt;nodeb.b;</div><div class="line">		<span class="keyword">return</span> a&lt;nodeb.a;     <span class="comment">//优先最小值</span></div><div class="line">	&#125;</div><div class="line">&#125;s[maxn];</div></pre></td></tr></table></figure>
<h4 id="自定义排序函数更改排序规则"><a href="#自定义排序函数更改排序规则" class="headerlink" title="自定义排序函数更改排序规则"></a>自定义排序函数更改排序规则</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Cmp</span><span class="params">(<span class="keyword">const</span> node &amp;x,<span class="keyword">const</span> node &amp;y)</span>   <span class="comment">//自定义比较函数</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(x.a==y.a)                       <span class="comment">//a的优先级大于b</span></div><div class="line">		<span class="keyword">return</span> x.b&lt;y.b;</div><div class="line">	<span class="keyword">return</span> x.a&lt;y.a;                   <span class="comment">//最小值优先</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="partial-sort-first-middle-last"><a href="#partial-sort-first-middle-last" class="headerlink" title="partial_sort(first,middle,last)"></a>partial_sort(first,middle,last)</h3><p>对中间部分元素进行排序，缺省比较函数，可以用于求出最大（或者最小）的k个元素<br>类似的partial_sort_copy(first,last,d_first,d_last) 对部分元素（根据新的容器的范围）进行排序以后复制值新的容器内</p>
<h3 id="lower-bound-upper-bound-first-last-value"><a href="#lower-bound-upper-bound-first-last-value" class="headerlink" title="lower_bound/upper_bound(first,last,value)"></a>lower_bound/upper_bound(first,last,value)</h3><p>前者返回大于等于value的第一个数的迭代器，<br>后者返回大于value的第一个数的迭代器</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> STL </tag>
            
            <tag> 算法模板 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Codeforces 390 题解]]></title>
      <url>/2017/05/13/Codeforces%20390%20%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>这次Codeforces的A和B都是比较简单的，A就是贪心算法（我一开始在理解题意的时候出了一点问题），B就是蛮力枚举。<br>看懂题目的话我觉得每道题在20分钟之内将把代码写出来是没有问题的，可是英语还是硬伤，努力学英语中。。。</p>
<a id="more"></a>
<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你一个数组要求将他们进行划分成连续的几个部分，要求每个部分部分不为0</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul>
<li>无法划分的情况：数组中的各个都为0</li>
<li>对于剩下的情况，我一开始就只是统一处理：分成两组，第一组从1到最后一个不为0的前面一位，剩下的部分组成第二组。但是后来发现这样做是对于数组总和为0的时候可以，对于数组总和不为0时就是不对的，因为可能有第一组都是0的情况，所以还是要分两种情况讨论</li>
<li>数组总和不为0时，就分成一组</li>
<li>数组总和为0是，分成两组：第一组从1到最后一个不为0的数的前面一位，剩下的组成第二组</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>,tag=<span class="number">1</span>,u;</div><div class="line">		<span class="keyword">int</span> a[<span class="number">101</span>];</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cin</span>&gt;&gt;a[i];</div><div class="line">			sum+=a[i];</div><div class="line">			<span class="keyword">if</span>(a[i])  <span class="comment">//记录最后一个不为0的数字</span></div><div class="line">			&#123;</div><div class="line">				u=i+<span class="number">1</span>;</div><div class="line">				tag=<span class="number">0</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(tag)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">			<span class="keyword">return</span> ;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(sum)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"1"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"1"</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">			<span class="keyword">return</span> ;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span></div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"2"</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"1"</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;u<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;u&lt;&lt;<span class="string">" "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>题目以小时候玩的井字旗为背景，给出残局，让你求出其中一方是否可以走一步就获得胜利（棋盘大小4*4）</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><ul>
<li>依次考虑每个空格，胜利有两种情况</li>
<li>中间和两边中的一个棋子是自己的，另一个是空格</li>
<li>两个自己的棋子夹一个空格</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> a[<span class="number">6</span>][<span class="number">6</span>];</div><div class="line"><span class="keyword">char</span> tl[<span class="number">2</span>]=&#123;<span class="string">'x'</span>,<span class="string">'o'</span>&#125;;</div><div class="line"><span class="keyword">int</span> dx[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</div><div class="line"><span class="keyword">int</span> dy[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> nu)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> xx=x+dx[i];</div><div class="line">        <span class="keyword">int</span> yy=y+dy[i];</div><div class="line">        <span class="keyword">if</span>(a[xx][yy]==tl[nu])</div><div class="line">        &#123;</div><div class="line">            xx=x-dx[i];</div><div class="line">            yy=y-dy[i];</div><div class="line">            <span class="keyword">if</span>(a[xx][yy]==<span class="string">'.'</span>)</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(a[xx][yy]==<span class="string">'.'</span>)</div><div class="line">        &#123;</div><div class="line">            xx=xx+dx[i];</div><div class="line">            yy=yy+dy[i];</div><div class="line">            <span class="keyword">if</span>(a[xx][yy]==tl[nu])</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> num1=<span class="number">0</span>,num2=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;a[i][j];</div><div class="line">            <span class="keyword">if</span>(a[i][j]==<span class="string">'x'</span>)</div><div class="line">                num1++;</div><div class="line">            <span class="keyword">if</span>(a[i][j]==<span class="string">'o'</span>)</div><div class="line">                num2++;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</div><div class="line">        a[i][<span class="number">0</span>]=a[<span class="number">0</span>][i]=a[<span class="number">6</span>][i]=a[i][<span class="number">6</span>]=<span class="string">'*'</span>;</div><div class="line">    <span class="keyword">int</span> be=<span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(num2&lt;num1)</div><div class="line">        be=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(a[i][j]==tl[be]&amp;&amp;judge(i,j,be))</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="简洁的代码"><a href="#简洁的代码" class="headerlink" title="简洁的代码"></a>简洁的代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</div><div class="line"><span class="keyword">int</span> dy[]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</div><div class="line"><span class="keyword">char</span> s[<span class="number">10</span>][<span class="number">10</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">8</span>;k++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(s[i+dx[k]][j+dy[k]]==<span class="string">'x'</span>&amp;&amp;s[i+dx[k]*<span class="number">2</span>][j+dy[k]*<span class="number">2</span>]==<span class="string">'x'</span>)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">puts</span>(<span class="string">"YES"</span>);</div><div class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(s[i+dx[k]][j+dy[k]]==<span class="string">'x'</span>&amp;&amp;s[i-dx[k]][j-dy[k]]==<span class="string">'x'</span>)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">puts</span>(<span class="string">"YES"</span>);</div><div class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">5</span>;i++)<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i]+<span class="number">2</span>);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">5</span>;i++)<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=<span class="number">5</span>;j++)<span class="keyword">if</span>(s[i][j]==<span class="string">'.'</span>)check(i,j);</div><div class="line">	<span class="built_in">puts</span>(<span class="string">"NO"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>还是要多练，切水题的时间比较长，不能死在水题上面</li>
<li>看题目不能靠翻译，要锻炼自己的英语水平</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ACM中常用的STL （一）]]></title>
      <url>/2017/05/13/ACM%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84STL-%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>近期在在刷题的时候发现很多的STL的容器还有函数都用得不是很熟练。总所周知，在刷题的时候一些基本的STL的容器和函数的用法是必不可少的。<br>我将用两篇文章来整理一些常用的STL容器和函数的用法，这一篇主要讲容器</p>
<a id="more"></a>
<h2 id="共通能力"><a href="#共通能力" class="headerlink" title="共通能力"></a>共通能力</h2><p>所有容器中存放的都是值而非引用，即容器进行安插操作时内部实施的是拷贝操作。因此容器的每个元素必须能够被拷贝。如果希望存放的不是副本，容器元素只能是指针。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue 队列"></a>queue 队列</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>queue的定义需要两个参数，一个是元素类型，一个容器类型，元素类型是必要的，容器类型是可选的，默认为deque类型</p>
<h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><ul>
<li>push(x) 入队，将x接到队列的末端</li>
<li>pop() 出队，弹出队列的第一个元素，注意，并不会返回被弹出元素的值</li>
<li>front() 访问队首元素</li>
<li>back() 访问队尾元素</li>
<li>empty() 判断队列是否为空</li>
<li>size()  访问队列中的元素个数</li>
</ul>
<h3 id="priority-queue-优先队列"><a href="#priority-queue-优先队列" class="headerlink" title="priority_queue 优先队列"></a>priority_queue 优先队列</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>需要三个参数，一个是元素类型，一个是保存数据的容器类型（默认为vector），一个是比较方式（默认为less()方法，即最大值优先），后两个参数可以省去</p>
<h4 id="自定义比较方式"><a href="#自定义比较方式" class="headerlink" title="自定义比较方式"></a>自定义比较方式</h4><h5 id="改变第三个参数比较类"><a href="#改变第三个参数比较类" class="headerlink" title="改变第三个参数比较类"></a>改变第三个参数比较类</h5><p>使用greater比较类即为最小值优先，此时对容器类型不能够省略<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;que3;<span class="comment">//注意“&gt;&gt;”会被认为错误，    </span></div><div class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;que4;<span class="comment">////最大值优先</span></div></pre></td></tr></table></figure></p>
<h5 id="自定义比较类（结构体）"><a href="#自定义比较类（结构体）" class="headerlink" title="自定义比较类（结构体）"></a>自定义比较类（结构体）</h5><p>可以自定义一个规定对比方式的结构最为第三个参数进行传入，同上容器类型不能够省略<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义比较结构</span></div><div class="line"><span class="keyword">struct</span> cmp1&#123;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> a&gt;b;<span class="comment">//最小值优先</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> cmp2&#123;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> a&lt;b;<span class="comment">//最大值优先</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,cmp1&gt;que1;<span class="comment">//最小值优先</span></div><div class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,cmp2&gt;que2;<span class="comment">//最大值优先</span></div></pre></td></tr></table></figure></p>
<h5 id="重载operate-lt"><a href="#重载operate-lt" class="headerlink" title="重载operate&lt;"></a>重载operate&lt;</h5><p>我们也可以对数据结构中的operate&lt;进行重载，从而使用其默认的比较类。<br>这种方法也可以定义结构体中各个变量比较的一个优先级<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//自定义数据结构</span></div><div class="line"><span class="keyword">struct</span> number1&#123;</div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> number1 &amp;a) <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">return</span> x&gt;a.x;<span class="comment">//最小值优先</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> number2&#123;</div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> number2 &amp;a) <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">return</span> x&lt;a.x;<span class="comment">//最大值优先</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">    priority_queue&lt;number1&gt;que5; <span class="comment">//最小优先级队列</span></div><div class="line">    priority_queue&lt;number2&gt;que6;  <span class="comment">//最大优先级队列</span></div></pre></td></tr></table></figure></p>
<h4 id="基本方法-1"><a href="#基本方法-1" class="headerlink" title="基本方法"></a>基本方法</h4><ul>
<li>push(x) 插入元素并在容器中进行排序</li>
<li>pop() 移除堆顶元素</li>
<li>top() 获取堆顶元素</li>
<li>empty() 判断队列是否为空</li>
<li>size()  访问队列中的元素个数</li>
</ul>
<h3 id="vector-动态数组"><a href="#vector-动态数组" class="headerlink" title="vector 动态数组"></a>vector 动态数组</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>一般只使用到一个参数，数据类型参数</p>
<h4 id="基本方法-2"><a href="#基本方法-2" class="headerlink" title="基本方法"></a>基本方法</h4><ul>
<li>重载[]  可以通过下边获取元素</li>
<li>front() 返回第一个元素的值</li>
<li>end()  返回最后一个元素的值</li>
<li>begin()  返回第一个迭代器</li>
<li>end()  返回最后一个迭代器</li>
<li>empty() 判断是否为空</li>
<li>size()  获取元素个数</li>
<li>reserve()  反转数组</li>
<li>clear()  清楚所有元素</li>
<li>push_back(x)  在最后加入元素x</li>
<li>pop_back()</li>
</ul>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>可以看成是集合，容器内不含有重复元素<br>针对集合操作的算法函数见函数部分<br>multiset 与set相似，不同就是前者支持重复对象</p>
<h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>第一个参数是数据类型，第二个参数是比较类（默认为less\<key\>,最大值优先）</key\></p>
<h4 id="基本方法-3"><a href="#基本方法-3" class="headerlink" title="基本方法"></a>基本方法</h4><ul>
<li>begin()     　　 返回set容器的第一个元素的迭代器</li>
<li>end() 　　　　 ,返回set容器的最后一个元素的迭代器</li>
<li>clear()   　　     ,删除set容器中的所有的元素</li>
<li>empty() 　　　,判断set容器是否为空</li>
<li>size() 　　　　 ,返回当前set容器中的元素个数</li>
<li>count()              用来查找set中某个某个键值出现的次数。这个函数在set并不是很实用，因为一个键值在set只可能出现0或1次，这样就变成了判断某一键值是否在set出现过了。</li>
<li>erase(key_value)    ,  删除键值key_value的值</li>
<li>find()  ，       返回给定值值得定位器，如果没找到则返回end()。</li>
<li>insert(key_value);       将key_value插入到set中 ，返回值是pair\<set\<int\>::iterator,bool>，bool标志着插入是否成功，而iterator代表插入的位置，若key_value已经在set中，则iterator表示的key_value在set中的位置。</set\<int\></li>
<li>lower_bound(key_value) ，   返回第一个大于等于key_value的定位器</li>
<li>upper_bound(key_value)，   返回最后一个大于等于key_value的定位器</li>
</ul>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>自动建立Key － value的对应，可以根据key值快速查找记录。<br>multimap 用法与map用法相似，区别在于允许出现重复的key值</p>
<h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>第一个参数key类型，第二个参数value类型，第三个参数比较类（默认less\<key\>)</key\></p>
<h4 id="基本方法-4"><a href="#基本方法-4" class="headerlink" title="基本方法"></a>基本方法</h4><ul>
<li>重载[]  可以通过下标来修改/插入key-value</li>
<li>insert(key-value)   插入键值对，可以是pair\<key,value\>对，返回一个map的迭代器</key,value\></li>
<li>find(key)     根据key来查找键值对，返回一个map的迭代器</li>
<li>count(key)     返回键为key的键值对个数</li>
<li>lower_bound(key)    返回大于等于key的一个元素的迭代器</li>
<li>upper_bound(key)   返回大于key的第一个元素的迭代器</li>
</ul>
<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>添加头文件utility<br>提供存储将两种数据合在一起的数据类型一个数据类型。</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> STL </tag>
            
            <tag> 算法模板 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Codeforces Round #412 Div 2 题解]]></title>
      <url>/2017/05/08/Codeforces-Round-412-Div-2-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>比赛链接：<a href="http://codeforces.com/contest/807" target="_blank" rel="external">http://codeforces.com/contest/807</a></p>
<a id="more"></a>
<h2 id="A-Is-it-rated"><a href="#A-Is-it-rated" class="headerlink" title="A Is it rated?"></a>A Is it rated?</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定多个比赛参与者比赛前后的积分，判断这场比赛有没有rated，对rated的定义：至少一个选手的积分发生变化，unrated定义：积分没有变化但是排名发生变化;maybe定义：分数没有变化，排名没变（非递增）</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先判断积分是否发生变化，然后判断是否非递减</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a[maxn],b[maxn];</div><div class="line">	<span class="keyword">int</span> t;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;t)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">bool</span> flag=<span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</div><div class="line">			<span class="built_in">cin</span>&gt;&gt;a[i]&gt;&gt;b[i];</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(a[i]!=b[i])</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"rated"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">				flag=<span class="number">0</span>;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(!flag)</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;a[i]&gt;a[i<span class="number">-1</span>])</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"unrated"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">				flag=<span class="number">0</span>;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(flag)</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"maybe"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="B-T-Shirt-Hunt"><a href="#B-T-Shirt-Hunt" class="headerlink" title="B T-Shirt Hunt"></a>B T-Shirt Hunt</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出一个选手这场比赛的排名和当前成绩和这场比赛可能的最差成绩，同时给出一个程序：<br>i := (s div 50) mod 475<br>repeat 25 times:<br>    i := (i * 96 + 42) mod 475<br>        print (26 + i)<br>程序输入一个积分，有25个输出每个输入表示可能的排名，问经过hacks以后达到能够输出当前排名的积分所需要进行成功的hacks次数是多少？</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>读懂题目这道题非常水，只要以50为单位不断在原来的基础进行加减直到达到符合要求的值，最后输出需要成功的hacks次数就行了</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> p)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i=(s/<span class="number">50</span>)%<span class="number">475</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">25</span>;j++)</div><div class="line">	&#123;</div><div class="line">		i=(i*<span class="number">96</span>+<span class="number">42</span>)%<span class="number">475</span>;</div><div class="line">		<span class="keyword">if</span>(<span class="number">26</span>+i==p)</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> p,x,y;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;p&gt;&gt;x&gt;&gt;y)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(fun(x,p))</div><div class="line">		&#123;</div><div class="line">			<span class="comment">//cout&lt;&lt;x&lt;&lt;endl;</span></div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">bool</span> flag=<span class="number">1</span>;</div><div class="line">		<span class="keyword">int</span> tmp=x<span class="number">-50</span>;</div><div class="line">		<span class="keyword">while</span>(tmp&gt;=y)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(fun(tmp,p))</div><div class="line">			&#123;</div><div class="line">				<span class="comment">//cout&lt;&lt;tmp&lt;&lt;endl;</span></div><div class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">                flag=<span class="number">0</span>;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			tmp-=<span class="number">50</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(!flag)</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		tmp=x+<span class="number">50</span>;</div><div class="line">		<span class="keyword">while</span>(tmp)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(fun(tmp,p))</div><div class="line">			&#123;</div><div class="line">				<span class="comment">//cout&lt;&lt;tmp&lt;&lt;endl;</span></div><div class="line">                <span class="keyword">int</span> ans=(tmp-x)/<span class="number">100</span>;</div><div class="line">				<span class="keyword">if</span>((tmp-x)%<span class="number">100</span>!=<span class="number">0</span>) ans++;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			tmp+=<span class="number">50</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="C-Success-Rate"><a href="#C-Success-Rate" class="headerlink" title="C Success Rate"></a>C Success Rate</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出两个分数：x/y p/q，定义两种操作：分子分母同时加上1；分母加上1。问要将前面的分数变成后面的分数要进行的操作数</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>前面的分数操作到后面的分数y是一定会变成q的倍数的，这样就相当于选择最小的倍数，写一个判断当前倍数是否符合条件的函数，然后再用二分法跑一边就行了，注意特判！</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judg</span><span class="params">(ll x,ll y,ll p,ll q,ll rate)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(rate*p&gt;=x &amp;&amp; rate*q-y&gt;=rate*p-x)</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(ll x,ll y,ll p,ll q,ll l,ll r)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> r;</div><div class="line">	<span class="keyword">if</span>(r==l+<span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(judg(x,y,p,q,l)) <span class="keyword">return</span> l;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(judg(x,y,p,q,r)) <span class="keyword">return</span> r;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;endl;</span></div><div class="line">	ll rate=y/q;</div><div class="line">	ll m=(l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span>(judg(x,y,p,q,m)) <span class="keyword">return</span> fun(x,y,p,q,l,m);</div><div class="line">	<span class="keyword">else</span> <span class="keyword">return</span> fun(x,y,p,q,m,r);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> t;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;t)</div><div class="line">	&#123;</div><div class="line">		ll x,y,p,q;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> id=<span class="number">0</span>;id&lt;t;id++)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;p&gt;&gt;q;</div><div class="line">			<span class="keyword">if</span>(x*q==p*y)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span>(p==q || (p==<span class="number">0</span> &amp;&amp; x!=<span class="number">0</span>)) </div><div class="line">			&#123;</div><div class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">			ll rate=fun(x,y,p,q,y/q,<span class="number">1e18</span>/q);</div><div class="line">			<span class="keyword">if</span>(rate==<span class="number">-1</span>)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;rate*q-y&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 1284 Primitive Roots 欧拉函数]]></title>
      <url>/2017/05/06/POJ-1284-Primitive-Roots-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=1284" target="_blank" rel="external">http://poj.org/problem?id=1284</a><br><a id="more"></a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>定义一个数原根x：{x^i(mod p) =1,2,…,p-1}，先给出素数p，要求p得原根个数</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这里用到了一个定理：<br>如果p有原根，则p的原根个数为Euler[Euler[p]]</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"></div><div class="line"><span class="built_in">map</span>&lt;ll,ll&gt; prime_factor(ll t)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">map</span>&lt;ll,ll&gt; ret;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=t;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">while</span>(t%i==<span class="number">0</span>) &#123; ++ret[i];t/=i; &#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(t!=<span class="number">1</span>) ret[t]=<span class="number">1</span>;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">Euler</span> <span class="params">(ll t)</span></span></div><div class="line">&#123;</div><div class="line">	ll ret=t;</div><div class="line">	<span class="built_in">map</span>&lt;ll,ll&gt; fac=prime_factor(t);</div><div class="line">	<span class="keyword">for</span>(<span class="built_in">map</span>&lt;ll,ll&gt;::iterator i=fac.begin();i!=fac.end();i++)</div><div class="line">		ret=ret*(i-&gt;first<span class="number">-1</span>)/i-&gt;first;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ll n;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n)!=EOF &amp;&amp; n)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Euler(Euler(n)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 2407 Relatives 欧拉函数]]></title>
      <url>/2017/05/06/POJ-2407-Relatives-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2407" target="_blank" rel="external">http://poj.org/problem?id=2407</a></p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个数n，求出有多少个数小于n并且与n互质，n的范围为1e9</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>裸的欧拉函数，具体的内容：<br>小于n且与n互质的数的个数=n*(1-1/P1)*(1-1/P2)….*(1-1/Pn)，其中Pn为不同的质因数<br>注意特判1的时候ans=0，不过本题没有卡这个东西</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"></div><div class="line"><span class="built_in">map</span>&lt;ll,ll&gt; prime_factor(ll t)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">map</span>&lt;ll,ll&gt; ret;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=t;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">while</span>(t%i==<span class="number">0</span>) &#123; ++ret[i];t/=i; &#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(t!=<span class="number">1</span>) ret[t]=<span class="number">1</span>;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">Euler</span> <span class="params">(ll t)</span></span></div><div class="line">&#123;</div><div class="line">	ll ret=t;</div><div class="line">	<span class="built_in">map</span>&lt;ll,ll&gt; fac=prime_factor(t);</div><div class="line">	<span class="keyword">for</span>(<span class="built_in">map</span>&lt;ll,ll&gt;::iterator i=fac.begin();i!=fac.end();i++)</div><div class="line">		ret=ret*(i-&gt;first<span class="number">-1</span>)/i-&gt;first;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ll n;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n)!=EOF &amp;&amp; n)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Euler(n));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Codeforces Round #411 (Div. 2) 题解]]></title>
      <url>/2017/05/05/Codeforces-Round-411-Div-2-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>比赛链接：<a href="http://codeforces.com/contest/805" target="_blank" rel="external">http://codeforces.com/contest/805</a></p>
<a id="more"></a>
<h2 id="A-Fake-NP"><a href="#A-Fake-NP" class="headerlink" title="A Fake NP"></a>A Fake NP</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个范围[l,r]，对于所有的从l到r的数的因子数中出现最多的因子数</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>可以发现除了范围内只有一个数，其他情况2都是出现次数最多的因子数</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> l,r;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(l==r)</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"2"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="B-3-palindrome"><a href="#B-3-palindrome" class="headerlink" title="B 3-palindrome"></a>B 3-palindrome</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>要求你创建一个仅含有a、b、c三个字符的长度为n的序列，要求序列中不含有长度为3的回文串,，并且要求含有c字符的数目尽可能少。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>“aabb”这样的字符创不断循环就不会含有长度为3的回文串</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">olve()</div><div class="line">&#123;</div><div class="line">	<span class="built_in">string</span> st=<span class="string">"aabb"</span>;</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> d=n/<span class="number">4</span>;</div><div class="line">		n%=<span class="number">4</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;d;i++)</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;st;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;st[i];</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="C-Find-Amir"><a href="#C-Find-Amir" class="headerlink" title="C Find Amir"></a>C Find Amir</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出编号为1到n的n个点，规定两点(i,j)之间的权值为(i+j)mod(n+1)，求将所有点连接起来的最小代价</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><ul>
<li>最小生成树问题，用贪心思想，发现将第1小的点和第1大的点配对，第2小的点和第2大的点配对，。。。（以此类推可以配对n/2条边）,这样的每次配对的代价都是0</li>
<li>这样两两结对以后（奇数情况下会多出一个点），再将第i大点和第i+1小的点配对，这种配对的每次代价为1。这样就可以生成一棵最小生成树，总体的代价就是后面的配对产生的代价：偶数时候为(n/2-1)，奇数的时候是n/2</li>
</ul>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(n%<span class="number">2</span>)</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;n/<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="built_in">cout</span>&lt;&lt;n/<span class="number">2</span><span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="D-Minimum-number-of-steps"><a href="#D-Minimum-number-of-steps" class="headerlink" title="D Minimum number of steps"></a>D Minimum number of steps</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给出一个只含有字符a、b的字符串，规定一次操作为将原字符串的一个’ab’子串转换成’bba’，求转换成最终无法转换的状态要进行的操作次数（对10^9+7取模）</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><ul>
<li>操作完的最终状态应该是所有的字符a都换到了字符串的最后，同时每次操作我们可以看成a向后移动一位的过程，这样的话我们可以计算每个字符a到字符串最后全是a的部分的距离来对于这个a要进行的操作次数。</li>
<li>但是每次a向后移动一位对前面的a是有影响的————每向后移动一位对于前面的a相当于增加了一个b，也就是增加了前面的a到字符串最后的距离。这样我们可以从后往前进行考虑来统一这种影响。</li>
<li>从后往前扫描，用tmp记录中间b的个数，遇到a时累加到ans中同时对tmp加倍（相当于已经将当前的a转移到了最后，这样对于前面的a来说就是增加了tmp个b）。最后的答案就是所有操作的代价ans</li>
</ul>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">string</span> a;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a)</div><div class="line">	&#123;</div><div class="line">		ll tmp=<span class="number">0</span>,ans=<span class="number">0</span>,num=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=a.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(a[i]==<span class="string">'a'</span>)</div><div class="line">			&#123;</div><div class="line">				ans=(ans+tmp)%MOD;</div><div class="line">				tmp=(<span class="number">2</span>*tmp)%MOD;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span></div><div class="line">				tmp++;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>看清题意再敲代码，B题就是因为误以为是长度&gt;=3的回文子串而导致错了两发</li>
<li>提高debug水平，D题思路一直对但是因为else分支里面的一个错误导致迟迟没有AC</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDU 5686 斐波那契数+大数]]></title>
      <url>/2017/05/04/HDU-5686-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0-%E5%A4%A7%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5686" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5686</a></p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一个全部是1组成的序列，可以合并相邻的两个1，变成一个新的序列。问总共可以构成多少种不同的序列。序列长度范围为200</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题其实列出前几个数的答案可以观察得到是一个斐波那契数，当然也可以按照下面这种方式进行理解：<br>一个序列的组合方式可以分成两种情况：第一种情况是最后一个数不考虑那么相当于前面的n-1个数的排列种树；第二种情况将最后两个数合并这样就相当于前面n-2个数的排列情况<br>斐波那契数到达200个数，要使用大数模板，套上用就行了。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> BigInt</div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> nlen=<span class="number">4</span>;  <span class="comment">//控制数组中的每一个数字的长度，为了乘法运算不溢出设定为4</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> mod=<span class="number">10000</span>;    <span class="comment">//每个数字大小设定</span></div><div class="line">    <span class="keyword">short</span> n[<span class="number">1000</span>],len;  <span class="comment">//存放数字的数组以及数组的长度</span></div><div class="line">    BigInt()<span class="comment">//没有赋值时初始化为0</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">memset</span>(n,<span class="number">0</span>,<span class="keyword">sizeof</span>(n));</div><div class="line">        len=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    BigInt(<span class="keyword">int</span> num)<span class="comment">//数字为其赋值时，将数字4位4位存放在数组当中</span></div><div class="line">    &#123;</div><div class="line">        len=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            n[len++]=num%mod;</div><div class="line">            num/=mod;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    BigInt(<span class="keyword">const</span> <span class="keyword">char</span> *s)  <span class="comment">//字符串赋值时</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> l=<span class="built_in">strlen</span>(s);</div><div class="line">        len=l%nlen==<span class="number">0</span>?l/nlen:l/nlen+<span class="number">1</span>;<span class="comment">//确定数组长度</span></div><div class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-=nlen)<span class="comment">//每次处理数组中的一位</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> tmp=<span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> j=i-nlen+<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>(j&lt;<span class="number">0</span>) j=<span class="number">0</span>;<span class="comment">//最后面数字的处理</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;=i;k++)</div><div class="line">                tmp=tmp*<span class="number">10</span>+s[k]-<span class="string">'0'</span>;</div><div class="line">            n[index++]=tmp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    BigInt <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInt &amp;b)<span class="keyword">const</span> <span class="comment">//加法操作</span></div><div class="line">    &#123;</div><div class="line">        BigInt res;</div><div class="line">        res.len=max(len,b.len);  <span class="comment">//确定位数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++)</div><div class="line">        &#123;</div><div class="line">            res.n[i]+=(i&lt;len?n[i]:<span class="number">0</span>)+(i&lt;b.len?b.n[i]:<span class="number">0</span>); <span class="comment">//对象位置相加</span></div><div class="line">            res.n[i+<span class="number">1</span>]+=res.n[i]/mod; <span class="comment">//进位处理</span></div><div class="line">            res.n[i]=res.n[i]%mod;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(res.n[res.len]&gt;<span class="number">0</span>)res.len++;  <span class="comment">//最后的结果多出一位时</span></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    BigInt <span class="keyword">operator</span>*(<span class="keyword">const</span> BigInt &amp;b)<span class="keyword">const</span>  <span class="comment">//乘法操作</span></div><div class="line">    &#123;</div><div class="line">        BigInt res;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)  <span class="comment">//模拟过程</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> up=<span class="number">0</span>;  <span class="comment">//进位存储</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b.len;j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> tmp=n[i]*b.n[i]+up+res.n[i+j];</div><div class="line">                res.n[i+j]=tmp%mod;</div><div class="line">                up=tmp/mod;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(up!=<span class="number">0</span>)  <span class="comment">//处理一遍以后还有进位</span></div><div class="line">                res.n[i+b.len]=up;</div><div class="line">        &#125;</div><div class="line">        res.len=len+b.len;  <span class="comment">//先取到位数可能最大的值</span></div><div class="line">        <span class="keyword">while</span>(res.n[res.len<span class="number">-1</span>]==<span class="number">0</span>&amp;&amp;res.len&gt;<span class="number">1</span>)res.len--;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span>  <span class="comment">//输出时的逆序输出</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,n[len<span class="number">-1</span>]);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%04d"</span>,n[i]);   <span class="comment">//注意一定要加04,确保输出四位</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    BigInt a[<span class="number">210</span>];</div><div class="line">    a[<span class="number">1</span>]=<span class="number">1</span>;</div><div class="line">    a[<span class="number">2</span>]=<span class="number">2</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;<span class="number">201</span>;i++)</div><div class="line">        a[i]=a[i<span class="number">-1</span>]+a[i<span class="number">-2</span>];</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</div><div class="line">        a[n].show();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 2429 GCD & LCM Inverse 大素数分解]]></title>
      <url>/2017/05/01/POJ-2429-GCD-LCM-Inverse-%E5%A4%A7%E7%B4%A0%E6%95%B0%E5%88%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2429" target="_blank" rel="external">http://poj.org/problem?id=2429</a></p>
<a id="more"></a>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出两个数的最大公因数和最小公倍数（数据范围2^64），求这两个数（存在多组数时输出和最小的一组数）</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我们很容易得到以下方程： (a/gcd)*(b/gcd)=(lcm/gcd)。因为(a/gcd)和(b/gcd)一定是互质的（如果不互质，gcd就要改变），这样我们就可以看成是将(lcm/gcd)分解成互质的两个数。<br>使用Pollard-Rho算法算出大整数的素因子表，为了保证分解成的两个数是互质的，将素质因子表中相同的数进行相乘，可以证明这样得到的数组内的元素之间还是互质的。<br>最后只需要对表中的元素分成两组就行了，用一个简单的DFS就可以搞定。</p>
<h3 id="代码-处于Runtime-error"><a href="#代码-处于Runtime-error" class="headerlink" title="代码(处于Runtime error )"></a>代码(处于Runtime error )</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"></div><div class="line"><span class="comment">//Miller_Rabin 算法进行素数测试</span></div><div class="line"><span class="comment">//速度快，而且可以判断 &lt;2^63的数</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> S=<span class="number">20</span>; <span class="comment">//随机算法判定次数</span></div><div class="line"></div><div class="line"><span class="comment">//计算 (a*b)%c  加法快速幂</span></div><div class="line"><span class="function">ll <span class="title">mul_mod</span><span class="params">(ll a,ll b,ll c)</span></span></div><div class="line">&#123;</div><div class="line">	a%=c;</div><div class="line">	b%=c;</div><div class="line">	ll ret=<span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(b)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)</div><div class="line">			ret+=a,ret%=c;</div><div class="line">		a&lt;&lt;=<span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span>(a&gt;=c)a%=c;</div><div class="line">		b&gt;&gt;=<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 计算x^n %c</span></div><div class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll x,ll n,ll mod)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> x%mod;</div><div class="line">	x%=mod;</div><div class="line">	ll tmp=x;</div><div class="line">	ll ret=<span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(n)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) ret=mul_mod(ret,tmp,mod);</div><div class="line">		tmp=mul_mod(tmp,tmp,mod);</div><div class="line">		n&gt;&gt;=<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//以a为基,n-1=x*2^t      a^(n-1)=1(mod n)  验证n是不是合数</span></div><div class="line"><span class="comment">//一定是合数返回true,不一定返回false</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll a,ll n,ll x,ll t)</span></span></div><div class="line">&#123;</div><div class="line">	ll ret=pow_mod(a,x,n);</div><div class="line">	ll last=ret;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</div><div class="line">	&#123;</div><div class="line">		ret=mul_mod(ret,ret,n);</div><div class="line">		<span class="keyword">if</span>(ret==<span class="number">1</span> &amp;&amp; last!=<span class="number">1</span> &amp;&amp; last!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		last=ret;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(ret!=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Miller_Rabin()算法素数判定</span></div><div class="line"><span class="comment">//是素数返回true.(可能是伪素数，但概率极小)</span></div><div class="line"><span class="comment">//合数返回false;</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(ll n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//偶数</span></div><div class="line">	ll x=n<span class="number">-1</span>,t=<span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(!(x&amp;<span class="number">1</span>)) </div><div class="line">	&#123;</div><div class="line">		x&gt;&gt;=<span class="number">1</span>;</div><div class="line">		t++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S;i++)</div><div class="line">	&#123;</div><div class="line">		ll a=rand()%(n<span class="number">-1</span>)+<span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span>(check(a,n,x,t))</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// pollard_rho 算法进行质因数分解</span></div><div class="line">ll factor[<span class="number">10000</span>];   <span class="comment">//分解结果</span></div><div class="line"><span class="keyword">int</span> tol;    <span class="comment">//分解个数</span></div><div class="line"></div><div class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(a==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span>(a&lt;<span class="number">0</span>) <span class="keyword">return</span> gcd(-a,b);</div><div class="line">	<span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">Pollard_rho</span><span class="params">(ll x,ll c)</span></span></div><div class="line">&#123;</div><div class="line">	ll i=<span class="number">1</span>,k=<span class="number">2</span>;</div><div class="line">	ll x0=rand()%x;</div><div class="line">	ll y=x0;</div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		i++;</div><div class="line">        x0=(mul_mod(x0,x0,x)+c)%x;</div><div class="line">        ll d=gcd(y-x0,x);</div><div class="line">        <span class="keyword">if</span>(d!=<span class="number">1</span>&amp;&amp;d!=x) <span class="keyword">return</span> d;</div><div class="line">        <span class="keyword">if</span>(y==x0) <span class="keyword">return</span> x;</div><div class="line">        <span class="keyword">if</span>(i==k)&#123;y=x0;k+=k;&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//对n进行素因子分解</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">findfac</span><span class="params">(ll n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(Miller_Rabin(n))</div><div class="line">	&#123;</div><div class="line">		factor[tol++]=n;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	ll p=n;</div><div class="line">    <span class="keyword">while</span>(p&gt;=n)p=Pollard_rho(p,rand()%(n<span class="number">-1</span>)+<span class="number">1</span>);</div><div class="line">    findfac(p);</div><div class="line">    findfac(n/p);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//DFS 求数</span></div><div class="line">ll min_sum;   <span class="comment">//和的最小值设置为全局变量</span></div><div class="line">ll ansa,ansb;</div><div class="line">ll factor_new[<span class="number">10000</span>],num1;  <span class="comment">//将重复素因子相乘以后的表</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll tmpa,ll tmpb,ll pos,<span class="keyword">const</span> ll len)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(pos==len)</div><div class="line">	&#123;</div><div class="line">        <span class="keyword">if</span>(tmpa+tmpb&lt;=min_sum)</div><div class="line">		    ansa=tmpa,ansb=tmpb;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		dfs(tmpa*factor_new[pos],tmpb,pos+<span class="number">1</span>,len);</div><div class="line">		dfs(tmpa,tmpb*factor_new[pos],pos+<span class="number">1</span>,len);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ll a,b;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;a,&amp;b)!=EOF)</div><div class="line">	&#123;</div><div class="line">		num1=<span class="number">0</span>;</div><div class="line">		b/=a;</div><div class="line">		findfac(b);</div><div class="line">		sort(factor,factor+tol);    </div><div class="line">		factor_new[<span class="number">0</span>]=factor[<span class="number">0</span>];</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;tol;i++)                    <span class="comment">//除去重复素因子</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(factor[i]==factor[i<span class="number">-1</span>])</div><div class="line">				factor_new[num1]*=factor[i];</div><div class="line">			<span class="keyword">else</span></div><div class="line">				factor_new[++num1]=factor[i];</div><div class="line">		&#125;</div><div class="line">		min_sum=factor_new[<span class="number">0</span>]+b/factor_new[<span class="number">0</span>];</div><div class="line">		dfs(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,num1+<span class="number">1</span>);    <span class="comment">//dfs 枚举结果</span></div><div class="line">		<span class="keyword">if</span>(ansa&gt;ansb) swap(ansa,ansb);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>,ansa*a,ansb*a);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line"></div><div class="line">    <span class="comment">//test();</span></div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 1811 Prime Test /Miller-Rabin素数测试+Pollard Rho 大整数分解]]></title>
      <url>/2017/05/01/POJ-1811-Prime-Test-Miller-Rabin%E7%B4%A0%E6%95%B0%E6%B5%8B%E8%AF%95-Pollard-Rho-%E5%A4%A7%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>题目连接：<a href="http://poj.org/problem?id=1811" target="_blank" rel="external">http://poj.org/problem?id=1811</a></p>
<a id="more"></a>
<h3 id="Miller-Rabin素数测试"><a href="#Miller-Rabin素数测试" class="headerlink" title="Miller-Rabin素数测试"></a>Miller-Rabin素数测试</h3><p>该算法是随机算法，可以用来检测一个很大的数字（2^64范围)是不是素数。主要基于两个定理：费马小定理和二次探测定理<br>学习链接：<br><a href="https://www.cnblogs.com/jianglangcaijin/p/3446859.html" target="_blank" rel="external">Miller-Rabin素数测试学习小计</a><br><a href="https://www.cnblogs.com/vongang/archive/2012/03/15/2398626.html" target="_blank" rel="external">Miller-Rabin素数测试学习笔记</a><br><a href="https://www.cnblogs.com/kuangbin/archive/2012/08/19/2646404.html" target="_blank" rel="external">kuangbin 模板</a></p>
<h3 id="Pollard-Rho-大整数分解"><a href="#Pollard-Rho-大整数分解" class="headerlink" title="Pollard Rho 大整数分解"></a>Pollard Rho 大整数分解</h3><p>该算法是试除法和筛选法之外对比较大的整数的分解算法<br>学习链接：<br><a href="http://www.voidcn.com/blog/fsqfang/article/p-3803935.html" target="_blank" rel="external">Pollard Rho 大整数分解</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个非常大的数（2^54范围），如果这个数是素数，则输出Prime ，否则输出其最小的素因子</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>套用Miller-Rabin算法和Pollard-rho算法的模板题</p>
<h3 id="代码（模板）"><a href="#代码（模板）" class="headerlink" title="代码（模板）"></a>代码（模板）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Miller_Rabin 算法进行素数测试</span></div><div class="line"><span class="comment">//速度快，而且可以判断 &lt;2^63的数</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> S=<span class="number">20</span>; <span class="comment">//随机算法判定次数</span></div><div class="line"></div><div class="line"><span class="comment">//计算 (a*b)%c  加法快速幂</span></div><div class="line"><span class="function">ll <span class="title">mul_mod</span><span class="params">(ll a,ll b,ll c)</span></span></div><div class="line">&#123;</div><div class="line">	a%=c;</div><div class="line">	b%=c;</div><div class="line">	ll ret=<span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(b)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)</div><div class="line">			ret+=a,ret%=c;</div><div class="line">		a&lt;&lt;=<span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span>(a&gt;=c)a%=c;</div><div class="line">		b&gt;&gt;=<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 计算x^n %c</span></div><div class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll x,ll n,ll mod)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> x%mod;</div><div class="line">	x%=mod;</div><div class="line">	ll tmp=x;</div><div class="line">	ll ret=<span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(n)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) ret=mul_mod(ret,tmp,mod);</div><div class="line">		tmp=mul_mod(tmp,tmp,mod);</div><div class="line">		n&gt;&gt;=<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//以a为基,n-1=x*2^t      a^(n-1)=1(mod n)  验证n是不是合数</span></div><div class="line"><span class="comment">//一定是合数返回true,不一定返回false</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll a,ll n,ll x,ll t)</span></span></div><div class="line">&#123;</div><div class="line">	ll ret=pow_mod(a,x,n);</div><div class="line">	ll last=ret;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</div><div class="line">	&#123;</div><div class="line">		ret=mul_mod(ret,ret,n);</div><div class="line">		<span class="keyword">if</span>(ret==<span class="number">1</span> &amp;&amp; last!=<span class="number">1</span> &amp;&amp; last!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		last=ret;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(ret!=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Miller_Rabin()算法素数判定</span></div><div class="line"><span class="comment">//是素数返回true.(可能是伪素数，但概率极小)</span></div><div class="line"><span class="comment">//合数返回false;</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(ll n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//偶数</span></div><div class="line">	ll x=n<span class="number">-1</span>,t=<span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(!(x&amp;<span class="number">1</span>)) </div><div class="line">	&#123;</div><div class="line">		x&gt;&gt;=<span class="number">1</span>;</div><div class="line">		t++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S;i++)</div><div class="line">	&#123;</div><div class="line">		ll a=rand()%(n<span class="number">-1</span>)+<span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span>(check(a,n,x,t))</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// pollard_rho 算法进行质因数分解</span></div><div class="line">ll factor[<span class="number">100</span>];   <span class="comment">//分解结果</span></div><div class="line"><span class="keyword">int</span> tol;    <span class="comment">//分解个数</span></div><div class="line"></div><div class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(a==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span>(a&lt;<span class="number">0</span>) <span class="keyword">return</span> gcd(-a,b);</div><div class="line">	<span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">Pollard_rho</span><span class="params">(ll x,ll c)</span></span></div><div class="line">&#123;</div><div class="line">	ll i=<span class="number">1</span>,k=<span class="number">2</span>;</div><div class="line">	ll x0=rand()%x;</div><div class="line">	ll y=x0;</div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		i++;</div><div class="line">        x0=(mul_mod(x0,x0,x)+c)%x;</div><div class="line">        ll d=gcd(y-x0,x);</div><div class="line">        <span class="keyword">if</span>(d!=<span class="number">1</span>&amp;&amp;d!=x) <span class="keyword">return</span> d;</div><div class="line">        <span class="keyword">if</span>(y==x0) <span class="keyword">return</span> x;</div><div class="line">        <span class="keyword">if</span>(i==k)&#123;y=x0;k+=k;&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//对n进行素因子分解</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">findfac</span><span class="params">(ll n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(Miller_Rabin(n))</div><div class="line">	&#123;</div><div class="line">		factor[tol++]=n;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	ll p=n;</div><div class="line">    <span class="keyword">while</span>(p&gt;=n)p=Pollard_rho(p,rand()%(n<span class="number">-1</span>)+<span class="number">1</span>);</div><div class="line">    findfac(p);</div><div class="line">    findfac(n/p);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> t;</div><div class="line">	ll n;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</div><div class="line">	<span class="keyword">while</span>(t--)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</div><div class="line">		<span class="keyword">if</span>(Miller_Rabin(n))</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"Prime\n"</span>);</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		tol=<span class="number">0</span>;</div><div class="line">		findfac(n);</div><div class="line">		ll ans=factor[<span class="number">0</span>];</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;tol;i++)</div><div class="line">			ans=min(ans,factor[i]);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 2689 Prime Distance 埃拉托色尼筛法]]></title>
      <url>/2017/04/30/POJ-2689-Prime-Distance-%E5%9F%83%E6%8B%89%E6%89%98%E8%89%B2%E5%B0%BC%E7%AD%9B%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2689" target="_blank" rel="external">http://poj.org/problem?id=2689</a></p>
<a id="more"></a>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个区间[L,R],求这个区间内的连续两个素数之间的差最大和最小的两个素数，范围限制为1&lt;=L&lt; U&lt;=2,147,483,647。但是所给的区间长度不会超过1000000。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对于这个范围，全部筛选打表是不现实的，想到了只对区间内的素数进行筛选。这里用到了一个埃拉托色尼筛法的定理：<strong>如果n是一个合数，那么n一定有一个不超过sqrt(n)的素因子</strong>。这样我们只需要对前面5万个数的素数进行打表就行了。<br>枚举前面的素数，将对应区间内的合数进行删除，达到筛选的目的。同时计算素数对应到区间的倍数避免一个一个枚举，实现加速。<br>要注意新素数表中一些细节的处理，比如说排除值为1的情况。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000003</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxp=<span class="number">50050</span>;</div><div class="line"><span class="keyword">bool</span> is_prime[maxp];</div><div class="line"><span class="keyword">int</span> prime[maxp],num;</div><div class="line"><span class="keyword">bool</span> is_prime2[maxn];</div><div class="line">ll prime2[maxn],num2;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime_init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	num=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(is_prime,<span class="literal">true</span>,<span class="keyword">sizeof</span>(is_prime));</div><div class="line">	is_prime[<span class="number">0</span>]=is_prime[<span class="number">1</span>]=<span class="literal">false</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxp;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(is_prime[i]) prime[num++]=i;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num &amp;&amp; i*prime[j]&lt;maxp;j++)</div><div class="line">		&#123;</div><div class="line">			is_prime[i*prime[j]]=<span class="literal">false</span>;</div><div class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bigger_prime</span><span class="params">(ll L,ll R)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">memset</span>(is_prime2,<span class="number">1</span>,<span class="keyword">sizeof</span>(is_prime2));</div><div class="line">    ll mul;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num &amp;&amp; prime[i]&lt;=R;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(prime[i]&lt;=L)</div><div class="line">            mul=(L-prime[i])/prime[i];           <span class="comment">//获得相差的倍数</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            mul=<span class="number">2</span>;</div><div class="line">		<span class="keyword">while</span>(mul*prime[i]&lt;L || mul&lt;=<span class="number">1</span>) mul++;     <span class="comment">//修正倍数值,不能够等于一</span></div><div class="line">		<span class="keyword">for</span>(ll j=mul*prime[i];j&lt;=R;j+=prime[i])</div><div class="line">			<span class="keyword">if</span>(j&gt;=L)</div><div class="line">                is_prime2[j-L]=<span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">    num2=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=R-L;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(is_prime2[i])</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i+L==<span class="number">1</span>) <span class="keyword">continue</span>;   <span class="comment">//注意要排除1这个不是素数的数</span></div><div class="line">            prime2[num2++]=i+L;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ll L,R;</div><div class="line">	prime_init();</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;L,&amp;R)!=EOF)</div><div class="line">	&#123;</div><div class="line">		bigger_prime(L,R);</div><div class="line">		ll maxv=<span class="number">0</span>,minv=INF,maxid,minid;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num2<span class="number">-1</span>;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(maxv&lt;prime2[i+<span class="number">1</span>]-prime2[i])</div><div class="line">                maxv=prime2[i+<span class="number">1</span>]-prime2[i],maxid=i;</div><div class="line">            <span class="keyword">if</span>(minv&gt;prime2[i+<span class="number">1</span>]-prime2[i])</div><div class="line">                minv=prime2[i+<span class="number">1</span>]-prime2[i],minid=i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(num2&lt;<span class="number">2</span>)</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"There are no adjacent primes.\n"</span>);</div><div class="line">		<span class="keyword">else</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%lld,%lld are closest, %lld,%lld are most distant.\n"</span>,prime2[minid],prime2[minid+<span class="number">1</span>],prime2[maxid],prime2[maxid+<span class="number">1</span>]);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 1730 Perfect Pth Powers 素数分解]]></title>
      <url>/2017/04/30/POJ-1730-Perfect-Pth-Powers-%E7%B4%A0%E6%95%B0%E5%88%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>题目链接： <a href="http://poj.org/problem?id=1730" target="_blank" rel="external">http://poj.org/problem?id=1730</a></p>
<a id="more"></a>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>如果一个数x能够被表示成b^p这样的形式，称x为完美p次方数，现在给出x求最大的p使得其为一个完美p次方树</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>利用素数分解，如果x为正数的话，最大的p就是这个数的素因子幂级数的最大公因数。<br>如果x为奇数的话，先转化为正数进行计算，最后将结果不断除2直到变成奇数。因为偶次方是不可能得到一个正数的。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">t ll maxp=<span class="number">100003</span>;</div><div class="line"><span class="keyword">bool</span> is_prime[maxp];</div><div class="line"><span class="keyword">int</span> prime[maxp],num;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime_init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	num=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(is_prime,<span class="literal">true</span>,<span class="keyword">sizeof</span>(is_prime));</div><div class="line">	is_prime[<span class="number">0</span>]=is_prime[<span class="number">1</span>]=<span class="literal">false</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxp;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(is_prime[i]) prime[num++]=i;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num &amp;&amp; i*prime[j]&lt;maxp;j++)</div><div class="line">		&#123;</div><div class="line">			is_prime[i*prime[j]]=<span class="literal">false</span>;</div><div class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ll x;</div><div class="line">	prime_init();</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x)!=EOF &amp;&amp; x)</div><div class="line">	&#123;</div><div class="line">		ll ans=<span class="number">-1</span>,i=<span class="number">0</span>,tmp;</div><div class="line">		<span class="keyword">bool</span> flag=<span class="number">0</span>;</div><div class="line">		<span class="keyword">if</span>(x&lt;<span class="number">0</span>)</div><div class="line">			x=-x,flag=<span class="number">1</span>;</div><div class="line">		<span class="keyword">while</span>(x!=<span class="number">1</span> &amp;&amp; i&lt;num<span class="number">-1</span>)</div><div class="line">		&#123;</div><div class="line">			tmp=<span class="number">0</span>;</div><div class="line">			<span class="keyword">while</span>(x%prime[i]==<span class="number">0</span>)</div><div class="line">			&#123;</div><div class="line">				tmp++;</div><div class="line">				x/=prime[i];</div><div class="line">			&#125;</div><div class="line">			i++;</div><div class="line">			ans=ans==<span class="number">-1</span>?tmp:gcd(ans,tmp);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(x!=<span class="number">1</span>) ans=<span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span>(flag)      <span class="comment">//如果是负数的话将ans变为奇数</span></div><div class="line">			<span class="keyword">while</span>(ans%<span class="number">2</span>==<span class="number">0</span>)</div><div class="line">				ans/=<span class="number">2</span>;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Codeforces Educational Round 20 题解]]></title>
      <url>/2017/04/30/Codeforces-Educational-Round-20-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>比赛链接：<a href="http://codeforces.com/contest/803" target="_blank" rel="external">http://codeforces.com/contest/803</a></p>
<a id="more"></a>
<h2 id="A-Maximal-Binary-Matrix"><a href="#A-Maximal-Binary-Matrix" class="headerlink" title="A Maximal Binary Matrix"></a>A Maximal Binary Matrix</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个n*n的全0矩阵，用k个1进行填充，使得填充后的矩阵是对称的并且还是字典序最大的（第一矩阵的字典序大于另一个矩阵定义：从上往下的第一个不同行的第一个不同数字前者大于后者）。最后要求输出这个矩阵</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>模拟填充过程，从上往下、从左往右依次进行填充。一次填充填充对称位置的两个点。<br>无解情况：填充数大于矩阵中点的个数</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i][j]);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;             </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n,k;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</div><div class="line">		<span class="keyword">if</span>(k&gt;n*n)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"-1\n"</span>); </div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span>(i==j &amp;&amp; k&gt;<span class="number">0</span>)</div><div class="line">				&#123;</div><div class="line">					a[i][i]=<span class="number">1</span>;</div><div class="line">					k--;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span>(i!=j &amp;&amp; !a[i][j] &amp;&amp; k&gt;<span class="number">1</span>)</div><div class="line">				&#123;</div><div class="line">					a[i][j]=a[j][i]=<span class="number">1</span>;</div><div class="line">					k-=<span class="number">2</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		out(n);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="B-Distances-to-Zero"><a href="#B-Distances-to-Zero" class="headerlink" title="B Distances to Zero"></a>B Distances to Zero</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出一个序列，求序列中各个元素的值到最近的元素值为0的元素的距离</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>我想到的方法是从序列中的元素值为0的位置出发，不断更新周围元素到0的距离，直到出界或者找到新的0为止<br>看到一个大牛的方法是，从左到右进行一次遍历，通过元素与左边的0的最小距离来更新距离值，再从右向左遍历一次，通过元素与右边的0的最小距离再更新一次距离值。<br>虽然两者的时间复杂度都是O(n)，但是明显后者的代码量和简介程度都比前者更优</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</div><div class="line">	&#123;</div><div class="line">        fill(b,b+n,n);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">			<span class="built_in">cin</span>&gt;&gt;a[i];</div><div class="line">		<span class="keyword">int</span> lst=-n;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(a[i]==<span class="number">0</span>)</div><div class="line">				lst=i;</div><div class="line">			b[i]=min(b[i],i-lst);</div><div class="line">		&#125;</div><div class="line">		lst=<span class="number">2</span>*n;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(a[i]==<span class="number">0</span>)</div><div class="line">				lst=i;</div><div class="line">			b[i]=min(b[i],lst-i);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,b[i]);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="C-Maximal-GCD"><a href="#C-Maximal-GCD" class="headerlink" title="C Maximal GCD"></a>C Maximal GCD</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给出一个正整数n和k，要求将n分解成一个严格递增的序列，并且使得这个序列的最大公因数尽可能大</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><ul>
<li>先给出最大公因数一个范围，再枚举范围内的值，考虑合法性，选取最优解</li>
<li>求最大公因数的范围用到了一个贪心思想，因为序列是严格递增的，最大只所对应的序列就应该是1到k倍公因数的值进行排列</li>
<li>枚举的值是否合法无非就是判断是否能够整除n</li>
<li>!!防止越界，对于超过int范围的题目，所有的变量声明都用long long !! </li>
</ul>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ll n,k;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(k&gt;(ll)<span class="number">1e8</span>)     <span class="comment">//分割的段数过大不存在解</span></div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);	</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		ll b=n/(k*(k+<span class="number">1</span>)/<span class="number">2</span>);</div><div class="line">		<span class="keyword">if</span>(b==<span class="number">0</span>)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line">		ll r=<span class="number">1</span>;       <span class="comment">//最大公因数</span></div><div class="line">		<span class="keyword">for</span>(ll x=<span class="number">1</span>;x*x&lt;=n;x++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(n%x!=<span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">			<span class="keyword">if</span>(x&lt;=b &amp;&amp; x&gt;r) r=x;</div><div class="line">			<span class="keyword">if</span>(n/x&lt;=b &amp;&amp; n/x&gt;r) r=n/x;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;k;i++)</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;i*r&lt;&lt;<span class="string">" "</span>;</div><div class="line">		ll tmp=n-(k*(k<span class="number">-1</span>)/<span class="number">2</span>)*r;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;tmp&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[月亮湾 游记]]></title>
      <url>/2017/04/29/%E6%9C%88%E4%BA%AE%E6%B9%BE-%E6%B8%B8%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>挺过学校变态的一周三场考试，终于迎来了五一假，出去浪的心油然而生。加上最近前段时间换了一辆山地车，所以就有了这波游玩。拉上两个同学来了一场短途骑行。</p>
<a id="more"></a>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>这次我们去的是月亮湾风景区，一个普通的看山山水水的地方。离学校直线距离26km，导航距离32km。贴吧上看学长骑过这条路线，觉得风景不错，就准备了这次骑行。路程的一大半是在省道上，一半是在那种山间小路上，我们主要享受的山间小路上的风景。</p>
<h3 id="出发"><a href="#出发" class="headerlink" title="出发"></a>出发</h3><p>因为一些原因，原计划早上出发的变成了下午3点出发。那时刚好是太阳比较大的时候，但是气温不是很高，所以整体上不是很热。因为一个同学是第一次骑这么长的距离，加上车子存在一些问题（很久没有上油了），我们在去的路上走走停停花了三个多小时。我因为一开始买的都是水，没有买什么补充能量的东西，骑到后面一段距离的时候就有点吃力了。<br>印象比较深的是，靠近目的地有一段非常大而且坡度也比较大的斜坡，一不小心车速就达到了50km/h创下了我骑车的最快速度。那个感觉不要太爽。<br><img src="http://oeziv5rwi.bkt.clouddn.com/2017/4/29/001.png" alt=""></p>
<h3 id="游玩"><a href="#游玩" class="headerlink" title="游玩"></a>游玩</h3><p>因为我们骑到月亮湾的时候已经下午六点多了，天马上就要黑了，所以只有先休息一晚，第二天再考虑玩的事情。我们找了一个当地的小旅馆，价格不错，老板人不错。<br>解决晚餐问题之后我们在镇子的周围逛了逛。比较尴尬的是我们骑出去一公里的时候一个同学的车坏了，后轮根本动不了。没有办法只有两个人抬一辆车，另一个人推两辆车回到镇子上修。到了镇子上又发现那些摩托车维修的店子都关门了，看来要我们自己动手了。幸好旅店的老板来帮了一下我们提供了我们很多工具。最好没有解决根本问题，但是车子可以骑了，所以决定回去以后再说。<br>第二天一早，我们就开始骑向所谓的风景区。其实就是一条沿河而行的风景比较优美的公路。风景比路上的风景好一点点。<br><img src="http://oeziv5rwi.bkt.clouddn.com/2017/4/29/003.jpg" alt=""><br><img src="http://oeziv5rwi.bkt.clouddn.com/2017/4/29/004.jpg" alt=""><br><img src="http://oeziv5rwi.bkt.clouddn.com/2017/4/29/005.jpg" alt=""></p>
<h3 id="返程"><a href="#返程" class="headerlink" title="返程"></a>返程</h3><p>大概在风景区里面逛了一下（走了10km左右），我们就准备返程了。主要是因为下午比较热，而且这次旅行的主要目的就是享受骑行沿途的风景。吸取来的时候的教训，我准备了一些补充能量的巧克力和运动饮料。返程的整体车速比较快，在s322省道基本上车速能够保持在25km/h左右，下坡的时候在40km/h左右。除此之外我们在返程的途中只休息了一次，所以回来用了不到两个小时的时间。看来在去的时候路上休息的时间太长了。<br><img src="http://oeziv5rwi.bkt.clouddn.com/2017/4/29/002.png" alt=""></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>骑车出游车要修好，保证不要在路上出问题</li>
<li>出发前准备好补充水分和能量的东西</li>
<li>风景很美，心情很好，下次再来！</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 杂记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 3126 Prime Path 素数打表+BFS]]></title>
      <url>/2017/04/26/POJ-3126-Prime-Path-%E7%B4%A0%E6%95%B0%E6%89%93%E8%A1%A8-BFS/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=3126" target="_blank" rel="external">http://poj.org/problem?id=3126</a></p>
<a id="more"></a>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一次操作的定义，将一个四位数的一位转换成另外一位数字（不含前导0）。同时给出两位素数，求中间需要进过多少次这样的操作才能够从开始的哪一位素数达到后面的那一位素数，而且必须满足中间进过的数都是素数.</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul>
<li>使用BFS搜索路径，同时记录搜索路径的长度</li>
<li>用结构体将一个数和搜索到这个数是已经走过的步数绑定起来</li>
<li>数字用string表示，便于进行操作，只需对对应的字符进行操作即可</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10005</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxp=<span class="number">10005</span>;</div><div class="line"><span class="keyword">bool</span> is_prime[maxp];</div><div class="line"><span class="keyword">int</span> prime[maxp],num;</div><div class="line"><span class="keyword">int</span> visit[maxn];</div><div class="line"><span class="keyword">struct</span> poin</div><div class="line">&#123;</div><div class="line">	<span class="built_in">string</span> num;</div><div class="line">	<span class="keyword">int</span> step;</div><div class="line">	poin(<span class="built_in">string</span> num,<span class="keyword">int</span> step):num(num),step(step) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>    <span class="comment">//欧拉筛选素数打表</span></span></div><div class="line">&#123;</div><div class="line">	num=<span class="number">0</span>;</div><div class="line">    <span class="built_in">memset</span>(is_prime,<span class="literal">true</span>,<span class="keyword">sizeof</span>(is_prime));</div><div class="line">	is_prime[<span class="number">0</span>]=is_prime[<span class="number">1</span>]=<span class="literal">false</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxp;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(is_prime[i]) prime[num++]=i;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num &amp;&amp; i*prime[j]&lt;maxp;j++)</div><div class="line">		&#123;</div><div class="line">			is_prime[i*prime[j]]=<span class="literal">false</span>;</div><div class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> t;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;t;</div><div class="line">	<span class="built_in">string</span> a,b;</div><div class="line">	<span class="keyword">while</span>(t--)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</div><div class="line">		<span class="keyword">int</span> ans=<span class="number">-1</span>;</div><div class="line">		init();</div><div class="line">		<span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</div><div class="line">		<span class="built_in">queue</span>&lt;poin&gt; que;</div><div class="line">		que.push(poin(a,<span class="number">0</span>));</div><div class="line">		<span class="keyword">while</span>(!que.empty())</div><div class="line">		&#123;</div><div class="line">			poin p=que.front();</div><div class="line">			que.pop();</div><div class="line">			<span class="keyword">if</span>(p.num==b)</div><div class="line">			&#123;</div><div class="line">				ans=p.step;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">int</span> be= (i==<span class="number">0</span>)?<span class="number">1</span>:<span class="number">0</span>;</div><div class="line">				<span class="built_in">string</span> c=p.num;</div><div class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=be;j&lt;<span class="number">10</span>;j++)</div><div class="line">				&#123;</div><div class="line">					c[i]=j+<span class="string">'0'</span>;</div><div class="line">					<span class="keyword">int</span> next=atoi(c.c_str());</div><div class="line">					<span class="keyword">if</span>(!visit[next] &amp;&amp; is_prime[next] &amp;&amp;c!=p.num)  <span class="comment">//防止出不来了</span></div><div class="line">					&#123;</div><div class="line">						<span class="comment">//cout&lt;&lt;c&lt;&lt;endl;</span></div><div class="line">						visit[next]=<span class="number">1</span>;</div><div class="line">						que.push(poin(c,p.step+<span class="number">1</span>));</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 2739 素数打表+暴力枚举]]></title>
      <url>/2017/04/24/POJ-2739-%E7%B4%A0%E6%95%B0%E6%89%93%E8%A1%A8-%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/</url>
      <content type="html"><![CDATA[<p>题目连接：<a href="http://poj.org/problem?id=2739" target="_blank" rel="external">http://poj.org/problem?id=2739</a></p>
<a id="more"></a>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个数，问其有多少种方案能够分解成连续多个素数的和</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>因为这道题的数据规模只有10000所以完全可以暴力解决，首先使用欧拉筛选得到素数表，枚举所有在数据范围内的连续素数和，打表。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxp=<span class="number">10005</span>;</div><div class="line"><span class="keyword">bool</span> is_prime[maxp];</div><div class="line"><span class="keyword">int</span> prime[maxp],num;</div><div class="line"><span class="keyword">int</span> a[maxp];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>    <span class="comment">//欧拉筛选素数打表</span></span></div><div class="line">&#123;</div><div class="line">	num=<span class="number">0</span>;</div><div class="line">    <span class="built_in">memset</span>(is_prime,<span class="literal">true</span>,<span class="keyword">sizeof</span>(is_prime));</div><div class="line">	is_prime[<span class="number">0</span>]=is_prime[<span class="number">1</span>]=<span class="literal">false</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxp;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(is_prime[i]) prime[num++]=i;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num &amp;&amp; i*prime[j]&lt;maxp;j++)</div><div class="line">		&#123;</div><div class="line">			is_prime[i*prime[j]]=<span class="literal">false</span>;</div><div class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span>  <span class="comment">//枚举所有的连续素数和，打表</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</div><div class="line">	<span class="keyword">int</span> tmp;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;num;j++)</div><div class="line">		&#123;</div><div class="line">			tmp=<span class="number">0</span>;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j;k++)</div><div class="line">				tmp+=prime[k];</div><div class="line">			<span class="keyword">if</span>(tmp&lt;maxp)</div><div class="line">				a[tmp]++;</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> t;</div><div class="line">	init();</div><div class="line">	fun();</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t)!=EOF &amp;&amp; t)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[t]);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 2034 Anti-prime Sequences 素数+DFS回溯]]></title>
      <url>/2017/04/23/POJ-2034-Anti-prime-Sequences-%E7%B4%A0%E6%95%B0-DFS%E5%9B%9E%E6%BA%AF/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=2034" target="_blank" rel="external">http://poj.org/problem?id=2034</a></p>
<a id="more"></a>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个序列: {n,n+1,n+2,…,m} 现在对这个序列进行重新排序，使得每相邻2、3、。。。、d个数都是合数</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑使用回溯法，从第一个开始往后排。判断一个数num是否能够排在pos位置的方法（pos前面的数已经确定好了）是从这个数开始不断向前加一个数，只要这个和是素数就可以得到这个位置不能排这个数。<br>回溯法套用的就是生成全排列的那种方法。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">ol is_prime[maxp];</div><div class="line"><span class="keyword">int</span> prime[maxp],num;</div><div class="line"><span class="keyword">int</span> n,m,d;</div><div class="line"><span class="keyword">bool</span> visit[maxn];</div><div class="line"><span class="keyword">int</span> ans[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	num=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(is_prime,<span class="literal">true</span>,<span class="keyword">sizeof</span>(is_prime));</div><div class="line">	is_prime[<span class="number">0</span>]=is_prime[<span class="number">1</span>]=<span class="literal">false</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxp;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(is_prime[i]) prime[num++]=i;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num &amp;&amp; i*prime[j]&lt;maxp;j++)</div><div class="line">		&#123;</div><div class="line">			is_prime[i*prime[j]]=<span class="literal">false</span>;</div><div class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> nu)</span>  <span class="comment">//判断pos位置放置num值是否可行</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(pos==<span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">int</span> l=pos-d+<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(l&lt;<span class="number">0</span>)</div><div class="line">        l=<span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> sum=nu;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=pos<span class="number">-1</span>;i&gt;=l;i--)</div><div class="line">	&#123;</div><div class="line">		sum+=ans[i];</div><div class="line">		<span class="keyword">if</span>(is_prime[sum])</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(u==m-n+<span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;=m;i++)  <span class="comment">//枚举每个可以插入的数</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(!visit[i] &amp;&amp; judge(u,i))</div><div class="line">		&#123;</div><div class="line">			ans[u]=i;    <span class="comment">//记录下来为考虑后面的数做准备</span></div><div class="line">			visit[i]=<span class="literal">true</span>;</div><div class="line">			<span class="keyword">if</span>(dfs(u+<span class="number">1</span>))</div><div class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">			visit[i]=<span class="literal">false</span>; <span class="comment">// 回溯</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	init();</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;d)!=EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>&amp;&amp;d==<span class="number">0</span>)</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="built_in">memset</span>(visit,<span class="literal">false</span>,<span class="keyword">sizeof</span>(visit));</div><div class="line">		<span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</div><div class="line">		<span class="keyword">if</span>(dfs(<span class="number">0</span>))</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m-n+<span class="number">1</span>;i++)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans[i]);</div><div class="line">				<span class="keyword">if</span>(i!=m-n)</div><div class="line">					<span class="built_in">printf</span>(<span class="string">","</span>);</div><div class="line">			&#125;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="built_in">printf</span>(<span class="string">"No anti-prime sequence exists.\n"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学专题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Codeforces #410 题解]]></title>
      <url>/2017/04/22/Codeforces-410-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>比赛题目链接：<a href="http://codeforces.com/contest/798" target="_blank" rel="external">http://codeforces.com/contest/798</a></p>
<a id="more"></a>
<h2 id="798A-Mike-and-palindrome"><a href="#798A-Mike-and-palindrome" class="headerlink" title="798A - Mike and palindrome"></a>798A - Mike and palindrome</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一个字符串，判断是否能够只改变一个字符使得这个字符串变成一个回文串</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目要求必须改变一个字符串（一开始被这个坑了），所以把整体分成三种情况，改变一处成为回文串输出YES；已经是回文串并且串的长度是奇数输出YES（因为改变最中间那个字符，这个字符串还是回文串）；其他情况输出NO。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">string</span> s;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> n=s.size();</div><div class="line">		<span class="keyword">int</span> u=<span class="number">0</span>;</div><div class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">			<span class="keyword">return</span> ;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(s[i]!=s[n<span class="number">-1</span>-i])</div><div class="line">				u++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(u==<span class="number">2</span>)</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(u==<span class="number">0</span> &amp;&amp; n%<span class="number">2</span>==<span class="number">1</span>)</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="798B-Mike-and-strings"><a href="#798B-Mike-and-strings" class="headerlink" title="798B - Mike and strings"></a>798B - Mike and strings</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>定义对字符串的一个操作：将首字符移到最后。给出n个字符串，问最少进行多少次这样的操作能够使得给出的所有字符串都相同。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><h4 id="模拟法"><a href="#模拟法" class="headerlink" title="模拟法"></a>模拟法</h4><p>首先将每一个字符串都复制一遍放到最后，这样左移k位就可以看成是从第k个字符开始长度为len的字符串了。遍历每一个字符串,将其当做目标字符串，计算其他的字符串变成这个字符串的最小开销，求出一个最小值就行了。加上检查是否相等的O(len)的时间复杂度，整体的时间复杂度为O(n^2*len^2)。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> n,len;</div><div class="line"><span class="keyword">char</span> s[<span class="number">51</span>][<span class="number">101</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">char</span> *b)</span> <span class="comment">//判断以a b两个字符串是否相等</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</div><div class="line">		<span class="keyword">if</span>(a[i]!=b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">bool</span> flag=<span class="literal">false</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i]);</div><div class="line">		len=<span class="built_in">strlen</span>(s[<span class="number">0</span>]);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)</div><div class="line">				s[i][j+len]=s[i][j];     <span class="comment">//在原来的字符串后面加上相同的字符串</span></div><div class="line">		<span class="keyword">int</span> res=<span class="number">0</span>,ans=INF;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)      <span class="comment">//作为基准字符串</span></div><div class="line">		&#123;</div><div class="line">			res=<span class="number">0</span>;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span>(i==j)</div><div class="line">					<span class="keyword">continue</span>;</div><div class="line">				<span class="keyword">int</span> k;</div><div class="line">				<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;len;k++)</div><div class="line">					<span class="keyword">if</span>(s[i][<span class="number">0</span>]==s[j][k] &amp;&amp; judge(s[i],s[j]+k))   <span class="comment">//j串循环左移k位</span></div><div class="line">					&#123;</div><div class="line">						res+=k;</div><div class="line">						<span class="keyword">break</span>;</div><div class="line">					&#125;</div><div class="line">				<span class="keyword">if</span>(k==len)</div><div class="line">				&#123;</div><div class="line">					<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</div><div class="line">					flag=<span class="number">1</span>;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span>(flag)</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			ans=min(ans,res);</div><div class="line">		&#125;</div><div class="line">        <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="798C-Mike-and-gcd-problem"><a href="#798C-Mike-and-gcd-problem" class="headerlink" title="798C - Mike and gcd problem"></a>798C - Mike and gcd problem</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>首先定义对于序列的一个操作：将an 和 an+1的值分别替换为（an-an+1）和（an+an+1）。给出一个序列，问要进行多少步如上的操作才能使得这个序列的最大公因数大于1。</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>如果两个操作数都是奇数的话，进行一次操作就全部变成偶数；如果两个数是一奇一偶的话，进行一次操作后变成两个都是奇数，再进行一次操作就得到两个偶数。如果一个序列全是偶数的话，他们的最大公因数至少是2，比1大。所以不管序列怎样，一定是有解的。<br>一个序列如果gcd是1的话那么这个序列中一定存在奇数，并且至少有两个数互质。所以采取将所有的奇数通过操作变换成偶数的方案。我们知道如果是两个奇数要进行一次操作，一奇一偶进行两次操作。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> b?gcd(b,a%b):a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> a[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">		<span class="keyword">int</span> g=gcd(a[<span class="number">0</span>],a[<span class="number">1</span>]);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)</div><div class="line">			g=gcd(g,a[i]);</div><div class="line">		<span class="keyword">if</span>(g&gt;<span class="number">1</span>)</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"0\n"</span>);</div><div class="line">		<span class="keyword">else</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span>(!(a[i]&amp;<span class="number">1</span>))   <span class="comment">//对奇数进行操作</span></div><div class="line">					<span class="keyword">continue</span>;</div><div class="line">				<span class="keyword">if</span>(i==n<span class="number">-1</span>)</div><div class="line">					ans+=<span class="number">2</span>;</div><div class="line">				<span class="keyword">else</span></div><div class="line">				&#123;</div><div class="line">					<span class="keyword">int</span> tmp=a[i];</div><div class="line">					a[i]=a[i]-a[i+<span class="number">1</span>];</div><div class="line">					a[i+<span class="number">1</span>]=tmp+a[i+<span class="number">1</span>];</div><div class="line">					ans++;</div><div class="line">					<span class="keyword">if</span>(a[i]&amp;<span class="number">1</span>)   <span class="comment">//进行两步操作</span></div><div class="line">					&#123;</div><div class="line">						tmp=a[i];</div><div class="line">						a[i]=a[i]-a[i+<span class="number">1</span>];</div><div class="line">						a[i+<span class="number">1</span>]=tmp+a[i+<span class="number">1</span>];</div><div class="line">						ans++;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UVA-1471 Defense Lines 扫描+二分]]></title>
      <url>/2017/04/21/UVA-1471-Defense-Lines-%E6%89%AB%E6%8F%8F-%E4%BA%8C%E5%88%86/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://vjudge.net/problem/UVA-1471" target="_blank" rel="external">https://vjudge.net/problem/UVA-1471</a></p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个序列，要求删除一子序列以后，能够得到一个最长的连续递增子序列，输出这个连续递增子序列的长度</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="前期处理"><a href="#前期处理" class="headerlink" title="前期处理"></a>前期处理</h3><p>我们可以将问题分成两个部分：求以j开头的最长递增子序列的长度g[j];求以i结尾的最长递增子序列的长度f[i],这样的话问题就转化成了求i和j满足条件：A[i]&lt; A[j] 并且 f[i]+g[j] 最大</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>我们还可以在上面的O(n^2)算法的基础上继续改进，首先我们开一个数组Min，其中元素Min[i]表示长度为i的递增序列中的结尾元素值最小的值。<br>可见Min一定是递增的，因为长度为的n的最后一个元素的值一定比长度为n-1的序列的最后一个元素值大。这样的话我们已知A[i]的值就可以通过二分查找（lower_bound）来判断其在Min中的位置，从而得出能够取到的最长的序列长度。这样二分查找的时间复杂度为O(logn)，这个算法的时间复杂度为O(nlogn)。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200005</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> t,n,a[maxn],Left[maxn],Right[maxn],Min[maxn];</div><div class="line"></div><div class="line"><span class="comment">// 初始化确定左右两边的值</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    Left[<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">    Right[n<span class="number">-1</span>]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">        <span class="keyword">if</span>(i)</div><div class="line">        &#123;</div><div class="line">            Left[i]=<span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>(a[i]&gt;a[i<span class="number">-1</span>]) Left[i]+=Left[i<span class="number">-1</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</div><div class="line">    &#123;</div><div class="line">        Right[i]=<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(a[i]&lt;a[i+<span class="number">1</span>]) Right[i]+=Right[i+<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">    <span class="built_in">memset</span>(Min,INF,<span class="keyword">sizeof</span>(Min));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> len=lower_bound(Min+<span class="number">1</span>,Min+<span class="number">1</span>+n,a[i])-Min;  <span class="comment">//根据元素值得到最小延伸值</span></div><div class="line">        ans=max(ans,Right[i]+len<span class="number">-1</span>);</div><div class="line">        Min[Left[i]]=min(Min[Left[i]],a[i]);   <span class="comment">//更新延伸值对应的元素值 </span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> t;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</div><div class="line">    <span class="keyword">while</span>(t--)</div><div class="line">    &#123;</div><div class="line">        init();</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,fun());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"></div><div class="line">&#123;</div><div class="line">    freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[凸包问题]]></title>
      <url>/2017/04/17/%E5%87%B8%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>首先是凸包的定义，假设平面内有一些点，这些点中的一部分组成一个多边形，将其他的点都包含起来，当这个多边形是凸多边形的时候，我们就把他当成是一个凸包。<br>解决凸包问题有很多种算法，比较常见的有O(n^3)的暴力穷举算法以及O(nlogn)d的分治算法，这里讲的是一个时间复杂度为O(nlogn)的Graham扫描法。</p>
<a id="more"></a>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="图中点的编号排序"><a href="#图中点的编号排序" class="headerlink" title="图中点的编号排序"></a>图中点的编号排序</h3><p>首先建立一个极坐标系，选取所有点中最左下的点作为极点，将所有的点按照逆时针方向进行排序，角度相同的点，距离极点小的点排在前面。</p>
<h3 id="依次寻找凸包上面的点"><a href="#依次寻找凸包上面的点" class="headerlink" title="依次寻找凸包上面的点"></a>依次寻找凸包上面的点</h3><p>用栈来存储凸包的点（因为我们要读取栈顶的两个点，所以不用STL中的queue，而是用数组建栈)，依次考察排序好的点,判断是否弹出栈顶元素。考察规则：从栈中取出栈顶的两个点，两点连接成一条直线，然后判断当前考虑的点在再这条直线的左边还是右边（利用叉乘进行判断），在左边表示这个点在凸包上，入栈；在右边表示当前栈顶元素不是凸包上的点，将这个点出栈，然后继续取出栈顶的两个点进行考虑，直到可以将这个点加入栈中。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> point</div><div class="line">&#123;</div><div class="line">	<span class="keyword">double</span> x,y;</div><div class="line">&#125;p[maxn],t[maxn];</div><div class="line"><span class="keyword">int</span> n;    <span class="comment">//点的个数</span></div><div class="line"></div><div class="line"><span class="comment">//得到相应的叉乘</span></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_X</span><span class="params">(point a,point b,point c)</span>        <span class="comment">//ab到ac的叉乘计算</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">(point a,point b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(point &amp;a,point &amp;b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">double</span> pp=get_X(p[<span class="number">0</span>],a,b);</div><div class="line">	<span class="keyword">if</span>(pp&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">if</span>(pp&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	<span class="keyword">return</span> len(p[<span class="number">0</span>],a)&lt;len(p[<span class="number">0</span>],b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Graham</span><span class="params">()</span>     <span class="comment">//返回凸包所含有的点的个数</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)     <span class="comment">//找到起始点</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(p[i].x&lt;p[<span class="number">0</span>].x) swap(p[i],p[<span class="number">0</span>]);</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(p[i].x==p[<span class="number">0</span>].x &amp;&amp; p[i].y&lt;p[<span class="number">0</span>].y) swap(p[i],p[<span class="number">0</span>]);</div><div class="line">		&#125;</div><div class="line">		sort(p+<span class="number">1</span>,p+n,cmp);</div><div class="line">		t[<span class="number">0</span>]=p[<span class="number">0</span>];</div><div class="line">		t[<span class="number">1</span>]=p[<span class="number">1</span>];</div><div class="line">		<span class="keyword">int</span> top=<span class="number">1</span>;    <span class="comment">//栈顶位置</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">while</span>(t&gt;<span class="number">0</span> &amp;&amp; get_X(t[top<span class="number">-1</span>],t[top],p[i])&lt;=<span class="number">0</span>) top--;    <span class="comment">//考虑的点在右侧的时候将栈顶的点弹出</span></div><div class="line">			top++;</div><div class="line">			t[top]=p[i];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> top;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[最大团问题]]></title>
      <url>/2017/04/15/%E6%9C%80%E5%A4%A7%E5%9B%A2%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>最大团问题（Maximum Clique Problem, MCP）是图论中一个经典的组合优化问题，也是一类NP完全问题。看到前面的描述可能会觉得很复杂，但是最大团的定义其实很简单，通俗点讲最大团问题就是一个最大的完全子图的问题。<br>因为是NP完全问题，自然没有多项式时间复杂度求解的算法，解决这个问题有很多有效的算法：遗传算法、模拟退火算法、禁忌算法等等，但是这些算法比较高级，这里讲一种比较简单的搜索算法。<br><a id="more"></a></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>总体上来讲，这个算法就是通过DFS进行搜索，通过剪枝来优化的方法。DFS搜索的本质就是维护一个已经是完全图的子图，并在搜索过程中不断扩大这个子图，直到所有的点都被考虑进去。</p>
<h3 id="DFS过程"><a href="#DFS过程" class="headerlink" title="DFS过程"></a>DFS过程</h3><blockquote>
<p>　　　　初始化：</p>
<p>　　　　　从一个点 u 开始，把这个点加入集合 U 中。将编号比它大的且和它相连的点加入集合 S1 中，为了方便，将集合 S1 中的点有序，让他们从小到大排列，进行第一遍 DFS</p>
<p>　　　第一遍 DFS ：</p>
<p>　　　　　从 S1 中选择一个点 u1，遍历 S1 中，所有编号比 u1 大且和 u1 相连的点，其实也就是排在 u1 后面，并且和 u1 相连的点，将它们加入集合 S2 中。同理，让 S2 中的点也按照编号也从小到大排列。将 u1 加入集合 U 中，进行第二遍 DFS</p>
<p>　　　第二遍 DFS ：</p>
<p>　　　　　从 S2 中选择一个点 u2，遍历 S2 中，所有排在 u2 后面且和 u2 相连的点，并把它们加入集合 S3 中，让 S3 中的点按照编号从小到大排列，将 u2 加入集合 U 中进行第三遍 DFS</p>
<p>　　　第三遍 DFS ：</p>
<p>　　　　　从 S3 中选择一个点 u3，遍历 S3 中，所有排在 u3 后面且和 u3 相连的点，并把它们加入集合 S4 中，让 S4 中的点按照编号从小到大排列，将 u3 加入集合 U 中进行第四遍 DFS</p>
<p>　　　……</p>
<p>　　　最底层的 DFS ：</p>
<p>　　　　　当某个 S 集合为空时，DFS 过程结束，得到一个只用后面几个点构成的完全子图，并用它去更新只用后面几个点构成的最大团。退出当前 DFS，返回上层 DFS，接着找下一个完全子图，直到找完所有的完全子图</p>
</blockquote>
<h3 id="辅助集合"><a href="#辅助集合" class="headerlink" title="辅助集合"></a>辅助集合</h3><p>为每一层的DFS遍历开一个集合Sn，用来表示在这一层DFS中，考虑加入完全图中的点。从这个集合Sn中取一个点准备加入完全图，同时将和这个点相连的Sn中的其他点加入下一层DFS的辅助集合S(n+1)中去。</p>
<h3 id="剪枝1"><a href="#剪枝1" class="headerlink" title="剪枝1"></a>剪枝1</h3><p>已经在完全图U中的点的数量 + 辅助集合Sn中的点的数量 &lt; 已经产生的最优解，则不再进行后面的DFS</p>
<h3 id="剪枝2"><a href="#剪枝2" class="headerlink" title="剪枝2"></a>剪枝2</h3><p>已经在完全图U中的点的数量 + 后面集合能够构成的最大完全子图的顶点数量 &lt; 已经产生的最优解，则不再进行后面的DFS。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">bool</span> G[maxn][maxn];</div><div class="line"><span class="keyword">int</span> Max[maxn],Alt[maxn][maxn],ans,n;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> tot)</span>     <span class="comment">//cur 当前层次集合大小  tot 所在的层次</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(cur==<span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(tot&gt;ans)</div><div class="line">		&#123;</div><div class="line">			ans=tot;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(cur-i+tot&lt;=ans) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">//剪枝1</span></div><div class="line">		<span class="keyword">int</span> u=Alt[tot][i];    <span class="comment">//选取当前考虑的点</span></div><div class="line">		<span class="keyword">if</span>(Max[u]+tot&lt;=ans) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> next=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;cur;j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(G[u][Alt[tot][j]])  Alt[tot+<span class="number">1</span>][next++]=Alt[tot][j];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(dfs(next,tot+<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>  <span class="title">MaxClique</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ans=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(Max,<span class="number">0</span>,<span class="keyword">sizeof</span>(Max));</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)    <span class="comment">//逆向构建Max</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> cur=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++) </div><div class="line">			<span class="keyword">if</span>(G[i][j]) Alt[<span class="number">1</span>][cur++]=j;</div><div class="line">		dfs(cur,<span class="number">1</span>);</div><div class="line">		Max[i]=ans;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ZOJ-1492"><a href="#ZOJ-1492" class="headerlink" title="ZOJ 1492"></a>ZOJ 1492</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>裸的最大团模板题</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">nclude &lt;iostream&gt;</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">55</span>;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> G[maxn][maxn];</div><div class="line"><span class="keyword">int</span> Max[maxn],Alt[maxn][maxn],ans,n;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> tot)</span>     <span class="comment">//cur 当前层次集合大小  tot 所在的层次</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(cur==<span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(tot&gt;ans)</div><div class="line">		&#123;</div><div class="line">			ans=tot;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(cur-i+tot&lt;=ans) <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">//剪枝1</span></div><div class="line">		<span class="keyword">int</span> u=Alt[tot][i];    <span class="comment">//选取当前考虑的点</span></div><div class="line">		<span class="keyword">if</span>(Max[u]+tot&lt;=ans) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> next=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;cur;j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(G[u][Alt[tot][j]])  Alt[tot+<span class="number">1</span>][next++]=Alt[tot][j];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(dfs(next,tot+<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span>  <span class="title">MaxClique</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	ans=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(Max,<span class="number">0</span>,<span class="keyword">sizeof</span>(Max));</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)    <span class="comment">//逆向构建Max</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> cur=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++) </div><div class="line">			<span class="keyword">if</span>(G[i][j]) Alt[<span class="number">1</span>][cur++]=j;</div><div class="line">		dfs(cur,<span class="number">1</span>);</div><div class="line">		Max[i]=ans;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> a;</div><div class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</div><div class="line">                <span class="keyword">if</span>(a==<span class="number">1</span>)G[i][j]=<span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span> G[i][j]=<span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">		MaxClique();</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[KM算法]]></title>
      <url>/2017/04/10/KM%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>之前讲到了匈牙利算法，今天讲一个在匈牙利算法的基础上的解决最大全的完美二分匹配的问题的KM算法，这个算法在理解上面可能有一点难度，不过有一句话说得好：组合数学靠运气，计算几何瞎暴力，图论一顿套模板，数论只会gcd。23333.。。<br><a id="more"></a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h4 id="完备匹配"><a href="#完备匹配" class="headerlink" title="完备匹配"></a>完备匹配</h4><p>二分图中，含有较少点集合中的所有点都有匹配的点的时候，我们称这样的匹配叫完备匹配</p>
<h4 id="完美匹配"><a href="#完美匹配" class="headerlink" title="完美匹配"></a>完美匹配</h4><p>在完备匹配的基础上，二分图中两个点的集合中点的个数相同。如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。完美匹配一定是最大匹配。</p>
<h4 id="相关问题变形"><a href="#相关问题变形" class="headerlink" title="相关问题变形"></a>相关问题变形</h4><p>完备匹配变完美匹配：添加无用顶点和权值为0的边</p>
<h4 id="顶点顶标"><a href="#顶点顶标" class="headerlink" title="顶点顶标"></a>顶点顶标</h4><p>为每个点设定一个顶标，设顶点Xi的顶标为A[ i ]，顶点Yj的顶标为B[ j ]，顶点Xi与Yj之间的边权为w[i,j]。在算法执行过程中的任一时刻，对于任一条边(i,j)，A[i]+B[j] &gt;= w[i,j] 始终成立。</p>
<h4 id="相等子图"><a href="#相等子图" class="headerlink" title="相等子图"></a>相等子图</h4><p>G中满足A[i]+B[j]=w[i,j] 的边生成的子图<br>KM算法在G的相等子图中求一个完备匹配</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>初始化：令A[ i ]为所有与顶点Xi关联的边的最大权，B[ j ]=0<br>如果当前的相等子图没有完备匹配，就需要修改顶标以扩大相等子图<br>重复第二步，直到相等子图有完备匹配为止</p>
<h4 id="修改顶标（关键）"><a href="#修改顶标（关键）" class="headerlink" title="修改顶标（关键）"></a>修改顶标（关键）</h4><p>KM算法的关键为如何修改顶标，以使顶标维持其性质的同时使相等子图得到扩展。<br>考虑到，如果当前相等子图不存在完备匹配，是因为存在某个不被匹配的x结点，在当前相等子图中不存在其的增广路。这样由这个点出发我们可得到一棵交错树，并且该树的所有叶子结点都在X集合中<br>这时如果我们把交错树中所有X集合结点的顶标减去d，所有Y集合结点的顶标加上d。则会发现：</p>
<ol>
<li>两端都在交错树中的边(i, j)，A[ i ]+B[ j ]的值没有变化。也就是说，它原来属于相等子图，现在仍属于相等子图。</li>
<li>两端都不在交错树中的边(i, j)，A[ i ]和B[ j ]都没有变化。也就是说，它原来属于（或不属于）相等子图，现在仍属于（或不属于）相等子图。</li>
<li>X端不在交错树中，Y端在交错树中的边(i, j)，它的A[ i ]+B[ j ]的值有所增大。它原来不属于相等子图，现在仍不属于相等子图。</li>
<li>X端在交错树中，Y端不在交错树中的边(i, j)，它的A[ i ]+B[ j ]的值有所减小。也就说，它原来不属于相等子图，现在可能进入了相等子图，因而使相等子图得到了扩大。<br>确定d的值：（以确保每次修该顶标既能保持顶标性质，又能使至少一条边加入到相等子图中来，使其得到扩展。）<br>d=Min{A[ i ]+B[ j ]-w[i , j] | Xi在交错树中，Yj不在交错树中}</li>
</ol>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>按照刚才的算法来的时间复杂度是O(n^4)，需要找O(n)次增广路，每次增广最多需要修改O(n)次顶标，每次修改顶标时由于要枚举边来求d值，复杂度为O(n2)。<br>可以看出，通过枚举边来求d的值是有改进空间的 。实际上我们给每个Y顶点一个“松弛量”函数slack，每次开始找增广路时初始化为无穷大。在寻找增广路的过程中，检查边(i,j)时，如果它不在相等子图中， 则让slack[j]变成原值与A[ i ]+B[j]-w[i,j]的较小值。这样，在修改顶标时，取所有不在交错树中的Y顶点的slack值中的最小值作为d值即可。但还要注意一点：修改顶标后，要把所有的slack值都减去d。<br>这样求d的复杂度降为O(n)级，使得总时间复杂度为O(n3)</p>
<h2 id="模板（代码实现）"><a href="#模板（代码实现）" class="headerlink" title="模板（代码实现）"></a>模板（代码实现）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> nx,ny;  <span class="comment">//两边的点数</span></div><div class="line"><span class="keyword">int</span> g[maxn][maxn];   <span class="comment">//建图</span></div><div class="line"><span class="keyword">int</span> linker[maxn],lx[maxn],ly[maxn];     <span class="comment">//y中欧各个点的匹配状态,x y 中各个点的标号</span></div><div class="line"><span class="keyword">int</span> slack[maxn];        <span class="comment">//松弛量数组</span></div><div class="line"><span class="keyword">bool</span> visx[maxn],visy[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line">&#123;</div><div class="line">	visx[x]=<span class="literal">true</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;ny;y++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(visy[y]) <span class="keyword">continue</span>;</div><div class="line">		<span class="keyword">int</span> tmp=lx[x]+ly[y]-g[x][y];</div><div class="line">		<span class="keyword">if</span>(tmp==<span class="number">0</span>)    <span class="comment">//顶标符合要求，匈牙利算法寻找完备匹配</span></div><div class="line">		&#123;</div><div class="line">			visy[y]=<span class="literal">true</span>;</div><div class="line">			<span class="keyword">if</span>(linker[y]==<span class="number">-1</span> || dfs(linker[y]))</div><div class="line">			&#123;</div><div class="line">				linker[y]=x;</div><div class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(slack[y]&gt;tmp)</div><div class="line">			slack[y] =tmp;        <span class="comment">//更新松弛量</span></div><div class="line">	&#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">KM</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">memset</span>(linker,<span class="number">-1</span>,<span class="keyword">sizeof</span>(linker));     <span class="comment">//初始化一开始匹配的点</span></div><div class="line">	<span class="built_in">memset</span>(ly,<span class="number">0</span>,<span class="keyword">sizeof</span>(ly));      <span class="comment">//y的顶标先全部变成0</span></div><div class="line">	<span class="comment">//初始化顶标</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nx;i++)</div><div class="line">	&#123;</div><div class="line">		lx[i]= -INF;            <span class="comment">//求最大值，首先初始化为最小值</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ny;j++)</div><div class="line">			<span class="keyword">if</span>(g[i][j]&gt;lx[i]) lx[i]=g[i][j];</div><div class="line">	&#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;nx;x++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ny;i++)</div><div class="line">			slack[i]=INF;</div><div class="line">		<span class="comment">//算法核心部分</span></div><div class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">memset</span>(visx,<span class="literal">false</span>,<span class="keyword">sizeof</span>(visx));</div><div class="line">            <span class="built_in">memset</span>(visy,<span class="literal">false</span>,<span class="keyword">sizeof</span>(visy));</div><div class="line">			<span class="keyword">if</span>(dfs(x)) <span class="keyword">break</span>;        <span class="comment">//找到完备匹配，退出</span></div><div class="line">			<span class="comment">//没有找到完备匹配，在交错树中更改相关节点的顶标值</span></div><div class="line">			<span class="keyword">int</span> d= INF;</div><div class="line">			<span class="comment">//修改顶标，增加相等子图中的边</span></div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ny;i++)</div><div class="line">				<span class="keyword">if</span>(!visy[i] &amp;&amp; d&gt;slack[i])</div><div class="line">					d=slack[i];          <span class="comment">//求出最小一个slack值</span></div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nx;i++)     <span class="comment">//在交错树中的x的节点减少d</span></div><div class="line">				<span class="keyword">if</span>(visx[i])</div><div class="line">					lx[i]-=d;    </div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ny;i++)        <span class="comment">//不在交错树中的y的节点增加d</span></div><div class="line">			&#123;</div><div class="line">				<span class="keyword">if</span>(visy[i]) ly[i]+=d;     </div><div class="line">				<span class="keyword">else</span></div><div class="line">					slack[i] -=d;          <span class="comment">//x值减小，则相对的slack的值就会增大</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ny;i++)</div><div class="line">		<span class="keyword">if</span>(linker[i]!=<span class="number">-1</span>)</div><div class="line">			res+=g[linker[i]][i];</div><div class="line">	<span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 3276 (开关问题)]]></title>
      <url>/2017/04/09/POJ-3276-%E5%BC%80%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>这道题本来是挑战上面一道经典的例题，这次在Google 的<a href="https://code.google.com/codejam/" target="_blank" rel="external">code jam</a>的资格赛里面也出现了。可气的是我忘记怎么做了，只好重新看一遍挑战的书，下面讲一讲我对这道题的理解吧。</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出了N头牛的朝向（朝前或者朝后），现有一台机器，可以一次性反转连续的k头牛的朝向，最终要使得所有的牛的朝向都是朝前的，现在问使得反转次数最少的k的取值和最小的反转次数。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一个区间的反转会导致区间内的所有牛的朝向都改变，反转区间的顺序对最后的结果是没有影响的。同时对于一个区间要么就不反转，要么就只反转一次,不可能有两次或者以上的反转。一头牛是否需要反转是由这头牛一开始的状态以及其他区间的反转对这头牛的影响决定的。所以我们每次都考虑区间中最左边的牛，根据初始的朝向以及其他区间反转对这头牛的影响决定这头牛是否要反转，后面我们就不需要考虑这头牛，只要区间是否反转给后面的牛考虑带来的影响。这样每次每次问题的规模就减少了1。<br>我们设f[i]: 区间[i,i+K-1]是否进行反转，是为1，否则为0<br>这样我们考虑到第i头牛的时候，就是考虑f[i-K+1]-f[i-1]对它的影响，将这些值相加，然后再加上牛本身的状态，为奇数时改变朝向，为偶数时不需要改变，这样我们就可以得到f[i]的值了，f[i]继续影响后面的牛的决策。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5006</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> dir[maxn],f[maxn];    <span class="comment">//存放初始状态和反转情况</span></div><div class="line"><span class="keyword">int</span> N;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> k)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</div><div class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;        <span class="comment">//最后反转的次数</span></div><div class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;        <span class="comment">//之前区间的反转对当前节点的影响数</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+k&lt;=N;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>((dir[i]+sum)%<span class="number">2</span>)    <span class="comment">//需要进行反转</span></div><div class="line">		&#123;</div><div class="line">			res++;</div><div class="line">			f[i]=<span class="number">1</span>;         <span class="comment">//会对后面的产生影响</span></div><div class="line">		&#125;</div><div class="line">		sum+=f[i];</div><div class="line">		<span class="keyword">if</span>(i-k+<span class="number">1</span>&gt;=<span class="number">0</span>)</div><div class="line">			sum-=f[i-k+<span class="number">1</span>];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=N-k+<span class="number">1</span>;i&lt;N;i++)  <span class="comment">//无法进行反转的阶段</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>((dir[i]+sum)%<span class="number">2</span>)</div><div class="line">			<span class="keyword">return</span> <span class="number">-1</span>;    <span class="comment">//无解</span></div><div class="line">		<span class="keyword">if</span>(i-k+<span class="number">1</span>&gt;=<span class="number">0</span>)</div><div class="line">			sum-=f[i-k+<span class="number">1</span>];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> res;	</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> ch[<span class="number">2</span>];</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N)!=EOF)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;ch);</div><div class="line">			<span class="keyword">if</span>(ch[<span class="number">0</span>]==<span class="string">'F'</span>)</div><div class="line">				dir[i]=<span class="number">0</span>;</div><div class="line">			<span class="keyword">else</span></div><div class="line">				dir[i]=<span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> minid=<span class="number">1</span>,minva=N;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=N;k++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">int</span> tmp=calc(k);</div><div class="line">			<span class="keyword">if</span>(tmp&gt;=<span class="number">0</span> &amp;&amp; tmp&lt;minva)</div><div class="line">			&#123;</div><div class="line">				minva=tmp;</div><div class="line">				minid=k;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,minid,minva);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法技巧 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[匈牙利算法]]></title>
      <url>/2017/04/08/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>今天实验室的“周末算法讲堂”轮到我啦，今天主要讲的是匈牙利算法，主要用来解决最大的二分匹配问题（当然还可以用最大流来解决）。下面把握准备过程的资料整理总结出来吧。（感觉这么点东西讲的东西比较少，实验室的大佬们别介意啊）<br>后面会讲到在这个的基础上解决最大权完美匹配问题的KM算法</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><p>如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。每一条边的两个端点都分别在两个组当中<br><img src="http://oeziv5rwi.bkt.clouddn.com/2017/4/8/001.jpg" alt="二分图"></p>
<h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><p>在图论中，一个「匹配」（matching）是原图边的一个子集，其中任意两条边都没有公共顶点。图中的点要么有一条边相连，要么没有边相连，不可能一个点和多条边相连。</p>
<h3 id="最大匹配"><a href="#最大匹配" class="headerlink" title="最大匹配"></a>最大匹配</h3><p>一个图中含有匹配数最多的匹配</p>
<h3 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h3><p>求出所有的匹配方案，从中选取覆盖顶点数最大的匹配方案。</p>
<h3 id="最大流算法"><a href="#最大流算法" class="headerlink" title="最大流算法"></a>最大流算法</h3><p>在两边各加一个源点和一个汇点，同时为两边的每一个点都添加一条指向源点/汇点的边，如图所示。同时从源点到汇点给每一条边都指定方向。这样问题就转换成最大流问题，通过最大流的相关算法就可以求解。</p>
<p><img src="http://oeziv5rwi.bkt.clouddn.com/2017/4/8/002.jpg" alt="最大流求解二分匹配问题"></p>
<hr>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>匈牙利算法提供一种找图中的最大匹配的算法</p>
<h3 id="增广路径"><a href="#增广路径" class="headerlink" title="增广路径"></a>增广路径</h3><p>从未匹配点出发，交替通过未匹配边和已匹配边，最后到达另一个未匹配点的路径。<br><img src="http://oeziv5rwi.bkt.clouddn.com/2017/4/8/003.jpg" alt="增广路径"><br>性质</p>
<ol>
<li>增广路的长度一定是奇数，并且第一条边和最后一条边一定不是匹配边。</li>
<li>增广路径中未匹配边的数量始终比已匹配边的数量多一位。<br>这样通过反转（已匹配边变成未匹配边，未匹配边变成已匹配边）就可以增加一天匹配边。反转不改变匹配的性质。<br>可以证明，找到最大的匹配当且仅当找不到新的增广路：<br>最大匹配是一定不存在增广路，性质2容易证明<br>找不到增广路一定是最大匹配，证明比较麻烦，忽略<br>每找到一条增广路就可以增加一条匹配边。匈牙利算法实际上就是不断从未匹配点开始找增广路的算法。一个点找到匹配的边以后，以后寻找增广路的过程中这个点始终都会有匹配的边</li>
</ol>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>1、设置匹配为空<br>2、遍历每一个未匹配点，从这个点出发，找增广路。通常情况下我们只需要遍历一边的点就可以了，因为匹配边连接的两个点一定分别处在两个集合中，一边的点达到最大的匹配，另外一遍的点也必定会达到最大的匹配<br>3、记录匹配的边数，进行输出</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>空间复杂度：空间复杂度主要来源于图的复杂度，使用链式前向星来存储图，空间复杂度为O(e)</li>
<li>时间复杂度：枚举一边的点的时间复杂度为O(v)，在最坏的情况下每次寻找增广路的时间复杂度为O(e)，所以总的时间复杂度为O(v*e)</li>
</ul>
<h3 id="实现模板"><a href="#实现模板" class="headerlink" title="实现模板"></a>实现模板</h3><p>DFS实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> matching[maxn],head[maxn];</div><div class="line"><span class="keyword">bool</span> visit[maxn];</div><div class="line"><span class="keyword">int</span> cnt,P,N;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Edge</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> to;</div><div class="line">	<span class="keyword">int</span> next;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Edge edge[maxn*maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	cnt=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></div><div class="line">&#123;</div><div class="line">	edge[cnt].to=v;</div><div class="line">	edge[cnt].next=head[u];</div><div class="line">	head[u]=cnt++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=edge[i].next)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> v=edge[i].to;</div><div class="line">		<span class="keyword">if</span>(!visit[v])</div><div class="line">		&#123;</div><div class="line">			visit[v]=<span class="number">1</span>;</div><div class="line">			<span class="keyword">if</span>(matching[v]==<span class="number">-1</span>|| dfs(matching[v]))</div><div class="line">			&#123;</div><div class="line">				matching[v]=u;</div><div class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">huangay</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(matching,<span class="number">-1</span>,<span class="keyword">sizeof</span>(matching));</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=P;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</div><div class="line">		<span class="keyword">if</span>(dfs(i)) ans++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="POJ-1469"><a href="#POJ-1469" class="headerlink" title="POJ 1469"></a>POJ 1469</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出N个学生和P堂课，以及每堂课报名的学生名单，存在以下对于课代表的规则：每个学生当一门课的课代表，每门课都有课代表。问是否存在满足上述条件的课代表组合。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>裸的匈牙利算法，只要将最后算法出来的匹配数和课堂树进行比对，相等的话就满足条件，否则不满足条件。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">305</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> matching[maxn],head[maxn];</div><div class="line"><span class="keyword">bool</span> visit[maxn];</div><div class="line"><span class="keyword">int</span> cnt,P,N;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Edge</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> to;</div><div class="line">	<span class="keyword">int</span> next;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Edge edge[maxn*maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	cnt=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></div><div class="line">&#123;</div><div class="line">	edge[cnt].to=v;</div><div class="line">	edge[cnt].next=head[u];</div><div class="line">	head[u]=cnt++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=edge[i].next)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> v=edge[i].to;</div><div class="line">		<span class="keyword">if</span>(!visit[v])</div><div class="line">		&#123;</div><div class="line">			visit[v]=<span class="number">1</span>;</div><div class="line">			<span class="keyword">if</span>(matching[v]==<span class="number">-1</span>|| dfs(matching[v]))</div><div class="line">			&#123;</div><div class="line">				matching[v]=u;</div><div class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">huangay</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">	<span class="built_in">memset</span>(matching,<span class="number">-1</span>,<span class="keyword">sizeof</span>(matching));</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=P;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</div><div class="line">		<span class="keyword">if</span>(dfs(i)) ans++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> t;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</div><div class="line">    <span class="keyword">while</span>(t--)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;P,&amp;N);</div><div class="line">        Init();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=P;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> tmp,a;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tmp);</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tmp;j++)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</div><div class="line">                add(i,a);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> ans=huangay();</div><div class="line">        <span class="keyword">if</span>(ans==P)</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//freopen("input.txt","r",stdin);</span></div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识 朱刘算法]]></title>
      <url>/2017/03/25/%E5%88%9D%E8%AF%86-%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>又到了每周一次的实验室算法专题分享，这次讲的是的是朱刘算法（好奇葩的算法名字），朱刘算法主要用来解决的是最小树型图的问题，算法整体的理解不是很难结合模板代码比较容易理解。接下来讲讲我的理解吧，当做自己学习的一个总结吧！</p>
<a id="more"></a>
<h2 id="最小树型图"><a href="#最小树型图" class="headerlink" title="最小树型图"></a>最小树型图</h2><p>我们知道最小生成树是一个加权无向图，有n-1条边，能够连接图中所有的点的边集。这里的最小树型图就是最小生成树的有向图版本。除了根节点之外所有的节点都有一条入边指向它。</p>
<h2 id="朱刘算法"><a href="#朱刘算法" class="headerlink" title="朱刘算法"></a>朱刘算法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>首先我们可以利用贪心思想，像Kruscal算法的选边原则一样，我们可以先找到每个节点的入边中最小的一条边，如果选出来的这些边中不能构成环，这样选出来的边就组成了一个最小树型图。但很多时候我们选出来的边是含有环的，对于环的处理，朱刘算法采取的不是直接换边，而是用一个点来代替原来的那个环（这个操作叫做缩点操作），并且修改跟这个环里的点有关的边的权值 ， 为什么要修改权值呢？因为我们是换边 ， 不是增加边 ， <strong>当我们每更换一个点的入边的时候我们就要去掉原来那个入边  ， 于是我们把这个点所有可能的入边全部减小原来我们枚举的那个边的权值 ， 这样每增加一条入边无形中就删去了原来那条边</strong>(此处想通再继续)。 当我们把所有的环都缩点并且修改权值之后 ， 相当于就重新建图了。</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>算法用到必要数组有inw[]用来计算每个点的最小入边权值，id[]用来记录重新构图以后对应的点的编号，pre[]数组记录最小入边的上一个点</p>
<ul>
<li>初始化inw数组和pre数组，找到每个点的最小入边</li>
<li>寻找图中的环，通过一个辅助的数组v数组来实现</li>
<li>进行缩点操作，将一个环中的点当做一个点</li>
<li>重新构图</li>
</ul>
<h2 id="POJ-3164"><a href="#POJ-3164" class="headerlink" title="POJ 3164"></a>POJ 3164</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出N个点、这N个点的坐标信息和这N个点的M条关联关系，求最小树型图的权值代价和</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>裸的朱刘算法，模板题</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> in(a) scanf(<span class="meta-string">"%d"</span>,&amp;a)</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">110</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> edge</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> u,v;</div><div class="line">    <span class="keyword">double</span>  w;</div><div class="line">    edge(<span class="keyword">int</span> uu,<span class="keyword">int</span> vv, <span class="keyword">double</span> ww):u(uu),v(vv),w(ww)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;edge&gt; g;</div><div class="line"></div><div class="line"><span class="keyword">int</span> id[maxn],pre[maxn],v[maxn];</div><div class="line"><span class="keyword">double</span> inw[maxn],ans;</div><div class="line"><span class="keyword">int</span> n,m;</div><div class="line"><span class="keyword">int</span> xx[maxn],yy[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">double</span> ret= <span class="built_in">sqrt</span>(<span class="keyword">double</span>((yy[b]-yy[a])*(yy[b]-yy[a])+(xx[b]-xx[a])*(xx[b]-xx[a])));</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> s)</span>      <span class="comment">//存在最小树型图时，返回TRUE，ans；不存在的时候，返回FALSE</span></span></div><div class="line">&#123;</div><div class="line">    ans=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            inw[i]=INF;</div><div class="line">            id[i]=<span class="number">-1</span>;</div><div class="line">            v[i]=<span class="number">-1</span>;</div><div class="line">            pre[i]=<span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//找到每个点的最小入边</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g.size();i++)</div><div class="line">            <span class="keyword">if</span>(g[i].w &lt;=inw[g[i].v] &amp;&amp; g[i].v!=g[i].u)</div><div class="line">            &#123;</div><div class="line">                inw[g[i].v]=g[i].w;</div><div class="line">                pre[g[i].v]=g[i].u;</div><div class="line">            &#125;</div><div class="line">        pre[s]=s;</div><div class="line">        inw[s]=<span class="number">0</span>;       <span class="comment">//根节点没有入边</span></div><div class="line">        <span class="comment">//计算总的权重和</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(inw[i]==INF)</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">//没有找到最小的入边的时候，返回错误</span></div><div class="line">            ans+=inw[i];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//判断有没有环</span></div><div class="line">        <span class="keyword">int</span> idx=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(v[i]==<span class="number">-1</span>)     <span class="comment">//v[]作用是判断有没有环</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> t=i;</div><div class="line">                <span class="keyword">while</span> (v[t]==<span class="number">-1</span>)</div><div class="line">                &#123;</div><div class="line">                    v[t]=i;</div><div class="line">                    t=pre[t];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(v[t]!=i || t==s)</div><div class="line">                    <span class="keyword">continue</span>;      <span class="comment">//没有环的时候</span></div><div class="line">                id[t]=idx++;      <span class="comment">//重构图中新的点</span></div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=pre[t];j!=t;j=pre[j])id[j]=idx<span class="number">-1</span>;     <span class="comment">//缩点操作，确定前后点的关系</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(idx==<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="comment">//为不在环中的点建立图之间点的关系</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">            <span class="keyword">if</span>(id[i]==<span class="number">-1</span>)id[i]=idx++;</div><div class="line">        <span class="comment">//重新构图,改变边连接的两个点的关系</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g.size();i++)</div><div class="line">        &#123;</div><div class="line">            g[i].w-=inw[g[i].v];</div><div class="line">            g[i].u=id[g[i].u];</div><div class="line">            g[i].v=id[g[i].v];</div><div class="line">        &#125;</div><div class="line">        n=idx<span class="number">-1</span>;</div><div class="line">        s=id[s];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m)!=EOF)</div><div class="line">    &#123;</div><div class="line">        g.clear();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;xx[i],&amp;yy[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> a,b;</div><div class="line">        <span class="keyword">double</span> we;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b);</div><div class="line">            we=getdis(a,b);</div><div class="line">            g.push_back(edge(a,b,we));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(fun(<span class="number">1</span>))</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,ans);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"poor snoopy\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈 差分约束]]></title>
      <url>/2017/03/18/%E6%B5%85%E8%B0%88%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/</url>
      <content type="html"><![CDATA[<p>近期实验室专题学习讲到了差分约束系统，就写点东西来总结一下自己学到的东西吧。首先是一种的比较方便的图的存储方式——链式前向星，然后是在Dijkstra、Bellman-Ford之后的一种非常快的能够求出负环的最短路算法——SPFA，最后是一个最短路的变式——差分约束系统。</p>
<a id="more"></a>
<h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><p>存储图我们通常有两种方法：一种是邻接矩阵法，这个是最基本的东西；另外一种是邻接链表法，通常使用vector的数组表示（相当于一个二维数组）。<br>首先我们要知道什么是前向星，前向星就是一个边的数组，用起点进行排序，起点相同的情况下用终点进行排序。这样我们就可以找到点所连得所有边了<br>链式前向星在以上的基础上避免了排序，用一个head数组来存储每个节点的第一条边，后面的边想要加入进来通过边的结构体中的next来实现，新加入进来的边成为第一条边，这样我们取出边的顺序与插入的顺序是相反的，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">strut Node</div><div class="line">&#123;</div><div class="line">	int v,w,next;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void addedge(int u,int v,int w)</div><div class="line">&#123;</div><div class="line">	edges[id].v=v;</div><div class="line">	edges[id].w=w;</div><div class="line">	edges[id].next=head[u];    //把之前的第一条边作为当前边的最后一条边</div><div class="line">	head[u]=id++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>SPFA就是在Bellman-Ford算法的基础上加一个队列优化，减少冗余的松弛操作。把进行完松弛操作的点加入队列中，同时在判断负边方面，SPFA也具有比较大的优势。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">void spfa(int st)</div><div class="line">&#123;</div><div class="line">    fill(visit,visit+maxn,0);</div><div class="line">    fill(dist,dist+maxn,-INF);</div><div class="line"></div><div class="line">    queue&lt;int&gt; Q;</div><div class="line">    visit[st]=1;</div><div class="line">    dist[st]=0;</div><div class="line">    Q.push(st);</div><div class="line">    while (!Q.empty())</div><div class="line">    &#123;</div><div class="line">        int now=Q.front();</div><div class="line">        Q.pop();</div><div class="line"></div><div class="line">        visit[now]=0;</div><div class="line">        for(int i=head[now];i!=-1;i=edges[i].next)</div><div class="line">        &#123;</div><div class="line">            int v=edges[i].v;</div><div class="line">            int w=edges[i].w;</div><div class="line">            if(dist[v]&lt;dist[now]+w)</div><div class="line">            &#123;</div><div class="line">                dist[v]=dist[now]+w;</div><div class="line">                if(!visit[v])</div><div class="line">                &#123;</div><div class="line">                    Q.push(v);</div><div class="line">                    visit[v]=1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h2><p>我们把一个类似于 d[u]-d[v]&lt;=w  的不等式组放到图中来，看成两个点u、v之间的的距离小于等于w，这样每一个方程组就可以看成图中的一条边，我们构建一个图。这样求(d[0]-d[n])的最大值这样的问题我们就可以放到图中用最短路来解决。</p>
<h2 id="POJ-1201"><a href="#POJ-1201" class="headerlink" title="POJ 1201"></a>POJ 1201</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在一个区间0-50000内，给出n组约束条件，每一个条件表示在一个区间[a,b]内至少有c个点，让你求整个区间里面至少有的点数。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul>
<li>用一个数组d[i]表示从0到i的点数，这样区间[a,b]中至少含有的点数就可以表示为d[b]-d[a-1]，因为要减一处理，所以要多加一个数，不然0作为起点就不好表示。这样根据所给的条件就能够很多不等式组</li>
<li>题目中还隐含一个条件，就是每个点最后只能最多含有一个点，即 1&gt;=d[i+1]-d[i]&gt;=0</li>
<li>转化为最长路问题，通过SPFA来进行求解</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">#define INF 0x3f3f3ff</div><div class="line">const int maxn=500005;</div><div class="line"></div><div class="line">struct Node</div><div class="line">&#123;</div><div class="line">    int v,w,next;     //体现链式</div><div class="line">&#125;edges[maxn];</div><div class="line"></div><div class="line">int id,head[maxn],visit[maxn],dist[maxn];</div><div class="line"></div><div class="line">void init()</div><div class="line">&#123;</div><div class="line">    fill(head,head+maxn,-1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void addedge(int u,int v,int w)</div><div class="line">&#123;</div><div class="line">    edges[id].v=v;</div><div class="line">    edges[id].w=w;</div><div class="line">    edges[id].next=head[u];     //指向u节点的第一条边</div><div class="line">    head[u]=id++;    //替换这个第一条边</div><div class="line">&#125;</div><div class="line"></div><div class="line">void spfa(int st)</div><div class="line">&#123;</div><div class="line">    fill(visit,visit+maxn,0);</div><div class="line">    fill(dist,dist+maxn,-INF);</div><div class="line"></div><div class="line">    queue&lt;int&gt; Q;</div><div class="line">    visit[st]=1;</div><div class="line">    dist[st]=0;</div><div class="line">    Q.push(st);</div><div class="line">    while (!Q.empty())</div><div class="line">    &#123;</div><div class="line">        int now=Q.front();</div><div class="line">        Q.pop();</div><div class="line"></div><div class="line">        visit[now]=0;</div><div class="line">        for(int i=head[now];i!=-1;i=edges[i].next)</div><div class="line">        &#123;</div><div class="line">            int v=edges[i].v;</div><div class="line">            int w=edges[i].w;</div><div class="line">            if(dist[v]&lt;dist[now]+w)</div><div class="line">            &#123;</div><div class="line">                dist[v]=dist[now]+w;</div><div class="line">                if(!visit[v])</div><div class="line">                &#123;</div><div class="line">                    Q.push(v);</div><div class="line">                    visit[v]=1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void solve()</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    while (scanf(&quot;%d&quot;,&amp;n)!=EOF)</div><div class="line">    &#123;</div><div class="line">        init();</div><div class="line">        id=0;</div><div class="line">        int maxnum=0,minnum=INF;</div><div class="line">        int u,v,w;</div><div class="line">        for(int i=0;i&lt;n;i++)</div><div class="line">        &#123;</div><div class="line">            scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w);</div><div class="line">            maxnum=max(maxnum,v+1);</div><div class="line">            minnum=min(minnum,u);</div><div class="line">            addedge(u,v+1,w);    //坐标向后面移一位</div><div class="line">        &#125;</div><div class="line">        for(int i=minnum;i&lt;maxnum;i++)</div><div class="line">        &#123;</div><div class="line">            addedge(i,i+1,0);</div><div class="line">            addedge(i+1,i,-1);   //隐含信息，每一个节点只有最多只能存放一个点</div><div class="line">        &#125;</div><div class="line">        spfa(minnum);</div><div class="line">        printf(&quot;%d\n&quot;,dist[maxnum]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</div><div class="line">    solve();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈可持续化线段树]]></title>
      <url>/2017/03/02/%E6%B5%85%E8%B0%88%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>可持续化线段树（又叫主席树、函数式线段树），顾名思义就是保存线段树的所有历史版本，并且利用他们共同的数据来减少时间和空间的消耗<br>相比普通的线段树维护当前节点对应的区间的信息，可持续化线段树能够记录每次修改后的线段树，可以解决区间第k个数大小的问题。</p>
<a id="more"></a>
<p>主席树能够保存线段树的所有历史版本，这肯定不会是每一个线段树都存储下来（这样一定会MLE的），而是在每次修改的时候只记录修改的结点，没有修改的结点还用原来的线段树里面的结点，这样在线段树中修改某一个值得时候，只需要新增logn个结点来记录这修改了的logn个结点，其他的结点都是不变的，充分利用其中的共有数据。主席树中的每一个结点保存的是一个线段树，维护的区间相同，    结构相同，只有保存的信息不同，这样主席树中的结点就具备了加减性。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>原始的树可以看成是一课空树tree[0]，树中的任何结点的左右结点都是这个空结点，载入原始数据的过程可以看成是第一个历史版本，其他的过程和普通的线段树相同，临界判断，向下更新。</p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>在原来的线段树上进行更改，所修改的每一个结点都是充分分配空间的新结点，同时将父节点指向当前的结点，再用root数组存储当前线段树的根节点。这里很巧妙地用到了引用操作（&amp;），例如update(tree[id].l,l,r,v)，同时update函数的变量表为update(int &amp;id,int l,int r,int v)，函数体的开头就是tree[++cnt]=tree[id];id=cnt; 这样巧妙地操作顺便将父节点的左右孩子结点指针也指向了该结点，这样就跟普通的线段树相差无几了</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询的操作基本上跟普通的线段树一样，就是我们可以随便在哪一个历史版本中查询，比如query(root[k],l,r)  表示在第k个历史版本中查询</p>
<h2 id="POJ-2104-区间第k大问题"><a href="#POJ-2104-区间第k大问题" class="headerlink" title="POJ 2104  区间第k大问题"></a>POJ 2104  区间第k大问题</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出n个数，查询区间[l,r]中第k大的数是多少</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul>
<li>首先数据范围比较大，考虑进行离散化，即对所给的数列进行排序，利用每个数在排序后的数组中的下标进行处理</li>
<li>使用可持续化线段树，建立n个线段树，从第一个线段树开始，后面每一个线段树多一个数的信息</li>
<li>实现查询，因为所建立的这n个线段树维护的区间相同，结构相同，将查询区间两个端点的线段树相减就可以得到[l,r]中的信息，再使用二分法递归找到查询的数在整个数组中的排位</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span>  <span class="keyword">int</span> MAX=<span class="number">100005</span>;</div><div class="line"><span class="keyword">int</span> nums[MAX],sorted[MAX],root[MAX];</div><div class="line"><span class="keyword">int</span> cnt;  <span class="comment">//记录主席树节点编号</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> segment</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> sum,l,r;</div><div class="line">&#125;tree[MAX&lt;&lt;<span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">creatnode</span><span class="params">(<span class="keyword">int</span> sum,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> ro=++cnt;</div><div class="line">    tree[ro].sum=sum;</div><div class="line">    tree[ro].l=l;</div><div class="line">    tree[ro].r=r;</div><div class="line">    <span class="keyword">return</span> ro;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> &amp;ro,<span class="keyword">int</span> pre,<span class="keyword">int</span> pos,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></div><div class="line">&#123;</div><div class="line">    ro=creatnode(tree[pre].sum+<span class="number">1</span>,tree[pre].l,tree[pre].r);    <span class="comment">//创建结点，更改区间所维护值</span></div><div class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(pos&lt;=m)</div><div class="line">        Insert(tree[ro].l,tree[pre].l,pos,l,m);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        Insert(tree[ro].r,tree[pre].r,pos,m+<span class="number">1</span>,r);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> S,<span class="keyword">int</span> E,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> l;</div><div class="line">    <span class="keyword">int</span> sum_l=tree[tree[E].l].sum-tree[tree[S].l].sum;   <span class="comment">//表示区间[l,r]的左子区间的个数和</span></div><div class="line">    <span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(k&lt;=sum_l)</div><div class="line">        <span class="keyword">return</span> query(tree[S].l,tree[E].l,l,m,k);      <span class="comment">//二分递归查找</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> query(tree[S].r,tree[E].r,m+<span class="number">1</span>,r,k-sum_l);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,m,num,pos;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m)!=EOF)</div><div class="line">    &#123;</div><div class="line">        cnt=<span class="number">0</span>;</div><div class="line">        root[<span class="number">0</span>]=<span class="number">0</span>;    <span class="comment">//一开始的线段树是一个空的线段树</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nums[i]);</div><div class="line">            sorted[i]=nums[i];</div><div class="line">        &#125;</div><div class="line">        sort(sorted+<span class="number">1</span>,sorted+<span class="number">1</span>+n);</div><div class="line">        num=unique(sorted+<span class="number">1</span>,sorted+<span class="number">1</span>+n)-(sorted+<span class="number">1</span>);  <span class="comment">//离散化，数组中的数用排序后的下表表示</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            pos=lower_bound(sorted+<span class="number">1</span>,sorted+<span class="number">1</span>+num,nums[i])-sorted;</div><div class="line">            Insert(root[i],root[i<span class="number">-1</span>],pos,<span class="number">1</span>,num);    <span class="comment">//创建主席树中的一个又一个结点</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> l,r,k;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;l,&amp;r,&amp;k);</div><div class="line">            pos=query(root[l<span class="number">-1</span>],root[r],<span class="number">1</span>,num,k);</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sorted[pos]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="HDU-4348-区间增加-可持续化"><a href="#HDU-4348-区间增加-可持续化" class="headerlink" title="HDU 4348 区间增加+可持续化"></a>HDU 4348 区间增加+可持续化</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给出一个序列，并为每次插入操作添加时间点，进行一下操作：查询区间[l,r]的和；查询时间点k下的[l,r]区间和；更改时间点；为区间[l,r]添加数</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><ul>
<li>为每一个历史版本创建一颗线段树，同时充分利用共有数据，只增加有改变的结点</li>
<li>root数组记录每一个历史版本线段树的根节点信息</li>
<li>lazy思想，在查询的时候再进行向下的更改</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> segnode</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> lt,rt,lv,rv;     <span class="comment">//左右孩子结点的位置，维护的区间值</span></div><div class="line">    ll sum,lazy;      <span class="comment">//lazy思想，在查询的时候再进行修改</span></div><div class="line">&#125;tree[maxn&lt;&lt;<span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="keyword">int</span> cnt,now,a[maxn],root[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;id,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></div><div class="line">&#123;</div><div class="line">    tree[++cnt]=tree[id];</div><div class="line">    id=cnt;</div><div class="line">    tree[id].lv=l;</div><div class="line">    tree[id].rv=r;</div><div class="line">    <span class="keyword">if</span>(l==r)</div><div class="line">    &#123;</div><div class="line">        tree[id].sum=a[l];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">    build(tree[id].lt,l,mid);   <span class="comment">//引用的妙处</span></div><div class="line">    build(tree[id].rt,mid+<span class="number">1</span>,r);</div><div class="line">    tree[id].sum=tree[tree[id].lt].sum+tree[tree[id].rt].sum;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;id,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span></div><div class="line">&#123;</div><div class="line">    tree[++cnt]=tree[id];</div><div class="line">    id=cnt;</div><div class="line">    tree[id].sum+=(min(r,tree[id].rv)-max(l,tree[id].lv)+<span class="number">1</span>)*v;</div><div class="line">    <span class="keyword">if</span>(l&lt;=tree[id].lv &amp;&amp; tree[id].rv&lt;=r)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(tree[id].lv!=tree[id].rv)</div><div class="line">            tree[id].lazy+=v;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> mid=(tree[id].lv+tree[id].rv)&gt;&gt;<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(r&lt;=mid)</div><div class="line">        update(tree[id].lt,l,r,v);    <span class="comment">//引用的妙用</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid)</div><div class="line">        update(tree[id].rt,l,r,v);</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        update(tree[id].lt,l,r,v);</div><div class="line">        update(tree[id].rt,l,r,v);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(l&lt;=tree[id].lv &amp;&amp; tree[id].rv&lt;=r)</div><div class="line">        <span class="keyword">return</span> tree[id].sum;</div><div class="line">    ll ret=(min(r,tree[id].rv)-max(l,tree[id].lv)+<span class="number">1</span>)*tree[id].lazy;</div><div class="line">    <span class="keyword">int</span> mid=(tree[id].lv+tree[id].rv)&gt;&gt;<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(r&lt;=mid)</div><div class="line">        ret+=query(tree[id].lt,l,r);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid)</div><div class="line">        ret+=query(tree[id].rt,l,r);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        ret+=query(tree[id].lt,l,r)+query(tree[id].rt,l,r);</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,m,l,r,t,d;</div><div class="line">    <span class="keyword">char</span> op;</div><div class="line">    <span class="keyword">bool</span> hh=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m)!=EOF)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(hh)</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            hh=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">        now=cnt=<span class="number">0</span>;</div><div class="line">        build(root[<span class="number">0</span>],<span class="number">1</span>,n);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">" %c"</span>,&amp;op);    <span class="comment">//注意前面要加一个空格</span></div><div class="line">            <span class="keyword">if</span>(op==<span class="string">'C'</span>)</div><div class="line">            &#123;</div><div class="line">                now++; <span class="comment">//时间增加</span></div><div class="line">                <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;l,&amp;r,&amp;d);</div><div class="line">                update(root[now]=root[now<span class="number">-1</span>],l,r,d);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(op==<span class="string">'Q'</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;l,&amp;r);</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(root[now],l,r));</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(op==<span class="string">'H'</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;l,&amp;r,&amp;t);</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(root[t],l,r));</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(op==<span class="string">'B'</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;now);</div><div class="line">                cnt=root[now+<span class="number">1</span>]<span class="number">-1</span>;   <span class="comment">//释放结点</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.cnblogs.com/wujiechao/p/6419877.html" target="_blank" rel="external">博客1</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Codeforces Good Bye 2016 题解]]></title>
      <url>/2016/12/31/Codeforces-Good-Bye-2016-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>  2016的最后一场CF，很遗憾昨天没能打这场比赛。只能在今天——2016年的最后一天补上这套题。话说这场比赛是我开始接触CF以来看到报名的人最多的一场比赛，意义特殊。。<br>  从道题通过的人数来看八道题应该分成两个层次（这个跟平常的div1和div2差不多吧），前面四道题应该就是我这个水平做的，后面四道题做出来的人不超过200人，最后一道题做出来的人只有个位数。。。<br>  下面就是前面四道题的题解啦<br>  <a id="more"></a></p>
<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>大水题，数列求和，注意上限</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n,k,i;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</div><div class="line">	k=<span class="number">240</span>-k;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;k&gt;=<span class="number">5</span>*i&amp;&amp;i&lt;=n;++i)k-=<span class="number">5</span>*i;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,i<span class="number">-1</span>);![enter description here][<span class="number">1</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>将地球想象成一个均匀的球体，一个人从北极出发进行一次旅行，给出n个指令，每个指令包含行走的距离和行走的方向，判断旅行的旅行是否符合以下规则：1.在北极只能向南边走；2.在南极只能向北边走；3.最后要回到北极</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>以北极为坐标原点模拟旅行过程，设置标记变量标记是否在南北极，在南北极的时候就不能向东西方向走，同时判断行走的坐标点是否会超过20000或者小于0</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> o;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;o;</div><div class="line">	<span class="keyword">int</span> k,l,t=<span class="number">0</span>;</div><div class="line">	<span class="built_in">string</span> s;</div><div class="line">	l=<span class="number">1</span>;  <span class="comment">//标记在不在南北两级</span></div><div class="line">	<span class="keyword">while</span>(o--)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;k&gt;&gt;s;</div><div class="line">		<span class="keyword">if</span>(l)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(s==<span class="string">"East"</span>||s==<span class="string">"West"</span>)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(s==<span class="string">"North"</span>)</div><div class="line">		&#123;</div><div class="line">			t-=k;</div><div class="line">			<span class="keyword">if</span>(t&lt;<span class="number">0</span>)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(s==<span class="string">"South"</span>)</div><div class="line">		&#123;</div><div class="line">			t+=k;</div><div class="line">			<span class="keyword">if</span>(t&gt;<span class="number">20000</span>)</div><div class="line">			&#123;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(t==<span class="number">0</span>||t==<span class="number">20000</span>)</div><div class="line">			l=<span class="number">1</span>;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			l=<span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(t==<span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="同思路但十分简化的代码"><a href="#同思路但十分简化的代码" class="headerlink" title="同思路但十分简化的代码"></a>同思路但十分简化的代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n,p=<span class="number">0</span>,x;<span class="keyword">char</span> s[<span class="number">10</span>];</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">	<span class="keyword">while</span>(n--)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%s"</span>,&amp;x,s);</div><div class="line">		<span class="keyword">if</span>(!p&amp;&amp;s[<span class="number">0</span>]!=<span class="string">'S'</span>)<span class="keyword">return</span> <span class="number">0</span>*<span class="built_in">puts</span>(<span class="string">"NO"</span>);</div><div class="line">		<span class="keyword">if</span>(p==<span class="number">20000</span>&amp;&amp;s[<span class="number">0</span>]!=<span class="string">'N'</span>)<span class="keyword">return</span> <span class="number">0</span>*<span class="built_in">puts</span>(<span class="string">"NO"</span>);</div><div class="line">		<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'S'</span>)p+=x;</div><div class="line">		<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'N'</span>)p-=x;</div><div class="line">		<span class="keyword">if</span>(p&lt;<span class="number">0</span>||p&gt;<span class="number">20000</span>)<span class="keyword">return</span> <span class="number">0</span>*<span class="built_in">puts</span>(<span class="string">"NO"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">puts</span>(p?<span class="string">"NO"</span>:<span class="string">"YES"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><ul>
<li>对于英文题目，一开始理解的时候可能存在一些问题，在看懂样例之后一定要回去看原文，根据原文中的信息去写代码</li>
</ul>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题目以Codeforce的rating制度为背景，根据积分将用户的段位分成两个div1和div2，给出一个人2016年以来每次打比赛之前的所处的段位和比赛后的分数变化，根据这些来判断这个人最后可能最高的分数，可能的答案有：无穷大，不可能的情况，具体的数字</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><ul>
<li>模拟题，设置一个最大值和最小值的范围，根据每一句比赛所给的条件来更新这个范围，在div1则最小值一定在1900以上，在div2则最大值一定在1899以下，更新范围以后再模拟变化再一次更新范围</li>
<li>如果整个过程中出现一次div2，则永远都不会是无穷大</li>
<li>不可能情况的确定，最大值和最小值不符合实际</li>
</ul>
<h4 id="代码1（范围判断为最后结果的范围）"><a href="#代码1（范围判断为最后结果的范围）" class="headerlink" title="代码1（范围判断为最后结果的范围）"></a>代码1（范围判断为最后结果的范围）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> t,maxi=<span class="number">1</span>&lt;&lt;<span class="number">30</span>,mini=<span class="number">-1</span>&lt;&lt;<span class="number">30</span>,flag=<span class="number">1</span>;  <span class="comment">//是否可能是最大值</span></div><div class="line">	<span class="built_in">cin</span>&gt;&gt;t;</div><div class="line">	<span class="keyword">while</span>(t--)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> x,y;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</div><div class="line">		<span class="keyword">if</span>(y==<span class="number">1</span>&amp;&amp;mini&lt;<span class="number">1900</span>)mini=<span class="number">1900</span>;</div><div class="line">		<span class="keyword">if</span>(y==<span class="number">2</span>&amp;&amp;maxi&gt;<span class="number">1899</span>)maxi=<span class="number">1899</span>,flag=<span class="number">0</span>;</div><div class="line">		mini+=x,maxi+=x;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(flag)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Infinity"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(mini&gt;maxi)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Impossible"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;maxi&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="代码2（范围判断为一开始的范围）"><a href="#代码2（范围判断为一开始的范围）" class="headerlink" title="代码2（范围判断为一开始的范围）"></a>代码2（范围判断为一开始的范围）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = (<span class="keyword">int</span>) <span class="number">1e9</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> n;</div><div class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line">  <span class="keyword">int</span> from = -inf, to = inf;</div><div class="line">  <span class="keyword">int</span> delta = <span class="number">0</span>;    <span class="comment">//变化的值</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">    <span class="keyword">int</span> d, cur;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;cur, &amp;d);</div><div class="line">    <span class="keyword">if</span> (d == <span class="number">1</span>) &#123;</div><div class="line">      from = max(from, <span class="number">1900</span> - delta);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      to = min(to, <span class="number">1899</span> - delta);</div><div class="line">    &#125;</div><div class="line">    delta += cur;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (from &gt; to) &#123;</div><div class="line">    <span class="built_in">puts</span>(<span class="string">"Impossible"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (to == inf) &#123;</div><div class="line">    <span class="built_in">puts</span>(<span class="string">"Infinity"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, to + delta);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>以烟花爆炸为背景，相当与在由单位正方形组成的一个平面里面生成一颗树，在分岔点一定会一分为二，从跟到分支给出的是”树“的每一段的长度，求占用的点数（一个单位正方形代表一个点，可以重复占用一个点）</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><ul>
<li>模拟这个平面，使用dfs进行递归，计算占用的正方形的数量</li>
<li>dfs递归函数传入四个参数：位置坐标，当前递归层数，树枝伸展方向</li>
<li>去除重复操作：使用数组标记递归函数的执行情况，四个参数对应四维数组</li>
<li>貌似还可以用dp等方法做出来</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> dy[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,dx[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> used[<span class="number">400</span>][<span class="number">400</span>][<span class="number">31</span>][<span class="number">8</span>];    <span class="comment">//去除重复操作的标记数组</span></div><div class="line"><span class="keyword">bool</span> a[<span class="number">400</span>][<span class="number">400</span>];</div><div class="line"></div><div class="line"><span class="keyword">int</span> t,f[<span class="number">31</span>],h;  <span class="comment">//记录总数</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> d,<span class="keyword">int</span> l)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(used[x][y][d][l])<span class="keyword">return</span>;</div><div class="line">    used[x][y][d][l]=<span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span>(d==h)</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> ix=x,iy=y;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=f[d];i++)</div><div class="line">	&#123;</div><div class="line">	    ix+=dx[l];</div><div class="line">	    iy+=dy[l];</div><div class="line">	    <span class="keyword">if</span>(!a[ix][iy])</div><div class="line">			t++;</div><div class="line">		a[ix][iy]=<span class="literal">true</span>;</div><div class="line">	&#125;</div><div class="line">	dfs(ix,iy,d+<span class="number">1</span>,(l+<span class="number">1</span>)%<span class="number">8</span>);</div><div class="line">	dfs(ix,iy,d+<span class="number">1</span>,(l+<span class="number">7</span>)%<span class="number">8</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;h;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;h;i++)</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;f[i];</div><div class="line">	t=<span class="number">0</span>;</div><div class="line">	dfs(<span class="number">200</span>,<span class="number">200</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;t&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用uWSGI和nginx来搭建Django应用]]></title>
      <url>/2016/11/30/%E4%BD%BF%E7%94%A8uWSGI%E5%92%8Cnginx%E6%9D%A5%E6%90%AD%E5%BB%BADjango%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>近期用python的Django写了一个小程序，想部署到服务器上面。网上搜了一下，发现所有使用nginx的解决方案基本上都是来源于这篇文章。所以就把这篇文章翻译了一下，加深自己的理解。<br><a id="more"></a></p>
<p><a href="http://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html" target="_blank" rel="external">原文地址</a></p>
<p>这篇教程适用于想在生产服务器上搭建应用的Django使用者。只需要几部就可以让你用nginx和uWSGI搭建一个Django应用。它涵盖所有三个组件，提供一个完整的Web应用程序和服务器软件搭建方案。（It covers all three components, providing a complete stack of web application and server software.）</p>
<p>DJango是一个高质量的Web开发框架，鼓励快速、简介、务实的设计（pragmatic design）</p>
<p>nginx是一款免费、开源、高并发访问的HTTP服务器和反向代理以及IMAP/POP3 代理服务器</p>
<h3 id="这篇教程的一些笔记"><a href="#这篇教程的一些笔记" class="headerlink" title="这篇教程的一些笔记"></a>这篇教程的一些笔记</h3><blockquote>
<p>这只是一篇入门教程，它的目的不是提供一个全面的参考指南，不会为开发者提供一个详细的开发指南<br><br><br>nginx和uWSGI是DJango开发者的好选择，但不是唯一的或者说“官方”的选择。每一种方案都有优点，值得你去尝试。<br><br><br>这种方法也许是一种好的方法，但不是唯一的方法，从某些方面来说他甚至不是最好的方法<br><br><br>然而，这是一个可靠和简单的方法，这里涵盖的材料将向您介绍概念和程序，您将需要熟悉用于部署Django的任何软件。<br><br><br>在熟悉了这些配置和这些步骤之后，如果你能够探索其他的方法也能达到相同的目的</p>
</blockquote>
<hr>
<blockquote>
<p>这篇教程假定你的系统已经完成了一些配置<br><br><br>假定你使用的是进行可以进行包管理的Unix系列的系统。然而如果你有类似“Mac OS系统该怎样配置”这样的问题，你会很容易找到这类问题的答案。<br><br><br>这篇教程使用的是Django1.4或者更新版本，它能够在你新建的项目中创建一个wsgi模块。如果你使用的是更早期的版本的话，你需要自己去创建一个wsgi模块</p>
</blockquote>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>一个Web服务面向世界。它能够直接从系统提供一些文件（比如说HTML、图像、CSS等等）。然而，他不能直接从Django中获取，这需要一些东西来运行这些应用，比如来自客户端的请求和响应。</p>
<p><br><br>一个Web服务网关接口==WSGI，就是干这件事情的。WSGI是一个python的标准。<br><br></p>
<p>uWSGI是WSGI的一个实现工具，在这篇教程中我们将设置uWSGI从而创建一个Unix socket服务。服务响应通过WSGi协议来对传给web应用。最后，我们完成的主要原理图如下：</p>
<blockquote>
<p>the web client &lt;-&gt; the web server &lt;-&gt; the socket &lt;-&gt; uwsgi &lt;-&gt; Django</p>
</blockquote>
<h3 id="在开始设置uWSGI之前需要做的准备"><a href="#在开始设置uWSGI之前需要做的准备" class="headerlink" title="在开始设置uWSGI之前需要做的准备"></a>在开始设置uWSGI之前需要做的准备</h3><h5 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h5><p>确保你在虚拟环境下安装软件（稍后我们将介绍在原生系统中安装uWSGI）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">virtualenv uwsgi-tutorial</div><div class="line"><span class="built_in">cd</span> uwsgi-tutorial</div><div class="line"><span class="built_in">source</span> bin/activate</div></pre></td></tr></table></figure>
<h5 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h5><p> 在虚拟环境下安装Django,创建一个项目，并且通过<em>cd</em>来进入这个项目</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> pip install Django</div><div class="line">django-admin.py startproject mysite</div><div class="line"><span class="built_in">cd</span> mysite</div></pre></td></tr></table></figure>
<h5 id="关于域名和端口"><a href="#关于域名和端口" class="headerlink" title="关于域名和端口"></a>关于域名和端口</h5><p>教程中默认你的域名为：example.com  你可以替换成你的域名或者Ip地址<br><br><br>跟Django默认使用的端口一样，在这里我们将始终使用8000端口作为服务的对外端口。当然你也可以使用其他的你想用的端口，但是我使用这个端口并没有和之前的配置发生任何冲突。</p>
<hr>
<h3 id="基本uWSGI安装和配置"><a href="#基本uWSGI安装和配置" class="headerlink" title="基本uWSGI安装和配置"></a>基本uWSGI安装和配置</h3><h5 id="在你的虚拟环境中安装uWSGI"><a href="#在你的虚拟环境中安装uWSGI" class="headerlink" title="在你的虚拟环境中安装uWSGI"></a>在你的虚拟环境中安装uWSGI</h5><blockquote>
<p>pip install uwsgi</p>
</blockquote>
<p>当然还有其他的方式安装，不过这种方法是最好的一种。注意你必须要安装好相关的依赖包。例如在Debain或者像Ubuntu这样与Debain类似的系统中，你就需要安装pythonX.Y-dev（X.Y是你的python版本号）</p>
<h5 id="基础测试"><a href="#基础测试" class="headerlink" title="基础测试"></a>基础测试</h5><p>创建一个叫test.py的文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># test.py</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(env, start_response)</span>:</span></div><div class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>,<span class="string">'text/html'</span>)])</div><div class="line">    <span class="keyword">return</span> [<span class="string">b"Hello World"</span>] <span class="comment"># python3</span></div><div class="line">    <span class="comment">#return ["Hello World"] # python2</span></div></pre></td></tr></table></figure></p>
<hr>
<blockquote>
<p>笔记<br>注意python3需要使用bytes()</p>
</blockquote>
<p>运行uWSGI：</p>
<blockquote>
<p>uwsgi –http :8000 –wsgi-file test.py</p>
</blockquote>
<p>选项的意思：</p>
<blockquote>
<p>http :8000  使用http的8000端口<br>wsgi-file test.py  加载指定文件</p>
</blockquote>
<p>当你使用浏览器访问8000端口的时候应该会看到“Hello，World”的字样</p>
<blockquote>
<p><a href="http://example.com:8000" target="_blank" rel="external">http://example.com:8000</a></p>
</blockquote>
<p>检查如果是这样的话，说明一下这些部分没有问题了；</p>
<blockquote>
<p>the web client &lt;-&gt; uWSGI &lt;-&gt; Python</p>
</blockquote>
<h5 id="测试你的Django应用"><a href="#测试你的Django应用" class="headerlink" title="测试你的Django应用"></a>测试你的Django应用</h5><p>现在uWSGI做着同样的事情，只不过运行的是Django应用而不是test.py模块<br>如果你还没有做到这里，确保你的mysite项目能够工作：</p>
<blockquote>
<p>python manage.py runserver 0.0.0.0:8000</p>
</blockquote>
<p>如果他能够正常工作，就用uWSGI运行它：</p>
<blockquote>
<p>uwsgi –http :8000 –module mysite.wsgi</p>
</blockquote>
<ul>
<li>module mysite.wsgi 加载指定的uWSGI模块</li>
</ul>
<p>在你的浏览器中查看，如果服务能够正常运行，就意味着uWSGI能够从虚拟环境中运行Django应用，现在就到了这一步：</p>
<blockquote>
<p>the web client &lt;-&gt; uWSGI &lt;-&gt; Django</p>
</blockquote>
<p>我们一般不让客户端直接和uWSGI联系。这是Web服务器的工作，在其中扮演者中间人的角色。</p>
<h3 id="Nginx基本配置"><a href="#Nginx基本配置" class="headerlink" title="Nginx基本配置"></a>Nginx基本配置</h3><h5 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install nginx</div><div class="line">sudo /etc/init.d/nginx start    <span class="comment"># start nginx</span></div></pre></td></tr></table></figure>
<p>现在通过浏览器访问网站的80端口，你应该会看到nginx的一条信息：Welcome to nginx!。这就说明一下环节是打通的：</p>
<blockquote>
<p>the web client &lt;-&gt; the web server</p>
</blockquote>
<p>如果其他应用已经占据了80端口，但是你还是想使用nginx服务，你就要更改nginx监听另外的端口。在这篇教程中，我们将使用8000端口。</p>
<h5 id="在你的网站中配置nginx"><a href="#在你的网站中配置nginx" class="headerlink" title="在你的网站中配置nginx"></a>在你的网站中配置nginx</h5><p>你需要uwsgi_params 文件，它能够然nginx又uWSGI支配，你可以从这里<a href="https://github.com/nginx/nginx/blob/master/conf/uwsgi_params" target="_blank" rel="external">下载</a></p>
<p>将它复制到你的项目目录下，接下来nginx将会使用到它。<br>现在创建一个mysite_nginx.conf文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"># mysite_nginx.conf</div><div class="line"></div><div class="line"># the upstream component nginx needs to connect to</div><div class="line">upstream django &#123;</div><div class="line">    # server unix:///path/to/your/mysite/mysite.sock; # for a file socket</div><div class="line">    server 127.0.0.1:8001; # for a web port socket (we&apos;ll use this first)</div><div class="line">&#125;</div><div class="line"></div><div class="line"># configuration of the server</div><div class="line">server &#123;</div><div class="line">    # the port your site will be served on</div><div class="line">    listen      8000;</div><div class="line">    # the domain name it will serve for</div><div class="line">    server_name .example.com; # substitute your machine&apos;s IP address or FQDN</div><div class="line">    charset     utf-8;</div><div class="line"></div><div class="line">    # max upload size</div><div class="line">    client_max_body_size 75M;   # adjust to taste</div><div class="line"></div><div class="line">    # Django media</div><div class="line">    location /media  &#123;</div><div class="line">        alias /path/to/your/mysite/media;  # your Django project&apos;s media files - amend as required</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location /static &#123;</div><div class="line">        alias /path/to/your/mysite/static; # your Django project&apos;s static files - amend as required</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    # Finally, send all non-media requests to the Django server.</div><div class="line">    location / &#123;</div><div class="line">        uwsgi_pass  django;</div><div class="line">        include     /path/to/your/mysite/uwsgi_params; # the uwsgi_params file you installed</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个配置文件告诉nginx服务文件系统中那些媒体和静态文件，并且处理来自Django的请求。为你长远打算你也可以让一个服务处理media/static，另外一个服务处理Django请求，但在这里，这样刚刚好。</p>
<p>创建一个链接到/etc/nginx/sites-enabled让nginx能够识别它：</p>
<blockquote>
<p>sudo ln -s ~/path/to/your/mysite/mysite_nginx.conf /etc/nginx/sites-enabled/</p>
<h5 id="部署静态文件"><a href="#部署静态文件" class="headerlink" title="部署静态文件"></a>部署静态文件</h5></blockquote>
<p>在运行nginx之前，你要在static目录下收集Django用到的静态文件，首先你要在mysite/settings.py中加上：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">STATIC_ROOT = os.path.join(BASE_DIR, <span class="string">"static/"</span>)</div></pre></td></tr></table></figure></p>
<p>然后运行</p>
<blockquote>
<p>python manage.py collectstatic</p>
<h5 id="基本nginx测试"><a href="#基本nginx测试" class="headerlink" title="基本nginx测试"></a>基本nginx测试</h5></blockquote>
<p>重启nginx服务</p>
<blockquote>
<p> sudo /etc/init.d/nginx restart<br>为了检查media文件是否正确，在/path/to/your/project/project/media directory添加一张图片media.png ，然后访问<a href="http://example.com:8000/media/media.png" target="_blank" rel="external">http://example.com:8000/media/media.png</a>  。如果起作用，至少说明nginx能够提供服务。<br>你可以不重启nginx服务，而是先关掉他，然后再重新打开，这样你就会发现一些问题。</p>
</blockquote>
<h3 id="nginx、uWSGI和test-py"><a href="#nginx、uWSGI和test-py" class="headerlink" title="nginx、uWSGI和test.py"></a>nginx、uWSGI和test.py</h3><p>让我们将nginx与‘hello word’的test.py应用连接起来</p>
<blockquote>
<p>uwsgi –socket :8001 –uwsgi-file test.py     #刚才nginx对内的端口是8001</p>
</blockquote>
<p>除了这个部分，这次跟前面一样：</p>
<blockquote>
<p>socket :8001   #使用uwsgi协议，8001端口</p>
</blockquote>
<p>nginx同时也配置成在那个端口与uWSGI相连接，外网连接的端口是8000端口</p>
<p><em><a href="http://example.com:8000/" target="_blank" rel="external">http://example.com:8000/</a></em></p>
<p>点击一下，说明我们现在所处的阶段是：</p>
<blockquote>
<p>the web client &lt;-&gt; the web server &lt;-&gt; the socket &lt;-&gt; uWSGI &lt;-&gt; Python</p>
</blockquote>
<p>于此同时你也可以访问uWSGI的对外端口：8000，但是有非常大的可能他是不会工作的因为你的浏览器使用的是http而不是uWSGI，虽然你能够在你的终端上看到来自uWSGI的输出</p>
<h3 id="使用Unix-sockets来代替端口"><a href="#使用Unix-sockets来代替端口" class="headerlink" title="使用Unix sockets来代替端口"></a>使用Unix sockets来代替端口</h3><p>现在为止我们已经使用了TCP端口（因为它很简单），但是事实上用Unix sockets比端口更好——他会减少很多麻烦（here’s less overhead）</p>
<p>编辑文件 <em>mysite_nginx.conf</em> ，把它改成这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">server unix:///path/to/your/mysite/mysite.sock; <span class="comment"># for a file socket</span></div><div class="line"><span class="comment"># server 127.0.0.1:8001; # for a web port socket (we'll use this first)</span></div></pre></td></tr></table></figure>
<p>然后重启nginx服务</p>
<p>重新运行uWSGI：</p>
<blockquote>
<p>uwsgi –socket mysite.sock –wsgi-file test.py</p>
</blockquote>
<p>这个时候socket告诉uWSGI他要用哪个文件</p>
<p>在浏览器里面再次打开连接<a href="http://example.com:8000/" target="_blank" rel="external">http://example.com:8000/</a> 吧</p>
<h5 id="如果不起作用"><a href="#如果不起作用" class="headerlink" title="如果不起作用"></a>如果不起作用</h5><p>检查你的nginx日志文件（/var/log/nginx/error.log），如果你看到下面的错误：</p>
<blockquote>
<p> connect() to unix:///path/to/your/mysite/mysite.sock failed (13: Permissiondenied)</p>
</blockquote>
<p>也许你需要管理权限允许nginx使用socket</p>
<p>尝试：</p>
<blockquote>
<p>uwsgi –socket mysite.sock –wsgi-file test.py –chmod-socket=666 # (very permissive)</p>
</blockquote>
<p>或者：</p>
<blockquote>
<p>uwsgi –socket mysite.sock –wsgi-file test.py –chmod-socket=664 # (more sensible)</p>
</blockquote>
<p>你可能还需要添加你的用户到nginx的用户群中去（可能是类似www-data这样的），这样nginx就可以读写你的socket了</p>
<p>nginx的日志文件值得你在终端一直打开，这样你就可以很容易排除错误</p>
<h3 id="使用uWSGI和nginx来运行Django应用"><a href="#使用uWSGI和nginx来运行Django应用" class="headerlink" title="使用uWSGI和nginx来运行Django应用"></a>使用uWSGI和nginx来运行Django应用</h3><p>让我们来运行我们的Django 应用：</p>
<blockquote>
<p>uwsgi –socket mysite.sock –module mysite.wsgi –chmod-socket=664</p>
</blockquote>
<p>现在uWSGI和nginx应该不只是显示‘hello，world’了，而是你的Django应用。</p>
<h3 id="配置一个-ini文件来让你的uWSGI运行"><a href="#配置一个-ini文件来让你的uWSGI运行" class="headerlink" title="配置一个.ini文件来让你的uWSGI运行"></a>配置一个.ini文件来让你的uWSGI运行</h3><p>我们可以将一些我们常用的uWSGI选项加入一个文件中，然后让uWSGI去运行这个文件，这能够让我们更好得管理我们的配置</p>
<p>创建一个文件mysite_uwsgi.ini</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># mysite_uwsgi.ini file</div><div class="line">[uwsgi]</div><div class="line"></div><div class="line"># Django-related settings</div><div class="line"># the base directory (full path)</div><div class="line">chdir           = /path/to/your/project</div><div class="line"># Django&apos;s wsgi file</div><div class="line">module          = project.wsgi</div><div class="line"># the virtualenv (full path)</div><div class="line">home            = /path/to/virtualenv</div><div class="line"></div><div class="line"># process-related settings</div><div class="line"># master</div><div class="line">master          = true</div><div class="line"># maximum number of worker processes</div><div class="line">processes       = 10</div><div class="line"># the socket (use the full path to be safe</div><div class="line">socket          = /path/to/your/project/mysite.sock</div><div class="line"># ... with appropriate permissions - may be needed</div><div class="line"># chmod-socket    = 664</div><div class="line"># clear environment on exit</div><div class="line">vacuum          = true</div></pre></td></tr></table></figure>
<p>然后用这个文件运行uWSGI：</p>
<blockquote>
<p>uwsgi –ini mysite_uwsgi.ini # the –ini option is used to specify a file<br>（注意这里同时也要给socket加权限才可以）</p>
</blockquote>
<p>测试Django应用是否运行成功</p>
<h3 id="在本地系统中运行uWSGI"><a href="#在本地系统中运行uWSGI" class="headerlink" title="在本地系统中运行uWSGI"></a>在本地系统中运行uWSGI</h3><p>到目前为止，uWSGI只能够在我们的虚拟环境下运行，为了开发我们要将他放在本地系统中</p>
<p>退出虚拟环境：</p>
<blockquote>
<p>deactivate</p>
</blockquote>
<p>在本地系统安装uWSGI：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo pip install uwsgi</div><div class="line"></div><div class="line"><span class="comment"># Or install LTS (long term support).</span></div><div class="line">pip install http://projects.unbit.it/downloads/uwsgi-lts.tar.gz</div></pre></td></tr></table></figure>
<p>uWSGI的Wiki中有一个<a href="http://projects.unbit.it/uwsgi/wiki/Install" target="_blank" rel="external">安装说明</a>，在安装之前，值得你去考虑使用哪个版本并且使用最合适的方式去安装它</p>
<p>再一次检查你能够跟之前一样运行uWSGI：</p>
<blockquote>
<p>uwsgi –ini mysite_uwsgi.ini # the –ini option is used to specify a file</p>
</blockquote>
<h3 id="Emperor-模式"><a href="#Emperor-模式" class="headerlink" title="Emperor 模式"></a>Emperor 模式</h3><p>uWSGI能够运行emperor模式。再这个模式下，能够监视uWSGI的配置文件，并且为每种情况产生样例（will spawn instances (‘vassals’) for each one it finds.）</p>
<p>每次只要配置文件修改了，emperor就会自动重启服务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># create a directory for the vassals</span></div><div class="line">sudo mkdir /etc/uwsgi</div><div class="line">sudo mkdir /etc/uwsgi/vassals</div><div class="line"><span class="comment"># symlink from the default config directory to your config file</span></div><div class="line">sudo ln <span class="_">-s</span> /path/to/your/mysite/mysite_uwsgi.ini /etc/uwsgi/vassals/</div><div class="line"><span class="comment"># run the emperor</span></div><div class="line">uwsgi --emperor /etc/uwsgi/vassals --uid www-data --gid www-data</div></pre></td></tr></table></figure></p>
<p>你可能要用到超级用户的权限来运行：</p>
<blockquote>
<p>sudo uwsgi –emperor /etc/uwsgi/vassals –uid www-data –gid www-data</p>
</blockquote>
<p>选项的含义：</p>
<ul>
<li>emperor ： 去哪里找到服务</li>
<li>uid: 启动的用户id</li>
<li>gid：启动的群id</li>
</ul>
<p>检查一下站点服务，它应该能够成功运行</p>
<h3 id="让uWSGI自启动"><a href="#让uWSGI自启动" class="headerlink" title="让uWSGI自启动"></a>让uWSGI自启动</h3><p>最后一步就是让以上这些在开机的时候能够自启动</p>
<p>你只需要编辑/etc/rc.local 并添加：</p>
<blockquote>
<p>/usr/local/bin/uwsgi –emperor /etc/uwsgi/vassals –uid www-data –gid www-data –daemonize /var/log/uwsgi-emperor.log</p>
</blockquote>
<p>更加全面的ini配置文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">[uwsgi]</div><div class="line">uid = www                                        <span class="comment"># 设置启动的用户组</span></div><div class="line">gid = www</div><div class="line"> </div><div class="line"><span class="built_in">chdir</span> = /alidata/www/fdcode/devops               <span class="comment"># 指定项目目录</span></div><div class="line"> </div><div class="line">module = wsgi                                    <span class="comment"># 加载wsgi.py模块</span></div><div class="line"> </div><div class="line">master = <span class="literal">true</span>                                    <span class="comment"># 启动主进程，一般设置true或 1</span></div><div class="line"> </div><div class="line">processes = 2                                    <span class="comment"># 设置启动的进程数</span></div><div class="line"> </div><div class="line">listen = 100                                     <span class="comment"># 设置socket监听队列大小，超出队列的请求将会被拒绝</span></div><div class="line"> </div><div class="line">;socket = /var/run/uwsgi/uwsgi.sock              <span class="comment"># 设置socket监听</span></div><div class="line"> </div><div class="line">socket = :9090                                   <span class="comment"># 设置端口监听</span></div><div class="line"> </div><div class="line">pidfile = /var/run/uwsgi/uwsgi.pid               <span class="comment"># 指定pid文件</span></div><div class="line"> </div><div class="line">vacuum = <span class="literal">true</span>                                    <span class="comment"># 当服务器退出的时候自动删除unixsocket文件和pid文件。</span></div><div class="line"> </div><div class="line"><span class="built_in">enable</span>-threads = <span class="literal">true</span>                            <span class="comment"># 允许用内嵌的语言启动线程。这将允许你在app程序中产生一个子线程</span></div><div class="line"> </div><div class="line">buffer-size = 32768                              <span class="comment"># 设置用于uwsgi包解析的内部缓存区大小为64k。默认是4k。</span></div><div class="line"> </div><div class="line">reload-mercy = 8                                 <span class="comment"># 设置在平滑的重启（直到接收到的请求处理完才重启）一个工作子进程中，等待这个工作结束的最长秒数。这个配置会使在平滑地重启工作子进程中，如果工作进程结束时间超过了8秒就会被强行结束（忽略之前已经接收到的请求而直接结束）</span></div><div class="line"> </div><div class="line">max-requests = 5000                              <span class="comment"># 为每个工作进程设置请求数的上限。当一个工作进程处理的请求数达到这个值，那么该工作进程就会被回收重用（重启）。你可以使用这个选项来默默地对抗内存泄漏</span></div><div class="line"> </div><div class="line"><span class="built_in">limit</span>-as = 512                                   <span class="comment"># 通过使用POSIX/UNIX的setrlimit()函数来限制每个uWSGI进程的虚拟内存使用数。这个配置会限制uWSGI的进程占用虚拟内存不超过256M。如果虚拟内存已经达到256M，并继续申请虚拟内存则会使程序报内存错误，本次的http请求将返回500错误。</span></div><div class="line"> </div><div class="line">harakiri = 60                                    <span class="comment"># 一个请求花费的时间超过了这个harakiri超时时间，那么这个请求都会被丢弃，并且当前处理这个请求的工作进程会被回收再利用（即重启）</span></div><div class="line"> </div><div class="line">daemonize = /alidata/<span class="built_in">log</span>/uwsgi/uwsgi_server.log  <span class="comment"># 使进程在后台运行，并将日志打到指定的日志文件或者udp服务器</span></div></pre></td></tr></table></figure></p>
<h2 id="总结一波"><a href="#总结一波" class="headerlink" title="总结一波"></a>总结一波</h2><p>在一开始的流程图中各段的实现：</p>
<ul>
<li><p>the web client &lt;-&gt; the web server<br>通过nginx服务器，监听的是8000端口。配置文件：mysite_nginx.conf</p>
</li>
<li><p>the web server &lt;-&gt; the socket<br>nginx配置文件指定socket,  在配置文件中添加sock路径  我这里是htmltest/htmltest.sock   配置文件：mysite_nginx.conf</p>
</li>
<li><p>the socket &lt;-&gt; uwsgi<br>通过指定socket（给出socket的路径） 配置文件：mysite_uwsgi.ini  （注意要在配置中给uWSGI权限）</p>
</li>
<li><p>uwsgi &lt;-&gt; Django<br>通过指定服务模块  配置文件：mysite_uwsgi.ini</p>
</li>
</ul>
<p>第一次翻译文章，如果有什么恰当的地方望指正。</p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Codeforces #381（Div.2）题解]]></title>
      <url>/2016/11/25/Codeforces-381%EF%BC%88Div-2%EF%BC%89%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>第二次打CF，一开始的读题速度是快了一点但是在英语环境下对题目中的一些细节和关键部分的理解还是有待加强。<br>这次想玩玩hack结果锁定题目太早了，导致A马上就被hack了，改都不能改，哎，好气啊。。。</p>
<a id="more"></a>
<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>Alynoa去买书，1、2、3本书套装的售价分别为a、b、c，已知Alynoa手中有n本书，假设他买了k本书后总共拥有的书的数量能够被4整除，求他购买这k本书的最小花费。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul>
<li>一开始想到的就是模拟，分四种情况（需要0/1/2/3本书）进行讨论，需要注意的是除0外的每种情况下都有三种选择，要从这些方案中找到一个最小消耗方案（一开始被hack了）</li>
<li>后面发现可以用DP做（感觉有点大财小用），状态转移方程为 <em>dp[i]=min(dp[i-1]+a,dp[i-2]+b,dp[i-3]+c)</em></li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>模拟做法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span>  n,a,b,c,p,res;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</div><div class="line">        p=n%<span class="number">4</span>;</div><div class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        p=<span class="number">4</span>-p;</div><div class="line">        <span class="keyword">if</span>(p==<span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            res=min(a,min(<span class="number">3</span>*c,b+c));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(p==<span class="number">2</span>)</div><div class="line">            res=min(<span class="number">2</span>*a,min(b,<span class="number">2</span>*c));</div><div class="line">        <span class="keyword">if</span>(p==<span class="number">3</span>)</div><div class="line">            res=min(<span class="number">3</span>*a,min(c,a+b));</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>DP 做法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span>  n,a,b,c,res;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> co[<span class="number">10</span>];</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</div><div class="line">    &#123;</div><div class="line">        res=<span class="number">1e18</span>;</div><div class="line">        fill(co,co+<span class="number">9</span>,<span class="number">1e18</span>);</div><div class="line">        co[<span class="number">0</span>]=<span class="number">0</span>;  <span class="comment">//没买书的花费为0</span></div><div class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</div><div class="line">        <span class="keyword">if</span>(n%<span class="number">4</span>==<span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)   <span class="comment">//最多买9本书</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">1</span>)co[i]=min(co[i],co[i<span class="number">-1</span>]+a);</div><div class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">2</span>)co[i]=min(co[i],co[i<span class="number">-2</span>]+b);</div><div class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">3</span>)co[i]=min(co[i],co[i<span class="number">-3</span>]+c);</div><div class="line">            <span class="keyword">if</span>((n+i)%<span class="number">4</span>==<span class="number">0</span>)res=min(res,co[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><h4 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h4><p>给出一些花的魅力值和花的一些组合（给出花魅力值的几个区间），求从这些组合中取出某几个中的花的魅力总数最大。</p>
<blockquote>
<p>The first line contains two integers n and m (1 ≤ n, m ≤ 100) — the number of flowers and the number of subarrays suggested by the mother.</p>
<p>The second line contains the flowers moods — n integers a1, a2, …, an ( - 100 ≤ ai ≤ 100).</p>
<p>The next m lines contain the description of the subarrays suggested by the mother. The i-th of these lines contain two integers li and ri (1 ≤ li ≤ ri ≤ n) denoting the subarray a[li], a[li + 1], …, a[ri].</p>
<p>Each subarray can encounter more than once.</p>
</blockquote>
<hr>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul>
<li>将给出的每个区间的花的魅力值相加，如果和为负就舍弃，和为正加入，算出最后的总和</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,m,a[<span class="number">101</span>],s[<span class="number">101</span>],res,i,j,x,y;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</div><div class="line">    &#123;</div><div class="line">        res=s[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</div><div class="line">            s[i]=s[i<span class="number">-1</span>]+a[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(m--)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</div><div class="line">            j=s[y]-s[x<span class="number">-1</span>];</div><div class="line">            <span class="keyword">if</span>(j&gt;<span class="number">0</span>)      <span class="comment">//只取和为正的区间</span></div><div class="line">                res+=j;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><h4 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h4><p>首先给出mex的定义：在数组中不存在的最小正整数。然后给出一个数组的长度n，和m个子数组区间（起止点），求依据这个信息能够构造的一个数组，使得所有的mex的最小值最大。并输出这个数组。</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ul>
<li>mex不难求，整体的mex最小值也很容易找到（就是所有给出区间长度的最小值+1）。关键是后面数组的构造。</li>
<li>构造数组的方法，假设我们找到的最大的mex最小值为mexi，从数组开始0-mexi不停的循环赋值，因为求得的mexi是最小的并且构造是连续的，凡事数组长度大于mexi的区间都会有0-mex的所有数，这样这个区间就不会出现其mex值比发现的mexi值小的情况。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"></div><div class="line">ll a[<span class="number">100005</span>],b[<span class="number">100005</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,m;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</div><div class="line">    &#123;</div><div class="line">        ll res=<span class="number">1e10</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;a[i]&gt;&gt;b[i];</div><div class="line">            res=min(res,b[i]-a[i]+<span class="number">1</span>);     <span class="comment">//取最小的mex值</span></div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">int</span> tem=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(n--)     <span class="comment">//重复不断地从0-mexi赋值</span></div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;tem&lt;&lt;<span class="string">" "</span>;</div><div class="line">            tem++;</div><div class="line">            <span class="keyword">if</span>(tem==res)</div><div class="line">                tem=<span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>在理解题意、解题速度方面，英语还是一个很大的障碍。这次比赛就是因为英语，在很多地方对题目的理解都存在偏差。要学好英语</li>
<li>因为好奇hack是什么，所以A题一过样例就锁定了，结果被hack了还不能改。呜呜呜。。。hack是高手玩的东西，以后不要一过了就锁定题目，要hack也要等快结束了再玩（不过话说那个时候能hack的就已经被hack得差不多了。。。）</li>
<li>练水题速度、练水题速度、练水题速度。重要的事情说三遍！</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初次打codeforces]]></title>
      <url>/2016/11/16/%E5%88%9D%E6%AC%A1%E6%89%93codeforces/</url>
      <content type="html"><![CDATA[<p>今天凌晨开始了的第一把CF（并不是TC的CF），第一次做全英文的题目，第一次在国外的的平台上比赛，还是有一些鸡冻的。昨天大致的看了看codeforces，感觉确实比国内的一些平台做得好（在比赛中的体验也确实是这样），特别是看到传说中的tourist大神，看到他的rating曲线，感觉好牛逼啊。。。。。。<br><a id="more"></a><br><img src="http://oeziv5rwi.bkt.clouddn.com/2016/11/16/001.PNG" alt=""><br>看了看题目，前面两道题的确是大水题，注意数据范围基本上可以一次性AC。<br><img src="http://oeziv5rwi.bkt.clouddn.com/2016/11/16/002.PNG" alt=""><br>因为是全英文的理解题意还是需要一段时间的（原谅我这个英语渣渣），前面两道题花了40分钟，感觉应该再快一点的（第一次打这个比赛总是小心翼翼的）。<br>到了第三题，光看懂题目的意思我就花了二十多分钟差不多半个小时，看懂题目以后觉得是一个贪心题，然后找各种优化，但是总是超时，然后继续找办法优化，然后就一直一直卡在这里了（当我意识可以看看后面有没有题可以的时候，就只有十分钟左右了），就这样我的第一次CF就这样结束了。。。。。</p>
<hr>
<p>只A了两题，第一次比赛以后我的状态是这样的<br><img src="http://oeziv5rwi.bkt.clouddn.com/2016/11/16/003.PNG" alt=""><br>今天早上起来看了看官方的题解，发现昨天的C题我的思路是对的，但是我忽视了一个两个单词：<strong>not decreasing</strong> 他还特别设置为粗体，但是我就是没看到，求英语不好的我心理阴影面积有多大。。。<br>下面贴上我C题的题解吧：</p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>安东正在玩一个非常有趣的电脑游戏，但现在他被困在一个级别。要传递到下一个级别，他必须准备n药水。</p>
<p>安东有一个特殊的水壶，可以在x秒内准备一瓶药水。此外，他知道两种类型的法术，可以更快的准备药水的过程。</p>
<ul>
<li>这种类型的法术加速了一个药水的准备时间。有这种类型的m个咒语，其中的第i个成本bi manapoints和改变每个药水的准备时间为ai而不是x。</li>
<li>这种类型的法术会立即准备一些魔药。有这样的法术，第i个成本di manapoints和立即创建ci药剂。</li>
</ul>
<p>安东可以使用不超过一个第一类型的法术，不超过一个第二类型的法术，并且使用的manapoint的总数不应超过s。考虑到所有的法术都在瞬间使用，在安东开始准备魔药之前。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>输入的第一行包含三个整数n，m，k（1≤n≤2·109，1≤m，k≤2·105） -  Anton必须生成的药剂数量，第一类型和第二类型的法术的数量。</p>
<p>输入的第二行包含两个整数x和s（2≤x≤2·109,1≤s≤2·109） - 准备一个部分所需的初始秒数和Anton可以使用的manapoint数。</p>
<p>第三行包含m个整数ai（1≤ai&lt;x） - 如果使用第一类型的第i个法术，则准备一个药剂所需的秒数。</p>
<p>第四行包含m个整数bi（1≤bi≤2·109） - 使用第一类型第i个咒语的manapoints数量。</p>
<p>在第五行中有k个整数ci（1≤ci≤n） - 如果使用第二类型的第i个咒语，将立即创建的药剂数。保证ci不减小，即如果i &lt;j，则ci≤cj。</p>
<p>第六行包含k个整数di（1≤di≤2·109） - 使用第二个类型的第i个咒语所需的manapoint数量。保证di不减小，即如果i &lt;j，则di≤dj。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>打印一个整数 - 为了准备n个药水，花费的最少时间。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>因为后面给的第二种类型的法术是递增的（包括获得的药水数量和消耗的体力），这样我们就可以使用二分查找（upper_bound函数）找到，进行第一种类型的法术选择以后的第二种的最优策略，这样时间复杂度就是O(m*logk)了</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 200005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> in(a) scanf(<span class="meta-string">"%d"</span>,&amp;a)</span></div><div class="line"></div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m,k,x,s;</div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAXSIZE],b[MAXSIZE],c[MAXSIZE],d[MAXSIZE];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> i;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;s;  <span class="comment">//数据输入</span></div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;b[i];</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;c[i];</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;d[i];</div><div class="line"></div><div class="line">        a[m]=x;</div><div class="line">        b[m]=<span class="number">0</span>;</div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> imin,o,e;</div><div class="line">        imin=n*x;</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=m;i++)</div><div class="line">        &#123;</div><div class="line">            o=s-b[i];</div><div class="line">            <span class="keyword">if</span>(o&lt;<span class="number">0</span>)</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            e=upper_bound(d,d+k,o)-d;</div><div class="line">            <span class="keyword">if</span>(e)</div><div class="line">                imin=min(a[i]*(n-c[e<span class="number">-1</span>]),imin);    </div><div class="line">            <span class="keyword">else</span>     <span class="comment">//注意不进行第二次选择的情况</span></div><div class="line">                imin=min(a[i]*n,imin);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;imin&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><ul>
<li>在cf的比赛中，比赛时提交的程序只进行一部分测试点的测试，比赛结束以后重新验证测试点会多好多</li>
<li>初始rating积分是1500，我竟然少了几十分。。。。听说这个积分的计算用到的是一个叫<em>Elo rating system</em>的东西，看起来好高大上的样子。（<a href="https://en.wikipedia.org/wiki/Elo_rating_system" target="_blank" rel="external">维基的解释</a>）</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 点滴 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ 3253 Fence Repair 题解]]></title>
      <url>/2016/11/09/POJ-3253-Fence-Repair-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>Fence Repair</p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Farmer John wants to repair a small length of the fence around the pasture. He measures the fence and finds that he needs N (1 ≤ N ≤ 20,000) planks of wood, each having some integer length Li (1 ≤ Li ≤ 50,000) units. He then purchases a single long board just long enough to saw into the N planks (i.e., whose length is the sum of the lengths Li). FJ is ignoring the “kerf”, the extra length lost to sawdust when a sawcut is made; you should ignore it, too.FJ sadly realizes that he doesn’t own a saw with which to cut the wood, so he mosies over to Farmer Don’s Farm with this long board and politely asks if he may borrow a saw.Farmer Don, a closet capitalist, doesn’t lend FJ a saw but instead offers to charge Farmer John for each of the N-1 cuts in the plank. The charge to cut a piece of wood is exactly equal to its length. Cutting a plank of length 21 costs 21 cents.Farmer Don then lets Farmer John decide the order and locations to cut the plank. Help Farmer John determine the minimum amount of money he can spend to create the N planks. FJ knows that he can cut the board in various different orders which will result in different charges since the resulting intermediate planks are of different lengths.<br><a id="more"></a></p>
<hr>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>Line 1: One integer N, the number of planks<br>Lines 2..N+1: Each line contains a single integer describing the length of a needed plank</p>
<hr>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>Line 1: One integer: the minimum amount of money he must spend to make N-1 cuts</p>
<hr>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><p>3<br>8<br>5<br>8</p>
<hr>
<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><p>34</p>
<hr>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>将一块很长的木板切成N快，给出处理以后的的木板长度，求切割的成本。其中切割成本计算方法：将一块木板切割成两份的成本为切割前的木板长度。</p>
<hr>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ol>
<li>逆向推导，使用贪心算法，每次都只取长度最小的两块木板，计算这次切割的成本以后，将其当做新的未被切割的木板进行下一步操作</li>
<li>就是哈夫曼编码中构造哈夫曼树的过程</li>
</ol>
<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;   <span class="comment">//用int提交时数据会溢出</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    ans=<span class="number">0</span>;</div><div class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; p;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">    <span class="keyword">int</span> i,x;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cin</span>&gt;&gt;x;</div><div class="line">        p.push(x);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(p.size()!=<span class="number">1</span>)   <span class="comment">//每次取两个木板合并</span></div><div class="line">    &#123;</div><div class="line">        x=<span class="number">0</span>;</div><div class="line">        x+=p.top();</div><div class="line">        p.pop();</div><div class="line">        x+=p.top();</div><div class="line">        p.pop();</div><div class="line">        p.push(x);</div><div class="line">        ans+=x;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</div><div class="line">    <span class="comment">//freopen("input.txt","r",stdin);</span></div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 哈夫曼编码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[poj 2386 Laking Counting]]></title>
      <url>/2016/11/08/poj-2386-Laking-Counting/</url>
      <content type="html"><![CDATA[<p>Lake Counting</p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’).  Farmer John would like to figure out how many ponds have formed in his field.  A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors.</p>
<p>Given a diagram of Farmer John’s field, determine how many ponds he has.<br><a id="more"></a></p>
<hr>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><ul>
<li><p>Line 1: Two space-separated integers: N and M</p>
</li>
<li><p>Lines 2..N+1: M characters per line representing one row of Farmer John’s field.  Each character is either ‘W’ or ‘.’.  The characters do not have spaces between them.</p>
</li>
</ul>
<hr>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><ul>
<li>Line 1: The number of ponds in Farmer John’s field.</li>
</ul>
<hr>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><p>10 12<br>W……..WW.<br>.WWW…..WWW<br>….WW…WW.<br>………WW.<br>………W..<br>..W……W..<br>.W.W…..WW.<br>W.W.W…..W.<br>.W.W……W.<br>..W…….W.</p>
<hr>
<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><p>3</p>
<hr>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给出N*M的矩形土地以及土地中的积水位置（用W表示），要求整块矩形土地中的连续积水的区域数量</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><blockquote>
<p>1.采用深度优先搜索，对于一块连续的积水区域用一次深度优先搜索就可以将所有的W区域置为.<br>2.记录总共要进行几次这样的深度优先搜索，就是矩形区域内的连续积水区域的数量</p>
</blockquote>
<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mm(a) memset(a,1,sizeof(a))</span></div><div class="line"><span class="keyword">char</span> b[<span class="number">101</span>][<span class="number">101</span>];</div><div class="line"><span class="keyword">int</span> n,m;</div><div class="line"><span class="keyword">int</span> ans;  <span class="comment">//进行深度优先搜索的次数</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> d)</span>  <span class="comment">//深度优先搜索算法实现</span></span></div><div class="line">&#123;</div><div class="line">    b[a][d]=<span class="string">'.'</span>;</div><div class="line">    <span class="keyword">int</span> x,y,dx,dy;</div><div class="line">    <span class="keyword">for</span>(dx=<span class="number">-1</span>;dx&lt;<span class="number">2</span>;dx++)</div><div class="line">        <span class="keyword">for</span>(dy=<span class="number">-1</span>;dy&lt;<span class="number">2</span>;dy++)</div><div class="line">        &#123;</div><div class="line">            x=a+dx;</div><div class="line">            y=d+dy;</div><div class="line">            <span class="keyword">if</span>(x&gt;<span class="number">0</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;<span class="number">0</span>&amp;&amp;y&lt;=m&amp;&amp;b[x][y]==<span class="string">'W'</span>)</div><div class="line">                dfs(x,y);</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    ans=<span class="number">0</span>;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;b[i][j];</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(b[i][j]==<span class="string">'W'</span>)</div><div class="line">            &#123;</div><div class="line">                dfs(i,j);</div><div class="line">                ans++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</div><div class="line">    solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[锐雯上单不给就送——题解]]></title>
      <url>/2016/11/03/%E9%94%90%E9%9B%AF%E4%B8%8A%E5%8D%95%E4%B8%8D%E7%BB%99%E5%B0%B1%E9%80%81-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>15安徽省赛D题</p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>《英雄联盟》（简称LOL）是由美国Riot Games开发，腾讯游戏运营的英雄对战网游。《英雄联盟》除了即时战略、团队作战外，还拥有特色的英雄、自动匹配的战网平台，包括天赋树、召唤师系统、符文等元素。简单来说，LOL是一个10人组的对战游戏，一个队伍(5个人)对抗另一个队伍(5个人)，主要目的是拆掉对面的建筑物，一个每个队伍的英雄都扮演着不同的角色，分别为“上单”，“打野”，“中单”，“辅助”，“ADC”，通常的情况是各自队伍的“上单”VS“上单”，“打野”VS“打野”，“中单”VS“中单”，“辅助”VS“辅助”，“ADC”VS“ADC”。上单在LOL中一直是一个很吃香的角色，一般小学生进入匹配以后都会强调一句“锐雯上单不给就送”作为联络暗号。zz_1215和devtang经常玩这个游戏，zz_1215是devtang的宿敌，devtang很想知道zz_1215玩的什么角色，然后他就选同样的角色和zz_1215决斗(solo)。经过观察devtang发现zz_1215选择什么角色是有规律的，那就是取决于他上一次玩的什么角色。现用一个5*5的矩阵来表示，表示上一次如果zz_1215玩的是第j个角色，那么他这一次玩第i个角色的概率为，另外有。现在知道zz_1215第一次玩的是什么角色，devtang想知道在第n次游戏中，zz_1215最有可能玩的是什么角色。<br><a id="more"></a></p>
<hr>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>首先是一个正整数T，表示有T组数据<br>每组数据包括<br>第一行是一个数字n，表示devtang想知道第n次游戏中zz_1215最可能玩的角色<br>接下来会给出5*5的矩阵表示概率关系<br>最后一行给出整数m()表示zz_1215第一次游戏玩的角色，角色表示方法见注意事项</p>
<hr>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出第n次游戏中，zz_1215最有可能玩的角色，角色表示方法见注意事项，每个输出单独占一行</p>
<hr>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><p>2<br>1<br>0 0.1 0.2 0.3 0.4<br>0.4 0 0.1 0.2 0.3<br>0.3 0.4 0 0.1 0.2<br>0.2 0.3 0.4 0 0.1<br>0.1 0.2 0.3 0.4 0<br>3<br>2<br>0 0.1 0.2 0.3 0.4<br>0.4 0 0.1 0.2 0.3<br>0.3 0.4 0 0.1 0.2<br>0.2 0.3 0.4 0 0.1<br>0.1 0.2 0.3 0.4 0<br>3</p>
<hr>
<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><p>3<br>4</p>
<hr>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>通过对矩阵的“运算”，相当于给出起点和路径概率得所到达的终点的概率，此题中得出从一个角色开始玩到最后玩的角色的概率</li>
<li>使用快速幂运算进行n次幂“运算”，快速幂运算就是将n次方运算转化为多个2的k次方运算之积</li>
<li>有一点坑的就是最后的要求是概率相同取编号小的角色，因为概率运算是实数运算，结果是不准确的，最后要同过<em>abs(ans.g[s-1][j]-maxi)&lt;1e-6</em>来消除整数运算所带来的不准确性</li>
</ul>
<hr>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iterator&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> statu</div><div class="line">&#123;</div><div class="line">    <span class="keyword">double</span> g[<span class="number">5</span>][<span class="number">5</span>];</div><div class="line">&#125;sta;</div><div class="line"></div><div class="line"><span class="function">sta <span class="title">mul</span><span class="params">(sta a,sta b)</span></span></div><div class="line">&#123;</div><div class="line">    sta c;</div><div class="line">    <span class="keyword">int</span> i,j,k;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)</div><div class="line">        &#123;</div><div class="line">            c.g[i][j]=<span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">5</span>;k++)</div><div class="line">                c.g[i][j]+=a.g[i][k]*b.g[k][j];    <span class="comment">//i到j有多条线路</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> c;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">sta <span class="title">pow</span><span class="params">(sta a,<span class="keyword">int</span> d)</span>   <span class="comment">//利用二进制数的特点</span></span></div><div class="line">&#123;</div><div class="line">    sta b,c;</div><div class="line">    b=a;</div><div class="line">    <span class="built_in">memset</span>(c.g,<span class="number">0</span>,<span class="keyword">sizeof</span>(c.g));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</div><div class="line">        c.g[i][i]=<span class="number">1</span>;     <span class="comment">//累加位初始化</span></div><div class="line">    <span class="keyword">while</span>(d)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(d&amp;<span class="number">1</span>)c=mul(c,b);   <span class="comment">//累加位</span></div><div class="line">        b=mul(b,b);    <span class="comment">//二进制增长位</span></div><div class="line">        d/=<span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> c;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,s,maxj;</div><div class="line">    <span class="keyword">double</span> maxi=<span class="number">0</span>;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    sta a,ans;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</div><div class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;a.g[j][i];     <span class="comment">//j在前使其与前面的运算对应</span></div><div class="line">    <span class="built_in">cin</span>&gt;&gt;s;</div><div class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    ans=<span class="built_in">pow</span>(a,n<span class="number">-1</span>);</div><div class="line">    <span class="comment">//for(i=0;i&lt;5;i++)    //已经确定起点</span></div><div class="line">        <span class="keyword">for</span>(j=<span class="number">4</span>;j&gt;=<span class="number">0</span>;j--)    <span class="comment">//不能使用for(j=0;j&lt;5;j++),原因：概率相同要选最小的，多次乘法运算时不精确的，通过1e-6来获得近似精确的解</span></div><div class="line">            <span class="keyword">if</span>(ans.g[s<span class="number">-1</span>][j]&gt;maxi||<span class="built_in">abs</span>(ans.g[s<span class="number">-1</span>][j]-maxi)&lt;<span class="number">1e-6</span>)</div><div class="line">            &#123;</div><div class="line">                maxi=ans.g[s<span class="number">-1</span>][j];</div><div class="line">                maxj=j;</div><div class="line">            &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;maxj+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</div><div class="line">    <span class="keyword">int</span> t;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;t;</div><div class="line">    <span class="keyword">while</span>(t--)</div><div class="line">    &#123;</div><div class="line">        solve();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 快速幂运算 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WOX 快捷启动器]]></title>
      <url>/2016/10/31/WOX-%E5%BF%AB%E6%8D%B7%E5%90%AF%E5%8A%A8%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>介绍：WOX是国人开发的一款比较好用的开源快捷启动器，在一定程度上能够让我们暂时对鼠标说拜拜。这几天使用的体验还不错，所以就写一篇博文来推荐一下。希望大家能够喜欢。</p>
<a id="more"></a>
<h4 id="系统插件"><a href="#系统插件" class="headerlink" title="系统插件"></a>系统插件</h4><h5 id="程序插件"><a href="#程序插件" class="headerlink" title="程序插件"></a>程序插件</h5><p>程序搜索列表主要在开始菜单和用户自定义目录中的程序（定义：     Setting=&gt;Plugin=&gt;Programs ）。还支持汉字的拼音输入</p>
<h5 id="颜色插件"><a href="#颜色插件" class="headerlink" title="颜色插件"></a>颜色插件</h5><p>输入颜色代码会显示出具体的颜色值</p>
<h5 id="控制面板插件"><a href="#控制面板插件" class="headerlink" title="控制面板插件"></a>控制面板插件</h5><p>可以直接在搜索框中输入控制面板中的选项</p>
<h5 id="计算机插件"><a href="#计算机插件" class="headerlink" title="计算机插件"></a>计算机插件</h5><p>这个不用说就知道怎么用了吧</p>
<h5 id="网址插件"><a href="#网址插件" class="headerlink" title="网址插件"></a>网址插件</h5><p>直接拷贝的网址在这里面就可以打开了（使用默认浏览器）</p>
<h5 id="Web搜索框"><a href="#Web搜索框" class="headerlink" title="Web搜索框"></a>Web搜索框</h5><p>Wox还提供了名为Web搜索的系统插件。所谓Web搜索，就是Wox允许用户设置一个URL，然后替换其中搜索关键字部分，从而达到快速搜索的目的。最常见的莫过于谷歌，百度搜索了。Wox内置了谷歌的Web搜索。关键字是 g 。另外在添加自定的Web搜索的时候记得把需要替换的地方换成 {q} 占位符，此占位符会在正常搜索的时候替换为你的输入。<br><img src="http://oeziv5rwi.bkt.clouddn.com/2016/10/31/001.jpg" alt=""><br>非常不错的一个功能</p>
<h5 id="命令行插件"><a href="#命令行插件" class="headerlink" title="命令行插件"></a>命令行插件</h5><p>通过 <strong>Win + R</strong>启动命令行，或者输入<strong>&gt; + 命令</strong></p>
<h5 id="第三方提示插件"><a href="#第三方提示插件" class="headerlink" title="第三方提示插件"></a>第三方提示插件</h5><p>提示触发第三方插件的关键字</p>
<h4 id="第三方插件"><a href="#第三方插件" class="headerlink" title="第三方插件"></a>第三方插件</h4><p>需要关键字出发</p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>使用<strong>wpm</strong> 命令进行安装</p>
<ol>
<li>安装插件：  <em>wpm install &lt;插件名字&gt;</em></li>
<li>删除插件：<em>wpm uninstall &lt;插件名字&gt;</em></li>
<li>插件列表： <em>wpm list</em></li>
</ol>
<p>手动安装，下载.wox结尾的安装包    ，将插件拖拽到搜索框中即可安装</p>
<p>所有第三方插件列表在<a href="http://www.getwox.com/plugin" target="_blank" rel="external">这里</a></p>
<p>希望这款小应用能够给你的在工作或学习的效率得到提升</p>
]]></content>
      
        <categories>
            
            <category> 软件使用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 效率提升 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python Requests库 基本用法]]></title>
      <url>/2016/10/29/python-Requests%E5%BA%93-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>Requests 是一个比较常用的python HTTP 库，是爬虫必备的第三方扩展库。下面是Requests库的一些基本的用法</p>
<a id="more"></a>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><p>导入requests库，通过get（或者其他请求类型）得到一个requests对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line">r=requests.get(<span class="string">"https://www.baidu.com/"</span>)</div><div class="line">r=requests.post(<span class="string">"https://www.baidu.com/"</span>)</div></pre></td></tr></table></figure></p>
<h4 id="传递URL参数"><a href="#传递URL参数" class="headerlink" title="传递URL参数"></a>传递URL参数</h4><p>手工构建的URL（如abc.com/get?key=value）转化为params参数，以一个字典的形式来提供这些参数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import requests</div><div class="line"></div><div class="line">payload=&#123;'kay1':'value1','key2':'value2'&#125;</div><div class="line">r=requests.get("https://www.baidu.com",params=payload)</div><div class="line">print(r.url)</div><div class="line"></div><div class="line">&gt;&gt;https://www.baidu.com/?kay1=value1&amp;key2=value2</div><div class="line">``` </div><div class="line"></div><div class="line">## 响应内容</div><div class="line"></div><div class="line">我们可以通过text属性来获得响应内容</div><div class="line">``` python</div><div class="line"></div><div class="line">import requests</div><div class="line"></div><div class="line">r=requests.get("https://github.com/timeline.json")</div><div class="line">print(r.text)</div><div class="line"></div><div class="line">&gt;&gt;&#123;"message":"Hello there, wayfaring stranger. If you’re reading this then you probably didn’t see ...</div></pre></td></tr></table></figure>
<p>Requests 会自动解码获取的内容（通过HTTP的头部对编码进行推测），当然你也可以用encoding属性来改变它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> r.encoding</div><div class="line"><span class="string">'utf-8'</span></div><div class="line"> r.encoding = <span class="string">'ISO-8859-1'</span></div></pre></td></tr></table></figure>
<h4 id="二进制响应内容"><a href="#二进制响应内容" class="headerlink" title="二进制响应内容"></a>二进制响应内容</h4><p>对于非文本请求（如二进制内容请求）,Requests 会自动为你解码gzip和deflate传输编码的响应数据，对受到请求以后进行处理就行了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</div><div class="line"></div><div class="line">i = Image.open(BytesIO(r.content))</div></pre></td></tr></table></figure></p>
<h4 id="JSON-响应内容"><a href="#JSON-响应内容" class="headerlink" title="JSON 响应内容"></a>JSON 响应内容</h4><p>Requests内置json解码器，对返回对象调用json()方法即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div><div class="line">r=requests.get(<span class="string">'https://github.com/timeline.json'</span>)</div><div class="line">r.json()</div></pre></td></tr></table></figure>
<h4 id="原始响应内容"><a href="#原始响应内容" class="headerlink" title="原始响应内容"></a>原始响应内容</h4><p>获取服务器的原始套接字响应，可以访问r.raw（这样就要在请求中设置参数stream=True）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'https://github.com/timeline.json'</span>, stream=<span class="keyword">True</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.raw</div><div class="line">&lt;requests.packages.urllib3.response.HTTPResponse object at <span class="number">0x101194810</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.raw.read(<span class="number">10</span>)</div><div class="line"><span class="string">'\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\x03'</span></div></pre></td></tr></table></figure></p>
<p>获取原始内容以后，你可以使用这种方法将文本流保存到文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(filename, <span class="string">'wb'</span>) <span class="keyword">as</span> fd:</div><div class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(chunk_size):</div><div class="line">        fd.write(chunk)</div></pre></td></tr></table></figure></p>
<p>使用 Response.iter_content 将会处理大量你直接使用 Response.raw 不得不处理的。 当流下载时，上面是优先推荐的获取内容方式。</p>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>添加HTTP头部信息，只要传递一个dict给headers参数就可以了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'https://api.github.com/some/endpoint'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>headers = &#123;<span class="string">'user-agent'</span>: <span class="string">'my-app/0.0.1'</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(url, headers=headers)</div></pre></td></tr></table></figure></p>
<p>注意：<br>Requests 不会基于定制 header 的具体情况改变自己的行为。只不过在最后的请求中，所有的 header 信息都会被传递进去。</p>
<h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><p>可以通过传递一个dict给data参数来发送像表单内容一样的数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(<span class="string">"http://httpbin.org/post"</span>, data=payload)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(r.text)</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  <span class="string">"form"</span>: &#123;</div><div class="line">    <span class="string">"key2"</span>: <span class="string">"value2"</span>,</div><div class="line">    <span class="string">"key1"</span>: <span class="string">"value1"</span></div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="状态响应码"><a href="#状态响应码" class="headerlink" title="状态响应码"></a>状态响应码</h3><p>通过status_code来获得状态信息<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'http://httpbin.org/get'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</div><div class="line"><span class="number">200</span></div></pre></td></tr></table></figure></p>
<h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>通过headers属性来获得服务器的响应头：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers</div><div class="line">&#123;</div><div class="line">    <span class="string">'content-encoding'</span>: <span class="string">'gzip'</span>,</div><div class="line">    <span class="string">'transfer-encoding'</span>: <span class="string">'chunked'</span>,</div><div class="line">    <span class="string">'connection'</span>: <span class="string">'close'</span>,</div><div class="line">    <span class="string">'server'</span>: <span class="string">'nginx/1.0.4'</span>,</div><div class="line">    <span class="string">'x-runtime'</span>: <span class="string">'148ms'</span>,</div><div class="line">    <span class="string">'etag'</span>: <span class="string">'"e1ca502697e5c9317743dc078f67693f"'</span>,</div><div class="line">    <span class="string">'content-type'</span>: <span class="string">'application/json'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>HTTP 头部对大小写不敏感</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>获得cookie，使用cookies属性；发送你的cookie到服务器，使用cookie参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://example.com/some/cookie/setting/url'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(url)</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.cookies[<span class="string">'example_cookie_name'</span>]</div><div class="line"><span class="string">'example_cookie_value'</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'http://httpbin.org/cookies'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>cookies = dict(cookies_are=<span class="string">'working'</span>)</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(url, cookies=cookies)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</div><div class="line"><span class="string">'&#123;"cookies": &#123;"cookies_are": "working"&#125;&#125;'</span></div></pre></td></tr></table></figure></p>
<h3 id="重定向和请求历史"><a href="#重定向和请求历史" class="headerlink" title="重定向和请求历史"></a>重定向和请求历史</h3><p>使用对象的history属性返回Response对象列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'http://github.com'</span>)</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.url</div><div class="line"><span class="string">'https://github.com/'</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</div><div class="line"><span class="number">200</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.history</div><div class="line">[&lt;Response [<span class="number">301</span>]&gt;]</div></pre></td></tr></table></figure></p>
<p>使用allow_redirects参数来禁用重定向处理：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'http://github.com'</span>, allow_redirects=<span class="keyword">False</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</div><div class="line"><span class="number">301</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r.history</div><div class="line">[]</div></pre></td></tr></table></figure></p>
<p><a href="http://cn.python-requests.org/zh_CN/latest/index.html" target="_blank" rel="external">中文官方文档</a></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[开启ACM之路]]></title>
      <url>/2016/10/22/%E5%BC%80%E5%90%AFACM%E4%B9%8B%E8%B7%AF/</url>
      <content type="html"><![CDATA[<p>今天参加了学校的程序设计竞赛，一直以来都是对这次比赛抱有很大的期望。从暑假开始到现在也一直在看相关算法的资料书籍，转专业过来以后花在这方面的时间和精力也非常多，学习从简单的动态规划问题到图论中的各种算法，在学校的OJ上面也刷了一些题。<br>但是这次比赛自己的结果并不理想，为什么我会在第三题因为break这个错误（本来应该是return的）卡了这么久，提交了十次才发现这个错误，最后变成了做出四道题目中的倒数第二。。。<br><a id="more"></a><br><img src="http://oeziv5rwi.bkt.clouddn.com/2016/10/22/001.jpg" alt=""></p>
<p>幸好还做出了四道题目，因此也算是进入了ACM实验室吧。从今天起我也算真正踏上了ACM之路，之前的努力和辛苦还是会有回报的。 还是应了那句话：</p>
<blockquote>
<p>机会总是留给有准备的人的！<br>未来的路走得肯定不会那么轻松，也会给我带来很多挑战、很多考验。但是我相信这条路是我自己选的，我一定会坚持下去的！<br>希望在以后在ACM成长的道路上，我能够牢记这次机会的来之不易，真正在这条路上坚持下去。<br><img src="http://oeziv5rwi.bkt.clouddn.com/2016/10/22/002.jpg" alt=""></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 杂记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 点滴 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[木条染色_题解]]></title>
      <url>/2016/10/13/%E6%9C%A8%E6%9D%A1%E6%9F%93%E8%89%B2%E8%89%B2-%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><blockquote>
<p>小明是一个非常浪漫的画家，他喜欢画各种奇奇怪怪的画，虽然没人理解他画的究竟是什么东西。 有一天，他突发奇想，对于一根木条，他每次从木条中选取一个区间[l,r]进行染色，经过多次染色后，他想知道在[a,b]区间中有几个未被染色的子区间？ 可惜小明虽然画画非常厉害，但是并不擅长解决这类问题，于是，他拿着这根木条来找你，希望你能够给他帮助。 假设木条无限长，所有查询都在木条长度范围内，未被染色的子区间是指，木条上染过色的区间的间断部分。</p>
</blockquote>
<a id="more"></a>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote>
<p>第一行一个整数T，代表数据组数。 对于每组数据，第一行给出两个整数n，q，分别代表染色的区间个数，以及查询个数。 之后n行，每行两个整数l，r，表示将l到r的区间进行染色，包含l，r两个节点。 之后q行，每行两个整数a，b，表示询问a到b总共有多少未被染色的子区间。 两组数据之间用一个空行隔开。 T &lt; 20<br>n &lt; 10000<br>q &lt; 100000<br>0 &lt; = l &lt; r &lt; 1000000<br>0 &lt; = a &lt; = b &lt; 1000000</p>
</blockquote>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote>
<p>对于每次询问，输出一个整数，表示查询结果。 每组数据之后，请输出一个空行。</p>
</blockquote>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><blockquote>
<p>对于第一组数据，[0,1)，(2,3)，(4,+ )是未染色的子区间，因此查询[1,3]可以找到(2,3)这个子区间，而对于[3,4]不能找到，对于[5,5]可以找到[5,5]。<br>对于第二组数据，[0,1)和(8,+ )是未染色的子区间，因此对于[0,5]只有子区间[0,1)，对于查询[0,9]，有子区间[0,1)和（8,9]，对于查询[9,9]，有[9,9]这个子区间。</p>
</blockquote>
<hr>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>使用标记法，首先就是区分染色的和未染色的区间，通过染色起点++染色终点–后每一个点的标记值加上前一个点的标记值形成新的标记值，这样标记为0的就是空区间中的点，非0的就是非空区间中的点。然后通过大区间标号（即一个空区间和他右边的一个非空区间进行合并形成大区间然后给每个区间从小到大标号），这样两个点之间的空区间标记数之差就是两点间的空区间数了。注意处理最前面的空区间和最后面的空区间，最前面的空区间是直接判断点在不在空区间中，如果在的话答案++。为大区间标号的时候，向染色设计的最大范围后面多标一个，以应对查询范围在染色范围右端的情况。</strong></p>
<hr>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 1000005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mm(a,b) memset(a,b,sizeof(a))</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> a[SIZE],b[SIZE],anse[SIZE/<span class="number">10</span>+<span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,q,i,d,t,ml=<span class="number">0</span>;</div><div class="line">    mm(a,<span class="number">0</span>);</div><div class="line">    mm(b,<span class="number">0</span>);</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</div><div class="line">    <span class="comment">//cin&gt;&gt;n&gt;&gt;q;</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;d,&amp;t);</div><div class="line">        <span class="comment">//cin&gt;&gt;d&gt;&gt;t;</span></div><div class="line">        a[d]++;</div><div class="line">        a[t]--;</div><div class="line">        ml=max(ml,t);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> num=<span class="number">1</span>,ans;</div><div class="line">    b[<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=ml+<span class="number">1</span>;i++)  <span class="comment">//+1确保从空区间开始空区间结束</span></div><div class="line">    &#123;</div><div class="line">        a[i]+=a[i<span class="number">-1</span>];</div><div class="line">        b[i]=num;</div><div class="line">        <span class="keyword">if</span>(a[i]==<span class="number">0</span>&amp;&amp;a[i<span class="number">-1</span>]!=<span class="number">0</span>)num++; <span class="comment">//下一个在空区间内的点归入下一个大区间</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;q;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;d,&amp;t);</div><div class="line">        <span class="comment">//cin&gt;&gt;d&gt;&gt;t;</span></div><div class="line">        <span class="keyword">if</span>(t&gt;ml)t=ml+<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(d&gt;ml)d=ml+<span class="number">1</span>;</div><div class="line">        ans=b[t]-b[d];</div><div class="line">        <span class="keyword">if</span>((d&gt;<span class="number">0</span>&amp;&amp;a[d]==<span class="number">0</span>&amp;&amp;a[d<span class="number">-1</span>]==<span class="number">0</span>)||(d==<span class="number">0</span>&amp;&amp;a[d]==<span class="number">0</span>))  <span class="comment">//对开始为空区间的情况进行讨论</span></div><div class="line">            ans++;</div><div class="line">        anse[i]=ans;</div><div class="line">        <span class="comment">//cout&lt;&lt;ans&lt;&lt;endl;</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;q;i++)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,anse[i]);</div><div class="line">        <span class="comment">//cout&lt;&lt;anse[i]&lt;&lt;endl;</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> t;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</div><div class="line">    <span class="comment">//cin&gt;&gt;t;</span></div><div class="line">    <span class="keyword">while</span>(t--)solve();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[背包九讲（转）]]></title>
      <url>/2016/10/09/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2%EF%BC%88%E8%BD%AC%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>背包问题是常见的动态规划算法题,背包问题中又包含了许多细分的问题，我觉得dd大牛总结的比较好！</p>
<a id="more"></a>
<h3 id="P01-01背包问题"><a href="#P01-01背包问题" class="headerlink" title="P01: 01背包问题"></a>P01: 01背包问题</h3><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p>
<h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><p>这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 </p>
<p>用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}。</p>
<p>这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-c[i]的背包中”，此时能获得的最大价值就是f [i-1][v-c[i]]再加上通过放入第i件物品获得的价值w[i]。</p>
<p>注意f[i][v]有意义当且仅当存在一个前i件物品的子集，其费用总和为v。所以按照这个方程递推完毕后，最终的答案并不一定是f[N] [V]，而是f[N][0..V]的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项f[i][v-1]，这样就可以保证f[N] [V]就是最后的答案。至于为什么这样就可以，由你自己来体会了。 </p>
<h5 id="优化空间复杂度"><a href="#优化空间复杂度" class="headerlink" title="优化空间复杂度"></a>优化空间复杂度</h5><p>以上方法的时间和空间复杂度均为O(N*V)，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到O(V)。</p>
<p>先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组f[i][0..V]的所有值。那么，如果只用一个数组f [0..V]，能不能保证第i次循环结束后f[v]中表示的就是我们定义的状态f[i][v]呢？f[i][v]是由f[i-1][v]和f[i-1] [v-c[i]]两个子问题递推而来，能否保证在推f[i][v]时（也即在第i次主循环中推f[v]时）能够得到f[i-1][v]和f[i-1][v -c[i]]的值呢？事实上，这要求在每次主循环中我们以v=V..0的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态f[i -1][v-c[i]]的值。伪代码如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</div><div class="line"><span class="keyword">for</span> v=V.<span class="number">.0</span></div><div class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</div></pre></td></tr></table></figure>
<p> 其中的f[v]=max{f[v],f[v-c[i]]}一句恰就相当于我们的转移方程f[i][v]=max{f[i-1][v],f[i- 1][v-c[i]]}，因为现在的f[v-c[i]]就相当于原来的f[i-1][v-c[i]]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-c[i]]推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。 </p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。 </p>
<hr>
<h4 id="P02-完全背包问题"><a href="#P02-完全背包问题" class="headerlink" title="P02: 完全背包问题"></a>P02: 完全背包问题</h4><h5 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h5><p>有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p>
<h5 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h5><p>这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：f[i][v]=max{f[i-1][v-k<em>c[i]]+k</em>w[i]|0&lt;=k<em>c[i]&lt;= v}。这跟01背包问题一样有O(N</em>V)个状态需要求解，但求解每个状态的时间则不是常数了，求解状态f[i][v]的时间是O(v/c[i])，总的复杂度是超过O(VN)的。 </p>
<p>将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。 </p>
<h5 id="一个简单有效的优化"><a href="#一个简单有效的优化" class="headerlink" title="一个简单有效的优化"></a>一个简单有效的优化</h5><p>完全背包问题有一个很简单有效的优化，是这样的：若两件物品i、j满足c[i]&lt;=c[j]且w[i]&gt;=w[j]，则将物品j去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高得j换成物美价廉的i，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。 </p>
<p>转化为01背包问题求解<br>既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选V/c [i]件，于是可以把第i种物品转化为V/c[i]件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。 </p>
<p>更高效的转化方法是：把第i种物品拆成费用为c[i]<em>2^k、价值为w[i]</em>2^k的若干件物品，其中k满足c[i]<em>2^k&lt;V。这是二进制的思想，因为不管最优策略选几件第i种物品，总可以表示成若干个2^k件物品的和。这样把每种物品拆成O(log(V/c[i]))件物品，是一个很大的改进。但我们有更优的O(VN)的算法。</em> O(VN)的算法这个算法使用一维数组，先看伪代码： <pre class"example"=""> for i=1..N for v=0..V f[v]=max{f[v],f[v-c[i]]+w[i]};</pre></p>
<p> 你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照v=V..0的逆序来循环。这是因为要保证第i次循环中的状态f[i][v]是由状态f[i-1][v-c[i]]递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[i-1][v-c[i]]。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v= 0..V的顺序循环。这就是这个简单的程序为何成立的道理。</p>
<p>这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}，将这个方程用一维数组实现，便得到了上面的伪代码。 </p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在“基本思路”以及“O(VN)的算法“的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。 </p>
<hr>
<h4 id="P03-多重背包问题"><a href="#P03-多重背包问题" class="headerlink" title="P03: 多重背包问题"></a>P03: 多重背包问题</h4><h5 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h5><p>有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p>
<h5 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h5><p>这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有n[i]+1种策略：取0件，取1件……取n[i]件。令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值，则：f[i][v]=max{f[i-1][v-k<em>c[i]]+ k</em>w[i]|0&lt;=k&lt;=n[i]}。复杂度是O(V*∑n[i])。</p>
<p>转化为01背包问题<br>另一种好想好写的基本方法是转化为01背包求解：把第i种物品换成n[i]件01背包中的物品，则得到了物品数为∑n[i]的01背包问题，直接求解，复杂度仍然是O(V*∑n[i])。 </p>
<p>但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n[i]件——均能等价于取若干件代换以后的物品。另外，取超过n[i]件的策略必不能出现。 </p>
<p>方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为 1,2,4,…,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1&gt;0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。 </p>
<p>分成的这几件物品的系数和为n[i]，表明不可能取多于n[i]件的第i种物品。另外这种方法也能保证对于0..n[i]间的每一个整数，均可以用若干个系数的和表示，这个证明可以分0..2^k-1和2^k..n[i]两段来分别讨论得出，并不难，希望你自己思考尝试一下。 </p>
<p>这样就将第i种物品分成了O(log n[i])种物品，将原问题转化为了复杂度为O(V*∑log n[i])的01背包问题，是很大的改进。 </p>
<p>O(VN)的算法<br>多重背包问题同样有O(VN)的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。 </p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>这里我们看到了将一个算法的复杂度由O(V<em>∑n[i])改进到O(V</em>∑log n[i])的过程，还知道了存在应用超出NOIP范围的知识的O(VN)算法。希望你特别注意“拆分物品”的思想和方法，自己证明一下它的正确性，并用尽量简洁的程序来实现。</p>
<hr>
<h4 id="P04-混合三种背包问题"><a href="#P04-混合三种背包问题" class="headerlink" title="P04: 混合三种背包问题"></a>P04: 混合三种背包问题</h4><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>如果将P01、P02、P03混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？ </p>
<h5 id="01背包与完全背包的混合"><a href="#01背包与完全背包的混合" class="headerlink" title="01背包与完全背包的混合"></a>01背包与完全背包的混合</h5><p>考虑到在P01和P02中最后给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是O(VN)。伪代码如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</div><div class="line"><span class="keyword">if</span> 第i件物品是<span class="number">01</span>背包</div><div class="line"><span class="keyword">for</span> v=V.<span class="number">.0</span></div><div class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> 第i件物品是完全背包 </div><div class="line"><span class="keyword">for</span> v=<span class="number">0.</span>.V</div><div class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</div></pre></td></tr></table></figure>
<h5 id="再加上多重背包"><a href="#再加上多重背包" class="headerlink" title="再加上多重背包"></a>再加上多重背包</h5><p>如果再加上有的物品最多可以取有限次，那么原则上也可以给出O(VN)的解法：遇到多重背包类型的物品用单调队列解即可。但如果不考虑超过NOIP范围的算法的话，用P03中将每个这类物品分成O(log n[i])个01背包的物品的方法也已经很优了。 </p>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>有人说，困难的题目都是由简单的题目叠加而来的。这句话是否公理暂且存之不论，但它在本讲中已经得到了充分的体现。本来01背包、完全背包、多重背包都不是什么难题，但将它们简单地组合起来以后就得到了这样一道一定能吓倒不少人的题目。但只要基础扎实，领会三种基本背包问题的思想，就可以做到把困难的题目拆分成简单的题目来解决。 </p>
<hr>
<h4 id="P05-二维费用的背包问题"><a href="#P05-二维费用的背包问题" class="headerlink" title="P05: 二维费用的背包问题"></a>P05: 二维费用的背包问题</h4><h5 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h5><p>二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为w[i]。</p>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><p>费用加了一维，只需状态也加一维即可。设f[i][v][u]表示前i件物品付出两种代价分别为v和u时可获得的最大价值。状态转移方程就是：f [i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}。如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量v和u采用顺序的循环，当物品有如完全背包问题时采用逆序的循环。当物品有如多重背包问题时拆分物品。 </p>
<p>物品总个数的限制<br>有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取M件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为1，可以付出的最大件数费用为M。换句话说，设f[v][m]表示付出费用v、最多选m件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在f[0..V][0..M]范围内寻找答案。 </p>
<p>另外，如果要求“恰取M件物品”，则在f[0..V][M]范围内寻找答案。 </p>
<h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><p>事实上，当发现由熟悉的动态规划题目变形得来的题目时，在原来的状态中加一纬以满足新的限制是一种比较通用的方法。希望你能从本讲中初步体会到这种方法。 </p>
<hr>
<h4 id="P06-分组的背包问题"><a href="#P06-分组的背包问题" class="headerlink" title="P06: 分组的背包问题"></a>P06: 分组的背包问题</h4><h5 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h5><p>有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p>
<h5 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h5><p>这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设f[k][v]表示前k组物品花费费用v能取得的最大权值，则有f[k][v]=max{f[k-1][v],f[k-1][v-c[i]]+w[i]|物品i属于第k组}。</p>
<p>使用一维数组的伪代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> 所有的组k</div><div class="line"><span class="keyword">for</span> 所有的i属于组k</div><div class="line"><span class="keyword">for</span> v=V.<span class="number">.0</span></div><div class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;</div></pre></td></tr></table></figure></p>
<p> 另外，显然可以对每组中的物品应用P02中“一个简单有效的优化”。</p>
<h5 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h5><p>分组的背包问题将彼此互斥的若干物品称为一个组，这建立了一个很好的模型。不少背包问题的变形都可以转化为分组的背包问题（例如P07），由分组的背包问题进一步可定义“泛化物品”的概念，十分有利于解题。 </p>
<hr>
<h4 id="P07-有依赖的背包问题"><a href="#P07-有依赖的背包问题" class="headerlink" title="P07: 有依赖的背包问题"></a>P07: 有依赖的背包问题</h4><h5 id="简化的问题"><a href="#简化的问题" class="headerlink" title="简化的问题"></a>简化的问题</h5><p>这种背包问题的物品间存在某种“依赖”的关系。也就是说，i依赖于j，表示若选物品i，则必须选物品j。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。 </p>
<h5 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h5><p>这个问题由NOIP2006金明的预算方案一题扩展而来。遵从该题的提法，将不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。 </p>
<p>按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……无法用状态转移方程来表示如此多的策略。（事实上，设有n个附件，则策略有2^n+1个，为指数级。） </p>
<p>考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于P06中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。 </p>
<p>再考虑P06中的一句话：可以对每组中的物品应用P02中“一个简单有效的优化”。这提示我们，对于一个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，我们可以对主件i的“附件集合”先进行一次01背包，得到费用依次为0..V-c[i]所有这些值时相应的最大价值f’[0..V-c[i]]。那么这个主件及它的附件集合相当于V-c[i]+1个物品的物品组，其中费用为c[i]+k的物品的价值为f’[k]+w[i]。也就是说原来指数级的策略中有很多策略都是冗余的，通过一次01背包后，将主件i转化为 V-c[i]+1个物品的物品组，就可以直接应用P06的算法解决问题了。 </p>
<p>更一般的问题<br>更一般的问题是：依赖关系以图论中“森林”的形式给出（森林即多叉树的集合），也就是说，主件的附件仍然可以具有自己的附件集合，限制只是每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。 </p>
<p>解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的01 背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。 </p>
<p>事实上，这是一种树形DP，其特点是每个父节点都需要对它的各个儿子的属性进行一次DP以求得自己的相关属性。这已经触及到了“泛化物品”的思想。看完P08后，你会发现这个“依赖关系树”每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。 </p>
<h5 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h5><p>NOIP2006的那道背包问题我做得很失败，写了上百行的代码，却一分未得。后来我通过思考发现通过引入“物品组”和“依赖”的概念可以加深对这题的理解，还可以解决它的推广问题。用物品组的思想考虑那题中极其特殊的依赖关系：物品不能既作主件又作附件，每个主件最多有两个附件，可以发现一个主件和它的两个附件等价于一个由四个物品组成的物品组，这便揭示了问题的某种本质。 </p>
<p>我想说：失败不是什么丢人的事情，从失败中全无收获才是。 </p>
<hr>
<h4 id="P08-泛化物品"><a href="#P08-泛化物品" class="headerlink" title="P08: 泛化物品"></a>P08: 泛化物品</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的费用而变化。这就是泛化物品的概念。 </p>
<p>更严格的定义之。在背包容量为V的背包问题中，泛化物品是一个定义域为0..V中的整数的函数h，当分配给它的费用为v时，能得到的价值就是h(v)。</p>
<p>这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组h[0..V]，给它费用v，可得到价值h[V]。</p>
<p>一个费用为c价值为w的物品，如果它是01背包中的物品，那么把它看成泛化物品，它就是除了h(c)=w其它函数值都为0的一个函数。如果它是完全背包中的物品，那么它可以看成这样一个函数，仅当v被c整除时有h(v)=v/c<em>w，其它函数值均为0。如果它是多重背包中重复次数最多为n的物品，那么它对应的泛化物品的函数有h(v)=v/c</em>w仅当v被c整除且v/c&lt;=n，其它情况函数值均为0。 </p>
<p>一个物品组可以看作一个泛化物品h。对于一个0..V中的v，若物品组中不存在费用为v的的物品，则h(v)=0，否则h(v)为所有费用为v的物品的最大价值。P07中每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。</p>
<h5 id="泛化物品的和"><a href="#泛化物品的和" class="headerlink" title="泛化物品的和"></a>泛化物品的和</h5><p>如果面对两个泛化物品h和l，要用给定的费用从这两个泛化物品中得到最大的价值，怎么求呢？事实上，对于一个给定的费用v，只需枚举将这个费用如何分配给两个泛化物品就可以了。同样的，对于0..V的每一个整数v，可以求得费用v分配到h和l中的最大价值f(v)。也即f(v)=max{h(k) +l(v-k)|0&lt;=k&lt;=v}。可以看到，f也是一个由泛化物品h和l决定的定义域为0..V的函数，也就是说，f是一个由泛化物品h和 l决定的泛化物品。 </p>
<p>由此可以定义泛化物品的和：h、l都是泛化物品，若泛化物品f满足f(v)=max{h(k)+l(v-k)|0&lt;=k&lt;=v}，则称f是h与l的和，即f=h+l。这个运算的时间复杂度是O(V^2)。 </p>
<p>泛化物品的定义表明：在一个背包问题中，若将两个泛化物品代以它们的和，不影响问题的答案。事实上，对于其中的物品都是泛化物品的背包问题，求它的答案的过程也就是求所有这些泛化物品之和的过程。设此和为s，则答案就是s[0..V]中的最大值。</p>
<p>背包问题的泛化物品<br>一个背包问题中，可能会给出很多条件，包括每种物品的费用、价值等属性，物品之间的分组、依赖等关系等。但肯定能将问题对应于某个泛化物品。也就是说，给定了所有条件以后，就可以对每个非负整数v求得：若背包容量为v，将物品装入背包可得到的最大价值是多少，这可以认为是定义在非负整数集上的一件泛化物品。这个泛化物品——或者说问题所对应的一个定义域为非负整数的函数——包含了关于问题本身的高度浓缩的信息。一般而言，求得这个泛化物品的一个子域（例如0..V）的值之后，就可以根据这个函数的取值得到背包问题的最终答案。</p>
<p>综上所述，一般而言，求解背包问题，即求解这个问题所对应的一个函数，即该问题的泛化物品。而求解某个泛化物品的一种方法就是将它表示为若干泛化物品的和然后求之。 </p>
<h5 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h5><p>本讲可以说都是我自己的原创思想。具体来说，是我在学习函数式编程的 Scheme 语言时，用函数编程的眼光审视各类背包问题得出的理论。这一讲真的很抽象，也许在“模型的抽象程度”这一方面已经超出了NOIP的要求，所以暂且看不懂也没关系。相信随着你的OI之路逐渐延伸，有一天你会理解的。 </p>
<p>我想说：“思考”是一个OIer最重要的品质。简单的问题，深入思考以后，也能发现更多。 </p>
<hr>
<h4 id="P09-背包问题问法的变化"><a href="#P09-背包问题问法的变化" class="headerlink" title="P09: 背包问题问法的变化"></a>P09: 背包问题问法的变化</h4><p>以上涉及的各种背包问题都是要求在背包容量（费用）的限制下求可以取到的最大价值，但背包问题还有很多种灵活的问法，在这里值得提一下。但是我认为，只要深入理解了求背包问题最大价值的方法，即使问法变化了，也是不难想出算法的。 </p>
<p>例如，求解最多可以放多少件物品或者最多可以装满多少背包的空间。这都可以根据具体问题利用前面的方程求出所有状态的值（f数组）之后得到。 </p>
<p>还有，如果要求的是“总价值最小”“总件数最小”，只需简单的将上面的状态转移方程中的max改成min即可。</p>
<p>下面说一些变化更大的问法。 </p>
<p>输出方案<br>一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由状态转移方程的哪一项推出来的，换句话说，记录下它是由哪一个策略推出来的。便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。 </p>
<p>还是以01背包为例，方程为f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}。再用一个数组g[i] [v]，设g[i][v]=0表示推出f[i][v]的值时是采用了方程的前一项（也即f[i][v]=f[i-1][v]），g[i][v]表示采用了方程的后一项。注意这两项分别表示了两种策略：未选第i个物品及选了第i个物品。那么输出方案的伪代码可以这样写（设最终状态为f[N][V]）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">i=N</div><div class="line">v=V</div><div class="line"><span class="keyword">while</span>(i&gt;<span class="number">0</span>)</div><div class="line"><span class="keyword">if</span>(g[i][v]==<span class="number">0</span>)</div><div class="line">print <span class="string">"未选第i项物品"</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g[i][v]==<span class="number">1</span>)</div><div class="line">print <span class="string">"选了第i项物品"</span></div><div class="line">v=v-c[i]</div></pre></td></tr></table></figure></p>
<p> 另外，采用方程的前一项或后一项也可以在输出方案的过程中根据f[i][v]的值实时地求出来，也即不须纪录g数组，将上述代码中的g[i] [v]==0改成f[i][v]==f[i-1][v]，g[i][v]==1改成f[i][v]==f[i-1][v-c[i]]+w[i]也可。</p>
<p>输出字典序最小的最优方案<br>这里“字典序最小”的意思是1..N号物品的选择方案排列出来以后字典序最小。以输出01背包最小字典序的方案为例。 </p>
<p>一般而言，求一个字典序最小的最优方案，只需要在转移时注意策略。首先，子问题的定义要略改一些。我们注意到，如果存在一个选了物品1的最优方案，那么答案一定包含物品1，原问题转化为一个背包容量为v-c[1]，物品为2..N的子问题。反之，如果答案不包含物品1，则转化成背包容量仍为V，物品为2..N的子问题。不管答案怎样，子问题的物品都是以i..N而非前所述的1..i的形式来定义的，所以状态的定义和转移方程都需要改一下。但也许更简易的方法是先把物品逆序排列一下，以下按物品已被逆序排列来叙述。 </p>
<p>在这种情况下，可以按照前面经典的状态转移方程来求值，只是输出方案的时候要注意：从N到1输入时，如果f[i][v]==f[i-v]及f[i][v]==f[i-1][f-c[i]]+w[i]同时成立，应该按照后者（即选择了物品i）来输出方案。 </p>
<p>求方案总数<br>对于一个给定了背包容量、物品费用、物品间相互关系（分组、依赖等）的背包问题，除了再给定每个物品的价值后求可得到的最大价值外，还可以得到装满背包或将背包装至某一指定容量的方案总数。 </p>
<p>对于这类改变问法的问题，一般只需将状态转移方程中的max改成sum即可。例如若每件物品均是01背包中的物品，转移方程即为f[i][v]=sum{f[i-1][v],f[i-1][v-c[i]]+w[i]}，初始条件f[0][0]=1。</p>
<p>事实上，这样做可行的原因在于状态转移方程已经考察了所有可能的背包组成方案。 </p>
<p>最优方案的总数<br>这里的最优方案是指物品总价值最大的方案。还是以01背包为例。 </p>
<p>结合求最大总价值和方案总数两个问题的思路，最优方案的总数可以这样求：f[i][v]意义同前述，g[i][v]表示这个子问题的最优方案的总数，则在求f[i][v]的同时求g[i][v]的伪代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</div><div class="line"><span class="keyword">for</span> v=<span class="number">0.</span>.V</div><div class="line">f[i][v]=max&#123;f[i<span class="number">-1</span>][v],f[i<span class="number">-1</span>][v-c[i]]+w[i]&#125;</div><div class="line">g[i][v]=<span class="number">0</span></div><div class="line"><span class="keyword">if</span>(f[i][v]==f[i<span class="number">-1</span>][v])</div><div class="line">inc(g[i][v],g[i<span class="number">-1</span>][v]</div><div class="line"><span class="keyword">if</span>(f[i][v]==f[i<span class="number">-1</span>][v-c[i]]+w[i])</div><div class="line">inc(g[i][v],g[i<span class="number">-1</span>][v-c[i]])</div></pre></td></tr></table></figure></p>
<p> 如果你是第一次看到这样的问题，请仔细体会上面的伪代码。 </p>
<h5 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h5><p>显然，这里不可能穷尽背包类动态规划问题所有的问法。甚至还存在一类将背包类动态规划问题与其它领域（例如数论、图论）结合起来的问题，在这篇论背包问题的专文中也不会论及。但只要深刻领会前述所有类别的背包问题的思路和状态转移方程，遇到其它的变形问法，只要题目难度还属于NOIP，应该也不难想出算法。 </p>
<p>触类旁通、举一反三，应该也是一个OIer应有的品质吧。</p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>转自dd大牛，膜拜大神</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[极客精神]]></title>
      <url>/2016/10/01/%E6%9E%81%E5%AE%A2%E7%B2%BE%E7%A5%9E/</url>
      <content type="html"><![CDATA[<p>讲到极客，大家可能会联想到很多的代名词：科技、钻研、较真…… 很长的一段时间里面我都希望自己是一个极客，但在很多人的心目中极客的定义各不相同，最近看了ZEALER创始人王自如的一个视频，我比较认可他对于极客的理解。</p>
<a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>讲到极客，大家可能会联想到很多的代名词：科技、钻研、较真…… 很长的一段时间里面我都希望自己是一个极客，但在很多人的心目中极客的定义各不相同，最近看了ZEALER创始人王自如的一个视频，我比较认可他对于极客的理解。</p>
<h3 id="极客精神"><a href="#极客精神" class="headerlink" title="极客精神"></a>极客精神</h3><p>下面就来讲一讲极我认同的极客所具备的品质：</p>
<h5 id="技术控"><a href="#技术控" class="headerlink" title="技术控"></a>技术控</h5><p>极客是对技术有着很强的的理解和学习能力的人，不仅知道当今的流行技术是什么，还能知道这些技术具体的工作原理。懂技术的不一定能够懂产品，但是懂产品的人是不可能不懂技术的。</p>
<h5 id="动手能力"><a href="#动手能力" class="headerlink" title="动手能力"></a>动手能力</h5><p>不仅脑袋里面有知识懂得科技的工作原理，还能够将他们应用于实践，像什么装个系统、写个软件等等是必须的。这种动手能力就应该是将所学的东西应用起来或者说要做出个什么东西而去学具体的知识技术所锻炼出来的。当然对技术的热爱，也是锻炼出这种动手能力所必须的。我想每一个极客都有自己动手丰衣足食的经历吧、</p>
<h5 id="偏执、较真"><a href="#偏执、较真" class="headerlink" title="偏执、较真"></a>偏执、较真</h5><p>一件事，干不到我想要的样，它就是不行。有一丁点的不满意，极客推导重来都可以！极客能够克服技术学习和实践当中的各种枯燥。做不到自己定的目标，就是不甘心，就是不放弃。</p>
<h5 id="探索精神"><a href="#探索精神" class="headerlink" title="探索精神"></a>探索精神</h5><p>当人咧的始祖第一次对日月更替、下雨打雷产生好奇的时候；当他们第一次抬头看都漫天繁星的时候，人类的科技就已经开始进步了。极客就是具备这样不停发问、不停求知的一些人。他们都是利用自己对技术的痴迷和执拗的方式身体力行去实践。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>极客可以是一群被未知点燃的生物。不管怎样，没有对事物的热爱、对技术的痴迷，是不能够成为极客的。</p>
<p>由此可见，在极客养成的道路上我还有很长的路要走，不过对于科技的热爱我想我是真心的，希望在这条路上我能够越走越远。</p>
<p>最后附上视频的<a href="http://www.zealer.com/post/242.html" target="_blank" rel="external">链接</a></p>
]]></content>
      
        <categories>
            
            <category> 杂记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 极客 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux学习——在线帮助和档案属性]]></title>
      <url>/2016/09/30/Linux%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9C%A8%E7%BA%BF%E5%B8%AE%E5%8A%A9%E5%92%8C%E6%A1%A3%E6%A1%88%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>因为有些应用和项目要部署到Linux服务器上，而且作为一个计算机专业的人怎么能不会用Linux呢！所以我要开始深入学习Linux了。通过博客我会将对一些常用、重要的命令进行总结。</p>
<a id="more"></a>
<h2 id="在线求助"><a href="#在线求助" class="headerlink" title="在线求助"></a>在线求助</h2><h3 id="man-要查询的内容"><a href="#man-要查询的内容" class="headerlink" title="man + 要查询的内容"></a>man + 要查询的内容</h3><h4 id="命令的种类"><a href="#命令的种类" class="headerlink" title="命令的种类"></a>命令的种类</h4><p>返回的文本中第一行中以括号的形式显示查询内容所属的类，大致分成一下几种</p>
<ol>
<li>使用者可以操作的指令或可执行文件</li>
<li>系统核心可呼叫的函数与工具等</li>
<li>一些常用的函数(function)与函式库(library)</li>
<li>装置档案的说明</li>
<li>设定档或者是某些档案的格式</li>
<li>游戏(games)</li>
<li>惯例与协议等，例如 Linux 标准档案系统、 网络协议、ASCII code 等等的说明内容</li>
<li>系统管理员可用的管理指令</li>
<li>跟 kernel 有关的文件</li>
</ol>
<h4 id="返回文本的内容"><a href="#返回文本的内容" class="headerlink" title="返回文本的内容"></a>返回文本的内容</h4><ul>
<li>NAME 简短的指令、数据名称说明</li>
<li>SYNOPSIS 简短的指令下达语法(syntax)简介</li>
<li>DESCRIPTION 较为完整的说明，这部分最好仔细看看！</li>
<li>OPTIONS 针对 SYNOPSIS 部分中，有列举的所有可用的参数说明</li>
<li>COMMANDS 当这个程序(软件)在执行的时候，可以在此程序(软件)中下达的指令</li>
<li>FILES 这个程序或数据所使用或参考或连结到的某些档案</li>
<li>SEE ALSO 可以参考的，跟这个指令或数据有相关的其它说明！</li>
<li>EXAMPLE 一些可以参考的范例</li>
<li>BUGS 是否有相关的臭虫</li>
</ul>
<h4 id="搜索关键字"><a href="#搜索关键字" class="headerlink" title="搜索关键字"></a>搜索关键字</h4><p>输入/+word 系统将会搜索输入的关键字，并且将光标指向相应的位置</p>
<h3 id="info-查询内容"><a href="#info-查询内容" class="headerlink" title="info + 查询内容"></a>info + 查询内容</h3><p>与man相似的查询相关指令或者档案的方法就是info，不用的是info以info的形式保存在文件中</p>
<h2 id="档案属性"><a href="#档案属性" class="headerlink" title="档案属性"></a>档案属性</h2><h3 id="使用者与群组"><a href="#使用者与群组" class="headerlink" title="使用者与群组"></a>使用者与群组</h3><p>因为Linux系统是一个多用户多任务的系统，所以文件档案的操作使用权限对不同的用户是不同的。主要区分一下这几种用户：</p>
<ul>
<li>档案拥有者</li>
<li>群组</li>
<li>其他人</li>
</ul>
<p>通过设置对这几种用户的权限来实现对文件安全的管理</p>
<p>以上的信息都保存在一些文件当中，root 的相关信息，都是记录在 /etc/passwd 这个档案内的，至于密码则是记录在 /etc/shadow 这个档案下，Linux 所有的群组名称都纪录在 /etc/group 内</p>
<h3 id="档案权限"><a href="#档案权限" class="headerlink" title="档案权限"></a>档案权限</h3><p>区分了用户，自然就会对不同的用户有不同的权限方案。利用 ls -al 命令查询文件档案的属性，显示的形式如下：</p>
<blockquote>
<p>drwxr–r– 3 root root 4096 Jun 25 08:35 .ssh</p>
</blockquote>
<p>第一个字符代表该档案的类型，主要有一下几种：</p>
<ul>
<li>当为[ d ]则是目录，例如上表的第 11 行；</li>
<li>当为[ - ]则是档案，例如上表的第 5 行；</li>
<li>若是[ l ]则表示为连结档(link file)；</li>
<li>若是[ b ]则表示为装置文件里面的可供储存的接口设备；</li>
<li>若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标。</li>
</ul>
<p>接下来的3*3分三组表示对三种用户的权限情况</p>
<ul>
<li>第一组为『拥有人的权限』</li>
<li>第二组为『同群组的权限』</li>
<li>第三组为『其它非本群组的权限』</li>
</ul>
<p>每组中有单个字符r,w,x 分别表示可读，可写，可执行</p>
<blockquote>
<p>想要进入该目录就必须给相应用户这个目录x权限</p>
</blockquote>
<h3 id="改变档案权限"><a href="#改变档案权限" class="headerlink" title="改变档案权限"></a>改变档案权限</h3><h4 id="chgrp-改变群组"><a href="#chgrp-改变群组" class="headerlink" title="chgrp 改变群组"></a>chgrp 改变群组</h4><blockquote>
<p>chgrp [-R] dirname/filename</p>
</blockquote>
<p>其中-R : 进行递归( recursive )的持续变更，亦即连同次目录下的所有档案、目录<br>都更新成为这个群组之意。常常用在变更某一目录的情况</p>
<h4 id="chown-改变档案拥有者"><a href="#chown-改变档案拥有者" class="headerlink" title="chown 改变档案拥有者"></a>chown 改变档案拥有者</h4><blockquote>
<p>chown [-R] 账号名称 档案或目录</p>
</blockquote>
<h4 id="chmod-改变九个属性"><a href="#chmod-改变九个属性" class="headerlink" title="chmod 改变九个属性"></a>chmod 改变九个属性</h4><blockquote>
<p>chmod [-R] xyz 档案或目录</p>
</blockquote>
<p>用数字4，2，1分别表示权限中的 r，w，x   三个权限相加以后就是对应用户对该档案的权限情况。有三种用户自然就会有三种权限</p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[开启我的博客之旅]]></title>
      <url>/2016/09/25/%E5%BC%80%E5%90%AF%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%97%85/</url>
      <content type="html"><![CDATA[<p>很久以来都想做一个自己的博客，但是由于各种原因一直没能做出来。这个学期开学也有一段时间了，我也成功地转到了计算机专业。最近就花了一些时间把博客做出来，当然刚开始很多地方都有不足有漏洞，希望未来真正能够把这个博客做起来！下面讲一讲我为什么要把这个博客给做起来吧。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  很久以来都想做一个自己的博客，但是由于各种原因一直没能做出来。这个学期开学也有一段时间了，我也成功地转到了计算机专业。最近就花了一些时间把博客做出来，当然刚开始很多地方都有不足有漏洞，希望未来真正能够把这个博客做起来！下面讲一讲我为什么要把这个博客给做起来吧。</p>
<h2 id="希望发挥的作用"><a href="#希望发挥的作用" class="headerlink" title="希望发挥的作用"></a>希望发挥的作用</h2><ul>
<li><p>希望能够通过这个博客来督促我对所学的知识进行定期的总结，我觉得这对于身为计算机的学生所必要的。</p>
</li>
<li><p>希望通过写博客来对我语言表达能力进行一定的锻炼，促使我将各个事物各个知识点之间的关系连接起来。让我的文章的逻辑更加清晰。</p>
</li>
<li><p>希望通过这个平台对我总结的东西进行一个审视同时与各种各样的大牛进行交流，相互学习共同进步</p>
</li>
</ul>
<blockquote>
<p>不忘初心，放得始终。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 杂记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 点滴 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
