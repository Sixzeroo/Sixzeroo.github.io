<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sixzeroo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.liuin.cn/"/>
  <updated>2018-08-30T15:19:15.000Z</updated>
  <id>https://www.liuin.cn/</id>
  
  <author>
    <name>Sixzeroo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 多线程与多进程</title>
    <link href="https://www.liuin.cn/2018/07/04/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>https://www.liuin.cn/2018/07/04/Python-多线程与多进程/</id>
    <published>2018-07-04T08:18:01.000Z</published>
    <updated>2018-08-30T15:19:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近实习接触到这方面的东西，整理了一下</p>
<a id="more"></a>
<h2 id="Python多线程并不是真的多线程"><a href="#Python多线程并不是真的多线程" class="headerlink" title="Python多线程并不是真的多线程"></a>Python多线程并不是真的多线程</h2><p>Python代码的执行由Python虚拟机（解释器）来控制。Python在设计之初就考虑要在主循环中，同时只有一个线程在执行，就像单CPU的系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序在CPU中运行。同样地，<strong>虽然Python解释器可以运行多个线程，只有一个线程在解释器中运行。对Python虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同时只有一个线程在运行</strong>。</p>
<p>在多线程环境中，Python虚拟机按照以下方式执行。</p>
<ol>
<li>设置GIL。</li>
<li>切换到一个线程去执行。</li>
<li>运行。</li>
<li>把线程设置为睡眠状态。</li>
<li>解锁GIL。</li>
<li>再次重复以上步骤。</li>
</ol>
<p>对所有面向I/O的（会调用内建的操作系统C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其他线程在这个线程等待I/O的时候运行。如果某线程并未使用很多I/O操作，它会在自己的时间片内一直占用处理器和GIL。也就是说，<strong>I/O密集型的Python程序比计算密集型的Python程序更能充分利用多线程的好处</strong>。</p>
<p>我们都知道，比方我有一个4核的CPU，那么这样一来，在单位时间内每个核只能跑一个线程，然后时间片轮转切换。但是Python不一样，它不管你有几个核，单位时间多个核只能跑一个线程，然后时间片轮转。看起来很不可思议？但是这就是GIL搞的鬼。任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。</p>
<h2 id="Python-多线程"><a href="#Python-多线程" class="headerlink" title="Python 多线程"></a>Python 多线程</h2><p>Python中有三种模式实现多线程：继承Thread类、Thread对象和multiprocessing.dummy线程池</p>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>继承Thread类，通过重写它的run方法实现多线程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># encoding=utf-8</span></div><div class="line"></div><div class="line"><span class="comment"># 直接从Thread继承，创建一个新的class，把线程执行的代码放到这个新的 class里</span></div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> time</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadImpl</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></div><div class="line">        threading.Thread.__init__(self)</div><div class="line">        self._num = num</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">global</span> total, mutex</div><div class="line">        </div><div class="line">        <span class="comment"># 打印线程名</span></div><div class="line">        <span class="keyword">print</span> threading.currentThread().getName()</div><div class="line"> </div><div class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">0</span>, int(self._num)):</div><div class="line">            <span class="comment"># 取得锁</span></div><div class="line">            mutex.acquire()</div><div class="line">            total = total + <span class="number">1</span></div><div class="line">            <span class="comment"># 释放锁</span></div><div class="line">            mutex.release()</div><div class="line"> </div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="comment">#定义全局变量</span></div><div class="line">    <span class="keyword">global</span> total, mutex</div><div class="line">    total = <span class="number">0</span></div><div class="line">    <span class="comment"># 创建锁</span></div><div class="line">    mutex = threading.Lock()</div><div class="line">    </div><div class="line">    <span class="comment">#定义线程池</span></div><div class="line">    threads = []</div><div class="line">    <span class="comment"># 创建线程对象</span></div><div class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="number">40</span>):</div><div class="line">        threads.append(ThreadImpl(<span class="number">100</span>))</div><div class="line">    <span class="comment"># 启动线程</span></div><div class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</div><div class="line">        t.start()</div><div class="line">    <span class="comment"># 等待子线程结束</span></div><div class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</div><div class="line">        t.join()  </div><div class="line">    </div><div class="line">    <span class="comment"># 打印执行结果</span></div><div class="line">    <span class="keyword">print</span> total</div></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ul>
<li>一定要有<code>Thread.__init__(self)</code>这句话</li>
<li>执行的功能函数必须叫run</li>
</ul>
<h3 id="Thread对象"><a href="#Thread对象" class="headerlink" title="Thread对象"></a>Thread对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># encoding=utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> time</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">threadFunc</span><span class="params">(num)</span>:</span></div><div class="line">    <span class="keyword">global</span> total, mutex</div><div class="line">    </div><div class="line">    <span class="comment"># 打印线程名</span></div><div class="line">    <span class="keyword">print</span> threading.currentThread().getName()</div><div class="line"> </div><div class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">0</span>, int(num)):</div><div class="line">        <span class="comment"># 取得锁</span></div><div class="line">        mutex.acquire()</div><div class="line">        total = total + <span class="number">1</span></div><div class="line">        <span class="comment"># 释放锁</span></div><div class="line">        mutex.release()</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(num)</span>:</span></div><div class="line">    <span class="comment">#定义全局变量</span></div><div class="line">    <span class="keyword">global</span> total, mutex</div><div class="line">    total = <span class="number">0</span></div><div class="line">    <span class="comment"># 创建锁</span></div><div class="line">    mutex = threading.Lock()</div><div class="line">    </div><div class="line">    <span class="comment">#定义线程池</span></div><div class="line">    threads = []</div><div class="line">    <span class="comment"># 先创建线程对象</span></div><div class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">0</span>, num):</div><div class="line">        threads.append(threading.Thread(target=threadFunc, args=(<span class="number">100</span>,)))</div><div class="line">    <span class="comment"># 启动所有线程</span></div><div class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</div><div class="line">        t.start()</div><div class="line">    <span class="comment"># 主线程中等待所有子线程退出</span></div><div class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</div><div class="line">        t.join()  </div><div class="line">        </div><div class="line">    <span class="comment"># 打印执行结果</span></div><div class="line">    <span class="keyword">print</span> total</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="comment"># 创建40个线程</span></div><div class="line">    main(<span class="number">40</span>)</div></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ul>
<li>args=是一个tuple，即使没有参数也应该用()</li>
<li>如果希望子线程异步工作，要设置setDaemon为True；如果希望等待子线程工作结束后主进程再执行，在线程start后join</li>
</ul>
<h3 id="multiprocessing-dummy线程池"><a href="#multiprocessing-dummy线程池" class="headerlink" title="multiprocessing.dummy线程池"></a>multiprocessing.dummy线程池</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># encoding=utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> multiprocessing</div><div class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool <span class="keyword">as</span> ThreadPool</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.pool = ThreadPool(processes=<span class="number">8</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self, para)</span>:</span></div><div class="line">        print(para)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multi_work</span><span class="params">(self, trans)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            self.pool.map(self.display, trans)</div><div class="line">        <span class="keyword">except</span> multiprocessing.TimeoutError:</div><div class="line">            print(<span class="string">"pool time out"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></div><div class="line">        self.pool.close()</div><div class="line">        self.pool.join()</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    test = Test()</div><div class="line">    t = range(<span class="number">0</span>, <span class="number">6</span>)</div><div class="line">    test.multi_work(t)</div><div class="line">    test.close()</div></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>pool的join要在close之后执行</li>
<li>pool.map有可能超时，尽量捕捉这个错误</li>
</ul>
<h2 id="Python-多进程"><a href="#Python-多进程" class="headerlink" title="Python 多进程"></a>Python 多进程</h2><p>Python 多进程的实现也有三种：继承自multiprocessing.Process类、multiprocessing.process对象和multiprocessing pool进程池</p>
<h3 id="继承自multiprocessing-Process类"><a href="#继承自multiprocessing-Process类" class="headerlink" title="继承自multiprocessing.Process类"></a>继承自multiprocessing.Process类</h3><p>这里和多线程第一种实现方式一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> multiprocessing</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(multiprocessing.Process)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        multiprocessing.Process.__init__(self)</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<h3 id="multiprocessing-process对象"><a href="#multiprocessing-process对象" class="headerlink" title="multiprocessing.process对象"></a>multiprocessing.process对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="comment"># 子进程要执行的代码</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(name)</span>:</span></div><div class="line">  print(<span class="string">'Run child process %s (%s)...'</span> % (name, os.getpid()))</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">  print(<span class="string">'Parent process %s.'</span> % os.getpid())</div><div class="line">  p = Process(target=run_proc, args=(<span class="string">'test'</span>,))</div><div class="line">  print(<span class="string">'Child process will start.'</span>)</div><div class="line">  p.start()</div><div class="line">  p.join()</div><div class="line">  print(<span class="string">'Child process end.'</span>)</div></pre></td></tr></table></figure>
<h3 id="multiprocessing-pool进程池"><a href="#multiprocessing-pool进程池" class="headerlink" title="multiprocessing pool进程池"></a>multiprocessing pool进程池</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div><div class="line"><span class="keyword">import</span> os, time, random</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></div><div class="line">  print(<span class="string">'Run task %s (%s)...'</span> % (name, os.getpid()))</div><div class="line">  start = time.time()</div><div class="line">  time.sleep(random.random() * <span class="number">3</span>)</div><div class="line">  end = time.time()</div><div class="line">  print(<span class="string">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</div><div class="line">  print(<span class="string">'Parent process %s.'</span> % os.getpid())</div><div class="line">  p = Pool(<span class="number">4</span>)</div><div class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">    p.apply_async(long_time_task, args=(i,))</div><div class="line">  print(<span class="string">'Waiting for all subprocesses done...'</span>)</div><div class="line">  p.close()</div><div class="line">  p.join()</div><div class="line">  print(<span class="string">'All subprocesses done.'</span>)</div></pre></td></tr></table></figure>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol>
<li>多线程的线程间消息传递使用Queue.Queue；多进程使用multiprocessing.Queue；进程池必须使用multiprocessing.manager().Queue</li>
<li>多进程的消息传递可以采取Queue和Pipe两种高级数据结构，其中Queue是用Pipe实现的。Pipe只能支持两个进程的生产消费关系，如果存在多生产或者多消费的场景，只能用Queue。Pipe的效率高一些，但是高得有限，整体来看，多进程的消息传递的效率不高，尽量不要进行消息传递</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://realpython.com/python-gil/" target="_blank" rel="external">https://realpython.com/python-gil/</a></li>
<li><a href="https://my.oschina.net/cloudcoder/blog/226111" target="_blank" rel="external">https://my.oschina.net/cloudcoder/blog/226111</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近实习接触到这方面的东西，整理了一下&lt;/p&gt;
    
    </summary>
    
      <category term="开发随笔" scheme="https://www.liuin.cn/categories/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="python" scheme="https://www.liuin.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode总结——Minimax算法</title>
    <link href="https://www.liuin.cn/2018/06/30/LeetCode%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94Minimax%E7%AE%97%E6%B3%95/"/>
    <id>https://www.liuin.cn/2018/06/30/LeetCode总结——Minimax算法/</id>
    <published>2018-06-30T14:23:56.000Z</published>
    <updated>2018-08-30T15:07:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结在解决博弈问题中会用到的一个算法——Minimax算法</p>
<a id="more"></a>
<h2 id="什么是Minimax算法"><a href="#什么是Minimax算法" class="headerlink" title="什么是Minimax算法"></a>什么是Minimax算法</h2><p>什么是Minimax，它是用在决策轮、博弈论和概率论中的一条决策规则。它被用来最小化最坏情况下的可能损失。“最坏”情况是对手带来的最坏情况，“最小”是我要执行的一个最优策略的目标。</p>
<p>实际使用中一般，DFS来遍历当前局势以后所有可能的结果，通过『最大化』自己和『最小化』对手的方法获取下一步的动作。</p>
<h2 id="LeetCode-486"><a href="#LeetCode-486" class="headerlink" title="LeetCode 486"></a>LeetCode 486</h2><p>给定一个数组，双方轮流从数组的两边取出一个数，判断最后谁取的数多。</p>
<p>这是一个博弈问题，站在我的角度一定是要使自己的收益最大，但是站在对方的角度一定是要使我的收益最小。此时我们可以用f[i][j]表示我方在i~j这个数组下的收益，s[i][j]表示对方从两边拿了一个数以后我方的收益。此时不难得出状态转移方程：<code>f[i][j] = max(nums[i] + s[i+1][j], nums[j] + s[i][j-1])</code> 和 <code>min(f[i+1][j], f[i][j-1])</code> </p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Minimax 算法</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = nums.size();</div><div class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; f(len, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len, <span class="number">0</span>)), s(len, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len, <span class="number">0</span>));</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums) sum += i;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)</div><div class="line">        &#123;</div><div class="line">            f[j][j] = nums[j];</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = j<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</div><div class="line">            &#123;</div><div class="line">                f[i][j] = max(nums[i] + s[i+<span class="number">1</span>][j], nums[j] + s[i][j<span class="number">-1</span>]);</div><div class="line">                s[i][j] = min(f[i+<span class="number">1</span>][j], f[i][j<span class="number">-1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][len<span class="number">-1</span>] &gt;= (sum+<span class="number">1</span>)/<span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="LeetCode-375"><a href="#LeetCode-375" class="headerlink" title="LeetCode 375"></a>LeetCode 375</h2><p>题意：某人从1~n中选一个数k，你每次给出一个数x，他会告诉你x与n的关系(大于，小于或等于)，每次询问你都需要花费x的代价，问你至少需要花费多少钱才能保证查找到k是多少。</p>
<p>一道比较典型的Minimax题目，最小化最大值，当确定中间的一个数x的时候，为了保证找到k一定是选取两边的代价中最大的。但是你可以选取这个x时，你可以选取一个代价最小的x。dp[i][j]表示从i到j猜出值所需要的代价，这时我们可以得到状态转移方程：<code>dp[i][j] = min(x + max(dp[i][k-1], dp[k+1][j]) ) {i &lt;= k &lt;= j}</code></p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Minimax算法，dp思路</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, INT_MAX));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(i == j) dp[i][j] = <span class="number">0</span>;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; j) dp[i][j] = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n-i; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> tem = INT_MAX;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt;= j+i; k++)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(k == <span class="number">0</span>)</div><div class="line">                        tem = min(tem, k + dp[k+<span class="number">1</span>][j+i]);</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(k == n)</div><div class="line">                        tem = min(tem, k + dp[j][k<span class="number">-1</span>]);</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        tem = min(tem, k + max(dp[j][k<span class="number">-1</span>], dp[k+<span class="number">1</span>][j+i]));</div><div class="line">                &#125;</div><div class="line">                dp[j][j+i] = tem;</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="LeetCode-464"><a href="#LeetCode-464" class="headerlink" title="LeetCode 464"></a>LeetCode 464</h2><p>题意：给定两个数m和target，两人依次从1到m的m个数中取出一个数，当轮到的人取出一个数以后使得所有取出的数不小于target这个人就获胜了，判断第一个取的能不能取得游戏的胜利</p>
<p>按照Minimax的思路，当我方作出决策的时候一定作出的是最我方损失最小的决策。当我方所在一个状态数组（1到m中各个数的取出状态数组）和一个target的时候，这个时候我们要做的是从这个状态数组中标记一个数为拿出状态，使得其大于target或者使得轮到对方决策后一定是输。</p>
<p>这里比较棘手的就是这个状态数组了，但是题目给了一个条件，m的值不会超过20个，这个时候我们就可以做一个状态压缩——用status一个数表示整个状态数组：那么这个时候我们就可以得到状态转移方程：<code>dp[n][status] = ((1 &lt;&lt; x) &amp; status) == 0 &amp;&amp; (x &gt;= n || dp[n-x][status | (1 &lt;&lt; x)])</code>，其中<code>((1 &lt;&lt; x) &amp; status)</code>表示当前选择的数x是否被选择过；<code>status | (1 &lt;&lt; x)</code>表示选择了x以后的状态数组的状态</p>
<p>虽然得到状态转移方程，但是我们不好通过遍历求解，这个时候就可以将动态规划“退化”成递归加上状态记录。这里dp按理说是一个二维数组，但是status和n是有关系的，n表示的是总数减去其取出的数。这里使用map来表示这个dp数组，因为能够表示出三种状态：没有访问过、true、false</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; dp;</div><div class="line">    </div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Minimax算法思想，最小化对手的收益</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> desiredTotal)</span> </span>&#123;</div><div class="line">        n = maxChoosableInteger;</div><div class="line">        <span class="keyword">if</span>(n &gt;= desiredTotal) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span>((<span class="number">1</span> + n) * n / <span class="number">2</span> &lt; desiredTotal) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> solute(desiredTotal, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 因为status和nowNum是有关联关系的，所以map中需要一个</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solute</span><span class="params">(<span class="keyword">int</span> nowNum, <span class="keyword">int</span> status)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(dp.find(status) != dp.end()) <span class="keyword">return</span> dp[status];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> tem = (<span class="number">1</span> &lt;&lt; i);</div><div class="line">            <span class="keyword">if</span>((tem &amp; status) == <span class="number">0</span> &amp;&amp; (i &gt;= nowNum || !solute(nowNum - i, tem | status)))</div><div class="line">            &#123;</div><div class="line">                dp[status] = <span class="literal">true</span>;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        dp[status] = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结在解决博弈问题中会用到的一个算法——Minimax算法&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.liuin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://www.liuin.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>推荐两个终端代理工具：ProxyChains 和 Proxifier</title>
    <link href="https://www.liuin.cn/2018/06/24/%E6%8E%A8%E8%8D%90%E4%B8%A4%E4%B8%AA%E7%BB%88%E7%AB%AF%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9AProxyChains-%E5%92%8C-Proxifier/"/>
    <id>https://www.liuin.cn/2018/06/24/推荐两个终端代理工具：ProxyChains-和-Proxifier/</id>
    <published>2018-06-24T07:10:19.000Z</published>
    <updated>2018-06-24T07:42:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>Shadowsocks代理是sock5代理，但是我们的终端中的很多应用都是不走sock5代理的，这个时候就需要一些工具来让这些数据通过sock5进行传输，这里推荐两个Linux和Mac中常用的工具：ProxyChains 和 Proxifier</p>
<a id="more"></a>
<h2 id="ProxyChains"><a href="#ProxyChains" class="headerlink" title="ProxyChains"></a>ProxyChains</h2><p>ProxyChains的功能就是Hook 了 sockets 相关的操作，让普通程序的 sockets 数据走 SOCKS/HTTP 代理。其在实现部分主要是重写了部分socket函数。</p>
<p>其能够在同一条代理链中整合不同类型的代理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">your_host &lt;--&gt;socks5 &lt;--&gt; http &lt;--&gt; socks4 &lt;--&gt; target_host</div></pre></td></tr></table></figure></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote>
<p>源码编译安装</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 下载源码</div><div class="line">$ git <span class="built_in">clone</span> https://github.com/rofl0r/proxychains-ng</div><div class="line">// 编译</div><div class="line">$ ./configure --prefix=/usr --sysconfdir=/etc</div><div class="line">$ make</div><div class="line">$ make install</div><div class="line">$ make install-config (安装proxychains.conf配置文件)</div></pre></td></tr></table></figure>
<blockquote>
<p>Mac 安装</p>
</blockquote>
<p>因为macOS 10.11 后开启了 <a href="https://support.apple.com/zh-cn/ht204899" target="_blank" rel="external">SIP（System Integrity Protection）</a> 会导致命令行下 proxychains-ng 代理的模式失效。所以要安装ProxyChains首先需要关闭SIP功能</p>
<ul>
<li>部分关闭SIP</li>
</ul>
<p>重启Mac，按住Option键进入启动盘选择模式，再按⌘ + R进入Recovery模式。<br>实用工具（Utilities）-&gt; 终端（Terminal）。<br>输入命令<code>csrutil enable --without debug</code>运行。<br>重启进入系统后，终端里输入 csrutil status，结果中如果有 Debugging Restrictions: disabled 则说明关闭成功。</p>
<ul>
<li>全部关闭SIP</li>
</ul>
<p>重启Mac，按住Option键进入启动盘选择模式，再按⌘ + R进入Recovery模式。<br>实用工具（Utilities）-&gt; 终端（Terminal）。<br>输入命令<code>csrutil disable</code>运行。<br>重启进入系统后，终端里输入 csrutil status，结果中如果有 System Integrity Protection status:disabled. 则说明关闭成功。</p>
<p>关闭以后通过<code>brew</code>进行安装就行了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install proxychains-ng</div></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>proxychains-ng默认配置文件名为proxychains.conf</p>
<ul>
<li>通过源代码编译安装的默认为/etc/proxychains.conf。</li>
<li>Mac下用<code>Homebrew</code>安装的默认为/usr/local/etc/proxychains.conf</li>
</ul>
<p>配置只需要将代理加入[ProxyList]中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[ProxyList]</div><div class="line">socks5  127.0.0.1 1086</div></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在你需要进行代理的页面前面加上<code>proxychains4</code>即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ proxhchains4 curl www.google.com</div></pre></td></tr></table></figure>
<h2 id="Proxifier"><a href="#Proxifier" class="headerlink" title="Proxifier"></a>Proxifier</h2><p>Mac用户可能会觉得关闭SIP会造成一些安全隐患，这个时候可以使用Mac下的一个工具：Proxifier</p>
<p>Proxifier可以设定Mac上不同的应用走不同的代理，我们把我们平常需要的一些终端应用设置走指定的代理就行了</p>
<h3 id="添加代理"><a href="#添加代理" class="headerlink" title="添加代理"></a>添加代理</h3><p>打开Proxifier，打开<code>Proxies-&gt;Add</code>，输入地址和端口号添加对应的sock5代理</p>
<p><img src="http://data3.liuin.cn/2018-06-24-15298257914991.jpg" alt=""></p>
<h3 id="设置代理规则"><a href="#设置代理规则" class="headerlink" title="设置代理规则"></a>设置代理规则</h3><p>在<code>Rules</code>模块中，我们可以设置指定应用、目标主机、目标端口走我们刚才添加的代理</p>
<p><img src="http://data3.liuin.cn/2018-06-24-15298261213304.jpg" alt=""></p>
<p>需要注意的是，我们给我们提供的代理的Shadowsocks要设置成直接连接不能加入代理中，否则会造成整个代理链成了一条环，最后上不了网。</p>
<p>设置以后就可能在终端中享受代理服务了~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Shadowsocks代理是sock5代理，但是我们的终端中的很多应用都是不走sock5代理的，这个时候就需要一些工具来让这些数据通过sock5进行传输，这里推荐两个Linux和Mac中常用的工具：ProxyChains 和 Proxifier&lt;/p&gt;
    
    </summary>
    
      <category term="软件使用" scheme="https://www.liuin.cn/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="效率提升" scheme="https://www.liuin.cn/tags/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>初识 Go 语言</title>
    <link href="https://www.liuin.cn/2018/06/22/%E5%88%9D%E8%AF%86-Go-%E8%AF%AD%E8%A8%80/"/>
    <id>https://www.liuin.cn/2018/06/22/初识-Go-语言/</id>
    <published>2018-06-22T00:51:45.000Z</published>
    <updated>2018-06-24T07:06:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天来会一会这个小地鼠</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Go是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。Go语言号称集多数编程语言的优势于一身，具有较高的生产效率、先进的依赖管理和类型系统，以及原生的并发计算支持。</p>
<p>Go语言的语法接近C语言，但对于变量的声明有所不同。Go语言支持垃圾回收功能。Go语言的并行模型是以东尼·霍尔的通信顺序进程（CSP）为基础，采取类似模型的其他语言包括Occam和Limbo，但它也具有Pi运算的特征，比如通道传输。</p>
<p>与C++相比，Go语言并不包括如异常处理、继承、泛型、断言、虚函数等功能，但增加了 Slice 型、并发、管道、垃圾回收、接口（Interface）等特性的语言级支持</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol>
<li><p>部署简单。Go 是一个编译型语言，Go 编译生成的是一个静态可执行文件，除了 glibc 外没有其他外部依赖。</p>
</li>
<li><p>并发性好。Goroutine 和 channel 使得编写高并发的服务端软件变得相当容易，很多情况下完全不需要考虑锁机制以及由此带来的问题。</p>
</li>
<li><p>代码风格强制统一</p>
</li>
<li><p>Go语言语法趋于脚本化，比较简洁，但Go是编译型语言而非解释型语言。</p>
</li>
<li><p>Go语言使用垃圾自动回收机制（GC），GC是定时自动启动，人工可做稍微的干预。</p>
</li>
</ol>
<h2 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h2><ol>
<li>错误处理</li>
</ol>
<p>在Go语言中处理错误的基本模式是：函数通常返回多个值，其中最后一个值是error类型，用于表示错误类型极其描述；调用者每次调用完一个函数，都需要检查这个error并进行相应的错误处理：if err != nil { /*这种代码写多了不想吐么*/ }。此模式跟C语言那种很原始的错误处理相比如出一辙，并无实质性改进。</p>
<ol>
<li>软件包管理</li>
</ol>
<p>Go 语言的软件包管理绝对不是完美的。默认情况下，它没有办法制定特定版本的依赖库，也无法创建可复写的 builds。相比之下 Python、Node 和 Ruby 都有更好的软件包管理系统。然而通过正确的工具，Go 语言的软件包管理也可以表现得不错。</p>
<h2 id="基本语法学习"><a href="#基本语法学习" class="headerlink" title="基本语法学习"></a>基本语法学习</h2><p>找到两个口碑比较好的入门Go语言的教程：</p>
<ul>
<li><a href="https://tour.go-zh.org/welcome/1" target="_blank" rel="external">Go语言之旅</a></li>
<li><a href="https://legacy.gitbook.com/book/yar999/gopl-zh/details" target="_blank" rel="external">Go语言圣经</a></li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Go在Linux上的配置比较简单，无非就是下载一个二进制文件，然后添加一下环境变量。</p>
<p>Go在mac上推荐使用brew进行安装，使用官网的安装包进行安装因为<a href="https://support.apple.com/zh-cn/HT204899" target="_blank" rel="external">苹果对一些目录的保护</a>，后面在安装其他库的时候可能会存在问题</p>
<p>具体可以参考官方<a href="https://golang.org/doc/install" target="_blank" rel="external">配置文档</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.zhihu.com/question/21409296" target="_blank" rel="external">https://www.zhihu.com/question/21409296</a></li>
<li><a href="https://blog.csdn.net/itsenlin/article/details/53750262" target="_blank" rel="external">https://blog.csdn.net/itsenlin/article/details/53750262</a></li>
<li><a href="https://blog.csdn.net/liigo/article/details/23699459" target="_blank" rel="external">https://blog.csdn.net/liigo/article/details/23699459</a></li>
<li><a href="http://www.techug.com/post/bad-and-good-of-golang.html" target="_blank" rel="external">http://www.techug.com/post/bad-and-good-of-golang.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来会一会这个小地鼠&lt;/p&gt;
    
    </summary>
    
      <category term="开发随笔" scheme="https://www.liuin.cn/categories/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Go" scheme="https://www.liuin.cn/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析——客户端和服务器</title>
    <link href="https://www.liuin.cn/2018/06/19/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://www.liuin.cn/2018/06/19/Redis源码剖析——客户端和服务器/</id>
    <published>2018-06-19T06:52:27.000Z</published>
    <updated>2018-06-21T08:16:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis服务器是典型的一对多服务器程序:一个服务器可以与多个客户端建立网络连接。这篇文章将通过源码看看客户端和服务器的底层数据结构和工作过程</p>
<a id="more"></a>
<p>在Redis这种一对多的服务模式下，每个客户端可以向服务器发送命令请求,而服务器则接收并处理客户端发送的命令请求,并向客户端返回命令回复。通过使用由I/O多路复用技术实现的文件事件处理器,Redis服务器使用单线程单进程的方式来处理命令请求,并与多个客户端进行网络通信。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="客户端数据结构"><a href="#客户端数据结构" class="headerlink" title="客户端数据结构"></a>客户端数据结构</h3><p>客户端底层的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisClient &#123;</div><div class="line">    <span class="keyword">uint64_t</span> id;            <span class="comment">/* Client incremental unique ID. */</span></div><div class="line">    <span class="comment">// 套接字描述符</span></div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line">    redisDb *db;</div><div class="line">    <span class="keyword">int</span> dictid;</div><div class="line">    <span class="comment">// 客户端名字</span></div><div class="line">    robj *name;             <span class="comment">/* As set by CLIENT SETNAME */</span></div><div class="line">    <span class="comment">// 输入缓冲区，保存客户端发送的命令请求</span></div><div class="line">    sds querybuf;</div><div class="line">    <span class="keyword">size_t</span> querybuf_peak;   <span class="comment">/* Recent (100ms or more) peak of querybuf size */</span></div><div class="line">    <span class="comment">// 命令和命令参数</span></div><div class="line">    <span class="keyword">int</span> argc;</div><div class="line">    robj **argv;</div><div class="line">    <span class="comment">// 命令实现函数字典</span></div><div class="line">    <span class="keyword">struct</span> redisCommand *cmd, *lastcmd;</div><div class="line">    <span class="keyword">int</span> reqtype;</div><div class="line">    <span class="keyword">int</span> multibulklen;       <span class="comment">/* number of multi bulk arguments left to read */</span></div><div class="line">    <span class="keyword">long</span> bulklen;           <span class="comment">/* length of bulk argument in multi bulk request */</span></div><div class="line">    <span class="built_in">list</span> *reply;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> reply_bytes; <span class="comment">/* Tot bytes of objects in reply list */</span></div><div class="line">    <span class="keyword">int</span> sentlen;            <span class="comment">/* Amount of bytes already sent in the current</span></div><div class="line">                               buffer or object being sent. */</div><div class="line">    <span class="comment">// 创建客户端时间</span></div><div class="line">    <span class="keyword">time_t</span> ctime;           <span class="comment">/* Client creation time */</span></div><div class="line">    <span class="comment">// 客户端和服务器最后一次进行互动的时间</span></div><div class="line">    <span class="keyword">time_t</span> lastinteraction; <span class="comment">/* time of the last interaction, used for timeout */</span></div><div class="line">    <span class="keyword">time_t</span> obuf_soft_limit_reached_time;</div><div class="line">    <span class="comment">// 标志，记录客户端的角色</span></div><div class="line">    <span class="keyword">int</span> flags;              <span class="comment">/* REDIS_SLAVE | REDIS_MONITOR | REDIS_MULTI ... */</span></div><div class="line">    <span class="comment">// 标志是否通过身份验证</span></div><div class="line">    <span class="keyword">int</span> authenticated;      <span class="comment">/* when requirepass is non-NULL */</span></div><div class="line">    ... <span class="comment">// 其他相关属性</span></div><div class="line"></div><div class="line">    <span class="comment">/* Response buffer */</span></div><div class="line">    <span class="comment">// 回应缓冲区</span></div><div class="line">    <span class="keyword">int</span> bufpos;</div><div class="line">    <span class="keyword">char</span> buf[REDIS_REPLY_CHUNK_BYTES];</div><div class="line">&#125; redisClient;</div></pre></td></tr></table></figure>
<p>在客户端的各个属性中：</p>
<p>fd表示套接字描述符，伪客户端的fd属性的值为-1:伪客户端处理的命令请求来源于AOF文件或者Lua脚本,而不是网络,所以这种客户端不需要套接字连接；普通客户端的fd属性的值为大于-1的整数</p>
<p>命令和命令参数是对输入缓冲的命令进行解析以后获得命令和参数。</p>
<p><code>cmd</code>是命令的实现函数的数组，命令实现函数的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> redisCommand &#123;</div><div class="line">    <span class="comment">// 命令名称</span></div><div class="line">    <span class="keyword">char</span> *name;</div><div class="line">    <span class="comment">// 命令执行函数</span></div><div class="line">    redisCommandProc *proc;</div><div class="line">    <span class="comment">// 参数个数</span></div><div class="line">    <span class="keyword">int</span> arity;</div><div class="line">    <span class="comment">// 字符串表示flag</span></div><div class="line">    <span class="keyword">char</span> *sflags; <span class="comment">/* Flags as string representation, one char per flag. */</span></div><div class="line">    <span class="comment">// 实际flag</span></div><div class="line">    <span class="keyword">int</span> flags;    <span class="comment">/* The actual flags, obtained from the 'sflags' field. */</span></div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">// 指定哪些参数是key</span></div><div class="line">    <span class="keyword">int</span> firstkey; <span class="comment">/* The first argument that's a key (0 = no keys) */</span></div><div class="line">    <span class="keyword">int</span> lastkey;  <span class="comment">/* The last argument that's a key */</span></div><div class="line">    <span class="keyword">int</span> keystep;  <span class="comment">/* The step between first and last key */</span></div><div class="line">    <span class="comment">// 统计信息</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> microseconds, calls;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="客户端的创建和关闭"><a href="#客户端的创建和关闭" class="headerlink" title="客户端的创建和关闭"></a>客户端的创建和关闭</h3><p>当客户端向服务器发出connect请求的时候，服务器的事件处理器就会对这个事件进行处理，创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 创建一个新客户端</div><div class="line"> */</div><div class="line"><span class="function">redisClient *<span class="title">createClient</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 分配空间</span></div><div class="line">    redisClient *c = zmalloc(<span class="keyword">sizeof</span>(redisClient));</div><div class="line"></div><div class="line">    <span class="comment">// 当 fd 不为 -1 时，创建带网络连接的客户端</span></div><div class="line">    <span class="comment">// 如果 fd 为 -1 ，那么创建无网络连接的伪客户端</span></div><div class="line">    <span class="comment">// 因为 Redis 的命令必须在客户端的上下文中使用，所以在执行 Lua 环境中的命令时</span></div><div class="line">    <span class="comment">// 需要用到这种伪终端</span></div><div class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</div><div class="line">        <span class="comment">// 非阻塞</span></div><div class="line">        anetNonBlock(<span class="literal">NULL</span>,fd);</div><div class="line">        <span class="comment">// 禁用 Nagle 算法</span></div><div class="line">        anetEnableTcpNoDelay(<span class="literal">NULL</span>,fd);</div><div class="line">        <span class="comment">// 设置 keep alive</span></div><div class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</div><div class="line">            anetKeepAlive(<span class="literal">NULL</span>,fd,server.tcpkeepalive);</div><div class="line">        <span class="comment">// 绑定读事件到事件 loop （开始接收命令请求）</span></div><div class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el,fd,AE_READABLE,</div><div class="line">            readQueryFromClient, c) == AE_ERR)</div><div class="line">        &#123;</div><div class="line">            close(fd);</div><div class="line">            zfree(c);</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化各个属性</span></div><div class="line"></div><div class="line">    <span class="comment">// 默认数据库</span></div><div class="line">    selectDb(c,<span class="number">0</span>);</div><div class="line">    <span class="comment">// 套接字</span></div><div class="line">    c-&gt;fd = fd;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    </div><div class="line">    listSetFreeMethod(c-&gt;pubsub_patterns,decrRefCountVoid);</div><div class="line">    listSetMatchMethod(c-&gt;pubsub_patterns,listMatchObjects);</div><div class="line">    <span class="comment">// 如果不是伪客户端，那么添加到服务器的客户端链表中</span></div><div class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) listAddNodeTail(server.clients,c);</div><div class="line">    <span class="comment">// 初始化客户端的事务状态</span></div><div class="line">    initClientMultiState(c);</div><div class="line"></div><div class="line">    <span class="comment">// 返回客户端</span></div><div class="line">    <span class="keyword">return</span> c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于客户端的启动程序，其大致的逻辑是：读取本地配置，连接服务器获取服务器的配置，获取本地输入的命令并发送到服务器</p>
<p>一个普通客户端可以因为多种原因而被关闭:</p>
<ul>
<li>如果客户端进程退出或者被杀死,那么客户端与服务器之间的网络连接将被关闭,从而造成客户端被关闭。</li>
<li>如果客户端向服务器发送了带有不符合协议格式的命令请求,那么这个客户端也会被服务器关闭。</li>
<li>如果客户端成为了CLIENT KLLL命令的目标,那么它也会被关闭。</li>
</ul>
<p>关闭客户端的底层实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 释放客户端</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeClient</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    listNode *ln;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">/* Free the query buffer */</span></div><div class="line">    sdsfree(c-&gt;querybuf);</div><div class="line">    c-&gt;querybuf = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Deallocate structures used to block on blocking ops. */</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_BLOCKED) unblockClient(c);</div><div class="line">    dictRelease(c-&gt;bpop.keys);</div><div class="line"></div><div class="line">    <span class="comment">/* UNWATCH all the keys */</span></div><div class="line">    <span class="comment">// 清空 WATCH 信息</span></div><div class="line">    unwatchAllKeys(c);</div><div class="line">    listRelease(c-&gt;watched_keys);</div><div class="line"></div><div class="line">    <span class="comment">/* Unsubscribe from all the pubsub channels */</span></div><div class="line">    <span class="comment">// 退订所有频道和模式</span></div><div class="line">    pubsubUnsubscribeAllChannels(c,<span class="number">0</span>);</div><div class="line">    pubsubUnsubscribeAllPatterns(c,<span class="number">0</span>);</div><div class="line">    dictRelease(c-&gt;pubsub_channels);</div><div class="line">    listRelease(c-&gt;pubsub_patterns);</div><div class="line"></div><div class="line">    <span class="comment">/* Close socket, unregister events, and remove list of replies and</span></div><div class="line">     * accumulated arguments. */</div><div class="line">    <span class="comment">// 关闭套接字，并从事件处理器中删除该套接字的事件</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;fd != <span class="number">-1</span>) &#123;</div><div class="line">        aeDeleteFileEvent(server.el,c-&gt;fd,AE_READABLE);</div><div class="line">        aeDeleteFileEvent(server.el,c-&gt;fd,AE_WRITABLE);</div><div class="line">        close(c-&gt;fd);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 清空回复缓冲区</span></div><div class="line">    listRelease(c-&gt;reply);</div><div class="line"></div><div class="line">    <span class="comment">// 清空命令参数</span></div><div class="line">    freeClientArgv(c);</div><div class="line"></div><div class="line">    <span class="comment">/* Remove from the list of clients */</span></div><div class="line">    <span class="comment">// 从服务器的客户端链表中删除自身</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;fd != <span class="number">-1</span>) &#123;</div><div class="line">        ln = listSearchKey(server.clients,c);</div><div class="line">        redisAssert(ln != <span class="literal">NULL</span>);</div><div class="line">        listDelNode(server.clients,ln);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除客户端的阻塞信息</span></div><div class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_UNBLOCKED) &#123;</div><div class="line">        ln = listSearchKey(server.unblocked_clients,c);</div><div class="line">        redisAssert(ln != <span class="literal">NULL</span>);</div><div class="line">        listDelNode(server.unblocked_clients,ln);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (c-&gt;name) decrRefCount(c-&gt;name);</div><div class="line">    <span class="comment">// 清除参数空间</span></div><div class="line">    zfree(c-&gt;argv);</div><div class="line">    <span class="comment">// 清除事务状态信息</span></div><div class="line">    freeClientMultiState(c);</div><div class="line">    sdsfree(c-&gt;peerid);</div><div class="line">    <span class="comment">// 释放客户端 redisClient 结构本身</span></div><div class="line">    zfree(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="请求命令执行的过程"><a href="#请求命令执行的过程" class="headerlink" title="请求命令执行的过程"></a>请求命令执行的过程</h3><p>从客户端输入一条指令到服务端完成命令的内容并返回要经历以下这些步骤：</p>
<ol>
<li>发送命令请求，Redis服务器的命令请求来自 Redis客户端,当用户在客户端中键人一个命令请求时,客户端会将这个命令请求转换成协议格式,然后通过套接字发送给服务器</li>
<li>读取命令的内容，服务器接受到套接字以后会产生一个文件事件，通过对文件事件的处理，判断为命令内容</li>
<li>查找命令实现，根据客户端的命令参数argv[0]，在服务器的命令表中查找指定的命令，并将找到的命令保存到客户端状态的cmd属性里面</li>
<li>执行预备操作，在执行命令前需要进行一些操作：检查给出的命令是否有效（cmd是否为NULL）;判断给定的参数是否正确；判断客户端是否通过验证</li>
<li>调用命令的实现函数</li>
<li>执行后续的工作，包括添加日志，计算时间属性，进行AOF操作等等</li>
<li>将命令回复发送给客户端</li>
<li>客户端收到并打印命令</li>
</ol>
<h3 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h3><p>Redis服务器中的 serverCron函数默认每隔100毫秒执行一次,这个函数负责管理服务器的资源,并保持服务器自身的良好运转</p>
<p>因为serverCron的实现代码太过冗长，所以这里就简单说一些serverCron函数都干了哪些事情</p>
<ol>
<li>更新服务器时间缓存</li>
</ol>
<p>Redis服务器中许多的操作都需要用到当前的系统时间属性<code>unixtime</code>，serverCron会更新这个时间属性</p>
<ol>
<li>更新LRU时钟</li>
</ol>
<p>Reids服务器中实现过期键的删除需要计算其空转时间，计算空转时间需要用LRU时钟，serverCron会更新这个时钟保证Redis过期键删除功能的正常使用</p>
<ol>
<li>更新服务器内存峰值记录</li>
</ol>
<p>Redis中使用了一个属性<code>stat_peak_memory</code>记录了使用内存的峰值，这个属性需要serverCron进行更新</p>
<ol>
<li>处理SIGTERM信号</li>
</ol>
<p>在启动服务器时, Redis会为服务器进程的 SIGTERM信号关联处理器 sigtermhandier函数,这个信号处理器负责在服务器接到 SIGTERM信号时,打开服务器状态的 shutdown_asap标识。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis服务器是典型的一对多服务器程序:一个服务器可以与多个客户端建立网络连接。这篇文章将通过源码看看客户端和服务器的底层数据结构和工作过程&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="https://www.liuin.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode总结——字符串相关算法</title>
    <link href="https://www.liuin.cn/2018/06/18/LeetCode%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
    <id>https://www.liuin.cn/2018/06/18/LeetCode总结——字符串相关算法/</id>
    <published>2018-06-18T04:37:11.000Z</published>
    <updated>2018-06-18T04:54:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结在LeetCode中字符串相关的常用的一些算法</p>
<a id="more"></a>
<h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><p>KMP算法解决的是两个字符串的匹配问题（一个字符串是不是另外一个字符串的子串）</p>
<p>暴力法所需要的时间复杂度是O(n*m)，KMP算法能够优化到O(n)。KMP算法的核心是使用一个next数组实现匹配的加速</p>
<h3 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h3><p>最长前缀后缀：一个字符串中所有的前缀和其所有的后缀中最长的相等的长度，比如说“abcabc”的最长前缀后缀为”abc”</p>
<p>给定一个串s的next数组next[]，其每一位next[i]表示串s[0…i-1]中最长前缀后缀</p>
<p>使用next数据对字符串匹配进行加速：s1中查找是否有子串s2，如果s1[i]匹配到s2[j]的时候不相等，并且此时next[j]=k，此时不需要重新回到s1[1]继续进行匹配，而是用s2[k]继续和s1[i]进行匹配，依次类推</p>
<p><img src="http://data3.liuin.cn/2018-06-17-15292350043789.jpg" alt=""></p>
<p>因为next数组是找到了最长前缀后缀的，所以其能够从最长前缀的匹配跳到最长后缀的匹配，因为中间不可能出现匹配的情况，如果出现匹配那么表示当前next计算的不可能是”最长“前缀后缀。</p>
<h3 id="next数组求法"><a href="#next数组求法" class="headerlink" title="next数组求法"></a>next数组求法</h3><p>规定<code>next[0] = -1</code>， 因为其前面没有字符串；<code>next[1] = 0</code>，因为其前面的字符串中只有一个字符，后面的next值的计算取决于前面的next值：</p>
<p>判断当前位置的字符和最长前缀的后一个字符是否相等，如果相等则<code>next[i] = next[i-1] + 1</code>，如果不等再判断最长前缀的最长前缀和其相等不相等，如果还不相等就继续找最长前缀，直到最长前缀长度为0的时候表示没有找到，这个时候<code>next[i] = 0</code></p>
<h3 id="LeetCode-028"><a href="#LeetCode-028" class="headerlink" title="LeetCode 028"></a>LeetCode 028</h3><p><a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="external">Implement strStr()</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = p.size();</div><div class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="comment">// 生成next数组</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(len, <span class="number">0</span>);</div><div class="line">        getNext(next, p);</div><div class="line">        <span class="comment">// 两个数组的遍历指针</span></div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; j &lt; len)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(s[i] == p[j])</div><div class="line">            &#123;</div><div class="line">                i++;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>) i++;</div><div class="line">                <span class="comment">// 根据next数组中的信息进行重新指向</span></div><div class="line">                <span class="keyword">else</span> j = next[j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> j == len ? i - j : <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;next, <span class="built_in">string</span> p)</span></span></div><div class="line">    &#123;</div><div class="line">        next[<span class="number">0</span>] = <span class="number">-1</span>;</div><div class="line">        <span class="comment">// k表示最长前缀后缀的长度</span></div><div class="line">        <span class="keyword">int</span> k = <span class="number">-1</span>, i = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 计算到最后一位</span></div><div class="line">        <span class="keyword">while</span>(i &lt; p.size() - <span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 相匹配的时候对next数组赋值</span></div><div class="line">            <span class="keyword">if</span>(k == <span class="number">-1</span> || p[i] == p[k])</div><div class="line">                next[++i] = ++k;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                k = next[k];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="Manacher-算法"><a href="#Manacher-算法" class="headerlink" title="Manacher 算法"></a>Manacher 算法</h2><p>Manacher 算法解决的是字符串中最长的回文子串的问题</p>
<p>暴力法（技巧：中间添加辅助字符）解决这个问题的时间复杂度为O(n^2)，Manacher算法能够时间复杂度优化为O(n)</p>
<h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><ul>
<li>回文半径数组，以i为中心的的回文的半径长度</li>
<li>回文右边界，遍历过的回文能够达到的最右的下标</li>
<li>右边界中心位置，回文右边界对应的回文中心点下标</li>
</ul>
<h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><p>和暴力解法一样从左向右扩充判断，有以下几种情况：</p>
<ol>
<li>当前位置不在回文右边界里面，暴力扩充</li>
<li>当前位置在回文右边界里面，其关于右边界中心的对称点的回文区域<strong>在左边界里面</strong>，其回文半径和其对称点一样</li>
<li>当前位置在回文右边界里面，其关于右边界中心的对称点的回文左区域<strong>超过回文左边界</strong>，其回文半径为r-i</li>
<li>当前位置在回文右边界里面，其关于右边界中心的对称点的回文左区域<strong>与回文左边界重合（压线）</strong>，其回文半径需要在r-i的基础上往后判断</li>
</ol>
<p><img src="http://data3.liuin.cn/2018-06-17-15292498856933.jpg" alt=""></p>
<h3 id="LeetCode-005"><a href="#LeetCode-005" class="headerlink" title="LeetCode 005"></a>LeetCode 005</h3><p><a href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank" rel="external">Longest Palindromic Substring</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Manacher 算法</span></div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="comment">// 添加辅助字符#</span></div><div class="line">        <span class="built_in">string</span> new_s;</div><div class="line">        new_s.push_back(<span class="string">'#'</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</div><div class="line">        &#123;</div><div class="line">            new_s.push_back(s[i]);</div><div class="line">            new_s.push_back(<span class="string">'#'</span>);</div><div class="line">        &#125;</div><div class="line">        s = new_s;</div><div class="line">        <span class="keyword">int</span> len = s.size();</div><div class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="comment">// 回文半径数组</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pArr(len, <span class="number">0</span>);</div><div class="line">        <span class="comment">// C表示回文中心， R表示回文右边界</span></div><div class="line">        <span class="keyword">int</span> C = <span class="number">-1</span>, R = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">int</span> maxv = INT_MIN, maxi = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 在回文右边界里面与否的区分</span></div><div class="line">            <span class="comment">// 此时pArr表示的是起码不用验的区域 </span></div><div class="line">            pArr[i] = R &gt; i ? min(pArr[<span class="number">2</span>*C - i], R - i) : <span class="number">1</span>;</div><div class="line">            <span class="comment">// 区域没有越界</span></div><div class="line">            <span class="keyword">while</span>(i + pArr[i] &lt; len &amp;&amp; i - pArr[i] &gt; <span class="number">-1</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">// 情况1+4 扩充</span></div><div class="line">                <span class="keyword">if</span>(s[i + pArr[i]] == s[i - pArr[i]])</div><div class="line">                    pArr[i]++;</div><div class="line">                <span class="comment">// 情况2+3</span></div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(i + pArr[i] &gt; R)</div><div class="line">            &#123;</div><div class="line">                R = i + pArr[i];</div><div class="line">                C = i;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(maxv &lt; pArr[i])</div><div class="line">            &#123;</div><div class="line">                maxv = pArr[i];</div><div class="line">                maxi = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">string</span> res;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = maxi - maxv + <span class="number">1</span>; i &lt;= maxi + maxv - <span class="number">1</span>; i++)</div><div class="line">            <span class="keyword">if</span>(s[i] != <span class="string">'#'</span>) res.push_back(s[i]);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结在LeetCode中字符串相关的常用的一些算法&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.liuin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://www.liuin.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>《大型网站技术架构》 笔记</title>
    <link href="https://www.liuin.cn/2018/06/18/%E3%80%8A%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E3%80%8B-%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.liuin.cn/2018/06/18/《大型网站技术架构》-笔记/</id>
    <published>2018-06-18T02:01:58.000Z</published>
    <updated>2018-06-18T05:56:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近用了三天的时间把《大型网站技术架构》看完了，收获颇多。这本书主要讲了一个网站从小到大发展过程在技术架构上的需要注意的地方，这里简短地记录一下我的收获吧。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>第一篇概述主要从大型网站的架构演化、架构模式和核心构架要素三个方面对大型网站技术架构进行了一个综合性的概述。</p>
<p>大型网站架构演化发展历程主要经过以下几个阶段：</p>
<ul>
<li>初始阶段的网站架构，能够跑来就行，所有的资源放在一个服务器上</li>
<li>应用服务和数据服务分离，随着需求的不断扩大，将应用和数据根据对硬件资源的要求不同分离成应用服务器、文件服务器和数据库服务器</li>
<li>使用缓存改善网站性能，根据二八定律把经常访问的一小部分数据缓存在内存中，减少对数据库访问的压力，改善网站性能</li>
<li>使用应用服务器集群改善网站的并发处理能力，通过负载均衡调度服务器，将请求分发到应用服务器集群中的任何一台服务器中</li>
<li>数据库读写分离，对数据库读的需求远大于写的需求，应用服务器在写数据的时候，访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库</li>
<li>使用反向代理和CDN加速网站响应，CDN解决不同的地区其访问性能有较大差异的情况，反向代理是应用在应用服务器的一种缓存手段</li>
<li>使用分布式文件系统和分布式数据库系统，分布式数据库是网站数据库拆分的最后手段</li>
<li>使用 NOSQL和搜索引擎，提供对可伸缩性的更好支持</li>
<li>业务拆分</li>
<li>分布式服务</li>
</ul>
<p>架构模式中讲了9种解决大型网站一系列问题的解决方案：</p>
<ul>
<li>分层，将系统在横向维度上切分成几个部分，使得每一个部门负责的职能比较单一</li>
<li>分割，在纵向方面对软件进行切分，将不同的功能和服务分割开来,包装成高内聚低耦合的模块单元</li>
<li>分布式，将分层和分割后的模块独立部署，达到处理更大的并发访问</li>
<li>集群，多台服务器部署相同应用构成一个集群,通过负载均衡设备共同对外提供服务</li>
<li>缓存，将数据存放在距离计算最近的位置以加快处理速度</li>
<li>异步，业务之间的消息传递不是同步调用,而是将一个业务操作分成多个阶段,每个阶段之间通过共享数据的方式异步执行进行协作</li>
<li>冗余，为网站的高可用性提供保障</li>
<li>自动化，在无人值守的情况下网站可以正常运行,一切都可以自动化是网站的理想状态</li>
<li>安全，互联网的开放特性使得其从诞生起就面对巨大的安全挑战</li>
</ul>
<p>核心架构要素中讲了5个核心架构要素：</p>
<ol>
<li>性能，访问的响应时间、TPS、系统性能计数器决定</li>
<li>可用性，高可用设计的目标就是当服务器宕机的时候,服务或者应用依然可用</li>
<li>伸缩性，通过不断向集群中加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的数据存储需求</li>
<li>扩展性，使网站能够快速响应需求变化，网站可伸缩架构的主要手段是事件驱动架构和分布式服务</li>
<li>安全性，保护网站不受恶意访问和攻击,保护网站的重要数据不被窃取</li>
</ol>
<h2 id="导图"><a href="#导图" class="headerlink" title="导图"></a>导图</h2><p>后面的内容比较多，我就整理成思维导图的形式吧</p>
<p><img src="http://data3.liuin.cn/2018-06-17-15292395484469.jpg" alt=""></p>
<p>展开的高清大图可以看<a href="https://data2.liuin.cn/2018-060-18-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84.svg" target="_blank" rel="external">这里</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近用了三天的时间把《大型网站技术架构》看完了，收获颇多。这本书主要讲了一个网站从小到大发展过程在技术架构上的需要注意的地方，这里简短地记录一下我的收获吧。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis源码剖析——事件</title>
    <link href="https://www.liuin.cn/2018/06/16/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6/"/>
    <id>https://www.liuin.cn/2018/06/16/Redis源码剖析——事件/</id>
    <published>2018-06-16T02:10:22.000Z</published>
    <updated>2018-06-17T06:45:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>对RDB处理事件的的过程实现进行分析</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis服务器是一个事件驱动程序,服务器需要处理以下两类事件</p>
<ul>
<li>文件事件( file event): Redis服务器通过套接字与客户端(或者其他 Redis服务器)进行连接,而文件事件就是服务器对套接字操作的抽象。服务器与客户端(或者其他服务器)的通信会产生相应的文件事件,而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li>
<li>时间事件( time event): Redis服务器中的一些操作需要在给定的时间点执行,而时间事件就是服务器对这类定时操作的抽象</li>
</ul>
<h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>Redis基于Reactor模式开发了自己的网络事件处理器:这个处理器被称为文件事件处理器( fle event handler)</p>
<ul>
<li>文件事件处理器使用I/o多路复用( multiplexing)程序来<strong>同时监听多个套接字</strong>,并根据套接字目前执行的任务来为套接字关联不同的事件处理器</li>
<li>当被监听的套接字准备好执行连接应答( accept)、读取(read)、写人( wrte)关闭( close)等操作时,与操作相对应的文件事件就会产生,这时<strong>文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件</strong>。</li>
</ul>
<p>虽然文件事件处理器以单线程方式运行,但通过使用I/O多路复用程序来监听多个套接字,文件事件处理器既实现了<strong>高性能的网络通信模型</strong>,又可以很好地与 Redis服务器中其他同样以单线程方式运行的模块进行对接,这保持了 Redis内部单线程设计的简单性。</p>
<p><img src="http://data3.liuin.cn/2018-06-17-15292019497333.jpg" alt=""></p>
<h3 id="事件结构定义"><a href="#事件结构定义" class="headerlink" title="事件结构定义"></a>事件结构定义</h3><p>在Redis中事件结构体的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeFileEvent &#123;</div><div class="line">    <span class="keyword">int</span> mask;   <span class="comment">// 读or写标记</span></div><div class="line">    aeFileProc *rfileProc;  <span class="comment">// 读处理函数</span></div><div class="line">    aeFileProc *wfileProc;  <span class="comment">// 写处理函数</span></div><div class="line">    <span class="keyword">void</span> *clientData;  <span class="comment">// 私有数据</span></div><div class="line">&#125; aeFileEvent;</div></pre></td></tr></table></figure></p>
<h3 id="事件的创建和删除"><a href="#事件的创建和删除" class="headerlink" title="事件的创建和删除"></a>事件的创建和删除</h3><p>针对事件的创建和删除的API有：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建文件事件</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask,</span></span></div><div class="line">        aeFileProc *proc, <span class="keyword">void</span> *clientData);</div><div class="line"><span class="comment">// 删除文件事件</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeDeleteFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span></span>;</div><div class="line"><span class="comment">// 根据文件描述符获取文件事件</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeGetFileEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这些接口的实现都比较简单，就是在<code>eventLoop</code>这个事件池中创建（删除）指定属性的事件</p>
<p>需要使用到事件的创建的地方有两个：</p>
<ul>
<li>一个是在初始化服务器的时候，需要添加一个对应套接字描述符的监听套接字来监听新的客户端连接</li>
<li>新的客户端连接的时候，需要添加一个文件事件来监听这个客户端的请求</li>
</ul>
<h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p>在Linux/Unix中实现I/O多路复用的方法有非常多，大致有select、 epoll、 export和 kqueue这些IO多路复用函数库来实现的</p>
<p>各种实现的性能也是不一样的，之前我写了一篇博客<a href="/2018/04/20/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8BSelect%E3%80%81Poll%E5%92%8CEpoll/">对比了三种I/O多路复用</a></p>
<p>在Redis中，其会根据具体底层操作系统的不同自动选择系统中性能最高的I/O多路复用函数库来作为 Redis的I/O多路复用程序的底层实现（从程序中看，其性能的排行应该是evport &gt; epoll &gt; kqueue &gt; select ）:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Include the best multiplexing layer supported by this system.</span></div><div class="line"> * The following should be ordered by performances, descending. */</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EVPORT</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_evport.c"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EPOLL</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_epoll.c"</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_KQUEUE</span></div><div class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_kqueue.c"</span></span></div><div class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_select.c"</span></span></div><div class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>各种不同的I/O多路复用库的使用方式是不一样的，所以Redis对功能进行了统一的封装，方便在不同的环境下的使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建，初始化</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span></span>;</div><div class="line"><span class="comment">// 改变能够监听事件的大小值</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiResize</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> setsize)</span></span>;</div><div class="line"><span class="comment">// 清空</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aeApiFree</span><span class="params">(aeEventLoop *eventLoop)</span></span>;</div><div class="line"><span class="comment">// 添加监听事件</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span></span>;</div><div class="line"><span class="comment">// 删除监听事件</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aeApiDelEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> delmask)</span></span>;</div><div class="line"><span class="comment">// 取出已经就绪的文件描述符</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">struct</span> timeval *tvp)</span></span></div></pre></td></tr></table></figure>
<p>下面以我比较熟悉的epoll为例查看封装的实现：</p>
<p>首先定义一个ae状态结构体，事实上就是epoll的文件描述符和一个获取监听事件中就绪文件描述符的文件表<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeApiState &#123;</div><div class="line">    <span class="keyword">int</span> epfd;</div><div class="line">    <span class="keyword">struct</span> epoll_event *events;</div><div class="line">&#125; aeApiState;</div></pre></td></tr></table></figure></p>
<p>创建的过程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</div><div class="line">    aeApiState *state = zmalloc(<span class="keyword">sizeof</span>(aeApiState));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!state) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="comment">// 监听指定大小的事件数量</span></div><div class="line">    state-&gt;events = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event)*eventLoop-&gt;setsize);</div><div class="line">    <span class="keyword">if</span> (!state-&gt;events) &#123;</div><div class="line">        zfree(state);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 创建epoll</span></div><div class="line">    state-&gt;epfd = epoll_create(<span class="number">1024</span>); <span class="comment">/* 1024 is just a hint for the kernel */</span></div><div class="line">    <span class="keyword">if</span> (state-&gt;epfd == <span class="number">-1</span>) &#123;</div><div class="line">        zfree(state-&gt;events);</div><div class="line">        zfree(state);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 指定数据</span></div><div class="line">    eventLoop-&gt;apidata = state;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>添加监听事件过程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span> </span>&#123;</div><div class="line">    aeApiState *state = eventLoop-&gt;apidata;</div><div class="line">    <span class="keyword">struct</span> epoll_event ee;</div><div class="line">    <span class="comment">/* If the fd was already monitored for some event, we need a MOD</span></div><div class="line">     * operation. Otherwise we need an ADD operation. */</div><div class="line">    <span class="keyword">int</span> op = eventLoop-&gt;events[fd].mask == AE_NONE ?</div><div class="line">            EPOLL_CTL_ADD : EPOLL_CTL_MOD;</div><div class="line"></div><div class="line">    ee.events = <span class="number">0</span>;</div><div class="line">    mask |= eventLoop-&gt;events[fd].mask; <span class="comment">/* Merge old events */</span></div><div class="line">    <span class="comment">// 根据时间的mask来决定监听读or写就绪</span></div><div class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;</div><div class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</div><div class="line">    ee.data.u64 = <span class="number">0</span>; <span class="comment">/* avoid valgrind warning */</span></div><div class="line">    ee.data.fd = fd;</div><div class="line">    <span class="comment">// 添加监听事件到内核中</span></div><div class="line">    <span class="keyword">if</span> (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="文件事件的处理"><a href="#文件事件的处理" class="headerlink" title="文件事件的处理"></a>文件事件的处理</h3><p>I/O多路复用接收到了就绪的事件的时候，就需要对事件进行处理，通过文件事件分派器来分派给不同的文件事件处理器，具体需要处理的文件事件类型如下：</p>
<ul>
<li>为了对连接服务器的各个客户端进行应答,服务器要为监听套接字关联连接应答处理器。</li>
<li>为了接收客户端传来的命令请求,服务器要为客户端套接字关联命令请求处理器。</li>
<li>为了向客户端返回命令的执行结果,服务器要为客户端套接字关联命令回复处理器。</li>
<li>当主服务器和从服务器进行复制操作时,主从服务器都需要关联特别为复制功能编写的复制处理器。</li>
</ul>
<p>值得注意的是连接应答处理时，需要新添加一个监听事件</p>
<blockquote>
<p>连接应答处理</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptTcpHandler</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> cport, cfd, max = MAX_ACCEPTS_PER_CALL;</div><div class="line">    <span class="keyword">char</span> cip[REDIS_IP_STR_LEN];</div><div class="line">    REDIS_NOTUSED(el);</div><div class="line">    REDIS_NOTUSED(mask);</div><div class="line">    REDIS_NOTUSED(privdata);</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(max--) &#123;</div><div class="line">        <span class="comment">// accept 客户端连接</span></div><div class="line">        cfd = anetTcpAccept(server.neterr, fd, cip, <span class="keyword">sizeof</span>(cip), &amp;cport);</div><div class="line">        <span class="keyword">if</span> (cfd == ANET_ERR) &#123;</div><div class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK)</div><div class="line">                redisLog(REDIS_WARNING,</div><div class="line">                    <span class="string">"Accepting client connection: %s"</span>, server.neterr);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        redisLog(REDIS_VERBOSE,<span class="string">"Accepted %s:%d"</span>, cip, cport);</div><div class="line">        <span class="comment">// 为客户端创建客户端状态（redisClient）</span></div><div class="line">        acceptCommonHandler(cfd,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过Redis对上面几种事件的应答处理，我们可以得出客户端和服务端的通信模型如下：</p>
<p><img src="http://data3.liuin.cn/2018-06-17-15292047392028.jpg" alt=""></p>
<h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>Redis的时间事件分为以下两类:</p>
<ul>
<li>定时事件:让一段程序在指定的时间之后执行一次。比如说,让程序X在当前时间的30毫秒之后执行一次。</li>
<li>周期性事件:让一段程序每隔指定时间就执行一次。比如说,让程序Y每隔30毫秒就执行一次。</li>
</ul>
<h3 id="事件结构定义-1"><a href="#事件结构定义-1" class="headerlink" title="事件结构定义"></a>事件结构定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeTimeEvent &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 时间事件的唯一标识符</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id; <span class="comment">/* time event identifier. */</span></div><div class="line">    <span class="comment">// 事件的到达时间</span></div><div class="line">    <span class="keyword">long</span> when_sec; <span class="comment">/* seconds */</span></div><div class="line">    <span class="keyword">long</span> when_ms; <span class="comment">/* milliseconds */</span></div><div class="line">    <span class="comment">// 事件处理函数</span></div><div class="line">    aeTimeProc *timeProc;</div><div class="line">    <span class="comment">// 事件释放函数</span></div><div class="line">    aeEventFinalizerProc *finalizerProc;</div><div class="line">    <span class="comment">// 多路复用库的私有数据</span></div><div class="line">    <span class="keyword">void</span> *clientData;</div><div class="line">    <span class="comment">// 指向下个时间事件结构，形成链表</span></div><div class="line">    <span class="keyword">struct</span> aeTimeEvent *next;</div><div class="line"></div><div class="line">&#125; aeTimeEvent;</div></pre></td></tr></table></figure>
<p>服务器将所有时间事件都放在一个无序链表中,每当时间事件执行器运行时,它就遍历整个链表,查找所有已到达的时间事件,并调用相应的事件处理器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 已就绪事件</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeFiredEvent &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 已就绪文件描述符</span></div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line"></div><div class="line">    <span class="comment">// 事件类型掩码，</span></div><div class="line">    <span class="comment">// 值可以是 AE_READABLE 或 AE_WRITABLE</span></div><div class="line">    <span class="comment">// 或者是两者的或</span></div><div class="line">    <span class="keyword">int</span> mask;</div><div class="line"></div><div class="line">&#125; aeFiredEvent;</div></pre></td></tr></table></figure>
<h3 id="时间事件相关API"><a href="#时间事件相关API" class="headerlink" title="时间事件相关API"></a>时间事件相关API</h3><p>时间事件相关API如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建时间事件</span></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">aeCreateTimeEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> milliseconds,</span></span></div><div class="line">        aeTimeProc *proc, <span class="keyword">void</span> *clientData,</div><div class="line">        aeEventFinalizerProc *finalizerProc);</div><div class="line"><span class="comment">// 删除时间事件</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeDeleteTimeEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id)</span></span>;</div><div class="line"><span class="comment">// 时间事件的执行器</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span>;</div><div class="line"><span class="comment">// 返回最近的时间事件</span></div><div class="line"><span class="function"><span class="keyword">static</span> aeTimeEvent *<span class="title">aeSearchNearestTimer</span><span class="params">(aeEventLoop *eventLoop)</span></span>;</div></pre></td></tr></table></figure>
<p>创建和删除时间事件的实现都比较简单，相当于构造和析构函数，我们先看看时间事件执行器的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">processTimeEvents</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>;</div><div class="line">    aeTimeEvent *te;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxId;</div><div class="line">    <span class="keyword">time_t</span> now = time(<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 通过重置事件的运行时间，</span></div><div class="line">    <span class="comment">// 防止因时间穿插（skew）而造成的事件处理混乱</span></div><div class="line">    <span class="keyword">if</span> (now &lt; eventLoop-&gt;lastTime) &#123;</div><div class="line">        te = eventLoop-&gt;timeEventHead;</div><div class="line">        <span class="keyword">while</span>(te) &#123;</div><div class="line">            te-&gt;when_sec = <span class="number">0</span>;</div><div class="line">            te = te-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 更新最后一次处理时间事件的时间</span></div><div class="line">    eventLoop-&gt;lastTime = now;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历链表</span></div><div class="line">    <span class="comment">// 执行那些已经到达的事件</span></div><div class="line">    te = eventLoop-&gt;timeEventHead;</div><div class="line">    maxId = eventLoop-&gt;timeEventNextId<span class="number">-1</span>;</div><div class="line">    <span class="keyword">while</span>(te) &#123;</div><div class="line">        <span class="keyword">long</span> now_sec, now_ms;</div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> id;</div><div class="line"></div><div class="line">        <span class="comment">// 跳过无效事件</span></div><div class="line">        <span class="keyword">if</span> (te-&gt;id &gt; maxId) &#123;</div><div class="line">            te = te-&gt;next;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 获取当前时间</span></div><div class="line">        aeGetTime(&amp;now_sec, &amp;now_ms);</div><div class="line"></div><div class="line">        <span class="comment">// 如果当前时间等于或等于事件的执行时间，那么说明事件已到达，执行这个事件</span></div><div class="line">        <span class="keyword">if</span> (now_sec &gt; te-&gt;when_sec ||</div><div class="line">            (now_sec == te-&gt;when_sec &amp;&amp; now_ms &gt;= te-&gt;when_ms))</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> retval;</div><div class="line"></div><div class="line">            id = te-&gt;id;</div><div class="line">            <span class="comment">// 执行事件处理器，并获取返回值</span></div><div class="line">            retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);</div><div class="line">            processed++;</div><div class="line"></div><div class="line">            <span class="comment">// 记录是否有需要循环执行这个事件时间</span></div><div class="line">            <span class="keyword">if</span> (retval != AE_NOMORE) &#123;</div><div class="line">                <span class="comment">// 是的， retval 毫秒之后继续执行这个时间事件</span></div><div class="line">                aeAddMillisecondsToNow(retval,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 不，将这个事件删除</span></div><div class="line">                aeDeleteTimeEvent(eventLoop, id);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 因为执行事件之后，事件列表可能已经被改变了</span></div><div class="line">            <span class="comment">// 因此需要将 te 放回表头，继续开始执行事件</span></div><div class="line">            te = eventLoop-&gt;timeEventHead;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            te = te-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> processed;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其总体的思想是：遍历所有已到达的时间事件并调用这些事件的处理器。已到达指的是,时间事件的when属性记录的UNIX时间截等于或小于当前时间的UNIX时间戳。</p>
<p><code>aeSearchNearestTimer</code>返回目前时间最近的时间事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 寻找里目前时间最近的时间事件</span></div><div class="line"><span class="comment">// 因为链表是乱序的，所以查找复杂度为 O（N）</span></div><div class="line"><span class="function"><span class="keyword">static</span> aeTimeEvent *<span class="title">aeSearchNearestTimer</span><span class="params">(aeEventLoop *eventLoop)</span></span></div><div class="line">&#123;</div><div class="line">    aeTimeEvent *te = eventLoop-&gt;timeEventHead;</div><div class="line">    aeTimeEvent *nearest = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(te) &#123;</div><div class="line">        <span class="keyword">if</span> (!nearest || te-&gt;when_sec &lt; nearest-&gt;when_sec ||</div><div class="line">                (te-&gt;when_sec == nearest-&gt;when_sec &amp;&amp;</div><div class="line">                 te-&gt;when_ms &lt; nearest-&gt;when_ms))</div><div class="line">            nearest = te;</div><div class="line">        te = te-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> nearest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="时间事件的处理"><a href="#时间事件的处理" class="headerlink" title="时间事件的处理"></a>时间事件的处理</h3><p>时间事件的主要处理应用在<code>serverCron</code>中，其函数的主要工作有：</p>
<ul>
<li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用等</li>
<li>清理数据库中的过期键值对</li>
<li>关闭和清理连接失效的客户端</li>
<li>尝试进行AOF和RDB持久化操作</li>
<li>如果是主服务器，就对从服务器进行定期同步</li>
<li>如果是集群模式，对集群进行定期同步和连接测试</li>
</ul>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>时间事件和文件事件都在一个事件循环结构体中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeEventLoop &#123;</div><div class="line">    <span class="comment">// 目前已注册的最大描述符</span></div><div class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">/* highest file descriptor currently registered */</span></div><div class="line">    <span class="comment">// 目前已追踪的最大描述符</span></div><div class="line">    <span class="keyword">int</span> setsize; <span class="comment">/* max number of file descriptors tracked */</span></div><div class="line">    <span class="comment">// 用于生成时间事件 id</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId;</div><div class="line">    <span class="comment">// 最后一次执行时间事件的时间</span></div><div class="line">    <span class="keyword">time_t</span> lastTime;     <span class="comment">/* Used to detect system clock skew */</span></div><div class="line">    <span class="comment">// 已注册的文件事件</span></div><div class="line">    aeFileEvent *events; <span class="comment">/* Registered events */</span></div><div class="line">    <span class="comment">// 已就绪的文件事件</span></div><div class="line">    aeFiredEvent *fired; <span class="comment">/* Fired events */</span></div><div class="line">    <span class="comment">// 时间事件</span></div><div class="line">    aeTimeEvent *timeEventHead;</div><div class="line">    <span class="comment">// 事件处理器的开关</span></div><div class="line">    <span class="keyword">int</span> stop;</div><div class="line">    <span class="comment">// 多路复用库的私有数据</span></div><div class="line">    <span class="keyword">void</span> *apidata; <span class="comment">/* This is used for polling API specific data */</span></div><div class="line">    <span class="comment">// 在处理事件前要执行的函数</span></div><div class="line">    aeBeforeSleepProc *beforesleep;</div><div class="line"></div><div class="line">&#125; aeEventLoop;</div></pre></td></tr></table></figure>
<p>在加入事件到进行处理事件中间的环节就是事件循环了，其调用的是<code>aeMain</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</div><div class="line"></div><div class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 如果有需要在事件处理前执行的函数，那么运行它</span></div><div class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</div><div class="line">            eventLoop-&gt;beforesleep(eventLoop);</div><div class="line"></div><div class="line">        <span class="comment">// 开始处理事件</span></div><div class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，当服务器开始运行的时候，事件循环就不停运行，其事件处理函数<code>aeProcessEvents</code>实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</div><div class="line"></div><div class="line">    <span class="comment">/* Nothing to do? return ASAP */</span></div><div class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</div><div class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">struct</span> timeval tv, *tvp;</div><div class="line"></div><div class="line">        <span class="comment">// 获取最近的时间事件</span></div><div class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</div><div class="line">            shortest = aeSearchNearestTimer(eventLoop);</div><div class="line">        <span class="keyword">if</span> (shortest) &#123;</div><div class="line">            <span class="comment">// 如果时间事件存在的话</span></div><div class="line">            <span class="comment">// 那么根据最近可执行时间事件和现在时间的时间差来决定文件事件的阻塞时间</span></div><div class="line">            <span class="keyword">long</span> now_sec, now_ms;</div><div class="line"></div><div class="line">            <span class="comment">// 计算距今最近的时间事件还要多久才能达到</span></div><div class="line">            <span class="comment">// 并将该时间距保存在 tv 结构中</span></div><div class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</div><div class="line">            tvp = &amp;tv;</div><div class="line">            tvp-&gt;tv_sec = shortest-&gt;when_sec - now_sec;</div><div class="line">            <span class="keyword">if</span> (shortest-&gt;when_ms &lt; now_ms) &#123;</div><div class="line">                tvp-&gt;tv_usec = ((shortest-&gt;when_ms+<span class="number">1000</span>) - now_ms)*<span class="number">1000</span>;</div><div class="line">                tvp-&gt;tv_sec --;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                tvp-&gt;tv_usec = (shortest-&gt;when_ms - now_ms)*<span class="number">1000</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 时间差小于 0 ，说明事件已经可以执行了，将秒和毫秒设为 0 （不阻塞）</span></div><div class="line">            <span class="keyword">if</span> (tvp-&gt;tv_sec &lt; <span class="number">0</span>) tvp-&gt;tv_sec = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (tvp-&gt;tv_usec &lt; <span class="number">0</span>) tvp-&gt;tv_usec = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            </div><div class="line">            <span class="comment">// 执行到这一步，说明没有时间事件</span></div><div class="line">            <span class="comment">// 那么根据 AE_DONT_WAIT 是否设置来决定是否阻塞，以及阻塞的时间长度</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</div><div class="line">                <span class="comment">// 设置文件事件不阻塞</span></div><div class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</div><div class="line">                tvp = &amp;tv;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">/* Otherwise we can block */</span></div><div class="line">                <span class="comment">// 文件事件可以阻塞直到有事件到达为止</span></div><div class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 处理文件事件，阻塞时间由 tvp 决定</span></div><div class="line">        numevents = aeApiPoll(eventLoop, tvp);</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</div><div class="line">            <span class="comment">// 从已就绪数组中获取事件</span></div><div class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</div><div class="line"></div><div class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</div><div class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</div><div class="line">            <span class="keyword">int</span> rfired = <span class="number">0</span>;</div><div class="line"></div><div class="line">            <span class="comment">// 读事件</span></div><div class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</div><div class="line">                <span class="comment">// rfired 确保读/写事件只能执行其中一个</span></div><div class="line">                rfired = <span class="number">1</span>;</div><div class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 写事件</span></div><div class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</div><div class="line">                <span class="keyword">if</span> (!rfired || fe-&gt;wfileProc != fe-&gt;rfileProc)</div><div class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            processed++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Check time events */</span></div><div class="line">    <span class="comment">// 执行时间事件</span></div><div class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</div><div class="line">        processed += processTimeEvents(eventLoop);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其主题的逻辑如下：</p>
<ul>
<li>查找最早的时间事件，判断是否需要执行，如需要，就标记下来，等待处理，并确定后面处理文件事件的阻塞时间</li>
<li>获取已准备好的文件事件描述符集</li>
<li>优先处理读事件</li>
<li>处理写事件</li>
<li>如有时间事件，就处理时间事件</li>
</ul>
<p><img src="http://data3.liuin.cn/2018-06-17-15292178140041.jpg" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过对Redis的时间事件和文件事件的解析，能够了解Redis客户端和服务端交互的基本过程，同时也能够了解到Redis是单线程的，整个事件循环是串行的</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对RDB处理事件的的过程实现进行分析&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="https://www.liuin.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析——AOF持久化</title>
    <link href="https://www.liuin.cn/2018/06/10/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94AOF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://www.liuin.cn/2018/06/10/Redis源码剖析——AOF持久化/</id>
    <published>2018-06-10T00:35:53.000Z</published>
    <updated>2018-06-12T14:52:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>对RDB持久化的实现过程进行剖析</p>
<a id="more"></a>
<p>前面讲了RDB持久化的实现，其主要保存的是数据库中的键值对。除了RDB持久化功能之外, Redis还提供了AOF(Append Only File)持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同,AOF持久化是通过<strong>保存Redis服务器所执行的写命令</strong>来记录数据库状态的。</p>
<p><img src="http://data3.liuin.cn/2018-06-12-15287641912469.jpg" alt=""></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="服务器中的缓冲区"><a href="#服务器中的缓冲区" class="headerlink" title="服务器中的缓冲区"></a>服务器中的缓冲区</h3><p>在Redis中服务器状态结构体<code>redisServer</code>中有一个字段是<code>aof_buf</code>的缓冲区，当服务器执行完一条命令以后会以协议格式将被执行的写命令追加到服务器状态的<code>aof_buf</code>缓冲区的末尾:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> redisServer &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// AOF 状态（开启/关闭/可写）</span></div><div class="line">    <span class="keyword">int</span> aof_state;                  <span class="comment">/* REDIS_AOF_(ON|OFF|WAIT_REWRITE) */</span></div><div class="line">    </div><div class="line">    <span class="comment">// AOF 缓冲区</span></div><div class="line">    sds aof_buf;      <span class="comment">/* AOF buffer, written before entering the event loop */</span></div><div class="line"></div><div class="line">    <span class="comment">// AOF 文件的描述符</span></div><div class="line">    <span class="keyword">int</span> aof_fd;       <span class="comment">/* File descriptor of currently selected AOF file */</span></div><div class="line"></div><div class="line">    <span class="comment">// AOF 的当前目标数据库</span></div><div class="line">    <span class="keyword">int</span> aof_selected_db; <span class="comment">/* Currently selected DB in AOF */</span></div><div class="line">    ...</div></pre></td></tr></table></figure>
<h3 id="AOF文件的写入与同步"><a href="#AOF文件的写入与同步" class="headerlink" title="AOF文件的写入与同步"></a>AOF文件的写入与同步</h3><p>Redis的服务器进程就是一个事件循环(loop),这个循环中的文件事件负责接收客户端的命令请求,以及向客户端发送命令回复,而时间事件则负责执行像server_cron函数这样需要定时运行的函数。</p>
<p>因为服务器在处理文件事件时可能会执行写命令,使得一些内容被追加到 aof_buf缓冲区里面,所以在服务器每次结束一个事件循环之前,它都会调用<code>flushAppendOnlyFile</code>函数,考虑是否需要将 aof_buf缓冲区中的内容写人和保存到AOF文件里面</p>
<p>flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值来决定,各个不同值产生的行为</p>
<p><img src="http://data3.liuin.cn/2018-06-12-15287653307562.jpg" alt=""></p>
<p>命令写入实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedAppendOnlyFile</span><span class="params">(<span class="keyword">struct</span> redisCommand *cmd, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span> </span>&#123;</div><div class="line">    sds buf = sdsempty();</div><div class="line">    robj *tmpargv[<span class="number">3</span>];</div><div class="line"></div><div class="line">    <span class="comment">/* The DB this command was targeting is not the same as the last command</span></div><div class="line">     * we appendend. To issue a SELECT command is needed. </div><div class="line">     *</div><div class="line">     * 使用 SELECT 命令，显式设置数据库，确保之后的命令被设置到正确的数据库</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (dictid != server.aof_selected_db) &#123;</div><div class="line">        <span class="keyword">char</span> seldb[<span class="number">64</span>];</div><div class="line"></div><div class="line">        <span class="built_in">snprintf</span>(seldb,<span class="keyword">sizeof</span>(seldb),<span class="string">"%d"</span>,dictid);</div><div class="line">        buf = sdscatprintf(buf,<span class="string">"*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n"</span>,</div><div class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="built_in">strlen</span>(seldb),seldb);</div><div class="line"></div><div class="line">        server.aof_selected_db = dictid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="comment">// 省略其他命令的加入buff过程</span></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">/* Append to the AOF buffer. This will be flushed on disk just before</span></div><div class="line">     * of re-entering the event loop, so before the client will get a</div><div class="line">     * positive reply about the operation performed. </div><div class="line">     *</div><div class="line">     * 将命令追加到 AOF 缓存中，</div><div class="line">     * 在重新进入事件循环之前，这些命令会被冲洗到磁盘上，</div><div class="line">     * 并向客户端返回一个回复。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (server.aof_state == REDIS_AOF_ON)</div><div class="line">        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));</div><div class="line"></div><div class="line">    <span class="comment">/* If a background append only file rewriting is in progress we want to</span></div><div class="line">     * accumulate the differences between the child DB and the current one</div><div class="line">     * in a buffer, so that when the child process will do its work we</div><div class="line">     * can append the differences to the new append only file. </div><div class="line">     *</div><div class="line">     * 如果 BGREWRITEAOF 正在进行，</div><div class="line">     * 那么我们还需要将命令追加到重写缓存中，</div><div class="line">     * 从而记录当前正在重写的 AOF 文件和数据库当前状态的差异。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>)</div><div class="line">        aofRewriteBufferAppend((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf,sdslen(buf));</div><div class="line"></div><div class="line">    <span class="comment">// 释放</span></div><div class="line">    sdsfree(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>缓冲区人间写入AOF实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushAppendOnlyFile</span><span class="params">(<span class="keyword">int</span> force)</span> </span>&#123;</div><div class="line">    <span class="keyword">ssize_t</span> nwritten;</div><div class="line">    <span class="keyword">int</span> sync_in_progress = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 缓冲区中没有任何内容，直接返回</span></div><div class="line">    <span class="keyword">if</span> (sdslen(server.aof_buf) == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 策略为每秒 FSYNC </span></div><div class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC)</div><div class="line">        <span class="comment">// 是否有 SYNC 正在后台进行？</span></div><div class="line">        sync_in_progress = bioPendingJobsOfType(REDIS_BIO_AOF_FSYNC) != <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 每秒 fsync ，并且强制写入为假</span></div><div class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp; !force) &#123;</div><div class="line"></div><div class="line">        <span class="comment">/* With this append fsync policy we do background fsyncing.</span></div><div class="line">         *</div><div class="line">         * 当 fsync 策略为每秒钟一次时， fsync 在后台执行。</div><div class="line">         *</div><div class="line">         * If the fsync is still in progress we can try to delay</div><div class="line">         * the write for a couple of seconds. </div><div class="line">         *</div><div class="line">         * 如果后台仍在执行 FSYNC ，那么我们可以延迟写操作一两秒</div><div class="line">         * （如果强制执行 write 的话，服务器主线程将阻塞在 write 上面）</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (sync_in_progress) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 有 fsync 正在后台进行 。。。</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (server.aof_flush_postponed_start == <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">/* No previous write postponinig, remember that we are</span></div><div class="line">                 * postponing the flush and return. </div><div class="line">                 *</div><div class="line">                 * 前面没有推迟过 write 操作，这里将推迟写操作的时间记录下来</div><div class="line">                 * 然后就返回，不执行 write 或者 fsync</div><div class="line">                 */</div><div class="line">                server.aof_flush_postponed_start = server.unixtime;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.unixtime - server.aof_flush_postponed_start &lt; <span class="number">2</span>) &#123;</div><div class="line">                <span class="comment">/* We were already waiting for fsync to finish, but for less</span></div><div class="line">                 * than two seconds this is still ok. Postpone again. </div><div class="line">                 *</div><div class="line">                 * 如果之前已经因为 fsync 而推迟了 write 操作</div><div class="line">                 * 但是推迟的时间不超过 2 秒，那么直接返回</div><div class="line">                 * 不执行 write 或者 fsync</div><div class="line">                 */</div><div class="line">                <span class="keyword">return</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">/* Otherwise fall trough, and go write since we can't wait</span></div><div class="line">             * over two seconds. </div><div class="line">             *</div><div class="line">             * 如果后台还有 fsync 在执行，并且 write 已经推迟 &gt;= 2 秒</div><div class="line">             * 那么执行写操作（write 将被阻塞）</div><div class="line">             */</div><div class="line">            server.aof_delayed_fsync++;</div><div class="line">            redisLog(REDIS_NOTICE,<span class="string">"Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* If you are following this code path, then we are going to write so</span></div><div class="line">     * set reset the postponed flush sentinel to zero. </div><div class="line">     *</div><div class="line">     * 执行到这里，程序会对 AOF 文件进行写入。</div><div class="line">     *</div><div class="line">     * 清零延迟 write 的时间记录</div><div class="line">     */</div><div class="line">    server.aof_flush_postponed_start = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* We want to perform a single write. This should be guaranteed atomic</span></div><div class="line">     * at least if the filesystem we are writing is a real physical one.</div><div class="line">     *</div><div class="line">     * 执行单个 write 操作，如果写入设备是物理的话，那么这个操作应该是原子的</div><div class="line">     *</div><div class="line">     * While this will save us against the server being killed I don't think</div><div class="line">     * there is much to do about the whole server stopping for power problems</div><div class="line">     * or alike </div><div class="line">     *</div><div class="line">     * 当然，如果出现像电源中断这样的不可抗现象，那么 AOF 文件也是可能会出现问题的</div><div class="line">     * 这时就要用 redis-check-aof 程序来进行修复。</div><div class="line">     */</div><div class="line">    nwritten = write(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));</div><div class="line">    <span class="keyword">if</span> (nwritten != (<span class="keyword">signed</span>)sdslen(server.aof_buf)) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">static</span> <span class="keyword">time_t</span> last_write_error_log = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> can_log = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* Limit logging rate to 1 line per AOF_WRITE_LOG_ERROR_RATE seconds. */</span></div><div class="line">        <span class="comment">// 将日志的记录频率限制在每行 AOF_WRITE_LOG_ERROR_RATE 秒</span></div><div class="line">        <span class="keyword">if</span> ((server.unixtime - last_write_error_log) &gt; AOF_WRITE_LOG_ERROR_RATE) &#123;</div><div class="line">            can_log = <span class="number">1</span>;</div><div class="line">            last_write_error_log = server.unixtime;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Lof the AOF write error and record the error code. */</span></div><div class="line">        <span class="comment">// 如果写入出错，那么尝试将该情况写入到日志里面</span></div><div class="line">        <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (can_log) &#123;</div><div class="line">                redisLog(REDIS_WARNING,<span class="string">"Error writing to the AOF file: %s"</span>,</div><div class="line">                    strerror(errno));</div><div class="line">                server.aof_last_write_errno = errno;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (can_log) &#123;</div><div class="line">                redisLog(REDIS_WARNING,<span class="string">"Short write while writing to "</span></div><div class="line">                                       <span class="string">"the AOF file: (nwritten=%lld, "</span></div><div class="line">                                       <span class="string">"expected=%lld)"</span>,</div><div class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)nwritten,</div><div class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)sdslen(server.aof_buf));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 尝试移除新追加的不完整内容</span></div><div class="line">            <span class="keyword">if</span> (ftruncate(server.aof_fd, server.aof_current_size) == <span class="number">-1</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (can_log) &#123;</div><div class="line">                    redisLog(REDIS_WARNING, <span class="string">"Could not remove short write "</span></div><div class="line">                             <span class="string">"from the append-only file.  Redis may refuse "</span></div><div class="line">                             <span class="string">"to load the AOF the next time it starts.  "</span></div><div class="line">                             <span class="string">"ftruncate: %s"</span>, strerror(errno));</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">/* If the ftrunacate() succeeded we can set nwritten to</span></div><div class="line">                 * -1 since there is no longer partial data into the AOF. */</div><div class="line">                nwritten = <span class="number">-1</span>;</div><div class="line">            &#125;</div><div class="line">            server.aof_last_write_errno = ENOSPC;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Handle the AOF write error. */</span></div><div class="line">        <span class="comment">// 处理写入 AOF 文件时出现的错误</span></div><div class="line">        <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</div><div class="line">            <span class="comment">/* We can't recover when the fsync policy is ALWAYS since the</span></div><div class="line">             * reply for the client is already in the output buffers, and we</div><div class="line">             * have the contract with the user that on acknowledged write data</div><div class="line">             * is synched on disk. */</div><div class="line">            redisLog(REDIS_WARNING,<span class="string">"Can't recover from AOF write error when the AOF fsync policy is 'always'. Exiting..."</span>);</div><div class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/* Recover from failed write leaving data into the buffer. However</span></div><div class="line">             * set an error to stop accepting writes as long as the error</div><div class="line">             * condition is not cleared. */</div><div class="line">            server.aof_last_write_status = REDIS_ERR;</div><div class="line"></div><div class="line">            <span class="comment">/* Trim the sds buffer if there was a partial write, and there</span></div><div class="line">             * was no way to undo it with ftruncate(2). */</div><div class="line">            <span class="keyword">if</span> (nwritten &gt; <span class="number">0</span>) &#123;</div><div class="line">                server.aof_current_size += nwritten;</div><div class="line">                sdsrange(server.aof_buf,nwritten,<span class="number">-1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>; <span class="comment">/* We'll try again on the next call... */</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* Successful write(2). If AOF was in error state, restore the</span></div><div class="line">         * OK state and log the event. */</div><div class="line">        <span class="comment">// 写入成功，更新最后写入状态</span></div><div class="line">        <span class="keyword">if</span> (server.aof_last_write_status == REDIS_ERR) &#123;</div><div class="line">            redisLog(REDIS_WARNING,</div><div class="line">                <span class="string">"AOF write error looks solved, Redis can write again."</span>);</div><div class="line">            server.aof_last_write_status = REDIS_OK;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 更新写入后的 AOF 文件大小</span></div><div class="line">    server.aof_current_size += nwritten;</div><div class="line"></div><div class="line">    <span class="comment">/* Re-use AOF buffer when it is small enough. The maximum comes from the</span></div><div class="line">     * arena size of 4k minus some overhead (but is otherwise arbitrary). </div><div class="line">     *</div><div class="line">     * 如果 AOF 缓存的大小足够小的话，那么重用这个缓存，</div><div class="line">     * 否则的话，释放 AOF 缓存。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) &lt; <span class="number">4000</span>) &#123;</div><div class="line">        <span class="comment">// 清空缓存中的内容，等待重用</span></div><div class="line">        sdsclear(server.aof_buf);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 释放缓存</span></div><div class="line">        sdsfree(server.aof_buf);</div><div class="line">        server.aof_buf = sdsempty();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Don't fsync if no-appendfsync-on-rewrite is set to yes and there are</span></div><div class="line">     * children doing I/O in the background. </div><div class="line">     *</div><div class="line">     * 如果 no-appendfsync-on-rewrite 选项为开启状态，</div><div class="line">     * 并且有 BGSAVE 或者 BGREWRITEAOF 正在进行的话，</div><div class="line">     * 那么不执行 fsync </div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (server.aof_no_fsync_on_rewrite &amp;&amp;</div><div class="line">        (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Perform the fsync if needed. */</span></div><div class="line"></div><div class="line">    <span class="comment">// 总是执行 fsnyc</span></div><div class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</div><div class="line">        <span class="comment">/* aof_fsync is defined as fdatasync() for Linux in order to avoid</span></div><div class="line">         * flushing metadata. */</div><div class="line">        aof_fsync(server.aof_fd); <span class="comment">/* Let's try to get this data on the disk */</span></div><div class="line"></div><div class="line">        <span class="comment">// 更新最后一次执行 fsnyc 的时间</span></div><div class="line">        server.aof_last_fsync = server.unixtime;</div><div class="line"></div><div class="line">    <span class="comment">// 策略为每秒 fsnyc ，并且距离上次 fsync 已经超过 1 秒</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</div><div class="line">                server.unixtime &gt; server.aof_last_fsync)) &#123;</div><div class="line">        <span class="comment">// 放到后台执行</span></div><div class="line">        <span class="keyword">if</span> (!sync_in_progress) aof_background_fsync(server.aof_fd);</div><div class="line">        <span class="comment">// 更新最后一次执行 fsync 的时间</span></div><div class="line">        server.aof_last_fsync = server.unixtime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 其实上面无论执行 if 部分还是 else 部分都要更新 fsync 的时间</span></div><div class="line">    <span class="comment">// 可以将代码挪到下面来</span></div><div class="line">    <span class="comment">// server.aof_last_fsync = server.unixtime;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于三种不同的策略其效率和安全性能是不一样的：</p>
<ul>
<li><code>always</code>因为在每一个事件循环中都需要将所有的内容写入AOF文件，所以其效率是最低的，但是其安全性是最高的</li>
<li><code>everysec</code>是一个效率和安全性的折中。从效率上来讲, everysec模式足够快,并且就算出现故障停机,数据库也只丢失一秒钟的命令数据。</li>
<li><code>no</code>的同步时间需要有操作系统控制，这样其效率比较高但是安全性就比较差了</li>
</ul>
<h2 id="文件载入和数据的还原"><a href="#文件载入和数据的还原" class="headerlink" title="文件载入和数据的还原"></a>文件载入和数据的还原</h2><p>因为AOF文件里面包含了重建数据库状态所需的所有写命令,所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令,就可以还原服务器关闭之前的数据库状态。</p>
<p><img src="http://data3.liuin.cn/2018-06-12-15287660987749.jpg" alt=""></p>
<p>其底层主要通过<code>loadAppendOnlyFile</code>这个函数实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 执行 AOF 文件中的命令。</div><div class="line"> *</div><div class="line"> * 出错时返回 REDIS_OK 。</div><div class="line"> *</div><div class="line"> * 出现非执行错误（比如文件长度为 0 ）时返回 REDIS_ERR 。</div><div class="line"> *</div><div class="line"> * 出现致命错误时打印信息到日志，并且程序退出。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 为客户端</span></div><div class="line">    <span class="keyword">struct</span> redisClient *fakeClient;</div><div class="line"></div><div class="line">    <span class="comment">// 打开 AOF 文件</span></div><div class="line">    FILE *fp = fopen(filename,<span class="string">"r"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> redis_stat sb;</div><div class="line">    <span class="keyword">int</span> old_aof_state = server.aof_state;</div><div class="line">    <span class="keyword">long</span> loops = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 检查文件的正确性</span></div><div class="line">    <span class="keyword">if</span> (fp &amp;&amp; redis_fstat(fileno(fp),&amp;sb) != <span class="number">-1</span> &amp;&amp; sb.st_size == <span class="number">0</span>) &#123;</div><div class="line">        server.aof_current_size = <span class="number">0</span>;</div><div class="line">        fclose(fp);</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 检查文件是否正常打开</span></div><div class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Fatal error: can't open the append log file for reading: %s"</span>,strerror(errno));</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 暂时性地关闭 AOF ，防止在执行 MULTI 时，</div><div class="line">     * EXEC 命令被传播到正在打开的 AOF 文件中。</div><div class="line">     */</div><div class="line">    server.aof_state = REDIS_AOF_OFF;</div><div class="line"></div><div class="line">    fakeClient = createFakeClient();</div><div class="line"></div><div class="line">    <span class="comment">// 设置服务器的状态为：正在载入</span></div><div class="line">    <span class="comment">// startLoading 定义于 rdb.c</span></div><div class="line">    startLoading(fp);</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="comment">// 省略载入过程</span></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 如果能执行到这里，说明 AOF 文件的全部内容都可以正确地读取，</div><div class="line">     * 但是，还要检查 AOF 是否包含未正确结束的事务</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (fakeClient-&gt;flags &amp; REDIS_MULTI) <span class="keyword">goto</span> readerr;</div><div class="line"></div><div class="line">    <span class="comment">// 关闭 AOF 文件</span></div><div class="line">    fclose(fp);</div><div class="line">    <span class="comment">// 释放伪客户端</span></div><div class="line">    freeFakeClient(fakeClient);</div><div class="line">    <span class="comment">// 复原 AOF 状态</span></div><div class="line">    server.aof_state = old_aof_state;</div><div class="line">    <span class="comment">// 停止载入</span></div><div class="line">    stopLoading();</div><div class="line">    <span class="comment">// 更新服务器状态中， AOF 文件的当前大小</span></div><div class="line">    aofUpdateCurrentSize();</div><div class="line">    <span class="comment">// 记录前一次重写时的大小</span></div><div class="line">    server.aof_rewrite_base_size = server.aof_current_size;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div></pre></td></tr></table></figure>
<h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>因为AOF持久化是通过保存被执行的写命令来记录数据库状态的,所以随着服务器运行时间的流逝,AOF文件中的内容会越来越多,文件的体积也会越来越大,如果不加以控制的话,体积过大的AOF文件很可能对 Redis服务器、甚至整个宿主计算机造成影响,并且AOF文件的体积越大,便用AOF文件来进行数据还原所需的时间就越多。</p>
<p>为了解决AOF文件体积膨胀的问题, Redis提供了AOF文件重写( rewrite)功能。通过该功能, Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件,新旧两个AOF文件所保存的数据库状态相同,但新AOF文件不会包含任何浪费空间的冗余命令,所以新AOF文件的体积通常会比旧AOF文件的体积要小得多。</p>
<h3 id="AOF重写实现"><a href="#AOF重写实现" class="headerlink" title="AOF重写实现"></a>AOF重写实现</h3><p>AOF重写部分的主要实现（遍历所有的键，通过命令进行插入）如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">        </div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="comment">/* Iterate this DB writing every entry </span></div><div class="line">         *</div><div class="line">         * 遍历数据库所有键，并通过命令将它们的当前状态（值）记录到新 AOF 文件中</div><div class="line">         */</div><div class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</div><div class="line">            sds keystr;</div><div class="line">            robj key, *o;</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> expiretime;</div><div class="line"></div><div class="line">            <span class="comment">// 取出键</span></div><div class="line">            keystr = dictGetKey(de);</div><div class="line"></div><div class="line">            <span class="comment">// 取出值</span></div><div class="line">            o = dictGetVal(de);</div><div class="line">            initStaticStringObject(key,keystr);</div><div class="line"></div><div class="line">            <span class="comment">// 取出过期时间</span></div><div class="line">            expiretime = getExpire(db,&amp;key);</div><div class="line"></div><div class="line">            <span class="comment">/* If this key is already expired skip it </span></div><div class="line">             *</div><div class="line">             * 如果键已经过期，那么跳过它，不保存</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (expiretime != <span class="number">-1</span> &amp;&amp; expiretime &lt; now) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">            <span class="comment">/* Save the key and associated value </span></div><div class="line">             *</div><div class="line">             * 根据值的类型，选择适当的命令来保存值</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (o-&gt;type == REDIS_STRING) &#123;</div><div class="line">                <span class="comment">/* Emit a SET command */</span></div><div class="line">                <span class="keyword">char</span> cmd[]=<span class="string">"*3\r\n$3\r\nSET\r\n"</span>;</div><div class="line">                <span class="keyword">if</span> (rioWrite(&amp;aof,cmd,<span class="keyword">sizeof</span>(cmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">                <span class="comment">/* Key and value */</span></div><div class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,&amp;key) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_LIST) &#123;</div><div class="line">                <span class="keyword">if</span> (rewriteListObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_SET) &#123;</div><div class="line">                <span class="keyword">if</span> (rewriteSetObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_ZSET) &#123;</div><div class="line">                <span class="keyword">if</span> (rewriteSortedSetObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_HASH) &#123;</div><div class="line">                <span class="keyword">if</span> (rewriteHashObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                redisPanic(<span class="string">"Unknown object type"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">/* Save the expire time </span></div><div class="line">             *</div><div class="line">             * 保存键的过期时间</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) &#123;</div><div class="line">                <span class="keyword">char</span> cmd[]=<span class="string">"*3\r\n$9\r\nPEXPIREAT\r\n"</span>;</div><div class="line"></div><div class="line">                <span class="comment">// 写入 PEXPIREAT expiretime 命令</span></div><div class="line">                <span class="keyword">if</span> (rioWrite(&amp;aof,cmd,<span class="keyword">sizeof</span>(cmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,&amp;key) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">                <span class="keyword">if</span> (rioWriteBulkLongLong(&amp;aof,expiretime) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div></pre></td></tr></table></figure>
<p>因为新的AOF文件只包含还原当前数据库所必须的命令，所以新AOF文件不会浪费任何空间。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对RDB持久化的实现过程进行剖析&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="https://www.liuin.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析——RDB持久化</title>
    <link href="https://www.liuin.cn/2018/06/05/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94RDB%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://www.liuin.cn/2018/06/05/Redis源码剖析——RDB持久化/</id>
    <published>2018-06-05T02:30:43.000Z</published>
    <updated>2018-06-08T03:10:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>对RDB实现持久化的过程进行剖析</p>
<a id="more"></a>
<h2 id="持久化概述"><a href="#持久化概述" class="headerlink" title="持久化概述"></a>持久化概述</h2><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>因为Redis数据库是基于内存的Key-Value型数据库，他的所有数据库状态都存储在内存里面，如果服务器进程退出，那么存放在内存中的所有Redis数据库的状态都将消失。为了避免这种情况发生，就需要一种将数据库状态从内存转移到磁盘中的技术。</p>
<p>持久化就是这样一种将数据库的状态从内存存储到磁盘中的技术，Redis提供两种持久化：RDB持久化和AOF持久化。</p>
<h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>Redis提供了RDB持久化功能,这个功能可以将 Redis在内存中的数据库状态保存到磁盘里面,避免数据意外丢失。RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件,通过该文件可以还原生成RDB文件时的数据库状态。</p>
<p><img src="http://data3.liuin.cn/2018-06-08-15284258851033.jpg" alt=""></p>
<h2 id="RDB命令"><a href="#RDB命令" class="headerlink" title="RDB命令"></a>RDB命令</h2><p>Redis中生成RDB文件有两个命令：SAVE和BGSAVE。</p>
<p>SAVE命令会阻塞Redis服务器进程,直到RDB文件创建完毕为止,在服务器进程阻塞期间,服务器不能处理任何命令请求；BGSAVE命令会派生出一个子进程,然后由子进程负责创建RDB文件,服务器进程(父进程)继续处理命令请求</p>
<p>由此可见BGSAVE的实现是在SAVE的基础上进行的。</p>
<p>RDB文件的载入工作是在服务器启动时自动执行的,所以Redis并没有专门用于载入RDB文件的命令,只要 Redis服务器在启动时检测到RDB文件存在,它就会自动载入RDB文件。</p>
<h3 id="生成RDB文件实现"><a href="#生成RDB文件实现" class="headerlink" title="生成RDB文件实现"></a>生成RDB文件实现</h3><p>在讲生成RDB文件前首先要讲一个Redis中对I/O进行封装的一个结构体：<code>rio</code>，这个结构体在基本I/O的基础上加了一些计算校验和，获取文件指针所在偏移量等功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> _rio &#123;</div><div class="line"></div><div class="line">    <span class="comment">/* Backend functions.</span></div><div class="line">     * Since this functions do not tolerate short writes or reads the return</div><div class="line">     * value is simplified to: zero on error, non zero on complete success. */</div><div class="line">    <span class="comment">// API</span></div><div class="line">    <span class="keyword">size_t</span> (*read)(<span class="keyword">struct</span> _rio *, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len);</div><div class="line">    <span class="keyword">size_t</span> (*write)(<span class="keyword">struct</span> _rio *, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len);</div><div class="line">    <span class="keyword">off_t</span> (*tell)(<span class="keyword">struct</span> _rio *);</div><div class="line"></div><div class="line">    <span class="comment">/* The update_cksum method if not NULL is used to compute the checksum of</span></div><div class="line">     * all the data that was read or written so far. The method should be</div><div class="line">     * designed so that can be called with the current checksum, and the buf</div><div class="line">     * and len fields pointing to the new block of data to add to the checksum</div><div class="line">     * computation. */</div><div class="line">    <span class="comment">// 校验和计算函数，每次有写入/读取新数据时都要计算一次</span></div><div class="line">    <span class="keyword">void</span> (*update_cksum)(<span class="keyword">struct</span> _rio *, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len);</div><div class="line"></div><div class="line">    <span class="comment">/* The current checksum */</span></div><div class="line">    <span class="comment">// 当前校验和</span></div><div class="line">    <span class="keyword">uint64_t</span> cksum;</div><div class="line"></div><div class="line">    <span class="comment">/* number of bytes read or written */</span></div><div class="line">    <span class="keyword">size_t</span> processed_bytes;</div><div class="line"></div><div class="line">    <span class="comment">/* maximum single read or write chunk size */</span></div><div class="line">    <span class="keyword">size_t</span> max_processing_chunk;</div><div class="line"></div><div class="line">    <span class="comment">/* Backend-specific vars. */</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">struct</span> &#123;</div><div class="line">            <span class="comment">// 缓存指针</span></div><div class="line">            sds ptr;</div><div class="line">            <span class="comment">// 偏移量</span></div><div class="line">            <span class="keyword">off_t</span> pos;</div><div class="line">        &#125; buffer;</div><div class="line"></div><div class="line">        <span class="keyword">struct</span> &#123;</div><div class="line">            <span class="comment">// 被打开文件的指针</span></div><div class="line">            FILE *fp;</div><div class="line">            <span class="comment">// 最近一次 fsync() 以来，写入的字节量</span></div><div class="line">            <span class="keyword">off_t</span> buffered; <span class="comment">/* Bytes written since last fsync. */</span></div><div class="line">            <span class="comment">// 写入多少字节之后，才会自动执行一次 fsync()</span></div><div class="line">            <span class="keyword">off_t</span> autosync; <span class="comment">/* fsync after 'autosync' bytes written. */</span></div><div class="line">        &#125; file;</div><div class="line">    &#125; io;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>SAVE的实现就是依靠<code>rio</code>的，其所有的I/O都是通过<code>rio</code>进行的。SAVE实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSave</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">    dictIterator *di = <span class="literal">NULL</span>;</div><div class="line">    dictEntry *de;</div><div class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</div><div class="line">    <span class="keyword">char</span> magic[<span class="number">10</span>];</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> now = mstime();</div><div class="line">    FILE *fp;</div><div class="line">    rio rdb;</div><div class="line">    <span class="keyword">uint64_t</span> cksum;</div><div class="line"></div><div class="line">    <span class="comment">// 创建临时文件</span></div><div class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">"temp-%d.rdb"</span>, (<span class="keyword">int</span>) getpid());</div><div class="line">    fp = fopen(tmpfile,<span class="string">"w"</span>);</div><div class="line">    <span class="keyword">if</span> (!fp) &#123;</div><div class="line">        redisLog(REDIS_WARNING, <span class="string">"Failed opening .rdb for saving: %s"</span>,</div><div class="line">            strerror(errno));</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化 I/O</span></div><div class="line">    rioInitWithFile(&amp;rdb,fp);</div><div class="line"></div><div class="line">    <span class="comment">// 设置校验和函数</span></div><div class="line">    <span class="keyword">if</span> (server.rdb_checksum)</div><div class="line">        rdb.update_cksum = rioGenericUpdateChecksum;</div><div class="line"></div><div class="line">    <span class="comment">// 写入 RDB 版本号</span></div><div class="line">    <span class="built_in">snprintf</span>(magic,<span class="keyword">sizeof</span>(magic),<span class="string">"REDIS%04d"</span>,REDIS_RDB_VERSION);</div><div class="line">    <span class="keyword">if</span> (rdbWriteRaw(&amp;rdb,magic,<span class="number">9</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历所有数据库</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 指向数据库</span></div><div class="line">        redisDb *db = server.db+j;</div><div class="line"></div><div class="line">        <span class="comment">// 指向数据库键空间</span></div><div class="line">        dict *d = db-&gt;dict;</div><div class="line"></div><div class="line">        <span class="comment">// 跳过空数据库</span></div><div class="line">        <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 创建键空间迭代器</span></div><div class="line">        di = dictGetSafeIterator(d);</div><div class="line">        <span class="keyword">if</span> (!di) &#123;</div><div class="line">            fclose(fp);</div><div class="line">            <span class="keyword">return</span> REDIS_ERR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Write the SELECT DB opcode </span></div><div class="line">         *</div><div class="line">         * 写入 DB 选择器</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (rdbSaveType(&amp;rdb,REDIS_RDB_OPCODE_SELECTDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line">        <span class="keyword">if</span> (rdbSaveLen(&amp;rdb,j) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">        <span class="comment">/* Iterate this DB writing every entry </span></div><div class="line">         *</div><div class="line">         * 遍历数据库，并写入每个键值对的数据</div><div class="line">         */</div><div class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</div><div class="line">            sds keystr = dictGetKey(de);</div><div class="line">            robj key, *o = dictGetVal(de);</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> expire;</div><div class="line">            </div><div class="line">            <span class="comment">// 根据 keystr ，在栈中创建一个 key 对象</span></div><div class="line">            initStaticStringObject(key,keystr);</div><div class="line"></div><div class="line">            <span class="comment">// 获取键的过期时间</span></div><div class="line">            expire = getExpire(db,&amp;key);</div><div class="line"></div><div class="line">            <span class="comment">// 保存键值对数据</span></div><div class="line">            <span class="keyword">if</span> (rdbSaveKeyValuePair(&amp;rdb,&amp;key,o,expire,now) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line">        &#125;</div><div class="line">        dictReleaseIterator(di);</div><div class="line">    &#125;</div><div class="line">    di = <span class="literal">NULL</span>; <span class="comment">/* So that we don't release it again on error. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* EOF opcode </span></div><div class="line">     *</div><div class="line">     * 写入 EOF 代码</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (rdbSaveType(&amp;rdb,REDIS_RDB_OPCODE_EOF) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">/* CRC64 checksum. It will be zero if checksum computation is disabled, the</span></div><div class="line">     * loading code skips the check in this case. </div><div class="line">     *</div><div class="line">     * CRC64 校验和。</div><div class="line">     *</div><div class="line">     * 如果校验和功能已关闭，那么 rdb.cksum 将为 0 ，</div><div class="line">     * 在这种情况下， RDB 载入时会跳过校验和检查。</div><div class="line">     */</div><div class="line">    cksum = rdb.cksum;</div><div class="line">    memrev64ifbe(&amp;cksum);</div><div class="line">    rioWrite(&amp;rdb,&amp;cksum,<span class="number">8</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* Make sure data will not remain on the OS's output buffers */</span></div><div class="line">    <span class="comment">// 冲洗缓存，确保数据已写入磁盘</span></div><div class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</div><div class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line">    <span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">/* Use RENAME to make sure the DB file is changed atomically only</span></div><div class="line">     * if the generate DB file is ok. </div><div class="line">     *</div><div class="line">     * 使用 RENAME ，原子性地对临时文件进行改名，覆盖原来的 RDB 文件。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Error moving temp DB file on the final destination: %s"</span>, strerror(errno));</div><div class="line">        unlink(tmpfile);</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 写入完成，打印日志</span></div><div class="line">    redisLog(REDIS_NOTICE,<span class="string">"DB saved on disk"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 清零数据库脏状态</span></div><div class="line">    server.dirty = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 记录最后一次完成 SAVE 的时间</span></div><div class="line">    server.lastsave = time(<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 记录最后一次执行 SAVE 的状态</span></div><div class="line">    server.lastbgsave_status = REDIS_OK;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line"></div><div class="line">werr:</div><div class="line">    <span class="comment">// 关闭文件</span></div><div class="line">    fclose(fp);</div><div class="line">    <span class="comment">// 删除文件</span></div><div class="line">    unlink(tmpfile);</div><div class="line"></div><div class="line">    redisLog(REDIS_WARNING,<span class="string">"Write error saving DB on disk: %s"</span>, strerror(errno));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (di) dictReleaseIterator(di);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> REDIS_ERR;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码逻辑上看，SAVE的实现还是比较简单的，首先写入一些Redis版本信息，然后将数据库中的所有数据写入文件，最后加上一个校验和。</p>
<p>BESAVE在SAVE的基础上还要实现一些新进程创建等任务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveBackground</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">    <span class="keyword">pid_t</span> childpid;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start;</div><div class="line"></div><div class="line">    <span class="comment">// 如果 BGSAVE 已经在执行，那么出错</span></div><div class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">    <span class="comment">// 记录 BGSAVE 执行前的数据库被修改次数</span></div><div class="line">    server.dirty_before_bgsave = server.dirty;</div><div class="line"></div><div class="line">    <span class="comment">// 最近一次尝试执行 BGSAVE 的时间</span></div><div class="line">    server.lastbgsave_try = time(<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// fork() 开始前的时间，记录 fork() 返回耗时用</span></div><div class="line">    start = ustime();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> retval;</div><div class="line"></div><div class="line">        <span class="comment">/* Child */</span></div><div class="line"></div><div class="line">        <span class="comment">// 关闭网络连接 fd</span></div><div class="line">        closeListeningSockets(<span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 设置进程的标题，方便识别</span></div><div class="line">        redisSetProcTitle(<span class="string">"redis-rdb-bgsave"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 执行保存操作</span></div><div class="line">        retval = rdbSave(filename);</div><div class="line"></div><div class="line">        <span class="comment">// 打印 copy-on-write 时使用的内存数</span></div><div class="line">        <span class="keyword">if</span> (retval == REDIS_OK) &#123;</div><div class="line">            <span class="keyword">size_t</span> private_dirty = zmalloc_get_private_dirty();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (private_dirty) &#123;</div><div class="line">                redisLog(REDIS_NOTICE,</div><div class="line">                    <span class="string">"RDB: %zu MB of memory used by copy-on-write"</span>,</div><div class="line">                    private_dirty/(<span class="number">1024</span>*<span class="number">1024</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 向父进程发送信号</span></div><div class="line">        exitFromChild((retval == REDIS_OK) ? <span class="number">0</span> : <span class="number">1</span>);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="comment">/* Parent */</span></div><div class="line"></div><div class="line">        <span class="comment">// 计算 fork() 执行的时间</span></div><div class="line">        server.stat_fork_time = ustime()-start;</div><div class="line"></div><div class="line">        <span class="comment">// 如果 fork() 出错，那么报告错误</span></div><div class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</div><div class="line">            server.lastbgsave_status = REDIS_ERR;</div><div class="line">            redisLog(REDIS_WARNING,<span class="string">"Can't save in background: fork: %s"</span>,</div><div class="line">                strerror(errno));</div><div class="line">            <span class="keyword">return</span> REDIS_ERR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 打印 BGSAVE 开始的日志</span></div><div class="line">        redisLog(REDIS_NOTICE,<span class="string">"Background saving started by pid %d"</span>,childpid);</div><div class="line"></div><div class="line">        <span class="comment">// 记录数据库开始 BGSAVE 的时间</span></div><div class="line">        server.rdb_save_time_start = time(<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 记录负责执行 BGSAVE 的子进程 ID</span></div><div class="line">        server.rdb_child_pid = childpid;</div><div class="line"></div><div class="line">        <span class="comment">// 关闭自动 rehash</span></div><div class="line">        updateDictResizePolicy();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> REDIS_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> REDIS_OK; <span class="comment">/* unreached */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RDB文件载入实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoad</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">    <span class="keyword">uint32_t</span> dbid;</div><div class="line">    <span class="keyword">int</span> type, rdbver;</div><div class="line">    redisDb *db = server.db+<span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> expiretime, now = mstime();</div><div class="line">    FILE *fp;</div><div class="line">    rio rdb;</div><div class="line"></div><div class="line">    <span class="comment">// 打开 rdb 文件</span></div><div class="line">    <span class="keyword">if</span> ((fp = fopen(filename,<span class="string">"r"</span>)) == <span class="literal">NULL</span>) <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化写入流</span></div><div class="line">    rioInitWithFile(&amp;rdb,fp);</div><div class="line">    rdb.update_cksum = rdbLoadProgressCallback;</div><div class="line">    rdb.max_processing_chunk = server.loading_process_events_interval_bytes;</div><div class="line">    <span class="keyword">if</span> (rioRead(&amp;rdb,buf,<span class="number">9</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">    buf[<span class="number">9</span>] = <span class="string">'\0'</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 检查版本号</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(buf,<span class="string">"REDIS"</span>,<span class="number">5</span>) != <span class="number">0</span>) &#123;</div><div class="line">        fclose(fp);</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Wrong signature trying to load DB from file"</span>);</div><div class="line">        errno = EINVAL;</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line">    rdbver = atoi(buf+<span class="number">5</span>);</div><div class="line">    <span class="keyword">if</span> (rdbver &lt; <span class="number">1</span> || rdbver &gt; REDIS_RDB_VERSION) &#123;</div><div class="line">        fclose(fp);</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Can't handle RDB format version %d"</span>,rdbver);</div><div class="line">        errno = EINVAL;</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将服务器状态调整到开始载入状态</span></div><div class="line">    startLoading(fp);</div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">        robj *key, *val;</div><div class="line">        expiretime = <span class="number">-1</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* Read type. </span></div><div class="line">         *</div><div class="line">         * 读入类型指示，决定该如何读入之后跟着的数据。</div><div class="line">         *</div><div class="line">         * 这个指示可以是 rdb.h 中定义的所有以</div><div class="line">         * REDIS_RDB_TYPE_* 为前缀的常量的其中一个</div><div class="line">         * 或者所有以 REDIS_RDB_OPCODE_* 为前缀的常量的其中一个</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> ((type = rdbLoadType(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">        <span class="comment">// 读入过期时间值</span></div><div class="line">        <span class="keyword">if</span> (type == REDIS_RDB_OPCODE_EXPIRETIME) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 以秒计算的过期时间</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> ((expiretime = rdbLoadTime(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">            <span class="comment">/* We read the time so we need to read the object type again. </span></div><div class="line">             *</div><div class="line">             * 在过期时间之后会跟着一个键值对，我们要读入这个键值对的类型</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> ((type = rdbLoadType(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">            <span class="comment">/* the EXPIRETIME opcode specifies time in seconds, so convert</span></div><div class="line">             * into milliseconds. </div><div class="line">             *</div><div class="line">             * 将格式转换为毫秒*/</div><div class="line">            expiretime *= <span class="number">1000</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == REDIS_RDB_OPCODE_EXPIRETIME_MS) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 以毫秒计算的过期时间</span></div><div class="line"></div><div class="line">            <span class="comment">/* Milliseconds precision expire times introduced with RDB</span></div><div class="line">             * version 3. */</div><div class="line">            <span class="keyword">if</span> ((expiretime = rdbLoadMillisecondTime(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">            <span class="comment">/* We read the time so we need to read the object type again.</span></div><div class="line">             *</div><div class="line">             * 在过期时间之后会跟着一个键值对，我们要读入这个键值对的类型</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> ((type = rdbLoadType(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">        &#125;</div><div class="line">            </div><div class="line">        <span class="comment">// 读入数据 EOF （不是 rdb 文件的 EOF）</span></div><div class="line">        <span class="keyword">if</span> (type == REDIS_RDB_OPCODE_EOF)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* Handle SELECT DB opcode as a special case </span></div><div class="line">         *</div><div class="line">         * 读入切换数据库指示</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (type == REDIS_RDB_OPCODE_SELECTDB) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 读入数据库号码</span></div><div class="line">            <span class="keyword">if</span> ((dbid = rdbLoadLen(&amp;rdb,<span class="literal">NULL</span>)) == REDIS_RDB_LENERR)</div><div class="line">                <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">            <span class="comment">// 检查数据库号码的正确性</span></div><div class="line">            <span class="keyword">if</span> (dbid &gt;= (<span class="keyword">unsigned</span>)server.dbnum) &#123;</div><div class="line">                redisLog(REDIS_WARNING,<span class="string">"FATAL: Data file was created with a Redis server configured to handle more than %d databases. Exiting\n"</span>, server.dbnum);</div><div class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 在程序内容切换数据库</span></div><div class="line">            db = server.db+dbid;</div><div class="line"></div><div class="line">            <span class="comment">// 跳过</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Read key </span></div><div class="line">         *</div><div class="line">         * 读入键</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> ((key = rdbLoadStringObject(&amp;rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">        <span class="comment">/* Read value </span></div><div class="line">         *</div><div class="line">         * 读入值</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> ((val = rdbLoadObject(type,&amp;rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">        <span class="comment">/* Check if the key already expired. This function is used when loading</span></div><div class="line">         * an RDB file from disk, either at startup, or when an RDB was</div><div class="line">         * received from the master. In the latter case, the master is</div><div class="line">         * responsible for key expiry. If we would expire keys here, the</div><div class="line">         * snapshot taken by the master may not be reflected on the slave. </div><div class="line">         *</div><div class="line">         * 如果服务器为主节点的话，</div><div class="line">         * 那么在键已经过期的时候，不再将它们关联到数据库中去</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span> &amp;&amp; expiretime != <span class="number">-1</span> &amp;&amp; expiretime &lt; now) &#123;</div><div class="line">            decrRefCount(key);</div><div class="line">            decrRefCount(val);</div><div class="line">            <span class="comment">// 跳过</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Add the new object in the hash table </span></div><div class="line">         *</div><div class="line">         * 将键值对关联到数据库中</div><div class="line">         */</div><div class="line">        dbAdd(db,key,val);</div><div class="line"></div><div class="line">        <span class="comment">/* Set the expire time if needed </span></div><div class="line">         *</div><div class="line">         * 设置过期时间</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) setExpire(db,key,expiretime);</div><div class="line"></div><div class="line">        decrRefCount(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Verify the checksum if RDB version is &gt;= 5 </span></div><div class="line">     *</div><div class="line">     * 如果 RDB 版本 &gt;= 5 ，那么比对校验和</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (rdbver &gt;= <span class="number">5</span> &amp;&amp; server.rdb_checksum) &#123;</div><div class="line">        <span class="keyword">uint64_t</span> cksum, expected = rdb.cksum;</div><div class="line"></div><div class="line">        <span class="comment">// 读入文件的校验和</span></div><div class="line">        <span class="keyword">if</span> (rioRead(&amp;rdb,&amp;cksum,<span class="number">8</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">        memrev64ifbe(&amp;cksum);</div><div class="line"></div><div class="line">        <span class="comment">// 比对校验和</span></div><div class="line">        <span class="keyword">if</span> (cksum == <span class="number">0</span>) &#123;</div><div class="line">            redisLog(REDIS_WARNING,<span class="string">"RDB file was saved with checksum disabled: no check performed."</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cksum != expected) &#123;</div><div class="line">            redisLog(REDIS_WARNING,<span class="string">"Wrong RDB checksum. Aborting now."</span>);</div><div class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 关闭 RDB </span></div><div class="line">    fclose(fp);</div><div class="line"></div><div class="line">    <span class="comment">// 服务器从载入状态中退出</span></div><div class="line">    stopLoading();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line"></div><div class="line">eoferr: <span class="comment">/* unexpected end of file is handled here with a fatal exit */</span></div><div class="line">    redisLog(REDIS_WARNING,<span class="string">"Short read or OOM loading DB. Unrecoverable error, aborting now."</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> REDIS_ERR; <span class="comment">/* Just to avoid warning */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h2><p>从SAVE命令的实现过程，我们能够知道一个RDB文件总体结构可以这样划分：</p>
<p><img src="http://data3.liuin.cn/2018-06-08-15284270187199.jpg" alt=""></p>
<p>在数据库数据部分其最基本的元素是键值对，存储在RDB的数据又可以分含有过期键的键值对和没有过期键的键值对两种</p>
<p>没有过期键的键值对组织形式：</p>
<p><img src="http://data3.liuin.cn/2018-06-08-15284272306576.jpg" alt=""></p>
<p>含有过期键的键值对组织形式：</p>
<p><img src="http://data3.liuin.cn/2018-06-08-15284272441950.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对RDB实现持久化的过程进行剖析&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="https://www.liuin.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析——数据库</title>
    <link href="https://www.liuin.cn/2018/05/30/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://www.liuin.cn/2018/05/30/Redis源码剖析——数据库/</id>
    <published>2018-05-30T01:35:46.000Z</published>
    <updated>2018-05-30T05:58:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将对Redis服务器的数据库实现进行介绍</p>
<a id="more"></a>
<h2 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h2><p>Redis服务器中一般保存了多个数据库，每个数据库用<code>redisDb</code>结构表示，结构的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisDb &#123;</div><div class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></div><div class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span></div><div class="line">    <span class="comment">// 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳</span></div><div class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span></div><div class="line">    <span class="comment">// 正处于阻塞状态的键</span></div><div class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP) */</span></div><div class="line">    <span class="comment">// 可以解除阻塞的键</span></div><div class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></div><div class="line">    <span class="comment">// 正在被 WATCH 命令监视的键</span></div><div class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></div><div class="line">    <span class="keyword">struct</span> evictionPoolEntry *eviction_pool;    <span class="comment">/* Eviction pool of keys */</span></div><div class="line">    <span class="comment">// 数据库号码</span></div><div class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID */</span></div><div class="line">    <span class="comment">// 数据库的键的平均 TTL ，统计信息</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></div><div class="line">&#125; redisDb;</div></pre></td></tr></table></figure>
<p>可以从Redis数据库中的定义中看到：数据库的所有键值对都存放在一个字典结构中，同时记录了用于键的删除所需要的过期时间。</p>
<p><img src="http://data3.liuin.cn/2018-05-30-15276449785249.jpg" alt=""></p>
<p>在Redis服务器结构中有一个数据库数组，存放各个数据库的指针；有一个记录数据库数量的变量dbnum，服务器初始化的时候根据这个变量来创建相应数量的数据库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> redisServer &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 数据库</span></div><div class="line">    redisDb *db;</div><div class="line">    <span class="comment">// 数据库数量</span></div><div class="line">    <span class="keyword">int</span> dbnum;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h2><p>每个 Redis客户端都有自己的目标数据库,每当客户端执行数据库写命令或者数据库读命令的时候,目标数据库就会成为这些命令的操作对象。默认情况下, Redis客户端的目标数据库为0号数据库,但客户端可以通过执行SELECT命令来切换目标数据库。</p>
<p>在客户端结构redisClient结构中用db属性记录客户端当前的目标数据库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisClient &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 记录客户端当前使用的数据库</span></div><div class="line">    redisDb *db;</div><div class="line">    ...</div><div class="line"></div><div class="line">&#125; redisClient</div></pre></td></tr></table></figure>
<p>redisClient.db指针指向redisServer.db数组的其中一个元素,而被指向的元素就是客户端的目标数据库。</p>
<p><img src="http://data3.liuin.cn/2018-05-30-15276464513190.jpg" alt=""></p>
<p>使用select切换数据库的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectDb</span><span class="params">(redisClient *c, <span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">    <span class="comment">// 验证db编号的合法性</span></div><div class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span> || id &gt;= server.dbnum)</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    c-&gt;db = &amp;server.db[id];</div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数据库的键空间"><a href="#数据库的键空间" class="headerlink" title="数据库的键空间"></a>数据库的键空间</h2><p>因为数据库的键空间是一个字典,所以所有针对数据库的操作,比如添加一个键值对到数据库,或者从数据库中删除一个键值对,又或者在数据库中获取某个键值对等,实际上都是通过对键空间字典进行操作来实现的</p>
<p><img src="http://data3.liuin.cn/2018-05-30-15276486205548.jpg" alt=""></p>
<h3 id="添加新键"><a href="#添加新键" class="headerlink" title="添加新键"></a>添加新键</h3><p>添加一个新键值对到数据库,实际上就是将一个新键值对添加到键空间字典里面,其中键为字符串对象,而值则为任意一种类型的 Redis对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbAdd</span><span class="params">(redisDb *db, robj *key, robj *val)</span> </span>&#123;</div><div class="line">    <span class="comment">// 拷贝字符串对象</span></div><div class="line">    sds copy = sdsdup(key-&gt;ptr);</div><div class="line">    <span class="comment">// 加入字典</span></div><div class="line">    <span class="keyword">int</span> retval = dictAdd(db-&gt;dict, copy, val);</div><div class="line"></div><div class="line">    redisAssertWithInfo(<span class="literal">NULL</span>,key,retval == REDIS_OK);</div><div class="line">    <span class="comment">// 如果值对象类型为list，需要判断该键是不是引起阻塞的键</span></div><div class="line">    <span class="keyword">if</span> (val-&gt;type == REDIS_LIST) signalListAsReady(db, key);</div><div class="line">    <span class="comment">// 如果开启的集群选项，则需要做相应的处理</span></div><div class="line">    <span class="keyword">if</span> (server.cluster_enabled) slotToKeyAdd(key);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p><img src="http://data3.liuin.cn/2018-05-30-15276578873211.jpg" alt=""></p>
<h3 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h3><p>删除数据库中的一个键,实际上就是在键空间里面删除键所对应的键值对对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></div><div class="line">     * the key, because it is shared with the main dictionary. */</div><div class="line">    <span class="comment">/* 如果有设定过期键，就去过期键字典中删除该键 */</span></div><div class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</div><div class="line">    <span class="keyword">if</span> (dictDelete(db-&gt;dict,key-&gt;ptr) == DICT_OK) &#123;</div><div class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><p>Reids中有LRU机制，能够实现对数据设置期限（过期时间），在期限到达的时候会执行删除机制。Redis中有三种不同的删除策略:</p>
<ul>
<li>定时删除:在设置键的过期时间的同时,创建一个定时器(timer),让定时器在键的过期时间来临时,立即执行对键的删除操作。</li>
<li>惰性删除:放任键过期不管,但是每次从键空间中获取键时,都检查取得的键是否过期,如果过期的话,就删除该键;如果没有过期,就返回该键。</li>
<li>定期删除:每隔一段时间,程序就对数据库进行一次检查,删除里面的过期键。至于要删除多少过期键,以及要检查多少个数据库,则由算法决定。</li>
</ul>
<p>在这三种策略中,第一种和第三种为主动删除策略,而第二种则为被动删除策略。</p>
<h3 id="过期时间的保存"><a href="#过期时间的保存" class="headerlink" title="过期时间的保存"></a>过期时间的保存</h3><p>redisDb结构的expires字典保存了数据库中所有键的过期时间,我们称这个字典为过期字典:</p>
<ul>
<li>过期字典的键是一个指针,这个指针指向键空间中的某个键对象(也即是某个数据库键)</li>
<li>过期字典的值是一个1ong 1ong类型的整数,这个整数保存了键所指向的数据库键的过期时间—个毫秒精度的UNIX时间戳。</li>
</ul>
<p><img src="http://data3.liuin.cn/2018-05-30-15276582632098.jpg" alt=""></p>
<h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>定时删除策略对内存是最友好的:通过使用定时器,定时删除策略可以保证过期键会尽可能快地被删除,并释放过期键所占用的内存。</p>
<p>另一方面,定时删除策略的缺点是,它对CPU时间是最不友好的:在过期键比较多的情况下,删除过期键这一行为可能会占用相当一部分CPU时间,在内存不紧张但是CPU时间非常紧张的情况下,将CPU时间用在删除和当前任务无关的过期键上,无疑会对服务器的响应时间和吞吐量造成影响。</p>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>惰性删除策略对CPU时间来说是最友好的:程序只会在取出键时才对键进行过期检查这可以保证删除过期键的操作只会在非做不可的情况下进行,并且删除的目标仅限于当前处理的键,这个策略<strong>不会在删除其他无关的过期键上花费任何CPU时间</strong>。</p>
<p>惰性删除策略的缺点是,它对内存是最不友好的:如果一个键已经过期,而这个键又仍然保留在数据库中,那么只要这个过期键不被删除,它所占用的内存就不会释放。</p>
<p>具体的实现是通过<code>expireIfNeeded</code>函数实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取定时时间</span></div><div class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key);</div><div class="line">    <span class="keyword">mstime_t</span> now;</div><div class="line">    <span class="comment">// 没有设置定时时间</span></div><div class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></div><div class="line">    <span class="comment">/* 服务器正在加载，不需要处理 */</span></div><div class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">/* lua相关 */</span></div><div class="line">    now = server.lua_caller ? server.lua_time_start : mstime();</div><div class="line">    <span class="comment">/* 主从复制相关 */</span></div><div class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> now &gt; when;</div><div class="line">    <span class="comment">/* 没有过期 */</span></div><div class="line">    <span class="keyword">if</span> (now &lt;= when) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">/* 删除键 */</span></div><div class="line">    server.stat_expiredkeys++;</div><div class="line">    propagateExpire(db,key);</div><div class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED,</div><div class="line">        <span class="string">"expired"</span>,key,db-&gt;id);</div><div class="line">    <span class="keyword">return</span> dbDelete(db,key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>从上面对定时删除和惰性删除的讨论来看,这两种删除方式在单一使用时都有明显的缺陷:</p>
<ul>
<li>定时删除占用太多CPU时间,影响服务器的响应时间和吞吐量。</li>
<li>惰性删除浪费太多内存,有内存泄漏的危险</li>
</ul>
<p>定期删除策略是前两种策略的一种整合和折中</p>
<ul>
<li>定期删除策略每隔一段时间执行一次删除过期键操作,并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li>
<li>除此之外,通过定期删除过期键,定期删除策略有效地减少了因为过期键而带来的内存浪费。</li>
</ul>
<p>定期删除策略的难点是确定删除操作执行的时长和频率</p>
<ul>
<li>如果删除操作执行得太频繁,或者执行的时间太长,定期删除策略就会退化成定时删除策略,以至于将CPU时间过多地消耗在删除过期键上面。</li>
<li>如果删除操作执行得太少,或者执行的时间太短,定期删除策略又会和惰性删除策略一样,出现浪费内存的情况</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将对Redis服务器的数据库实现进行介绍&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="https://www.liuin.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析——对象</title>
    <link href="https://www.liuin.cn/2018/05/29/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.liuin.cn/2018/05/29/Redis源码剖析——对象/</id>
    <published>2018-05-29T06:39:50.000Z</published>
    <updated>2018-05-30T01:09:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章将剖析Redis提供给用户的5种对象底层的数据结构和接口</p>
<a id="more"></a>
<p>前面讲了Reids底层所使用的一些数据结构：SDS、双端链表、字典、跳跃表等等，但是Redis并没有直接使用这些数据结构来构造键值对数据库。</p>
<h2 id="对象数据结构"><a href="#对象数据结构" class="headerlink" title="对象数据结构"></a>对象数据结构</h2><p>在redis.h中定义类redisObject的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Redis 对象定义</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisObject &#123;</div><div class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;       <span class="comment">// 类型</span></div><div class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;   <span class="comment">// 编码</span></div><div class="line">    <span class="comment">// 对象最后一次被访问的时间</span></div><div class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></div><div class="line">    <span class="comment">// 引用计数</span></div><div class="line">    <span class="keyword">int</span> refcount;</div><div class="line">    <span class="comment">// 实现的数据结构</span></div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line">&#125; robj;</div></pre></td></tr></table></figure>
<p>从代码中我们可以看到Redis对象所包含的信息有：类型、编码、实现指针、引用计数和访问时间</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>对于 Redis数据库保存的键值对来说,键总是一个字符串对象,而值则可以是字符串对象(string)、列表对象(list)、哈希对象(hash)、集合对象(set)或者有序集合对象(zset)的其中一种</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Object types */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_STRING 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LIST 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_SET 2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ZSET 3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_HASH 4</span></div></pre></td></tr></table></figure>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>对象的ptr指针指向对象的底层实现数据结构,而这些数据结构由对象的encoding属性决定encoding属性记录了对象所使用的编码,也即是说这个对象使用了什么数据结构作为对象的底层实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_RAW 0     <span class="comment">/* 编码为 简单动态字符串 */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INT 1     <span class="comment">/* 编码为 long类型的整数 */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_HT 2      <span class="comment">/* 编码为 字典 */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPMAP 3   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_LINKEDLIST 4 <span class="comment">/* 编码为 双端链表 */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPLIST 5 <span class="comment">/* 编码为 压缩列表 */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INTSET 6  <span class="comment">/* 编码为 整数集合 */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_SKIPLIST 7  <span class="comment">/* 编码为 跳跃表和字典 */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_EMBSTR 8  <span class="comment">/* 编码为 embstr编码的简单动态字符串 */</span></span></div></pre></td></tr></table></figure>
<p>每种类型的对象都至少对应两种不同的编码</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275795005914.jpg" alt=""></p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>Redis的对象系统实现了<strong>基于引用计数技术的内存回收机制</strong>,当程序不再使用某个对象的时候,这个对象所占用的内存就会被自动释放;另外, Redis还<strong>通过引用计数技术实现了对象共享机制</strong>,这一机制可以在适当的条件下,通过让多个数据库键共享同个对象来节约内存。</p>
<p>上面这些功能都是通过<code>refcount</code>这个属性来实现的：</p>
<ul>
<li>在创建一个新对象时,引用计数的值会被初始化为1</li>
<li>当对象被一个新程序使用时,它的引用计数值会被增一</li>
<li>当对象不再被一个程序使用时,它的引用计数值会被减一</li>
<li>当对象的引用计数值变为0时,对象所占用的内存会被释放</li>
</ul>
<p>修改引用计数的api如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrRefCount</span><span class="params">(robj *o)</span></span>;</div><div class="line"><span class="function">robj *<span class="title">resetRefCount</span><span class="params">(robj *obj)</span></span>;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>内存回收</p>
</blockquote>
<p>我们可以通过decrRefCount的实现看到当引用计数到达0的时候会自动释放对象所占有的资源</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) redisPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);</div><div class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// 释放对象占有的资源</span></div><div class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</div><div class="line">        <span class="keyword">case</span> REDIS_STRING: freeStringObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> REDIS_LIST: freeListObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> REDIS_SET: freeSetObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> REDIS_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> REDIS_HASH: freeHashObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>: redisPanic(<span class="string">"Unknown object type"</span>); <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        zfree(o);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        o-&gt;refcount--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>对象共享</p>
</blockquote>
<p>如果想创建一个与另外一个对象含有相同值的对象，这个时候可以启动对象的共享机制。</p>
<p>在Redis中,让多个键共享同一个值对象需要执行以下两个步骤</p>
<ul>
<li>将数据库键的值指针指向一个现有的值对象</li>
<li>将被共享的值对象的引用计数增一</li>
</ul>
<p>比如在从LongLong创建一个字符串对象的时候，首先要判断在不在共享对象的范围内，如果在的话就对引用计数加1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function">robj *<span class="title">createStringObjectFromLongLong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</div><div class="line"></div><div class="line">    robj *o;</div><div class="line"></div><div class="line">    <span class="comment">// value 的大小符合 REDIS 共享整数的范围</span></div><div class="line">    <span class="comment">// 那么返回一个共享对象</span></div><div class="line">    <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt; REDIS_SHARED_INTEGERS) &#123;</div><div class="line">        incrRefCount(shared.integers[value]);</div><div class="line">        o = shared.integers[value];</div><div class="line"></div><div class="line">    <span class="comment">// 不符合共享范围，创建一个新的整数对象</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 值可以用 long 类型保存，</span></div><div class="line">        <span class="comment">// 创建一个 REDIS_ENCODING_INT 编码的字符串对象</span></div><div class="line">        <span class="keyword">if</span> (value &gt;= LONG_MIN &amp;&amp; value &lt;= LONG_MAX) &#123;</div><div class="line">            o = createObject(REDIS_STRING, <span class="literal">NULL</span>);</div><div class="line">            o-&gt;encoding = REDIS_ENCODING_INT;</div><div class="line">            o-&gt;ptr = (<span class="keyword">void</span>*)((<span class="keyword">long</span>)value);</div><div class="line"></div><div class="line">        <span class="comment">// 值不能用 long 类型保存（long long 类型），将值转换为字符串，</span></div><div class="line">        <span class="comment">// 并创建一个 REDIS_ENCODING_RAW 的字符串对象来保存值</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            o = createObject(REDIS_STRING,sdsfromlonglong(value));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="对象的基本操作"><a href="#对象的基本操作" class="headerlink" title="对象的基本操作"></a>对象的基本操作</h2><p>Redis对象的基本操作包含了创建对象、销毁对象、编码转换等等</p>
<p>大部分操作的实现都在object.c文件中</p>
<h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>各种对象创建的API如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span></span>;  <span class="comment">// 创建对象，设定参数</span></div><div class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>;  <span class="comment">// 创建字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createRawStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>;   <span class="comment">// 创建raw编码的字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createEmbeddedStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>;  <span class="comment">// 创建embstr编码的字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createStringObjectFromLongLong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;  <span class="comment">// 根据传入LongLong创建字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createStringObjectFromLongDouble</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> value)</span></span>;  <span class="comment">// 根据传入的LongDouble创建字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createListObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建双端链表链表编码的列表对象</span></div><div class="line"><span class="function">robj *<span class="title">createZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建压缩列表编码的列表对象</span></div><div class="line"><span class="function">robj *<span class="title">createSetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建集合对象</span></div><div class="line"><span class="function">robj *<span class="title">createIntsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建整型集合编码的集合对象</span></div><div class="line"><span class="function">robj *<span class="title">createHashObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建hash对象</span></div><div class="line"><span class="function">robj *<span class="title">createZsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建zset对象</span></div><div class="line"><span class="function">robj *<span class="title">createZsetZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//创建压缩列表编码的zset对象</span></div></pre></td></tr></table></figure></p>
<p>具体我们以列表对象为例，看看创建对象的过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 创建一个 LINKEDLIST 编码的列表对象</div><div class="line"> */</div><div class="line"><span class="function">robj *<span class="title">createListObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="built_in">list</span> *l = listCreate();</div><div class="line">    robj *o = createObject(REDIS_LIST,l);</div><div class="line">    listSetFreeMethod(l,decrRefCountVoid);</div><div class="line">    o-&gt;encoding = REDIS_ENCODING_LINKEDLIST;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 创建一个 ZIPLIST 编码的列表对象</div><div class="line"> */</div><div class="line"><span class="function">robj *<span class="title">createZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</div><div class="line">    robj *o = createObject(REDIS_LIST,zl);</div><div class="line">    o-&gt;encoding = REDIS_ENCODING_ZIPLIST;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对象销毁"><a href="#对象销毁" class="headerlink" title="对象销毁"></a>对象销毁</h3><p>各种对象销毁的API如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeStringObject</span><span class="params">(robj *o)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeListObject</span><span class="params">(robj *o)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeSetObject</span><span class="params">(robj *o)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeZsetObject</span><span class="params">(robj *o)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeHashObject</span><span class="params">(robj *o)</span></span>;</div></pre></td></tr></table></figure></p>
<p>以List为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 释放列表对象</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeListObject</span><span class="params">(robj *o)</span> </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (o-&gt;encoding) &#123;</div><div class="line">    <span class="keyword">case</span> REDIS_ENCODING_LINKEDLIST:</div><div class="line">        listRelease((<span class="built_in">list</span>*) o-&gt;ptr);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> REDIS_ENCODING_ZIPLIST:</div><div class="line">        zfree(o-&gt;ptr);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        redisPanic(<span class="string">"Unknown list encoding type"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</div><div class="line">    listNode *current, *next;</div><div class="line"></div><div class="line">    <span class="comment">// 指向头指针</span></div><div class="line">    current = <span class="built_in">list</span>-&gt;head;</div><div class="line">    <span class="comment">// 遍历整个链表</span></div><div class="line">    len = <span class="built_in">list</span>-&gt;len;</div><div class="line">    <span class="keyword">while</span>(len--) &#123;</div><div class="line">        next = current-&gt;next;</div><div class="line">        <span class="comment">// 如果有设置值释放函数，那么调用它</span></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</div><div class="line">        <span class="comment">// 释放节点结构</span></div><div class="line">        zfree(current);</div><div class="line">        current = next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 释放链表结构</span></div><div class="line">    zfree(<span class="built_in">list</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和创建对象分多钟编码格式相对应，释放对象的时候也要根据编码具体执行释放</p>
<h2 id="对象交互指令"><a href="#对象交互指令" class="headerlink" title="对象交互指令"></a>对象交互指令</h2><p>Redis提供三个命令用户获取对象的一些参数：</p>
<ul>
<li>object refcount <key> 返回key所指的对象的引用计数</key></li>
<li>object encoding <key> 返回key所指的对象中存放的数据的编码方式</key></li>
<li>object idletime <key> 返回key所指的对象的空转时长</key></li>
</ul>
<p>具体的实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">objectCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    robj *o;</div><div class="line"></div><div class="line">    <span class="comment">// 返回对戏哪个的引用计数</span></div><div class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"refcount"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((o = objectCommandLookupOrReply(c,c-&gt;argv[<span class="number">2</span>],shared.nullbulk))</div><div class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line">        addReplyLongLong(c,o-&gt;refcount);</div><div class="line"></div><div class="line">    <span class="comment">// 返回对象的编码</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"encoding"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((o = objectCommandLookupOrReply(c,c-&gt;argv[<span class="number">2</span>],shared.nullbulk))</div><div class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line">        addReplyBulkCString(c,strEncoding(o-&gt;encoding));</div><div class="line">    </div><div class="line">    <span class="comment">// 返回对象的空闲时间</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"idletime"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((o = objectCommandLookupOrReply(c,c-&gt;argv[<span class="number">2</span>],shared.nullbulk))</div><div class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line">        addReplyLongLong(c,estimateObjectIdleTime(o)/<span class="number">1000</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        addReplyError(c,<span class="string">"Syntax error. Try OBJECT (refcount|encoding|idletime)"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章将剖析Redis提供给用户的5种对象底层的数据结构和接口&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="https://www.liuin.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>《UNIX网络编程卷1》笔记 基本套接字编程部分</title>
    <link href="https://www.liuin.cn/2018/05/23/%E3%80%8AUNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B71%E3%80%8B%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%E9%83%A8%E5%88%86/"/>
    <id>https://www.liuin.cn/2018/05/23/《UNIX网络编程卷1》笔记-基本套接字编程部分/</id>
    <published>2018-05-23T13:36:29.000Z</published>
    <updated>2018-06-14T03:28:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>UNIX网络编程必读书籍——《UNIX网络编程卷1》  基本套接字编程 笔记</p>
<a id="more"></a>
<h1 id="套接字编程简介"><a href="#套接字编程简介" class="headerlink" title="套接字编程简介"></a>套接字编程简介</h1><h2 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h2><p>大多数套接字函数都需要一个指向套接字地址结构的指针作为参数。每个协议族都定义它自己的套接字地址结构。这些结构的名字均以 sockaddr_开头,并以对应每个协议族的唯一后缀结尾。</p>
<h3 id="IPv4套接字地址结构"><a href="#IPv4套接字地址结构" class="headerlink" title="IPv4套接字地址结构"></a>IPv4套接字地址结构</h3><p>IPv4套接字地址结构通常也称为“网际套接字地址结构”,它以 sockaddr_in命名,定义在<netinet in.h="">头文件中。POSIX定义：</netinet></p>
<p><img src="https://data2.liuin.cn/2018-05-22-15269964950047.jpg" alt=""></p>
<p>下面给出几点说明：</p>
<ul>
<li>并不是所有厂商都支持sin_len，即使有长度字段,我们也无须设置和检查它,除非涉及路由套接字，处理来自不同协议族的套接字地址结构的例程(例如路由表处理代码)在内核中使用的。</li>
<li>POSX规范只需要这个结构中的3个字段:sin_fari1y、 sin_addr和sin_port,</li>
</ul>
<h3 id="通用套接字地址结构"><a href="#通用套接字地址结构" class="headerlink" title="通用套接字地址结构"></a>通用套接字地址结构</h3><p>当作为一个参数传递进任何套接字函数时,套接字地址结构总是以引用形式(也就是以指向该结构的指针)来传递。然而以这样的指针作为参数之一的任何套接字函数必须处理来自所支持的任何协议族的套接字地址结构。</p>
<p>现在所采用的方法是在<sys socket.h="">头文件中定义一个通用的套接字地址结构：</sys></p>
<p><img src="https://data2.liuin.cn/2018-05-22-15269968296764.jpg" alt=""></p>
<p>于是套接字函数被定义为以指向某个通用套接字地址结构的一个指针作为其参数之一。这就要求对这些函数的任何调用都必须要将<strong>指向特定于协议的套接字地址结构的指针进行强制转换(casting),变成指向某个通用套接字地址结构的指针</strong></p>
<p>从应用程序开发人员的观点看,这些通用套接字地址结构的唯一用途就是<strong>对指向特定于协议的套接字地址结构的指针执行类型强制转换</strong>。</p>
<h3 id="套接字地址结构比较"><a href="#套接字地址结构比较" class="headerlink" title="套接字地址结构比较"></a>套接字地址结构比较</h3><p><img src="https://data2.liuin.cn/2018-05-22-15269969711360.jpg" alt=""></p>
<h2 id="值-结果参数"><a href="#值-结果参数" class="headerlink" title="值-结果参数"></a>值-结果参数</h2><p>当往一个套接字函数传递一个套接字地址结构时,该<strong>结构总是以引用形式来传递</strong>,也就是说传递的是指向该结构的一个指针。该结构的长度也作为一个参数来传递,不过其传递方式取决于该结构的传递方向:是从进程到内核,还是从内核到进程。</p>
<p>(1)从进程到内核传递套接字地址结构的函数有3个:bind、connect和 sendto。这些函数的一个参数是指向某个套接字地址结构的指针,另一个参数是该结构的整数大小。既然指针和指针所指内容的大小都传递给了内核,于是内核知道到底需从进程复制多少数据进来。</p>
<p><img src="https://data2.liuin.cn/2018-05-22-15269972347844.jpg" alt=""></p>
<p>(2)从内核到进程传递套接字地址结构的函数有4个: accept、 recvfrom、 getsockname和 getpeername。这4个函数的其中两个参数是<strong>指向某个套接字地址结构的指针</strong>和<strong>指向表示该结构大小的整数变量的指针</strong>。把套接字地址结构大小这个参数从一个整数改为指向某个整数变量的指针,其原因在于:当函数被调用时,结构大小是一个值(value),它告诉内核该结构的大小,这样内核在写该结构时不至于越界;当函数返回时,结构大小又是一个结果(result.),它告诉进程内核在该结构中究竟存储了多少信息。这种类型的参数称为值-结果(value-result)参数。</p>
<p><img src="https://data2.liuin.cn/2018-05-22-15269973186591.jpg" alt=""></p>
<p>在网络编程中,值-结果参数最常见的例子是所返回套接字地址结构的长度</p>
<h2 id="字节排序函数"><a href="#字节排序函数" class="headerlink" title="字节排序函数"></a>字节排序函数</h2><p>内存中有两种存储多字节数的方法：一种是将低序字节存储在起始地址,这称为小端(little-endian)字节序;另一种方法是将高序字节存储在起始地址,这称为大端(big-endian)字节序</p>
<p><img src="https://data2.liuin.cn/2018-05-22-15269974255787.jpg" alt=""></p>
<p>不同的主机中使用的字节序是不一样的。</p>
<p>套接字地址结构中的某些字段必须按照网络字节序进行维护。因此我们要关注如何在主机字节序和网络字节序之间相互转换。这两种字节序之间的转换使用以下4个函数：</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270558826021.jpg" alt=""></p>
<p>在这些函数的名字中,h代表host,n代表network,s代表short,l代表long。</p>
<h2 id="字节操作函数"><a href="#字节操作函数" class="headerlink" title="字节操作函数"></a>字节操作函数</h2><p>操纵多字节字段的函数有两组,它们<strong>既不对数据作解释,也不假设数据是以空字符结束的C字符串</strong>。当处理套接字地址结构时,我们需要这些类型的函数,因为我们需要操纵诸如IP地址这样的字段,这些字段可能包含值为0的字节,却并不是C字符串。以空字符结尾的C字符串是由在<string.h>头文件中定义、名字以str(表示字符串)开头的函数处理的。</string.h></p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270567699154.jpg" alt=""></p>
<p>bzero把目标字节串中指定数目的字节置为0。我们经常使用该函数来把一个套接字地址结构初始化为0。 bcopy将指定数目的字节从源字节串移到目标字节串。bcmp比较两个任意的字节串,若相同则返回值为0,否则返回值为非0。</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270568142560.jpg" alt=""></p>
<p>memset把目标字节串指定数目的字节置为值c。 memcpy类似bcopy,不过两个指针参数的顺序是相反的。当源字节串与目标字节串重叠时,bco能够正确处理,但是 memcpy的操作结果却不可知。这种情形下必须改用 ANSI C的 mernmove函数。</p>
<h2 id="inet-aton、inet-addr和inet-ntoa函数"><a href="#inet-aton、inet-addr和inet-ntoa函数" class="headerlink" title="inet_aton、inet_addr和inet_ntoa函数"></a>inet_aton、inet_addr和inet_ntoa函数</h2><p>在ASCII字符串(这是人们偏爱使用的格式)与网络字节序的二进制值(这是存放在套接字地址结构中的值)之间转换网际地址需要一些函数进行实现。</p>
<p>inet_aton、inet_addr和 inet_ntoa在点分十进制数串(例如“206,168,112.96”)与它长度为32位的网络字节序二进制值间转换IP4地址:</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270571324262.jpg" alt=""></p>
<h2 id="inet-pton和inet-ntop函数"><a href="#inet-pton和inet-ntop函数" class="headerlink" title="inet_pton和inet_ntop函数"></a>inet_pton和inet_ntop函数</h2><p>这两个函数是随Iv6出现的新函数,对于IPv4地址和Pv6地址都适用。本书通篇都在使用这两个函数。函数名中和n分别代表表达( presentation)和数值( numeric)。地址的表达格式通常是ASCⅡ字符串,数值格式则是存放到套接字地址结构中的二进制值</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270571987014.jpg" alt=""></p>
<h2 id="sock-ntop和相关函数"><a href="#sock-ntop和相关函数" class="headerlink" title="sock_ntop和相关函数"></a>sock_ntop和相关函数</h2><p>inet_ntop的一个基本问题是:它要求调用者传递一个指向某个二进制地址的指针,而该地址通常包含在一个套接字地址结构中,这就要求调用者必须知道这个结构的格式和地址族。</p>
<p>为了解决这个问题,我们将自行编写一个名为sock_ntop的函数,它以指向某个套接字地址结构的指针为参数,查看该结构的内部,然后调用适当的函数返回该地址的表达格式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sock_ntop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *sockaddr, <span class="keyword">sockelen_t</span> addrlen)</span></span>;</div></pre></td></tr></table></figure>
<p>仅为AF_INET下的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sock_ntop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *sockaddr, <span class="keyword">sockelen_t</span> addrlen)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> portstr[<span class="number">8</span>];</div><div class="line">	<span class="keyword">static</span> <span class="keyword">char</span> str[<span class="number">128</span>];</div><div class="line"></div><div class="line">	<span class="keyword">switch</span>(sockaddr-&gt;sa_family)&#123;</div><div class="line">		<span class="keyword">case</span> AF_INET:</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">struct</span> sockaddr_in *<span class="built_in">sin</span> = (<span class="keyword">struct</span> sockaddr_in *) sockeaddr;</div><div class="line">				<span class="keyword">if</span>(inet_ntop(AF_INET, &amp;<span class="built_in">sin</span>-&gt;sin_addr, str, <span class="keyword">sizeof</span>(str)) == <span class="literal">NULL</span>)</div><div class="line">					<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">				<span class="keyword">if</span>(ntohs(<span class="built_in">sin</span>-&gt;sin_port) != <span class="number">0</span>)</div><div class="line">				&#123;</div><div class="line">					<span class="built_in">snprintf</span>(portstr, <span class="keyword">sizeof</span>(portstr), <span class="string">":%d"</span>, ntohs(<span class="built_in">sin</span>-&gt;sin_port));</div><div class="line">					<span class="built_in">strcat</span>(str, portstr);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> str;</div><div class="line">			&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="readn、writen和readline函数"><a href="#readn、writen和readline函数" class="headerlink" title="readn、writen和readline函数"></a>readn、writen和readline函数</h2><p>字节流套接字(例如TCP套接字)上的read和 write函数所表现的行为不同于通常的文件IO。字节流套接字上调用read或 write输入或输出的字节数可能比请求的数量少,然而这不是出错的状态。这个现象的原因在于<strong>内核中用于套接字的缓冲区可能已达到了极限</strong>。</p>
<p>因为这个原因，我们可以在原始的读写函数的基础上，为了使得I/O传输所有的字符，我们不断调用read、write直到对所需要的数据完成所有的传输</p>
<h1 id="基本TCP套接字编程"><a href="#基本TCP套接字编程" class="headerlink" title="基本TCP套接字编程"></a>基本TCP套接字编程</h1><p>下图给出了TCP客户与服务器进程之间发生的一些典型事件的时间表：</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270592134854.jpg" alt=""></p>
<h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><p>为了执行网络O,一个进程必须做的第一件事情就是调用 socket函数,指定期望的通信协议类型(使用IPv4的TCP、使用IPv6的UDP、Unix域字节流协议等)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span> <span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: non-negative descriptor if OK, -1 on error</span></div></pre></td></tr></table></figure>
<p>其中family参数指明协议族。该参数也往往被称为协议域。type参数指明套接字类型。protocol参数应设为某个协议类型常值,或者设为0,以选择所给定mi和nye组合的系统默认值。</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270603977151.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270604018451.jpg" alt=""></p>
<p>socket函数在成功时返回一个小的非负整数值,它与文件描述符类似,我们把它称为套接字描述符(socket descriptor),简称sockfd</p>
<blockquote>
<p>对比AF_XXX和PF_XXX</p>
</blockquote>
<p>AF前缀表示地址族,PF前缀表示协议族。历史上曾有这样的想法:单个协议族可以支持多个地址族,<strong>PF值用来创建套接字,而AF值用于套接字地址结构</strong>。但实际上,支持多个地址族的协议族从来就未实现过,而且头文件<sys socket.h="">中为一给定协议定义的PF值总是与此协议的AF值相等。</sys></p>
<h2 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h2><p>TCP客户用 connect函数来建立与TCP服务器的连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *servaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>; </div><div class="line"><span class="comment">// Returns: 0 if OK, -1 on error</span></div></pre></td></tr></table></figure>
<p>sockfd是由socket函数返回的套接字描述符,第二个、第三个参数分别是一个指向套接字地址结构的指针和该结构的大小。客户在调用函数 connect前不必非得调用bind函数,因为如果需要的话,内核会确定源IP地址,并选择一个临时端口作为源端口。</p>
<p>建立连接是通过TCP三次握手建立的，建立连接中产生的具体错误可以通过返回值进行判断</p>
<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><p>bind函数把一个本地协议地址赋予一个套接字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span> <span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK,-1 on error</span></div></pre></td></tr></table></figure>
<p>第二个参数是一个指向特定于协议的地址结构的指针,第三个参数是该地址结构的长度。对于TCP,调用bind函数可以指定一个端口号,或指定一个IP地址,也可以两者都指定,还可以都不指定。</p>
<ul>
<li>服务器在启动时捆绑它们的众所周知端口</li>
<li>进程可以把一个特定的IP地址捆绑到它的套接字上,不过这个IP地址必须属于其所在主机的网络接口之一。对于TCP客户,这就为在该套接字上发送的IP数据报指派了源IP地址。对于TCP服务器,这就限定该套接字只接收那些目的地为这个P地址的客户连接。</li>
</ul>
<p>如果指定端口号为0,那么内核就在bind被调用时选择一个临时端口。然而如果指定IP地址为通配地址,那么内核将等到套接字已连接(TCP)或已在套接字上发出数据报(UDP)时才选择一个本地IP地址</p>
<h2 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h2><p>listen函数仅由TCP服务器调用,它做两件事情</p>
<ol>
<li>当 socket函数创建一个套接字时,它被假设为一个<strong>主动套接字</strong>,也就是说,它是一个将调用connect发起连接的客户套接字。listen函数把一个未连接的套接字转换成一个被动套接字,指示内核应接受指向该套接字的连接请求。</li>
<li>本函数的第二个参数规定了内核应该为相应套接字排队的最大连接个数。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span> <span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, -1 on error</span></div></pre></td></tr></table></figure>
<p>为了理解其中的backlog参数,我们必须认识到内核为任何一个给定的监听套接字维护两个队列:</p>
<ol>
<li>未完成连接队列(incomplete connection queue),每个这样的SYN分节对应其中一项:已由某个客户发出并到达服务器,而服务器正在等待完成相应的TCP三路握手过程。这些套接字处于SYN RCVD状态。</li>
<li>已完成连接队列(completed connection queue),每个已完成TCP三路握手过程的客户对应其中一项。这些套接字处于 ESTABLISHED状态</li>
</ol>
<h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><p>accept函数由TCP服务器调用,用于从已完成连接队列队头返回下一个已完成连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span> <span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *cliaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: non-negative descriptor if OK, -1 on error</span></div></pre></td></tr></table></figure>
<p>参数cliaddr和addrlen用来返回已连接的对端进程(客户)的协议地址。 addrlen是值-结果参数:调用前,我们将由*addrlen所引用的整数值置为由cliaddr所指的套接字地址结构的长度,返回时,该整数值即为由内核存放在该套接字地址结构内的确切字节数。</p>
<p>如果accept成功,那么其返回值是由内核自动生成的一个全新描述符,代表与所返回客户的TCP连接。在讨论 accept函数时,我们称它的第一个参数为<strong>监听套接字</strong>(listening socket)描述符(由socke创建,随后用作bind和listen的第一个参数的描述符),称它的返回值为<strong>已连接套接字</strong>( connected socket)描述符。</p>
<p>区分这两个套接字非常重要。一个服务器通常仅仅创建个监听套接字,它在该服务器的生命期内一直存在。内核为每个由服务器进程接受的客户连接创建一个已连接套接字(也就是说对于它的TCP三路握手过程已经完成)。当服务器完成对某个给定客户的服务时,相应的已连接套接字就被关闭。</p>
<h2 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h2><p>然而当服务一个客户请求可能花费较长时间时,我们并不希望整个服务器被单个客户长期占用,而是希望同时服务多个客户。Unix中编写并发服务器程序最简单的办法就是foxk一个子进程来服务每个客户。</p>
<p>当一个连接建立时, accept返回,服务器接着调用fork,然后由子进程服务客户(通过已连接套接字clientfd),父进程则等待另一个连接(通过监听套接字listened)。既然新的客户由子进程提供服务,父进程就关闭已连接套接。</p>
<h2 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h2><p>close一个TCP套接字的默认行为是把该套接字标记成已关闭,然后立即返回到调用进程。该套接字描述符不能再由调用进程使用,也就是说它不能再作为read或wrie的第一个参数。然而TCP将尝试发送已排队等待发送到对端的任何数据,发送完毕后发生的是正常的TCP连接终止序列。</p>
<p>并发服务器中父进程关闭已连接套接字只是导致相应描述符的引用计数值减1。既然引用计数值仍大于0,这个<strong>c1ose调用并不引发TCP的四分组连接终止序列</strong>。对于父进程与子进程共享已连接套接字的并发服务器来说,这正是所期望的。如果我们确实想在某个TCP连接上发送一个FⅠN,那么可以改用shutdow函数以代替c1ose。</p>
<h1 id="I-O复用：select和poll函数"><a href="#I-O复用：select和poll函数" class="headerlink" title="I/O复用：select和poll函数"></a>I/O复用：select和poll函数</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>有的时候，进程需要一种预先告知内核的能力,使得内核一旦发现进程指定的一个或多个I/O条件就绪(也就是说输入已准备好被读取,或者描述符已能承接更多的输出),它就通知进程。这个能力称为I/O复用(I/O multiplexing),是由se1ect和po11这两个函数支持的。</p>
<p>IO复用典型使用在下列网络应用场合:</p>
<ul>
<li>当客户处理多个描述符(通常是交互式输入和网络套接字)时,必须使用I/O复用。</li>
<li>一个客户同时处理多个套接字是可能的,不过比较少见。</li>
<li>如果一个TCP服务器既要处理监听套接字,又要处理已连接套接字,一般就要使用I/O复用</li>
<li>如果一个服务器即要处理TCP,又要处理UDP,一般就要使用I/O复用</li>
<li>如果一个服务器要处理多个服务或者多个协议,一般就要使用IO复用。</li>
</ul>
<p>IO复用并非只限于网络编程,许多重要的应用程序也需要使用这项技术。</p>
<h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h2><p>在介绍 select和poll这两个函数之前,我们需要回顾整体,查看Uniⅸ下可用的5种I/O模型的基本区别:</p>
<ul>
<li>阻塞式I/O;</li>
<li>非阻塞式I/O;</li>
<li>IO复用(se1ect和po11);</li>
<li>信号驱动式IO(SIGIO);</li>
<li>异步I/O(POSIX的aio_系列函数)。</li>
</ul>
<h3 id="阻塞式I-O模型"><a href="#阻塞式I-O模型" class="headerlink" title="阻塞式I/O模型"></a>阻塞式I/O模型</h3><p>默认情形下,所有套接字都是阻塞的</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274240586717.jpg" alt=""></p>
<p>在图中,进程调用 recvfrom,其系统调用直到数据报到达且被复制到应用进程的缓冲区中或者发生错误才返回。最常见的错误是系统调用被信号中断</p>
<h3 id="非阻塞式I-O模型"><a href="#非阻塞式I-O模型" class="headerlink" title="非阻塞式I/O模型"></a>非阻塞式I/O模型</h3><p>进程把一个套接字设置成非阻塞是在通知内核：当所请求的I/O操作非得把本进程投入睡眠才能完成时,不要把本进程投入睡眠,而是返回一个错误。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274241782814.jpg" alt=""></p>
<p>当一个应用进程像这样对一个非阻塞描述符循环调用 recvfrom时,我们称之为轮询</p>
<h3 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h3><p>有了I/O复用(I/O multiplexing),我们就可以调用select或po11,<strong>阻塞在这两个系统调用中的某一个之上,而不是阻塞在真正的I/O系统调用上</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274242724836.jpg" alt=""></p>
<p>我们阻塞于se]ect调用,等待数据报套接字变为可读。当se1ect返回套接字可读这一条件时,我们调用 recvfrom把所读数据报复制到应用进程缓冲区。</p>
<h3 id="信号驱动式IO模型"><a href="#信号驱动式IO模型" class="headerlink" title="信号驱动式IO模型"></a>信号驱动式IO模型</h3><p>我们也可以用信号,让内核在描述符就绪时发送SIGIO信号通知我们。我们称这种模型为信号驱动式I/O( signal-driven I/O)</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274243322666.jpg" alt=""></p>
<h3 id="异步I-O模型"><a href="#异步I-O模型" class="headerlink" title="异步I/O模型"></a>异步I/O模型</h3><p>这些函数的工作机制是:告知内核启动某个操作,并让内核在整个操作(包括将数据从内核复制到我们自己的缓冲区)完成后通知我们。这种模型与前一节介绍的信号驱动模型的主要区别在于:<strong>信号驱动式IO是由内核通知我们何时可以启动一个O操作,而异步LO模型是由内核通知我们IO操作何时完成</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274244101255.jpg" alt=""></p>
<h3 id="各种I-O模型的比较"><a href="#各种I-O模型的比较" class="headerlink" title="各种I/O模型的比较"></a>各种I/O模型的比较</h3><p><img src="https://data2.liuin.cn/2018-05-27-15274244780614.jpg" alt=""></p>
<p>上图对比了上述5种不同的I/O模型。可以看出,前4种模型的主要区别在于第一阶段,因为它们的第二阶段是一样的:在数据从内核复制到调用者的缓冲区期间,进程阻塞于recvfrom调用。相反,异步I/O模型在这两个阶段都要处理,从而不同于其他4种模型。</p>
<h2 id="select-函数"><a href="#select-函数" class="headerlink" title="select 函数"></a>select 函数</h2><p>该函数允许进程指示内核等待多个事件中的任何一个发生,并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。也就是说,我们调用 select告知内核对哪些描述符(就读、写或异常条件)感兴趣以及等待多长时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> <span class="keyword">struct</span> timeval *timeout)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: positive count of ready descriptors, 0 on timeout, –1 on error</span></div></pre></td></tr></table></figure>
<p>最后一个参数它告知内核等待所指定描述符中的任何一个就绪可花多少时间。</p>
<p>中间的三个参数 readset、 writeset和 excepts指定我们要让内核测试读、写和异常条件的描述符。目前支持的异常条件只有两个:<br>(1)某个套接字的带外数据的到达<br>(2)某个已置为分组模式的伪终端存在可从其主端读取的控制状态信息</p>
<p>如何给这3个参数中的每一个参数指定一个或多个描述符值是一个设计上的问题。se1ect使用描述符集,通常是一个整数数组,其中每个整数中的每一位对应一个描述符</p>
<p>select函数的中间三个参数 readset、 writeset和 excepts中,如果我们对某一个的条件不感兴趣,就可以把它设为空指针。事实上,如果这三个指针}均为空,我们就有了一个比UNIX的s1eep函数更为精确的定时器( sleep睡眠以秒为最小单位)。</p>
<p>头文件<sys select.h="">中定义的 FD_SETSIZE常值是数据类型 fd_set中的描述符总数,其值通常是1024,不过很少有程序用到那么多的描述符。<strong>maxfdpl参数迫使我们计算出所关心的最大描述符并告知内核该值</strong>。</sys></p>
<p>se1ect函数修改由指针 readset、 writeset和 excepts所指向的的描述符集,因而这三个参数都是值结果参数。调用该函数时,我们指定所关心的描述符的值,该函数返回时,结果将指示哪些描述符已就绪。该函数返回后,我们使用 FD_ISSET宏来测试 fa_set数据类型中的描述符描述符集内任何与未就绪描述符对应的位返回时均清成0。为此,每次重新调用se1ect函数时,我们都得再次把所有描述符集内所关心的位均置为1。</p>
<p>该函数的<strong>返回值表示跨所有描述符集的已就绪的总位数</strong>。如果在任何描述符就绪之前定时器到时,那么返回0。返回-1表示出错(这是可能发生的,譬如本函数被一个所捕获的信号中断)。</p>
<h3 id="描述符就绪条件"><a href="#描述符就绪条件" class="headerlink" title="描述符就绪条件"></a>描述符就绪条件</h3><p>我们一直在讨论等待某个描述符准备好I/O(读或写)或是等待其上发生一个待处理的异常条件(带外数据)。尽管可读性和可写性对于普通文件这样的描述符显而易见,然而对于引起select返回套接字“就绪”的条件我们必须讨论得更明确些</p>
<p>满足下列四个条件中的任何一个时,一个套接字准备好读</p>
<ol>
<li>该套接字接收缓冲区中的数据字节数大于等于套接字接收缓冲区低水位标记的当前大小。对这样的套接字执行读操作不会阻塞并将返回一个大于0的值(也就是返回准备好读入的数据)。</li>
<li>该连接的读半部关闭(也就是接收了FIN的TCP连接)。对这样的套接字的读操作将不阻塞并返回0(也就是返回EOF)。</li>
<li>该套接字是一个监听套接字且已完成的连接数不为0。对这样的套接字的accept通常不会阻塞</li>
<li>其上有一个套接字错误待处理。</li>
</ol>
<p>下列四个条件中的任何一个满足时,一个套接字准备好写</p>
<ol>
<li>该套接字发送缓冲区中的可用空间字节数大于等于套接字发送缓冲区低水位标记的当前大小,并且或者该套接字已连接,或者该套接字不需要连接(如UDP套接字)。这意味着如果我们把这样的套接字设置成非阻塞，写操作将不阻塞并返回一个正值(例如由传输层接受的字节数)。</li>
<li>该连接的写半部关闭。对这样的套接字的写操作将产生SIGPIP信号</li>
<li>使用非阻塞式connect的套接字已建立连接,或者connect已经以失败告终</li>
<li>其上有一个套接字错误待处理。</li>
</ol>
<p>如果一个套接字存在带外数据或者仍处于带外标记,那么它有异常条件待处理。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274255486025.jpg" alt=""></p>
<h2 id="shutdown函数"><a href="#shutdown函数" class="headerlink" title="shutdown函数"></a>shutdown函数</h2><p>终止网络连接的通常方法是调用c1ose函数。不过cose有两个限制,却可以使用shutdown来避免：</p>
<ol>
<li>close把描述符的引用计数减1,仅在该计数变为0时才关闭套接字。使用 shutdown可以不管引用计数就激发TCP的正常连接终止序列</li>
<li>close终止读和写两个方向的数据传送。既然TCP连接是全双工的,有时候我们需要告知对端我们已经完成了数据发送,即使对端仍有数据要发送给我们。</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-05-27-15274259894144.jpg" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, –1 on error</span></div></pre></td></tr></table></figure>
<p>该函数的行为依赖于howo参数的值:</p>
<ul>
<li>SHUT_RD——关闭连接的读这一半——套接字中不再有数据可接收,而且套接字接收缓冲区中的现有数据都被丢弃。进程不能再对这样的套接字调用任何读函数。对一个TCP套接字这样调用 shutdown函数后,由该套接字接收的来自对端的任何数据都被确认,然后悄然丢弃。</li>
<li>SHUT_WR——关闭连接的写这一半——对于TCP套接字,这称为半关闭。当前留在套接字发送缓冲区中的数据将被发送掉,后跟TCP的正常连接终止序列。我们已经说过,不管套接字描述符的引用计数是否等于0,这样的写半部关闭照样执行。进程不能再对这样的套接字调用任何写函数。</li>
<li>SHUT_RDWR——连接的读半部和写半部都关闭——这与调用shutdown两次等效:第一次调用指定 SHUT_RD,第二次调用指定 SHUT_WR</li>
</ul>
<h2 id="pselect-函数"><a href="#pselect-函数" class="headerlink" title="pselect 函数"></a>pselect 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span> <span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *timeout, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, –1 on error</span></div></pre></td></tr></table></figure>
<p>pselect相对于通常的select有两个变化。</p>
<ul>
<li>pselect使用timespec结构,而不使用timeval结构。前者指定纳秒数，后者指定微秒数</li>
<li>pselect函数增加了第六个参数:一个指向信号掩码的指针。该参数允许程序先禁止递交某些信号,再测试由这些当前被禁止信号的信号处理函数设置的全局变量,然后调用select,告诉它重新设置信号掩码。</li>
</ul>
<h2 id="poll-函数"><a href="#poll-函数" class="headerlink" title="poll 函数"></a>poll 函数</h2><p>po11提供的功能与se1ect类似,不过在处理流设备时,它能够提供额外的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(<span class="keyword">struct</span> pollfd *fdarray, <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, –1 on error</span></div></pre></td></tr></table></figure>
<p>第一个参数是指向一个结构数组第一个元素的指针。每个数组元素都是一个pollfd结构,用于指定测试某个给定描述符fd的条件。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274265737476.jpg" alt=""></p>
<p>要测试的条件由 events成员指定,函数在相应的 revents成员中返回该描述符的状态。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274266342975.jpg" alt=""></p>
<h1 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h1><h2 id="getsockopt和setsockopt函数"><a href="#getsockopt和setsockopt函数" class="headerlink" title="getsockopt和setsockopt函数"></a>getsockopt和setsockopt函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval <span class="keyword">socklen_t</span> optlen)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK,–1 on error</span></div></pre></td></tr></table></figure>
<p>其中sockfd必须指向一个打开的套接字描述符,level(级别)指定系统中解释选项的代码或为通用套接字代码,或为某个特定于协议的代码(例如IPv4、IPv6、TCP或SCTP)。optval是一个指向某个变量(*optval)的指针, setsockopt从*optval中取得选项待设置的新值, getsockopt则把已获取的选项当前值存放到*optval冲中。*optval的大小由最后一个参数指定,它对于setsockopt是一个值参数,对于 getsockopt是一个值-结果参数</p>
<p>套接字选项粗分为两大基本类型:一是<strong>启用或禁止某个特性的二元选项(称为标志选项)</strong>二是<strong>取得并返回我们可以设置或检查的特定值的选项</strong>(称为值选项)。</p>
<h2 id="通用套接字选项"><a href="#通用套接字选项" class="headerlink" title="通用套接字选项"></a>通用套接字选项</h2><p>通用套接字选项是与协议无关的，不过其中有些选项只能应用到某些特定类型的套接字中。</p>
<h3 id="SO-BROADCAST套接字选项"><a href="#SO-BROADCAST套接字选项" class="headerlink" title="SO_BROADCAST套接字选项"></a>SO_BROADCAST套接字选项</h3><p>本选项开启或禁止进程发送广播消息的能力。只有数据报套接字支持广播,并且还必须是在支持广播消息的网络上(例如以太网、令牌环网等)。我们不可能在点对点链路上进行广播,也不可能在基于连接的传输协议(例如TCP和SCTP)之上进行广播。</p>
<p>由于应用进程在发送广播数据报之前必须设置本套接字选项,因此它能够有效地防止一个进程在其应用程序根本没有设计成可广播时就发送广播数据报。</p>
<h3 id="SO-DEBUG套接字选项"><a href="#SO-DEBUG套接字选项" class="headerlink" title="SO_DEBUG套接字选项"></a>SO_DEBUG套接字选项</h3><p>本选项仅由TCP支持。当给一个TCP套接字开启本选项时,内核将为TCP在该套接字发送和接收的所有分组保留详细跟踪信息。这些信息保存在内核的某个环形缓冲区中,并可使用trpt程序进行检查。</p>
<h3 id="SO-DONTROUTE套接字选项"><a href="#SO-DONTROUTE套接字选项" class="headerlink" title="SO_DONTROUTE套接字选项"></a>SO_DONTROUTE套接字选项</h3><p>本选项规定外出的分组将绕过底层协议的正常路由机制</p>
<h3 id="SO-ERROR套接字选项"><a href="#SO-ERROR套接字选项" class="headerlink" title="SO_ERROR套接字选项"></a>SO_ERROR套接字选项</h3><p>当一个套接字上发生错误时,源自 Berkeley的内核中的协议模块将该套接字的名为so_error的变量设为标准的Unix Exxx值中的一个,我们称它为该套接字的待处理错误( pendingeror)。内核能够以下面两种方式之一立即通知进程这个错误。</p>
<ol>
<li>如果进程阻塞在对该套接字的 select调用上,那么无论是检查可读条件还是可写条件, select均返回并设置其中一个或所有两个条件。</li>
<li>如果进程使用信号驱动式I/O模型,那就给进程或进程组产生一个SIGTO信号。</li>
</ol>
<h3 id="SO-KEEPALIVE套接字选项"><a href="#SO-KEEPALIVE套接字选项" class="headerlink" title="SO_KEEPALIVE套接字选项"></a>SO_KEEPALIVE套接字选项</h3><p>给一个TCP套接字设置保持存活( keep-alive)选项后,如果2小时内在该套接字的任一方向上都没有数据交换,TCP就自动给对端发送一个保持存活探测分节( keep-alive probe)。这是一个对端必须响应的TCP分节,它会导致以下三种情况之一</p>
<ul>
<li>对端以期望的ACK响应。应用进程得不到通知(因为一切正常)。在又经过仍无动静的时后,TCP将发出另一个探测分节。</li>
<li>对端以RST响应,它告知本端TCP:对端已崩溃且己重新启动。该套接字的待处理错误被置为 ECONNRESET,套接字本身则被关闭。</li>
<li>对端对保持存活探测分节没有任何响应。</li>
</ul>
<p>本选项的功用是检测对端主机是否崩溃或变得不可达(譬如拨号调制解调器连接掉线,电源发生故障,等等)。如果对端进程崩溃,它的TCP将跨连接发送一个FIN,这可以通过调用select很容易地检测到。同时也要认识到,即使对任何保持存活探测分节均无响应(第三种情况),我们也不能肯定对端主机已经崩溃,因而TCP可能会终止一个有效连接。</p>
<p>本选项一般由服务器使用,不过客户也可以使用。服务器使用本选项是因为它们花大部分时间阻塞在等待穿越TCP连接的输入上,也就是说在等待客户的请求。然而如果客户主机连接掉线、电源掉电或系统崩溃,服务器进程将永远不会知道,并将继续等待永远不会到达的输入我们称这种情况为半开连接( half-open connection)。保持存活选项将检测出这些半开连接并终止它们。</p>
<h3 id="SO-LINGER套接字选项"><a href="#SO-LINGER套接字选项" class="headerlink" title="SO_LINGER套接字选项"></a>SO_LINGER套接字选项</h3><p>本选项指定close函数对面向连接的协议(例如TCP和SCTP,但不是UDP)如何操作。默认操作是c1ose立即返回,但是如果有数据残留在套接字发送缓冲区中,系统将试着把这些数据发送给对端。</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275638162436.jpg" alt=""></p>
<p>客户可以设置so_LINGER套接字选项,指定一个正的延滞时间。这种情况下客户的c1ose要到它的数据和FIN已被服务器主机的TCP确认后才返回</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275638674270.jpg" alt=""></p>
<p>然而我们会面临一个问题:在服务器应用进程读剩余数据之前,服务器主机可能崩溃,并且客户应用进程永远不会知道。更糟糕的是，下图展示了当给 SO_LINGER选项设置偏低的延滞时间值时可能发生的现象。</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275640017253.jpg" alt=""></p>
<p>让客户知道服务器已读取其数据的一个方法是改为调用shutdown(并设置它的第二个参数为 SHUT_WR)而不是调用c1ose,并等待对端c1ose连接的当地端(服务器端)。</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275641013574.jpg" alt=""></p>
<h2 id="IPv4套接字选项"><a href="#IPv4套接字选项" class="headerlink" title="IPv4套接字选项"></a>IPv4套接字选项</h2><p>这些套接字选项由IPv4处理,它们的级别(即 getsockopt和 setsockopt函数的第二个参数)为IPPROTO_IP。</p>
<h3 id="IP-HDRINCL套接字选项"><a href="#IP-HDRINCL套接字选项" class="headerlink" title="IP_HDRINCL套接字选项"></a>IP_HDRINCL套接字选项</h3><p>如果本选项是给一个原始IP套接字设置的,那么我们必须为所有在该原始套接字上发送的数据报构造自己的IP首部。一般情况下,在原始套接字上发送的数据报其IP首部是由内核构造的,不过有些应用程序(特别是路由跟踪程序 traceroute)需要构造自己的IP首部以取代IP置于该首部中的某些字段。</p>
<h3 id="IP-OPTIONS套接字选项"><a href="#IP-OPTIONS套接字选项" class="headerlink" title="IP_OPTIONS套接字选项"></a>IP_OPTIONS套接字选项</h3><p>本选项的设置允许我们在IPv4首部中设置IP选项</p>
<h3 id="IP-RECVDSTADDR套接字选项"><a href="#IP-RECVDSTADDR套接字选项" class="headerlink" title="IP_RECVDSTADDR套接字选项"></a>IP_RECVDSTADDR套接字选项</h3><p>本套接字选项导致所收到UDP数据报的且的IP地址由 recvmsg函数作为辅助数据返回</p>
<h3 id="IP-TOS套接字选项"><a href="#IP-TOS套接字选项" class="headerlink" title="IP_TOS套接字选项"></a>IP_TOS套接字选项</h3><p>本套接字选项允许我们为TCP、UDP或SCTP套接字设置IP首部中的服务类型字段</p>
<h2 id="TCP套接字选项"><a href="#TCP套接字选项" class="headerlink" title="TCP套接字选项"></a>TCP套接字选项</h2><p>TCP有两个套接字选项,它们的级别(即 get_sockopt和 set_sockopt函数的第二个参数)为IPPROTO_TCP。</p>
<h3 id="TCP-MAXSEG套接字选项"><a href="#TCP-MAXSEG套接字选项" class="headerlink" title="TCP_MAXSEG套接字选项"></a>TCP_MAXSEG套接字选项</h3><p>本选项允许我们获取或设置TCP连接的最大分节大小(MSS)。返回值是我们的TCP可以发送给对端的最大数据量,它通常是由对端使用SYN分节通告的MSS,除非我们的TCP选择使用个比对端通告的MSS小些的值。如果该值在相应套接字的连接建立之前取得,那么返回值是未从对端收到MSS选项的情况下所用的默认值。</p>
<h3 id="TCP-NODELAY套接字选项"><a href="#TCP-NODELAY套接字选项" class="headerlink" title="TCP_NODELAY套接字选项"></a>TCP_NODELAY套接字选项</h3><p>开启本选项将禁止TCP的 Nagle算法。默认情况下该算法是启动的。</p>
<p>Nagle算法的目的在于减少广域网(wAN)上小分组的数目。该算法指出:如果某个给定连接上有待确认数据( outstanding data),那么原本应该作为用戶写操作之响应的在该连接上立即发送相应小分组的行为就不会发生,直到现有数据被确认为止。这里“小”分组的定义就是小于MSS的任何分组。TCP总是尽可能地发送最大大小的分组, Nagle算法的目的在于防止一个连接在任何时刻有多个小分组待确认。</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275651499834.jpg" alt=""></p>
<h2 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h2><p>与代表“file control”(文件控制)的名字相符,fcntl函数可执行各种描述符控制操作。</p>
<p>fcntl函数提供了与网络编程相关的如下特性:</p>
<ul>
<li>非阻塞式I/O。通过使用F_SETFL命令设置O_NONBLOCK文件状态标志,我们可以把一个套接字设置为非阻塞型。</li>
<li>信号驱动式I/O。通过使用F_SEFL命令设置o_ASYNC文件状态标志,我们可以把一个套接字设置成一旦其状态发生变化,内核就产生一个SIGIO信号。</li>
<li>F_SETOWN命令允许我们指定用于接收SIGIO和SIGURG信号的套接字属主(进程ID或进程组IO)。其中 SIGIO信号是套接字被设置为信号驱动式I/O型后产生的,SIGURG信号是在新的带外数据到达套接字时产生的。F_GETOWN命令返回套接字的当前属主。</li>
</ul>
<h1 id="基本UDP套接字编程"><a href="#基本UDP套接字编程" class="headerlink" title="基本UDP套接字编程"></a>基本UDP套接字编程</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>在使用TCP编写的应用程序和使用UDP编写的应用程序之间存在一些本质差异,其原因在于这两个传输层之间的差别:UDP是无连接不可靠的数据报协议,非常不同于TCP提供的面向连接的可靠字节流。然而相比TCP,有些场合确实更适合使用UDP</p>
<p>下图给出了典型的UDP客户服务器程序的函数调用。客户不与服务器建立连接,而是只管使用sendto函数给服务器发送数据报,其中必须指定目的地(即服务器)的地址作为参数。类似地,服务器不接受来自客户的连接,而是只管调用 recvfrom函数,等待来自客户的某个数据到达</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275736670682.jpg" alt=""></p>
<h2 id="recvfrom和sendto函数"><a href="#recvfrom和sendto函数" class="headerlink" title="recvfrom和sendto函数"></a>recvfrom和sendto函数</h2><p>这两个函数类似于标准的read和write函数,不过需要三个额外的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags, <span class="keyword">struct</span> sockaddr *from, <span class="keyword">socklen_t</span> *addrlen);</div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *to, <span class="keyword">socklen_t</span> addrlen);</div><div class="line"></div><div class="line"><span class="comment">// Both return: number of bytes read or written if OK, –1 on error</span></div></pre></td></tr></table></figure>
<p>前三个参数<code>sockfd</code>、<code>buff</code>和<code>nbytes</code>等同于read和write函数的三个参数:描述符、指向读入或写出缓冲区的指针和读写字节数</p>
<p>sendto的to参数指向一个含有数据报接收者的协议地址(例如IP地址及端口号)的套接字地址结构,其大小由 addrlen参数指定。 recvfrom的fom参数指向一个将由该函数在返回时填写数据报发送者的协议地址的套接字地址结构,而在该套接字地址结构中填写的字节数则放在addrlen参数所指的整数中返回给调用者。注意, sendto的最后一个参数是一个整数值,而recvfrom的最后一个参数是一个指向整数值的指针(即值-结果参数)。</p>
<h2 id="数据报的丢失"><a href="#数据报的丢失" class="headerlink" title="数据报的丢失"></a>数据报的丢失</h2><p>我们的UDP客户服务器例子是不可靠的。如果一个客户数据报丢失(譬如说,被客户主机与服务器主机之间的某个路由器丢弃),客户将永远阻塞于dg_cli函数中的recvfrom调用,等待一个永远不会到达的服务器应答。类似地,如果客户数据报到达服务器,但是服务器的应答丢失了,客户也将永远阻塞于recvfrom调用。防止这样永久阻塞的一般方法是给客户的recvfrom调用设置一个超时。</p>
<p>但是仅仅给recvfrom调用设置超时并不是完整的解决办法。</p>
<h2 id="UDP的connect函数"><a href="#UDP的connect函数" class="headerlink" title="UDP的connect函数"></a>UDP的connect函数</h2><p>除非套接字已连接,否则异步错误是不会返回到UDP套接字的。我们确实可以给UDP套接字调用 connect(4,3节),然而这样做的结果却与TCP连接大相径庭:没有三路握手过程。内核只是检查是否存在立即可知的错误(例如一个显然不可达的目的地),记录对端的P地址和端口号(取自传递给 connect的套接字地址结构),然后立即返回到调用进程。</p>
<p>对于已连接UDP套接字,与默认的未连接UDP套接字相比,发生了三个变化</p>
<ol>
<li>我们再也不能给输出操作指定目的IP地址和端口号。也就是说,我们不使用sendto,而改用write或send写到已连接UDP套接字上的任何内容都自动发送到由connect指定的协议地址（例如IP地址和端口号）</li>
<li>我们不必使用recvfrom以获悉数据报的发送者,而改用read、recv或recvmsg</li>
<li>由已连接UDP套接字引发的异步错误会返回给它们所在的进程,而未连接UDP套接字不接收任何异步错误。</li>
</ol>
<p><img src="http://data3.liuin.cn/2018-05-29-15275750978867.jpg" alt=""></p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275751182016.jpg" alt=""></p>
<h3 id="给一个UDP套接字多次调用connect"><a href="#给一个UDP套接字多次调用connect" class="headerlink" title="给一个UDP套接字多次调用connect"></a>给一个UDP套接字多次调用connect</h3><p>拥有一个已连接UDP套接字的进程可出于下列两个目的之一再次调用 connect:</p>
<ol>
<li>指定新的IP地址和端口号</li>
<li>断开套接字。</li>
</ol>
<p>第一个目的(即给一个已连接UDP套接字指定新的对端)不同于TCP套接字中 connect的使用:对于TCP套接字, connect只能调用一次。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>当应用进程在一个未连接的UDP套接字上调用sendto时,源自Berkeley的内核暂时连接该套接字,发送数据报,然后断开该连接。在一个未连接的UDP套接字上给两个数据报调用sendto函数于是涉及内核执行下列6个步骤:</p>
<ul>
<li>连接套接字;</li>
<li>输出第一个数据报;</li>
<li>断开套接字连接;</li>
<li>连接套接字;</li>
<li>输出第二个数据报;</li>
<li>断开套接字连接。</li>
</ul>
<p>当应用进程知道自己要给同一目的地址发送多个数据报时,显式连接套接字效率更高。调用 connect后调用两次 write涉及内核执行如下步骤:</p>
<ul>
<li>连接套接字</li>
<li>输出第一个数据报</li>
<li>输出第二个数据报</li>
</ul>
<p>在这种情况下,内核只复制一次含有目的IP地址和端口号的套接字地址结构,相反当调用两次 sendto时,需复制两次。临时连接未连接的UDP套接字大约会耗费每个UDP传输三分之一的开销。</p>
<h1 id="名字与地址转换"><a href="#名字与地址转换" class="headerlink" title="名字与地址转换"></a>名字与地址转换</h1><p>到目前为止,以上所有例子都用数值地址来表示主机,用数值端口号来标识服务器。然而出于许多理由,我们应该使用名字而不是数值:名字比较容易记住;数值地址可以变动而名字保持不变;随着往Iv6上转移,数值地址变得相当长,手工键入数值地址更易出错。</p>
<h2 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h2><p>域名系统( Domain Name System,DNS)主要用于主机名字与IP地址之间的映射。主机名既可以是一个简单名字(simple name),,也可以是一个全限定域名(Fully Qualified Domain Name, FQDN), 比如说www.baidu.com</p>
<h3 id="资源记录"><a href="#资源记录" class="headerlink" title="资源记录"></a>资源记录</h3><p>DNS中记录的条目称为资源记录，主要的有以下几种：</p>
<ul>
<li>A记录把一个主机名映射成一个32位的IPV4地址</li>
<li>AAAA称为“四A”把一个主机名映射成一个128位的Iv6</li>
<li>称为“指针记录”( pointer record)的PTR记录把IP地址映射成主机名</li>
<li>MX记录把一个主机指定作为给定主机的“邮件交换器”</li>
</ul>
<h3 id="解析器和名字服务器"><a href="#解析器和名字服务器" class="headerlink" title="解析器和名字服务器"></a>解析器和名字服务器</h3><p>每个组织机构往往运行一个或多个名字服务器。常见的解析所做的东西就是把主机名映射成IPv4地址和做相反的映射。</p>
<p><img src="http://data3.liuin.cn/2018-06-14-15289459622135.jpg" alt=""></p>
<h3 id="DNS替代方案"><a href="#DNS替代方案" class="headerlink" title="DNS替代方案"></a>DNS替代方案</h3><p>不使用DNS也可能获取名字和地址信息。常用的替代方法有静态主机文件(通常是etc/hosts文件)、网络信息系统( Network Information System,NIS)以及轻权目录访问协议( Lightweight Directory Access Protocol,LDAP)。</p>
<h2 id="gethostbyname函数"><a href="#gethostbyname函数" class="headerlink" title="gethostbyname函数"></a>gethostbyname函数</h2><p>查找主机名最基本的函数是 gethostbyname。如果调用成功,它就返回一个指向 hostent结构的指针,该结构中含有所查找主机的所有IPv4地址。这个函数的局限是只能返回IPv4地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> hostent *<span class="title">gethostbyname</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *hostname)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: non-null pointer if OK,NULL on error with h_errno se</span></div></pre></td></tr></table></figure>
<p>hostent的数据结构如下：</p>
<p><img src="http://data3.liuin.cn/2018-06-14-15289462083765.jpg" alt=""></p>
<p><img src="http://data3.liuin.cn/2018-06-14-15289462760527.jpg" alt=""></p>
<p>gethostbyname执行的是对A记录的查询，所以只能够返回IPv4的地址</p>
<h2 id="gethostbyaddr函数"><a href="#gethostbyaddr函数" class="headerlink" title="gethostbyaddr函数"></a>gethostbyaddr函数</h2><p>gethostbyaddr的功能刚好和gethostbyname相反，试图由一个二进制的IP地址找到相应的主机名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> hostent *<span class="title">gethostbyaddr</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">socklen_t</span> len, <span class="keyword">int</span> family)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: non-null pointer if OK, NULL on error with h_errno set</span></div></pre></td></tr></table></figure>
<h2 id="getservbyname和-getservbyport函数"><a href="#getservbyname和-getservbyport函数" class="headerlink" title="getservbyname和 getservbyport函数"></a>getservbyname和 getservbyport函数</h2><p>像主机一样,<strong>服务也通常靠名字来认知</strong>。如果我们在程序代码中通过其名字而不是其端口号来指代一个服务,而且从名字到端口号的映射关系保存在一个文件中(通常是/etc/services),那么即使端口号发生变动,我们需修改的仅仅是/etc/services文件中的某行,而不必重新编译应用程序。</p>
<p>getservtbyname函数用于根据给定名字查找相应服务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> servent *<span class="title">getservbyname</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *servname, <span class="keyword">const</span> <span class="keyword">char</span> *protoname)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: non-null pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
<p>返回的servent结构：</p>
<p><img src="http://data3.liuin.cn/2018-06-14-15289465680796.jpg" alt=""></p>
<p>服务名参数 servname必须指定。如果同时指定了协议(即protoname参数为非空指针),那么指定服务必须有匹配的协议。有些因特网服务既用TCP也用UDP提供,其他因特网服务则仅仅支持单个协议(例如FTP要求使用TCP)。如果 protoname未指定而 servname指定服务支持多个协议,那么返回哪个端口号取决于实现。</p>
<p>getservbyport用于根据给定端口号和可选协议査找相应服务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> servent *<span class="title">getservbyport</span> <span class="params">(<span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *protoname)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: non-null pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UNIX网络编程必读书籍——《UNIX网络编程卷1》  基本套接字编程 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://www.liuin.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>《STL源码剖析》 笔记</title>
    <link href="https://www.liuin.cn/2018/05/20/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B-%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.liuin.cn/2018/05/20/《STL源码剖析》-笔记/</id>
    <published>2018-05-20T00:52:59.000Z</published>
    <updated>2018-05-29T06:35:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>侯捷老师的《STL源码剖析》可谓是学习STL的经典。在书籍的自序中侯捷老师提到的”我的确认为99.99%的程序员所写的程序，在SGI STL面前都是三流水平“，这让我等菜鸟根本把持不住呀。</p>
<a id="more"></a>
<h1 id="空间配置其（allocator）"><a href="#空间配置其（allocator）" class="headerlink" title="空间配置其（allocator）"></a>空间配置其（allocator）</h1><p>以STL的运用角度而言，空间配置器是最不需要介绍的东西，它总是隐藏在切组件(更具体地说是指容器， container)的背后，默默工作，默默付出。但若以STL的实现角度而言，第一个需要介绍的就是空间配置器，因为整个<strong>STL的操作对象(所有的数值)都存放在容器之内</strong>，而容器一定需要配置空间以置放资料不先掌握空间配置器的原理，难免在阅读其它STL组件的实现时处处遇到挡路石。</p>
<h2 id="空间配置器的标准接口"><a href="#空间配置器的标准接口" class="headerlink" title="空间配置器的标准接口"></a>空间配置器的标准接口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">allocator::value_type</div><div class="line">allocator::pointer</div><div class="line">allocator::const_pointer</div><div class="line">allocator::reference</div><div class="line">allocator::const_reference</div><div class="line">allocator::sieze_type</div><div class="line">allocator::defference_type</div><div class="line"><span class="comment">// 一个嵌套的(nested) class template。 class rebind&lt;U&gt;拥有唯一成员other，那是一个 typedef，代表allocator&lt;U&gt;</span></div><div class="line">allocator::rebind</div><div class="line"><span class="comment">// default constructor</span></div><div class="line">allocator::allocator()</div><div class="line"><span class="comment">// copy constructor</span></div><div class="line">allocator::allocator(<span class="keyword">const</span> allocator&amp;)</div><div class="line"><span class="comment">// 泛化的 copy constructor</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;allocator::allocator(<span class="keyword">const</span> allocator&lt;U&gt;&amp;)</div><div class="line"><span class="comment">// 默认析构</span></div><div class="line">allocator::~allocator()</div><div class="line"><span class="comment">// 返回某个对象的地址</span></div><div class="line">pointer allocator::address(reference x) <span class="keyword">const</span></div><div class="line"><span class="comment">// 返回某个const对象的地址</span></div><div class="line">const_pointer allocator::address(const_reference x) <span class="keyword">const</span></div><div class="line"><span class="comment">// 配置空间，足以存储n个T对象</span></div><div class="line">pointer allocator::allocate(size_type n， <span class="keyword">const</span> <span class="keyword">void</span>* = <span class="number">0</span>)</div><div class="line"><span class="comment">// 归还先前配置的空间</span></div><div class="line"><span class="keyword">void</span> allocator::deallocate(pointer p， size_type n)</div><div class="line"><span class="comment">// 返回可成功配置的最大量</span></div><div class="line">size_type allocator::max_size() <span class="keyword">const</span></div><div class="line"><span class="comment">// 等同于 new(const void*) p) T(x)</span></div><div class="line"><span class="keyword">void</span> allocator::construct(pointer p， <span class="keyword">const</span> T&amp; x)</div><div class="line"><span class="comment">// 等同于 p-&gt;~T()</span></div><div class="line"><span class="keyword">void</span> allocator::destory(pointer p)</div></pre></td></tr></table></figure>
<h2 id="具备次配置力-sub-allocation-的SGI空间配置器"><a href="#具备次配置力-sub-allocation-的SGI空间配置器" class="headerlink" title="具备次配置力(sub-allocation)的SGI空间配置器"></a>具备次配置力(sub-allocation)的SGI空间配置器</h2><p>SGI STI的配置器与众不同，也与标准规范不同，其名称是a1loc而非allocator，而且不接受任何参数。</p>
<h3 id="SGI的标准空间配置器，std-allocator"><a href="#SGI的标准空间配置器，std-allocator" class="headerlink" title="SGI的标准空间配置器，std::allocator"></a>SGI的标准空间配置器，std::allocator</h3><p>虽然SGI也定义有一个符合部分标准、名为allocator的配置器，但SGI自己从未用过它，也不建议我们使用。主要原因是效率不佳，只把C++的<code>::operator new</code>和<code>::operator delete</code>做一层薄薄的包装而已。</p>
<h3 id="SGI特殊的空间配置器，std-alloc"><a href="#SGI特殊的空间配置器，std-alloc" class="headerlink" title="SGI特殊的空间配置器，std::alloc"></a>SGI特殊的空间配置器，std::alloc</h3><p>一般而言，我们所习惯的C++内存配置操作和释放操作是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Foo &#123; ... &#125;;</div><div class="line"></div><div class="line">Foo* pf = <span class="keyword">new</span> Foo;</div><div class="line"><span class="keyword">delete</span> pf;</div></pre></td></tr></table></figure>
<p>这其中的new算式内含两阶段操作(1)调用:: operator new配置内存;(2)调用Foo::Foo()构造对象内容。<br>delete算式也内含两阶段操作:(1)调用Foo::~FOO()将对象析构:(2)调用::operator delete释放内存</p>
<p>为了精密分工， STL allocator决定将这两阶段操作区分开来。内存配置操作由a11c:allocate()负责，内存释放操作由alloc::deallocate()负责对象构造操作由::construct()负责，对象析构操作由::destroy()负责。</p>
<p>配置器定义在<memory>中，SGI<memory>的主要组成如下：</memory></memory></p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270395375460.jpg" alt=""></p>
<h3 id="构造和析构基本工具-construct-和-destroy"><a href="#构造和析构基本工具-construct-和-destroy" class="headerlink" title="构造和析构基本工具: construct()和 destroy()"></a>构造和析构基本工具: construct()和 destroy()</h3><p><img src="https://data2.liuin.cn/2018-05-23-15270396596949.jpg" alt=""></p>
<h3 id="空间的配置与释放"><a href="#空间的配置与释放" class="headerlink" title="空间的配置与释放"></a>空间的配置与释放</h3><p>对象构造前的空间配置和对象析构后的空间释放，由<stla1loc.h>负责，SGI对此的设计哲学如下:</stla1loc.h></p>
<ul>
<li>向 system heap要求空间</li>
<li>考虑多线程( multi-threads)状态</li>
<li>考虑内存不足时的应变措施</li>
<li>考虑过多“小型区块”可能造成的内存碎片( fragment)问题</li>
</ul>
<p>考虑到小型区块所可能造成的内存破碎问题，SGI设计了<strong>双层级配置器</strong>：</p>
<p>第一级配置器直接使用malloc()和free()，第二级配置器则视情况采用不同的策略:当配置区块超过128 bytes时，视之为“足够大”，便调用第一级配置器;<strong>当配置区块小于128 bytes时，视之为“过小”，为了降低额外负担，便采用复杂的memory pool整理方式，而不再求助于第一级配置器</strong>。整个设计究竟只开放第一级配置器，或是同时开放第二级配置器</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270402949330.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270403004835.jpg" alt=""></p>
<h3 id="第一级配置器"><a href="#第一级配置器" class="headerlink" title="第一级配置器"></a>第一级配置器</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">template &lt;int inst&gt;</div><div class="line">class __malloc_alloc_template &#123;</div><div class="line">private:</div><div class="line">//malloc调用内存不足时调用函数</div><div class="line">static void *oom_malloc(size_t);</div><div class="line">//realloc调用内存不足时调用函数</div><div class="line">static void *oom_realloc(void *, size_t);</div><div class="line">//错误处理函数，类似C++的set_new_handler，默认值为０，如果不设置，则内存分配失败时，返回THROW_BAD_ALLOC</div><div class="line">#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG</div><div class="line">    static void (* __malloc_alloc_oom_handler)();</div><div class="line">#endif</div><div class="line">public:</div><div class="line">static void * allocate(size_t n)</div><div class="line">&#123;</div><div class="line">    void *result = malloc(n);	第一级配置器直接使用malloc分配内存</div><div class="line">    if (0 == result) result = oom_malloc(n);//如果分配失败，则调用oom_malloc()</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line">static void deallocate(void *p, size_t /* n */)</div><div class="line">&#123;</div><div class="line">    free(p);	//第一级配置器用free回收内存</div><div class="line">&#125;</div><div class="line">static void * reallocate(void *p, size_t /* old_sz */, size_t new_sz)</div><div class="line">&#123;</div><div class="line">    void * result = realloc(p, new_sz);	//第一级配置器用reallocate重分配内存</div><div class="line">    if (0 == result) result = oom_realloc(p, new_sz);／／分配失败，调用oom_realloc分配</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line">// 设置分配错误处理函数，用于在oom_malloc和oom_realloc中使用</div><div class="line">static void (* set_malloc_handler(void (*f)()))()</div><div class="line">&#123;</div><div class="line">    void (* old)() = __malloc_alloc_oom_handler;</div><div class="line">    __malloc_alloc_oom_handler = f;</div><div class="line">    return(old);</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">template &lt;int inst&gt;</div><div class="line">void * __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n)</div><div class="line">&#123;</div><div class="line">    void (* my_malloc_handler)();//声明一个函数指针，用于赋值 __malloc_alloc_oom_handler</div><div class="line">    void *result;//返回的内存指针</div><div class="line">    for (;;) &#123;	// 不断尝试释放内存，分配，再释放，再分配...</div><div class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</div><div class="line">        if (0 == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;//为设置处理函数时，抛出错误</div><div class="line">        (*my_malloc_handler)();		// 调用处理函数，尝试释放内存</div><div class="line">        result = malloc(n);			// 再重新分配内存。</div><div class="line">        if (result) return(result);//如果分配成功，返回指针</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">template &lt;int inst&gt;</div><div class="line">void * __malloc_alloc_template&lt;inst&gt;::oom_realloc(void *p, size_t n)</div><div class="line">&#123;</div><div class="line">    void (* my_malloc_handler)();</div><div class="line">    void *result;</div><div class="line">    for (;;) &#123;	// 不断尝试释放内存，分配，再释放，再分配...</div><div class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</div><div class="line">        if (0 == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;////为设置处理函数时，抛出错误</div><div class="line">        (*my_malloc_handler)();	//  调用处理函数，尝试释放内存</div><div class="line">        result = realloc(p, n);	// 再重新分配内存。</div><div class="line">        if (result) return(result);////如果分配成功，返回指针</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一级配置器以malloc(),free(), realloc()等C函数执行实际的内存配置、释放、重配置操作,并实现出类似C++ new-handler 的机制。所谓C++ new handler机制是,你可以要求系统在内存配置需求无法被满足时,调用一个你所指定的函数。</p>
<p>SGI第一级配置器的allocate()和 realloc()都是在调用ma11oc()和rea11oc()不成功后,改调用 oom_ma11oc()和oom_realloc()。后两者都有内循环,不断调用“内存不足处理例程”,期望在某次调用之后,获得足够的内存而圆满完成任务。</p>
<h3 id="第二级配置器"><a href="#第二级配置器" class="headerlink" title="第二级配置器"></a>第二级配置器</h3><p>第二级配置器多了一些机制,避免太多小额区块造成内存的碎片。小额区块带来的其实不仅是内存碎片,配置时的额外负担(overhead)也是一个大问题。额外负担永远无法避免,毕竟系统要靠这多出来的空间来管理内存。但是区块愈小,额外负担所占的比例就愈大,愈显得浪费</p>
<p>SGI第二级配置器的做法是,如果区块够大,超过128 bytes时,就移交第级配置器处理。当区块小于128 bytes时,则以内存池( memory pool)管理,此法又称为次层配置(sub-allocation):每次配置一大块内存,并维护对应之自由链表(free-list)。下次若再有相同大小的内存需求,就直接从free-lists中拨出。如果客端释还小额区块,就由配置器回收到free-lists中——是的,别忘了,配置器除了负责配置,也负责回收。</p>
<p>为了方便管理,SGl第二级配置器会主动将任何小额区块的内存<strong>需求量上调至8的倍数</strong>(例如客端要求30 bytes,就自动调整为32 bytes)并维护16个free-lists,各自管理大小分别为8,16,24,32,40,48,56,64,72,80,88,96,104,l12,120,128 bytes的小额区块。 </p>
<p>free-lists的节点结构如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> obj &#123;</div><div class="line">      <span class="keyword">union</span> obj * free_list_link;<span class="comment">//指向下一个内存的地址</span></div><div class="line">      <span class="keyword">char</span> client_data[<span class="number">1</span>];    <span class="comment">//内存的首地址</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><img src="https://data2.liuin.cn/2018-05-23-15270421196298.jpg" alt=""></p>
<h1 id="迭代器概念与traits编程技法"><a href="#迭代器概念与traits编程技法" class="headerlink" title="迭代器概念与traits编程技法"></a>迭代器概念与traits编程技法</h1><p>在设计模式中有一种迭代器模式，其定义如下：提供一种方法，使之能够依序巡访某个聚合物(容器)所含的各个元素，而又无需暴露该聚合物的内部表述方式</p>
<h2 id="迭代器设计思维——STL关键所在"><a href="#迭代器设计思维——STL关键所在" class="headerlink" title="迭代器设计思维——STL关键所在"></a>迭代器设计思维——STL关键所在</h2><p>STL的中心思想在于:将数据容器( containers)和算法 algorithms)分开，彼此独立设计，最后再以一帖胶着剂将它们撮合在一起。容器和算法的泛型化，从技术角度来看并不困难，C++的class templates和 function templates可分别达成目标。如何设计出两者之间的良好胶着剂，才是大难题</p>
<h2 id="迭代器是一种smart-pointer"><a href="#迭代器是一种smart-pointer" class="headerlink" title="迭代器是一种smart pointer"></a>迭代器是一种smart pointer</h2><p>迭代器是一种行为类似指针的对象，而指针的各种行为中最常见也最重要的便是内容提领(dereference)和成员访问( member access)，因此，迭代器最重要的编程工作就是对 operator*和 operator-&gt;进行重载( overloading)工作。</p>
<p>在设计实现每一个容器的迭代器的时候都会暴露许多这些容器的一些实现细节的东西，要设计出 LIstitem，首先必须对List的实现细节有非常丰富的了解。既然这无可避免，干脆就把迭代器的开发工作交给List的设计者好了，如此一来，所有实现细节反而得以封装起来不被使用者看到。<strong>这正是为什么每一种STL容器都提供有专属迭代器的缘故</strong></p>
<h2 id="迭代器相应的型别"><a href="#迭代器相应的型别" class="headerlink" title="迭代器相应的型别"></a>迭代器相应的型别</h2><p>迭代器中相应的型别之一是迭代器所指之物的型别</p>
<p>迭代器相应型别(associated types)不只是“迭代器所指对象的型别”一种而已。根据经验，最常用的相应型别有五种，然而并非任何情况下任何一种都可利用上述的 template参数推导机制来取得.我们需要更全面的解法</p>
<h1 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h1><h2 id="容器的概观与分类"><a href="#容器的概观与分类" class="headerlink" title="容器的概观与分类"></a>容器的概观与分类</h2><p>研究数据的特定排列方式，以利于搜寻或排序或其它特殊目的，这一专门学科我们称为数据结构( Data Structures)。大学信息类相关教育里面，与编程最有直接关系的科目，首推数据结构与算法( Algorithms)。几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。STL容器即是将运用最广的一些数据结构实现出来</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267795512022.jpg" alt=""></p>
<blockquote>
<p>序列式容器</p>
</blockquote>
<p>所谓序列式容器，其中的<strong>元素都可序( ordered)，但未必有序( sorted)</strong>。C++语言本身提供了一个序列式容器 array，STL另外再提供 vector， list， deque， stack， queue， priority-queue等等序列式容器。其中 stack和 queue由于只是将 deque改头换面而成，技术上被归类为一种配接器( adapter)</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="vector-概述"><a href="#vector-概述" class="headerlink" title="vector 概述"></a>vector 概述</h3><p>vector的数据安排以及操作方式，与 array非常相似。两者的唯一差别在于空间的运用的灵活性。 array是静态空间，一旦配置了就不能改变，如果需要更多的空间需要用户自己解决。vector是动态空间，随着元素的加人，它的内部机制会自行扩充空间以容纳新元素。因此， vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必因为害怕空间不足而开始就要求一个大块头 array了，我们可以安心使用 vector，吃多少用多少</p>
<h3 id="vector-迭代器"><a href="#vector-迭代器" class="headerlink" title="vector 迭代器"></a>vector 迭代器</h3><p>vector维护的是一个连续线性空间，所以不论其元素型别为何，<strong>普通指针都可以作为 vector的迭代器而满足所有必要条件</strong>，因为 vector迭代器所需要的操作行为普通指针天生就具备。 vector支持随机存取，而普通指针正有着这样的能力。所以， vector提供的是 Random Access Iterators。</p>
<h3 id="vector-的数据结构"><a href="#vector-的数据结构" class="headerlink" title="vector 的数据结构"></a>vector 的数据结构</h3><p>vector所采用的数据结构非常简单:线性连续空间。它以两个迭代器 start和 finish分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器end_of_storage指向整块连续空间(含备用空间)的尾端</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T， <span class="keyword">class</span> Alloc = alloc&gt;</div><div class="line"><span class="keyword">class</span> <span class="built_in">vector</span>&#123;</div><div class="line">...</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    iterator start;</div><div class="line">    iterator finish;</div><div class="line">    iterator end_of_storage;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了降低空间配置时的速度成本， vector实际配置的大小可能比客户端需求量更大一些，以备将来可能的扩充。这便是容量( capacity)的观念。换句话说个 vector的容量永远大于或等于其大小。一旦容量等于大小，便是满载，下次再有新增元素，整个 vector就得另觅居所</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267802557974.jpg" alt=""></p>
<h3 id="vector-的构造和内存管理"><a href="#vector-的构造和内存管理" class="headerlink" title="vector 的构造和内存管理"></a>vector 的构造和内存管理</h3><p>当我们以 push_back()将新元素插入于 vector尾端时，该函数首先检查是否还有备用空间，如果有就直接在备用空间上构造元素，并调整迭代器 finish，使vector变大。如果没有备用空间了，就扩充空间(重新配置、移动数据、释放原空间)</p>
<p>注意，所谓动态增加大小，并不是在原空间之后接续新空间(因为无法保证原空间之后尚有可供配置的空间)，而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此对 vector的任何操作，<strong>一旦引起空间重新配置，指向原 vector的所有迭代器就都失效了</strong>。这是程序员易犯的一个错误，务需小心</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="list-概述"><a href="#list-概述" class="headerlink" title="list 概述"></a>list 概述</h3><p>相较于vector的连续线性空间，list就显得复杂许多，它的好处是每次插人或删除一个元素，就配置或释放一个元素空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素移除，list永远是常数时间。</p>
<p>list和 vector是两个最常被使用的容器。什么时机下最适合使用哪一种容器，必须视元素的多寡、元素的构造复杂度、元素存取行为的特性而定。</p>
<h3 id="list的节点-node"><a href="#list的节点-node" class="headerlink" title="list的节点(node)"></a>list的节点(node)</h3><p>list的节点是一个典型的双向链表的结构</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267809077014.jpg" alt=""></p>
<h3 id="list的迭代器"><a href="#list的迭代器" class="headerlink" title="list的迭代器"></a>list的迭代器</h3><p>list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在储存空间中连续存在。list迭代器必须有能力指向list的节点，并有能力进行正确的递增、递减、取值、成员存取等操作。</p>
<p>由于STL list是一个双向链表(double linked-ist)，迭代器必须具备前移后移的能力，所以list提供的是 Bidirectional iteratorslist</p>
<p>有一个重要性质:插入操作( insert)和接合操作( splice)都不会造成原有的list迭代器失效。这在 vector是不成立的，因为 vector的插人操作可能造成内存的重新配置，导致原有的迭代器全部失效。甚至list的元素删除操作( erase)，也只有“指向被删除元素”的那个迭代器失效，其它迭代器不受任何影响</p>
<h3 id="list的数据结构"><a href="#list的数据结构" class="headerlink" title="list的数据结构"></a>list的数据结构</h3><p>SGL list不仅是一个双向链表，而且还是一个环状双向链表。所以它只需要个指针，便可以完整表现整个链表</p>
<p>如果让指针node指向刻意置于尾端的一个空白节点，node便能符合STL对于“前闭后开”区间的要求，成为1ast迭代器，如图所示</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267812961833.jpg" alt=""></p>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><h3 id="deque概述"><a href="#deque概述" class="headerlink" title="deque概述"></a>deque概述</h3><p>vector是单向开口的连续线性空间， deque则是一种双向开口的连续线性空间。所谓双向开口，意思是<strong>可以在头尾两端分别做元素的插入和删除操作</strong>。 vector当然也可以在头尾两端进行操作(从技术观点)，但是其头部操作效率奇差，无法被接受</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267815267741.jpg" alt=""></p>
<p>deque和 vector的最大差异，一在于deque允许于常数时间内对起头端进行元素的插入或移除操作，二在于 deque没有所谓容量( capacity)观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。换句话说，像 vector那样“因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在 deque是不会发生的。也因此， deque没有必要提供所谓的空间保留( reserve)功能</p>
<p>虽然 deque也提供 Ramdon Access iterator，但<strong>它的迭代器并不是普通指针，其复杂度和 vector不可以道里计</strong>(稍后看到源代码，你便知道)，这当然影响了各个运算层面。因此，除非必要，我们应尽可能选择使用 vector而非 deque</p>
<h3 id="deque的中控器"><a href="#deque的中控器" class="headerlink" title="deque的中控器"></a>deque的中控器</h3><p>deque是连续空间(至少逻辑上看来如此)，连续线性空间总令我们联想到array或 vector。 array无法成长， vector虽可成长，却只能向尾端成长，而且其所谓成长原是个假象，事实上是(1)另觅更大空间;(2)将原数据复制过去;(3)释放原空间三部曲。如果不是 <strong>vector每次配置新空间时都有留下一些余裕，其成长”假象所带来的代价将是相当高昂</strong></p>
<p>deque系由一段一段的定量连续空间构成。一旦有必要在 deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个 deque的头端或尾端deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象并提供随机存取的接口·避开了“重新配置、复制、释放”的轮回，<strong>代价则是复杂的迭代器架构</strong></p>
<p>受到分段连续线性空间的字面影响，我们可能以为 deque的实现复杂度和vector相比虽不中亦不远矣，其实不然。主要因为，既日<strong>分段连续线性空间，就必须有中央控制，而为了维持整体连续的假象，数据结构的设计及迭代器前进后退等操作都颇为繁琐</strong>。 deque的实现代码分量远比 vector或list都多得多</p>
<p>deque采用一块所谓的mqp(注意，不是STL的map容器)作为主控。这里所谓map是一小块连续空间，其中每个元素(此处称为一个节点，node)都是指针，指向另一段(较大的)连续线性空间，称为缓冲区。缓冲区才是 deque的储存空间主体。 </p>
<p>把令人头皮发麻的各种型别定义(为了型别安全，那其实是有必要的)整理下，我们便可发现，map其实是一个T**，也就是说它是一个指针，所指之物又是个指针，指向型别为T的一块空间，如图所示</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267828260370.jpg" alt=""></p>
<h3 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h3><p>deque是分段连续空间。维持其“整体连续”假象的任务，落在了迭代器的operator++和operator–两个运算子身上</p>
<p>让我们思考一下， deque迭代器应该具备什么结构。首先，它必须能够<strong>指出分段连续空间(亦即缓冲区)在哪里，其次它必须能够判断自己是否已经处于其所在缓冲区的边缘</strong>，如果是，一旦前进或后退时就必须跳跃至下一个或上一个缓冲区为了能够正确跳跃， deque必须<strong>随时掌握管控中心</strong>(map)。</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267830496256.jpg" alt=""></p>
<h3 id="deque的数据结构"><a href="#deque的数据结构" class="headerlink" title="deque的数据结构"></a>deque的数据结构</h3><p>deque除了维护一个先前说过的指向map的指针外，也维护 start，fini两个迭代器，分别指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素(的下一位置)。此外，它当然也必须记住目前的mqp大小。因为一旦mqp所提供的节点不足，就必须重新配置更大的一块map</p>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><h3 id="stack-概述"><a href="#stack-概述" class="headerlink" title="stack 概述"></a>stack 概述</h3><p>stack是一种先进后出( First In last out，FILO)的数据结构。它只有一个出口，形式如图4-18所示。 stack允许新增元素、移除元素、取得最顶端元素。但除了最顶端外，没有任何其它方法可以存取 stack的其它元素。换言之， stack不允许有遍历行为</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267835939355.jpg" alt=""></p>
<h3 id="stack-定义完整列表"><a href="#stack-定义完整列表" class="headerlink" title="stack 定义完整列表"></a>stack 定义完整列表</h3><p>以某种既有容器作为底部结构，将其接口改变，使之符合“先进后出”的特性，形成一个 stack，是很容易做到的， deque是双向开口的数据结构，若以dequ为底部结构并封闭其头端开口，便轻而易举地形成了一个 stack。因此， SGI STI便以 deque作为缺省情况下的 stack底部结构， stack的实现因而非常简单，源代码十分简短，本处完整列出</p>
<p>由于 stack系以底部容器完成其所有工作，而具有这种“修改某物接口，形成另一种风貌”之性质者，称为 adapter(配接器)，因此STL stack往往不被归类为 container(容器)，而被归类为 container adapter</p>
<h3 id="stack-没有迭代器"><a href="#stack-没有迭代器" class="headerlink" title="stack 没有迭代器"></a>stack 没有迭代器</h3><p>stack所有元素的进出都必须符合“先进后出”的条件，只有 stack顶端的元素，才有机会被外界取用。 stack不提供走访功能，也不提供迭代器</p>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h3 id="queue概述"><a href="#queue概述" class="headerlink" title="queue概述"></a>queue概述</h3><p>queue是一种先进先出( First In First Out，FIFO)的数据结构。它有两个出口。 queue允许新增元素、移除元素、从最底端加入元素、取得最顶端元素。但除了最底端可以加入、最顶端可以取出外，没有任何其它方法可以存取 queue的其它元素。换言之， queue不允许有遍历行为。</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267838406632.jpg" alt=""></p>
<h3 id="queue定义完整列表"><a href="#queue定义完整列表" class="headerlink" title="queue定义完整列表"></a>queue定义完整列表</h3><p>以某种既有容器为底部结构，将其接口改变，使其符合“先进先出”的特性形成一个 queue，是很容易做到的. deque是双向开口的数据结构，若以 deque为底部结构并封闭其底端的出口和前端的入口，便轻而易举地形成了一个 queue。因此， SGI STL便以 deque作为缺省情况下的 queue底部结构。</p>
<h3 id="queue没有迭代器"><a href="#queue没有迭代器" class="headerlink" title="queue没有迭代器"></a>queue没有迭代器</h3><p>queue所有元素的进出都必须符合“先进先出”的条件，只有 queue顶端的元素，才有机会被外界取用。 queue不提供遍历功能，也不提供迭代器</p>
<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><h3 id="heap概述"><a href="#heap概述" class="headerlink" title="heap概述"></a>heap概述</h3><p>heap并不归属于STL容器组件，它是个幕后英雄，扮演 priority queue的助手。顾名思义， priority queue允许用户以任何次序将任何元素推入容器内，但取出时一定是从优先权最高(也就是数值最高)的元素开始取。 binary max heap正是具有这样的特性，适合作为 priority queue的底层机制</p>
<p>如果使用list作为 priority queue的底层机制，元素插入操作可享常数时间。但是要找到list中的极值，却需要对整个list进行线性扫描。我们也可以改变做法，让元素插入前先经过排序这一关，使得list的元素值总是由小到大(或由大到小)，但这么一来，收之东隅却失之桑榆:虽然取得极值以及元素删除操作达到最高效率，可元素的插人却只有线性表现</p>
<p>比较麻辣的做法是以 binary search tree作为 prlorltyqueue的底层机制。这么一来，元素的插入和极值的取得就有O(logN)的表现但杀鸡用牛刀，未免小题大做，一来 binary search tree的输人需要足够的随机性，二来 binary search tree并不容易实现。 </p>
<p>比较适合的是binary heap的方案，所谓 binary heap就是一种 complete binary tree(完全二叉树)，也就是说，整棵 binary tree除了最底层的叶节点之外，是填满的，而最底层的叶节点(s)由左至右又不得有空隙。</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267842482184.jpg" alt=""></p>
<p>这么一来，我们需要的工具就很简单了:一个 array和一组heap算法(用来插入元素、删除元素、取极值，将某一整组数据排列成一个heap)</p>
<h3 id="heap算法"><a href="#heap算法" class="headerlink" title="heap算法"></a>heap算法</h3><h4 id="push-heap-算法"><a href="#push-heap-算法" class="headerlink" title="push_heap 算法"></a>push_heap 算法</h4><p><img src="https://data2.liuin.cn/2018-05-20-15267844079830.jpg" alt=""></p>
<h4 id="pop-heap-算法"><a href="#pop-heap-算法" class="headerlink" title="pop_heap 算法"></a>pop_heap 算法</h4><p><img src="https://data2.liuin.cn/2018-05-20-15267844125899.jpg" alt=""></p>
<h4 id="sort-heap-算法"><a href="#sort-heap-算法" class="headerlink" title="sort_heap 算法"></a>sort_heap 算法</h4><p>堆排序思想，不断对heap进行pop操作，达到排序效果</p>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><h3 id="priority-queue概述"><a href="#priority-queue概述" class="headerlink" title="priority_queue概述"></a>priority_queue概述</h3><p>顾名思义， priority_queue是一个拥有权值观念的 queue，它允许加人新元素、移除旧元素、审视元素值等功能。由于这是一个 queue，所以只允许在底端加入元素，并从顶端取出元素，除此之外别无其它存取元素的途径</p>
<p>priority_queue带有权值观念，其内的元素并非依照被推入的次序排列，而是自动依照元素的权值排列(通常权值以实值表示)。权值最高者，排在最前面</p>
<p>缺省情况下 priority_queue系利用一个max-heap完成，后者是一个以vector表现的 complete binary tree。max-heap可以满足priority_queue所需要的“依权值高低自动递增排序”的特性。</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267846191674.jpg" alt=""></p>
<h3 id="priority-queue定义完整列表"><a href="#priority-queue定义完整列表" class="headerlink" title="priority_queue定义完整列表"></a>priority_queue定义完整列表</h3><p>由于 priority-queue完全以底部容器为根据，再加上heap处理规则，所以其实现非常简单。缺省情况下是以 vector为底部容器。</p>
<p>queue以底部容器完成其所有工作。具有这种“修改某物接口，形成另一种风貌”之性质者，称为 adapter(配接器)，因此， STL prior1ty_ queue往往不被归类为 container(容器)，而被归类为 container adapter</p>
<h3 id="priority-queue没有迭代器"><a href="#priority-queue没有迭代器" class="headerlink" title="priority_queue没有迭代器"></a>priority_queue没有迭代器</h3><p>priority-queue的所有元素，进出都有一定的规则，只有 queue顶端的元素(权值最高者)，才有机会被外界取用。 priority_queue不提供遍历功能，也不提供迭代器。</p>
<h1 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h1><p>标准的STL关联式容器分为set(集合)和map(映射表)两大类，以及这两大类的衍生体 multiset(多键集合)和multimap(多键映射表)。这些容器的底层机制均以RB-tree(红黑树)完成。RB-tree也是一个独立容器，但并不开放给外界使用</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15268607936529.jpg" alt=""></p>
<p>所谓关联式容器，观念上类似关联式数据库(实际上则简单许多):每笔数据(每个元素)都有一个键值(key)和一个实值( value)。当元素被插人到关联式容器中时，容器内部结构(可能是RB-tree，也可能是hash-tab1e)便依照其键值大小，以某种特定规则将这个元素放置于适当位置.关联式容器没有所谓头尾(只有最大元素和最小元素)</p>
<h2 id="RB-tree（红黑树）"><a href="#RB-tree（红黑树）" class="headerlink" title="RB-tree（红黑树）"></a>RB-tree（红黑树）</h2><p>AVL-tree之外，另一个颇具历史并被广泛运用的平衡二又搜索树是RB-tree(红黑树)。所谓RB-tree，不仅是一个二叉搜索树，而且必须满足以下规则</p>
<ol>
<li>每个节点不是红色就是黑色</li>
<li>根节点为黑色</li>
<li>如果节点为红，其子节点必须为黑</li>
<li>任一节点至NULL(树尾端)的任何路径，所含之黑节点数必须相同</li>
</ol>
<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p>当插入一个新节点的时候，就会导致红黑树上面的规则被破坏。这个时候就要进行调整，其中包括了四种情况：</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15268627862296.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-21-15268628337631.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-21-15268628547016.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-21-15268628574449.jpg" alt=""></p>
<h3 id="RB-tree的元素操作"><a href="#RB-tree的元素操作" class="headerlink" title="RB-tree的元素操作"></a>RB-tree的元素操作</h3><p>RB-tree提供两种插入操作:insert_unique()和 insert_equal()，前者表示被插入节点的键值(key)在整棵树中必须独一无二(因此，如果树中已存在相同的键值，插入操作就不会真正进行)，后者表示被插入节点的键值在整棵树中可以重复，因此，无论如何插入都会成功(除非空间不足导致配置失败)。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set的特性是，所有元素都会根据元素的键值自动被排序。set的元素不像map那样可以同时拥有实值( value)和键值(key)，set元素的键值就是实值实值就是键值。<strong>set不允许两个元素有相同的键值</strong></p>
<p>我们可以通过set的迭代器改变set的元素值吗?不行，因为set元素值就是其键值，关系到set元素的排列规则。如果任意改变set元素值，会严重破坏set组织。set iterators是一种constant iterators(相对于 mutable iterators)</p>
<p>set拥有与1ist相同的某些性质:当<strong>客户端对它进行元素新增操作( insert)或删除操作( erase)时，操作之前的所有迭代器，在操作完成之后都依然有效</strong>。当然，被删除的那个元素的迭代器必然是个例外</p>
<p>由于RB-tree是一种平衡二叉搜索树，自动排序的效果很不错，所以标准的STL set即以RB-tree为底层机制。又由于set所开放的各种操作接口，RB-tree也都提供了，所以几乎所有的set操作行为，都只是转调用RB→tree的操作行为而已</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map的特性是，所有元素都会根据元素的键值自动被排序。map的所有元素都是pair，同时拥有实值( value)和键值(key)。pair的第一元素被视为键值第二元素被视为实值.map不允许两个元素拥有相同的键值。</p>
<p>可以通过map的迭代器修改value的值，但是不能更改key的值，因为修改key会破坏map的组织结构。因此， map iterators既不是一种constant iterators，也不是一种 mutable iterators</p>
<p>map拥有和1ist相同的某些性质:当客户端对它进行元素新增操作或删除操作时，操作之前的所有迭代器，在操作完成之后都依然有效。当然，被删除的那个元素的迭代器必然是个例外</p>
<p>map底层以RB-tree为实现机制，主要调用的是底层RB-tree的各种接口</p>
<h2 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h2><p>multiset的特性以及用法和set完全相同，唯一的差别在于它允许键值重复，因此它的插入操作采用的是底层机制RB-tree的 insert_equa1()而非insert unique()。</p>
<h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h2><p>multimap的特性以及用法与map完全相同，唯一的差别在于它允许键值重复，因此它的插入操作采用的是底层机制RB-tree的 insert_equal()而非insert_unique()。</p>
<h2 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h2><p>二叉搜索树具有对数平均时间(logarithmic average time)的表现，但这样的表现构造在一个假设上:输入数据有足够的随机性。这一节要介绍一种名为hashtable(散列表)的数据结构，这种结构在插人、删除、搜寻等操作上也具有“常数平均时间”的表现，而且这种表现是以统计为基础，不需仰赖输入元素的随机性</p>
<h3 id="hashtable-概述"><a href="#hashtable-概述" class="headerlink" title="hashtable 概述"></a>hashtable 概述</h3><p>hash table可提供对任何有名项( named item)的存取操作和删除操作。由于操作对象是有名项，所以 hash table也可被视为一种字典结构( dictionary)这种结构的用意在于提供常数时间之基本操作，就像 stack或 queue那样。乍听之下这几乎是不可能的任务，因为约束制条件如此之少，而元素个数增加，搜寻操作必定耗费更多时间</p>
<p>通过hash function来进行key和index之间的转换。但是使用hash function会产生冲突的问题</p>
<p>解决冲突的方法主要有以下几种：</p>
<ol>
<li>线性探测法，产生冲突的时候向下一个地址进行存储</li>
<li>二次探测法，产生冲突的时候以H+1^2，H+2^2…的形式进行存储</li>
<li>开链法，在表格中维护一个list</li>
</ol>
<h3 id="hashtable-的buckets与nodes"><a href="#hashtable-的buckets与nodes" class="headerlink" title="hashtable 的buckets与nodes"></a>hashtable 的buckets与nodes</h3><p>下图是以开链法( separate chaining)完成 hash table的图形表述。为了解说 SGI STL源代码，我遵循SGI的命名，称 hash table表格内的元素为桶子( bucket)，此名称的大约意义是，表格内的每个单元，涵盖的不只是个节点(元素)，甚且可能是一“桶”节点</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15268653336402.jpg" alt=""></p>
<h2 id="hash-set"><a href="#hash-set" class="headerlink" title="hash_set"></a>hash_set</h2><p>STL set多半以RB-tree为底层机制。SGI则是在STL标准规格之外另又提供了一个所谓的hash_set，以 hash table为底层机制。由于hash_set所供应的操作接口hashtable都提供了，所以几乎所有的hash_set操作行为，都只是转调用hashtab1e的操作行为而已</p>
<p>运用set，为的是能够快速搜寻元素。这一点，不论其底层是RB-tree或是hash table，都可以达成任务。但是请注意，<strong>RB-tree有自动排序功能而 hashtable没有，反应出来的结果就是，set的元素有自动排序功能而hash_set没有</strong>。</p>
<h2 id="hash-map"><a href="#hash-map" class="headerlink" title="hash_map"></a>hash_map</h2><p>SGI在STL标准规格之外，另提供了一个所谓的 hash_map，以 hash table为底层机制。由于 hash_map所供应的操作接口， hash table都提供了，所以几乎所有的hash_map操作行为，都只是转调用 hashtable的操作行为而已。</p>
<p>运用map，为的是能够根据键值快速搜寻元素。这一点，不论其底层是RB-tree或是 hash table，都可以达成任务。但是请注意，RB-tree有自动排序功能而hashtable没有，反应出来的结果就是，<strong>map的元素有自动排序功能而hash_map没有</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;侯捷老师的《STL源码剖析》可谓是学习STL的经典。在书籍的自序中侯捷老师提到的”我的确认为99.99%的程序员所写的程序，在SGI STL面前都是三流水平“，这让我等菜鸟根本把持不住呀。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="STL" scheme="https://www.liuin.cn/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>《UNIX网络编程卷1》笔记 简介部分</title>
    <link href="https://www.liuin.cn/2018/05/15/%E3%80%8AUNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B71%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AE%80%E4%BB%8B%E9%83%A8%E5%88%86/"/>
    <id>https://www.liuin.cn/2018/05/15/《UNIX网络编程卷1》笔记 简介部分/</id>
    <published>2018-05-15T12:37:20.000Z</published>
    <updated>2018-05-21T13:35:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>UNIX网络编程必读书籍——《UNIX网络编程卷1》  简介部分 笔记</p>
<a id="more"></a>
<h1 id="传输层：TCP、UDP和SCTP"><a href="#传输层：TCP、UDP和SCTP" class="headerlink" title="传输层：TCP、UDP和SCTP"></a>传输层：TCP、UDP和SCTP</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>UDP是一个<strong>简单的、不可靠的数据报协议</strong>,而TCP是一个<strong>复杂、可靠的字节流协议</strong>。SCTP与TCP类似之处在于它<strong>也是一个可靠的传输协议,但它还提供消息边界、传输级别多宿</strong>（multihoming)支持以及将头端阻塞( head-of-line blockin)减少到最小的一种方法。我们必须了解由这些传输层协议提供给应用进程的服务,这样才能弄清这些协议处理什么,应用进程中又需要处理什么。</p>
<h2 id="总图"><a href="#总图" class="headerlink" title="总图"></a>总图</h2><p>TCP/IP协议族除了TCP和IP这两个协议以外，还有许多其他的成员：</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15269068803801.jpg" alt=""></p>
<h2 id="用户数据报协议（UDP）"><a href="#用户数据报协议（UDP）" class="headerlink" title="用户数据报协议（UDP）"></a>用户数据报协议（UDP）</h2><p>应用进程往一个UDP套接字写入一个消息,该消息随后被封装( encapsulating)到一个UDP数据报,该UDP数据报进而又被封装到一个IP数据报,然后发送到目的地。UDP不保证UDP数据报会到达其最终目的地,不保证各个数据报的先后顺序跨网络后保持不变,也不保证每个数据报只到达一次</p>
<p>使用UDP进行网络编程所遇到的问题是它缺乏可靠性。如果一个数据报到达了其最终目的地,但是校验和检测发现有错误,或者该数据报在网络传输途中被丢弃了,它就无法被投递给UDP套接字,也不会被源端自动重传。</p>
<p>每个UDP数据报都有一个长度。如果一个数据报正确地到达其目的地,那么该数据报的长度将随数据一道传递给接收端应用进程。同时TCP是一个字节流(byte-stream)协议,没有任何记录边界,这一点不同于UDP</p>
<h2 id="传输控制协议（TCP）"><a href="#传输控制协议（TCP）" class="headerlink" title="传输控制协议（TCP）"></a>传输控制协议（TCP）</h2><p>首先，TCP客户先与某个给定服务器<strong>建立一个连接</strong>,再跨该连接与那个服务器交换数据,然后终止这个连接。</p>
<p>其次,TCP还提供了<strong>可靠性</strong>( reliability)。当TCP向另一端发送数据时,它要求对端返回个确认。如果没有收到确认,TCP就自动重传数据并等待更长时间。在数次重传失败后,TCP才放弃。TCP通过给其中每个字节关联一个序列号对所发送的数据进行排序，从而达到确认重传的目的。</p>
<p>再次,TCP提供<strong>流量控制</strong>( flow control)。TCP总是告知对端在任何时刻它一次能够从对端接收多少字节的数据,这称为通告窗口( advertised window)。在任何时刻,该窗口指出接收缓冲区中当前可用的空间量,从而确保发送端发送的数据不会使接收缓冲区溢出。该窗口时刻动态变化。</p>
<p>最后,TCP连接是全双工的( full-duplex)。这意味着在一个给定的连接上应用可以在任何时刻在进出两个方向上既发送数据又接收数据。因此,TCP必须为每个数据流方向跟踪诸如序列号和通告窗口大小等状态信息。当然UDP也是全双工的。</p>
<h2 id="流控制传输协议（SCTP）"><a href="#流控制传输协议（SCTP）" class="headerlink" title="流控制传输协议（SCTP）"></a>流控制传输协议（SCTP）</h2><p>SCTP提供的服务与UDP和TCP提供的类似。SCTP在客户和服务器之间提供关联( association),并像TCP那样给应用提供可靠性、排序、流量控制以及全双工的数据传送。SCTP中使用“关联”一词取代“连接”是为了避免这样的内涵:一个连接只涉及两个IP地址之间的通信。一个关联指代两个系统之间的一次通信,它可能因为SCTP支持多宿而涉及不止两个地址</p>
<p>与TCP不同的是,SCTP是面向消息的(message-oriented)。它提供各个记录的按序递送服务。与UDP一样,由发送端写入的每条记录的长度随数据一道传递给接收端应用SCTP能够在所连接的端点之间提供多个流,每个流各自可靠地按序递送消息。</p>
<h2 id="TCP连接的建立和终止"><a href="#TCP连接的建立和终止" class="headerlink" title="TCP连接的建立和终止"></a>TCP连接的建立和终止</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://data2.liuin.cn/2018-05-21-15269078619660.jpg" alt=""></p>
<h3 id="TCP选项"><a href="#TCP选项" class="headerlink" title="TCP选项"></a>TCP选项</h3><p>每一个SYN可以含有多个TCP选项，下面是一些常用的：</p>
<ul>
<li>MSS选项。发送SYN的TCP一端使用本选项通告对端它的最大分节大小( maximunsegment size)即MSS,也就是它在本连接的每个TCP分节中愿意接受的最大数据量。</li>
<li>窗口规模选项。TCP连接任何一端能够通告对端的最大窗口大小是65535,因为在TCP首部中相应的字段占16位。</li>
<li>时间戳选项。这个选项对于高速网络连接是必要的,它可以防止由失而复现的分组°可能造成的数据损坏。</li>
</ul>
<h3 id="TCP-连接终止"><a href="#TCP-连接终止" class="headerlink" title="TCP 连接终止"></a>TCP 连接终止</h3><p><img src="https://data2.liuin.cn/2018-05-21-15269079942940.jpg" alt=""></p>
<h3 id="TCP-状态转换图"><a href="#TCP-状态转换图" class="headerlink" title="TCP 状态转换图"></a>TCP 状态转换图</h3><p>TCP建立连接和连接终止的操作可以用状态转换图来进行表示，其中一共有11种状态</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15269080313206.jpg" alt=""></p>
<h3 id="观察分组"><a href="#观察分组" class="headerlink" title="观察分组"></a>观察分组</h3><p>下图展示了一个完整的TCP连接所发生的实际分组交换情况，包括建立连接、数据传送和连接终止3个阶段</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15269082100424.jpg" alt=""></p>
<h2 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h2><p>TIME WAIT状态有两个存在的理由:</p>
<ol>
<li>可靠地实现TCP全双工连接的终止，当最终的ACK丢失的时候，客户端必须重新发出这个ACK，在这之前客户端必须维护之前的状态，以允许重新发送那个ACK</li>
<li>允许老的重复分节在网络中消逝，防止影响后面的TCP连接</li>
</ol>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>任何时候,多个进程可能同时使用TCP、UDP和SCTP这3种传输层协议中的任何一种。这3种协议都使用16位整数的端口号(port number)来区分这些进程</p>
<p>当一个客户想要跟一个服务器联系时,它必须标识想要与之通信的这个服务器。TCP、UDP和SCTP定义了一组众所周知的端口(well- known port),用于标识众所周知的服务。</p>
<p>另一方面,客户通常使用短期存活的临时端口( ephemeral port)。这些端口号通常<strong>由传输层协议自动赋予客户</strong>。客户通常不关心其临时端口的具体值,而只需确信该端口在所在主机中是唯一的就行。传输协议的代码确保这种唯一性</p>
<p>端口号被划分成以下3段：</p>
<ol>
<li>众所周知的端口为0~1023。这些端口由IANA分配和控制。可能的话,相同端口号就分配给TCP、UDP和SCTP的同一给定服务。</li>
<li>已登记的端口( registered port)为1024~49151。这些端口不受IANA控制,不过由LANA登记并提供它们的使用情况清单,以方便整个群体。</li>
<li>49152~65535是动态的( dynamic)或私用的( private)端口。IANA不管这些端口。它们就是我们所称的临时端口。(49152这个魔数是65536的四分之三。）</li>
</ol>
<blockquote>
<p>套接字对</p>
</blockquote>
<p>一个TCP连接的套接字对( socket pair)是一个定义该连接的两个端点的四元组:本地P地址、本地TCP端口号、外地IP地址、外地TCP端口号。套接字对唯一标识一个网络上的每个TCP连接。</p>
<h2 id="TCP端口号与并发服务器"><a href="#TCP端口号与并发服务器" class="headerlink" title="TCP端口号与并发服务器"></a>TCP端口号与并发服务器</h2><p>并发服务器中主服务器循环通过派生一个子进程来处理每个新的连接</p>
<p>我们必须在服务器主机上区分监听套接字和已连接套接字( connected socket)。注意已连接套接字使用与监听套接字相同的本地端口(21)。</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15269091556898.jpg" alt=""></p>
<p>从上面我们可以看到：TCP无法仅仅通过查看目的端口号来分离外来的分节到不同的端点。它必须查看套接字对的所有4个元素才能确定由哪个端点接收某个到达的分节。</p>
<h2 id="缓冲区大小和限制"><a href="#缓冲区大小和限制" class="headerlink" title="缓冲区大小和限制"></a>缓冲区大小和限制</h2><h3 id="TCP输出"><a href="#TCP输出" class="headerlink" title="TCP输出"></a>TCP输出</h3><p>每一个TCP套接字有一个发送缓冲区,我们可以使用 SO_SNDBUF套接字选项来更改该缓冲区的大小。当某个应用进程调用 write时,内核从该应用进程的缓冲区中复制所有数据到所写套接字的发送缓冲区。如果该套接字的发送缓冲区容不下该应用进程的所有数据(或是应用进程的缓冲区大于套接字的发送缓冲区,或是套接字的发送缓冲区中已有其他数据),该应用进程将被投入睡眠。这里假设该套接字是阻塞的,它是通常的默认设置。内核将不从wite系统调用返回,<strong>直到应用进程缓冲区中的所有数据都复制到套接字发送缓冲区</strong>。因此,从写一个TCP套接字的 write调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区,<strong>并不表明对端的TCP或应用进程已接收到数据</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15269096002757.jpg" alt=""></p>
<h3 id="UDP输出"><a href="#UDP输出" class="headerlink" title="UDP输出"></a>UDP输出</h3><p>任何UDP套接字都有发送缓冲区大小(我们可以使用 SO SNDBUE套接字选项更改它,见75节),不过它仅仅是可写到该套接字的UDP数据报的大小上限。如果一个应用进程写一个大于套接字发送缓冲区大小的数据报,内核将返回该进程一个 EMSGSIZE错误。既然UDP是不可靠的,它不必保存应用进程数据的一个副本,因此无需一个真正的发送缓冲区。</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15269096922589.jpg" alt=""></p>
<h2 id="常见因特网应用的协议使用"><a href="#常见因特网应用的协议使用" class="headerlink" title="常见因特网应用的协议使用"></a>常见因特网应用的协议使用</h2><p><img src="https://data2.liuin.cn/2018-05-21-15269097511476.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UNIX网络编程必读书籍——《UNIX网络编程卷1》  简介部分 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://www.liuin.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>APUE 伪终端</title>
    <link href="https://www.liuin.cn/2018/05/05/APUE-%E4%BC%AA%E7%BB%88%E7%AB%AF/"/>
    <id>https://www.liuin.cn/2018/05/05/APUE-伪终端/</id>
    <published>2018-05-05T08:09:34.000Z</published>
    <updated>2018-05-05T11:14:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第19章 伪终端 笔记</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>伪终端这个术语是指,对于一个应用程序而言,它看上去像一个终端,但事实上它并不是个真正的终端。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255087230010.jpg" alt=""></p>
<p>图中的关键点是：</p>
<ol>
<li>通常,一个进程打开伪终端主设备,然后调用fork。子进程建立一个新的会话,打开一个相应的伪终端从设备,将其文件描述符复制到标准输入、标准输出和标准错误,然后调用exec。伪终端从设备成为子进程的控制终端。</li>
<li>对于伪终端从设备上的用户进程来说,其标准输入、标准输出和标准错误都是终端设备。通过这些描述符,用户进程能够处理所有终端I/O函数。但是因为仍终端从设备不是真正的终端设备,所以无意义的函数调用(例如,改变波特率、发送中断符、设置奇偶校验)将被忽略</li>
<li>任何写到伪终端主设备的都会作为从设备的输入,反之亦然。事实上,所有从设备端的输入都来自于伪终端主设备上的用户进程。这看起来就像一个双向管道,但是从设备上的中断行规程使我们拥有管道没有的处理奇谈问题的能力</li>
</ol>
<p>伪终端的某些经典用途：</p>
<blockquote>
<p>网络登录服务器</p>
</blockquote>
<p>伪终端可用于构造提供网络登录的服务器。典型的例子是 telnetd和rlogind服务器</p>
<p>在rlogind服务器和登录shell之间有两个exec调用,这是因为login程序通常是在两个exec之间检验用户是否合法</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255090645150.jpg" alt=""></p>
<blockquote>
<p>窗口系统终端模拟</p>
</blockquote>
<p>窗口系统通常提供一个终端模拟器,这样我们就能在熟悉的命令行环境中通过shell来运行程序。终端模拟器作为shell和窗口管理器之间的媒介。每个shell在自己的窗口中执行。</p>
<p>shell将自己的标准输入、标准输出、标准错误连接到PTY的从设备端。终端模拟器程序打开PTY的主设备。终端模拟器除了作为窗口子系统的接口,还要负责模拟一种特殊的终端,这意味着它需要根据它所模拟的设备类型来响应返回码。这些码列在 termcap和 terminfo数据库中。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255091975517.jpg" alt=""></p>
<blockquote>
<p>script 程序</p>
</blockquote>
<p>script(1)程序是随大多数UNIX系统提供的,它将终端会话期间的所有输入和输出信息复制到一个文件中。为完成此工作,该程序将自己置于终端和一个新调用的登录 shell之间。这里要特别指出, script程序通常是从登录shell启动的,该 shell还要等待 script程序的终止。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255092890944.jpg" alt=""></p>
<blockquote>
<p>expect 程序</p>
</blockquote>
<p>伪终端可以用来在非交互模式中驱动交互式程序的运行。许多硬连线程序需要一个终端才能行, passwd(1)命令就是一个例子,它要求用户在系统提示后输入口令</p>
<blockquote>
<p>运行协同进程</p>
</blockquote>
<p>如果协同进程是一个已经编译的程序而我们又没有源程序,则无法在源程序中加入ff1ush语句来解决这个问题。我们需要做的是将一个伪终端放到两个进程之间,诱使协同进程认为它是由终端驱动的,而非另一个进程</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255094556754.jpg" alt=""></p>
<blockquote>
<p>观看长时间运行程序的输出</p>
</blockquote>
<p>使用任何一个标准 shell,可以将一个需要长时间运行的程序放到后台运行。但是,如果将该程序的标准输出重定向到一个文件,并且它产生的输出又不多,那么我们就不能方便地监控程序的进展,因为标准I/O库将完全缓冲它的标准输出。</p>
<p>如果有源程序,则可以加入fflush调用强制标准I/O缓冲区在某些节点冲洗或者把缓冲模式改使用 setybuf的行缓冲。然而,如果没有源程序,可以在pty程序下运行该程序,让标准I/O库认为标准输出是终端。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255095797010.jpg" alt=""></p>
<h2 id="打开伪终端设备"><a href="#打开伪终端设备" class="headerlink" title="打开伪终端设备"></a>打开伪终端设备</h2><p>PTY表现得就像物理终端设备一样,因此应用程序就无须在意它们在使用的是何种设备。各种平台打开伪终端设备的方法有所不同。posix_openpt函数提供了一种可移植的方法来打开下一个可用<strong>伪终端主设备</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; #include &lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">posix_openpt</span><span class="params">(<span class="keyword">int</span> oﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: ﬁle descriptor of next available PTY master if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>在伪终端从设备可用之前,它的权限必须设置,以便应用程序可以访问它。 grantpt函数提供这样的功能:它把从设备节点的用户ID设置为调用者的实际用户ID,设置其组ID为一非指定值,通常是可以访问该终端设备的组。权限被设置为:对个体所有者是读写,对组所有者是写(0620)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">grantpt</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlockpt</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 on success, −1 on error</span></div></pre></td></tr></table></figure>
<p>unlockpt函数用于准予对伪终端从设备的访问,从而允许应用程序打开该设备。阻止其他进程打开从设备后,建立该设备的应用程序有机会在使用主、从设备之前正确地初始化这些设备</p>
<p>注意,在 grantpt和unlockpt这两个函数中,文件描述符参数是与伪终端主设备关联的文件描述符。</p>
<p>如果给定了伪终端主设备的文件描述符,那么可以用 ptsname函数找到伪终端从设备的路径名。这使应用程序可以独立于给定平台的某种特定约定而标识从设备。注意,该函数返回的名字可能存储在静态存储中,因此后续的调用可能会覆盖它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ptsname</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to name of PTY slave if OK, NULL on error</span></div></pre></td></tr></table></figure>
<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><p>伪终端还有其他特性：</p>
<ol>
<li>打包模式</li>
</ol>
<p>打包模式(packet mode)能够使PTY主设备了解到PTY从设备的状态变化</p>
<ol>
<li>远程模式</li>
</ol>
<p>PTY主设备可以用 TIOCREMOTE ioct1命令将PTY从设备设置成远程模式</p>
<ol>
<li>窗口大小变化</li>
</ol>
<p>PTY主设备上的进程可以用 TIOCSWINSZ ioct1命令来设置从设备的窗口大小。如果新的大小和当前的大小不同, SIGWINCH信号将被发送到PTY从设备的前台进程组。</p>
<ol>
<li>信号发生</li>
</ol>
<p>读、写PTY主设备的进程可以向PTY从设备的进程组发送信号</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第19章 伪终端 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 终端I/O</title>
    <link href="https://www.liuin.cn/2018/05/05/APUE-%E7%BB%88%E7%AB%AFI-O/"/>
    <id>https://www.liuin.cn/2018/05/05/APUE-终端I-O/</id>
    <published>2018-05-05T02:53:52.000Z</published>
    <updated>2018-05-05T08:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第18章 终端I/O 笔记</p>
<a id="more"></a>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>终端I/O有两种不同的工作模式:</p>
<ol>
<li>规范模式输入处理。在这种模式中,对终端输入以行为单位进行处理。对于每个读请求终端驱动程序最多返回一行</li>
<li>非规范模式输入处理。输入字符不装配成行</li>
</ol>
<p>如果不做特殊处理,则默认模式是规范模式</p>
<p>可以认为终端设备是由通常位于内核中的终端驱动程序控制的。每个终端设备都有一个输入列和一个输出队列,如图所示：</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255055612367.jpg" alt=""></p>
<p>有以下几点说明：</p>
<ul>
<li>如果打开了回显功能,则在输入队列和输出队列之间有一个隐含的连接</li>
<li>输入队列的长度MAX_INPUT是有限值。当一个特定设备的输入队列已经填满时,系统的行为将依赖于实现。这种情况发生时大多数UNIX系统回显响铃字符。</li>
<li>图中没有显示另一个输入限制MAX_CANON。这个限制是一个规范输入行的最大字节数</li>
<li>虽然输出队列的长度通常也是有限的,但是程序并不能获得这个定义其长度的常量为当输出队列将要填满时,内核便直接使写进程休眠,直至写队列中有可用的空间。</li>
</ul>
<p>大多数UNIX系统在一个称为终端行规程(terminal linediscipline)的模块中进行全部的规范处理。可以将这个模块设想成一个盒子,<strong>位于内核通用读、写函数和实际设备驱动程序之间</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255057246778.jpg" alt=""></p>
<p>由于将规范处理分离为单独的模块,所有的终端驱动程序都能够一致地支持规范处理。</p>
<p>所有可以检测和更改的终端设备特性都包含在termios结构中。该结构定义在头文件<termios.h>中,本章使用这一头文件。</termios.h></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255057581968.jpg" alt=""></p>
<p>各个标志位的作用：</p>
<ul>
<li>输入标志通过终端设备驱动程序控制字符的输入(例如,剥除输入字节的第8位,允许输入奇偶校验)</li>
<li>输出标志则控制驱动程序输出(例如,执行输出处理、将换行符转换为CRLF)</li>
<li>控制标志影响RS232串行线(例如,忽略调制解调器的状态线、每个字符的一个或两个停止位)</li>
<li>本地标志影响驱动程序和用户之间的接口(例如,回显打开或关闭、可视地擦除字符、允许终端产生的信号以及对后台输出的作业控制停止信号</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-05-05-15255058794969.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255058823469.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255058855001.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255058879538.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255058906529.jpg" alt=""></p>
<p>与终端有关的各个函数之间的关系</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255059407734.jpg" alt=""></p>
<h2 id="特殊输入字符"><a href="#特殊输入字符" class="headerlink" title="特殊输入字符"></a>特殊输入字符</h2><p>POSIX.1定义了11个在输入时要特殊处理的字符。实现定义了另外一些特殊字符</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255061027706.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255061066356.jpg" alt=""></p>
<p>在POSIX的11个特殊字符中,其中有9个字符的值可以任意更改。不能更改的两个特殊字符是换行符和回车符(分别是\n和\r),也可能是STOP和START字符(依赖于实现)。为了更改,只需要修改termios结构中c_cc数组的相应项。该数组中的元素都用名字作为下标进行引用,每个名字都以字母V开头。</p>
<p>对各个字符的详细解释可见原书内容</p>
<h2 id="获得和设置终端属性"><a href="#获得和设置终端属性" class="headerlink" title="获得和设置终端属性"></a>获得和设置终端属性</h2><p>为了获得和设置 termios结构,可以调用 tcgetattr和 tcsetattr函数。这样就可以检测和修改各种终端选项标志和特殊字符,使终端按我们所希望的方式进行操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcgetattr</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">struct</span> termios *termptr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsetattr</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> opt, <span class="keyword">const</span> <span class="keyword">struct</span> termios *termptr)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>tcsetattr的参数opt使我们可以指定在什么时候新的终端属性才起作用。opt可以指定为下列常量中的一个:</p>
<ul>
<li>TCSANOW   更改立即发生。</li>
<li>TCSADRAIN 发送了所有输出后更改才发生。若更改输出参数则应使用此选项。</li>
<li>TCSAFLUSH 发送了所有输出后更改才发生。更进一步,在更改发生时未读的所有输入数据都被丢弃(冲洗)。</li>
</ul>
<h2 id="终端选项标志"><a href="#终端选项标志" class="headerlink" title="终端选项标志"></a>终端选项标志</h2><p>包含终端选项标志的所有的解释，具体可查看原书</p>
<h2 id="stty命令"><a href="#stty命令" class="headerlink" title="stty命令"></a>stty命令</h2><p>上节说明的所有选项都可以被检查和更改:在程序中用tcgetattr和tcsetattr函数进行检查和更改;在命令行(或shell脚本)中用stty(1)命令进行检查和更改。简单地说,stty(1)命令就是终端I/O所列的前6个函数的接口。</p>
<h2 id="波特率函数"><a href="#波特率函数" class="headerlink" title="波特率函数"></a>波特率函数</h2><p>术语波特率(baud rate)是一个历史沿用的术语,现在它指的是“位/秒”(bit per second)。虽然大多数终端设备对输入和输出使用同一波特率,但是只要硬件许可,可以将它们设置为两个不同值。</p>
<p>设置波特率函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">speed_t</span> cfgetispeed(<span class="keyword">const</span> <span class="keyword">struct</span> termios *termptr); </div><div class="line"><span class="keyword">speed_t</span> cfgetospeed(<span class="keyword">const</span> <span class="keyword">struct</span> termios *termptr); </div><div class="line"></div><div class="line"><span class="comment">// Both return: baud rate value </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cfsetispeed</span><span class="params">(<span class="keyword">struct</span> termios *termptr, <span class="keyword">speed_t</span> speed)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cfsetospeed</span><span class="params">(<span class="keyword">struct</span> termios *termptr, <span class="keyword">speed_t</span> speed)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="行控制函数"><a href="#行控制函数" class="headerlink" title="行控制函数"></a>行控制函数</h2><p>下列4个函数提供了终端设备的行控制能力：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcdrain</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcflow</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> action)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcflush</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> <span class="built_in">queue</span>)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsendbreak</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> duration)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All four return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>tcdrain函数等待所有输出都被传递。<br>tcflow函数用于对输入和输出流控制进行控制。<br>tcflush函数冲洗(抛弃)输入缓冲区(其中的数据是终端驱动程序已接收到,但用户程序尚未读取的)或输出缓冲区(其中的数据是用户程序已经写入,但尚未被传递的)。<br>tcsendbreak函数在一个指定的时间区间内发送连续的0值位流。</p>
<h2 id="终端标识"><a href="#终端标识" class="headerlink" title="终端标识"></a>终端标识</h2><p>历史上,在大多数UNIX系统版本中,控制终端的名字一直是/dev/tty。POSIX.1提供了个运行时函数,可用来确定控制终端的名字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctermid</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to name of controlling terminal on success, pointer to empty string on error</span></div></pre></td></tr></table></figure>
<p>另外还有两个UNIX系统比较感兴趣的函数: isatty和 ttyname。如果文件描述符引用个终端设备,则 isatty返回真。 ttyname返回的是在该文件描述符上打开的终端设备的路径名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">isatty</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 1 (true) if terminal device, 0 (false) otherwise</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ttyname</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to pathname of terminal, NULL on error</span></div></pre></td></tr></table></figure>
<h2 id="规范模式"><a href="#规范模式" class="headerlink" title="规范模式"></a>规范模式</h2><p>规范模式很简单:发一个读请求,<strong>当一行已经输入后,终端驱动程序即返回</strong>。以下几个条件造成读返回。</p>
<ol>
<li>所请求的字节数已读到时,读返回。无需读一个完整的行。如果读了部分行,那么也不会丢失任何信息,下一次读从前一次读的停止处开始。</li>
<li>当读到一个行定界符时,读返回。</li>
<li>如果捕捉到信号,并且该函数不再自动重启,则读也返回</li>
</ol>
<h2 id="非规范模式"><a href="#非规范模式" class="headerlink" title="非规范模式"></a>非规范模式</h2><p>可以通过关闭termios结构中c_lf1ag字段的ICANON标志来指定非规范模式。在非规范模式中,输入数据不装配成行,不处理下列特殊字符: ERASE、KILL、EOF、NLEOL、EOL2、CR、REPRINT、STATUS和 WERASE。</p>
<p>如前所述,规范模式很容易理解:系统每次至多返回一行。但在非规范模式下,系统如何知道在什么时候将数据返回给我们呢?如果它一次返回一个字节,那么系统开销就会过大。在启动读数据之前,往往不知道要读多少数据,所以系统不能总是一次返回多个字节解决方法是,当已读了指定量的数据后,或者已经超过了给定量的时间后,即通知系统返回。</p>
<p>这种技术使用了 termios结构中c_cc数组的两个变量:MIN和TIME。c_cc数组中的这两个元素的下标名为VMIN和VTIM。</p>
<p>MIN指定一个read返回前的最小字节数。TIME指定等待数据到达的分秒数(分秒为秒的1/10)。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255076147395.jpg" alt=""></p>
<h2 id="终端窗口大小"><a href="#终端窗口大小" class="headerlink" title="终端窗口大小"></a>终端窗口大小</h2><p>大多数UNⅨX系统都提供了一种跟踪当前终端窗口大小的方法,在窗口大小发生变化时,使内核通知前台进程组。内核为每个终端和伪终端都维护了一个wins1ze结构</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255076954042.jpg" alt=""></p>
<p>提供这种功能的目的是,当窗口大小发生变化时应用程序能够得到通知(如v1编辑器)。应用程序接收此信号后,可以获取窗口大小的新值,然后重绘屏幕。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第18章 终端I/O 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 高级进程间通信</title>
    <link href="https://www.liuin.cn/2018/05/05/APUE-%E9%AB%98%E7%BA%A7%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://www.liuin.cn/2018/05/05/APUE-高级进程间通信/</id>
    <published>2018-05-05T01:37:33.000Z</published>
    <updated>2018-05-05T02:55:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第17章 高级进程间通信 笔记</p>
<a id="more"></a>
<h2 id="UNIX-域套接字"><a href="#UNIX-域套接字" class="headerlink" title="UNIX 域套接字"></a>UNIX 域套接字</h2><p>UNIX域套接字用于在同一台计算机上运行的进程之间的通信。虽然因特网域套接字可用于同一目的,但<strong>UNIX域套接字的效率更高</strong>。UNIX域套接字仅仅复制数据,它们并不执行协议处理,不需要添加或删除网络报头,无需计算校验和,不要产生顺序号,无需发送确认报文。</p>
<p>UNIX域套接字<strong>提供流和数据报两种接口</strong>。UNIX域数据报服务是可靠的,既不会丢失报文也不会传递出错。UNIX域套接字就像是套接字和管道的混合。</p>
<p>可以使用它们面向网络的域套接字接口或者使用socketpair函数来创建一对无命名的、相互连接的UNIX域套接字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> sockfd[<span class="number">2</span>])</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>虽然接口足够通用,允许socketpair用于其他域,但一般来说操作系统仅对UNIX域提供支持</p>
<p>对相互连接的UNIX域套接字可以起到<strong>全双工管道的作用</strong>:两端对读和写开放。我们将其称为fd管道( fd-pipe),以便与普通的半双工管道区分开来。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254872539788.jpg" alt=""></p>
<p>曾经提到XSI消息队列的使用存在一个问题,即不能将它们和po11或者se1ect起使用,这是因为它们不能关联到文件描述符。然而,套接字是和文件描述符相关联的,消息到达时,可以用套接字来通知。对每个消息队列使用一个线程。每个线程都会在mmsgrcv调用中阻塞。当消息到达时,线程会把它写入一个UNIX域套接字的一端。当poll指示套接字可以读取数据时,应用程序会使用这个套接字的另外一端来接收这个消息。</p>
<blockquote>
<p>命名UNIX域套接字</p>
</blockquote>
<p>虽然socketpair函数能创建一对相互连接的套接字,但是每一个套接字都没有名字。这意味着无关进程不能使用它们。恰如因特网域套接字一样,可以命名UNIX域套接字,并可将其用于告示服务。但是要注意,UNX域套接字使用的地址格式不同于因特网域套接字，套接字地址格式会随实现而变。</p>
<p>UNIX域套接字的地址由 sockaddr_un结构表示。在 Linux3.20和 Solaris10中, sockaddr_un结构在头文件<sys un.h="">中的定义</sys></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254875673064.jpg" alt=""></p>
<p>sockaddr_un结构的sun_path成员包含一个路径名。当我们将一个地址绑定到一个UNIX域套接字时,系统会用该路径名创建一个S_IFSOCK类型的文件该文件仅用于向客户进程告示套接字名字。该文件无法打开,也不能由应用程序用于通信。</p>
<p>如果我们试图绑定同一地址时,该文件已经存在,那么bind请求会失败。当关闭套接字时,并不自动删除该文件,所以必须确保在应用程序退出前,对该文件执行解除链接操作。</p>
<h2 id="唯一连接"><a href="#唯一连接" class="headerlink" title="唯一连接"></a>唯一连接</h2><p>服务器进程可以使用标准bind、listen和 accept函数,为客户进程安排一个唯一UNIX域连接。客户进程使用 connect与服务器进程联系。在服务器进程接受了connect请求后,在服务器进程和客户进程之间就存在了唯一连接。</p>
<p>下图展示了客户进程和服务器进程存在连接之前二者的情形。服务器端把它的套接字绑定到sockaddr_un的地址并监听新的连接请求。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254879207178.jpg" alt=""></p>
<p>现在，开发3个函数,使用这些函数可以在运行于同一台计算机上的两个无关进程之间创建唯一连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span> </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">serv_listen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </div><div class="line"><span class="comment">// Returns: ﬁle descriptor to listen on if OK, negative value on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">serv_accept</span><span class="params">(<span class="keyword">int</span> listenfd, <span class="keyword">uid_t</span> *uidptr)</span></span>; </div><div class="line"><span class="comment">// Returns: new ﬁle descriptor if OK, negative value on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cli_conn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </div><div class="line"><span class="comment">// Returns: ﬁle descriptor if OK, negative value on error</span></div></pre></td></tr></table></figure>
<p>服务器进程可以调用serv_listen函数声明它要在一个众所周知的名字(文件系统中的某个路径名)上监听客户进程的连接请求。当客户进程想要连接至服务器进程时,它们将使用该名字。serv_listen函数的返回值是用于接收客户进程连接请求的服务器UNIX域套接字</p>
<p>服务器进程可以使用serv_accept函数等待客户进程连接请求的到达。当个请求到达时,系统自动创建一个新的UNIX域套接字,并将它与客户端套接字连接,最后将这个新套接字返回给服务器。此外,客户进程的有效用户ID存放在 uidptr指向的存储区中客户</p>
<p>进程调用cli_conn函数连接至服务器进程。客户进程指定的name参数必须与服务器进程调用serv_listen函数时所用的名字相同</p>
<p>这三个函数的具体实现可以查看书本</p>
<h2 id="传送文件描述符"><a href="#传送文件描述符" class="headerlink" title="传送文件描述符"></a>传送文件描述符</h2><p>在两个进程之间传送打开文件描述符的技术是非常有用的。因此可以对客户进程服务器进程应用进行不同的设计。它使一个进程(通常是服务器进程)能够处理打开一个文件所要做的一切操作(包括将网络名翻译为网络地址、拨号调制解调器、协商文件锁等)以及<strong>向调用进程送回个描述符</strong>,该描述符可被用于以后的所有I/O函数。涉及打开文件或设备的所有细节对客户进程而言都是透明的。</p>
<p>一般情况下，两个进程,它们打开了同一文件。虽然它们共享同一个v节点,但每个进程都有它自己的文件表项。当一个进程向另一个进程传送一个打开文件描述符时,我们想让发送进程和接收进程共享同文件表项。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254885933315.jpg" alt=""></p>
<p>在技术上,我们是<strong>将指向一个打开文件表项的指针从一个进程发送到另外一个进程</strong>。该指针被分配存放在接收进程的第一个可用描述符项中。(注意,不要造成错觉,以为发送进程和接收进程中的描述符编号是相同的,它们通常是不同的。)两个进程共享同一个打开文件表,这与foxk之后的父进程和子进程共享打开文件表的情况完全相同。</p>
<p>当发送进程将描述符传送给接收进程后,通常会关闭该描述符。发送进程关闭该描述符并不会真的关闭该文件或设备,其原因是该描述符仍被视为由接收进程打开(即使接收进程尚未接收到该描述符)</p>
<p>下面定义用以发送和接收文件描述符的3个函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include "apue.h" </div><div class="line"></div><div class="line">int send_fd(int fd, int fd_to_send); </div><div class="line">int send_err(int fd, int status, const char *errmsg); </div><div class="line">// Both return: 0 if OK, −1 on error </div><div class="line"></div><div class="line">int recv_fd(int fd, ssize_t (*userfunc)(int, const void *, size_t)); </div><div class="line">// Returns: ﬁle descriptor if OK, negative value on error</div></pre></td></tr></table></figure>
<p>具体的实现原书代码</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第17章 高级进程间通信 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 网络IPC：套接字</title>
    <link href="https://www.liuin.cn/2018/05/05/APUE-%E7%BD%91%E7%BB%9CIPC%EF%BC%9A%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    <id>https://www.liuin.cn/2018/05/05/APUE-网络IPC：套接字/</id>
    <published>2018-05-05T00:38:42.000Z</published>
    <updated>2018-05-05T01:37:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第16章 网络IPC：套接字 笔记</p>
<a id="more"></a>
<h2 id="套接字描述"><a href="#套接字描述" class="headerlink" title="套接字描述"></a>套接字描述</h2><p>套接字是通信端点的抽象。正如使用文件描述符访问文件,应用程序用套接字描述符访问套接字。<strong>套接字描述符在UNIX系统中被当作是一种文件描述符</strong>。事实上,许多处理文件描述符的函数(如read和 write)可以用于处理套接字描述符。</p>
<p>为创建一个套接字,调用socket函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: ﬁle (socket) descriptor if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>参数 domain(域)确定通信的特性,包括地址格式</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254808968863.jpg" alt=""></p>
<p>参数type确定套接字的类型,进一步确定通信特征。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254809237060.jpg" alt=""></p>
<p>参数protocol通常是0,表示为给定的域和套接字类型选择默认协议。当对同一域和套接字类型支持多个协议时,可以使用 protocol选择一个特定协议</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254809947426.jpg" alt=""></p>
<p>对于数据报(SOCK_DGRAM)接口,两个对等进程之间通信时不需要逻辑连接。只需要向对等进程所使用的套接字送出一个报文。字节流(SOCK_STREAM)要求在交换数据之前,在本地套接字和通信的对等进程的套接字之间建立一个逻辑连接。</p>
<p>调用socket与调用open相类似。在两种情况下,均可获得用于I/O的文件描述符。当不再需要该文件描述符时,调用c1ose来关闭对文件或套接字的访问,并且释放该描述符以便重新使用虽然套接字描述符本质上是一个文件描述符,但不是所有参数为文件描述符的函数都可以接受套接字描述符。</p>
<h2 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h2><p>在学习用套接字做一些有意义的事情之前,需要知道如何标识一个目标通信进程。进程标识由两部分组成。一部分是<strong>计算机的网络地址</strong>,它可以帮助标识网络上我们想与之通信的计算机;另一部分是该<strong>计算机上用端口号</strong>表示的服务,它可以帮助标识特定的进程。</p>
<h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>字节序是一个处理器架构特性用于指示像整数这样的大数据类型内部的字节如何排序。</p>
<p>如果处理器架构支持大端(big-endian)字节序,那么<strong>最大字节地址出现在最低有效字节</strong>( Least Significant Byte,LSB)上，小端(little-endian)字节序则相反:<strong>最低有效字节包含最小字节地址</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254815015116.jpg" alt=""></p>
<p>网络协议指定了字节序,因此异构计算机系统能够交换协议信息而不会被字节序所混淆。TCPP协议栈使用大端字节序。应用程序交换格式化数据时,字节序问题就会出现</p>
<p>对于TCPP应用程序,有4个用来在处理器字节序和网络字节序之间实施转换的函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostint32);</div><div class="line"><span class="comment">// Returns: 32-bit integer in network byte order</span></div><div class="line"></div><div class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostint16);</div><div class="line"><span class="comment">// Returns: 16-bit integer in network byte order</span></div><div class="line"></div><div class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netint32);</div><div class="line"></div><div class="line"><span class="comment">// Returns: 32-bit integer in host byte order</span></div><div class="line"></div><div class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> netint16);</div><div class="line"></div><div class="line"><span class="comment">// Returns: 16-bit integer in host byte order</span></div></pre></td></tr></table></figure>
<p>h表示“主机”字节序,n表示“网络”字节序。1表示“长”(即4字节)整数,s表示“短”</p>
<h3 id="地址格式"><a href="#地址格式" class="headerlink" title="地址格式"></a>地址格式</h3><p>一个地址标识一个特定通信域的套接字端点,地址格式与这个特定的通信域相关。为使不同格式地址能够传入到套接字函数,地址会被<strong>强制转换</strong>成一个通用的地址结构sockaddr</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254817776056.jpg" alt=""></p>
<p>不同的系统实现可能会不一样</p>
<p>因特网地址定义在<netinet in.h="">头文件中。在IPv4因特网域(AF_INET)中,套接字地址用结构 sockaddr_in表示</netinet></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254818310427.jpg" alt=""></p>
<p>有时,需要打印出能被人理解而不是计算机所理解的地址格式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> addr, <span class="keyword">char</span> *<span class="keyword">restrict</span> str, <span class="keyword">socklen_t</span> size)</span></span>;</div><div class="line"><span class="comment">// Returns: pointer to address string on success, NULL on error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> str, <span class="keyword">void</span> *<span class="keyword">restrict</span> addr)</span></span>;</div><div class="line"><span class="comment">// Returns: 1 on success, 0 if the format is invalid, or −1 on error</span></div></pre></td></tr></table></figure>
<p>函数inet_ntop将网络字节序的二进制地址转换成文本字符串格式。inet_pton将文本字符串格式转换成网络字节序的二进制地址。</p>
<h3 id="将套接字和地址关联"><a href="#将套接字和地址关联" class="headerlink" title="将套接字和地址关联"></a>将套接字和地址关联</h3><p>将一个客户端的套接字关联上一个地址没有多少新意,可以让系统选一个默认的地址。然而,<strong>对于服务器,需要给一个接收客户端请求的服务器套接字关联上一个众所周知的地址</strong>。客户端应有一种方法来发现连接服务器所需要的地址,最简单的方法就是服务器保留一个地址并且注册在/etc/services或者某个名字服务中。</p>
<p>使用bind函数来关联地址和套接字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>对于使用的地址有以下一些限制:</p>
<ul>
<li>在进程正在运行的计算机上,指定的地址必须有效，不能指定一个其他机器的地址。</li>
<li>地址必须和创建套接字时的地址族所支持的格式相匹配。</li>
<li>地址中的端口号必须不小于1024,除非该进程具有相应的特权(即超级用户)</li>
<li>一般只能将一个套接字端点绑定到一个给定地址上,尽管有些协议允许多重绑定</li>
</ul>
<p>可以调用 getsockname函数来发现绑定到套接字上的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> alenp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>调用 getsockname之前,将 alenp设置为一个指向整数的指针,该整数指定缓冲区sockaddr的长度。返回时,该整数会被设置成返回地址的大小。如果地址和提供的缓冲区长</p>
<p>如果套接字已经和对等方连接,可以调用 getpeername函数来找到对方的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> alenp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>如果要处理一个面向连接的网络服务(SOCK_STREAM或SOCK_SEQPACKET),那么在开始交换数据以前,需要在请求服务的进程套接字(客户端)和提供服务的进程套接字(服务器)之间建立一个连接。使用connect函数来建立连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>在connect中指定的地址是我们想与之通信的服务器地址。如果 sockfd没有绑定到一个地址, connect会给调用者绑定一个默认地址。</p>
<p>服务器调用listen函数来宣告它愿意接受连接请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>一旦服务器调用了listen,所用的套接字就能接收连接请求。使用accept函数获得连接请求并建立连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> len)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: ﬁle (socket) descriptor if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>函数accept所返回的文件描述符是套接字描述符,该描述符连接到调用connect的客户端。这个新的套接字描述符和原始套接字(sockfd)具有相同的套接字类型和地址族。传给accept原始套接字没有关联到这个连接,而是继续保持可用状态并接收其他连接请求。</p>
<p>如果服务器调用accept,并且当前没有连接请求,服务器会阻塞直到一个请求到来。另外服务器可以使用poll或se1ect来等待一个请求的到来。在这种情况下,一个带有等待连接请求的套接字会以可读的方式出现</p>
<h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>既然一个套接字端点表示为一个文件描述符,那么只要建立连接,就可以使用read和 write来通过套接字通信。</p>
<p>尽管可以通过read和write交换数据,但这就是这两个函数所能做的一切。如果想指定选项,从多个客户端接收数据包,或者发送带外数据,就需要使用6个为数据传递而设计的套接字函数中的一个</p>
<p>3个函数用来发送数据,3个用于接收数据。首先,考查用于发送数据的函数。最简单的是send,它和 write很像,但是可以指定标志来改变处理传输数据的方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> send(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> ﬂags);</div><div class="line"></div><div class="line"><span class="comment">// Returns: number of bytes sent if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>前面3个参数和write参数一样，不同的是第4个参数flags：</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254833405785.jpg" alt=""></p>
<p>即使send成功返回,也并不表示连接的另一端的进程就一定接收了数据。我们所能保证的只是当send成功返回时,数据已经被无错误地发送到网络驱动程序上</p>
<p>函数 sendto和send很类似。区别在于sendto可以在无连接的套接字上指定一个目标地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> ﬂags, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *destaddr, <span class="keyword">socklen_t</span> destlen); </div><div class="line"></div><div class="line"><span class="comment">// Returns: number of bytes sent if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>对于面向连接的套接字,目标地址是被忽略的,因为连接中隐含了目标地址。对于无连接的套接字,除非先调用 connect设置了目标地址,否则不能使用send。 sendto提供了发送报文的另一种方式</p>
<p>通过套接字发送数据时,还有一个选择。可以调用带有msghdr结构的sendmsg来指定多重缓冲区传输数据,这和 writev函数很相似</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> sendmsg(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="keyword">int</span> ﬂags);</div><div class="line"></div><div class="line"><span class="comment">// Returns: number of bytes sent if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>与发送数据相对应的，接受数据也有三个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> recv(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> ﬂags);</div><div class="line"></div><div class="line"><span class="comment">// Returns: length of message in bytes, 0 if no messages are available and peer has done an orderly shutdown, or −1 on error</span></div></pre></td></tr></table></figure>
<p><img src="https://data2.liuin.cn/2018-05-05-15254835445782.jpg" alt=""></p>
<p>如果有兴趣定位发送者,可以使用 recvfrom来得到数据发送者的源地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> ﬂags, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> addrlen); </div><div class="line"></div><div class="line"><span class="comment">// Returns: length of message in bytes, 0 if no messages are available and peer has done an orderly shutdown, or −1 on error</span></div></pre></td></tr></table></figure>
<p>为了将接收到的数据送入多个缓冲区,类似于 readv,或者想接收辅助数据,可以使用 recvmso</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> recvmsg(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="keyword">int</span> ﬂags);</div><div class="line"></div><div class="line"><span class="comment">// Returns: length of message in bytes, 0 if no messages are available and peer has done an orderly shutdown, or −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h2><p>套接字机制提供了两个套接字选项接口来控制套接字行为。一个接口用来设置选项,另一个接口可以查询选项的状态。可以获取或设置以下3种选项</p>
<ol>
<li>通用选项,工作在所有套接字类型上</li>
<li>在套接字层次管理的选项,但是依赖于下层协议的支持</li>
<li>特定于某协议的选项,每个协议独有的</li>
</ol>
<p>可以使用 setsockopt函数来设置套接字选项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option, <span class="keyword">const</span> <span class="keyword">void</span> *val, <span class="keyword">socklen_t</span> len)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>参数 level标识了选项应用的协议。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254838324441.jpg" alt=""></p>
<p>参数val根据选项的不同指向一个数据结构或者一个整数。一些选项是on/off开关。如果整数非0,则启用选项。如果整数为0,则禁止选项。参数len指定了val指向的对象的大小</p>
<p>可以使用getsockopt来查看选项的当前值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option, <span class="keyword">void</span> *<span class="keyword">restrict</span> val, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> lenp)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="带外数据"><a href="#带外数据" class="headerlink" title="带外数据"></a>带外数据</h2><p>带外数据( out-of-band data)是一些通信协议所支持的可选功能,与普通数据相比,它允许更高优先级的数据传输。带外数据先行传输,即使传输队列已经有数据。TCP支持带外数据,但是UDP不支持。套接字接口对带外数据的支持很大程度上受TCP带外数据具体实现的影响。TCP将带外数据称为紧急数据( urgent data)。</p>
<p>TCP仅支持一个字节的紧急数据,但是允许紧急数据在普通数据传递机制数据流之外传输。</p>
<h2 id="非阻塞和异步I-O"><a href="#非阻塞和异步I-O" class="headerlink" title="非阻塞和异步I/O"></a>非阻塞和异步I/O</h2><p>在基于套接字的异步LO中,当从套接字中读取数据时,或者当套接字写队列中空间变得可用时,可以安排要发送的信号 SIGIO。</p>
<p>启用异步IO是一个两步骤的过程</p>
<ol>
<li>建立套接字所有权,这样信号可以被传递到合适的进程</li>
<li>通知套接字当IO操作不会阻塞时发信号</li>
</ol>
<p>可以使用3种方式来完成第一个步骤</p>
<ul>
<li>在fcnt1中使用 F_SETOWN命令</li>
<li>在ioct1中使用 FIOSETOWN命令</li>
<li>在ioctl中使用 SIOCSPGRP命令</li>
</ul>
<p>要完成第二个步骤,有两个选择</p>
<ul>
<li>在fcnt1中使用F_SETFL命令并且启用文件标志O_ASYNO</li>
<li>在ioctl中使用FI命令</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第16章 网络IPC：套接字 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 进程间通信</title>
    <link href="https://www.liuin.cn/2018/05/04/APUE-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://www.liuin.cn/2018/05/04/APUE-进程间通信/</id>
    <published>2018-05-04T06:00:08.000Z</published>
    <updated>2018-05-27T12:01:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第15章 进程间通信 笔记</p>
<a id="more"></a>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道是UNX系统IPC的最古老形式,所有UNX系统都提供此种通信机制。</p>
<p>管道有以下两种局限性：</p>
<ol>
<li>历史上,它们是半双工的(即数据只能在一个方向上流动)。现在,某些系统提供全双工管道,但是为了最佳的可移植性,我们决不应预先假定系统支持全双工管道</li>
<li>管道只能在具有公共祖先的两个进程之间使用。通常,一个管道由一个进程创建,在进程调用fork之后,这个管道就能在父进程和子进程之间使用了。</li>
</ol>
<p>每当在管道中键入一个命令序列,让shell执行时,shell都会为每一条命令单独创建一个进程,然后用管道将前一条命令进程的标准输出与后一条命令的标准输入相连接。</p>
<p>管道是通过调用pipe函数创建的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</div><div class="line"></div><div class="line">Returns: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</div></pre></td></tr></table></figure>
<p>经由参数fd返回两个文件描述符:fd[0]为读而打开,fd[1]为写而打开。fd[1]的输出是fd[0]的输入。</p>
<p>单个进程中的管道几乎没有任何用处。通常,进程会先调用pipe,接着调用fork,从而创建从父进程到子进程的IPC通道,反之亦然</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254214499352.jpg" alt=""></p>
<p>对于一个从子进程到父进程的管道,父进程关闭fd[1],子进程关闭fd[0]当管道的一端被关闭后,下列两条规则起作用。<br>(1)当读(read)一个写端已被关闭的管道时,在所有数据都被读取后,read返回0,表示文件结束。(从技术上来讲,如果管道的写端还有进程,就不会产生文件的结束。可以复制一个管道的描述符,使得有多个进程对它具有写打开文件描述符。但是,通常一个管道只有一个读进程和一个写进程。）<br>(2)如果写(write)一个读端已被关闭的管道,则产生信号 SIGPIPE。如果忽略该信号或者捕捉该信号并从其处理程序返回,则 write返回-1, errno设置为 EPIPE。</p>
<h2 id="函数popen和pclose"><a href="#函数popen和pclose" class="headerlink" title="函数popen和pclose"></a>函数popen和pclose</h2><p>常见的操作是创建一个连接到另一个进程的管道,然后读其输出或向其输入端发送数据,为此,标准I/O库提供了两个函数 popen和 pclose。这两个函数实现的操作是:创建一个管道,fork一个子进程,关闭未使用的管道端,执行一个shell运行命令,然后等待命令终止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">`<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function">FILE *<span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</div><div class="line"><span class="comment">// Returns: ﬁle pointer if OK, NULL on error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *fp)</span></span>; </div><div class="line"><span class="comment">// Returns: termination status of cmdstring, or −1 on error</span></div></pre></td></tr></table></figure>
<p>函数 popen先执行fork,然后调用exec执行cstring,并且返回一个标准I/O文件指针。如果type是”r”,则文件指针连接到cstring的标准输出。如果type是”w”,则文件指针连接到 cmdstring的标准输入，表示写FILE中的东西</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254216672075.jpg" alt=""></p>
<p>可以将最后一个参数的使用方法和fopen类比，如果type是”r”,则返回的文件指针是可读的,如果type是”w”,则是可写的</p>
<h2 id="协同进程"><a href="#协同进程" class="headerlink" title="协同进程"></a>协同进程</h2><p>UNIX系统过滤程序从标准输入读取数据,向标准输出写数据。几个过滤程序通常在shell管道中线性连接。当一个过滤程序既产生某个过滤程序的输入,又读取该过滤程序的输出时,它就变成了协同进程(coprocess)。</p>
<p>协同进程通常在shell的后台运行,其标准输入和标准输出通过管道连接到另一个程序。</p>
<p>popen只提供连接到另一个进程的标准输入或标准输出的一个单向管道,而协同进程则有连接到另一个进程的两个单向管道:一个接到其标准输入,另一个则来自其标准输出。</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254220325027.jpg" alt=""></p>
<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>FIFO有时被称为命名管道。未命名的管道只能在两个相关的进程之间使用,而且这两个相关的进程还要有一个共同的创建了它们的祖先进程。但是,通过FIFO,不相关的进程也能交换数据。</p>
<p>FIFO是一种文件类型。通过<code>stat</code>结构的<code>st_mode</code>成员的编码可以知道文件是否是FIFO类型。可以用S_ ISFTEO宏对此进行测试。</p>
<p><strong>创建FIFO类似于创建文件</strong>。确实,FIFO的路径名存在于文件系统中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>当我们用 mkfifo或者 mkfifoat创建FIFO时,要用open来打开它。设置非阻塞以及对错误的处理和普通文件的处理是一样的。</p>
<p>类似于管道,若 write一个尚无进程为读而打开的FIFO,则产生信号SIGPIPE。若某个FIFO的最后一个写进程关闭了该FIFO,则将为该FIFO的读进程产生一个文件结束标志。</p>
<p>FIFO有以下两种用途</p>
<ul>
<li>shell命令使用FIFO将数据从一条管道传送到另一条时,无需创建中间临时文件</li>
<li>客户进程服务器进程应用程序中,FIFO用作汇聚点,在客户进程和服务器进程二者之间传递数据</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-05-04-15254224287657.jpg" alt=""></p>
<h2 id="XSI-IPC"><a href="#XSI-IPC" class="headerlink" title="XSI IPC"></a>XSI IPC</h2><p>有3种称作XSI IPC的IPC:消息队列、信号量以及共享存储器。它们之间有很多相似之处</p>
<h3 id="标识符与键"><a href="#标识符与键" class="headerlink" title="标识符与键"></a>标识符与键</h3><p>每个内核中的IPC结构(消息队列、信号量或共享存储段)都用一个非负整数的标识符(identifier)加以引用。</p>
<p>标识符是IPC对象的内部名。为使多个合作进程能够在同一IPC对象上汇聚,需要提供一个外部命名方案。为此,每个IPC对象都与一个键(key)相关联,将这个键作为该对象的外部名。键的数据结构是<code>key_t</code></p>
<p>有多种方法使客户进程和服务器进程在同一IPC结构上汇聚：</p>
<ol>
<li>服务器进程可以指定键IPC_PRIVATE创建一个新IPC结构,将返回的标识符存放在某处(如一个文件)以便客户进程取用。</li>
<li>可以在一个公用头文件中定义一个客户进程和服务器进程都认可的键。</li>
<li>客户进程和服务器进程认同一个路径名和项目ID，接着调用函数ftok将这两个值变成一个键</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">key_t</span> ftok(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> id);</div><div class="line"></div><div class="line"><span class="comment">// Returns: key if OK, (key_t)−1 on error</span></div></pre></td></tr></table></figure>
<p>ftok创建的键通常是用下列方式构成的:按给定的路径名取得其stat结构中的部分 st_dev和 st_ino字段,然后再将它们与项目ID组合起来。如果两个路径名引用的是两个不同的文件,那么ftok通常会为这两个路径名返回不同的键。但是,因为i节点编号和键通常都存放在长整型中,所以创建键时可能会丢失信息。这意味着,对于不同文件的两个路径名,如果使用同一项目ID,那么可能产生相同的键。</p>
<p>3个get函数( msgget、 semget和 shmget)都有两个类似的参数:一个key和一个整型flag。在创建新的IPC结构(通常由服务器进程创建)时,如果key是 IPC_PRIVATE或者和当前某种类型的IPC结构无关,则需要指明fag的 IPC_CREAT标志位。为了引用一个现有队列(通常由客户进程创建),key必须等于队列创建时指明的key的值,并且 IPC_CREAT必须不被指明。</p>
<p>注意,决不能指定 IPC_PRIVATE作为键来引用一个现有队列,因为这个特殊的键值总是用于创建一个新队列。为了引用一个用 IPC_PRIVATE键创建的现有队列,一定要知道这个相关的标识符,然后在其他IPC调用中(如 msgsnd、 nserc)使用该标识符,这样可以绕过get函数</p>
<p>如果希望创建一个新的IPC结构,而且要确保没有引用具有同一标识符的一个现有IPC结构,那么必须在flag中同时指定 IPC_CREAT和IPC_EXCL位。这样做了以后,如果IPC结构已经存在就会造成出错,返回 EEXIST(这与指定了O_CREAT和O_EXCL标志的open相类似)</p>
<h3 id="权限结构"><a href="#权限结构" class="headerlink" title="权限结构"></a>权限结构</h3><p>XSI IPC为每一个IPC结构关联了一个ipc_perm结构。该结构规定了权限和所有者,它至少包括下列成员:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct ipc_perm &#123; </div><div class="line">    uid_t uid; /* owner’s effective user ID */ </div><div class="line">    gid_t gid; /* owner’s effective group ID */ </div><div class="line">    uid_t cuid; /* creator’s effective user ID */ </div><div class="line">    gid_t cgid; /* creator’s effective group ID */ </div><div class="line">    mode_t mode; /* access modes */ </div><div class="line">    .</div><div class="line">    .</div><div class="line">    .</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>每个实现会包括另外一些成员。在创建IPC结构时,对所有字段都赋初值。</p>
<p>mode字段的值如下图所示，<strong>对于任何IPC结构都不存在执行权限</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274218221632.jpg" alt=""></p>
<h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><p>XSI IPC的一个基本问题是:<strong>IPC结构是在系统范围内起作用的,没有引用计数</strong>。例如,如果进程创建了一个消息队列,并且在该队列中放入了几则消息,然后终止,那么该消息队列及其内容不会被删除。它们会一直留在系统中直至发生下列动作为止:由某个进程调用 msgrcv或msct1读消息或删除消息队列;或某个进程执行 ipcri(1)命令删除消息队列;或正在自举的系统删除消息队列。</p>
<p>将此与管道相比,当最后一个引用管道的进程终止时,管道就被完全地删除了。对于FIFO而言,在最后一个引用FIFO的进程终止时,虽然FIFO的名字仍保留在系统中,直至被显式地删除,但是留在FIFO中的数据已被删除了</p>
<p>XSI IPC的另一个问题是:这些IPC结构在文件系统中没有名字，为了支持这些IPC对象，系统增加了许多的系统调用</p>
<p>因为这些形式的IPC不使用文件描述符,所以<strong>不能对它们使用多路转接I/O函数</strong></p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是消息的链接表,<strong>存储在内核中</strong>,由消息队列标识符标识。</p>
<p><code>msgget</code>用于创建一个新队列或打开一个现有队列。<code>msgsnd</code>将新消息添加到队列尾端。每个消息包含一个正的长整型类型的字段、一个非负的长度以及实际数据字节数(对应于长度),所有这些都在将消息添加到队列时,传送给<code>msgsnd</code>。 <code>msgrcv</code>用于从队列中取消息。我们并不定要以先进先出次序取消息,也可以按消息的类型字段取消息。</p>
<p>每个队列有一个msqid_ds结构与其相关联</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254293881565.jpg" alt=""></p>
<p>创建一个队列或者打开一个现有队列函数<code>msgget</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: message queue ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>msgctl函数对队列执行多种操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf )</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>cmd参数指定对msqid队列要执行的命令：</p>
<ul>
<li>IPC_STAT  获取此队列的msqid_ds结构</li>
<li>IPC_SET  设置队列结构</li>
<li>IPC_RMID  从系统中删除该消息队列以及仍在该消息队列中的所有数据</li>
</ul>
<p>调用msgsnd将数据放到消息队列中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>消息类型结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> mymesg &#123; </div><div class="line">    <span class="keyword">long</span> mtype; <span class="comment">/* positive message type */</span> </div><div class="line">    <span class="keyword">char</span> mtext[<span class="number">512</span>]; <span class="comment">/* message data, of length nbytes */</span> </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>msgrcv从队列中取用消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> msgrcv(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes, <span class="keyword">long</span> type, <span class="keyword">int</span> ﬂag); </div><div class="line"></div><div class="line"><span class="comment">// Returns: size of data portion of message if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量与已经介绍过的IPC机构(管道、FIFO以及消息列队)不同。它是一个计数器,用于为多个进程提供对共享数据对象的访问</p>
<p>为了正确地实现信号量,信号量值的测试及减1操作应当是原子操作。为此,信号量通常是在内核中实现的</p>
<p>常用的信号量形式被称为二元信号量(binary semaphore)。它控制单个资源,其初始值为1。但是,一般而言,信号量的初值可以是任意一个正值,该值表明有多少个共享资源单位可供共享应用。</p>
<p>下面3个特性造成了XSI信号量比较复杂：</p>
<ol>
<li>信号量并非是单个非负值,而必需定义为含有一个或多个信号量值的集合。</li>
<li>信号量的创建(semget)是独立于它的初始化(sectl)的。这是一个致命的缺点,因为不能原子地创建一个信号量集合,并且对该集合中的各个信号量值赋初值。</li>
<li>即使没有进程正在使用各种形式的XSI IPO,它们仍然是存在的。有的程序在终止时并没有释放已经分配给它的信号量,所以我们不得不为这种程序担心。</li>
</ol>
<p>当我们想使用XSI信号量时,首先需要通过调用函数 semget来获得一个信号量ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: semaphore ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>semctl函数包含对信号量的各种操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ... <span class="comment">/* union semun arg */</span> )</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: (see following)</span></div></pre></td></tr></table></figure></p>
<p>函数semop自动执行信号集合上面的操作数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">struct</span> sembuf semoparray[], <span class="keyword">size_t</span> nops)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>参数 semoparray是一个指针,它指向一个由 sembuf结构表示的信号量操作数组:</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254305267397.jpg" alt=""></p>
<h2 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h2><p>共享存储允许两个或多个进程共享一个给定的存储区。因为数据不需要在客户进程和服务器进程之间复制,所以这是最快的一种IPC。使用共享存储时要掌握的唯一窍门是,在多个进程之间同步访问一个给定的存储区。若服务器进程正在将数据放入共享存储区,则在它做完这一操作之前,客户进程不应当去取这些数据。通常,信号量用于同步共享存储访问。下面可以看到共享内存为什么是最快的一种IPC方式：</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274224200311.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274224241716.jpg" alt=""></p>
<p>我们已经看到了共享存储的一种形式,就是在多个进程将同一个文件映射到它们的地址空间的时候。XSI共享存储和内存映射的文件的不同之处在于,前者没有相关的文件。XSI共享存储段是内存的匿名段</p>
<p>内核为每一个共享存储段维护一个结构，包含以下成员：</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254405323155.jpg" alt=""></p>
<p>使用函数shmgget获取一个共享存储标识符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: shared memory ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>函数shmctl对共享存储段执行多种操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf )</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>一旦创建了一个共享存储段,进程就可调用 shmat将其连接到它的地址空间中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to shared memory segment if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>共享存储段连接到调用进程的哪个地址上与addr参数以及flag中是否指定SHM_RND位有关</p>
<ul>
<li>如果addr为0,则此段连接到由内核选择的第一个可用地址上。这是推荐的使用方式。</li>
<li>如果add非0,并且没有指定 SHM_RND,则此段连接到addr所指定的地址上。</li>
<li>如果add非0,并且指定了 SHM_RND,则此段连接到(addr-( addr mod SHMLBA))所表示的地址上。 SHM_RND命令的意思是“取整”。 SHMLBA的意思是“低边界地址倍数”,它总是2的乘方。该算式是将地址向下取最近1个 SHMLBA的倍数。</li>
</ul>
<p>当对共享存储段的操作已经结束时,则调用 shmdt与该段分离。注意,这<strong>并不从系统中删除其标识符以及其相关的数据结构</strong>。该标识符仍然存在,直至某个进程(一般是服务器进程)带IPC_RMID命令的调用shmctl特地删除它为止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *addr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>回忆一下mmap函数,它可将一个文件的若干部分映射至进程地址空间。这在概念上类似于用 shmat XSI IPC函数连接一个共享存储段。两者之间的主要区别是,用mmap映射的存储段是与文件相关联的,而XSI共享存储段则并无这种关联。</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254410116645.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第15章 进程间通信 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
</feed>
