<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sixzeroo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.liuin.cn/"/>
  <updated>2018-03-19T10:46:37.000Z</updated>
  <id>https://www.liuin.cn/</id>
  
  <author>
    <name>Sixzeroo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis源码解析——简单动态字符串(SDS)</title>
    <link href="https://www.liuin.cn/2018/03/19/Redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2-SDS/"/>
    <id>https://www.liuin.cn/2018/03/19/Redis源码解析——简单动态字符串-SDS/</id>
    <published>2018-03-19T10:45:00.000Z</published>
    <updated>2018-03-19T10:46:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>解析Redis的一个底层数据结构——简单动态数组，讨论起优点和不足</p>
<a id="more"></a>
<p>Redis没有直接使用C语言传统的字符串表示(以空字符结尾的字符数组),而是自己构建了一种名为<strong>简单动态字符串</strong>( simple dynamic string,SDS)的抽象类型,并将SDS用作 Redis的默认字符串表示。现在作者把这一个部分抽出来，单独做了一个项目，地址在<a href="https://github.com/antirez/sds" target="_blank" rel="external">这里</a></p>
<h2 id="数据结构定义定义"><a href="#数据结构定义定义" class="headerlink" title="数据结构定义定义"></a>数据结构定义定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sdshdr &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;   <span class="comment">// buf数组中已经使用的字节数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>;  <span class="comment">// buf数组中未使用的字节数量</span></div><div class="line">    <span class="keyword">char</span> buf[];         <span class="comment">// 字节数组，保存字符</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>SDS遵循C字符串以空字符结尾的惯例,保存空字符的1字节空间不计算在SDS的1en属性里面,并且为空字符分配额外的1字节空间,以及添加空字符到字符串末尾等操作</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><h3 id="获取字符串长度是常数级复杂度"><a href="#获取字符串长度是常数级复杂度" class="headerlink" title="获取字符串长度是常数级复杂度"></a>获取字符串长度是常数级复杂度</h3><p>C语言中获取字符串的长度需要把整个字符串都遍历一遍，而对于SDS来说，只需要访问len属性，将时间复杂度从O（N）降低到了O（1）</p>
<h3 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h3><p>除了获取字符串长度的复杂度高之外,C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出( buffer overflow)。C语言字符串进行拼接的时候如果不对原来的字符串分配足够的空间，容易造成溢出。</p>
<p>与C字符串不同,SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性:当SDS API需要对SDS进行修改时,API会先检查SDS的空间是否满足修改所需的要求,如果不满足的话,API会自动将SDS的空间扩展至执行修改所需的大小,然后才执行实际的修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 追加长度为len的字符串到buf的末尾</span></div><div class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh;</div><div class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</div><div class="line"></div><div class="line">    <span class="comment">// 扩展sds空间，确保其至少含有len+1个空间可以放置字符串</span></div><div class="line">    s = sdsMakeRoomFor(s,len);</div><div class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    <span class="comment">// 复制字符串</span></div><div class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</div><div class="line">    <span class="comment">// 更新长度</span></div><div class="line">    sh-&gt;len = curlen+len;</div><div class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>-len;</div><div class="line">    s[curlen+len] = <span class="string">'\0'</span>;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h3><p>C语言中，每次对字符串进行修改都要进行内存的重新分配，在SDS中使用<strong>空间预分配和惰性空间释放</strong>来减少内存重新分配的次数</p>
<blockquote>
<p>空间预分配</p>
</blockquote>
<p>SDS在执行空间扩展的时候将执行以下策略：</p>
<ul>
<li>如果对SDS进行修改之后,SDS的长度(也即是1en属性的值)将小于1MB,那么程序分配和1en属性同样大小的未使用空间,这时SDs1en属性的值将和free属性的值相同。</li>
<li>如果对SDs进行修改之后,SDS的长度将大于等于1MB,那么程序会分配1MB的未使用空间。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对sds中buf的长度进行扩展，至少有addlen+1长度的剩余空间</span></div><div class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh, *newsh;</div><div class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</div><div class="line">    <span class="keyword">size_t</span> len, newlen;</div><div class="line"></div><div class="line">    <span class="comment">// 目前剩余空间足够</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</div><div class="line">    len = sdslen(s);</div><div class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    newlen = (len+addlen);</div><div class="line">    <span class="comment">// 分配两倍空间</span></div><div class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</div><div class="line">        newlen *= <span class="number">2</span>;</div><div class="line">    <span class="comment">// 分配1M空间</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        newlen += SDS_MAX_PREALLOC;</div><div class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+newlen+<span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 更新剩余空间</span></div><div class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</div><div class="line">    <span class="keyword">return</span> newsh-&gt;buf;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>惰性空间释放</p>
</blockquote>
<p>惰性空间释放用于优化SDS的字符串缩短操作:当SDS的API需要缩短SDS保存的字符串时,程序并不立即使用内存重分配来回收缩短后多出来的字节,而是使用free属性将这些字节的数量记录起来,并等待将来使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 移除所有在s中出现过的cset字符</span></div><div class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    <span class="keyword">char</span> *start, *end, *sp, *ep;</div><div class="line">    <span class="keyword">size_t</span> len;</div><div class="line"></div><div class="line">    sp = start = s;</div><div class="line">    ep = end = s+sdslen(s)<span class="number">-1</span>;</div><div class="line">    <span class="keyword">while</span>(sp &lt;= end &amp;&amp; <span class="built_in">strchr</span>(cset, *sp)) sp++;</div><div class="line">    <span class="keyword">while</span>(ep &gt; start &amp;&amp; <span class="built_in">strchr</span>(cset, *ep)) ep--;</div><div class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep-sp)+<span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (sh-&gt;buf != sp) memmove(sh-&gt;buf, sp, len);</div><div class="line">    sh-&gt;buf[len] = <span class="string">'\0'</span>;</div><div class="line">    <span class="comment">// 并没有释放buf空间，而是增加free数量</span></div><div class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>+(sh-&gt;len-len);</div><div class="line">    sh-&gt;len = len;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>C字符串中的字符必须符合某种编码方式，并且除了字符串的末尾处，字符串里面不能包含空字符。使得C字符串只能保存文本数据,而不能保存像图片、音频、视频、压缩文件这样的二进制数据。</p>
<p>Redis可以适用于各种不同的使用场景,SDS的API都是二进制安全的(binary-safe),所有 SDS API都会以处理二进制的方式来处理SDs存放在buf数组里的数据</p>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><h3 id="API返回后不能确定内部是否重新分配了空间"><a href="#API返回后不能确定内部是否重新分配了空间" class="headerlink" title="API返回后不能确定内部是否重新分配了空间"></a>API返回后不能确定内部是否重新分配了空间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s = sdscat(s, <span class="string">"Hello world"</span>);</div></pre></td></tr></table></figure>
<p>s既是参数，又作为了返回值，原因是我们在调用sdscat函数之前不确定s的剩余空间是否足够分配出data长度的字节，如果不够的话，内部会重新malloc空间，然后把目前的sds包括头部全部挪过去，这样的话如果我们没有把返回的地址重新赋值给s,那么s实际上是失效的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解析Redis的一个底层数据结构——简单动态数组，讨论起优点和不足&lt;/p&gt;
    
    </summary>
    
      <category term="源码解析" scheme="https://www.liuin.cn/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>初识Redis</title>
    <link href="https://www.liuin.cn/2018/03/19/%E5%88%9D%E8%AF%86Redis/"/>
    <id>https://www.liuin.cn/2018/03/19/初识Redis/</id>
    <published>2018-03-19T10:41:15.000Z</published>
    <updated>2018-03-19T11:16:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是我在认识Redis过程中的一些笔记</p>
<a id="more"></a>
<h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>官网的介绍：</p>
<blockquote>
<p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.</p>
</blockquote>
<p>简单来说就是一个数据存储在内存中的一个key-value存储系统。</p>
<p>通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。而键（key）只能是字符串类型（String）</p>
<h2 id="Redis有什么优势"><a href="#Redis有什么优势" class="headerlink" title="Redis有什么优势"></a>Redis有什么优势</h2><h3 id="支持多种数据结构k"><a href="#支持多种数据结构k" class="headerlink" title="支持多种数据结构k"></a>支持多种数据结构k</h3><p>key-value系统中的值支持多种数据结构：字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)。使得我们使用的时候更加方便，更容易和已有的代码进行整合</p>
<h3 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h3><p>redis使用rdb和aof做数据的持久化存储。主从数据同时，生成rdb文件，并利用缓冲区添加新的数据更新操作做对应的同步。将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</p>
<h3 id="性能好"><a href="#性能好" class="headerlink" title="性能好"></a>性能好</h3><p>因为数据是存储在内存中，所以读写速度非常高。Redis能读的速度是110000次/s,写的速度是81000次/s 。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>Redis的所有操作都是原子的，同时支持几个操作合并以后的原子性</p>
<h3 id="丰富的特性"><a href="#丰富的特性" class="headerlink" title="丰富的特性"></a>丰富的特性</h3><p>支持pulish/subscribe、key过期等特性</p>
<h2 id="Redis有什么缺点"><a href="#Redis有什么缺点" class="headerlink" title="Redis有什么缺点"></a>Redis有什么缺点</h2><h3 id="使用内存，资源有限"><a href="#使用内存，资源有限" class="headerlink" title="使用内存，资源有限"></a>使用内存，资源有限</h3><p>因为数据存储在内存中，单台机器的存储数据量跟机器本身的内存大小有很大的关系。虽然redis本身有key过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。</p>
<h2 id="Redis-适用场景"><a href="#Redis-适用场景" class="headerlink" title="Redis 适用场景"></a>Redis 适用场景</h2><p>Redis因为其性能非常，所以很多在普通数据上运行不够理想的功能使用Redis都能够得到比较好的效果</p>
<h3 id="需要快速排序的相关应用"><a href="#需要快速排序的相关应用" class="headerlink" title="需要快速排序的相关应用"></a>需要快速排序的相关应用</h3><p>像排行榜、过期项目这些功能需要我们快速排序并进行更新，我们就可以使用到Redis</p>
<h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p>在很多普通数据库中实现一个计数器的功能往往会遇到写入敏感等一些问题。这个在Redis中能够有很好的解决：Redis支持原子递增（atomic increment）</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Redis能够替代memcached，让你的缓存从只能存储数据变得能够更新数据，因此你不再需要每次都重新生成数据了。</p>
<h2 id="安装及使用"><a href="#安装及使用" class="headerlink" title="安装及使用"></a>安装及使用</h2><p>这里可以参考官方文档或者<a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="external">菜鸟教程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是我在认识Redis过程中的一些笔记&lt;/p&gt;
    
    </summary>
    
      <category term="开发随笔" scheme="https://www.liuin.cn/categories/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》笔记 高级主题部分</title>
    <link href="https://www.liuin.cn/2018/03/18/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98%E9%83%A8%E5%88%86/"/>
    <id>https://www.liuin.cn/2018/03/18/《C-Primer》笔记-高级主题部分/</id>
    <published>2018-03-18T11:17:21.000Z</published>
    <updated>2018-03-19T11:18:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》笔记 高级主题部分，时间关系只看了其中一部分</p>
<a id="more"></a>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>大型程序往往会使用多个独立开发的库,这些库又会定义大量的全局名字,如类、函数和模板等。当应用程序用到多个供应商提供的库时,不可避免地会发生某些名字相互冲突的情况。多个库将名字放置在全局命名空间中将引发命名空间污染( namespace pollution)。</p>
<p><strong>命名空间</strong>( namespace)为防止名字冲突提供了更加可控的机制。<strong>命名空间分割了全局命名空间,其中每个命名空间是一个作用域</strong>。通过在某个命名空间中定义库的名字,库的作者(以及用户1)可以避免全局名字固有的限制。</p>
<h3 id="命名空间定义"><a href="#命名空间定义" class="headerlink" title="命名空间定义"></a>命名空间定义</h3><p>一个命名空间的定义包含两部分:首先是关键字 name space,随后是命名空间的名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内,主要包括:类、变量(及其初始化操作)、函数(及其定义)、模板和其他命名空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> cplusplus_primer &#123; </div><div class="line">    <span class="keyword">class</span> Sales_data &#123; / * ... * /&#125;; </div><div class="line">    Sales_data <span class="keyword">operator</span>+(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;); </div><div class="line">    <span class="keyword">class</span> Query &#123; <span class="comment">/* ... */</span> &#125;; </div><div class="line">    <span class="keyword">class</span> Query_base &#123; <span class="comment">/* ... */</span>&#125;; </div><div class="line">&#125; <span class="comment">// like blocks, namespaces do not end with a semicolon</span></div></pre></td></tr></table></figure>
<blockquote>
<p>每一个命名空间都是一个作用域</p>
</blockquote>
<p>和其他作用域类似,命名空间中的每个名字都必须表示该空间内的唯一实体。因为不同命名空间的作用域不同,所以在不同命名空间内可以有相同名字的成员。</p>
<blockquote>
<p>命名空间可以不连续</p>
</blockquote>
<p>命名空间可以定义在几个不同的部分,这点与其他作用域不太一样。命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件组成一个命名空间。此时,命名空间的组织方式类似于我们管理自定义类及函数的方式</p>
<ul>
<li>命名空间的一部分成员的作用是定义类,以及声明作为类接口的函数及对象,则这些成员应该置于头文件中,这些头文件将被包含在使用了这些成员的文件中。</li>
<li>命名空间成员的定义部分则置于另外的源文件中</li>
</ul>
<blockquote>
<p>定义命名空间成员</p>
</blockquote>
<p>假定作用域中存在合适的声明语句,则命名空间中的代码可以使用同一命名空间定义的名字的简写形式:</p>
<blockquote>
<p>全局命名空间</p>
</blockquote>
<p>全局作用域中定义的名字(即在所有类、函数及命名空间之外定义的名字)也就是定义在<strong>全局命名空间</strong>( global namespace)中。全局命名空间以隐式的方式声明,并且在所有程序中都存在。全局作用域中定义的名字被隐式地添加到全局命名空间中。</p>
<h3 id="使用命名空间成员"><a href="#使用命名空间成员" class="headerlink" title="使用命名空间成员"></a>使用命名空间成员</h3><p>像 namespace_name:: member_name 这样使用命名空间的成员显然非常烦琐,特别是当命名空间的名字很长时尤其如此。幸运的是,我们可以通过一些其他更简便的方法使用命名空间的成员。</p>
<blockquote>
<p>命名空间的别名</p>
</blockquote>
<p>命名空间的别名( namespace alias)使得我们可以为命名空间的名字设定一个短得多的同义词。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> primer = cplusplus_primer;</div></pre></td></tr></table></figure>
<blockquote>
<p>using声明：扼要概述</p>
</blockquote>
<p>一条using声明( using declaration)语句一次只引入命名空间的一个成员。它使得我们可以清楚地知道程序中所用的到底是哪个名字。</p>
<p>using声明引入的名字遵守与过去一样的作用域规则:它的有效范围从uS1ng声明的地方开始,一直到 using声明所在的作用域结束为止。在此过程中,外层作用域的同名实体将被隐藏。未加限定的名字只能在 using声明所在的作用域以及其内层作用域中使用。</p>
<blockquote>
<p>using 指示</p>
</blockquote>
<p>using指示( using directive)和 using声明类似的地方是,我们可以使用命名空间名字的简写形式:和 using声明不同的地方是,我们无法控制哪些名字是可见的,因为所有名字都是可见的</p>
<p>using指示以关键字using开始,后面是关键字 namespace以及命名空间的名字。</p>
<blockquote>
<p>using 指示与作用域</p>
</blockquote>
<p>using指示引入的名字的作用域远比 using声明引入的名字的作用域复杂。如我们所知,uS1ng声明的名字的作用域与uS1ng声明语句本身的作用域一致,从效果上看就好像 using声明语句为命名空间的成员在当前作用域内创建了一个别名一样。</p>
<p>using指示所做的绝非声明别名这么简单。相反,<strong>它具有将命名空间成员提升到包含命名空间本身和using指示的最近作用域的能力</strong>。    </p>
<blockquote>
<p>类、命名空间与作用域</p>
</blockquote>
<p>对命名空间内部名字的查找遵循常规的查找规则:即由内向外依次查找每个外层作用域。外层作用域也可能是一个或多个嵌套的命名空间,直到最外层的全局命名空间查找过程终止。只有位于开放的块中且在使用点之前声明的名字才被考虑</p>
<h2 id="tuple类型"><a href="#tuple类型" class="headerlink" title="tuple类型"></a>tuple类型</h2><p>tuple是类似pair的模板。每个pair的成员类型都不相同,但每个pair都恰好有两个成员。不同 tuple类型的成员类型也不相同,但<strong>一个tup1e可以有任意数量的成员</strong>。每个确定的 tuple类型的成员数目是固定的,但一个tuple类型的成员数目可以与另一个 tuple类型不同。</p>
<p>当我们希望将一些数据组合成单一对象,但又不想麻烦地定义一个新数据结构来表示这些数据时,tup1e是非常有用的。</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209268356387.jpg" alt=""></p>
<p>我们可以将 tuple看作一个“快速而随意”的数据结构。</p>
<h3 id="定义和初始化tuple"><a href="#定义和初始化tuple" class="headerlink" title="定义和初始化tuple"></a>定义和初始化tuple</h3><p>当我们定义一个 tuple时,需要指出每个成员的类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD; <span class="comment">// all three members set to 0 tuple&lt;string,</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;, <span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; someVal(<span class="string">"constants"</span>, &#123;<span class="number">3.14</span>, <span class="number">2.718</span>&#125;, <span class="number">42</span>, &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);</div></pre></td></tr></table></figure>
<p>当我们创建一个tup1e对象时,可以使用 tuple的默认构造函数,它会对每个成员进行值初始化;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">// error</span></div><div class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;   <span class="comment">// OK</span></div></pre></td></tr></table></figure>
<p>类似 make_pair函数,标准库定义了 make_tuple函,我们还可以用它来生成 tuple对象。</p>
<blockquote>
<p>访问tuple的成员</p>
</blockquote>
<p>tuple的成员都是未命名的。要访问一个 tuple的成员,就要使用一个名为get的标准库函数模板。为了使用get,我们必须指定一个显式模板实参,它指出我们想要访问第几个成员。我们传递给qet一个tup1e对象,它返回指定成员的引用:</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209364781943.jpg" alt=""></p>
<p>尖括号中的值必须是一个整型常量表达式。</p>
<p>如果不知道一个tup1e准确的类型细节信息,可以用两个辅助类模板来查询tuple成员的数量和类型:</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209366456481.jpg" alt=""></p>
<blockquote>
<p>关系和相等运算符</p>
</blockquote>
<p>tuple 的关系和相等运算符的行为类似容器的对应操作。</p>
<h3 id="使用tuple返回多个值"><a href="#使用tuple返回多个值" class="headerlink" title="使用tuple返回多个值"></a>使用tuple返回多个值</h3><p>tuple的一个常见用途是从一个函数返回多个值。</p>
<blockquote>
<p>返回tuple的函数</p>
</blockquote>
<p><img src="https://data2.liuin.cn/2018-03-13-15209367806251.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》笔记 高级主题部分，时间关系只看了其中一部分&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 题解——Longest Valid Parentheses</title>
    <link href="https://www.liuin.cn/2018/03/18/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Longest-Valid-Parentheses/"/>
    <id>https://www.liuin.cn/2018/03/18/LeetCode-题解——Longest-Valid-Parentheses/</id>
    <published>2018-03-18T01:52:16.000Z</published>
    <updated>2018-03-18T02:18:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题解——Longest Valid Parentheses</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个括号字符串，求出其中匹配的子字符串的最大长度</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>一个思路是用动态规划思想：用数组dp[i]表示以s[i]结尾的匹配子字符串的长度，这样我们可以得到状态转移方程：</p>
<p><img src="https://data2.liuin.cn/2018-03-18-15213386227746.jpg" alt=""></p>
<p>其中后面一个分支表示的情况是，最后以后<code>)</code>跳过前面的已经能够匹配的子字符串能和其前面的<code>(</code>匹配</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = s.length(), res = <span class="number">0</span>;</div><div class="line">        <span class="comment">// len+1 数组，最前面一个当做0</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(len+<span class="number">1</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i&gt;<span class="number">1</span> &amp;&amp; s[i<span class="number">-1</span>] == <span class="string">')'</span> &amp;&amp; s[i<span class="number">-2</span>] == <span class="string">'('</span>) dp[i]=dp[i<span class="number">-2</span>] + <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(i&gt;<span class="number">1</span> &amp;&amp; s[i<span class="number">-1</span>] == <span class="string">')'</span> &amp;&amp; s[i<span class="number">-2</span>] == <span class="string">')'</span> &amp;&amp; s[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>] == <span class="string">'('</span>) dp[i] = dp[i<span class="number">-1</span>] + dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>] + <span class="number">2</span>;</div><div class="line">            res = max(res, dp[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="利用栈"><a href="#利用栈" class="headerlink" title="利用栈"></a>利用栈</h3><p>这种括号字符串的题目，大部分都能够用栈来解决，按照以往的思路：遇到左括号入栈、遇到右括号出栈，这样输入匹配的括号之后，栈里面的东西不多不少，如果此时我们记录，第一个入栈时的位置，那么最后一个出栈的时候就可以通过位置（index）计算其长度了。</p>
<p>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</div><div class="line">        <span class="keyword">int</span> len = s.length();</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        st.push(<span class="number">-1</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</div><div class="line">                st.push(i);</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                st.pop();</div><div class="line">                <span class="comment">// 栈为空的时候表示新的串匹配开始</span></div><div class="line">                <span class="keyword">if</span>(st.empty())</div><div class="line">                    st.push(i);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                &#123;</div><div class="line">                    res = max(res, i-st.top());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题解——Longest Valid Parentheses&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.liuin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="DP" scheme="https://www.liuin.cn/tags/DP/"/>
    
      <category term="LeetCode" scheme="https://www.liuin.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX 数学公式</title>
    <link href="https://www.liuin.cn/2018/03/16/LaTeX-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <id>https://www.liuin.cn/2018/03/16/LaTeX-数学公式/</id>
    <published>2018-03-16T09:16:44.000Z</published>
    <updated>2018-03-16T11:03:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>平时写Markdown的时候难免会遇到一些用数学公式的情况，这里总结一些常用数学公式的写法。</p>
<a id="more"></a>
<h2 id="数学结构"><a href="#数学结构" class="headerlink" title="数学结构"></a>数学结构</h2><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p>常用的上下标结构</p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211921156811.jpg" alt=""></p>
<table>
<thead>
<tr>
<th>公式</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$A_{ij} = 2^{i+j}$</code></td>
<td>$A_{ij} = 2^{i+j}$</td>
</tr>
<tr>
<td><code>$A = 90^\circ$</code></td>
<td>$A = 90^\circ$</td>
</tr>
<tr>
<td><code>$\int_0^1 f(t) \dif t = \iint_D g(x, y) \dif x \dif y$</code></td>
<td>$\int_0^1 f(t) \cos t = \iint_D g(x, y) \cos x \sin y$</td>
</tr>
</tbody>
</table>
<h3 id="上下画线与花括号"><a href="#上下画线与花括号" class="headerlink" title="上下画线与花括号"></a>上下画线与花括号</h3><ul>
<li>\overline和\underline命令可用来在公式的上方和下方划横线</li>
<li>\overbrace和\underbrace带上花括号</li>
</ul>
<table>
<thead>
<tr>
<th>公式</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\overline{a+b} = \overline a \overline b$</code></td>
<td>$\overline{a+b} = \overline a \overline b$</td>
</tr>
<tr>
<td><code>$\overbrace {a+b+c} = \underbrace{1+2+3}$</code></td>
<td>$\overbrace {a+b+c} = \underbrace{1+2+3}$</td>
</tr>
</tbody>
</table>
<h3 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h3><p>分式使用<code>\face{分子}{分母}</code>得到</p>
<table>
<thead>
<tr>
<th>公式</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\frac{1}{\frac 12 (a+b)} = \frac{2}{a+b}$</code></td>
<td>$\frac{1}{\frac 12 (a+b)} = \frac{2}{a+b}$</td>
</tr>
</tbody>
</table>
<h3 id="根式"><a href="#根式" class="headerlink" title="根式"></a>根式</h3><p>根式是又一种常见的数学结构,用单参数的命令<code>\sqrt</code>得到,同时可以带一个可选参数,表示开方的次数</p>
<table>
<thead>
<tr>
<th>公式</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\sqrt[n] {\frac{x^2 + \sqrt 2}{x+y}}$</code></td>
<td>$\sqrt[n] {\frac{x^2 + \sqrt 2}{x+y}}$</td>
</tr>
</tbody>
</table>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>各种外括号不同的矩阵：</p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211932205959.jpg" alt=""></p>
<p>在矩阵环境中,不同的列用符号&amp;分隔,行用\分隔,矩阵每列中元素居中对齐</p>
<table>
<thead>
<tr>
<th>公式</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$ A = \begin{pmatrix} a &amp; b &amp; c \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; a \end{pmatrix}$</code></td>
<td>$ A = \begin {pmatrix} a &amp; b &amp; c \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; a \end {pmatrix}$</td>
</tr>
<tr>
<td><code>$ A = \begin{bmatrix} a_{11} &amp; \dots &amp; a_{1n} \\  &amp; \ddots &amp; \vdots \\ 0 &amp; &amp; a_{nn} \end{bmatrix} $</code></td>
<td>$ A = \begin{bmatrix} a_{11} &amp; \dots &amp; a_{1n} \\  &amp; \ddots &amp; \vdots \\ 0 &amp; &amp; a_{nn} \end{bmatrix} $</td>
</tr>
</tbody>
</table>
<h2 id="符号与类型"><a href="#符号与类型" class="headerlink" title="符号与类型"></a>符号与类型</h2><h3 id="字母表和普通符号"><a href="#字母表和普通符号" class="headerlink" title="字母表和普通符号"></a>字母表和普通符号</h3><p><img src="https://data2.liuin.cn/2018-03-16-15211956280206.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211956379753.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211956477483.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211956663623.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211956803907.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211956929506.jpg" alt=""></p>
<h3 id="数学算子"><a href="#数学算子" class="headerlink" title="数学算子"></a>数学算子</h3><p><img src="https://data2.liuin.cn/2018-03-16-15211957120206.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211957244734.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211957348221.jpg" alt=""></p>
<h3 id="二元运算符与关系符"><a href="#二元运算符与关系符" class="headerlink" title="二元运算符与关系符"></a>二元运算符与关系符</h3><p><img src="https://data2.liuin.cn/2018-03-16-15211957624199.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211957708521.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211957833150.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211957967157.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211958049898.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211958460225.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211958550071.jpg" alt=""></p>
<h3 id="括号与定界符"><a href="#括号与定界符" class="headerlink" title="括号与定界符"></a>括号与定界符</h3><p><img src="https://data2.liuin.cn/2018-03-16-15211959051369.jpg" alt=""></p>
<h3 id="标点"><a href="#标点" class="headerlink" title="标点"></a>标点</h3><p><img src="https://data2.liuin.cn/2018-03-16-15211959300033.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211959403756.jpg" alt=""></p>
<h2 id="在Hexo中使用LaTeX编辑数学公式"><a href="#在Hexo中使用LaTeX编辑数学公式" class="headerlink" title="在Hexo中使用LaTeX编辑数学公式"></a>在Hexo中使用LaTeX编辑数学公式</h2><p>在Hexo中编辑数学公式一般用的是<a href="https://github.com/hexojs/hexo-math" target="_blank" rel="external">这个</a>插件</p>
<p>其中有一个比较坑的点就是，不能够识别<code>\</code>和<code>_</code>这些符号，因为其在Markdown语法中也有一些意义，所以在某些情况下使用的时候还要在前面加一个<code>\</code>进行转义：</p>
<ul>
<li>后面接<code>,</code> 各种括号的时候，前面<code>_</code>所表示符号前面要加<code>\</code>转义</li>
</ul>
<p>另外可以更换markdown的渲染引擎，参考<a href="https://jdhao.github.io/2017/10/06/hexo-markdown-latex-equation/" target="_blank" rel="external">这里</a></p>
<p>主要参考：《LaTeX 入门》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时写Markdown的时候难免会遇到一些用数学公式的情况，这里总结一些常用数学公式的写法。&lt;/p&gt;
    
    </summary>
    
      <category term="开发随笔" scheme="https://www.liuin.cn/categories/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="LaTeX" scheme="https://www.liuin.cn/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 题解——Substring with Concatenation of All Words</title>
    <link href="https://www.liuin.cn/2018/03/15/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Substring-with-Concatenation-of-All-Words/"/>
    <id>https://www.liuin.cn/2018/03/15/LeetCode-题解——Substring-with-Concatenation-of-All-Words/</id>
    <published>2018-03-15T03:21:04.000Z</published>
    <updated>2018-03-15T03:22:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题解——Substring with Concatenation of All Words</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个字符串，和一组匹配字符串（vector），其中每一个字符串的长度是相同的，后面的这一组字符串可以形成一个组合，比如[“ab”,”cd”]可以组合成的字符串有：”abcd” “cdab”。题目要求我们在给定的这个字符串中查找出现后面这些组合的子串的位置（给出首字母位置）</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目中给出的匹配字符串组中每一个字符串的长度是相同的这个条件降低了题目的难度，如果从普通的字符串匹配的思路下手的话，就是每次从原串截取对比的长度是一样的，然后截取的字符串可以分割成几个长度相同的子字符串，我们只要判断这几个字符子串是否都在给出的这组匹配字符串中就行了。</p>
<p>这里使用两个unordered_map(Hash实现，性能更优)来判断是否都在这组字符串中，第一个map存储匹配字符串组中的字符串和出现的次数（都是1），第二个map存储截取的字符串分割以后的子串（并且在匹配字符串组中）以及其出现的次数，如果其次数大于1，表示截取的这段不符合条件，进行下一次匹配。</p>
<p>map有两个作用：查找字符串；记录出现次数</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        <span class="comment">// 用来进行对比的map</span></div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; contrast;</div><div class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> s : words)</div><div class="line">        &#123;</div><div class="line">            contrast[s]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> slen = s.length(), wlen = words[<span class="number">0</span>].length(), wsize = words.size();</div><div class="line">        <span class="comment">// 依次截取一定长度的字符串进行匹配</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;slen-wsize*wlen+<span class="number">1</span>; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; tem;</div><div class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(; j&lt;wsize; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">// 分割以后的每一个字符串</span></div><div class="line">                <span class="built_in">string</span> stem = s.substr(i+j*wlen, wlen);</div><div class="line">                <span class="comment">// 判断是否在匹配字符串组中</span></div><div class="line">                <span class="keyword">if</span>(contrast.find(stem) != contrast.end())</div><div class="line">                &#123;</div><div class="line">                    tem[stem]++;</div><div class="line">                    <span class="comment">// 出现次数超过1，放弃</span></div><div class="line">                    <span class="keyword">if</span>(tem[stem] &gt; contrast[stem])</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(j == wsize)</div><div class="line">                res.push_back(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题解——Substring with Concatenation of All Words&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.liuin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://www.liuin.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Coursera 吴恩达机器学习 课程笔记</title>
    <link href="https://www.liuin.cn/2018/03/13/Coursera-%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.liuin.cn/2018/03/13/Coursera-吴恩达机器学习-课程笔记/</id>
    <published>2018-03-13T06:27:40.000Z</published>
    <updated>2018-03-16T11:01:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Coursera 吴恩达机器学习 课程笔记</p>
<a id="more"></a>
<h1 id="监督学习和无监督学习"><a href="#监督学习和无监督学习" class="headerlink" title="监督学习和无监督学习"></a>监督学习和无监督学习</h1><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>维基百科中的定义：</p>
<blockquote>
<p>监督式学习（英语：Supervised learning），是一个机器学习中的方法，可以由训练资料中学到或建立一个模式（函数 / learning model），并依此模式推测新的实例。训练资料是由输入物件（通常是向量）和预期输出所组成。函数的输出可以是一个连续的值（称为回归分析），或是预测一个分类标签（称作分类）</p>
</blockquote>
<p>在监督学习中, 我们的预测结果可以是连续值, 也可以是离散值. 我们根据这样的属性将监督学习氛围回归问题和分类问题.</p>
<h3 id="监督学习举例"><a href="#监督学习举例" class="headerlink" title="监督学习举例"></a>监督学习举例</h3><blockquote>
<p>回归问题</p>
</blockquote>
<p>通过给定的一个房子的面积来预测这个房子在市场中的价格. 这里的房子的面积就是特征, 房子的价格就是一个输出值. 为了解决这个问题, 我们获取了大量的房地产数据, 每一条数据都包含房子的面积及其对应价格. 第一, 我们的数据不仅包含房屋的面积, 还包含其对应的价格, 而我们的目标就是通过面积预测房价. 所以这应该是一个监督学习; 其次, 我们的输出数据房价可以看做是连续的值, 所以这个问题是一个回归问题.</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208368350754.jpg" alt=""></p>
<blockquote>
<p>分类问题</p>
</blockquote>
<p>我们的目标应该是要对数据进行分类. 现在我们的数据是有关乳腺癌的医学数据, 它包含了肿瘤的大小以及该肿瘤是良性的还是恶性的. 我们的目标是给定一个肿瘤的大小来预测它是良性还是恶性. 我们可以用0代表良性，1代表恶性. 这就是一个分类问题, 因为我们要预测的是一个离散值. </p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208368814648.jpg" alt=""></p>
<p>在这个例子中特征只有一个即瘤的大小。 对于大多数机器学习的问题, 特征往往有多个(上面的房价问题也是, 实际中特征不止是房子的面积). 例如下图， 有“年龄”和“肿瘤大小”两个特征。</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208369551948.jpg" alt=""></p>
<h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>在无监督学习中, 我们的数据并没有给出特定的标签, 例如上面例子中的房价或者是良性还是恶性. 我们目标也从预测某个值或者某个分类变成了寻找数据集中特殊的或者对我们来说有价值结构. </p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208370522571.jpg" alt=""></p>
<h3 id="无监督学习举例"><a href="#无监督学习举例" class="headerlink" title="无监督学习举例"></a>无监督学习举例</h3><blockquote>
<p>新闻分类</p>
</blockquote>
<p>Google News搜集网上的新闻，并且根据新闻的主题将新闻分成许多簇, 然后将在同一个簇的新闻放在一起。如图中红圈部分都是关于BP Oil Well各种新闻的链接，当打开各个新闻链接的时候，展现的都是关于BP Oil Well的新闻。</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208370968972.jpg" alt=""></p>
<blockquote>
<p>根据给定基因将人群分类</p>
</blockquote>
<p><img src="https://data2.liuin.cn/2018-03-12-15208371698906.jpg" alt=""></p>
<h1 id="单变量线性回归"><a href="#单变量线性回归" class="headerlink" title="单变量线性回归"></a>单变量线性回归</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="训练集"><a href="#训练集" class="headerlink" title="训练集"></a>训练集</h3><p>由训练样例(training example)组成的集合就是训练集(training set)</p>
<h3 id="假设函数"><a href="#假设函数" class="headerlink" title="假设函数"></a>假设函数</h3><p>使用某种学习算法对训练集的数据进行训练, 我们可以得到假设函数(Hypothesis Function)</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208382454378.jpg" alt=""></p>
<p>我们使用如下方法表示假设函数，</p>
<p>$$ {h_\theta(x)=\theta_0+\theta_1x} $$</p>
<p>以上这个模型就叫做单变量的线性回归(Linear Regression with One Variable).</p>
<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><h3 id="什么是代价函数"><a href="#什么是代价函数" class="headerlink" title="什么是代价函数"></a>什么是代价函数</h3><p>只要我们知道了假设函数, 我们就可以进行预测了. 关键是, 假设函数中有两个未知的量$\theta_0$,$\theta_1$. 当选择不同的$\theta_0$和$\theta_1$时, 我们模型的效果肯定是不一样的. 我们的想法是选择某个$\theta_0$和$\theta_1$，使得对于训练样例$(x,y)$，$h_\theta(x)$最“接近”$y$。越是接近, 代表这个假设函数越是准确, 这里我们选择均方误差来作为衡量标准, 即我们想要每个样例的估计值与真实值之间差的平方的均值最小:（其中$1/2$只是为了我们后面计算方便）</p>
<p>$$<br>{\mathop{min}\limits_{\theta_0,\theta_1}\frac{1}{2m}\sum_{i=0}^m\left(h_\theta(x^{(i)})-y^{(i)}\right)^2}<br>$$</p>
<p>记作：</p>
<p>$${J(\theta_0,\theta_1) = \frac{1}{2m}\sum_{i=0}^m\left(h_\theta(x^{(i)})-y^{(i)}\right)^2 }$$</p>
<p>这样就得到了我们的代价函数(cost function), 也就是我们的优化目标, 我们想要代价函数最小:</p>
<p>$$ \mathop{min}\limits_{\theta_0,\theta_1}J(\theta_0,\theta_1)$$</p>
<h3 id="代价函数和假设函数"><a href="#代价函数和假设函数" class="headerlink" title="代价函数和假设函数"></a>代价函数和假设函数</h3><p>对于不同的$\theta_1$，对应着不同的假设函数$h_\theta(x)$，于是就有了不同的代价函数$J (\theta_1)$的值。将这些点连接起来就可以得到$J(\theta_1)$和$\theta_1$关系的图像：</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208395529904.jpg" alt=""></p>
<p>我们的目标是找到一个$\theta$使得$J(\theta_1)$最小</p>
<p>如果我们考虑两个变量，能够绘制$J(\theta_0,\theta_1)$的图形如下</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208397051963.jpg" alt=""></p>
<p>由于3D图形不太方便我们研究，我们就使用二维的等高线(上图右上角教授写的contour plots/figures)，这样看上去比较清楚一些。越靠近中心表示$J(\theta_0,\theta_1)$值越小</p>
<h2 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h2><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>梯度下降算法是一种优化算法, 它可以帮助我们找到一个函数的局部极小值点. 它不仅仅可以用在线性回归模型中, 在机器学习许多其他的模型中也可以使用它. 对于我们现在研究的单变量线性回归来说, 我们想要使用梯度下降来找到最优的$\theta_0$,$\theta_1$。</p>
<p>它的思想是，首先随机选择两个$\theta_0$,$\theta_1$，不断改变他们的值使得$J(\theta)$最小，最终找到$J(\theta)$的最小点</p>
<p>可以把梯度下降的过程想象成下山坡, 如果想要尽可能快的下坡, 应该每次都往坡度最大的方向下山.</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208400482188.jpg" alt=""></p>
<p>算法过程：（要注意的是，算法是每次同时改变$\theta_0$和$\theta_1$的值）</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208401837391.jpg" alt=""></p>
<h3 id="梯度和学习率"><a href="#梯度和学习率" class="headerlink" title="梯度和学习率"></a>梯度和学习率</h3><p>学习率$\alpha$会影响梯度下降的幅度。如果$\alpha$的值太小，$\theta$的值每次会变化很小，那么梯度下降就会比较慢；相反，如果$\alpha$过大，$\theta$的值每次就会变化很大，有可能超过最低点，可能导致永远没法到达最低点。</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208404559020.jpg" alt=""></p>
<p>由于随着越来越接近最低点, 相应的梯度(绝对值)也会逐渐减小，所以每次下降程度就会越来越小, 我们并不需要减小$\alpha$的值来减小下降程度。</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208404858375.jpg" alt=""></p>
<h3 id="计算梯度"><a href="#计算梯度" class="headerlink" title="计算梯度"></a>计算梯度</h3><p>将偏导计算出来就得到了完整梯度下降算法：</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208405675961.jpg" alt=""></p>
<p>事实上，用于线性回归的代价函数总是一个凸函数(Convex Function)。这样的函数没有局部最优解，只有一个全局最优解。所以我们在使用梯度下降的时候，总会得到一个全局最优解。</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208406207656.jpg" alt=""></p>
<h1 id="多变量线性回归"><a href="#多变量线性回归" class="headerlink" title="多变量线性回归"></a>多变量线性回归</h1><h2 id="假设函数-1"><a href="#假设函数-1" class="headerlink" title="假设函数"></a>假设函数</h2><p>在之前的单变量线性回归中, 我们的问题只涉及到了房子面积这一个特征。在实际问题中, 会有很多特征. 例如, 除了房子面积, 还有房子的卧室数量, 房子的楼层数, 房子建筑年龄.</p>
<p>在单变量线性回归中假设函数为：</p>
<p>$${h_\theta(x)=\theta_0+\theta_1x}$$</p>
<p>现在对于多变量，可以设其假设函数为：</p>
<p>$${h_\theta(x)=\theta_0+\theta_1x_1+\theta_2x_2+…+\theta_nx_n}$$</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208613808836.jpg" alt=""></p>
<p>得到其向量表示：</p>
<p>$${h_\theta(x)=\theta_0x_0+\theta_1x_1+\theta_2x_2+…+\theta_nx_n= \theta^Tx}$$</p>
<h2 id="梯度下降-1"><a href="#梯度下降-1" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>多变量情况下的梯度下降其实没有区别, 只需要把对应的偏导数项换掉即可</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208618844580.jpg" alt=""></p>
<h2 id="特征处理"><a href="#特征处理" class="headerlink" title="特征处理"></a>特征处理</h2><h3 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h3><p>如果每个特征的范围相差的很大, 梯度下降会很慢. 为了解决这个问题, 我们在梯度下降之前应该对数据做特征归缩放(Feature Scaling)处理, 从而将所有的特征的数量级都在一个差不多的范围之内, 以加快梯度下降的速度.</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208619474872.jpg" alt=""></p>
<p>通常我们需要把特征都缩放到$[-1,1]$(附近)这个范围</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208619856026.jpg" alt=""></p>
<h3 id="均值均一化"><a href="#均值均一化" class="headerlink" title="均值均一化"></a>均值均一化</h3><p>还有一个特征处理的方法就是均值归一化(Mean normalization)</p>
<p>$${x_i=\frac{x_i-\mu_i}{max-min}}$$</p>
<h2 id="代价函数与学习率"><a href="#代价函数与学习率" class="headerlink" title="代价函数与学习率"></a>代价函数与学习率</h2><p>我们可以通过画出$\mathop{min}\limits_{\theta}J(\theta)$与迭代次数的关系来观察梯度下降的运行情况，</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209095236343.jpg" alt=""></p>
<p>出现下面两种情况，应该选择更小的学习率$\alpha$，</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209096625766.jpg" alt=""></p>
<p>注意：</p>
<ul>
<li>如果$\alpha$足够小，，那么$J(\theta)$在每次迭代之后都会减小</li>
<li>如果$\alpha$太小， 梯度下降会进行的非常缓慢.</li>
</ul>
<p>进行尝试的值：<br><img src="https://data2.liuin.cn/2018-03-13-15209097782077.jpg" alt=""></p>
<h2 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h2><p>多项式回归(Polynomial Regression)是研究一个因变量与一个或多个自变量间多项式的回归分析方法。如果自变量只有一个时，称为一元多项式回归；如果自变量有多个时，称为多元多项式回归。</p>
<p>我们可以将房屋的面积作为第一个特征, 面积的平方作为第二个特征, 面积的立方作为第三个特征:</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209102744925.jpg" alt=""></p>
<p>除了三次函数模型, 这里也可以选择平方根函数模型, 如下图所示</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209107024350.jpg" alt=""></p>
<h2 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h2><h3 id="正规方程介绍"><a href="#正规方程介绍" class="headerlink" title="正规方程介绍"></a>正规方程介绍</h3><p>之前我们一直是用的梯度下降求解最优值. 它的缺点就是需要进行很多次迭代才能得到全局最优解. 有没有更好的方法呢? 我们先来看一个最简单的例子, 假设现在的代价函数为$J(\theta)=a\theta^2+b\theta+c$，在导数等于0的时候取到最优解。</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209111273173.jpg" alt=""></p>
<p>下面我们介绍一种向量化的求解方法。首先, 在数据集前加上一列$X_0$，值都为1，然后将所有的变量都放入矩阵$X$中（包括加上的$x_0$）；再将输出值放入向量$y$中. 最后通过公式$$\theta=(X^TX)^{-1}X^Ty$$就可以算出最优解</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209221924071.jpg" alt=""></p>
<p>更通用的表达方式</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209222169590.jpg" alt=""></p>
<h3 id="梯度下降和正规方程的比较"><a href="#梯度下降和正规方程的比较" class="headerlink" title="梯度下降和正规方程的比较"></a>梯度下降和正规方程的比较</h3><p><img src="https://data2.liuin.cn/2018-03-13-15209222993254.jpg" alt=""></p>
<h3 id="正规方程不可逆的情况"><a href="#正规方程不可逆的情况" class="headerlink" title="正规方程不可逆的情况"></a>正规方程不可逆的情况</h3><p>使用正规方程还有一个问题就是$X^TX$可能存在不可逆的情况. 这个时候, 可能是因为我们使用了冗余的特征, 还有一个原因是我们使用了太多的特征(特征的数量超过了样本的数量). 对于这种情况我们可以删掉一些特征或者使用正则化(正则化在后面的课中讲).</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209223711085.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Coursera 吴恩达机器学习 课程笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="https://www.liuin.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》笔记 类设计者的工具部分</title>
    <link href="https://www.liuin.cn/2018/03/11/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7%E9%83%A8%E5%88%86/"/>
    <id>https://www.liuin.cn/2018/03/11/《C-Primer》笔记-类设计者的工具部分/</id>
    <published>2018-03-11T11:58:50.000Z</published>
    <updated>2018-03-13T02:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》笔记 类设计者的工具部分</p>
<a id="more"></a>
<h1 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h1><p>当定义一个类时,我们显式地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作,包括:拷贝构造函数( copy constructor)、拷贝赋值运算符( copy-assignment operator)、移动构造函数(moveconstructor)、移动赋值运算符(move-assignment operator)和析构函数( destructor)。</p>
<h2 id="拷贝、赋值与销毁"><a href="#拷贝、赋值与销毁" class="headerlink" title="拷贝、赋值与销毁"></a>拷贝、赋值与销毁</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>如果一个构造函数的第一个参数是自身类类型的引用,且任何额外参数都有默认值,则此构造函数是拷贝构造函数。</p>
<p>拷贝构造函数的第一个参数必须是一个引用类型,原因我们稍后解释。虽然我们可以定义个接受非 const引用的拷贝构造函数,但此参数几乎总是一个 const的引用。拷贝构造函数在几种情况下都会被隐式地使用。因此,拷贝构造函数通常不应该是 explicit的</p>
<blockquote>
<p>合成拷贝构造函数</p>
</blockquote>
<p>对某些类来说,合成拷贝构造函数( synthesized copy constructor)用来阻止我们拷贝该类类型的对象。而一般情况,<strong>合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中</strong>。</p>
<blockquote>
<p>拷贝初始化</p>
</blockquote>
<p>当使用直接初始化时,我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。当我们使用拷贝初始化(copy initialization)时,我们要求<strong>编译器将右侧运算对象拷贝到正在创建的对象中,如果需要的话还要进行类型转换</strong>。</p>
<blockquote>
<p>参数和返回值</p>
</blockquote>
<p>在函数调用过程中,具有非引用类型的参数要进行拷贝初始化。类似的,当一个函数具有非引用的返回类型时,返回值会被用来初始化调用方的结果。</p>
<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><blockquote>
<p>重载赋值运算符</p>
</blockquote>
<p>重载运算符本质上是函数,其名字由 operator关键字后接表示要定义的运算符的符号组成。因此,赋值运算符就是一个名为 operator=的函数。类似于任何其他函数,运算符函数也有一个返回类型和一个参数列表。</p>
<p>重载运算符的参数表示运算符的运算对象。某些运算符,包括赋值运算符,必须定义为成员函数。如果一个运算符是一个成员函数,其左侧运算对象就绑定到隐式的this参数。对于一个二元运算符,例如赋值运算符,其右侧运算对象作为显式参数传递。</p>
<p>为了与内置类型的赋值保持一致,<strong>赋值运算符通常返回一个指向其左侧运算对象的引用</strong>。另外值得注意的是,标准库通常要求保存在容器中的类型要具</p>
<blockquote>
<p>合成拷贝赋值运算符</p>
</blockquote>
<p>与处理拷贝构造函数一样,如果一个类未定义自己的拷贝赋值运算符,编译器会为它生成一个合成拷贝赋值运算符</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数执行与构造函数相反的操作:构造函数初始化对象的非 static数据成员还可能做一些其他工作;析构函数释放对象使用的资源,并销毁对象的非 static数据成员</p>
<blockquote>
<p>析构函数完成什么工作</p>
</blockquote>
<p>如同构造函数有一个初始化部分和一个函数体,析构函数也有一个函数体和一个析构部分。在一个构造函数中,成员的初始化是在函数体执行之前完成的,且按照它们在类中出现的顺序进行初始化。<strong>在一个析构函数中,首先执行函数体,然后销毁成员。成员按初始化顺序的逆序销毁</strong>。</p>
<blockquote>
<p>什么时候用到析构函数</p>
</blockquote>
<p>无论何时一个对象被销毁,就会自动调用其析构函数:</p>
<ol>
<li>变量在离开其作用域时被销毁。</li>
<li>当一个对象被销毁时,其成员被销毁。</li>
<li>容器(无论是标准库容器还是数组)被销毁时,其元素被销毁。</li>
<li>对于动态分配的对象,当对指向它的指针应用 delete运算符时被销毁</li>
<li>对于临时对象,当创建它的完整表达式结束时被销毁。</li>
</ol>
<blockquote>
<p>合成析构函数</p>
</blockquote>
<p>当一个类未定义自己的析构函数时,编译器会为它定义一个合成析构函数( synthesizeddestructor)。类似拷贝构造函数和拷贝赋值运算符,对于某些类,合成析构函数被用来阻止该类型的对象被销毁。如果不是这种情况，合成析构函数就为空</p>
<p>认识到析构函数体自身并不直接销毁成员是非常重要的。<strong>成员是在析构函数体之后隐含的析构阶段中被销毁的</strong>。在整个对象销毁过程中,析构函数体是作为成员销毁步骤之外的另一部分而进行的。</p>
<h3 id="三-五法则"><a href="#三-五法则" class="headerlink" title="三/五法则"></a>三/五法则</h3><p>如前所述,有三个基本操作可以控制类的拷贝操作:拷贝构造函数、拷贝赋值运算符和析构函数。</p>
<blockquote>
<p>需要析构函数的类也需要拷贝和赋值操作</p>
</blockquote>
<p>当我们决定一个类是否要定义它自己版本的拷贝控制成员时,一个基本原则是<strong>首先确定这个类是否需要一个析构函数。通常,对析构函数的需求要比对拷贝枃造函数或赋偵运算符的需求更为明显</strong>。如果这个类需要一个析构函数,我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。</p>
<blockquote>
<p>需要拷贝操作的类也需要赋值操作，反之亦然</p>
</blockquote>
<p>虽然很多类需要定义所有(或是不需要定义任何)拷贝控制成员,但某些类所要完成的工作,只需要拷贝或赋值操作,不需要析构函数。</p>
<p>这个例子引出了第二个基本原则:如果一个类需要一个拷贝构造函数,几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然—如果一个类需要一个拷贝赋值运篁符,几平可以肯定它也需要一个拷贝构造函数。然而,无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。</p>
<h3 id="使用-default"><a href="#使用-default" class="headerlink" title="使用=default"></a>使用=default</h3><p>我们可以通过将拷贝控制成员定义为= defau1t来显式地要求编译器生成合成的版本</p>
<p><img src="https://data2.liuin.cn/2018-03-05-15202146959452.jpg" alt=""></p>
<h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><p>虽然大多数类应该定义(而且通常也的确定义了)拷贝构造函数和拷贝赋值运算符,但对某些类来说,这些操作没有合理的意义。在此情况下,定义类时必须采用某种机制阻止拷贝或赋值。</p>
<blockquote>
<p>定义删除的函数</p>
</blockquote>
<p>在新标准下,我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数( deletedfunction)来阻止拷贝。删除的函数是这样一种函数:我们虽然声明了它们,但不能以任何方式使用它们]。在函数的参数列表后面加上=de1ete来指出我们希望将它定义为删除的:</p>
<blockquote>
<p>析构函数不能是删除的成员</p>
</blockquote>
<p>值得注意的是,我不能删除析构函数。如果析构函数被删除,就无法销毁此类型的对象了。对于一个删除了析构函数的类型,编译器将不允许定义该类型的变量或创建该类的临时对象。而且,如果一个类有某个成员的类型删除了析构函数,我们也不能定义该类</p>
<blockquote>
<p>private 拷贝控制</p>
</blockquote>
<p>在新标准发布之前,类是通过将其拷贝构造函数和拷贝赋值运算符声明为 private的来阻止拷贝:</p>
<p><img src="https://data2.liuin.cn/2018-03-05-15202148530112.jpg" alt=""></p>
<p>友元和成员函数仍旧可以拷贝对象。为了阻止友元和成员函数进行拷贝,我们将这些拷贝控制成员声明为 private的,但并不定义它们。</p>
<h2 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h2><p>通常,管理类外资源的类必须定义拷贝控制成员。某些类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数,那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。为了定义这些成员,我首先必须确定此类型对象的拷贝语义。一般来说,有两种选择:可以定义拷贝操作,<strong>使类的行为看起来像一个值或者像一个指针</strong>。</p>
<p>类的行为像一个值,意味着它应该也有自己的状态。当我们拷贝一个像值的对象时,副本和原对象是完全独立的。改变副本不会对原对象有任何影响,反之亦然。</p>
<p>行为像指针的类则共享状态。当我们拷贝一个这种类的对象时,副本和原对象使用相同的底层数据。改变副本也会改变原对象,反之亦然</p>
<h3 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h3><p>为了提供类值的行为,对于类管理的资源,每个对象都应该拥有一份自己的拷贝。这意味着对于ps指向的 string,每个 Hasptr对象都必须有自己的拷贝。</p>
<blockquote>
<p>类值拷贝赋值运算符</p>
</blockquote>
<p>赋值运算符通常组合了析构函数和构造函数的操作。类似析构函数,赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数,赋值操作会从右侧运算对象拷贝数据。</p>
<h3 id="定义行为像指针的类"><a href="#定义行为像指针的类" class="headerlink" title="定义行为像指针的类"></a>定义行为像指针的类</h3><p>对于行为类似指针的类,我们需要为其定义拷贝构造函数和拷贝赋值运算符,来拷贝指针成员本身而不是它指向的 string。我们的类仍然需要自己的析构函数来释放接受string参数的构造函数分配的内存。</p>
<p>令一个类展现类似指针的行为的最好方法是使用 share_ptr来管理类中的资源</p>
<p>但是,有时我们希望直接管理资源。在这种情况下,使用<strong>引用计数</strong>( reference count)就很有用了。</p>
<blockquote>
<p>定义一个使用引用计数的类</p>
</blockquote>
<p><img src="https://data2.liuin.cn/2018-03-05-15202156946283.jpg" alt=""></p>
<h2 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h2><p>除了定义拷贝控制成员,管理资源的类通常还定义一个名为swap的函数。对于那些与重排元素顺序的算法一起使用的类,定义swap是非常重要的。这类算法在需要交换两个元素时会调用swap。</p>
<p>为了交换两个对象，我们需要一次拷贝和两次赋值</p>
<blockquote>
<p>在赋值运算符中使用swap</p>
</blockquote>
<p>定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为拷贝并交换( copy and swap)的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换</p>
<h2 id="动态内存管理类"><a href="#动态内存管理类" class="headerlink" title="动态内存管理类"></a>动态内存管理类</h2><p>某些类需要在运行时分配可变大小的内存空间。这种类通常可以(并且如果它们确实可以的话,一般应该)使用标准库容器来保存它们的数据。</p>
<p>但是,这一策略并不是对每个类都适用:某些类需要自己进行内存分配。这些类一般来说必须定义自己的拷贝控制成员来管理所分配的内存</p>
<h2 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h2><p>新标准的一个最主要的特性是可以移动而非拷贝对象的能力。在某些情况下,移动而非拷贝对象会大幅度提升性能。</p>
<p>在旧C++标准中,没有直接的方法移动对象。因此,即使不必拷贝对象的情况下,我们也不得不拷贝。如果对象较大,或者是对象本身要求分配内存空间(如 string),进行不必要的拷贝代价非常高。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>为了支持移动操作,新标准引入了一种新的引用类型——<strong>右值引用</strong>( rvalue reference)。所谓右值引用就是必须绑定到右值的引用。我们通过&amp;&amp;而不是&amp;来获得右值引用。如我们将要看到的,右值引用有一个重要的性质——一只能绑定到一个将要销毁的对象。</p>
<p>一般而言,一个左值表达式表示的是一个对象的身份,而一个右值表达式表示的是对象的值</p>
<p>类似任何引用,一个右值引用也不过是某个对象的另一个名字而已。如我们所知,对于常规引|用(为了与右值引用区分开来,我们可以称之为左值引用( Ivalue reference),我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用有着完全相反的绑定特性:<strong>我们可以将一个右值引用绑定到这类表达式上,但不能将一个右值引用直接绑定到一个左值上</strong></p>
<p><img src="https://data2.liuin.cn/2018-03-05-15202204986268.jpg" alt=""></p>
<blockquote>
<p>左值持久，右值短暂</p>
</blockquote>
<p>考察左值和右值表达式的列表,两者相互区别之处就很明显了:左值有持久的状态而右值要么是字面常量,要么是在表达式求值过程中创建的临时对象。</p>
<p>由于右值引用只能绑定到临时对象,我们得知</p>
<ul>
<li>所引用的对象将要被销毁</li>
<li>该对象没有其他用户</li>
</ul>
<p>这两个特性意味着:使用右值引用的代码可以自由地接管所引用的对象的资源</p>
<blockquote>
<p>标准库move函数</p>
</blockquote>
<p>虽然不能将一个右值引用直接绑定到一个左值上,但我们可以显式地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用,此函数定义在头文件uti1ity中。</p>
<h3 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h3><p>类似拷贝构造函数,移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是,这个引用参数在移动构造函数中是一个右值引|用。与拷贝构造函数一样,任何额外的参数都必须有默认实参。</p>
<p>除了完成资源移动,移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。特别是,一旦资源完成移动,源对象必须不再指向被移动的资源——这些资源的所有权已经归属新创建的对象</p>
<blockquote>
<p>移动赋值运算符</p>
</blockquote>
<p>移动赋值运算符执行与析构函数和移动构造函数相同的工作。与移动构造函数一样如果我们的移动赋值运算符不抛出任何异常,我们就应该将它标记为 except。</p>
<hr>
<h1 id="操作重载和类型转换"><a href="#操作重载和类型转换" class="headerlink" title="操作重载和类型转换"></a>操作重载和类型转换</h1><p>当运算符被用于类类型的对象时,C+语言允许我们为其指定新的含义:同时,我们也能自定义类类型之间的转换规则。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>重载的运算符是具有特殊名字的函数:它们的名字由关键字 operator和其后要定义的运算符号共同组成。和其他函数一样,重载的运算符也包含返回类型、参数列表以及函数体。</p>
<p>重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有个参数,二元运算符有两个。</p>
<p>如果一个运算符函数是成员函数,则它的第一个(左侧)运算对象绑定到隐式的this指针上。</p>
<p>可以被重载的运算符：<br><img src="https://data2.liuin.cn/2018-03-06-15202996380435.jpg" alt=""></p>
<p>我们只能重载已有的运算符,而无权发明新的运算符号。对于一个重载的运算符来说,其优先级和结合律与对应的内置运算符保持一致。</p>
<blockquote>
<p>直接调用重载运算符函数</p>
</blockquote>
<p>我们也能像调用普通函数一样直接调用运算符函数,先指定函数名字,然后传入数量正确、类型适当的实参:</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15202997181932.jpg" alt=""></p>
<blockquote>
<p>某些运算符不应该被重载</p>
</blockquote>
<p>回忆之前介绍过的,某些运算符指定了运算对象求值的顺序。因为使用重载的运算符本质上是一次函数调用,所以这些<strong>关于运算对象求值顺序的规则无法应用到重载的运算符上</strong>。特别是,逻辑与运算符、逻辑或运算符和逗号运算符的运算对又象求值顺序规则无法保留下来</p>
<p>还有一个原因使得我们一般不重载逗号运算符和取地址运篁符:C+语言已经<strong>定义了这两种运算符用于类类型对象时的特殊含义</strong>,这一点与大多数运算符都不相同。因为这两种运算符已经有了内置的含义,所以一般来说它们不应该被重载,否则它们的行为将异于常态,从而导致类的用户无法适应。</p>
<blockquote>
<p>赋值和复合赋值运算符</p>
</blockquote>
<p>赋值运算符的行为与复合版本的类似:赋值之后,左侧运算对象和右侧运算对象的值相等,并且运算符应该返回它左侧运算对象的一个引用。<strong>重载的赋值运算应该继承而非违背其内置版本的含义</strong>。</p>
<h2 id="输入和输出运算符"><a href="#输入和输出运算符" class="headerlink" title="输入和输出运算符"></a>输入和输出运算符</h2><p>IO标准库分别使用&gt;&gt;和&lt;&lt;执行输入和输出操作。</p>
<h3 id="重载输出运算符-lt-lt"><a href="#重载输出运算符-lt-lt" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符&lt;&lt;</h3><p>输出运算符的<strong>第一个形参是一个非常量 ostream对象的引用</strong>。之所以ostream是非常量是因为向流写入内容会改变其状态;而该形参是引用是因为我们无法直接复制一个 ostream对象。</p>
<p><strong>第二个形参一般来说是一个常量的引用,该常量是我们想要打印的类类型</strong>。第二个形参是引用的原因是我们希望避免复制实参;而之所以该形参可以是常量是因为(通常情况下)打印对象不会改变对象的内容。</p>
<p>为了与其他输出运算符保持一致, operator&lt;&lt;一般要返回它的 ostream形参。</p>
<blockquote>
<p>输入运算符尽量减少格式化操作</p>
</blockquote>
<p>用于内置类型的输出运算符不太考虑格式化操作,尤其不会打印换行符,用户希望类的输出运算符也像如此行事。如果运算符打印了换行符,则用户就无法在对象的同一行内接着打印一些描述性的文本了。</p>
<blockquote>
<p>输入输出函数必须为非成员函数</p>
</blockquote>
<p>与 iostream标准库兼容的输入输出运算符必须是普通的非成员函数,而不能是类的成员函数。否则,它们的左侧运算对象将是我们的类的一个对象</p>
<h3 id="重载输入运算符-gt-gt"><a href="#重载输入运算符-gt-gt" class="headerlink" title="重载输入运算符&gt;&gt;"></a>重载输入运算符&gt;&gt;</h3><p>通常情况下,输入运算符的<strong>第一个形参是运算符将要读取的流的引用</strong>,<strong>第二个形参是将要读入到的(非常量)对象的引用</strong>。该运算符通常会返回某个给定流的引|用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。</p>
<blockquote>
<p>输入时的错误</p>
</blockquote>
<ul>
<li>当流含有错误类型的数据时读取操作可能失败。</li>
<li>当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败。</li>
</ul>
<h2 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h2><p>我们把<strong>算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换</strong>。因为这些运算符一般不需要改变运算对象的状态,所以形参都是常量的引用</p>
<h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><p>C++中的类通过定义相等运算符来检验两个对象是否相等。</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15203006569640.jpg" alt=""></p>
<p>设计准则：</p>
<ol>
<li>如果一个类含有判断两个对象是否相等的操作,则它显然应该把函数定义成oprator=而非一个普通的命名函数:因为用户肯定希望能使用==比较对象,所以提供了==就意味着用户无须再费时费力地学习并记忆一个全新的函数名字此外,类定义了==运算符之后也更容易使用标准库容器和算法。</li>
<li>如果类定义了 perator==,则该运算符应该能判断一组给定的对象中是否含有重复数据。</li>
<li>通常情况下,相等运算符应该具有传递性</li>
<li>如果类定义了 operator==,则这个类也应该定义 operator!=。对于用户来说当他们能使用==时肯定也希望能使用!=,反之亦然</li>
<li>相等运算符和不相等运算符中的一个应该把工作委托给另外一个</li>
</ol>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>定义了相等运算符的类也常常(但不总是)包含关系运算符。特别是,因为关联容器和一些算法要用到小于运算符,所以定义。 operator&lt;会比较有用。</p>
<ol>
<li>定义顺序关系，令其与关联容器中对关键词的要求一致</li>
<li>如果类同时含有==运算符的话，则定义一种关系令其与==保持一致</li>
</ol>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>之前已经介绍过拷贝赋值和移动赋值运算符,它们可以把类的一个对象赋值给该类的另一个对象。此外,类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象。</p>
<p>复合赋值运算符不非得是类的成员,不过我们还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部。为了与内置类型的复合赋值保持一致,类中的复合赋值运算符也要返回其左侧运算对象的引用。</p>
<h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><p>表示容器的类通常可以通过元素在容器中的位置访问元素,这些类一般会定义下标运算符 operator[]。</p>
<p><strong>下标运算符必须是成员函数</strong></p>
<p>为了与下标的原始定义兼容,<strong>下标运算符通常以所访问元素的引用作为返回值</strong>,这样做的好处是下标可以出现在赋值运算符的任意一端。进一步,我们最好同时定义下标运算符的常量版本和非常量版本,当作用于一个常量对象时,下标运算符返回常量引用以确保我们不会给返回的对象赋值</p>
<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p>在迭代器类中通常会实现递増运算符(++)和递减运算符(–),这两种运算符使得类可以在元素的序列中前后移动。</p>
<blockquote>
<p>定义前置递增/递减运算符</p>
</blockquote>
<p>递增和递减运算符的工作机理非常相似:它们首先调用 check函数检验Strblobptr是否有效,如果是,接着检查给定的索引值是否有效。如果 check函数没有抛出异常,则运算符返回对象的引用。</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15203036806102.jpg" alt=""></p>
<blockquote>
<p>区分前置和后置运算符</p>
</blockquote>
<p>要想同时定义前置和后置运算符,必须首先解决一个问题,即普通的重载形式无法区分这两种情况。前置和后置版本使用的是同一个符号,意味着其重载版本所用的名字将是相同的,并且运算对象的数量和类型也相同。</p>
<p>为了解决这个问题,<strong>后置版本接受一个额外的(不被使用)int类型的形参</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15203037487660.jpg" alt=""></p>
<h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><p>在迭代器类及智能指针类中常常用到解引用运算符(*)和箭头运算符(-&gt;)。</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15203038781378.jpg" alt=""></p>
<blockquote>
<p>对箭头运算符返回值的限定</p>
</blockquote>
<p>和大多数其他运算符一样(尽管这么做不太好),我们能令 operator*完成任何我们指定的操作。换句话说,我们可以让 operator*返回一个固定值42,或者打印对象的内容,或者其他。<strong>箭头运算符则不是这样,它永远不能丢掉成员访问这个最基本的含义</strong>。当我们重载箭头时,可以改变的是箭头从哪个对象当中获取成员,而箭头获取成员这一事实则永远不变。</p>
<h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h2><p>如果类重载了函数调用运算符,则我们可以像使用函数一样使用该类的对象</p>
<h3 id="lambda-是函数对象"><a href="#lambda-是函数对象" class="headerlink" title="lambda 是函数对象"></a>lambda 是函数对象</h3><p>当我们编写了一个 lambda后,编译器将该表达式翻译成一个未命名类的未命名对象。在 lambda表达式产生的类中含有一个重载的函数调用运算符</p>
<h2 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h2><p>我们同样能定义对于类类型的类型转换,通过定义类型转换运算符可以做到这一点。转换构造函数和类型转换运算符共同定义了<strong>类类型转换</strong>( class-type conversions),这样的转换有时也被称作用户定义的类型转换(user- defined conversions)</p>
<h3 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h3><p>类型转换运算符( conversion operator)是类的一种特殊成员函数,它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">operator type()const;</div></pre></td></tr></table></figure></p>
<p>其中type表示某种类型。类型转换运算符可以面向任意类型(除了void之外)进行定义,只要该类型能作为函数的返回类型。因此,我们不允许转换成数组或者函数类型,但允许转换成指针(包括数组指针及函数指针)或者引用类型类型</p>
<p>转换运算符既没有显式的返回类型,也没有形参,而且必须定义成类的成员函数。类型转换运算符通常不应该改变待转换对象的内容,因此,类型转换运算符一般被定义成const成员。</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15203046723464.jpg" alt=""></p>
<h3 id="避免有二义性的类型转换"><a href="#避免有二义性的类型转换" class="headerlink" title="避免有二义性的类型转换"></a>避免有二义性的类型转换</h3><p>如果类中包含一个或多个类型转换,则必须确保在类类型和目标类型之间只存在唯一一种转换方式。否则的话,我们编写的代码将很可能会具有二义性在两种情况下可能产生多重转换路径。</p>
<p>第一种情况是<strong>两个类提供相同的类型转换</strong>;例如,当A类定义了一个接受B类对象的转换构造函数,同时B类定义了一个转换目标是A类的类型转换运算符时,我们就说它们提供了相同的类型转换</p>
<p>第二种情况是<strong>类定义了多个转换规则,而这些转换涉及的类型本身可以通过其他类型转换联系在一起</strong>。最典型的例子是算术运算符,对某个给定的类来说,最好只定义最多个与算术类型有关的转换规则。</p>
<hr>
<h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="OOP：概述"><a href="#OOP：概述" class="headerlink" title="OOP：概述"></a>OOP：概述</h2><p>面向对象程序设计( object-oriented programmin)的核心思想是<strong>数据抽象、继承和动态绑定</strong>。通过使用数据抽象,我们可以将类的接口与实现分离(见第7章);使用继承,可以定义相似的类型并对其相似关系建模;使用动态绑定,可以在一定程度上忽略相似类型的区别,而以统一的方式使用它们的对象。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>通过继承( inheritance)联系在一起的类构成一种层次关系。通常在层次关系的根部有一个<strong>基类</strong>( base class),其他类则直接或间接地从基类继承而来,这些继承得到的类称为<strong>派生类</strong>( derived class)。</p>
<p>在C++语言中,基类将<strong>类型相关的函数与派生类不做改变直接继承的函数区分对待</strong>。对于某些函数,<strong>基类希望它的派生类各自定义适合自身的版本,此时基类就将这些函数声明成虚函数</strong>( virtual function)。</p>
<p>派生类必须通过使用<strong>类派生列表</strong>( class derivation list)明确指出它是从哪个(哪些)基类继承而来的。类派生列表的形式是:首先是一个冒号,后面紧跟以逗号分隔的基类列表其中每个基类前面可以有访问说明符:</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204752450638.jpg" alt=""></p>
<p>派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上 virtua1关键字,但是并不是非得这么做。</p>
<h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>通过使用动态绑定( dynamic binding),我们们能用同一段代码分别处理 Quote和Bu1k_quote的对象(Bulk_quote 继承Quote）</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204753653946.jpg" alt=""></p>
<p>因为函数 print_tota1的item形参是基类Quote的一个引用,我们既能使用基类Quote的对象调用该函数,也能使用派生类Bu1k_quote的对象调用它;</p>
<p>因为在上述过程中函数的运行版本由实参决定,即在运行时选择函数的版本,所以动态绑定有时又被称为运行时绑定(run- time binding)。</p>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><p>基类通常都应该定义一个虚析构函数,即使该函数不执行任何实际操作也是如</p>
<blockquote>
<p>成员函数与继承</p>
</blockquote>
<p>在C++语言中,基类必须将它的两种成员函数区分开来:一种是<strong>基类希望其派生类进行覆盖的函数</strong>:另一种是<strong>基类希望派生类直接继承而不要改变的函数</strong>。对于前者,基类通常将其定义为<strong>虚函数</strong>( virtual)。当我们使用指针或引用调用虚函数时,该调用将被动态绑定。根据引用或指针所绑定的对象类型不同,该调用可能执行基类的版本,也可能执行某个派生类的版本。</p>
<p>任何构造函数之外的非静态函数都可以是虚函数。关键字V1rtua1只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把个函数声明成虚函数,则该函数在派生类中隐式地也是虚函数。</p>
<p>成员函数如果没被声明为虚函数,则其解析过程发生在编译时而非运行时。</p>
<blockquote>
<p>访问控制和继承</p>
</blockquote>
<p>派生类可以继承定义在基类中的成员,但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样,派生类能访问公有成员,而不能访问私有成员。不过在某些时候基类中还有这样一种成员,基类希望它的派生类有权访问该成员,同时禁止其他用户访向。我们用受保护的( protected)访向运算符说明这样的成员。</p>
<h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><p>派生类必须通过使用类派生列表( class derivation list)明确指出它是从哪个(哪些)基类继承而来的。类派生列表的形式是:首先是一个冒号,后面紧跟以逗号分隔的基类列表,其中每个基类前面可以有以下三种访问说明符中的一个:<strong>pub1ic、 protected或者private</strong></p>
<p>派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明,因此,我们的Bulk_quote类必须包含一个 net_price成员:</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204767757091.jpg" alt=""></p>
<p>大多数类都只继承自一个类,这种形式的继承被称作“单继承”,</p>
<blockquote>
<p>派生类中的虚函数</p>
</blockquote>
<p>派生类经常(但不总是)覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数,则该虚函数的行为类似于其他的普通成员,派生类会直接继承其在基类中的版本。</p>
<p>派生类可以在它覆盖的函数前使用 virtua1关键字,但不是非得这么做。</p>
<blockquote>
<p>派生类对象及派生类向基类的类型转换</p>
</blockquote>
<p>一个派生类对象包含多个组成部分:一个含有<strong>派生类自己定义的(非静态)成员的子对象</strong>,以及一个与该派生类<strong>继承的基类对应的子对象</strong>,如果有多个基类,那么这样的子对象也有多个。</p>
<p>因为在派生类对象中含有与其基类对应的组成部分,所以我们能把派生类的对象当成基类对象来使用,而且我们也能将基类的<strong>指针或引用</strong>绑定到派生类对象中的基类部分上</p>
<p>这种转换通常称为派生类到基类的( derived-to-base)类型转换。和其他类型转换一样,编译器会隐式地执行派生类到基类的转专换</p>
<blockquote>
<p>派生类构造函数</p>
</blockquote>
<p>尽管在派生类对象中含有从基类继承而来的成员,但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样,派生类也必须使用基类的构造函数来初始化它的基类部分</p>
<p>派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段执行初始化操作的。类似于我们初始化成员的过程,派生类构造函数同样是<strong>通过构造函数初始化列表来将实参传递给基类构造函数的</strong>。</p>
<p>除非我们特别指出,否则派生类对象的基类部分会像数据成员一样执行默认初始化。如果想使用其他的基类构造函数,我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。</p>
<blockquote>
<p>派生类使用基类成员</p>
</blockquote>
<p>派生类可以访问基类的公有成员和受保护成员:</p>
<p>目前只需要了解<strong>派生类的作用域嵌套在基类的作用域之内</strong>。因此,对于派生类的一个成员来说,它使用派生类成员(例如min aty和 discount)的方式与使用基类成员(例如 price)的方式没什么不同。</p>
<blockquote>
<p>继承与静态成员</p>
</blockquote>
<p>如果基类定义了一个静态成员,则在<strong>整个继承体系中只存在该成员的唯一定义</strong>。不论从基类中派生出来多少个派生类,对于每个静态成员来说都只存在唯一的实例。</p>
<p>静态成员遵循通用的访问控制规则,如果基类中的成员是pr⊥Vate的,则派生类无权访问它。假设某静态成员是可访问的,则我们既能通过基类使用它也能通过派生类使用它</p>
<blockquote>
<p>派生类的声明</p>
</blockquote>
<p>派生类的声明与其他类差别不大(参见7.3.3节,第250页),声明中包含类名但是不包含它的派生列表:</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204772352734.jpg" alt=""></p>
<blockquote>
<p>被用作基类的类</p>
</blockquote>
<p>如果我们想将某个类用作基类,则该类必须已经定义而非仅仅声明:</p>
<p>这一规定的原因显而易见:派生类中包含并且可以使用它从基类继承而来的成员,为了使用这些成员,派生类当然要知道它们是什十么。</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204772841857.jpg" alt=""></p>
<p>在这个继承关系中,Base是D1的直接基类( direct base),同时是D2的间接基类( indirectbase)。直接基类出现在派生列表中,而间接基类由派生类通过其直接基类继承而来</p>
<p>最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。</p>
<blockquote>
<p>防止继承发生</p>
</blockquote>
<p>有时我们会定义这样一种类,我们不希望其他类继承它,或者不想考虑它是否适合作为一个基类。为了实现这一日的,C++11新标准提供了一种防止继承发生的方法,即在类名后跟一个关键字fina1:</p>
<h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>通常情况下,如果我们想把引用或指针绑定到一个对象上,则引用或指针的类型应与对象的类型一致。存在继承关系的类是一个重要的意外</p>
<p>可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义:当使用基类的引用(或指针)时,实际上我们并不清楚该引用(或指针)所绑定对象的真实类型。该对象可能是基类的对象,也可能是派生类的对象。</p>
<blockquote>
<p>静态类型与动态类型</p>
</blockquote>
<p>当我们使用存在继承关系的类型时,必须<strong>将一个变量或其他表达式的静态类型</strong>( statictype)与该表达式表示对象的动态类型( dynamic type)区分开来。表达式的静态类型在编译时总是已知的,它是变量声明时的类型或表达式生成的类型:动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。</p>
<p>如果表达式既不是引用也不是指旨针,则它的动态类型永远与静态类型一致。</p>
<blockquote>
<p>不存在从基类向派生类的隐式类型转换</p>
</blockquote>
<p>之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分,而基类的引用或指针可以绑定到该基类部分上。一个基类的对象既可以以独立的形式存在,也可以作为派生类对象的一部分存在。如果基类对象不是派生类对象的一部分,则它只含有基类定义的成员,而不含有派生类定义的成员。</p>
<blockquote>
<p>对象之间不存在转换</p>
</blockquote>
<p>派生类向基类的自动类型转换只对指针或引用类型有效,在派生类类型和基类类型之间不存在这样的转换。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><blockquote>
<p>对虚函数的调用可能在运行时才被解析</p>
</blockquote>
<p>当某个虚函数通过指针或引用调用时,编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个</p>
<p>必须要搞清楚的一点是,动态绑定只有当我们通过指针或引用调用虚函数时才会发生。当我们通过一个具有普通类型(非引用非指针)的表达式调用虚函数时,在编译时就会将调用的版本确定下来。</p>
<blockquote>
<p>派生类中的虚函数</p>
</blockquote>
<p>当我们在派生类中覆盖了某个虚函数时,可以再一次使用 virtua1关键字指出该函数的性质。然而这么做并非必须,因为<strong>一旦某个函数被声明成虚函数,则在所有派生类中它都是虚函数</strong>。</p>
<p>一个派生类的函数如果覆盖了某个继承而来的虚函数,则它的形参类型必须与被它覆盖的基类函数完全一致。</p>
<blockquote>
<p>final 和 override说明符</p>
</blockquote>
<p>派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同,这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时,派生类的函数并没有覆盖掉基类中的版本。就实际的编程习惯而言,这种声明往主往意味着发生了错误,因为我们可能原本希望派生类能覆盖掉基类中的虚函数,但是一不小心把形参列表弄错了。</p>
<p>在C++11新标准中我们可以使用override关键字来说明派生类中的虚函数。这么做的好处是在使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误,后者在编程实践中显得更加重要。</p>
<blockquote>
<p>虚函数和默认实参</p>
</blockquote>
<p>和其他函数一样,虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参,则该实参值由本次调用的静态类型决定。</p>
<p>换句话说,如果我们通过基类的引用或指针调用函数,则使用基类中定义的默认实参,即使实际运行的是派生类中的函数版本也是如此匕。此时,传入派生类函数的将是基类函数定义的默认实参。</p>
<blockquote>
<p>回避虚函数的机制</p>
</blockquote>
<p>在某些情况下,我们希望对虚函数的调用不要进行动态绑定,而是强迫其执行虚函数的某个特定版本。</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204936697970.jpg" alt=""></p>
<p>什么时候我们需要回避虚函数的默认机制呢?通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。</p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><blockquote>
<p>纯虚函数</p>
</blockquote>
<p>当我们不想让用户从一个类中创建一个对象时，我们可以使用纯虚函数。</p>
<p>和普通的虚函数不一样,一个纯虚函数无须定义。我们通过在函数体的位置(即在声明语句的分号之前)书写=0就可以将一个虚函数说明为纯虚函数。其中,=0只能出现在类内部的虚函数声明语句处</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15205130777739.jpg" alt=""></p>
<blockquote>
<p>含有纯虚函数的类是抽象基类</p>
</blockquote>
<p>含有(或者未经覆盖直接继承)纯虚函数的类是抽象基类( abstract base class)。<strong>抽象基类负责定义接口,而后续的其他类可以覆盖该接口。我们不能(直接)创建一个抽象基类的对象</strong>。</p>
<blockquote>
<p>重构</p>
</blockquote>
<p>重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。对于面向对象的应用程序来说,重构是一种很普遍的现象。</p>
<h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><blockquote>
<p>受保护成员</p>
</blockquote>
<p>一个类使用 protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。 </p>
<blockquote>
<p>公有、私有和受保护继承</p>
</blockquote>
<p>某个类对其继承而来的成员的访问权限受到两个因素影响:一是在<strong>基类中该成员的访问说明符</strong>,二是在<strong>派生类的派生列表中的访问说明符</strong>。</p>
<p>派生访问说明符对于派生类的成员(及友元)能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关。 </p>
<p>派生访问说明符的目的是<strong>控制派生类用户(包括派生类的派生类在内)对于基类成员的访问权限</strong>:</p>
<p>假设我们之前还定义了一个名为 Prot_derv的类,它采用受保护继承,则Base的所有公有成员在新定义的类中都是受保护的。 Prot_Derv的用户不能访间 pub_mem,但是 Prot_derv的成员和友元可以访问那些继承而来的成员</p>
<blockquote>
<p>友元和继承</p>
</blockquote>
<p>就像友元关系不能传递一样,友元关系同样也不能继承。<strong>基类的友元在访问派生类成员时不具有特殊性</strong></p>
<p>当一个类将另一个类声明为友元时,这种友元关系只对做出声明的类有效。对于原来那个类来说,其友元的基类或者派生类不具有特殊的访问能力</p>
<blockquote>
<p>改变个别成员的可访问性</p>
</blockquote>
<p>有时我们需要改变派生类继承的某个名字的访问级别,通过使用 using声明。</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15205140838880.jpg" alt=""></p>
<p>因为 Derived使用了私有继承,所以继承而来的成员s1ze和n(在默认情况下)是Derived的私有成员。然而,我们使用us1ng声明语句改变了这些成员的可访问性。改变之后, Derived的用户将可以使用size成员,而 Derived的派生类将能使用n</p>
<blockquote>
<p>默认的继承保护级别</p>
</blockquote>
<p>我们曾经介绍过使用 struct和c1asS关键字定义的类具有不同的默认访问说明符。类似的,默认派生运算符也由定义派生类所用的关键字来决定默认情况下,<strong>使用c1ass关键字定义的派生类是私有继承的;而使用 struct关键字定义的派生类是公有继承的:</strong></p>
<p>两者的差别只有这一个。</p>
<h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><p>每个类定义自己的作用域,在这个作用域内我们定义类的成员。当存在继承关系时,<strong>派生类的作用域嵌套在其基类的作用域之内</strong>。如果一个名字在派生类的作用域内无法正确解析,则编译器将继续在外层的基类作用域中寻找该名字的定义</p>
<blockquote>
<p>在编译时进行名字查找</p>
</blockquote>
<p>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致(当使用基类的引用或指针时会发生这种情况),但是我们能使用哪些成员仍然是由静态类型决定的。</p>
<blockquote>
<p>名字冲突和继承</p>
</blockquote>
<p>和其他作用域一样,派生类也能重用定义在其直接基类或间接基类中的名字,此时<strong>定义在内层作用域(即派生类)的名字将隐藏定义在外层作用域(即基类)的名字</strong></p>
<blockquote>
<p>通过作用域运算符来使用隐藏的成员</p>
</blockquote>
<p>我们可以通过作用域运算符来使用一个被隐藏的基类成员:</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15205150138642.jpg" alt=""></p>
<p>作用域运算符将覆盖掉原有的査找规则,并指示编译器从BaSe类的作用域开始査找mem</p>
<blockquote>
<p>一如既往，名字查找先于类型检查</p>
</blockquote>
<p>如前所述,<strong>声明在内层作用域的函数并不会重载声明在外层作用域的函数</strong>。因此,定义派生类中的函数也不会重载其基类中的成员。和其他作用域样,如果派生类(即内层作用域)的成员与基类(即外层作用域)的某个成员同名,则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致,基类成员也仍然会被隐藏掉</p>
<blockquote>
<p>虚函数与作用域</p>
</blockquote>
<p>我们现在可以理解为什么基类与派生类中的虚函数必须有相同的形参列表了。<strong>假如基类与派生类的虚函数接受的实参不同,则我们就无法通过基类的引用或指针调用派生类的虚函数了</strong>。例如:</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15205151324990.jpg" alt=""></p>
<blockquote>
<p>覆盖重载的函数</p>
</blockquote>
<p>如果派生类希望所有的重载版本对于它来说都是可见的,那么它就需要覆盖所有的版本,或者一个也不覆盖。有时一个类仅需覆盖重载集合中的一些而非全部函数</p>
<h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>继承关系对基类拷贝控制最直接的影响是<strong>基类通常应该定义一个虚析构函数</strong>,这样我们就能动态分配继承体系中的对象了。如前所述,当我们de1ete一个动态分配的对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型,则有可能出现指针的静态类型与被删除对象的动态类型不符的情况</p>
<p>我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本:</p>
<p>和其他虚函数一样,析构函数的虚属性也会被继承。</p>
<p><strong>如果一个类需要析构函数,那么它也同样需要拷贝和赋值操作。基类的析构函数并不遵循上述准则</strong>,它是个重要的例外。一个基类总是需要析构函数,而且它能将析构函数设定为虚函数。</p>
<blockquote>
<p>虚析构函数将阻止合成移动操作</p>
</blockquote>
<p>基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响:如果一个类定义了析构函数,即使它通过= defau1t的形式使用了合成的版本,编译器也不会为这个类合成移动操作</p>
<h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><p>基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似:它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外,这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。</p>
<ul>
<li>合成的Bu1k_quote默认构造函数运行 Disc_quote的默认构造函数,后者又运行 Quote的默认构造函数。</li>
</ul>
<p>无论基类成员是合成的版本(如ρuote继承体系的例子)还是自定义的版本都没有太大影响。唯一的要求是相应的成员应该可访问并且不是一个被删除的函数。</p>
<blockquote>
<p>派生类中的删除的拷贝控制与基类的关系</p>
</blockquote>
<p>基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员定义成被删除的函数</p>
<ul>
<li>·如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问,则派生类中对应的成员将是被删除的,原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作</li>
<li>·如果在基类中有一个不可访问或删除掉的析构函数,则派生类中合成的默认和拷贝构造函数将是被删除的,因为编译器无法销毁派生类对象的基类部分。</li>
</ul>
<blockquote>
<p>移动操作与继承</p>
</blockquote>
<p>大多数基类都会定义一个虚析构函数。因此在默认情况下,基类通常不含有合成的移动操作,而且在它的派生类中也没有合成的移动操作。</p>
<h3 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h3><p>派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员,还负责初始化派生类对象的基类部分。因此,派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时,也要拷贝和移动基类部分的成员。类似的,派生类赋值运算符也必须为其基类部分的成员赋值。</p>
<blockquote>
<p>定义派生类的拷贝和移动构造函数</p>
</blockquote>
<p>当为派生类定义拷贝或移动构造函数时,我们通常使用对应的基类构造函数初始化对象的基类部分</p>
<p><img src="https://data2.liuin.cn/2018-03-09-15205965427434.jpg" alt=""></p>
<blockquote>
<p>派生类赋值运算符</p>
</blockquote>
<p>与拷贝和移动构造函数一样,派生类的赋值运算符也必须显式地为其基类部分赋值:</p>
<p>值得注意的是,无论基类的构造函数或赋值运算符是自定义的版本还是合成的版本,派生类的对应操作都能使用它们。</p>
<blockquote>
<p>派生类析构函数</p>
</blockquote>
<p>在析构函数体执行完成后,对象的成员会被隐式销毁。类似的,对象的基类部分也是隐式销毁的。因此,和构造函数及赋值运算符不同的是,派生类析构函数只负责销毁由派生类自己分配的资源:</p>
<p>对象销毁的顺序正好与其创建的顺序相反:派生类析构函数首先执行,然后是基类的析构函数,以此类推,沿着继承体系的反方向直至最后。</p>
<blockquote>
<p>在构造函数和析构函数中调用虚函数</p>
</blockquote>
<p>派生类对象的基类部分将首先被构建。当执行基类的构造函数时,该对象的派生类部分是未被初始化的状态。类似的,销毁派生类对象的次序正好相反,因此当执行基类的析构函数时,派生类部分已经被销毁掉了。</p>
<p>为了能够正确地处理这种未完成状态,编译器认为对象的类型在构造或析构的过程中仿佛发生了改变一样。也就是说,<strong>当我们构建一个对象时,需要把对象的类和构造函数的类看作是同一个;对虚函数的调用绑定正好符合这种把对象的类和构造函数的类看成同一个的要求;对于析构函数也是同样的道理。</strong></p>
<h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><p>在C++11新标准中,派生类能够重用其直接基类定义的构造函数。尽管如我们所知,这些构造函数并非以常规的方式继承而来,但是为了方便,我们不妨姑且称其为“继承”的。一个类只初始化它的直接基类,出于同样的原因,一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数,则编译器将为派生类合成它们。</p>
<p>派生类继承基类构造函数的方式是提供一条注明了(直接)基类名的uS1ng声明语句。举个例子,我们可以重新定义Bu1k_quote类,令其继承Disc_quote类的构造函数:</p>
<p><img src="https://data2.liuin.cn/2018-03-09-15205968035260.jpg" alt=""></p>
<blockquote>
<p>继承的构造函数的特点</p>
</blockquote>
<p>和普通成员的 using声明不一样构造函数的 using声明不会改变该构造函数的访问级别。</p>
<h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><p>当我们使用容器存放继承体系中的对象时,通常必须采取间接存储的方式。因为不允许在容器中保存不同类型的元素,所以我们不能把具有继承关系的多种类型的对象直接在放在容器当中。</p>
<blockquote>
<p>在容器中放置（智能）指针而非对象</p>
</blockquote>
<p>当我们希望在容器中存放具有继承关系的对象时,我们实际上存放的通常是基类的指针(更好的选择是智能指针。和往常一样,这些指针所指对象的动态类型可能是基类类型,也可能是派生类类型</p>
<h3 id="编写Basket类"><a href="#编写Basket类" class="headerlink" title="编写Basket类"></a>编写Basket类</h3><p>对于C++面向对象的编程来说,一个悖论是我们无法直接使用对象进行面向对象编程。相反,我们必须使用指针和引用。因为指针会增加程序的复杂性,所以我们经常定义一些辅助的类来处理这种复杂情况。</p>
<hr>
<h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><p>面向对象编程(OOP)和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于:OOP能处理类型在程序运行之前都未知的情况;而在泛型编程中,在编译时就能获知类型了。</p>
<p>模板是C++中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。</p>
<h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>我们可以定义一个通用的函数模板( function template),而不是为每个类型都定义一个新函数。一个函数模板就是一个公式,可用来生成针对特定类型的函数版本。 compare的模板版本可能像下面这样</p>
<p><img src="https://data2.liuin.cn/2018-03-10-15206810494191.jpg" alt=""></p>
<p>模板定义以关键字 template开始,后跟一个模板参数列表( template parameter list.,这是一个逗号分隔的一个或多个模板参数( template parameter)的列表,用小于号(&lt;)和大于号(&gt;)包围起来。<strong>在模板定义中，模板参数列表不能为空</strong>。</p>
<p>模板参数表示在类或函数定义中用到的类型或值。当使用模板时,我们(隐式地或显式地)指定模板实参( template argument),将其绑定到模板参数上。</p>
<blockquote>
<p>实例化函数模板</p>
</blockquote>
<p>当我们调用一个函数模板时!,<strong>编译器(通常)用函数实参来为我们推断模板实参</strong>。</p>
<p>编译器用推断出的模板参数来为我们实例化( instantiate)一个特定版本的函数。当编译器实例化一个模板时,它使用实际的模板实参代替对应的模板参数来创建出模板的一个新“实例”。</p>
<blockquote>
<p>模板类型参数</p>
</blockquote>
<p>我们的 compare函数有一个模板<strong>类型参数</strong>( type parameter.)。一般来说,我们可以<strong>将类型参数看作类型说明符</strong>,就像内置类型或类类型说明符一样使用。特别是,类型参数可以用来指定返回类型或函数的参数类型,以及在函数体内用于变量声明或类型转换</p>
<p><img src="https://data2.liuin.cn/2018-03-10-15206812431993.jpg" alt=""></p>
<blockquote>
<p>非类型模板参数</p>
</blockquote>
<p>除了定义类型参数,还可以在模板中定义非类型参数( nontype parameter)。<strong>一个非类型参数表示一个值而非一个类型</strong>。我通过一个特定的类型名而非关键字c1ass或typename来指定非类型参数。</p>
<p>当一个模板被实例化时,非类型参数被一个用户提供的或编译器推断出的值所代替。</p>
<blockquote>
<p>inline 和constexpr 的函数模板</p>
</blockquote>
<p>函数模板可以声明为in1ine或 constexpr的,如同非模板函数一样。in1ine或constexpr说明符放在模板参数列表之后,返回类型之前:</p>
<blockquote>
<p>编写类型无关的代码</p>
</blockquote>
<p>我们最初的 compare函数虽然简单,但它说明了编写泛型代码的两个重要原则:</p>
<ul>
<li>模板中的函数参数是 const的引用</li>
<li>函数体中的条件判断仅使用&lt;比较运算</li>
</ul>
<p>通过将函数参数设定为 const的引用,我们保证了函数可以用于不能拷贝的类型。</p>
<p>如果编写代码时只使用&lt;运算符,我们就降低了 compare函数对要处理的类型的要求。这些类型必须支持&lt;,但不必同时支持&gt;。</p>
<blockquote>
<p>模板编译</p>
</blockquote>
<p>当编译器遇到一个模板定义时,它并不生成代码。<strong>只有当我们实例化出模板的一个特定版本时,编译器才会生成代码</strong>。当我们使用(而不是定义)模板时,编译器才生成代码特性影响了我们如何组织代码以及错误何时被检测到。</p>
<p>为了生成一个实例化版本,编译器需要掌握函数模板或类模板成员函数的定义。因此,与非模板代码不同,模板的头文件通常既包括声明也包括定义。</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板( class template)是用来生成类的蓝图的。与函数模板的不同之处是,<strong>编译器不能为类模板推断模板参数类型</strong>。如我们已经多次看到的,<strong>为了使用类模板,我们必须在模板名后的尖括号中提供额外信息</strong>——用来代替模板参数的模板实参列表。</p>
<blockquote>
<p>定义类模板</p>
</blockquote>
<p>类似函数模板,类模板以关键字 template开始,后跟模板参数列表。在类模板(及其成员)的定义中,我们将模板参数当作替身,代替使用模板时用户需要提供的类型或值:</p>
<p><img src="https://data2.liuin.cn/2018-03-10-15206822514896.jpg" alt=""></p>
<blockquote>
<p>实例化类模板</p>
</blockquote>
<p>当使用一个类模板时,我们必须提供额外信息。我们现在知道这些额外信息是显式模板实参( explicit template argument)列表,它们被绑定到模板参数。编译器使用这些模板实参来实例化出特定的类。</p>
<blockquote>
<p>在模板作用域中引用模板类型</p>
</blockquote>
<p>为了阅读模板类代码,应该记住类<strong>模板的名字不是一个类型名</strong>。类模板用来实例化类型,而一个实例化的类型总是包含模板参数的可能令人迷惑的是,<strong>一个类模板中的代码如果使用了另外一个模板,通常不将一个实际类型(或值)的名字用作其模板实参。相反的,我们通常将模板自己的参数当作被使用模板的实参</strong>。</p>
<p>例如,我们的data成员使用了两个模板, vector和 shared_ptr。我们知道,无论何时使用模板都必须提供模板实参。在本例中,我们提供的模板实参就是Bob的模板参数。因此,data的定义如下</p>
<p><img src="https://data2.liuin.cn/2018-03-10-15206823729019.jpg" alt=""></p>
<blockquote>
<p>类模板的成员函数</p>
</blockquote>
<p>与其他任何类相同,我们既可以在类模板内部,也可以在类模板外部为其定义成员函数,且<strong>定义在类模板内的成员函数被隐式声明为内联函数</strong>。</p>
<p>类模板的成员函数本身是一个普通函数。但是,类模板的每个实例都有其自己版本的成员函数。因此,类模板的成员函数具有和模板相同的模板参数。因而,定义在类模板之外的成员函数就必须以关键字temp1ate开始,后接类模板参数列表。</p>
<p>当我们在类外定义一个成员时,必须说明成员属于哪个类。而且,<strong>从一个模板生成的类的名字中必须包含其模板实参</strong>。</p>
<blockquote>
<p>类模板成员函数的实例化</p>
</blockquote>
<p>默认情况下,一个类模板的成员函数只有当程序用到它时才进行实例化。</p>
<p>如果一个成员函数没有被使用,则它不会被实例化。成员函数只有在被用到时才进行实例化,这一特性使得即使某种类型不能完全符合模板操作的要求。</p>
<blockquote>
<p>在类代码内简化模板类名的使用</p>
</blockquote>
<p>当我们使用一个类模板类型时必须提供模板实参,但这一规则有一个例外。<strong>在类模板自己的作用域中,我们可以直接使用模板名而不提供实参</strong></p>
<blockquote>
<p>在类模板外使用类模板名</p>
</blockquote>
<p>当我们在类模板外定义其成员时,必须记住,我们并不在类的作用域中,直到遇到类名才表示进入类的作用域(参见</p>
<blockquote>
<p>模板类和友元</p>
</blockquote>
<p>当一个类包含一个友元声明时,类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板友元,则友元被授权可以访问所有模板实例。如果友元自身是模板,类可以授权给所有友元模板实例,也可以只授权给特定实例</p>
<blockquote>
<p>一对一友好关系</p>
</blockquote>
<p><strong>类模板与另一个(类或函数)模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-03-10-15206826958070.jpg" alt=""></p>
<blockquote>
<p>通用和特定的友好关系</p>
</blockquote>
<p>一个类也可以将另一个模板的每个实例都声明为自己的友元,或者限定特定的实例为友元</p>
<p>为了让所有实例成为友元,友元声明中必须使用与类模板本身不同的模板参数</p>
<blockquote>
<p>模板类型别名</p>
</blockquote>
<p>类模板的一个实例定义了一个类类型,与任何其他类类型一样,我们可以定义一个typedef来引用实例化的类:</p>
<p><code>typedef Blob&lt;string&gt; StrBlob;</code></p>
<blockquote>
<p>类模板的static成员</p>
</blockquote>
<p>与任何其他 static数据成员相同,模板类的每个 static数据成员必须有且仅有个定义。但是,类模板的每个实例都有一个独有的 static对象。因此,与定义模板的成员函数类似,我们将 static数据成员也定义为模板</p>
<p>与非模板类的静态成员相同,我们可以通过类类型对象来访问一个类模板的 statio成员,也可以使用作用域运算符直接访问成员。当然,为了通过类来直接访问 static成员,我们必须引用一个特定的实例</p>
<h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><p>类似函数参数的名字,一个模板参数的名字也没有什么内在含义。我们通常将类型参数命名为T,但实际上我们们可以使用任何名字:</p>
<blockquote>
<p>模板参数与作用域</p>
</blockquote>
<p>模板参数遵循普通的作用域规则。<strong>一个模板参数名的可用范围是在其声明之后,至模板声明或定义结束之前</strong>。与任何其他名字一样,模板参数会隐藏外层作用域中声明的相同名字。</p>
<blockquote>
<p>模板声明</p>
</blockquote>
<p>模板声明必须包含模板参数，一个给定模板的每个声明和定义必须有相同数量和种类(即,类型或非类型)的参数。</p>
<blockquote>
<p>使用类的类型成员</p>
</blockquote>
<p>假定T是一个模板类型参数,当编译器遇到类似里T::mem这样的代码时,它不会知道mem是一个类型成员还是一个 static数据成员,直至实例化时才会知道。但是,为了处理模板,编译器必须知道名字是否表示一个类型。</p>
<p>默认情况下,<strong>C++语言假定通过作用域运算符访问的名字不是类型</strong>。因此,如果我们希望使用一个模板类型参数的类型成员,就必须显式告诉编译器该名字是一个类型。</p>
<blockquote>
<p>默认模板实参</p>
</blockquote>
<p>就像我们能为函数参数提供默认实参一样,我们也可以提供默认模板实参( default template argument)。</p>
<blockquote>
<p>模板默认实参与类模板</p>
</blockquote>
<p>无论何时使用一个类模板,我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。特别是,如果一个类模板为其所有模板参数都提供了默认实参,且我们希望使用这些默认实参,就必须在模板名之后跟一个空尖括号对:</p>
<h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><p>一个类(无论是普通类还是类模板)可以包含本身是模板的成员函数。这种成员被称为成员模板( member template)。成员模板不能是虚函数。</p>
<blockquote>
<p>普通（非模板）类的成员模板</p>
</blockquote>
<p><img src="https://data2.liuin.cn/2018-03-12-15208165159357.jpg" alt=""></p>
<blockquote>
<p>类模板的成员模板</p>
</blockquote>
<p>对于类模板,我们也可以为其定义成员模板。在此情况下,类和成员各自有自己的、独立的模板参数。</p>
<p>与类模板的普通函数成员不同,成员模板是函数模板。当我们在类模板外定义一个成员模板时,必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前,后跟成员自己的模板参数列表:</p>
<blockquote>
<p>实例化与成员模板</p>
</blockquote>
<p>为了实例化一个类模板的成员模板,我们必须同时提供类和函数模板的实参。与往常样,我们在哪个对象上调用成员模板,编译器就根据该对象的类型来推断类模板参数的实参。</p>
<h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><p>当模板被使用时才会进行实例化这一特性意味着,<strong>相同的实例可能出现在多个对象文件中</strong>。当两个或多个独立编译的源文件使用了相同的模板并提供了相同的模板参数时,每个文件中就都会有该模板的一个实例。</p>
<p>在大系统中,在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中,我们可以通过显式实例化( explicit instantiation)来避免这种开销。一个显式实例化有如下：</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208167547457.jpg" alt=""></p>
<p>当编译器遇到 extern模板声明时,它不会在本文件中生成实例化代码。将一个实例化声明为 extern就表示承诺在程序其他位置有该实例化的一个非 extern声明(定义)。</p>
<blockquote>
<p>实例化定义会实例化所有成员</p>
</blockquote>
<p><strong>一个类模板的实例化定义会实例化该模板的所有成员,包括内联的成员函数</strong>。当编译器遇到一个实例化定义时,它不了解程序使用哪些成员函数。因此,与处理类模板的普通实例化不同,编译器会实例化该类的所有成员。即使我们不使用某个成员,它也会被实例化。因此,我们用来显式实例化一个类模板的类型,必须能用于模板的所有成员</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》笔记 类设计者的工具部分&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C/C++" scheme="https://www.liuin.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 题解——Container With Most Water</title>
    <link href="https://www.liuin.cn/2018/03/09/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Container-With-Most-Water/"/>
    <id>https://www.liuin.cn/2018/03/09/LeetCode-题解——Container-With-Most-Water/</id>
    <published>2018-03-09T10:37:07.000Z</published>
    <updated>2018-03-09T10:53:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题解——Container With Most Water</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目首先给出一个数组b，数组中的每一个数可以确定平面直角坐标系上的一个点<code>(i,b[i])</code>，两个点可以确定一个容器：两个点分别向x轴引垂线形成的容器，求所有形成的容器中容积（面积）最大的那一个。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先想到的是暴力法，枚举所有的情况，这样的时间复杂度是O(n^2)，要优化这个算法的话，要么就优化成O(logn)或者O(n)，如果想要优化成O(n)的话就意味着扫描一遍即可。</p>
<p>这样可以找到一个贪心的方法：用两个指针从两边向中间进行扫描，这样我们所求的面积的底在变小，要想扫描到更大的面积的情况只有更长的高才有可能找到，所以就在扫描过程中舍弃掉较小高度的点，让指针继续向中间靠拢。</p>
<h2 id="代码（C-）"><a href="#代码（C-）" class="headerlink" title="代码（C++）"></a>代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = height.size()<span class="number">-1</span>;</div><div class="line">        <span class="keyword">int</span> res = min(height[i], height[j])*(j-i);</div><div class="line">        <span class="comment">// 从两边向中间扫描</span></div><div class="line">        <span class="keyword">while</span>(i&lt;j)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(height[i] &lt; height[j])</div><div class="line">                i++;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                j--;</div><div class="line">            res = max(res, min(height[i], height[j])*(j-i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题解——Container With Most Water&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.liuin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://www.liuin.cn/tags/LeetCode/"/>
    
      <category term="贪心" scheme="https://www.liuin.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 题解——Regular Expression Matching</title>
    <link href="https://www.liuin.cn/2018/03/09/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Regular-Expression-Matching/"/>
    <id>https://www.liuin.cn/2018/03/09/LeetCode-题解——Regular-Expression-Matching/</id>
    <published>2018-03-09T10:06:12.000Z</published>
    <updated>2018-03-09T10:38:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题解——Regular Expression Matching</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>实现支持.和*正则匹配</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一开始的想法是从左向右进行模拟匹配，模拟的代码比较长，后面遇到这种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">aaa</div><div class="line">a*a</div></pre></td></tr></table></figure></p>
<p>就行不通了</p>
<p>事实上，上面那种情况的我们在匹配a*的时候，要分是否匹配a这个东西分两种情况进行讨论，这个时候就有一种递归的思路：<br>首先判断第一个字符是否匹配，然后判断是否是*模式，是的话可以匹配这个字符也可以不匹配，如果不是*模式的话就判断后面。</p>
<p>递归代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> plen = p.size(), slen = s.size();</div><div class="line">        <span class="keyword">if</span>(plen == <span class="number">0</span>) <span class="keyword">return</span> slen == <span class="number">0</span>;</div><div class="line">        <span class="comment">// 是否匹配第一个</span></div><div class="line">        <span class="keyword">bool</span> matchfirst = (slen != <span class="number">0</span> &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>));</div><div class="line">        <span class="comment">// 是否是*模式</span></div><div class="line">        <span class="keyword">if</span>(plen &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">'*'</span>)</div><div class="line">            <span class="keyword">return</span> (isMatch(s, p.substr(<span class="number">2</span>)) || (matchfirst &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p)));</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> (matchfirst &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>)));</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这样的递归我们会发现有大量的重复调用，这个时候可以使用动态规划进行优化。<br><code>dp[i][j]</code>表示<code>isMatch(s.strsub(i), p.strsub(j))</code>，由上面的递归方案我们可以推得</p>
<p><code>dp[i][j]</code>= </p>
<ol>
<li>dp[i][j+2],当前为*模式时不匹配的情况</li>
<li>dp[i+1][j],当前为*模式，并且第一个字符匹配成功的情况</li>
<li>dp[i+1][j],非*模式，第一个字符匹配成功的情况</li>
</ol>
<p>DP代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> plen = p.length(), slen = s.length();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; dp(slen + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; (plen + <span class="number">1</span>, <span class="literal">false</span>));</div><div class="line">        dp[slen][plen] = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=slen ;i&gt;=<span class="number">0</span>;--i)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=plen<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">// 判断第一个是否匹配</span></div><div class="line">                <span class="keyword">bool</span> match = (i&lt;slen &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">'.'</span>));</div><div class="line">                <span class="comment">// 是*模式，两种方案，匹配/不匹配</span></div><div class="line">                <span class="keyword">if</span>(j+<span class="number">1</span> &lt; plen &amp;&amp; p[j+<span class="number">1</span>] == <span class="string">'*'</span>)</div><div class="line">                    dp[i][j] = dp[i][j+<span class="number">2</span>] || (match &amp;&amp; dp[i+<span class="number">1</span>][j]);</div><div class="line">                <span class="comment">// 非*模式</span></div><div class="line">                <span class="keyword">else</span></div><div class="line">                    dp[i][j] = (match &amp;&amp; dp[i+<span class="number">1</span>][j+<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题解——Regular Expression Matching&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.liuin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="DP" scheme="https://www.liuin.cn/tags/DP/"/>
    
      <category term="LeetCode" scheme="https://www.liuin.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 题解——Median of Two Sorted Arrays</title>
    <link href="https://www.liuin.cn/2018/03/08/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Median-of-Two-Sorted-Arrays/"/>
    <id>https://www.liuin.cn/2018/03/08/LeetCode-题解——Median-of-Two-Sorted-Arrays/</id>
    <published>2018-03-08T06:42:12.000Z</published>
    <updated>2018-03-09T10:38:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题解——Median of Two Sorted Arrays</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定两个有序数组，求这两个有序数组中所有数的中位数</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先理解什么是中位数，中位数把这两个数组中的所有的数有序放到一起，排在中间的那一个数（或者两个数）就是中位数，我们也可以从另外一个角度去看，中位数作为边界把这些数分割成两半。这两边的数的个数是相等的。</p>
<p>对于这两个数组就相当于每个数组都有一个数把这个数组分割成两半：</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204918440445.jpg" alt=""></p>
<p>这里考虑使用二分法求解，对于两个数组，两边的数的个数是相等的。由此，考虑一种分割情况，我们可以假设A数组从i点分割，这样因为两边的数的个数相等很容易算得B数组的分割点<code>j=(n+m+1)/2-i</code>，对于每一种分割有三种情况：</p>
<ol>
<li><code>A[i]&gt;=B[j-1] &amp;&amp; B[j]&gt;=A[i-1]</code>这种情况下，刚好取得中位数</li>
<li><code>A[i]&lt;B[j-1]</code> 这种情况下，表示我们选取的i点过小，可以通过二分进一步缩减范围</li>
<li><code>B[j]&lt;A[i-1]</code> 这种情况下，表示我们选取的i点过大，可以通过二分进一步缩减范围</li>
</ol>
<p>除此之外另外还要注意几点：</p>
<ol>
<li>我们选取的i要从数组数量较小的那个数组中选取，因为如果从数组数量大的数组中选取的话，可能导致选取的i较小，使得计算出的j值大于B数组中的元素个数</li>
<li>存在一些特殊情况在端点分割的特殊情况，比如i=0，i=n，j=0，j=m的这些情况。在这样的情况下，我们可以只需要计算左边数的最大值，和右边数的最小值即可。</li>
<li>最后的结果要对总数是奇数还是偶数进行讨论，如果是奇数的话，表示中位数是左边那一堆中的最大值；如果是偶数的话，中位数中左边一堆数的最大值和右边一堆书的最小值的平均值。</li>
</ol>
<h2 id="代码（C-）"><a href="#代码（C-）" class="headerlink" title="代码（C++）"></a>代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = nums1.size(), m = nums2.size();</div><div class="line">        <span class="comment">// 对小的数组进行分割</span></div><div class="line">        <span class="keyword">if</span>(n &gt; m)</div><div class="line">        &#123;</div><div class="line">            swap(nums1, nums2);</div><div class="line">            swap(n,m);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 二分法确定两个界限</span></div><div class="line">        <span class="keyword">int</span> i, j, iMin = <span class="number">0</span>, iMax = n;</div><div class="line">        <span class="keyword">while</span>(iMin &lt;= iMax)</div><div class="line">        &#123;</div><div class="line">            i = (iMin + iMax)/<span class="number">2</span> ;</div><div class="line">            j = (m+n+<span class="number">1</span>)/<span class="number">2</span> - i;</div><div class="line">            <span class="comment">// i的取值过大</span></div><div class="line">            <span class="keyword">if</span>(i &gt; iMin &amp;&amp; nums1[i<span class="number">-1</span>] &gt; nums2[j])</div><div class="line">            &#123;</div><div class="line">                iMax = i - <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// i的取值过小的情况</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; iMax &amp;&amp; nums1[i] &lt; nums2[j<span class="number">-1</span>]) </div><div class="line">            &#123;</div><div class="line">                iMin = i + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 找到中位数</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) left = nums2[j<span class="number">-1</span>];</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) left = nums1[i<span class="number">-1</span>];</div><div class="line">                <span class="keyword">else</span> left = max(nums1[i<span class="number">-1</span>], nums2[j<span class="number">-1</span>]);</div><div class="line">                <span class="comment">// 总数是奇数的时候</span></div><div class="line">                <span class="keyword">if</span> ( (m + n) % <span class="number">2</span>) <span class="keyword">return</span> left;</div><div class="line">                </div><div class="line">                <span class="keyword">int</span> right = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span>(i == n) right = nums2[j];</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == m) right = nums1[i];</div><div class="line">                <span class="keyword">else</span> right = min(nums1[i], nums2[j]);</div><div class="line">                <span class="keyword">return</span> (left + right)/<span class="number">2.0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题解——Median of Two Sorted Arrays&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.liuin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://www.liuin.cn/tags/LeetCode/"/>
    
      <category term="二分" scheme="https://www.liuin.cn/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>APUE 文件I/O</title>
    <link href="https://www.liuin.cn/2018/03/06/APUE-%E6%96%87%E4%BB%B6I-O/"/>
    <id>https://www.liuin.cn/2018/03/06/APUE-文件I-O/</id>
    <published>2018-03-06T10:49:20.000Z</published>
    <updated>2018-03-07T03:29:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第2章 文件I/O 笔记</p>
<a id="more"></a>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>UNX系统中的大多数文件只需用到5个函数:open、read、 write、 lseek以及c1ose。</p>
<p>本章描述的函数经常被称为不带缓冲的I/O( unbuffered I/O,与将在第5章中说明的标准I/O函数相对照)。术语不带缓冲指的是每个read和 write都调用内核中的一个系统调用。</p>
<p>只要涉及在多个进程间共享资源,原子操作的概念就变得非常重要。我们将通过文件IO和open函数的参数来讨论此概念。</p>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>对于内核而言,<strong>所有打开的文件都通过文件描述符引用</strong>。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时,内核向进程返回一个文件描述符。</p>
<p>按照惯例,UNIX系统shell把<strong>文件描述符0与进程的标准输入关联,文件描述符1与标准输出关联,文件描述符2与标准错误关联</strong>。这是各种shel以及很多应用程序使用的惯例.</p>
<h2 id="函数open和openat"><a href="#函数open和openat" class="headerlink" title="函数open和openat"></a>函数open和openat</h2><p>用于打开或者创建一个文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oﬂag, ... <span class="comment">/* mode_t mode */</span> )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oﬂag, ... <span class="comment">/* mode_t mode */</span> )</span></span>; </div><div class="line"><span class="comment">//Both return: ﬁle descriptor if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>我们将最后一个参数写为…,ISO C用这种方法表明余下的参数的数量及其类型是可变的。对于open函数而言,仅当创建新文件时才使用最后这个参数(稍后将对此进行说明)。</p>
<p>path参数是要打开或创建文件的名字。oflag参数可用来说明此函数的多个选项。用一个或者多个常量“或”运算构成oflag参数</p>
<p>使用的常量可以参考原书</p>
<h2 id="函数create"><a href="#函数create" class="headerlink" title="函数create"></a>函数create</h2><p>可以调用create函数创建一个文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">//Returns: ﬁle descriptor opened for write-only if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>此函数等效于<code>open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);</code></p>
<p>creat的一个不足之处是它以只写方式打开所创建的文件。</p>
<h2 id="函数close"><a href="#函数close" class="headerlink" title="函数close"></a>函数close</h2><p>调用close函数关闭一个打开的文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>关闭一个文件时还会释放该进程加在该文件上的所有记录锁。</p>
<p>当一个进程终止时,内核自动关闭它所有的打开文件。很多程序都利用了这一功能而不显式地用c1ose关闭打开文件。</p>
<h2 id="函数lseek"><a href="#函数lseek" class="headerlink" title="函数lseek"></a>函数lseek</h2><p>每个打开文件都有一个与其相关联的“<strong>当前文件偏移量</strong>”( current file offset)。它通常是一个非负整数,用以度量从文件开始处计算的字节数。</p>
<p>调用1seek显式地为一个打开文件设置偏移量：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</div><div class="line"></div><div class="line"><span class="comment">//Returns: new ﬁle offset if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>对参数offet的解释与参数 whence的值有关。</p>
<ul>
<li>若 whence是 SEEK_SET,则将该文件的偏移量设置为距文件开始处 offset个字节。</li>
<li>若 whence是 SEEK_CUR,则将该文件的偏移量设置为其当前值加 offset, offset可为正或负。</li>
<li>若 whence是 SEEK_END,则将该文件的偏移量设置为文件长度加 offset, offset可正可负。</li>
</ul>
<p>通常,文件的当前偏移量应当是一个非负整数,但是,某些设备也可能允许负的偏移量。但对于普通文件,其偏移量必须是非负值。</p>
<p>1seek仅将当前的文件偏移量记录在内核中,它并不引起任何IO操作。然后,该偏移量用于下一个读或写操作。</p>
<p>文件偏移量可以大于文件的当前长度,在这种情况下,对该文件的下一次写将加长该文件,并在文件中构成一个空洞,这一点是允许的。位于文件中但没有写过的字节都被读为0</p>
<p><strong>文件中的空洞并不要求在磁盘上占用存储区</strong>。具体处理方式与文件系统的实现有关,当定位到超出文件尾端之后写时,对于新写的数据需要分配磁盘块,但是对于原文件尾端和新开始写位置之间的部分则不需要分配磁盘块。</p>
<p>创建一个具有空洞的文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">char</span>	buf1[] = <span class="string">"abcdefghij"</span>;</div><div class="line"><span class="keyword">char</span>	buf2[] = <span class="string">"ABCDEFGHIJ"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span>		fd;</div><div class="line"></div><div class="line">	<span class="comment">// 创建文件</span></div><div class="line">	<span class="keyword">if</span> ((fd = creat(<span class="string">"file.hole"</span>, FILE_MODE)) &lt; <span class="number">0</span>)</div><div class="line">		err_sys(<span class="string">"creat error"</span>);</div><div class="line"></div><div class="line">	<span class="comment">// 写入a-j，此时文件偏移量为10</span></div><div class="line">	<span class="keyword">if</span> (write(fd, buf1, <span class="number">10</span>) != <span class="number">10</span>)</div><div class="line">		err_sys(<span class="string">"buf1 write error"</span>);</div><div class="line">	<span class="comment">/* offset now = 10 */</span></div><div class="line"></div><div class="line">	<span class="comment">// 改变文件偏移量到16384</span></div><div class="line">	<span class="keyword">if</span> (lseek(fd, <span class="number">16384</span>, SEEK_SET) == <span class="number">-1</span>)</div><div class="line">		err_sys(<span class="string">"lseek error"</span>);</div><div class="line">	<span class="comment">/* offset now = 16384 */</span></div><div class="line"></div><div class="line">	<span class="comment">// 在新的文件偏移量下写入A-J</span></div><div class="line">	<span class="keyword">if</span> (write(fd, buf2, <span class="number">10</span>) != <span class="number">10</span>)</div><div class="line">		err_sys(<span class="string">"buf2 write error"</span>);</div><div class="line">	<span class="comment">/* offset now = 16394 */</span></div><div class="line"></div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为1seek使用的偏移量是用off_t类型表示的,所以允许具体实现根据各自特定的平台自行选择大小合适的数据类型。</p>
<h2 id="函数read"><a href="#函数read" class="headerlink" title="函数read"></a>函数read</h2><p>调用read函数从打开文件中读数据<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); </div><div class="line"></div><div class="line"><span class="comment">//Returns: number of bytes read, 0 if end of ﬁle, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>如read成功,则返回读到的字节数。如已到达文件的尾端,则返回0。</p>
<p>有多种情况可使实际读到的字节数少于要求读的字节数</p>
<ul>
<li>读普通文件时,在读到要求字节数之前已到达了文件尾端。</li>
<li>当从终端设备读时,通常一次最多读一行。</li>
<li>当从网络读时,网络中的缓冲机制可能造成返回值小于所要求读的字节数</li>
<li>当从管道或FIFO读时,如若管道包含的字节少于所需的数量,那么read将只返回实际可用的字节数</li>
<li>当从某些面向记录的设备(如磁带)读时,一次最多返回一个记录。</li>
<li>当一信号造成中断,而已经读了部分数据量时。</li>
</ul>
<h2 id="函数write"><a href="#函数write" class="headerlink" title="函数write"></a>函数write</h2><p>调用write函数想打开文件写数据<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); </div><div class="line"></div><div class="line"><span class="comment">//Returns: number of bytes written if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>其返回值通常与参数 nbytes的值相同,否则表示出错。 write出错的一个常见原因是磁盘已写满,或者超过了一个给定进程的文件长度限制</p>
<h2 id="I-O效率"><a href="#I-O效率" class="headerlink" title="I/O效率"></a>I/O效率</h2><p>BUFFSIZE 一般选取与磁盘块相同大小的字节数，大多数情况问4096</p>
<p>大多数文件系统为改善性能都采用某种预读( read ahead)技术。当检测到正进行顺序读取时,系统就试图读入比应用所要求的更多数据,并假想应用很快就会读这些数据。</p>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>UNIX系统支持在不同进程间共享打开文件。在介绍dup函数之前,先要说明这种共享。为此先介绍内核用于所有I/O的数据结构。</p>
<p>内核使用3种数据结构表示打开文件,它们之间的关系决定了在文件共享方面一个进程对另个进程可能产生的影响。</p>
<ol>
<li><strong>每个进程在进程表中都有一个记录项,记录项中包含一张打开文件描述符表</strong>,可将其视为一个矢量,每个描述符占用一项。与每个文件描述符相关联的是文件描述符标志和指向一个文件表项的指针。</li>
<li><strong>内核为所有打开文件维持一张文件表</strong>。每个文件表项包含文件状态标志(读、写、添写、同步和非阻塞等)、当前文件偏移量、指向该文件v节点表项的指针</li>
<li>每个打开文件(或设备)都有一个v节点( v-node)结构。v节点包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件,v节点还包含了该文件的i节点(i-node,索引节点)。</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-03-07-15203821021363.jpg" alt=""></p>
<blockquote>
<p>创建v节点结构的目的是对在一个计算机系统上的多文件系统类型提供支持。把与文件系统无关的i节点部分称为v节点。Linux没有将相关数据结构分为i节点和ⅴ节点,而是采用了一个与文件系统相关的i节点和个与文件系统无关的i节点。</p>
</blockquote>
<p>两个独立进程打开同一个文件</p>
<p><img src="https://data2.liuin.cn/2018-03-07-15203822136634.jpg" alt=""></p>
<p>文件描述符标志和文件状态标志在作用范围方面的区别,前者只用于一个进程的一个描述符,而后者则应用于指向该给定文件表项的任何进程中的所有描述符。</p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><ol>
<li>追加到一个文件</li>
</ol>
<p>多个进程同时使用这种方法将数据追加写到同一文件,则会产生问题</p>
<p>问题出在逻辑操作“先定位到文件尾端,然后写”,它使用了两个分开的函数调用。解决问题的方法是使这两个操作对于其他进程而言成为一个原子操作。</p>
<ol>
<li>函数pread和pwrite</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset); </div><div class="line"></div><div class="line"><span class="comment">//Returns: number of bytes read, 0 if end of ﬁle, −1 on error</span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> pwrite(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset); </div><div class="line"></div><div class="line"><span class="comment">//Returns: number of bytes written if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>调用 pread相当于调用1seek后调用read,但是 pread又与这种顺序调用有下列重要区别:1. 调用 pread时,无法中断其定位和读操作。2. 不更新当前文件偏移量。</p>
<p>调用pwrite相当于调用1seek后调用 write,但也与它们有类似的区别。</p>
<h2 id="函数dup和dup2"><a href="#函数dup和dup2" class="headerlink" title="函数dup和dup2"></a>函数dup和dup2</h2><p>下面两个用来复制一个文件描述符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//Both return: new ﬁle descriptor if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>由dup返回的新文件描述符一定是当前可用文件描述符中的最小数值。对于dup2,可以用fd2参数指定新描述符的值。如果fd2已经打开,则先将其关闭。如若fd等于fd2,则dup2返回fd2,而不关闭它。否则,fd2的 FD_CLOEXEO文件描述符标志就被清除,这样fd2在进程调用exec时是打开状态</p>
<p>dup(1)以后的内核数据结构：<br><img src="https://data2.liuin.cn/2018-03-07-15203828993104.jpg" alt=""></p>
<h2 id="函数sync、-fsync和-fdatasync"><a href="#函数sync、-fsync和-fdatasync" class="headerlink" title="函数sync、 fsync和 fdatasync"></a>函数sync、 fsync和 fdatasync</h2><p>传统的UNⅨ系统实现在内核中设有缓冲区高速缓存或页高速缓存,大多数磁盘I/O都通过缓冲区进行。当我们向文件写入数据时,内核通常先将数据复制到缓冲区中,然后排入队列,晚些时候再写入磁盘。这种方式被称为<strong>延迟写</strong>( delayed write)</p>
<p>通常,当内核需要重用缓冲区来存放其他磁盘块数据时,它会把所有延迟写数据块写入磁盘为了保证磁盘上实际文件系统与缓冲区中内容的一致性,UNIX系统提供了sync、 fsync和Edatasync三个函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//Returns: 0 if OK, −1 on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>sync只是将所有修改过的块缓冲区排入写队列,然后就返回,它并不等待实际写磁盘操作结束。</p>
<p>fsync函数只对由文件描述符/指定的一个文件起作用,并且等待写磁盘操作结束才返回fsync可用于数据库这样的应用程序,这种应用程序需要确保修改过的块立即写到磁盘上。</p>
<p>fdatasync函数类似于 sync,但它只影响文件的数据部分。而除数据外, fsync还会同步更新文件的属性。</p>
<h2 id="函数fcntl"><a href="#函数fcntl" class="headerlink" title="函数fcntl"></a>函数fcntl</h2><p>fcntl函数可以改变已经打开文件的属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* int arg */</span> )</span></span>; </div><div class="line"></div><div class="line"><span class="comment">//Returns: depends on cmd if OK (see following), −1 on error</span></div></pre></td></tr></table></figure>
<p>fcnt1函数有以下5种功能</p>
<ol>
<li>复制一个已有的描述符(cmd= F_DUPFD或 F_DUPFD_CLOEXEC)。</li>
<li>获取/设置文件描述符标志(cmd= E_GETED或 F_SETED)。</li>
<li>获取/设置文件状态标志(cmd= F_GETEL或 F_SETEL)</li>
<li>获取/设置异步IO所有权(cmd= F_GETOWN或F_SETOWN)。</li>
<li>获取/设置记录锁(cmd= F_GETLK、 F_SETLK或 F_SETLKW)</li>
</ol>
<p>在修改文件描述符标志或文件状态标志时必须谨慎,先要获得现在的标志值,然后按照期望修改它,最后设置新标志值。不能只是执行 F_SETED或 E_SETEL命令,这样会关闭以前设置的标志位。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">set_fl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span> <span class="comment">/* flags are file status flags to turn on */</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span>		val;</div><div class="line"></div><div class="line">	<span class="comment">// 获取现在的文件标志位</span></div><div class="line">	<span class="keyword">if</span> ((val = fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</div><div class="line">		err_sys(<span class="string">"fcntl F_GETFL error"</span>);</div><div class="line"></div><div class="line">	<span class="comment">// 计算新的标志值</span></div><div class="line">	val |= flags;		<span class="comment">/* turn on flags */</span></div><div class="line">         </div><div class="line">	<span class="comment">// 设置新的标志值</span></div><div class="line">	<span class="keyword">if</span> (fcntl(fd, F_SETFL, val) &lt; <span class="number">0</span>)</div><div class="line">		err_sys(<span class="string">"fcntl F_SETFL error"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="函数ioctl"><a href="#函数ioctl" class="headerlink" title="函数ioctl"></a>函数ioctl</h2><p>每个设备驱动程序可以定义它自己专用的一组ioct1命令,系统则为不同种类的设备提供通用的 ioctl命令。</p>
<h2 id="dev-fd"><a href="#dev-fd" class="headerlink" title="/dev/fd"></a>/dev/fd</h2><p>较新的系统都提供名为/aev/fd的目录,其目录项是名为0、1、2等的文件。打开文件/dev/fd/n等效于复制描述符n(假定描述符n是打开的)。</p>
<p>大多数系统忽略它所指定的mode,而另外一些系统则要求mode必须是所引用的文件(在这里是标准输入)初始打开时所使用的打开模式的一个子集。</p>
<p>某些系统提供路径名/dev/ stdin、/dev/stdoυt和/dev/ stderr,这些等效于dev/fd/0、/dev/fd/1和/dev/fd/2。</p>
<p>dev/fd文件主要由shell使用,它允许使用路径名作为调用参数的程序,能用处理其他路径名的相同方式处理标准输入和输出。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第2章 文件I/O 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》笔记 C++标准库部分</title>
    <link href="https://www.liuin.cn/2018/03/04/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-C-%E6%A0%87%E5%87%86%E5%BA%93%E9%83%A8%E5%88%86/"/>
    <id>https://www.liuin.cn/2018/03/04/《C-Primer》笔记-C-标准库部分/</id>
    <published>2018-03-04T02:58:33.000Z</published>
    <updated>2018-03-08T02:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》笔记 C++基础部分</p>
<a id="more"></a>
<h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><p>大部分的I/O库设施：</p>
<ul>
<li>istream(输入流)类型,提供输入操作。</li>
<li>ostream(输出流)类型,提供输出操作。</li>
<li>cin，一个 istream对象,从标准输入读取数据。</li>
<li>cout,一个 ostream对象,向标准输出写入数据。</li>
<li>cerr,一个 ostream对象,通常用于输出程序错误消息,写入到标准错误・</li>
<li>>&gt;运算符,用来从一个istream对象读取输入数据。</li>
<li>&lt;&lt;运算符,用来向一个ostream对象写入输出数据。</li>
<li>getline函数,从一个给定的 istream读取一行数据,存入一个给定的 string对象中。</li>
</ul>
<h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><p>我们已经使用过的IO类型和对象都是操纵char数据的。默认情况下,这些对象都是关联到用户的控制台窗口的。</p>
<p>为了支持这些不同种类的IO处理操作,在 istream和ostream之外,标准库还定义了其他一些IO类型:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518671687211.jpg" alt="enter description here"></p>
<p>为了支持宽字符的语言，标准库定义了一组类型和对象来操纵wchat_t类型的数据。宽字符版本的类型和函数的名字以一个w开始。</p>
<blockquote>
<p>IO类型之间的关系</p>
</blockquote>
<p>标准库使我们能忽略这些不同类型的流之间的差异,这是通过<strong>继承机制</strong>( inheritance)实现的。利用模板,我们可以使用具有继承关系的类,而不必了解继承机制如何工作的细节。简单地说,继承机制使我们可以声明一个特定的类继承自另一个类。我们通常可以将一个派生类(继承类)对象当作其基类(所继承的类)对象来使用</p>
<h3 id="IO对象无拷贝或赋值"><a href="#IO对象无拷贝或赋值" class="headerlink" title="IO对象无拷贝或赋值"></a>IO对象无拷贝或赋值</h3><p>我们不能拷贝或者对IO对象赋值，由于不能拷贝IO对象，因此我们也不能将形参或者函数返回类型设置为流类型。进行IO操作的函数通常以引用的方式传递和返回流。</p>
<p>读取或者返回一个IO对象会改变其状态，因此传递和引用不能是const的</p>
<h3 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h3><blockquote>
<p>查询流状态</p>
</blockquote>
<p>IO库定义了一个与机器无关的 iostate类型,它提供了表达流状态的完整功能。这个类型应作为一个位集合来使用</p>
<blockquote>
<p>管理条件状态</p>
</blockquote>
<p>流对象的 rdstate 成员返回一个iostate值,对应流的当前状态。 setstate操作将给定条件位置位,表示发生了对应错误。clear成员是一个重載的成员:它有一个不接受参数的版本,而另一个版本接受一个 iostate类型型的参数。</p>
<h3 id="管理输出缓存"><a href="#管理输出缓存" class="headerlink" title="管理输出缓存"></a>管理输出缓存</h3><p>每一个输出流都管理一个缓冲区，用来保存程序读写的数据。</p>
<p>文本串可能立即打印出来,但也有可能被操作系统保存在缓冲区中,随后再打印。有了缓冲机制,操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很耗时,<strong>允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升</strong>。</p>
<p>导致缓冲刷新(即,数据真正写到输出设备或文件)的原因有很多：</p>
<ul>
<li>程序正常结束,作为main函数的 return操作的一部分,缓冲冲刷新被执行。</li>
<li>缓冲区满时,需要刷新缓冲,而后新的数据才能继续写入缓冲区。</li>
<li>我们可以使用操纵符如endl来显式刷新缓冲区。</li>
<li>在每个输出操作之后,我们可以用操纵符unitbuf设置流的内部状态,来清空缓冲区。</li>
<li>一个输出流可能被关联到另一个流。在这种情况下,当读写被关联的流时,关联到的流的缓冲区会被刷新。</li>
</ul>
<blockquote>
<p>刷新输出缓冲区</p>
</blockquote>
<p>我们已经使用过操纵符endl,它完成换行并刷新缓冲区的工作。IO库中还有两个类似的操纵符:flush和ends。flush刷新缓冲区,但不输出任何额外的字符;ends向缓冲区插入一个空字符,然后刷新缓冲区</p>
<blockquote>
<p>uintbuf操作符</p>
</blockquote>
<p>如果想在每次输出操作后都刷新缓冲区,我们可以使用 unitbuf操纵符。它告诉流在接下来的每次写操作之后都进行一次=flush操作。而 nounitbuf操纵符则重置流,使其恢复使用正常的系统管理的缓冲区刷新机制:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518672433805.jpg" alt="enter description here"></p>
<h2 id="文件的输入输出"><a href="#文件的输入输出" class="headerlink" title="文件的输入输出"></a>文件的输入输出</h2><p>头文件 fstream定义了三个类型来支持文件IO: ifstream从一个给定文件读取数据,ofstream向一个给定文件写入数据,以及 fstream可以读写给定文件。</p>
<p>除了继承自 iostream类型的行为之外, fstream中定义的类型还增加了一些新的成员来管理与流关联的文件</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518672783415.jpg" alt="enter description here"></p>
<h3 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h3><p>当我们想要读写一个文件时,可以定义一个文件流对象,并将对象与文件关联起来。每个文件流类都定义了一个名为open的成员函数,它完成一些系统相关的操作,来定位给定的文件,并视情况打开为读或写模式。</p>
<blockquote>
<p>成员函数open和close</p>
</blockquote>
<p>如果我们定义一个空文件流对象，随后我们可以调用open来将它与文件关联起来。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518672886373.jpg" alt="enter description here"></p>
<p>如果调用open失败, failbit会被置位。因为调用open可能失败,进行open是否成功的检测通常是一个好习惯</p>
<h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><p>每一个流都有一个关联的<strong>文件模式</strong>（file mode），用来指出如何使用文件。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518672976516.jpg" alt="enter description here"></p>
<p>无论用哪种方式打开文件,我们都可以指定文件模式,调用open打开文件时可以,用一个文件名初始化流来隐式打开文件时也可以。</p>
<blockquote>
<p>以out模式打开文件会丢弃</p>
</blockquote>
<p>已有数据默认情况下,当我们打开一个 ofstream时,文件的内容会被丢弃。阻止一个ofstream清空给定文件内容的方法是同时指定aap模式:</p>
<h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><p>sstream头文件定义了三个类型来支持内存IO,这些类型可以向 string写入数据,从string读取数据,就像string是一个IO流一样。</p>
<p>istringstream从 string读取数据，ostringstream向 string写入数据,而头文件 stringstream既可从 string读数据也可向 string写数据。与fstream类型类似,头文件 sstream中定义的类型都继承自我们已经使用过的 iostream头文件中定义的类型。除了继承得来的操作, sstream中定义的类型还增加了一些成员来管理与流相关联的string。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518676701978.jpg" alt="enter description here"></p>
<h3 id="使用istringstream"><a href="#使用istringstream" class="headerlink" title="使用istringstream"></a>使用istringstream</h3><p>当我们的某些工作室对整行的文本进行处理，而其他的一些工作是处理行内的单个单词时，通常可以使用istringstream</p>
<h3 id="使用ostringstream"><a href="#使用ostringstream" class="headerlink" title="使用ostringstream"></a>使用ostringstream</h3><p>当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>C++使用标准库类来处理面向流的输入和输出:</p>
<ol>
<li>iostream处理控制台</li>
<li>fstream处理命名文件</li>
<li>stringstream完成内存string的IO</li>
</ol>
<hr>
<h1 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h1><p>一个容器就是一些特定类型对象的集合。<strong>顺序容器</strong>( sequential container)为程序员提供了<strong>控制元素存储和访问顺序的能力</strong>。这种顺序<strong>不依赖于元素的值,而是与元素加入容器时的位置相对应</strong>。与之相对的,我们将在第11章介绍的有序和无序关联容器,则根据关键字的值来存储元素。</p>
<h2 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_16_1518790789624.jpg" alt="enter description here"></p>
<p>以上就是标准库中的顺序容器了，所有顺序容器提供快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：</p>
<ul>
<li>向容器添加或从容器中删除元素的代价</li>
<li>非顺序访问容器中元素的代价</li>
</ul>
<p>除了固定大小的的 array外,其他容器都提供高效、灵活的内存管理。</p>
<p>list和 forward_list 两个容器的设计目的是<strong>令容器任何位置的添加和删除操作都很快速</strong>。作为代价,这两个容器不支持元素的随机访问:为了访问一个元素,我们只能遍历整个容器。而且,与 vector、 deque和 array相比,这两个容器的额外内存开销也很大。</p>
<p>deque是一个更为复杂的数据结构。与string和 vector类似, deque支持快速的随机访问。与 string和 vector一样,在 deque的中间位置添加或删除元素的代价(可能)很高。但是,<strong>在 deque的两端添加或删除元素都是很快的</strong>,与list或forward_list添加删除元素的速度相当。</p>
<p>以下是选择容器的基本原则：</p>
<ul>
<li>除非你有很好的理由选择其他容器,否则应使用 vector。</li>
<li>如果你的程序有很多小的的元素,且空间的额外开销很重要,则不要使用list或forward_list。</li>
<li>如果程序要求随机访问元素,应使用 vector或 deque如果程序要求在容器的中间插入或删除元素,应使用list或forward_list。</li>
<li>如果程序需要在头尾位置插入或删除元素,但不会在中间位置进行插入或删除操作,则使用 deque</li>
<li>如果程序只有在读取输入时才需要在容器中间位置插入元素,随后需要随机访问元素,则：首先，确定是否真的需要在容器中间添加元素；如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的额内容拷贝到一个vector 中</li>
</ul>
<h2 id="容器库概览"><a href="#容器库概览" class="headerlink" title="容器库概览"></a>容器库概览</h2><p>容器类型上形成了一种层次：</p>
<ul>
<li>某些操作是所有容器类型都提供的</li>
<li>另外一些操作仅针对顺序容器、关联容器或无序容器</li>
<li>还有一些操作只适用于一小部分容器</li>
</ul>
<p>本节我们介绍所有容器都适用的操作</p>
<p>一般来说，每个容器都定义在一个头文件中，文件名与类型名相同；顺序容器几乎可以保存任意类型的元素。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_16_1518793115931.jpg" alt="enter description here"></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>与容器一样,迭代器有着公共的接口:如果一个迭代器提供某个操作,那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。</p>
<p>一个迭代器范围( iterator range)由一对迭代器表示,两个迭代器分别指向同一个容器中的元素或者是<strong>尾元素之后的位置</strong>( one past the last element)。这两个迭代器通常被称为 begin和end,或者者是 first和laste(可能有些误导),它们标记了容器中元素的个范围</p>
<p>这种元素范围被称为<strong>左闭合区间</strong>( left-inclusive interval),其标准数学描述为<code>[begin, end)</code></p>
<h3 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h3><p>反向迭代器就是一种反向遍历容器的迭代器,与正向迭代器相比,各种操作的含义也都发生了颠倒</p>
<p>,通过类型别名,我们可以在不了解容器中元素类型的情况下使用它。如果需要元素类型,可以使用容器的value_type。如果需要元素类型的一个引用,可以使用 reference或 const_reference。这些元素相关的类型别名在泛型编程中非常有用</p>
<h3 id="begin-和-end成员"><a href="#begin-和-end成员" class="headerlink" title="begin 和 end成员"></a>begin 和 end成员</h3><p>begin和end操作生成指向容器中第一个元素和尾元素之后位置的迭代器。这两个迭代器最常见的用途是形成一个包含容器中所有元素的迭代器范围</p>
<h3 id="容器定义和初始化"><a href="#容器定义和初始化" class="headerlink" title="容器定义和初始化"></a>容器定义和初始化</h3><p>每个容器类型都定义了一个默认构造函数。除 array之外,其他容器的默认构造函数都会创建一个指定类型的空容器,且都可以接受指定容器大小和元素初始值的参数。</p>
<blockquote>
<p>将一个容器初始化为另一个容器的拷贝</p>
</blockquote>
<p>将一个新容器创建为另一个容器的拷贝的方法有两种:可以直接拷贝整个容器,或者( array除外)拷贝由一个迭代器对指定的元素范围。为了创建一个容器为另一个容器的拷贝,两个容器的类型及其元素类型必须匹配。不过,当传递迭代器参数来拷贝一个范围时,就不要求容器类型是相同的了。而且,新容器和原容器中的元素类型也可以不同,只要能将要拷贝的元素转换</p>
<blockquote>
<p>与顺序容器大小相关的构造函数</p>
</blockquote>
<p>除了与关联容器相同的构造函数外,顺序容器( array除外)还提供另一个构造函数,它接受一个容器大小和一个(可选的)元素初始值。</p>
<h3 id="赋值与swap"><a href="#赋值与swap" class="headerlink" title="赋值与swap"></a>赋值与swap</h3><p>赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝。</p>
<blockquote>
<p>使用assign</p>
</blockquote>
<p>顺序容器( array除外)还定义了一个名为 assign的成员,允许我们从一个不同但相容的类型赋值,或者从容器的一个子序列赋值。assign操作用参数所指定的元素(的拷贝)替换左边容器中的所有元素。例如,我们可以用 assign实现将一个 vector中的一段char*值赋予一个list中的 string：<br><img src="https://data2.liuin.cn/story-writer/2018_2_16_1518794438240.jpg" alt="enter description here"></p>
<blockquote>
<p>使用swap</p>
</blockquote>
<p>除 array外,交换两个容器内容的操作保证会很快——元素本身并未交换,swap只是交換了两个容器的内部数据结构。</p>
<p>元素不会被移动的事实意味着,除string外,指向容器的迭代器、引用和指针在swap操作之后都不会失效。它们仍指向swap操作之前所指向的那些元素。但是,在swap之后,这些元素已经属于不同的容器了。</p>
<p>与其他容器不同,swap两个 array会真正交换它们的元素。因此,交換两个 array所需的时间与 array中元素的数目成正比。</p>
<h3 id="容器大小操作"><a href="#容器大小操作" class="headerlink" title="容器大小操作"></a>容器大小操作</h3><p>除了一个例外,每个容器类型都有三个与大小相关的操作：</p>
<ul>
<li>成员函数size，返回容器中元素的数目; </li>
<li>empty当size为0时返回布尔值true,否则返回回false</li>
<li>max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。</li>
</ul>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符左右两边的运算对象必须是相同类型的容器,且必须保存相同类型的元素。</p>
<p>比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与string的关系运算类似:</p>
<ul>
<li>如果两个容器具有相同大小且所有元素都两两对应相等,则这两个容器相等;否则两个容器不等</li>
<li>如果两个容器大小不同,但较小容器中每个元素都等于较大容器中的对应元素,则则较小容器小于较大容器。</li>
<li>如果两个容器都不是另一个容器的前缀子序列,则它们的比较结果取決于第一个不相等的元素的比较结果。</li>
</ul>
<h2 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h2><h3 id="向顺序容器添加元素"><a href="#向顺序容器添加元素" class="headerlink" title="向顺序容器添加元素"></a>向顺序容器添加元素</h3><p>除 array外,所有标准库容器都提供灵活的内存管理。在运行时可以动态添加或刑除元素来改变容器大小。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518833554118.jpg" alt="enter description here"></p>
<p>在一个 vector或 string的尾部之外的任何位置,或是一个 deque的首尾之外的任何位置添加元素,都需要移动元素。而且,向一个 vector或 string添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存,并将元素从旧的空间移动到新的空间中。</p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>包括 array在内的每个顺序容器都有一个 front成员函数,而除 forward_list之外的所有顺序容器都有一个back成员函数。这两个操作分别返回首元素和尾元素的引用</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518833711199.jpg" alt="enter description here"></p>
<blockquote>
<p>下标操作和安全的随机访问</p>
</blockquote>
<p>提供快速随机访问的容器( string、 vector、 deque和 array)也都提供下标运算符。就像我们已经看到的那样,下标运算符接受一个下标参数,返回容器中该位置的元素的引用。<strong>给定下标必须“在范围内”</strong>(即,大于等于0,且小于容器的大小)。保证下标有效是程序员的责任,下标运算符并不检査下标是否在合法范围内。<strong>使用越界的下标是一种严重的程序设计错误</strong>,而且编译器并不检査这种错误。</p>
<p>如果我们希望确保下标是合法的,可以使用at成员函数。at成员函数类似下标运算,但如果下标越界,at会地出一个out of range异常:</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518834076074.jpg" alt="enter description here"></p>
<h3 id="特殊的forward-list操作"><a href="#特殊的forward-list操作" class="headerlink" title="特殊的forward_list操作"></a>特殊的forward_list操作</h3><p>在一个单向链表中,没有简单的方法来获取一个元素的前驱。出于这个原因,在一个 forward_list中添加或删除元素的操作是通过改变给定元素之后的元素来完成的</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518834143966.jpg" alt="enter description here"></p>
<h3 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h3><p>我们可以用rsize来增大或缩小容器・与往常一样, array不支持 resize。如果当前大小大于所要求的大小,容器后部的元素会被別除:如果当前大小小于新大小,会将新元素添加到容器后部:</p>
<h3 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h3><p>向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误,很可能引起与使用未初始化指针一样的问题</p>
<p>当你使用迭代器(或指向容器元素的引用或指针)时,最小化要求迭代器必须保持有效的程序片段是一个好的方法。</p>
<p>程序必须保证每个循环中都更新迭代器、引用或指针</p>
<blockquote>
<p>不要保存end返回的迭代器</p>
</blockquote>
<p>当我们添加删除 vector或 string的元素后,或在 deque中首元素之外任何位置添加删除元素后,原来end返回的迭代器总是会失效。因此,<strong>添加或删除元素的循环程序必须反复调用end,而不能在循环之前保存end返回的迭代器</strong>,一直当作容器末尾使用。通常C++标准库的实现中end()操作都很快,部分就是因为这个原因。</p>
<h2 id="vector对象是如何增长的"><a href="#vector对象是如何增长的" class="headerlink" title="vector对象是如何增长的"></a>vector对象是如何增长的</h2><p>为了支持快速随机访问，vector将元素连续存储——每个元素紧挨着前一个元素存储。</p>
<p>假定容器中元素是连续存储的,且容器的大小是可变的,考虑向 vector或string中添加元素会发生什么:如果没有空间容纳新元素,容器不可能简单地将它添加到内存中其他位置一一因为元素必须连续存储。容器必须分配新的内存空间来保存已有元素和新元素,将已有元素从旧位置移动到新空间中,然后添加新元素,释放旧存储空间。如如果我们每添加一个新元素, vector就执行一次这样的内存分配和释放操作,性能会慢到不可</p>
<p>为了避免这种代价,标准库实现者采用了可以减少容器空间重新分配次数的策略。当不得不获取新的内存空间时, vector和 string的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用,可用来保存更多的新元素。</p>
<p>vector 在每次重新分配内存的时候都要移动所有元素</p>
<blockquote>
<p>管理容量的成员函数</p>
</blockquote>
<p> capacity操作告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素。 reserve操作允许我们通知容器它应该准备保存多少个元素。</p>
<blockquote>
<p>capacity和size</p>
</blockquote>
<p>理解 capacity和size的区别非常重要。容器的size是指它已经保存的元素的数目;而 capacity则是在不分配新的内存空间的前提下它最多可以保存多少元素。</p>
<h2 id="额外的string操作"><a href="#额外的string操作" class="headerlink" title="额外的string操作"></a>额外的string操作</h2><h3 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861676844.jpg" alt="enter description here"></p>
<blockquote>
<p>substr操作</p>
</blockquote>
<p>substr操作返回一个str1ng,它是原始 string的一部分或全部的拷贝。可以传递给 substr一个可选的开始位置和计数值:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861736953.jpg" alt="enter description here"></p>
<h3 id="改变string的其他方法"><a href="#改变string的其他方法" class="headerlink" title="改变string的其他方法"></a>改变string的其他方法</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861803653.jpg" alt="enter description here"></p>
<h3 id="string搜索操作"><a href="#string搜索操作" class="headerlink" title="string搜索操作"></a>string搜索操作</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861836971.jpg" alt="enter description here"></p>
<h3 id="compare函数"><a href="#compare函数" class="headerlink" title="compare函数"></a>compare函数</h3><p>除了关系运算符外,标准准库str1ng类型还提供了一组compare函数,这些函数与C标准库的 strcmp函数很相似。类似 strcmp,据据s是等于、大于还是小于参数指定的字符串,s. compare返回回0、正数或负数。</p>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861942715.jpg" alt="enter description here"></p>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>除了顺序容器外,标准库还定义了三个顺序容器适配器: stack、 queue和priority_queue。<strong>适配器</strong>( adaptor)是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上,<strong>一个适配器是一种机制,能使某种事物的行为看起来像另外一种事物一样</strong>。一个容器适配器接受一种已有的容器类型,使其行为看起来像一种不同的类型。</p>
<blockquote>
<p>定义一个适配器</p>
</blockquote>
<p>每个适配器都定义两个构造函数:默认构造函数创建一个空对象,接受一个容器的构造函数拷贝该容器来初始化适配器。</p>
<p>默认情况下, stack和 queue是基于 deque实现的,priority_queue是在 vector之上实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第三个类型参数,来重载默认容器类型。</p>
<p>对于一个给定的适配器,可以使用哪些容器是有限制的。所有适配器都要求容器具有添加和删除元素的能力。因此,适配器不能构造在aray之上。类似的,我们也不能用forward_list来构造适配器,因为所有适配器都要求容器具有添加、删除以及访间尾元素的能力。 stack只要求 push_back、 pop_back和back操作,因此可以使用除 array</p>
<blockquote>
<p>栈适配器<br><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518862439794.jpg" alt="enter description here"></p>
</blockquote>
<p>每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作。我们只可以使用适配器操作,而不能使用底层容器类型的操作。</p>
<blockquote>
<p>队列适配器</p>
</blockquote>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518862492187.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518862504010.jpg" alt="enter description here"></p>
<p>标准库queue使用一种先进先出（first-in，first-out，FIFO）的存储和访问策略</p>
<p>priority_queue 允许我们为队列中的元素建立优先级，新加入的元素会排在所有优先级比它低的已有元素之前。</p>
<hr>
<h1 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h1><p>标准库容器定义的操作集合惊人得小。标准库并未给每个容器添加大量功能,而是提供了一组算法,这些算法中的大多数都独立于任何特定的容器。这些算法是通用的( generic,或称泛型的):它们可用于不同类型的容器和不同类型的元素。</p>
<p>顺序容器只定义了很少的一些操作，我们可以想象用户可能还希望做其他很多有用的操作:查找特定元素、替換或別除二个特定值、重排元素顺序等。</p>
<p>标准库并未给每个容器都定义成员函数来实现这些操作,而是定义了一组<strong>泛型算法</strong>( generic algorithm):称它们为“算法”,是因为它们实现了一些经典算法的公共接接口,如排序和搜索;称它们是“泛型的”,是因为它们可以用于不同类型的元素和多种容器类型</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一般情况下,泛型算法并不直接操作容器,而是遍历由两个迭代器指定的一个元素范围来进行操作。</p>
<p><strong>迭代器令算法不依赖于容器，但是算法依赖于容器的操作类型</strong>。虽然迭代器的使用令算法不依赖于容器类型,但大多数算法都使用了一个(或多个)元素类型上的操作。</p>
<p>泛型算法本身不会执行容器的操作，它们只会运行于迭代器上，执行迭代器的操作。</p>
<h2 id="初始泛型算法"><a href="#初始泛型算法" class="headerlink" title="初始泛型算法"></a>初始泛型算法</h2><h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p>一些算法只会读取其输入范围内的元素,而从不改变元素。find就是这样一种算法</p>
<p>另一个只读算法是 accumulate,它定义在头文件 numeric i中。 accumulate函数接受三个参数,前两个指出了需要求和的元素的范围,第三个参数是和的初值。accumulate将第三个参数作为求和起点,这蕴含着一个编程假定:将元素类型加到和的类型上的操作必须是可行的。即,序列中元素的类型必须与第三个参数匹配,或者能够转换为第三个参数的类型。</p>
<p>另一个只读算法是equal，用于确定两个序列是否保存相同的值。</p>
<h3 id="写容器元素的算法"><a href="#写容器元素的算法" class="headerlink" title="写容器元素的算法"></a>写容器元素的算法</h3><p>一些算法将新值赋予序列中的元素。当我们使用这类算法时,必须注意<strong>确保序列原大小至少不小于我们要求算法写入的元素数目</strong>。记住,<strong>算法不会执行容器操作,因此它们身不可能改变容器的大小</strong>。</p>
<p>一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素,该序列从目的位置迭代器指向的元素开始。</p>
<blockquote>
<p>介绍back_inserter</p>
</blockquote>
<p>一种保证算法有足够元素空间来容纳输出数据的方法是使用<strong>插入迭代器</strong>( InsertIterator)。插入送代器是一种向容器中添加元素的迭代器。通常情况,当我们通过一个送代器向容器元素赋值时,值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时,一个与赋值号右側值相等的元素被添加到容器中。</p>
<p>back_inserter接受一个指向容器的引用,返回一个与该容器绑定的插入迭代器当我们通过此迭代器赋值时,赋值运算符会调用 push_back将一个具有给定值的元素添加到容器中</p>
<blockquote>
<p>拷贝算法</p>
</blockquote>
<p>拷贝(copy)算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器,前两个表示一个输入范围,第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。</p>
<h3 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h3><p>某些算法会重排容器中元素的顺序,一个明显的例子是sort。调用sort会重排输入序列中的元素,使之有序,它是利用元素类型的运算符来实现排序的</p>
<blockquote>
<p>清除重复单词</p>
</blockquote>
<p>我们就可以使用另一个称为unique的标准库算法来重排ⅴector,使得不重复的元素出现在ⅴector的开始部分。由于算法不能执行容器的操作,我们将使用 vector的 erase成员来完成真正的删除操作</p>
<h2 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h2><p>很多算法都会比较输入序列中的元素。默认情况下,这类算法使用元素类型的&lt;或=运算符完成比较。标准库还为这些算法定义了额外的版本,允许<strong>我们提供自己定义的操作来代替默认运算符</strong>。</p>
<h3 id="向算法传递参数"><a href="#向算法传递参数" class="headerlink" title="向算法传递参数"></a>向算法传递参数</h3><blockquote>
<p>谓词</p>
</blockquote>
<p>谓词是一个可调用的表达式,其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类:一元谓词( unary predicate,意味着它们只接受单一参数)和二元谓词binary predicate,,意味着它们有两个参数)。接受谓词参数的算法对输入序列中的元素调用谓词。因此,元素类型必须能转换为谓词的参数类型。接受一个二元谓词参数的sOrt版本用这个谓词代替&lt;来比较元素。</p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>根据算法接受一元谓词还是二元谓词,我们传递给算法的谓词必须严格接受一个或两个参数。但是,有时我们希望进行的操作需要更多参数,超出了算法对谓词的限制。</p>
<blockquote>
<p>介绍lambda</p>
</blockquote>
<p>我们可以向一个算法传递任何类别的<strong>可调用对象</strong>( callable object)。对于一个对象或一个表达式,如果可以对其使用调用运算符,则称它为可调用的。即,如果e是一个可调用的表达式,则我们可以编写代码e(args),其中args是个逗号分隔的一个或多个参数的列表</p>
<p>到目前为止,<strong>我们使用过的仅有的两种可调用对象是函数和函数指针</strong>。还有其他两种可调用对象:重载了函数调用运算符的类,,以及 lambda表达式( lambda expression)</p>
<p>一个 lambda表达达式表示一个可调用的代码单元。我们们可以将其理解为一个未命名的内联函数。与任何函数类似似,一个 lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同, lambda可能定义在函数内部。一个 lambda表达式具有如下形式：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_18_1518953656030.jpg" alt="enter description here"></p>
<blockquote>
<p>向lambda传递参数</p>
</blockquote>
<p>与一个普通函数调用类似,调用一个 lambda时给定的实参被用来初始化 lambda的形参。通常,实参和形参的类型必须匹配。但与普通函数不同, <strong>lambda不能有默认参数</strong>。因此,一个 lambda调用的实参数目永远与形参数目相等。</p>
<blockquote>
<p>使用捕获列表</p>
</blockquote>
<p>虽然一个 lambda可以出现在一个函数中,使用其局部变量,但它只能使用那些明确指明的变量。<strong>一个 lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量</strong>。捕获列表指引 lambda在其内部包含访问局部变量所需的信息。</p>
<h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>当定义一个 lambda时,编译器生成一个与 lambda对应的新的(未命名的)类类型。目前,可以这样理解,当向个函数传递一个 lambda时,同时定义了一个新类型和该类型的一个对象:传递的参数就是此编译器生成的类类型的未命名对象。类似的,当使用auto定义一个用 lambda初始化的变量时,定义了一个从 lambda生成的类型的对象。</p>
<p>默认情況下,从 lambda生成的类都包含一个对应该 lambda 所捕获的変量的数据成员。类似任何普通类的数据成员, lambda的数据成员也在 lambda对象创建时被初始化。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_18_1518954256455.jpg" alt="enter description here"></p>
<blockquote>
<p>值捕获</p>
</blockquote>
<p>类似参数传递，变量的捕获方式也可以是值或引用。与传值参数类似,采用值捕获的前提是变量可以拷贝。与参数不同,被捕获的变量的值是在 lambda创建时拷贝,而不是调用时拷贝</p>
<blockquote>
<p>引用捕获</p>
</blockquote>
<p>一个以引用方式捕获的变量与其他任何类型的引用的行为类似。当我们在 lambda 函数体内使用此变量时,实际上使用用的是引用所绑定的对象。</p>
<blockquote>
<p>隐式捕获</p>
</blockquote>
<p>除了显式列出我们希望使用的来自所在函数的变量之外,还可以让编译器根据 lambda体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表,应在捕获列表中写一个&amp;或=。&amp;告诉编译器采用捕获引用方式,=则表示采用值捕获方式。</p>
<p>当我们混合使用隐式捕获和显式捕获时,捕获列表中的第一个元素必须是一个&amp;或=。此符号指定了默认捕获方式为引用或值。</p>
<p>当混合使用隐式捕获和显式捕获时,显式捕获的变量必须使用与隐式捕获不同的方式。即,如果隐式捕获是引用方式(使用了&amp;),则则显式捕获命名变量必须采用值方式,因此不能在其名字前使用&amp;。类似的,如如果隐式捕获采用的是值方式(使用了=),则显式捕获命名变量必须采用引用方式,即,在名字前使用&amp;。</p>
<blockquote>
<p>可变lambda</p>
</blockquote>
<p>默认情况下,对于一个值被拷贝的变量, lambda不会改变其值。如果我们希望能改变个被捕获的变量的值,就必须在参数列表首加上关键键字 mutale。</p>
<blockquote>
<p>指定的lambda返回类型</p>
</blockquote>
<p>默认情况下,如果一个 lambda体包含 return之外的任何语句,则编译器假定此 lambda返回void。与其他返回void的函数类似,被推断返回void的 lambda不能返回值。</p>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>对于那种只在一两个地方使用的简单操作, lambda表达式是最有用的。如果我们需要在很多地方使用相同的操作,通常应该定义一个函数,而不是多次编写相同的 lambda表达式。类似的,如果一个操作需要很多语句才能完成,通通常使用函数更好。</p>
<p>如果lambda的捕获列表为空，通常可以用函数来替代它。</p>
<p>但是,对于捕获局部变量的 lambda,用函数来替换它就不是那么容易了。</p>
<blockquote>
<p>标准bind函数</p>
</blockquote>
<p>我们可以解决向 check_size传递递一个长度参数的问题,方法是使用一个新的名为bind的标准库函数,它定义在头文件 functiona1中。可以将bind函数看作一个通用的函数适配记器,它接受一个可调用对象,生成一个新的可调用对象来“适应”原对象的参数列表</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_18_1518954580235.jpg" alt="enter description here"></p>
<h2 id="再探迭代器"><a href="#再探迭代器" class="headerlink" title="再探迭代器"></a>再探迭代器</h2><p>除了为每个容器定义的迭代器之外,标准库还定义了额外几种迭代器。这些迭代器包括以下几种</p>
<ul>
<li>插入迭代器( Insert iterator):这些迭代器被绑定到一个容器上,可用来向容器插入元素</li>
<li>流迭代器( stream Iterator):这些迭代器被绑定到输入或输出流上,可用来遍历所关联的IO流。</li>
<li>反向迭代器( reverse Iterator):这些迭代器向后而不是向前移动。除了forward1ist之外的标准库容器都有反向迭代器。</li>
<li>移动迭代器( move iterator):这些专用的迭代器不是拷贝其中的元素,而是移动它们。我们将在13.6.2节(第480页)介绍移动迭代器</li>
</ul>
<h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><p>插入器是一种迭代器适配器,它接受一个容器,生成一个迭代器,能实现向给定容器添加元素。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519893284405.jpg" alt="enter description here"></p>
<p>插入器有三种类型，其差异在于元素插入的位置：</p>
<ul>
<li>back_inserter创建一个使用 push_back的迭代器</li>
<li>front_inserter创建一个使用 push_front的迭代器</li>
<li>inserter创建一个使用 insert的迭代器。此函数接受第二个参数,这个参数必须是一个指向给定容器的迭代器。<strong>元素将被插入到给定迭代器所表示的元素之前</strong>。</li>
</ul>
<h3 id="iostream-迭代器"><a href="#iostream-迭代器" class="headerlink" title="iostream 迭代器"></a>iostream 迭代器</h3><p>虽然 iostream类型不是容器,但标准库定义了可以用于这些IO类型对象的迭代器。istream iterator读取输入流,ostream iterator向一个输出流写数据。<strong>这些迭代器将它们对应的流当作一个特定类型的元素序列来处理</strong>。通过使用流迭代器,我们可以用泛型算法从流对象读取数据以及向其写入数据。</p>
<blockquote>
<p>istream_iterator 允许使用懒惰求值</p>
</blockquote>
<p>当我们将一个 istream_iterator绑定到一个流时,标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据,直到我们使用迭代器时才真正读取。标准库中的实现所保证的是,<strong>在我们第一次解引用迭代器之前,从流中读取数据的操作已经完成了</strong>。对于大多数程序来说,立即读取还是推迟读取没什么差别。</p>
<h3 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h3><p>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器,递增(以及递减)操作的含义会颠倒过来。递增一个反向迭代器(++it)会移动到前一个元素;递减一个迭代器(–it)会移动到下一个元素。</p>
<p>除了 forwardlist之外,其他容器都支持反向迭代器。</p>
<h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><p>任何算法的最基本的特性是它要求其迭代器提供哪些操作。算法所要求的迭代器操作可以分为5个迭代器类别( Iterator category)。每个算法都会对它的每个迭代器参数指明须提供哪类迭代器。</p>
<p>算法还共享了一组参数传递规范和一组命名规范</p>
<h3 id="5类迭代器"><a href="#5类迭代器" class="headerlink" title="5类迭代器"></a>5类迭代器</h3><p>类似容器,迭代器也定义了一组公共操作。一些操作所有迭代器都支持,另外一些只有特定类别的迭代器才支持。例如, ostream_iterator只支持递增、解引用和赋值。vector、 string和 deque的迭代器除了这些操作外,还支持递减、关系和算术运算。</p>
<p>C++标准指明了泛型和数值算法的每个迭代器参数的最小类别。例如,find算法在一个序列上进行一遍扫描,对元素进行只读操作,因此至少需要输入迭代器。 </p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519894770101.jpg" alt="enter description here"></p>
<h3 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h3><p>在任何其他算法分类之上,还有一组参数规范。理解这些参数规范对学习新算法很有帮助—通过理解参数的含义,你可以将注意力集中在算法所做的操作上。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519894916626.jpg" alt="enter description here"></p>
<h3 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h3><p>除了参数规范,算法还遵循一套命名和重载规范。这些规范处理诸如:如何提供一个操作代替默认的&lt;或==运算符以及算法是将输出数据写入输入序列还是一个分离的目的位置等问题。</p>
<h2 id="特定容器算法"><a href="#特定容器算法" class="headerlink" title="特定容器算法"></a>特定容器算法</h2><p>与其他容器不同,链表类型list和forward_list定义了几个成员函数形式的算法。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519895023511.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519895035177.jpg" alt="enter description here"></p>
<hr>
<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>关联容器和顺序容器有着根本的不同:关联容器中的元素是按关键字来保存和访问的。与之相对,顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p>
<p>关联容器支持高效的关键字查找和访问。两个主要的<strong>关联容器</strong>( associative container)类型是map和set。map中的元素是一些关键字-值( key-value)对:关键字起到索引的作用,值则表示与索引相关联的数据。set中每个元素只包含一个关键字;set支持高效的关键字查询操作——检查一个给定关键字是否在set中。</p>
<p>标准库提供8个关联容器,。这8个容器间的不同体现在三个维度上:每个容器<br>(1)<strong>或者是一个set,或者是一个map</strong>;<br>(2)<strong>或者要求不重复的关键字,或者允许重复关键字</strong>;<br>(3)<strong>按顺序保存元素,或无序保存</strong></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519989186109.jpg" alt="enter description here"></p>
<h2 id="使用关联容器"><a href="#使用关联容器" class="headerlink" title="使用关联容器"></a>使用关联容器</h2><p>map是关键字值对的集合。例如,可以将一个人的名字作为关键字,将其电话号码作为值。我们称这样的数据结构为“将名字映射到电话号码”。map类型通常被称为关联数组( associative array)。关联数组与“正常”数组类似,不同之处在于其下标不必是整数。</p>
<p>与之相对,set就是关键字的简单集合。当只是想知道一个值是否存在时,set是最有用的。</p>
<h2 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h2><p>关联容器不支持顺序容器的位置相关的操作,例如 push_front或 push_back。原因是<strong>关联容器中元素是根据关键字存储的,这些操作对关联容器没有意义</strong>。而且,关联容器也<strong>不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作</strong>。</p>
<h3 id="定义关联容器"><a href="#定义关联容器" class="headerlink" title="定义关联容器"></a>定义关联容器</h3><p>当定义一个map时,必须既指明关键字类型又指明值类型;而定义一个set时,只需指明关键字类型,因为set中没有值。</p>
<p>map的初始化：<br><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519990637584.jpg" alt="enter description here"></p>
<h3 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h3><p>对于有序容器—map、 multimap、set以及 multiset,<strong>关键字类型必须定义元素比较的方法</strong>。默认情况下,标准库使用关键字类型的&lt;运算符来比较两个关键字。</p>
<blockquote>
<p>有序容器的关键字类型</p>
</blockquote>
<p>可以向一个算法提供我们自己定义的比较操作,与之类似也可以提供自己定义的操作来代替关键字上的&lt;运算符。所提供的操作必须在关键字类型上定义一个<strong>严格弱序</strong>( strict weak ordering)。</p>
<blockquote>
<p>使用关键字类型的比较函数</p>
</blockquote>
<p>用来组织一个容器中元素的操作的类型也是该容器类型的一部分。<strong>为了指定使用自定义的操作,必须在定义关联容器类型时提供此操作的类型</strong>。如前所述,用尖括号指出要定义哪种类型的容器,自定义的操作类型必须在尖括号中紧跟着元素类型给出</p>
<p>此处,我们使用 decltype来指出自定义操作的类型。记住,当用 decltype来获得一个函数指针类型时,必须加上一个*来指出我们要使用一个给定函数类型的指针</p>
<h3 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h3><p>在介绍关联容器操作之前,我们需要了解名为pair的标准库类型,它定义在头文件utility中。</p>
<p>一个pair保存两个数据成员。类似容器,pair是一个用来生成特定类型的模板当创建一个pair时,我们必须提供两个类型名,pa1r的数据成员将具有对应的类型。两个类型不要求一样:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519991091913.jpg" alt="enter description here"></p>
<p>与其他标准库类型不同,pair的数据成员是public的。两个成员分别命名为 first和 second。我们用普通的成员访问符号来访问它们</p>
<h2 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a>关联容器操作</h2><p>关联容器还定义了一些表示容器关键字和值的类型</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992027517.jpg" alt="enter description here"></p>
<h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><p>当解引用一个关联容器迭代器时,我们会得到一个类型为容器的value_type的值的引用。对map而言,value_type是一个pair类型,其 first成员保存 const的关键字, second成员保存值</p>
<blockquote>
<p>set 的迭代器是const的</p>
</blockquote>
<p>虽然set类型同时定义了 iterator和 const_iterator类型,但两种类型都只允许只读访问set中的元素。与不能改变一个map元素的关键字一样,一个set中的关键字也是 const的。可以用一个set迭代器来读取元素的值,但不能修改:</p>
<blockquote>
<p>遍历关联容器</p>
</blockquote>
<p>map和set类型都支持 begin和end操作。与往常一样我们可以用这些函数获取迭代器,然后用迭代器来遍历容器。</p>
<blockquote>
<p>关联容器和算法</p>
</blockquote>
<p>我们通常不对关联容器使用泛型算法。关键字是 const这一特性意味着<strong>不能将关联容器传递给修改或重排容器元素的算法</strong>,因为这类算法需要向元素写入值,而set类型中的元素是cnst的,map中的元素是pair,其第一个成员是 const的。</p>
<p>关联容器可用于只读取元素的算法。</p>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>关联容器的 insert成员向容器中添加一个元素或一个元素范围。由于map和set(以及对应的无序类型)包含不重复的关键字,因此插入一个已存在的元素对容器没有任何影响</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992536522.jpg" alt="enter description here"></p>
<blockquote>
<p>向map添加元素</p>
</blockquote>
<p>对一个map进行 insert操作时,必须记住元素类型是pair。通常,对于想要插入的数据,并没有一个现成的pair对象。可以在 insert的参数列表中创建一个pair</p>
<blockquote>
<p>检测insert的返回值</p>
</blockquote>
<p>insert(或emplace)返回的值依赖于容器类型和参数。对于不包含重复关键字的容器,添加单一元素的 insert和 emplace版本返回一个pair,告诉我们插入操作是否成功。pair的 first成员是一个迭代器,指向具有给定关键字的元素; second成员是一个bool值,指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中</p>
<h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992521248.jpg" alt="enter description here"></p>
<h3 id="map的下标操作"><a href="#map的下标操作" class="headerlink" title="map的下标操作"></a>map的下标操作</h3><p>map和 unordered_map容器提供了下标运算符和一个对应的at函数。set类型不支持下标,因为set中没有与关键字相关联的“值”。元素本身就是关键字,因此“获取与一个关键字相关联的值”的操作就没有意义了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992604789.jpg" alt="enter description here"></p>
<h3 id="访问元素-1"><a href="#访问元素-1" class="headerlink" title="访问元素"></a>访问元素</h3><p>关联容器提供多种查找一个指定元素的方法</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992681370.jpg" alt="enter description here"></p>
<blockquote>
<p>对map使用find代替下标操作</p>
</blockquote>
<p>对map和 unordered map类型,下标运算符提供了最简单的提取元素的方法。但是如我们所见,使用下标操作有一个严重的副作用:如果关键字还未在map中,下标操作会插入一个具有给定关键字的元素。这种行为是否正确完全依赖于我们的预期是什么。</p>
<h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p>新标准定义了4个<strong>无序关联容器</strong>( unordered associative container)。这些容器不是使用比较运算符来组织元素,而是使用一个哈希函数( hash function)和关键字类型==运算符。在关键字类型的元素没有明显的序关系的情况下,无序容器是非常有用的。</p>
<blockquote>
<p>使用无序容器</p>
</blockquote>
<p>除了哈希管理操作之外,无序容器还提供了与有序容器相同的操作(find、 insert）</p>
<blockquote>
<p>管理桶</p>
</blockquote>
<p>无序容器在存储上组织为一组桶,每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素,容器首先计算元素的哈希值,它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字,所有具有相同关键字的元素也都会在同一个桶中。因此,无序容器的性能依赖于哈希函数的质量和桶的数量和大小。</p>
<hr>
<h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><p>动态对象的正确释放被证明是编程中极其容易出错的地方。为了更安全地使用动态对象,标准库定义了两个智能指针类型来管理动态分配的对象。<strong>当一个对象应该被释放时,指向它的智能指针可以确保自动地释放它</strong>。</p>
<p>除了静态内存和栈内存,每个程序还拥有一个内存池。这部分内存被称作<strong>自由空间</strong>( free store)或<strong>堆</strong>(heap)。程序用堆来存储动态分配( dynamically allocate)的对象——即那些在程序运行时分配的对象。</p>
<h2 id="动态内存和智能指针"><a href="#动态内存和智能指针" class="headerlink" title="动态内存和智能指针"></a>动态内存和智能指针</h2><p>在++中,动态内存的管理是通过一对运算符来完成的:new,在动态内存中为对象分配空间并返回一个指向该对象的指针,我们可以选择对对象进行初始化; delete,接受一个动态对象的指针,销毁该对象,并释放与之关联的内存</p>
<p>为了更容易(同时也更安全)地使用动态内存,新的标准库提供了两种智能指针( smartpointer.)类型来管理动态对象。智能指针的行为类似常规指针,重要的区别是它<strong>负责自动释放所指向的对象</strong>。新标准库提供的这两种智能指针的区别在于管理底层指针的方式shared_ptr允许多个指针指向同一个对于象; unique_ptr则“独占”所指向的对象。标准库还定义了一个名为 weak_ptr的伴随类,它是一种弱引用,指向 shared_ptr所管理的对象。这三种类型都定义在 memory头文件中。</p>
<h3 id="share-ptr类"><a href="#share-ptr类" class="headerlink" title="share_ptr类"></a>share_ptr类</h3><p>类似 vector,智能指针也是模板。因此,当我们创建一个智能指针十时,必须提供额外的信息—指针可以指向的类型。智能指针的使用方式与普通指针类似。解引用一个智能指针返回它指向的对象。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520129716802.jpg" alt="enter description here"></p>
<blockquote>
<p>make_shared 函数</p>
</blockquote>
<p>最安全的分配和使用动态内存的方法是调用一个名为 make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它,返回指向此对象的 shared_ptr。</p>
<p>当要用 make_shared时,必须指定想要创建的对象的类型。定义方式与模板类相同在函数名之后跟一个尖括号,在其中给出类型</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520129795731.jpg" alt="enter description here"></p>
<blockquote>
<p>shared_ptr 的拷贝和赋值</p>
</blockquote>
<p>我们可以认为每个 shared_ptr都有一个关联的计数器,通常称其为<strong>引用计数</strong>( reference count)。无论何时我们拷贝一个 shared_ptr,计数器都会递增。一旦一个 shared_ptr的计数器变为0,它就会自动释放自己所管理的对象</p>
<blockquote>
<p>shared_ptr 自动销毁所管理的对象</p>
</blockquote>
<p>当指向一个对象的最后一个 shared_ptr被销毁时, shared_ptr类会自动销毁此对象。它是通过另一个特殊的成员函数——析构函数( destructor)完成销毁工作的。</p>
<blockquote>
<p>使用动态生存期的资源的类</p>
</blockquote>
<p>程序使用动态内存出于以下三种原因之一：</p>
<ul>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个资源之间共享数据</li>
</ul>
<h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><p>C++语言定义了两个运算符来分配和释放动态内存。运算符new分配内存, delete释放new分配的内存。</p>
<blockquote>
<p>使用new动态分配和初始化对象</p>
</blockquote>
<p>在自由空间分配的内存是无名的,因此new无法为其分配的对象命名,而是返回一个指向该对象的指针。</p>
<p>默认情况下,动态分配的对象是默认初始化的,这意味着内置类型或组合类型的对象的值将是未定义的,而类类型对象将用默认构造函数进行初始化</p>
<blockquote>
<p>内存耗尽</p>
</blockquote>
<p>一旦一个程序用光了它所有可用的内在,new表达式就会失败。默认情况下,加果new不能分配所要求的内存空间,它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常:</p>
<p>动态内存管理的时候非常容易出错：</p>
<ol>
<li>忘记delete内存</li>
<li>使用已经释放掉的对象</li>
<li>同一块内存释放两次</li>
</ol>
<blockquote>
<p>delete 之后重置指针</p>
</blockquote>
<p>当我们 delete一个指针后,指针值就变为无效了。虽然指针已经无效,但在很多机器上指针仍然保存着(已经释放了的)动态内存的地址。在 delete之后,指针就变成了人们所说的<strong>空悬指针</strong>( dangling pointer),即<strong>指向一块曾经保存数据对象但现在已经无效的内存的指针</strong>。</p>
<p>未初始化指针的所有缺点空悬指针也都有。有一种方法可以避免空悬指针的问题:在指针即将要离开其作用域之前释放掉它所关联的内存。</p>
<h3 id="share-ptr和new结合使用"><a href="#share-ptr和new结合使用" class="headerlink" title="share_ptr和new结合使用"></a>share_ptr和new结合使用</h3><p>如果我们不初始化一个智能指针，那么这个指针就会被初始化为一个空指针。</p>
<p>接受指针参数的智能指针构造函数是explicit的（禁止隐式转换）。因此,我们不能将一个内置指针隐式转换为一个智能指针,必须使用直接初始化形式</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520130371151.jpg" alt="enter description here"></p>
<h3 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h3><p>如果使用智能指针,即使程序块过早结束,智能指针类也能确保在内存不再需要时将其释放</p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>个 unique_ptr“拥有”它所指向的对象。与 shared_ptr不同,某个时刻只能有一个 unique_ptr指向一个给定对象。当 unique_ptr被销毁时,它所指向的对象也被销毁。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520130502646.jpg" alt="enter description here"></p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr是一种不控制所指向对象生存期的智能指针,它指向由一个shared_ptr管理的对象。将一个 weak_ptr绑定到一个 shared_ptr不会改变shared_ptr的引用计数。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520130696044.jpg" alt="enter description here"></p>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>new和 delete运算符一次分配释放一个对象,但某些应用需要一次为很多对象分配内存的功能。</p>
<p>为了支持这种需求,C++语言和标准库提供了两种一次分配一个对象数组的方法。C+语言定义了另一种new表达式语法,可以分配并初始化一个对象数组。标准库中包含个名为allocator的类,允许我们们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力</p>
<h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h3><p>为了让new分配一个对象数组,我们要在类型名之后跟一对方括号,在其中指明要分配的对象的数目。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span> [get_size()]; <span class="comment">// pia指向第一个int</span></div></pre></td></tr></table></figure>
<p>虽然我们]通常称newT[]分配的内存为“动态数组”,但这种叫法某种程度上有些误导。当用new分配一个数组时,我们并未得到一个数组类型的对象,而是得到一个数组元素类型的指针。不能对动态数组调用begin和end。</p>
<blockquote>
<p>释放动态数组</p>
</blockquote>
<p>为了释放动态数组,我们使用一种特殊形式的 delete—在指针前加上一个空方括号对:</p>
<blockquote>
<p>智能指针和动态数组</p>
</blockquote>
<p>标准库提供了一个可以管理new分配的数组的 unique_ptr版本。为了用一个unique_ptr管理动态数组,我们必须在对象类型后面跟一对空方括号:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520132049585.jpg" alt="enter description here"></p>
<h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>new有一些灵活性上的局限,其中一方面表现在它将内存分配和对象构造组合在了起。类似的, delete将对象析构和内存释放组合在了一起。我们分配单个对象时,通常希望将内存分配和对象初始化组合在一起。因为在这种情况下,我们几乎肯定知道对象应有什么值。</p>
<p>标准库allocator类定义在头文件 memory中,它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法,它分配的内存是原始的、未构造的。allocator是一个模板。</p>
<blockquote>
<p>allocator 分配未构造的内存</p>
</blockquote>
<p>allocator分配的内存是未构造的( unconstructed)。我们按需要在此内存中构造对象。在新标准库中, construct成员函数接受一个指针和零个或多个额外参数,在给定位置构造一个元素。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》笔记 C++基础部分&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C/C++" scheme="https://www.liuin.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker部署Hexo博客</title>
    <link href="https://www.liuin.cn/2018/03/02/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>https://www.liuin.cn/2018/03/02/使用Docker部署Hexo博客/</id>
    <published>2018-03-02T09:39:37.000Z</published>
    <updated>2018-03-02T09:47:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文展示使用Docker部署Hexo博客（当然也可以是其他的服务）在服务器上的一种方案，主要用到是webhook来触发git pull操作。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之前部署Hexo博客的时候好像配置蛮久的，想着能不能把这些东西都放进Docker里面，以后换服务器以后部署也方面，于是便有了这波操作。</p>
<p>这里使用的是<a href="https://github.com/adnanh/webhook" target="_blank" rel="external">webhook</a>这个轮子来实现持续集成的。</p>
<p>工作示意图：<br>本地编辑—-git push—-&gt;Github—-webhook—-&gt;server—-get pull—-&gt;内容更新</p>
<p>使用到两个Docker：</p>
<ol>
<li><code>webhook</code>:  当push新的commit到GitHub（或其他平台）时解析GitHub发过来的webhook执行脚本更新网站内容</li>
<li><code>nginx</code>: Web服务器，展示网站内容</li>
</ol>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx容器的配置比较简单,只需要修改<code>nginx.conf</code>配置，监听80端口就行了。（如果需要需要https，则需要配置要证书以及配置监听443端口）。</p>
<p>这里贴出我的<code>docker-compose.yml</code>文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">version: &apos;3&apos;</div><div class="line">services:</div><div class="line">    web:</div><div class="line">        image: nginx</div><div class="line">        volumes:</div><div class="line">            - ./nginx.conf:/etc/nginx/nginx.conf</div><div class="line">            - ./sites-enabled:/etc/nginx/sites-enabled</div><div class="line">            - /path-to-your-content:/var/www</div><div class="line">            - ./ssl:/ssl</div><div class="line">        ports:</div><div class="line">            - &quot;80:80&quot;</div><div class="line">            - &quot;443:443&quot;</div></pre></td></tr></table></figure></p>
<p>ssl文件夹中的是证书，<code>path-to-your-content</code>是你静态页面的路径。</p>
<h2 id="Webhook"><a href="#Webhook" class="headerlink" title="Webhook"></a>Webhook</h2><p>Webhook任务是解析发过来的请求，然后执行脚本来从远程仓库中拉取更新。</p>
<p>首先是构建镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">FROM golang</div><div class="line">MAINTAINER sixzeroo &lt;sixzeroo60@gmail.com&gt;</div><div class="line"></div><div class="line">RUN mkdir -p /code/webhook \</div><div class="line">    &amp;&amp; touch /code/webhook/hook.json \</div><div class="line">    &amp;&amp; go get github.com/adnanh/webhook</div><div class="line"></div><div class="line">WORKDIR /code/webhook</div><div class="line"></div><div class="line">ENTRYPOINT /go/bin/webhook -hooks /code/webhook/hooks.json -verbose</div></pre></td></tr></table></figure></p>
<p>成品：<a href="https://hub.docker.com/r/sixzeroo/webhook/" target="_blank" rel="external">sixzeroo/webhook</a></p>
<p>之后就可以使用webhook来创建钩子任务了，其中配置文件在<code>hooks.json</code>中：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  &#123;</div><div class="line">    <span class="attr">"id"</span>: <span class="string">"your-id"</span>,</div><div class="line">    <span class="attr">"execute-command"</span>: <span class="string">"/code/webhook/work.sh"</span>,</div><div class="line">    <span class="attr">"command-working-directory"</span>: <span class="string">"/code/webhook"</span></div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>执行的脚本就是从GitHub中拉取更新而已，<code>work.sh</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#! /bin/sh</div><div class="line"></div><div class="line">cd /var/www &amp;&amp; git pull</div><div class="line"></div><div class="line">curtime=`date +&quot;%Y%m%d%H%M%S&quot;`</div><div class="line"></div><div class="line">if [ $? -eq 0 ];then</div><div class="line">    echo &quot;$curtime pull success!&quot; &gt;&gt; /code/webhook/git.log</div><div class="line">else</div><div class="line">    echo &quot;$curtime pull fail!&quot; &gt;&gt; /code/webhook/git.log</div><div class="line">fi</div></pre></td></tr></table></figure></p>
<p>最后配置整个服务，<code>docker-compose.yml</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">version: &quot;3&quot;</div><div class="line">services:</div><div class="line"></div><div class="line">    webhook:</div><div class="line">        image: sixzeroo/webhook</div><div class="line">        volumes:</div><div class="line">         - ./:/code/webhook</div><div class="line">         - /path-to-your-content:/var/www</div><div class="line">         - /key-path:/root/.ssh</div><div class="line">        ports:</div><div class="line">         - &quot;9000:9000&quot;</div></pre></td></tr></table></figure></p>
<p>其中<code>key-path</code>是你ssh文件夹路径</p>
<p>最后启动两个服务就可以工作了，设置GitHub当有push的时候发送<code>http://your-host:9000/hooks/your-id</code>这样的webhook就行了。</p>
<p>这里不把两个容器放到一个服务里面的原因是Nginx容器之后会有新的服务部署，里面会做一些修改。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文展示使用Docker部署Hexo博客（当然也可以是其他的服务）在服务器上的一种方案，主要用到是webhook来触发git pull操作。&lt;/p&gt;
    
    </summary>
    
      <category term="开发随笔" scheme="https://www.liuin.cn/categories/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Docker" scheme="https://www.liuin.cn/tags/Docker/"/>
    
      <category term="Hexo" scheme="https://www.liuin.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Docker Swarm 简介</title>
    <link href="https://www.liuin.cn/2018/02/28/Docker-Swarm-%E7%AE%80%E4%BB%8B/"/>
    <id>https://www.liuin.cn/2018/02/28/Docker-Swarm-简介/</id>
    <published>2018-02-28T07:36:04.000Z</published>
    <updated>2018-02-28T07:37:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>Docker Swarm 为Docker 提供容器集群服务，是 Docker 官 方对容器云生态进行支持的核心方案。</p>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Swarm 是使用 SwarmKit 构建的 Docker 引擎内置（原生）的集群管理和编排工具。 Swarm 集群之前需要了解以下几个概念。</p>
<h3 id="什么是swarm"><a href="#什么是swarm" class="headerlink" title="什么是swarm"></a>什么是swarm</h3><p>嵌入在Docker Engine中的集群管理和编排功能是通过swarmkit构建的。 Swarmkit是一个独立的项目，它实现了Docker的编排层，并直接在Docker中使用。</p>
<p>一个群由多个Docker主机组成，这些主机以群模式运行并充当管理者（管理成员资格和委派）和工作者（运行群集服务）。 给定的Docker主机可以是管理员，工作者或执行这两种角色。 当您创建服务时，您可以定义其理想状态（副本数量，可用的网络和存储资源，将服务暴露给外部世界等等）。 Docker的工作是维持这个理想的状态。 例如，如果工作者节点变得不可用，Docker会在其他节点上调度该节点的任务。 任务是一个正在运行的容器，它是swarm服务的一部分，由swarm管理器管理，而不是独立的容器。</p>
<p>群集服务相对于独立容器的主要优势之一是可以修改服务的配置，其中包括连接的网络和卷，而无需手动重新启动服务。 Docker将更新配置，停止使用过时配置的服务任务，并创建与所需配置相匹配的新服务。</p>
<p>当Docker以群集模式运行时，您仍然可以在参与群集的任何Docker主机以及群集服务上运行独立容器。 独立容器和群集服务之间的一个主要区别是，只有群集管理员可以管理群集，而独立容器可以在任何守护进程上启动。 Docker守护进程可以作为管理者，工作者或两者参与群体。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>与Docker Engine集成的集群管理</li>
<li>分散设计：Docker Engine在部署时不需要处理节点角色之间的差异，而是在运行时处理这些特殊的东西</li>
<li>声明式服务模式：Docker Engine使用声明性方法来让您在应用程序堆栈中定义各种服务的所需状态。</li>
<li>伸缩服务</li>
<li>理想状态调整</li>
<li>多主机联网</li>
<li>服务发现</li>
</ul>
<h3 id="节点（Nodes）"><a href="#节点（Nodes）" class="headerlink" title="节点（Nodes）"></a>节点（Nodes）</h3><p>节点是参与群体的Docker引擎的一个实例。 您也可以将其视为Docker节点。 您可以在单台物理计算机或云服务器上运行一个或多个节点，但生产群部署通常包括分布在多台物理机和云计算机上的Docker节点。</p>
<p>节点分为管理( manager)节点和工作( wor ker)节点。</p>
<p>管理节点用于 Swarm集群的管理, <code>docker swarm</code>命令基本只能在管理节点执行(节点退出集群命令 docker swarm leave可以在工作节点执行)。一个 Swarm集群可以有多个管理节点,但只有一个管理节点可以成为 <code>leader</code> ,<code>leader</code>通过<code>raft</code>协议实现。</p>
<p>工作节点是任务执行节点,管理节点将服务( servlce)下发至工作节点执行。管理节点默认也作为工作节点。你也可以通过配置让服务只运行在管理节点</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_28_1519799540229.jpg" alt="enter description here"></p>
<h3 id="服务（Services）和任务（Tasks）"><a href="#服务（Services）和任务（Tasks）" class="headerlink" title="服务（Services）和任务（Tasks）"></a>服务（Services）和任务（Tasks）</h3><p>服务（Services）是要在管理器或工作节点上执行的任务的定义。它是群体系统的中心结构，也是群体与用户互动的主要根源。</p>
<p>任务（Task）包含一个Docker容器和在容器内运行的命令。它是swarm的原子调度单位。</p>
<p>服务有两种模式：</p>
<ul>
<li><code>replicated services</code> 按照一定规则在各个工作节点上运行指定个数的任务</li>
<li><code>global services</code>每个工作节点上运行一个任务</li>
</ul>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_28_1519799982888.jpg" alt="enter description here"></p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="初始化-swarm-init"><a href="#初始化-swarm-init" class="headerlink" title="初始化 (swarm init)"></a>初始化 (swarm init)</h3><p>使用<code>docker swarm init</code>来在本机初始化一个swarm集群</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ docker swarm init --advertise-addr 192.168.99.100</div><div class="line">Swarm initialized: current node (dxn1zf6l61qsb1josjja83ngz) is now a manager.</div><div class="line"></div><div class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</div><div class="line"></div><div class="line">    docker swarm join \</div><div class="line">    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \</div><div class="line">    192.168.99.100:2377</div><div class="line"></div><div class="line">To add a manager to this swarm, run <span class="string">'docker swarm join-token manager'</span> and follow the instructions.</div></pre></td></tr></table></figure>
<p>如果你的 Docker 主机有多个网卡，拥有多个 IP，必须使用 <code>--advertise-addr</code>指定 IP。</p>
<p>执行 docker swarm init 命令的节点自动成为管理节点。</p>
<h3 id="添加节点-swarm-join"><a href="#添加节点-swarm-join" class="headerlink" title="添加节点 (swarm join)"></a>添加节点 (swarm join)</h3><p>向集群中添加一个工作节点/管理节点</p>
<p>格式： <code>docker swarm join [OPTIONS] HOST:PORT</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker@worker1:~$ docker swarm join \</div><div class="line">    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \</div><div class="line">    192.168.99.100:2377</div></pre></td></tr></table></figure>
<h3 id="查看节点-node-ls"><a href="#查看节点-node-ls" class="headerlink" title="查看节点 (node ls)"></a>查看节点 (node ls)</h3><p>使用 <code>docker node ls</code> 查看集群</p>
<h3 id="新建服务-service-create"><a href="#新建服务-service-create" class="headerlink" title="新建服务 (service create)"></a>新建服务 (service create)</h3><p>命令格式：<code>docker service create [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker service create --replicas 3 -p 80:80 --name nginx nginx:1.13.7-alpine</div></pre></td></tr></table></figure></p>
<p><code>--replicas</code> 表示创建多少任务</p>
<h3 id="查看服务信息-service-ls"><a href="#查看服务信息-service-ls" class="headerlink" title="查看服务信息 (service ls)"></a>查看服务信息 (service ls)</h3><p>使用 <code>docker service ls</code> 来查看当前 Swarm 集群运行的服务</p>
<p>想要查看其中某一个服务的详细信息，可以使用 <code>service inspect</code>命令: <code>docker service inspect [OPTIONS] SERVICE [SERVICE...]</code></p>
<h3 id="查看服务中的任务详情-service-ps"><a href="#查看服务中的任务详情-service-ps" class="headerlink" title="查看服务中的任务详情 (service ps)"></a>查看服务中的任务详情 (service ps)</h3><p>使用 <code>docker service ps</code> 来查看某个服务中的任务(Task)的详情 <code>docker service ps [OPTIONS] SERVICE [SERVICE...]</code></p>
<h3 id="查看服务日志-service-logs"><a href="#查看服务日志-service-logs" class="headerlink" title="查看服务日志 (service logs)"></a>查看服务日志 (service logs)</h3><p>使用 <code>docker service logs</code> 来查看某个服务的日志</p>
<h3 id="删除服务-service-rm"><a href="#删除服务-service-rm" class="headerlink" title="删除服务 (service rm)"></a>删除服务 (service rm)</h3><p>使用 <code>docker service rm</code> 来从 Swarm 集群移除某个服务。</p>
<h3 id="服务伸缩-service-scale"><a href="#服务伸缩-service-scale" class="headerlink" title="服务伸缩 (service scale)"></a>服务伸缩 (service scale)</h3><p>使用 <code>docker service scale</code>调整服务中的任务数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker service scale backend=10</div></pre></td></tr></table></figure>
<h2 id="使用Stack部署服务"><a href="#使用Stack部署服务" class="headerlink" title="使用Stack部署服务"></a>使用Stack部署服务</h2><p>Stack是一组相互关联的服务，它们可以共享依赖关系，并且可以进行协调和缩放。 单个Stack能够定义和协调整个应用程序的功能（尽管非常复杂的应用程序可能需要使用多个Stack）</p>
<p>正如之前使用 docker-compose.yml 来一次配置、启动多个容器，在 Swarm 集群中也可以使用 compose 文件 （docker-compose.yml） 来配置、启动多个服务。</p>
<p>我们使用 docker service create 一次只能部署一个服务，使用 docker-compose.yml 我们可以一次启动多个关联的服务。我们在此以 Swarm 集群中部署 WordPress 为例进行说明。</p>
<p>docker-compose.yml 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">version: &quot;3&quot;</div><div class="line"></div><div class="line">services:</div><div class="line">  wordpress:</div><div class="line">    image: wordpress</div><div class="line">    ports:</div><div class="line">      - 80:80</div><div class="line">    networks:</div><div class="line">      - overlay</div><div class="line">    environment:</div><div class="line">      WORDPRESS_DB_HOST: db:3306</div><div class="line">      WORDPRESS_DB_USER: wordpress</div><div class="line">      WORDPRESS_DB_PASSWORD: wordpress</div><div class="line">    deploy:</div><div class="line">      mode: replicated</div><div class="line">      replicas: 3</div><div class="line"></div><div class="line">  db:</div><div class="line">    image: mysql</div><div class="line">    networks:</div><div class="line">       - overlay</div><div class="line">    volumes:</div><div class="line">      - db-data:/var/lib/mysql</div><div class="line">    environment:</div><div class="line">      MYSQL_ROOT_PASSWORD: somewordpress</div><div class="line">      MYSQL_DATABASE: wordpress</div><div class="line">      MYSQL_USER: wordpress</div><div class="line">      MYSQL_PASSWORD: wordpress</div><div class="line">    deploy:</div><div class="line">      placement:</div><div class="line">        constraints: [node.role == manager]</div><div class="line"></div><div class="line">  visualizer:</div><div class="line">    image: dockersamples/visualizer:stable</div><div class="line">    ports:</div><div class="line">      - &quot;8080:8080&quot;</div><div class="line">    stop_grace_period: 1m30s</div><div class="line">    volumes:</div><div class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</div><div class="line">    deploy:</div><div class="line">      placement:</div><div class="line">        constraints: [node.role == manager]</div><div class="line"></div><div class="line">volumes:</div><div class="line">  db-data:</div><div class="line">networks:</div><div class="line">  overlay:</div></pre></td></tr></table></figure></p>
<p>在 Swarm 集群管理节点新建该文件，其中的 visualizer 服务提供一个可视化页面，我们可以从浏览器中很直观的查看集群中各个服务的运行节点。</p>
<h3 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h3><p>部署服务使用 <code>docker stack deploy</code>，其中 -c 参数指定 compose 文件名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker stack deploy -c docker-compose.yml wordpress</div></pre></td></tr></table></figure></p>
<h3 id="查看服务"><a href="#查看服务" class="headerlink" title="查看服务"></a>查看服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker stack ls</div><div class="line">NAME                SERVICES</div><div class="line">wordpress           3</div></pre></td></tr></table></figure>
<h3 id="移除服务"><a href="#移除服务" class="headerlink" title="移除服务"></a>移除服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">要移除服务，使用 docker stack down</div><div class="line"></div><div class="line">$ docker stack down wordpress</div><div class="line">Removing service wordpress_db</div><div class="line">Removing service wordpress_visualizer</div><div class="line">Removing service wordpress_wordpress</div><div class="line">Removing network wordpress_overlay</div><div class="line">Removing network wordpress_default</div></pre></td></tr></table></figure>
<p>该命令不会移除服务所使用的 数据卷，如果你想移除数据卷请使用 docker volume rm</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://0x9.me/WYIcD" target="_blank" rel="external">https://0x9.me/WYIcD</a></li>
<li><a href="https://0x9.me/Woidc" target="_blank" rel="external">https://0x9.me/Woidc</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker Swarm 为Docker 提供容器集群服务，是 Docker 官 方对容器云生态进行支持的核心方案。&lt;/p&gt;
    
    </summary>
    
      <category term="运维" scheme="https://www.liuin.cn/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Docker" scheme="https://www.liuin.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Next Permutation 题解</title>
    <link href="https://www.liuin.cn/2018/02/25/LeetCode-Next-Permutation-%E9%A2%98%E8%A7%A3/"/>
    <id>https://www.liuin.cn/2018/02/25/LeetCode-Next-Permutation-题解/</id>
    <published>2018-02-25T01:27:43.000Z</published>
    <updated>2018-03-02T13:53:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode Next Permutation 题解</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目的意思就是求给定序列的下一个字典序</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们要了解什么是字典序，这里参考wiki的解释：</p>
<blockquote>
<p>设想一本英语字典里的单词，何者在前何者在后？</p>
<p>显然的做法是先按照第一个字母、以 a、b、c……z 的顺序排列；如果第一个字母一样，那么比较第二个、第三个乃至后面的字母。如果比到最后两个单词不一样长（比如，sigh 和 sight），那么把短者排在前。</p>
<p>通过这种方法，我们可以给本来不相关的单词强行规定出一个顺序。“单词”可以看作是“字母”的字符串，而把这一点推而广之就可以认为是给对应位置元素所属集合分别相同的各个有序多元组规定顺序</p>
</blockquote>
<p>我的理解是：<strong>把一组数的所有排列情况按照字母顺序进行一次排序得到的就是一个字典序</strong></p>
<p>在这道题中要求给定排列的下一个字典序，可以知道把一个大一点的数往前移动这个序列的字典序一定会变大，那么就要从后往前找到第一个能变大的数（变大指和它后面的某个数互换以后），找到这个数以后把他和比他大的“第一个”数互换获得最小的增量，然后把这个数后面的数字按照从小到大的顺序重新排列。</p>
<p>举个例子：</p>
<p><img src="https://leetcode.com/media/original_images/31_Next_Permutation.gif" alt="enter description here"></p>
<h2 id="代码-C"><a href="#代码-C" class="headerlink" title="代码(C++)"></a>代码(C++)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int first = nums.size(), len = nums.size();</div><div class="line">        // 倒序查找第一个升序数</div><div class="line">        for(int i=len-1; i&gt;0;--i)</div><div class="line">        &#123;</div><div class="line">            if(nums[i] &gt; nums[i-1])</div><div class="line">            &#123;</div><div class="line">                first = i-1;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if(first == len)</div><div class="line">            reverse(nums.begin(), nums.end());</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            int second = len-1;</div><div class="line">            // 在后面找一个刚好比这个数大一点的数和其互换</div><div class="line">            for(int i=first + 1;i&lt;len;++i)</div><div class="line">            &#123;</div><div class="line">                if(nums[i]&lt;=nums[first])</div><div class="line">                &#123;</div><div class="line">                    second = i-1;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            swap(nums[first], nums[second]);</div><div class="line">            // 反转后面的部分</div><div class="line">            reverse(nums.begin()+first+1, nums.end());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode Next Permutation 题解&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.liuin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://www.liuin.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Docker Machine 简介</title>
    <link href="https://www.liuin.cn/2018/02/16/Docker-Machine-%E7%AE%80%E4%BB%8B/"/>
    <id>https://www.liuin.cn/2018/02/16/Docker-Machine-简介/</id>
    <published>2018-02-16T11:08:04.000Z</published>
    <updated>2018-02-23T04:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 继续探索</p>
<a id="more"></a>
<h2 id="什么是Docker-Machine"><a href="#什么是Docker-Machine" class="headerlink" title="什么是Docker Machine"></a>什么是Docker Machine</h2><p>Docker Machine 是一种可让您在虚拟主机上安装 <code>Docker Engine</code> 并使用docker-machine命令管理主机的工具。你能使用Docker Machine 工具在你的本地 Mac 或 Windows boxs，公司网络，数据中心或 Azure 提供商（如 Azure，AWS 或 Digital Ocean）上创建 Docker 主机。</p>
<p>使用 <code>docker-machine</code> 命令，你能够开始、插入、停止和重启一个你所管理的主机、更新Docker的客户端和守护进程、并配置Docker配置以便和主机进行通信。</p>
<p>将Machine CLI指向一个正在运行并且托管的主机，你能够直接使用<code>docker</code>直接命令该主机。比如说，运行<code>docker-machine env default</code>指向一个名为<code>defaule</code>的主机，按照屏幕上的指令完成<code>env</code>的配置，并运行<code>docker ps</code> ，<code>docker run hello-world</code>等等</p>
<p>在Docker v1.12版本之前，Machine是在Mac和Window上运行Docker的唯一方法。从 Beta 版程序和 Docker v1.12 开始，Docker for Mac 和 Docker for Windows 可作为本地应用程序使用，并且是在在较新的台式机和笔记本电脑上的更好选择。我们鼓励您尝试这些新应用。 Docker for Mac 和Docker for Windows 的安装程序包括 Docker Machine，以及 Docker Compose。</p>
<h2 id="在什么情况下使用Docker-Machine"><a href="#在什么情况下使用Docker-Machine" class="headerlink" title="在什么情况下使用Docker Machine"></a>在什么情况下使用Docker Machine</h2><p>Docker Machine提供一种在各种各样的Linux主机上配置Docker的解决方案。此外Machine能够让你在老的的Mac和Windows上像上面一样运行Docker。</p>
<p>Docker有两个基本的应用场景：</p>
<ol>
<li>我有一个旧的桌面系统，并且想在Mac和Windows上运行Docker</li>
</ol>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518682583374.jpg" alt="enter description here"></p>
<p>如果你的主要工作环境是在一台旧的Mac或者Windows笔记本电脑或者台式机上，这些主机无法满足新的<code>Docker for Mac</code>和<code>Docker for Windows</code>的配置要求，那么你可以使用Docker Machine来在本地使用Docker Engine。</p>
<p>使用 Docker Toolbox 安装程序在 Mac 或 Windows box 上安装 Docker Machine 可以使用 Docker Engine 配置本地虚拟机，使您可以连接它并运行 docker 命令。</p>
<ol>
<li>我想在远程系统中配置Docker主机</li>
</ol>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518682822569.jpg" alt="enter description here"></p>
<p>Docker Engine在Linux系统上本机运行。如果有一个Linux box作为你的主系统，并且向运行<code>docker</code>命令，你需要的东西就是下载并安装Docker Engine。但是你想用一种高效的方式在网络、云端甚至本地配置多个Docker主机，你就需要Docker Machine</p>
<p>不管你的主系统是Linux、Max还是Windows，你都能够安装Docker Machine并且使用<code>docker-machine</code>去配置并管理大量的Docker主机。它会自动创建主机、安装Docker Engine并且配置docker 客户端。每个托管主机（“machine”）是 Docker 主机和配置的客户端的组合。</p>
<h2 id="Docker-Engine-和-Docker-Machine的区别"><a href="#Docker-Engine-和-Docker-Machine的区别" class="headerlink" title="Docker Engine 和 Docker Machine的区别"></a>Docker Engine 和 Docker Machine的区别</h2><p>当人们说“Docker”时，他们通常意味着 Docker Engine，即由 Docker 守护程序组成的客户端-服务器应用程序，指定用于与守护程序进行交互的接口的 REST API 以及与守护程序（通过 REST API 包装器）通信的命令行界面（CLI）客户端。<code>Docker Engine</code> 从 CLI 接受<code>docker</code>命令，例如<code>docker run &lt;image&gt;</code>，<code>docker ps</code>列出运行的容器，<code>docker images</code>以列出镜像等。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518683627228.jpg" alt="enter description here"></p>
<p>Docker Machine 是一种用于配置和管理 Docker 化的主机（Docker Engine的主机）的工具。通常，您在本地系统上安装 Docker Machine。Docker Machine 有自己的命令行客户端docker-machine和 Docker Engine 客户端docker。您可以使用 Machine 在一个或多个虚拟系统上安装 Docker Engine。这些虚拟系统可以是本地的（如当您使用 Machine 在 Mac 或 Windows 上的 VirtualBox 中安装和运行 Docker Engine）或远程（当您使用 Machine 在云提供商上配置 Docker 化主机时）。Docker 化主机本身可以被认为是有时被称为托管的“machines”。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518683773491.jpg" alt="enter description here"></p>
<h2 id="安装-Docker-Machine"><a href="#安装-Docker-Machine" class="headerlink" title="安装 Docker Machine"></a>安装 Docker Machine</h2><p>安装Docker Machine的前提是你已经安装好Docker</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -L https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-`uname <span class="_">-s</span>`-`uname -m` &gt;/usr/<span class="built_in">local</span>/bin/docker-machine &amp;&amp; \</div><div class="line"> chmod +x /usr/<span class="built_in">local</span>/bin/docker-machine</div></pre></td></tr></table></figure>
<h3 id="maxOS"><a href="#maxOS" class="headerlink" title="maxOS"></a>maxOS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> curl -L https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-`uname <span class="_">-s</span>`-`uname -m` &gt;/tmp/docker-machine &amp;&amp; \</div><div class="line">sudo install /tmp/docker-machine /usr/<span class="built_in">local</span>/bin/docker-machine</div></pre></td></tr></table></figure>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>使用GIt Bash工具安装，并且这个工具支持像<code>chmod</code>这样的Linux命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> if [[ ! -d &quot;$HOME/bin&quot; ]]; then mkdir -p &quot;$HOME/bin&quot;; fi &amp;&amp; \</div><div class="line">curl -L https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-Windows-x86_64.exe &gt; &quot;$HOME/bin/docker-machine.exe&quot; &amp;&amp; \</div><div class="line">chmod +x &quot;$HOME/bin/docker-machine.exe&quot;</div></pre></td></tr></table></figure></p>
<h2 id="普通情况使用Docker-Machine创建Machine"><a href="#普通情况使用Docker-Machine创建Machine" class="headerlink" title="普通情况使用Docker Machine创建Machine"></a>普通情况使用Docker Machine创建Machine</h2><p>假设我现在有两个主机：主机1运行Docker Machine，创建主机2为Docker 主机</p>
<h3 id="配置免交互认证登录"><a href="#配置免交互认证登录" class="headerlink" title="配置免交互认证登录"></a>配置免交互认证登录</h3><p>将主机1的公钥放入主机2的<code>~/.ssh/authorized_keys</code>文件中</p>
<p>或者使用<code>ssh-copy-id</code>完成上面的操作</p>
<h3 id="修改sudoers文件"><a href="#修改sudoers文件" class="headerlink" title="修改sudoers文件"></a>修改sudoers文件</h3><p>在主机2中的<code>/etc/sudoers</code>文件中添加<code>Defaults  visiblepw</code>一行（或者把<code>!visiblepw</code>改为<code>visiblepw</code>）</p>
<h3 id="创建一个Docker主机"><a href="#创建一个Docker主机" class="headerlink" title="创建一个Docker主机"></a>创建一个Docker主机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine create --driver generic--generic-ip-address=192.168.1.111 Ubuntu-004</div></pre></td></tr></table></figure>
<p>使用docker-machinecreate创建machine时，会检测主机是否已经安装docker，如果安装就简单做相应的检查动作即可，如果未安装，则会安装最新版的docker</p>
<h2 id="在云服务提供商平台使用Docker-Machine"><a href="#在云服务提供商平台使用Docker-Machine" class="headerlink" title="在云服务提供商平台使用Docker Machine"></a>在云服务提供商平台使用Docker Machine</h2><p>Docker Machine支持几个流行的云平台，如Digital Ocean、Amazon Web Services（AWS）、Microsoft Azure、Google Cloud Computing及其它等等，所以我们可以在不同的平台使用相同的接口来部署Docker。这里我们使用Digital Ocean驱动在Digital Ocean的服务器上部署Docker，运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker-machine create --driver digitalocean --digitalocean-access-token &lt;API-Token&gt; Linux-test</div><div class="line"></div><div class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(docker-machine env Linux-test)</span>"</span></div></pre></td></tr></table></figure>
<p><code>--driver</code>选项指定digitalocean驱动，<code>--digitalocean-access-token</code>选项指定<a href="https://cloud.digitalocean.com/settings/applications" target="_blank" rel="external">Digital Ocean Control Panel</a>提供的API Token，命令最后的是我们创建的Docker虚拟机的机器名。</p>
<p>返回的信息如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Creating CA: /root/.docker/machine/certs/ca.pem</div><div class="line">Creating client certificate: /root/.docker/machine/certs/cert.pem</div><div class="line">Running pre-create checks...</div><div class="line">Creating machine...</div><div class="line">(Linux-test) Creating SSH key...</div><div class="line">(Linux-test) Creating Digital Ocean droplet...</div><div class="line">(Linux-test) Waiting <span class="keyword">for</span> IP address to be assigned to the Droplet...</div><div class="line">Waiting <span class="keyword">for</span> machine to be running, this may take a few minutes...</div><div class="line">Detecting operating system of created instance...</div><div class="line">Waiting <span class="keyword">for</span> SSH to be available...</div><div class="line">Detecting the provisioner...</div><div class="line">Provisioning with ubuntu(systemd)...</div><div class="line">Installing Docker...</div><div class="line">Copying certs to the <span class="built_in">local</span> machine directory...</div><div class="line">Copying certs to the remote machine...</div><div class="line">Setting Docker configuration on the remote daemon...</div><div class="line">Checking connection to Docker...</div><div class="line">Docker is up and running!</div><div class="line">To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env Linux-test</div></pre></td></tr></table></figure></p>
<p>运行如上命令后，我们可以在Digital Ocean Droplet Panel中看到一个新的具有默认配置的droplet已经被创建出来了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518684941619.jpg" alt="enter description here"></p>
<p>简便起见，docker-machine会使用默认配置来部署Droplet。我们可以通过增加选项来定制我们的Droplet。这里是一些digitalocean相关的选项，我们可以使用它们来覆盖Docker Machine所使用的默认配置。</p>
<ul>
<li>–digitalocean-image “ubuntu-14-04-x64” 用于选择Droplet的镜像</li>
<li>–digitalocean-ipv6 enable 启用IPv6网络支持</li>
<li>–digitalocean-private-networking enable 启用专用网络</li>
<li>–digitalocean-region “nyc3” 选择部署Droplet的区域</li>
<li>–digitalocean-size “512mb” 选择内存大小和部署的类型</li>
</ul>
<p>如果你想在其他云服务使用docker-machine，并且想覆盖默认的配置，可以运行如下命令来获取Docker Mackine默认支持的对每种平台适用的参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine create -h</div></pre></td></tr></table></figure></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="查看主机"><a href="#查看主机" class="headerlink" title="查看主机"></a>查看主机</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine ls</div></pre></td></tr></table></figure>
<p>ACTIVE一列有“*”标记的是活跃主机，同时可以用<code>docker-machine active</code>命令来标记其他的主机为活跃主机</p>
<h3 id="使用Docker容器"><a href="#使用Docker容器" class="headerlink" title="使用Docker容器"></a>使用Docker容器</h3><p>创建主机成功后，可以通过 env 命令来让后续操作对象都是目标主机。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker-machine env <span class="built_in">test</span></div></pre></td></tr></table></figure></p>
<p>后续根据提示在命令行输入命令之后就可以操作 test 主机。</p>
<p>也可以通过 SSH 登录到主机：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh <span class="built_in">test</span></div><div class="line"></div><div class="line">docker@<span class="built_in">test</span>:~$ docker --version</div><div class="line">Docker version 17.10.0-ce, build f4ffd25</div></pre></td></tr></table></figure></p>
<p>连接到主机之后你就可以在其上使用 Docker 了。</p>
<h3 id="删除主机"><a href="#删除主机" class="headerlink" title="删除主机"></a>删除主机</h3><p>删除在运行的主机以及它的所有镜像和容器，我们可以使用<code>docker-machine rm</code>命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine rm linux-dev</div></pre></td></tr></table></figure></p>
<p>运行完以后，本地和与远端的都将删除，在云平台上的实例也会被删除</p>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><ul>
<li>active 查看活跃的 Docker 主机</li>
<li>config 输出连接的配置信息</li>
<li>create 创建一个 Docker 主机</li>
<li>env 显示连接到某个主机需要的环境变量</li>
<li>inspect 输出主机更多信息</li>
<li>ip 获取主机地址</li>
<li>kill 停止某个主机</li>
<li>ls 列出所有管理的主机</li>
<li>provision 重新设置一个已存在的主机</li>
<li>regenerate-certs 为某个主机重新生成 TLS 认证信息</li>
<li>restart 重启主机</li>
<li>rm 删除某台主机</li>
<li>ssh SSH 到主机上执行命令</li>
<li>scp 在主机之间复制文件</li>
<li>mount 挂载主机目录到本地</li>
<li>start 启动一个主机</li>
<li>status 查看主机状态</li>
<li>stop 停止一个主机</li>
<li>upgrade 更新主机 Docker 版本为最新</li>
<li>url 获取主机的 URL</li>
<li>version 输出 docker-machine 版本信息</li>
<li>help 输出帮助信息</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 继续探索&lt;/p&gt;
    
    </summary>
    
      <category term="运维" scheme="https://www.liuin.cn/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Docker" scheme="https://www.liuin.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》笔记 C++基础部分</title>
    <link href="https://www.liuin.cn/2018/02/15/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-C-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/"/>
    <id>https://www.liuin.cn/2018/02/15/《C-Primer》笔记-C-基础部分/</id>
    <published>2018-02-15T13:15:06.000Z</published>
    <updated>2018-02-23T04:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》笔记 C++基础部分</p>
<a id="more"></a>
<h1 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h1><h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><h3 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h3><p>类型char和类型signed char并不一样。尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。</p>
<p>当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）</p>
<p>与一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。把int转换成无符号数的过程和把int直接赋给无符号数—样。</p>
<h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517231165506.jpg" alt="enter description here"></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>初始化不是赋值，初始化的含义是创建一个变量的时候赋予其一个初始值，而赋值的含义是把对象的当前值删除，而以一个新值来代替</p>
<p>默认初始化：如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将不被初始化(uninitialized)。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。</p>
<p>使用未初始化的值将带来无法预计的后果</p>
<h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>变量能且只能被定义一次，但可以被声明多次</p>
<h3 id="标识符（identifier）"><a href="#标识符（identifier）" class="headerlink" title="标识符（identifier）"></a>标识符（identifier）</h3><h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>建议：当你第一次使用变量的时候再定义它</p>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用（reference）为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。</p>
<p>一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定（bind)在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此<strong>引用必须初始化</strong>。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517232990644.jpg" alt="enter description here"></p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针必须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，将拥有一个不确定的值。</p>
<p>指针的他（即地址）应属下列4种状态之一:</p>
<ol>
<li>指向一个对象。</li>
<li>指叫紧邻对象所占空间的下一个位置。</li>
<li>空指针，意味着指针没有指向任何对象。</li>
<li>无效指针，也就是上述情况之外的其他值。</li>
</ol>
<p>访问无效指针和空指针或者未知指针的后果无法预计</p>
<p><code>void*</code>指针时一种特殊的指针类型，可用于存放任意对象的地址。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象做哪些操作。</p>
<h3 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h3><p>引用本身不是对象，因此不能定义指向引用的指针。但是指针是对象，所以存在对指针的引用。</p>
<h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p>const对象被设定为仅在文件内有效</p>
<p>对const的引用可能引用一个并非const的对象：常量引用仅对引用可参与的操作做出了限定，对于引用对象本身是不是一个常量未作限定。</p>
<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p>用名词<strong>顶层const</strong>(top-levelconst)表示指针本身是个常量，而用名词<strong>底层const</strong>(low-levelconst)表示指针所指的对象是一个常量。</p>
<h3 id="constexpr-和常量表达式"><a href="#constexpr-和常量表达式" class="headerlink" title="constexpr 和常量表达式"></a>constexpr 和常量表达式</h3><p>常量表达式（constexpression)是指值不会改变而且在编译过程就能得到汁算结果的表达式。当然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。</p>
<p>C++11标准规定，允许将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量表达式。</p>
<h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h3><p>编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，C++11新标准引入了auto类型说明符，用它就能让编译器帮我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如double)不同，auto让编译器通始值来推算变量的类型。显然，auto定义的变量必须有初始值：</p>
<p>auto一般会忽略顶层const，同时底层const则会保留下来</p>
<h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h3><p>有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变蛩。为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数椐类型。在此过程中，编译器分忻表达式并得到它的类型，却不实际汁算表达式的值:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">decltype</span>(f()) sum = x;   <span class="comment">// sum的类型就是函数f的返回类型</span></div></pre></td></tr></table></figure>
<p>decltype 处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）</p>
<hr>
<h1 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a>字符串、向量和数组</h1><h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p>如果提供一个字符串字面值，则该字面值中除了最后那个空字符外其他所有字符都被拷贝新建的string对象中。</p>
<blockquote>
<p>直接初始化和拷贝初始化</p>
</blockquote>
<p>如果使用等号（=）初始化一个变量，实际上执行的是<strong>拷贝初始化</strong>（copy initialization），编译器将等号右侧的初始值拷贝到新创建的对象中去。<br>与之相反，不使用等号，则执行的是<strong>直接初始化</strong>（direct initialization）</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517572296753.jpg" alt="enter description here"></p>
<blockquote>
<p>string:size_type 类型</p>
</blockquote>
<p>string类及其他大多数标准库类型都定义了几种配套的类型。这些配套体现了标准库类型与机器无关的特性，类型size_type即是其中的一种。在具体使用的时候，通过作用域操作符表明名字size_type是在类string中定义的。</p>
<blockquote>
<p>字面值和string对象相加</p>
</blockquote>
<p>当把string对象和字符字面值以及字符串字面值混在一条语句中使用的时候，必须保证每个加法运算符的两侧至少有一个是string对象</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517572788565.jpg" alt="enter description here"></p>
<h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p>如果循环体内部包含有向 vector对象添加元元素的语句,则不能使用范 围for循环</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517659028911.jpg" alt="enter description here"></p>
<p>不能用下标形式添加元素：vector对象(以及 string对象)的下标运算符可用于访问已存在的元素, 而不能用于添加元素。</p>
<h2 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h2><p>所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符</p>
<p>类似于指针类型,迭代器也<strong>提供了对对象的间接访问</strong>。就迭代器而言,其对对象是容器中的元素或者者 string对象中的字符。使用迭代器可以访问某 个元素,迭代器也能从一个元素移动到另外一个元素。迭代器有有效和无效之分,这一点 和指针差不多。<strong>有效的迭代器或者指向某个元素,或者指向容器中尾元素的下一位置</strong>，其他所有情况都属于无效。</p>
<h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>end成员负责返回指向容器(或 string对象)“尾元素的下一位置( one past the end) 的迭代器,也就是说,该迭代器指示的是容器的一个本不存在的“尾后( off the end)”元 素。这样的迭代器没什么实际含义,仅是个标记而已,表示我们已经处理完了容器中的所 有元素。end成员返回的迭代器常被称作尾后迭代器( off-the- end iterator)或者简称为尾 迭代器( end iterator)。特殊情况下如果容器为空,则beg1n和end返回的是同一个迭 代器。（都是尾后迭代器）</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517659661001.jpg" alt="enter description here"></p>
<p>迭代器运算符</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517659702856.jpg" alt="enter description here"></p>
<blockquote>
<p>迭代器类型</p>
</blockquote>
<p>就像不知道 string和 vector的 size type成员员到底是什么类型一样,一般来说我们也不知道(其实是无须知道)迭代器的精确类型。而实际上, 那些拥有迭代器的标准库类型使用 iterator和 const iterator来表示迭代器的类型</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517659938792.jpg" alt="enter description here"></p>
<blockquote>
<p>某些对vector对象的操作会使迭代器失效</p>
</blockquote>
<p>不能在for循环范围内向vector对象添加元素；任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效</p>
<h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><p>迭代器的递增运算令迭代器每次移动一个元素,所有的标准库容器都有支持递增运算 的迭代器。类似的,也能用=和!=对任意标准库类型的两个有效迭代器进行比较</p>
<p>vector和string迭代器支持更多的迭代器运算</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517660460874.jpg" alt="enter description here"></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>不允许拷贝和赋值</p>
</blockquote>
<p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值</p>
<blockquote>
<p>理解复杂的数组声明</p>
</blockquote>
<p>类型修饰符从右向左依次绑定，就数组而言，由内向外阅读比从右向左好很多</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517660778235.jpg" alt="enter description here"></p>
<blockquote>
<p>访问数组元素</p>
</blockquote>
<p>在使用数组下标的时候,通常将其定义为size_t类型。size_t是一种机器相关的 无符号类型,它被设计得足够大以便能表示内存中任意对象的大小。</p>
<blockquote>
<p>标准库函数</p>
</blockquote>
<p>尽管能计算得到尾后指针,但这种用法极易出错。为了让指针的使用更简单、更安全, C++11新标准引引入了两个名为 begin和end的函数。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517661137672.jpg" alt="enter description here"></p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>严格来说，C++语言中没有多维数组，通常所说的的多维数组其实是数组的数组。</p>
<hr>
<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p>重载运算符</p>
</blockquote>
<p>C++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时,用户可以自行定义其含义义。因为这种自定义的过程事实 上是为已存在的运算符赋予了另外一层含义,所以称之为<strong>重載运算符</strong>( overloaded operator)。</p>
<blockquote>
<p>左值和右值</p>
</blockquote>
<p>C++的表达式要不然是右值( rvalue,读作“are- value”),要不然就是左值( lvalue, 读作“ ell-value”)。这两个名词是从C语言继承过来的,原本是为了帮助记忆:左值可以 位于赋值语句的左侧,右值则不能。</p>
<p>在C++语言中,二者的区别就没那么简单了。一个左值表达式的求值结果是一个对象 或者一个函数,然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对 象。此外,虽然某些表达式的求值结果是对象,但它们是右值而非左值。可以做一个简单 的归纳:<strong>当一个对象被用作右值的时候,用的是对象的值(内容);当对象被用作左值的 时候,用用的是对象的身份(在内存中的位置)。</strong> </p>
<p>不同的运算符对运算对象的要求各不相同,有的需要左值运算对象、有的需要右值运 算对象:返回值也有差异,有的得到左值结果、有的得到右值结果。一个重要的原则是：<strong>在需要右值的地方可以用左值来代替,但 是不能把右值当成左值(也就是位置)使用</strong>。 当一个左值被当成右值使用时,实际使用的 是它的内容(值)。</p>
<h3 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h3><p>对于那些没有指定执行顺序的运算符来说,如果表达式指向并修改了同一个对象,将会引发错误并产生<strong>未定义的行为</strong>。</p>
<p>举个简单的例子,&lt;&lt;运算符 没有明确规定何时以及如何对运算对象求值,因此下面的输出表达式是末定义的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"+"</span> &lt;&lt; ++i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 未定义的</span></div></pre></td></tr></table></figure></p>
<p>C++语言没有明确规定大多数二元运算符的求值顺序,给编译器优化留下了 余地。这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡.</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517751109803.jpg" alt="enter description here"></p>
<p>算术运算符能作用域任何算术类型以及任意能转化为算术类型的类型。</p>
<p>算术表达式有可能产生未定义的结果。一部分原因是数学性质本身:例如除数是0 的情况;另外一部分则源于计算机的特点:例如溢出,当计算的结果超出该类型所能表 示的范围时就会产生溢出。</p>
<blockquote>
<p>除法和取模运算</p>
</blockquote>
<p>在除法运算中,如果两个运算对象的符号相同则商为正(如果不为0的话),否则商 为负。C++语言的早期版本允许结果为负值的商向上或向下取整,C++11新标准则规定商 律向0取整(即直接切除小数部分) </p>
<p>根据取余运算的定义,如果m和n是整数且n非0,则表达式(m/n)*n+m%n的求值 结果与m相等。隐含的意思是,如果m%n不等于0,则它的符号和m相同。C++语言的早 期版本允许m%n的符号匹配n的符号,而且商向负无穷一侧取整,这一方式在新标准中 已经被禁止使用了。除了-m导致溢出的特殊情况,其他时候(-m)/n和m/(-n)都等于 (m/n),m%(-n)等于m%n,(-m)%n等于-(m%n)。</p>
<p>具体示例如下:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517751057230.jpg" alt="enter description here"></p>
<h2 id="逻辑运算符和关系运算符"><a href="#逻辑运算符和关系运算符" class="headerlink" title="逻辑运算符和关系运算符"></a>逻辑运算符和关系运算符</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517751134864.jpg" alt="enter description here"></p>
<p>逻辑与运算符和逻辑或运算符都是先求左側运算对象的值再求右侧运算对象的值,当 且仅当左側运算对象无法确定表达式的结果时オ会计算右侧运算对象的值。这种种策略称为 短路求值( short- circuit evaluation)。</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符的左侧运算对象必须是一个可修改的左值</p>
<h2 id="递增运算符和递减运算符"><a href="#递增运算符和递减运算符" class="headerlink" title="递增运算符和递减运算符"></a>递增运算符和递减运算符</h2><p>递增和递减运算符有两种形式:前置版本和后置版本。前置递增运算符首先将运算对象加1(或减1),然后将改变后的对象作为求 值结果。后置版本也会将运算对象加1(或减1),但是求值结果是运算对象改变之前那个 值的副本</p>
<p>建议:除非必须,否则不用递增递减运算符的后置版本：<br>有C语言背景的读者可能对优先使用前置版本递增运算符有所疑间问,其实原因非常 简单:前置版本的递增运算符避免了不必要的工作,它把值加1后直接返回改变了的运 算对象。与之相比,后置版本需要将原始值存储下来以便于返回这个未修改的内容。如 果我们不需要修改前的值,那么后置版本的操作就是一种浪费。</p>
<h2 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h2><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律,其所得得的值是一个size_t类型</p>
<p>运算符的运算对象有两种形式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">sizeof</span>(type)</div><div class="line"><span class="keyword">sizeof</span> expr</div></pre></td></tr></table></figure></p>
<p>在第二种形式中，sizeof返回的是表达式结果类型的大小。与众不同的一点是，sizeof并不实际计算其运算对象的值：</p>
<p>因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中的元素个数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(ia)/<span class="keyword">sizeof</span>(*ia);</div><div class="line"><span class="keyword">int</span> arr2[sz]; <span class="comment">// ok sizeof returns a constant expression</span></div></pre></td></tr></table></figure></p>
<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p>逗号运算符( comma operator)含有两个运算对象,按照从左向右的顺序依次求值 和逻辑与、逻辑或以及条件运算符一样,逗号运算符也规定了运算对象求值的顺序。 对于逗号运算符来说,首先对左侧的表达式求值,然后将求值结果丢弃掉。逗号运算符真正的结果是右側表达式的值。如果右侧运算对象是左值,那么最终的求值结果也是左值。</p>
<h2 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="其他隐式类型转换"><a href="#其他隐式类型转换" class="headerlink" title="其他隐式类型转换"></a>其他隐式类型转换</h3><p>数组转换为指针：在大多数用到数组的表达式中，数组自动转换为指向数组首元素的指针</p>
<p>指针的转换:C++还规定了几种其他的指针转换方式,包括常量整数值0或者者字面值 nu11ptr能转换成任意指针类型:指向任意非常量的指针能转换成void<em>;指向任意对 象的指针能转换成 const void</em>。</p>
<p>转换为布尔类型：存在一种从算术类型或指针类型向布尔类型自动转换的机制</p>
<p>转换为常量：允许将指向非常量类型的指针转换成为相应常量类型的指针，对于引用也是这样。</p>
<h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p>待整理</p>
<h2 id="运算符优先级表"><a href="#运算符优先级表" class="headerlink" title="运算符优先级表"></a>运算符优先级表</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517752932745.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517752958321.jpg" alt="enter description here"></p>
<hr>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><blockquote>
<p>悬垂else</p>
</blockquote>
<p>当一个if语句嵌套在另一个if语句内部时,很可能if分支会多于else分支。事实上,之前那个成绩转换的程序就有4个if分支,而只有2个else分支。这时候问题 出现了:我们怎么知道某个给定的else是和和哪个if匹配呢? 这个问题通常称作<strong>悬垂else</strong>( dangling else),在那些既有if语句又有if else语句的编程语言中是个普遍存在的问题。不同语言解决该问题的思路也不同,就就C++而言, 它规定else与离它最近的尚未匹配的if匹配,从而消除了程序的的二义性。</p>
<blockquote>
<p>case标签</p>
</blockquote>
<p>case关键字和它对应的值一起被称为case标签( case label)。case标签签必须是整 型常量表达式</p>
<blockquote>
<p>switch内部的变量定义</p>
</blockquote>
<p>如前所述, switch的执行流程有可能会跨过某些case标标签。如果程序跳转到了某个特定的case,则switch结构中该该case标签之前的部分会被忽略掉。这种忽略掉一 部分代码的行为引出了一个有趣的问题:如果被略过的代码中含有变量的定义该怎么办? 答案是:<strong>如果在某处一个带有初值的变量位于作用域之外,在另一处该变量位于作用域之内,则从前一处跳转到后一处的行为是非法行为。</strong></p>
<h2 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h2><h3 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h3><p>C++11新标准引入了一种更简单的for语句,这种语句可以遍历容器或其他序列的 所有元素。范围for语句( range for statement）的语法形式是: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (declaration expression) </div><div class="line">statement</div></pre></td></tr></table></figure>
<p>expression表示的必须是一个序列,比如用花括号括起来的初始值列表、数组或者 vector或string等类型的对象,这些类型的共同特点是拥有能返回迭代器的 begin和end成员。 </p>
<p>declaration定义一个变量,序列中的每个元素都得能转换成该变量的类型。确保类型相容最简单的办法是使用auto类型说明符,这个关键字可以令编译器帮助我们指定合适的类型。</p>
<p>如果需要对序列中的元素执行写操作,循环变量必须声明成引用类型 每次迭代都会重新定义循环控制变量,并将其初始化成序列中的下一个值,之后オ会 执行 statement。像往常一样, statement可以是一条单独的语句也可以是一个块。所有元素 都处理完毕后循环终止。</p>
<h2 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h2><p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。当程序的某部分检测到一个他无法处理的问题的时候，需要用到异常处理。</p>
<p>异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持。在C++语言 中,异常处理包括 </p>
<ul>
<li>throw表达式( throw expression),异常检测部分使用 throw表达式来表示它遇到 了无法处理的问题。我们说 throw引发( raise)了异常。 </li>
<li>ty语句块( try block),异常处理部分使用try语句块处理异常。try语句块以 关键字try开始,并以一个或多个 catch子句( catch clause)结束。try语句块 中代码抛出的异常通常会被某个 catch子句处理。因为 catch子句“处理”异常, 所以它们也被称作异常处理代码( exception handler)。 </li>
<li>套异常类( exception class),用于在 throw表达式和相关的 catch子句之间传 递异常的具体信息。</li>
</ul>
<h3 id="标注异常"><a href="#标注异常" class="headerlink" title="标注异常"></a>标注异常</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_7_1518014704271.jpg" alt="enter description here"></p>
<hr>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>我们通过<strong>调用运算符</strong>( call operator)来执行函数。调用运算符的形式是一对圆括물 它作用于一个表达式,该表达式是函数或者指向函数的指针:圆括号之内是一个用逗号隔 开的实参( argument)列列表,我们用实参初始化函数的形参。调调用表达式的类型就是函数 的返回类型。</p>
<p>函数的调用完成两项工作:一是用实参初始化函数对应的形参,二是将控制权转移给被调 用函数。此时,主调调函数( calling function)的执行被暂时中断,被调函数( called function) 开始执行。</p>
<blockquote>
<p>形参和实参</p>
</blockquote>
<p>实参是形参的初始值。尽管实参和形参存在对应关系，但是并没有规定实参的求值顺序。编译器能以任意可行的顺序对实参求值。</p>
<h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><p>名字有作用域，对象有生命周期（lifetime）：名字的作用域是程序文本的一部分，名字在其中可见；对象的生命周期是程序执行过程中该对象存在的一段时间。</p>
<p>如果局部静态变量没有显式的初始值，它将执行初始化：内置类型的局部静态变量初始化为0</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数的声明不包含函数体，所以也不需要形参的名字，但是加上名字能够让使用者更好地理解函数的功能。</p>
<h3 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h3><p>分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译</p>
<p>编译以后，如果我们修改了其中一个源文件，那么只需要重新编译那个改动的文件即可</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>当形参是引用类型时,我们说它对应的实参被<strong>引用传递</strong>( Dassed by reference )或者函 数被传引用週用( called by reference)。和其他引用一样,引用形参也是它绑定的对象的别 名;也就是说,引用形参是它对应的实参的别名。 </p>
<p>当实参的值被拷贝给形参时,形参和实参是两个相互独立的对象。我们们说这样的实参 被<strong>值传递</strong>( passed by value)或者者函数被传值调用( called by value)</p>
<blockquote>
<p>使用引用避免拷贝</p>
</blockquote>
<p>拷贝大的类类型对象或者容器对象比较低效,甚至有的类类型(包括括1O类型在内) 根本就不支持拷贝操作。当某种类型不支持拷贝操作时,函数只能通过引用形参访问该类 型的对象。</p>
<p>如果函数无需改变引用形参的值，最好将其声明为常量引用</p>
<h3 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h3><p><strong>当形参时const时，其为顶层const，顶层const作用于对象本身。</strong></p>
<p>和其他初始化过程一样,当用实参初始化形参时会忽略掉顶层 const。换句话说,形参的顶层 const被忽略掉了。当形参有顶层 const时,传给它常量对象或者非常量对象都是 可以的:</p>
<h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p>数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响,这两个性质分别 是:<strong>不允许拷贝数组</strong>以及<strong>使用数组时(通常)会将其转换成 指针</strong>。因为不能拷贝数组,所以我们<strong>无法以值传递的方式使用 数组参数</strong>。因为数组会被转换成指针,所以当我们为函数传递一个数组时,实际上传递的 是指向数组首元素的指针。</p>
<p>为了程序的可读性，我们可以把形参写成类似数组的形式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">( <span class="keyword">const</span> *<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">( <span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">( <span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;  <span class="comment">// 这里的维度表示我们期望有多少元素，实际不一定</span></div></pre></td></tr></table></figure></p>
<p>管理指针形参的三种常用技术：</p>
<ul>
<li>使用标记指定数组长度，要求数组本身包含一个结束标记</li>
<li>使用标准库规范，传递指向数组首元素和数组尾元素的指针</li>
<li>显式传递一个表示数组大小的形参</li>
</ul>
<blockquote>
<p>传递多维数组</p>
</blockquote>
<p>和所有数组一样,当将多维数组传递给函数时,真正传递的是指向数组首元素的指针 。因为我们处理的是数组的数组,所以首元素本身就是一个数组, 指针就是一个指向数组的指针。<strong>数组第二维(以及后面所有维度)的大小都是数组类型的 部分,不能省略</strong>:</p>
<h3 id="含有可变形参的参数"><a href="#含有可变形参的参数" class="headerlink" title="含有可变形参的参数"></a>含有可变形参的参数</h3><p>为了编写能处理不同数量实参的函数,C++11新标准提供了两种主要的方法:如如果所 有的实参类型相同,可以传递一个名为initializer_list的标准库类型:如果实参的 类型不同,我们可以编写一种特殊的函数,也就是所谓的可变参数模板,</p>
<blockquote>
<p>initializer_list 形参</p>
</blockquote>
<p>如果函数的实参数量未知但是全部实参的类型都相同,我们可以使用initializer_listt类型的形参。initializer_list是一种标准库类型,用于表示 某种特定类型的值的数组</p>
<blockquote>
<p>省略符形参</p>
</blockquote>
<p>省略符形参是为了便于C++程序访访问某些特殊的C代码而设置的,这些们代码使用了名 为 varargs的C标准库功能。</p>
<p>省略符形参只能出现在形参列表的最后一个位置,它的形式无外乎以下两种: </p>
<ul>
<li>void foo(parm list, …);</li>
<li>void foo(…)</li>
</ul>
<p>第一种形式指定了foo函数的部分形参的类型,对应于这些形参的实参将会执行正常的 类型检査。省略符形参所对应的实参无须类型检査。在第一种形式中,形参声明后面的逗 号是可选的。</p>
<h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h2><blockquote>
<p>不要返回局部对象的引用或指针</p>
</blockquote>
<p>函数完成后,它所占用的存储空间也随之被释放掉。因此, 函数终止意味着局部变量的引用将指向不再有效的内存区域。会引发未定义行为</p>
<blockquote>
<p>引用返回左值</p>
</blockquote>
<p>调用一个返回引用的函数返回左值，返回其他类型得到右值</p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>不允许两个函数除了返回类型外其他所有的要素都相同</p>
<p>一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来</p>
<blockquote>
<p>调用重载函数</p>
</blockquote>
<p>定义了一组重载函数后,我们需要以合理的实参调用它们。<strong>函数匹配</strong>( functionmatching)是指一个过程,在这个过程中我们把函数调用与一组重载函数中的某一个关联起来,函数匹配也叫做<strong>重载确定</strong>( overload resolution)。编编译器首先将调用的实参与重载集合中每一个函数的形参进行比较,然后根据比较的结果决定到底调用哪个函数。</p>
<h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><p>某些函数有这样一种形参,在函数的很多次调用中它们都被赋予一个相同的值,此时,我们把这个反复出现的值称为函数的<strong>默认实参</strong>( default argument)。调调用含有默认实参的函数时,可以包含该实参,也可以省略该实参。</p>
<p>一旦某个形参被赋予了默认值，后面所有的额形参都要赋予默认值。所以当设计含有默认实参的函数时,其中一项任务是合理设置形参的顺序,尽量让不怎么使用默认值的形参出现在前面,而让那些经常使用默认值的形参出现在后面</p>
<p>在给定的作用域中一个形参只能被赋予一次默认实参。换句句话说,函数的后续声明只能为之前那些没有默认值的形参添加默认实参,而且该形参右侧的所有形参必须都有默认值。</p>
<p>局部变量不能作为默认实参。除此之外,只要表达式的类型能转换成形参所需的类型,该表达式就能作为默认实参:</p>
<h3 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h3><p>在大多数机器上,一次次函数调用其实包含着一系列工作:调用前要先保存寄存器,并在返回时恢复;可能需要拷贝实参;程序转向一个新的位置继续执行。</p>
<h4 id="内联函数可以避免函数调用的开销"><a href="#内联函数可以避免函数调用的开销" class="headerlink" title="内联函数可以避免函数调用的开销"></a>内联函数可以避免函数调用的开销</h4><p>将函数定义为内联函数（inline），通常就是把它在每一个调用点上“内联地”展开。函数返回类型前面加上关键字inline，这样就可以将它声明为内联函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="built_in">string</span> &amp; <span class="title">shortString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> s1.size() &lt;= s2.size() ? s1 : s2;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>一般来说,内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数,而而且一个75行的函数也不大可能在调用点内联地展开。</p>
<h4 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h4><p>constexpr函数( constexpr function)是指能用于常量表达式的函数。定义 constexpr函数的方法与其他函数类似,不过要遵循几项约定:函数的返回类型及所有形参的类型都得是字面值类型,而且函数体中必须有且只有一条 return语句:</p>
<p>把內联函数和 constexpr函数放在头文件内和其他函数不一样,内联函数和 constexpr函数可以在程序中多次定义。毕竟,编译器要想展开函数仅有函数声明是不够的,还需要函数的定义。不过,对于某个给定的内联函数或者 constexpr函数来说,它的多个定义必须完全一致。基于这个原因,内联函数和 constexpr函数通常定义在头文件中。</p>
<h3 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h3><p>程序可以包含一些用于调试的代码,但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时,要先屏蔽掉调试代码。这种方法用到两项预处理功能: assert和 NDEBUG</p>
<h4 id="assert-预处理宏"><a href="#assert-预处理宏" class="headerlink" title="assert 预处理宏"></a>assert 预处理宏</h4><p>assert是一种<strong>预处理宏</strong>( preprocessor marco)。所谓预处理宏其实是一个预处理变量,它的行为有点类似于内联函数。 assert宏使用一个表达式作为它的条件:<code>assert(expr)</code> </p>
<p>首先对expr求值,如如果表达式为假(即0), assert输出信息并终止程序的执行。如果表达式为真(即非0), assert什么也不做。</p>
<p>assert宏定义在 assert头文件中。如我们所知,预处理名字由预处理器而非编译器管理,因此我们可以直接使用预处理名字而无须提供uS1ng明。也就是说,我们应该使用 assert而不是std:: assert,也不需要为 assert提供using声明。</p>
<h4 id="NDEBUG-预处理变量"><a href="#NDEBUG-预处理变量" class="headerlink" title="NDEBUG 预处理变量"></a>NDEBUG 预处理变量</h4><p>assert的行为依赖于一个名为 NDEBUG的预处理变量的状态。如果定义了 NDEBUG,则 assert什么也不做。默认状态下没有定义 NDEBUG,此时 assert将执行运行时检查。我们可以使用一个# define语句定义 NDEBUG,从而关闭调试状态。同时,很多编译器都提供了一个命令行选项使我们可以定义预处理变量</p>
<h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><h3 id="确定候选函数和可行函数"><a href="#确定候选函数和可行函数" class="headerlink" title="确定候选函数和可行函数"></a>确定候选函数和可行函数</h3><p>函数匹配的第一步是选定本次调用对应的重载函数集,集合中的函数称为<strong>候选函数</strong>( candidate function)。候选函数具备两个特征:一是与被调用的函数同名,二是其声明在调用点可见。</p>
<p>第二步考察本次调用提供的实参,然后从候选函数中选出能被这组实参调用的函数,这些新选出的函数称为<strong>可行函数数</strong>( viable function)。可行函数也有两个特征:一是其形参数量与本次调用提供的实参数量相等,二是每个实参的类型与对应的形参类型相同,或者能转换成形参的类型。</p>
<blockquote>
<p>寻找最佳匹配</p>
</blockquote>
<p>函数匹配的第三步是从可行函数中选择与本次调用最匹配的函数。实参类型与形参类型越接近，他们匹配得越好。</p>
<blockquote>
<p>含有多个形参的函数匹配</p>
</blockquote>
<p>当实参的数量有两个或更多时,函数匹配就比较复杂了。编译器依次检査每个实参以确定哪个函数是最佳匹配。如如果有且只有个函数满足下列条件,则匹配成功・该该函数每个实参的匹配都不劣于其他可行函数需要的匹配至少有一个实参的匹配优于其他可行函数提供的匹配。如果在检査了所有实参之后没有任何一个函数脱颖而出,则则该调用是错误的。</p>
<h3 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h3><p>为了确定最佳匹配,编译器将实参类型到形参类型的转換划分成儿个等级,具体排序如</p>
<ol>
<li>精确匹配,包括以下情况:实参类型和形参类型相同・实参从数组类型或函数类型转换成对应的指针类型。向实参添加顶层 const或者从实参中删除顶层 const</li>
<li>通过 const转换实现的匹配</li>
<li>通过过类型提升实现的匹配</li>
<li>通过算术类型转换或指针转换实现的匹配。</li>
<li>通过类类型转换实现的匹配配(参见14.9节</li>
</ol>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向的是函数而非对象。和其他指针一样,函数指针指向某种特定类型，函数的类型由它的返回类型和形参类型共同决定,与函数名无关。</p>
<p>想要声明一个可以指向该函数的指针，只需要用指针替换函数名即可</p>
<p>当我们把函数名作为一个值使用时，该函数自动地转换成指针。</p>
<p>此外,我们们还能直接使用指向函数的指针调用该函数,无须提前解引用指针</p>
<blockquote>
<p>函数指针形参</p>
</blockquote>
<p>和数组类似,虽然不能定义函数类型的形参,但是形参可以是指向函数的指针。此时,形参看起来是函数类型,实际上却是当成指针使用:</p>
<blockquote>
<p>返回指向函数的指针</p>
</blockquote>
<p>和数组类似,虽然不能返回一个函数,但是能返回指向函数类型的指针。然而,我们们必须把返回类型写成指针形式,编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样,要想声明一个返回函数指针的函数,最简单的办法是使用类型别名</p>
<hr>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类的基本思想是<strong>数据抽象</strong>( data abstraction)和<strong>封装</strong>( encapsulation)。<strong>数据抽象是二种依赖于接口( interface)和实现( implementation)分离的编程程(以及设计)技术。</strong>类的接口包括用户所能执行的操作;类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。</p>
<p><strong>封装实现了类的接口和实现的分离</strong>。封装后的类隐藏了它的实现细节,也就是说,类的用户只能使用接口而无法访问实现部分。</p>
<h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><h3 id="定义类的基本"><a href="#定义类的基本" class="headerlink" title="定义类的基本"></a>定义类的基本</h3><h4 id="引入-this"><a href="#引入-this" class="headerlink" title="引入 this"></a>引入 this</h4><p>成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时,用请求该函数的对象地址初始化this</p>
<p>对于我们来说,this形参是隐式定义的。实际上,任何自定义名为this的参数或变量的行为都是非法的。我们们可以在成员函数体内部使用this因此尽管没有必要,但我们还是能把isbn定义成如下的形式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; &#125;</div></pre></td></tr></table></figure>
<h4 id="引入const-成员函数"><a href="#引入const-成员函数" class="headerlink" title="引入const 成员函数"></a>引入const 成员函数</h4><p>上面的ibsn函数的另一个关键之处是紧随参数列表之后的 const关键字,这里, const的作用是修改隐式this指针的类型。</p>
<p>默认情况下,<strong>this的类型是指向类类型非常量版本的常量指针</strong>。尽管this是隐式的,但它仍然需要遵循初始化规则,意味着(在默认情况下)我们不能把this绑定到一个常量对象上。</p>
<p>C++语言的做法是允许<strong>把 const关键字放在成员函数的参数列表之后</strong>,此时,紧跟在参数列表后面的 const表示this是一个指向常量的指针。像这样使用 const的成员函数被称作<strong>常量成员函数</strong>( const member function)。</p>
<h4 id="类作用域和成员函数"><a href="#类作用域和成员函数" class="headerlink" title="类作用域和成员函数"></a>类作用域和成员函数</h4><p>编译器分两步处理类:首先编译成员的声明,然后才轮到成员函数体(如果有的话)。因此,成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p>
<h4 id="在类外部定义成员函数"><a href="#在类外部定义成员函数" class="headerlink" title="在类外部定义成员函数"></a>在类外部定义成员函数</h4><p>当我们在类的外部定义成员函数时,成员函数的定义必须与它的声明匹配。也就是说,返回类型、参数列表和函数名都得与类内部的声明保持一致。如果<strong>成员被声明成常量成员函数,那么它的定义也必须在参数列表后明确指定 const属性</strong>。同时,类外部定义的成员的名字必须包含它所属的类名</p>
<h4 id="定义一个返回this对象的函数"><a href="#定义一个返回this对象的函数" class="headerlink" title="定义一个返回this对象的函数"></a>定义一个返回this对象的函数</h4><p>一般来说,当我们定义的函数类似于某个内置运算符时,应该令该函数的行为尽量模仿这个运算符。内置的赋值运算符把它的左側运算对象当成左值返回,因此为了与它保持一致,combine函数必须返回引用类型。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>每个类都分别定义了它的对象被初始化的方式,类通过一个或几个特殊的成员函数来控制其对象的初始化过程,这些函数叫做构造函数( constructor)。<strong>构造函数的任务是初始化类对象的数据成员,无论何时只要类的对象被创建,就会执行构造函数</strong>。</p>
<p>构造函数的名字和类名相同。和其他函数不一样的是,构造函数没有返回类型;除此之外类似于其他的函数,构造函数也有一个(可能为空的)参数列表和一个(可能为空的)函数体。类可以包含多个构造函数,和其他重载函数差不多,不同的构造函数之间必须在参数数量或参数类型上有所区别。</p>
<p>不同于其他成员函数,构造函数不能被声明成 const的</p>
<h4 id="合成的默认构造函数"><a href="#合成的默认构造函数" class="headerlink" title="合成的默认构造函数"></a>合成的默认构造函数</h4><p>我们没有为这些对象提供初始值,因此我们知道它们执行了默认初始化。<strong>类通过一个特殊的构造函数来控制默认初始化过程,这个函数叫做默认构造函数( default constructor）</strong>默认构造函数无须任何实参。</p>
<p>如我们所见,默认构造函数在很多方面都有其特殊性。其中之一是,<strong>如果我们的类没有显式地定义构造函数,那么编译器就会为我们隐式地定义一个默认构造函数</strong>。编译器创建的构造函数又被称为合成的默认构造函数( synthesized defaultconstructor)。对于大多数类来说,这个合成的默认构造函数将按照如下规则初始化类的数据成员:</p>
<ul>
<li>如果存在类内的初始值,用它来初始化成员</li>
<li>否则,默认初始化该成员。</li>
</ul>
<h4 id="某些类不能依赖于合成的默认构造函数"><a href="#某些类不能依赖于合成的默认构造函数" class="headerlink" title="某些类不能依赖于合成的默认构造函数"></a>某些类不能依赖于合成的默认构造函数</h4><p>对于一个普通的类来说,必须定义它自己的默认构造函数,原因有三:</p>
<p>第一个原因也是最容易理解的一个原因就是编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。</p>
<p>第二个原因是对于某些类来说,<strong>合成的默认构造函数可能执行错误的操作</strong>。回忆我们之前介绍过的,如果定义在块中的内置类型或复合类型(比如数组和指针)的对象被默认初始化,则它们的值将是未定义的。该准则则同样适用于默认初始化的内置类型成员。因此,含有内置类型或复合类型成员的类应该在类的内部初始化这些成员,或者定义一个自己的默认构造函数。否则,用户在创建类的对象时就可能得到未定义的值。</p>
<p>第三个原因是有的时候编译器不能为某些类合成默认的构造函数</p>
<h4 id="default的含义"><a href="#default的含义" class="headerlink" title="=default的含义"></a>=default的含义</h4><p>在C++11标准中，如果我们需要默认行为，那么可以通过在参数列表后面写上<code>=default</code>来要求编译器生成构造函数</p>
<h4 id="构造函数的初始值列表"><a href="#构造函数的初始值列表" class="headerlink" title="构造函数的初始值列表"></a>构造函数的初始值列表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>: <span class="built_in">string</span> &amp;s): bookno(s) &#123; &#125; ;</div><div class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>: <span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p):bookno(s), units_sold(n), revenue(p*n) &#123; &#125; ;</div></pre></td></tr></table></figure>
<p>这两个定义中出现了新的部分,即冒号以及冒号和花括号之间的代码,其中花括号定义了函数体。我们把新出现的部分称为<strong>构造函数初始值列表</strong>( constructor initialize list),它负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表,每个名学后面紧跟括号括起来的(或者在花括号内的)成员初始值。不同成员的初始化通过逗号分隔开来</p>
<h3 id="拷贝、赋值和析构"><a href="#拷贝、赋值和析构" class="headerlink" title="拷贝、赋值和析构"></a>拷贝、赋值和析构</h3><h4 id="某些类不能依赖于合成的版本"><a href="#某些类不能依赖于合成的版本" class="headerlink" title="某些类不能依赖于合成的版本"></a>某些类不能依赖于合成的版本</h4><p>尽管编译器能替我们合成拷贝、赋值和销毁的操作,但是必须要清楚的一点是,对于某些类来说合成的版本无法正常工作。特別是,<strong>当类需要分配类对象之外的资源时,合成的版本常常会失效</strong>。</p>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>定义在public说明符之后的成员在整个程序内可被访问,public成员定义类的接口。</p>
<p>定义在 private说明符之后的成员可以被类的成员函数访问,但是不能被使用该类的代码访问, private部分封装了(即隐藏了)类的实现细节。</p>
<blockquote>
<p>使用class 和struct关键字</p>
</blockquote>
<p>我们可以使用class和struct这两个关键字中的任何一个定义类。唯一的一点区别是, struct和class的默认访问权限不太一样。类可以在它的第一个访问说明符之前定义成员,对这种成员的访问权限依赖于类定义。<strong>如果我们使用 struct关键字,则定义在第一个访问说明符之前的成员是public的</strong>;相反,如果<strong>我们使用class关键字,则这些成员是private的</strong>。</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类可以允许其他类或者函数访问它的非公有成员,方法是令其他类或者函数成为它的友元( friend)。如果类想把一个函数作为它的友元,只需要增加一条以friend关键字开始的函数声明语句即可:</p>
<p>友元的声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类成员也不受它所在区域访问控制级别的约束</p>
<blockquote>
<p>封装有两个重要的优点<br>确保用户代码不会无意间破坏封装对象的状态。<br>被封装的类的具体实现细节可以随时改变,而无须调整用户级别的代码。</p>
</blockquote>
<p>友元的声明仅仅指定了访问的权限,而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数,那么我们就必须在友元声明之外再专门对函数进行一次声明</p>
<h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><h3 id="类成员再探"><a href="#类成员再探" class="headerlink" title="类成员再探"></a>类成员再探</h3><p>除了定义数据和函数成员之外,类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制,可以是public或者private中的一种</p>
<blockquote>
<p>令成员函数作为内联函数</p>
</blockquote>
<p>在类中,常有一些规模较小的函数适合于被声明成内联函数。如我们之前所见的,定义在类内部的成员函数是自动inline的。</p>
<p>我们可以在类的内部把inline作为声明的一部分显式地声明成员函数,同样的,也能在类的外部用inline关键字修饰函数的定义</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_13_1518491517567.jpg" alt="enter description here"></p>
<blockquote>
<p>可变数据成员</p>
</blockquote>
<p>有时(但并不频繁)会发生这样一种情况,我们希望能<strong>修改类的某个数据成员</strong>,即使是在一个 const成员函数内。可以通过在变量的声明中加入 mutable关键字做到这点</p>
<p>一个<strong>可変数据成员</strong>( mutable data member)永远不会是 const,即使它是 const对象的成员。因此,一个 const成员函数可以改变一个可变成员的值。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_13_1518491662122.jpg" alt="enter description here"></p>
<h3 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回*this的成员函数</h3><p>返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本</p>
<blockquote>
<p>基于const的重载</p>
</blockquote>
<p>通过区分成员函数是否是 const的,我们可以对其进行重载,其原因与我们之前根据指针参数是否指向 const而重载函数的原因差不多。具体说</p>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>每个类定义了唯一的类型。对于两个类来说,即使它们的成员完全一样,这两个类也是两个不同的类型。</p>
<blockquote>
<p>类的声明</p>
</blockquote>
<p>就像可以把函数的声明和定义分离开来一样,我们也能仅仅声明类而暂时不定义它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Screen;   // screen类的声明</div></pre></td></tr></table></figure></p>
<p>这种声明有时被称作<strong>前向声明</strong>( forward declaration),它向程序中引入了名字 Screen并且指明 Screen是一种类类型。对于类型 Screen来说,在它声明之后定义之前是一个不完全类型( incomplete type),也就是说,此时我们已知 Screen是一个类型,但是不清楚它到底包含哪些成员。</p>
<p>不完全类型只能在非常有限的情景下使用:可以定义指向这种类型的指针或引用,也可以声明(但是不能定义)以不完全类型作为参数或者返回类型的函数。</p>
<h3 id="友元再探"><a href="#友元再探" class="headerlink" title="友元再探"></a>友元再探</h3><p>类还可以把其他的类定义成友元,也可以把其他类(之前已定义过的)的成员函数定义成友元。此外,友元函数能定义在类的内部,这样的函数是隐式内联的。</p>
<p>如果一个类定义了友元类，则友元类的成员函数可以访问此类包括非公有函数在内的所有成员。</p>
<p><strong>友元不具备传递性</strong></p>
<blockquote>
<p>令成员函数作为友元</p>
</blockquote>
<p>除了令整个Window mgr作为友元之外, Screen还可以只为clear提供访问权限。当把一个成员函数声明成友元时,我们必须明确指出该成员函数属于哪个类:</p>
<blockquote>
<p>函数重载和友元</p>
</blockquote>
<p>尽管重载函数的名字相同,但它们仍然是不同的函数。因此,如果一个类想把一组重载函数声明成它的友元,它需要对这组函数中的每一个分别声明:</p>
<blockquote>
<p>友元声明和作用域</p>
</blockquote>
<p>类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在个友元声明中时,我们隐式地假定该名字在当前作用域中是可见的。</p>
<h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><p>每个类都会定义它自己的作用域。<strong>在类的作用域之外,普通的数据和函数成员只能由对象、引用用或者指针使用成员访问运算符来访问</strong>。对于类类型成员则使用作用域运算符访问。不论哪种情况,跟在运算符之后的名字都必须是对应类的成员</p>
<blockquote>
<p>作用域和定义在类外部的成员</p>
</blockquote>
<p>在类的外部,成员的名字被隐藏起来了。一旦遇到了类名,定义的剩余部分就在类的作用域之内了,这里的剩余部分包括参数列表和函数体。结果就是,我们可以直接使用类的其他成员而无须再次授权了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518603468039.jpg" alt="enter description here"></p>
<p>另一方面,函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时,返回类型中使用的名字都位于类的作用域之外。这时,返回类型必须指明它是哪个类的成员。</p>
<h3 id="名字查找和类的作用域"><a href="#名字查找和类的作用域" class="headerlink" title="名字查找和类的作用域"></a>名字查找和类的作用域</h3><p><strong>名字查找( name lookup)</strong>(寻找与所用名字最匹配的声明的过程)的过程比较直截了当:</p>
<ul>
<li>首先,在名字所在的块中寻找其声明语句,只考虑在名字的使用之前出现的声明。</li>
<li>如果没找到,继续查找外层作用域。</li>
<li>如果最终没有找到匹配的声明,则程序报错。</li>
</ul>
<p>一般来说,内层作用域可以重新定义外层作用域中的名字,即使该名字已经在内层作用域中使用过。然而在类中,如果成员使用了外层作用域中的某个名字,而该名字代表种类型,则类不能在之后重新定义该名字:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518603659447.jpg" alt="enter description here"></p>
<h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><blockquote>
<p>构造函数的初始值有时必不可少</p>
</blockquote>
<p>有时我们可以忽略数据成员初始化和赋值之间的差异,但并非总能这样。<strong>如果成员是const或者是引用的话,必须将其初始化</strong>。类似的,当成员属于某种类类型且该类没有定义默认构造函数时,也必须将这个成员初始化。</p>
<p>一些数据成员必须初始化，建议养成使用构造函数初始化值的习惯</p>
<blockquote>
<p>成员初始化的顺序</p>
</blockquote>
<p>构造函数初始值列表只说明用于初始化成员的值,而不限定初始化的具体执行顺序。</p>
<p><strong>成员的初始化顺序与它们在类定义中的出现顺序一致</strong>:第一个成员先被初始化,然后第二个,以此类推。<strong>构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序</strong>。</p>
<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>C++11新标准扩展了构造函数初始值的功能,使得我们可以定义所谓的<strong>委托构造函数</strong>( delegating constructor)。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程,或者说它把它自自己的一些(或者全部)职责委托给了其他构造函数。</p>
<p>和其他构造函数一样,一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数内,成员初始值列表只有一个唯一的入口,就是类名本身。和其他成员初始值一样,类名后面紧跟圆括号括起来的参数列表,参数列表必须与类中另外一个构造函数匹配。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518610183005.jpg" alt="enter description here"></p>
<h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><p>我们能为类定义隐式转换规则。如果<strong>构造函数只接受一个实参,则它实际上定义了转换为此类类型的隐式转换机制</strong>,有时我们]把这种构造函数称作<strong>转换构造函数</strong></p>
<blockquote>
<p>抑制构造函数定义的隐式转换</p>
</blockquote>
<p>在要求隐式转换的程序上下文中,我们们可以通过将构造函数声明为explicit加以阻止:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518610514067.jpg" alt="enter description here"></p>
<h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p>聚合类( aggregate class)使得用户可以直接访问其成员,并且具有特殊的初始化语法形式。当一个类满足如下条件时,我们说它是聚合的:</p>
<ul>
<li>所有成员都是public的</li>
<li>没有定义任何构造函数。</li>
<li>没有类内初始值</li>
<li>没有基类,也没有 virtual函数,关于这部分知识我们将在第15章详细介绍</li>
</ul>
<h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><p><strong>数据成员都是字面值类型的聚合类</strong>是字面值常量类。如果一个类不是聚合类,但它符合下述要求,则它也是一个字面值常量类</p>
<ul>
<li>数据成员都必须是字面值类型。</li>
<li>类必须至少含有一个 constexpr构造造函数。</li>
<li>如果一个数据成员含有类内初始值,则内置类型成员的初始值必须是一条常量表达式;或者如果成员属于某种类类型,则初始值必须使用成员自己的 constexpr构造函数</li>
<li>类必须使用析构函数的默认定义,该成员负责销毀类的对象</li>
</ul>
<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。</p>
<blockquote>
<p>声明静态成员</p>
</blockquote>
<p>我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员样,静态成员可以是 public的或 private的。静态数据成员的类型可以是常量、引用、指针、类型等</p>
<p>我们使用作用域运算符直接访问静态成员：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> r;</div><div class="line">r = Account::rate();</div></pre></td></tr></table></figure></p>
<blockquote>
<p>定义静态成员</p>
</blockquote>
<p>和其他的成员函数一样,我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时,不能重复 static关键字,该关键字只出现在类内部的声明语句:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Account::rate( <span class="keyword">double</span> newRate)</div><div class="line">&#123;</div><div class="line">	interesRate = newRate;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>我们不能在类的内部初始化静态成员。相反的,必须在类的外部定义和初始化每个静态成员。</p>
<blockquote>
<p>静态成员的类内初始化</p>
</blockquote>
<p>通常情况下・类的静态成员不应该在类的内部初始化。然而,我们可以为静态成员提供 const整数类型的类内初始值,不过要求静态成员必须是字面值常量类型的constexpr</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》笔记 C++基础部分&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C/C++" scheme="https://www.liuin.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 配置反向代理</title>
    <link href="https://www.liuin.cn/2018/02/14/Nginx-%E9%85%8D%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>https://www.liuin.cn/2018/02/14/Nginx-配置反向代理/</id>
    <published>2018-02-14T05:26:06.000Z</published>
    <updated>2018-02-23T04:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>近段时间遇到一个问题：有多个服务要放在一个主机上，但是想用域名来区分这些服务而不是端口号（就像IP地址一样，没有人愿意记端口号）。后面找到了Nginx配置反向代理这个解决方案，这里总结一下。</p>
<a id="more"></a>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>一个Web应用的基本通信流程是：客户端（client）发送一个请求（request）给服务器（server），然后服务器根据请求返回相应的响应（response）给客户端。</p>
<p>那么代理的作用就是让一个机器来替我们发送请求或者返回响应，在客户端替我们发送请求的代理称为正向代理；在服务器替我们接受请求返回响应的代理称为反向代理。</p>
<p>正向代理：client —(send request)—&gt; clinet proxy –(send request)—&gt; server<br>反向代理：clinet –(send request)–&gt; server proxy –(send request)–&gt;other server</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518583313864.jpg" alt="正向代理和反向代理示意图"></p>
<h2 id="Nginx-配置反向代理"><a href="#Nginx-配置反向代理" class="headerlink" title="Nginx 配置反向代理"></a>Nginx 配置反向代理</h2><p>使用Nginx配置反向代理需要用到的配置模块有http模块、server模块、location模块、upstream模块</p>
<h3 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h3><p>http模块负责<strong>HTTP服务器相关属性的配置</strong>，它里面有server和upstream子模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">	# include用来设定文件的mime类型,类型在配置文件目录下的mime.type文件定义，来告诉nginx来识别文件类型。</div><div class="line">    include mime.types;</div><div class="line">    </div><div class="line">	# default_type 设定了默认的类型为二进制流，也就是当文件类型未定义时使用这种方式</div><div class="line">	default_type application/octet-stream;</div><div class="line">	</div><div class="line">	# log_format 用于设置日志的格式，和记录哪些参数</div><div class="line">    log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</div><div class="line">                    &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</div><div class="line">                    &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</div><div class="line">					</div><div class="line">	# 纪录每次的访问日志的文件地址，后面的main是日志的格式样式，对应于log_format的main。</div><div class="line">    access_log /usr/local/var/log/nginx/access.log  main;</div><div class="line">	</div><div class="line">	# sendfile开启高效文件传输模式。将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞。</div><div class="line">    sendfile on;</div><div class="line">    tcp_nopush on;</div><div class="line">    tcp_nodelay on;</div><div class="line">	</div><div class="line">	# keepalive设置客户端连接保持活动的超时时间。在超过这个时间之后，服务器会关闭该连接。</div><div class="line">    keepalive_timeout 10;</div><div class="line">    #gzip on;</div><div class="line">    upstream myproject &#123;</div><div class="line">        .....</div><div class="line">    &#125;</div><div class="line">    server &#123;</div><div class="line">        ....</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="server模块"><a href="#server模块" class="headerlink" title="server模块"></a>server模块</h3><p>为http模块的子模块，定义一个虚拟主机。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">	# listen 指定虚拟主机监听的服务端口</div><div class="line">    listen 8080;</div><div class="line">	</div><div class="line">	# server_name 用来指定IP地址或者域名，多个域名之间用空格分开</div><div class="line">    server_name localhost 192.168.12.10 www.yangyi.com;</div><div class="line">    </div><div class="line">	# 全局定义，如果都是这一个目录，这样定义最简单。</div><div class="line">    # root 表示在这整个server虚拟主机内，全部的root web根目录。</div><div class="line">	root   /Users/yangyi/www;</div><div class="line">	# index 全局定义访问的默认首页地址。</div><div class="line">    index  index.php index.html index.htm; </div><div class="line">	# charset 用于设置网页的默认编码格式。</div><div class="line">    charset utf-8;</div><div class="line">	# access_log 用来指定此虚拟主机的访问日志存放路径，最后的main用于指定访问日志的输出格式。</div><div class="line">    access_log  usr/local/var/log/host.access.log  main;</div><div class="line">    error_log  usr/local/var/log/host.error.log  error;</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="upstream模块"><a href="#upstream模块" class="headerlink" title="upstream模块"></a>upstream模块</h3><p>负责负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">upstream iyangyi.com&#123;</div><div class="line">    ip_hash;</div><div class="line">    server 192.168.12.1:80;</div><div class="line">    server 192.168.12.2:80 down;</div><div class="line">    server 192.168.12.3:8080  max_fails=3  fail_timeout=20s;</div><div class="line">    server 192.168.12.4:8080;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>通过upstream指令指定了一个负载均衡器的名称iyangyi.com。这个名称可以任意指定，在后面需要的地方直接调用即可。</li>
<li>ip_hash这是其中的一种负载均衡调度算法，下面会着重介绍。</li>
<li>紧接着就是各种服务器了。用server关键字表识，后面接ip。</li>
</ul>
<p>Nginx负载均衡模块支持的4种调度算法：</p>
<ul>
<li><strong>weight 轮询</strong>（默认）。每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。weight。指定轮询权值，weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。</li>
<li><strong>ip_hash</strong>。每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。</li>
<li><strong>fair（第三方）</strong>。比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。</li>
<li><strong>url_hash（第三方）</strong>。按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx的hash软件包。</li>
</ul>
<h3 id="location模块"><a href="#location模块" class="headerlink" title="location模块"></a>location模块</h3><p>location模块使用来定位URL、解析URL的，指明定位到的URL的功能是什么。提供了强大的正则匹配功能，也支持条件判断匹配，用户可以通过location指令实现Nginx对动、静态网页进行过滤处理。</p>
<p>最简单的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    root   /Users/yangyi/www;</div><div class="line">    index  index.php index.html index.htm;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>location / 表示匹配根目录</li>
<li>root 指令用于指定访问根目录时，虚拟主机的web目录</li>
<li>index 用于设定我们只输入域名后访问的默认首页地址</li>
</ul>
<p>当我们需要进行反向代理的时候，主要配置也是在这里的，其使用的是location模块下的proxy_pass选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">	proxy_pass          https://gist.github.com;</div><div class="line">	proxy_cache_valid   200 302 1h;</div><div class="line">	proxy_cache_valid   404 1m;</div><div class="line">	proxy_cache_use_stale error timeout invalid_header updating</div><div class="line">		http_500 http_502 http_503 http_504;</div><div class="line">	proxy_set_header    Accept-Encoding &quot;&quot;;</div><div class="line">	proxy_set_header    Accept-Language &quot;zh-CN&quot;;</div><div class="line">	proxy_set_header    User-Agent $http_user_agent;</div><div class="line">	sub_filter  https://gist-assets.github.com/ http://gist.example.com;</div><div class="line">	sub_filter  https://gist.github.com/ http://gist.example.com;</div><div class="line">	sub_filter_once     off;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>proxy_pass 指定反向代理的地址</li>
<li>proxy_set_header 设置 HTTP 请求头，Accept-Encoding “” 表示拒绝任何压缩，这保证了服务器返回给反向代理的内容是未经压缩的，以便进行 URL 替换</li>
<li>proxy_set_header 设置 HTTP 请求头，语言设置</li>
<li>proxy_set_header 设置 HTTP 请求头，设置 UA</li>
<li>sub_filter URL 替换</li>
<li>sub_filter_once 被关闭，替换所有可替换的内容</li>
</ul>
<h2 id="反向代理作用"><a href="#反向代理作用" class="headerlink" title="反向代理作用"></a>反向代理作用</h2><ul>
<li>保护了真实的web服务器，web服务器对外不可见，外网只能看到反向代理服务器，而反向代理服务器上并没有真实数据，因此，保证了web服务器的资源安全</li>
<li>负载均衡，最大化服务器集群的效率</li>
<li>请求的统一控制，包括设置权限、过滤规则等；</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>配置本地主机<code>gist.example.com</code>到github的<code>gist.github.com</code>的server模块配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen  80;</div><div class="line">    server_name gist.example.com;</div><div class="line">    access_log  off;</div><div class="line">    resolver    8.8.8.8;</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass          https://gist.github.com;</div><div class="line">        proxy_cache_valid   200 302 1h;</div><div class="line">        proxy_cache_valid   404 1m;</div><div class="line">        proxy_cache_use_stale error timeout invalid_header updating</div><div class="line">            http_500 http_502 http_503 http_504;</div><div class="line">        proxy_set_header    Accept-Encoding &quot;&quot;;</div><div class="line">        proxy_set_header    Accept-Language &quot;zh-CN&quot;;</div><div class="line">        proxy_set_header    User-Agent $http_user_agent;</div><div class="line">        sub_filter  https://gist-assets.github.com/ http://gist.example.com;</div><div class="line">        sub_filter  https://gist.github.com/ http://gist.example.com;</div><div class="line">        sub_filter_once     off;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>井号开头的行是注释</li>
<li>server 开始了 server 块</li>
<li>listen 表明 Nginx 将会在 80 端口监听</li>
<li>server_name 是我们给反向代理配置的域名，访问这个域名就相当于访问 Gist</li>
<li>access_log 是日志文件的配置，这里为了简化我将它关掉了</li>
<li>resolver 是 DNS 服务器</li>
<li>location 块具体配置反向代理的行为</li>
<li>proxy_pass 说明将会将请求转发至 Gist</li>
<li>proxy_cache_valid 配置缓存</li>
<li>proxy_cache_valid 同上</li>
<li>proxy_cache_use_stale 同上</li>
<li>proxy_set_header 设置 HTTP 请求头，Accept-Encoding “” 表示拒绝任何压缩，这保证了服务器返回给反向代理的内容是未经压缩的，以便进行 URL 替换</li>
<li>proxy_set_header 设置 HTTP 请求头，语言设置</li>
<li>proxy_set_header 设置 HTTP 请求头，设置 UA</li>
<li>sub_filter URL 替换</li>
<li>sub_filter 同上</li>
<li>sub_filter_once 被关闭，替换所有可替换的内容</li>
</ul>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://liam0205.me/2015/09/07/reverse-proxy-to-get-access-to-gist/" target="_blank" rel="external">https://liam0205.me/2015/09/07/reverse-proxy-to-get-access-to-gist/</a></li>
<li><a href="https://www.jianshu.com/p/bed000e1830b" target="_blank" rel="external">https://www.jianshu.com/p/bed000e1830b</a></li>
<li><a href="http://blog.csdn.net/physicsdandan/article/details/45667357" target="_blank" rel="external">http://blog.csdn.net/physicsdandan/article/details/45667357</a></li>
<li><a href="https://paste.ubuntu.com/p/jZ8tBwGYcM/" target="_blank" rel="external">nginx配置整理（含注释）</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近段时间遇到一个问题：有多个服务要放在一个主机上，但是想用域名来区分这些服务而不是端口号（就像IP地址一样，没有人愿意记端口号）。后面找到了Nginx配置反向代理这个解决方案，这里总结一下。&lt;/p&gt;
    
    </summary>
    
      <category term="运维" scheme="https://www.liuin.cn/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Nginx" scheme="https://www.liuin.cn/tags/Nginx/"/>
    
      <category term="代理" scheme="https://www.liuin.cn/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Git 内部原理</title>
    <link href="https://www.liuin.cn/2018/02/11/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/"/>
    <id>https://www.liuin.cn/2018/02/11/Git-内部原理/</id>
    <published>2018-02-11T13:39:14.000Z</published>
    <updated>2018-02-23T04:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>《Pro Git》读书笔记</p>
<a id="more"></a>
<p>从根本上来讲 Git 是一个内容寻址（content-addressable）文件系统</p>
<h2 id="底层命令和高层命令"><a href="#底层命令和高层命令" class="headerlink" title="底层命令和高层命令"></a>底层命令和高层命令</h2><p>由于 Git 最初是一套面向版本控制系统的工具集，而不是一个完整的、用户友好的版本控制系统，所以它还包含了一部分用于完成底层工作的命令。这些命令被设计成能以 UNIX 命令行的风格连接在一起，抑或藉由脚本调用，来完成工作。这部分命令一般被称作“<strong>底层（plumbing）”命令</strong>，而那些更友好的命令则被称作“高层（porcelain）”命令。</p>
<p>当在一个新目录或已有目录执行 git init 时，Git 会创建一个 .git 目录。这个目录包含了几乎所有 Git 存储和操作的对象。如若想备份或复制一个版本库，只需把这个目录拷贝至另一处即可。</p>
<p>目录结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ ls -F1</div><div class="line">index				# 保存暂存区信息</div><div class="line">HEAD				# 指示目前被检出的分支</div><div class="line">config*				# 包含项目特有的配置项</div><div class="line">description			# 仅供GitWeb使用</div><div class="line">hooks/				# 包含hook钩子脚本</div><div class="line">info/				# 包含全局性排除（global exclude）文件</div><div class="line">objects/			# 存储所有的数据内容</div><div class="line">refs/				# 存储指向数据（分支）的提交对象的指针</div></pre></td></tr></table></figure></p>
<h2 id="Git-对象"><a href="#Git-对象" class="headerlink" title="Git 对象"></a>Git 对象</h2><p>Git 是一个内容寻址文件系统。Git 的核心部分是一个简单的键值对数据库（key-value data store）。你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。</p>
<h3 id="树对象"><a href="#树对象" class="headerlink" title="树对象"></a>树对象</h3><p>树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起。Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。所有内容均以树对象和数据对象的形式存储，其中<strong>树对象对应了 UNIX 中的目录项</strong>，<strong>数据对象则大致上对应了 inodes 或文件内容</strong>。一个树对象包含了一条或多条树对象记录（tree entry），<strong>每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息</strong>。</p>
<p>通常，Git 根据某一时刻暂存区（即 index 区域，下同）所表示的状态创建并记录一个对应的树对象，如此重复便可依次记录（某个时间段内）一系列的树对象。因此，为创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。</p>
<h3 id="提交对象"><a href="#提交对象" class="headerlink" title="提交对象"></a>提交对象</h3><p>提交对象的格式很简单：它先指定一个顶层树对象，代表当前项目快照；然后是作者/提交者信息（依据你的user.name 和 user.email 配置来设定，外加一个时间戳）；留空一行，最后是提交注释</p>
<p>每次我们运行 git add 和 git commit 命令时， Git 所做的实质工作——<strong>将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。</strong>这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 .git/objects 目录下。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_11_1518354037927.jpg" alt="enter description here"></p>
<h3 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h3><p>在存储内容时，会有个头部信息一并被保存。让我们略花些时间来看看 Git 是如何存储其对象的。</p>
<p>所有的 Git 对象均以这种方式存储，区别仅在于类型标识——另两种对象类型的头部信息以字符串“commit”或“tree”开头，而不是“blob”。另外，虽然数据对象的内容几乎可以是任何东西，但提交对象和树对象的内容却有各自固定的格式。</p>
<h2 id="Git-引用"><a href="#Git-引用" class="headerlink" title="Git 引用"></a>Git 引用</h2><p>为了能遍历那段历史从而找到所有相关对象，你仍须记住 1a410e 是最后一个提交。我们需要一个文件来保存 SHA-1 值，并<strong>给文件起一个简单的名字，然后用这个名字指针来替代原始的 SHA-1 值</strong>。在 Git 里，这样的文件被称为“引用（references，或缩写为 refs）”；你可以在 .git/refs 目录下找到这类含有 SHA-1 值的文件。</p>
<p> <strong>Git 分支的本质：一个指向某一系列提交之首的指针或引用</strong>。</p>
<h3 id="HEAD引用"><a href="#HEAD引用" class="headerlink" title="HEAD引用"></a>HEAD引用</h3><p> HEAD 文件是一个符号引用（symbolic reference），指向目前所在的分支。所谓符号引用，意味着它并不像普通引用那样包含一个 SHA-1 值——它是一个<strong>指向其他引用的指针</strong>。</p>
<p>当我们执行 git commit 时，该命令会创建一个提交对象，并用 HEAD 文件中那个引用所指向的 SHA-1 值设置其父提交字段</p>
<h3 id="标签引用"><a href="#标签引用" class="headerlink" title="标签引用"></a>标签引用</h3><p>前文我们刚讨论过 Git 的三种主要对象类型，事实上还有第四种。标签对象（tag object）非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。主要的区别在于，<strong>标签对象通常指向一个提交对象，而不是一个树对象</strong>。它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。</p>
<p>存在两种类型的标签：附注标签和轻量标签。轻量标签的全部内容——一个固定的引用。一个附注标签则更复杂一些。若要创建一个附注标签，Git 会创建一个标签对象，并记录一个引用来指向该标签对象，而不是直接指向提交对象。</p>
<h3 id="远程引用"><a href="#远程引用" class="headerlink" title="远程引用"></a>远程引用</h3><p>第三种引用类型是远程引用（remote reference）。如果你添加了一个远程版本库并对其执行过推送操作，Git 会记录下最近一次推送操作时每一个分支所对应的值，并保存在 refs/remotes 目录下</p>
<p>远程引用和分支（位于 refs/heads 目录下的引用）之间最主要的区别在于，远程引用是只读的。虽然可以git checkout 到某个远程引用，但是 Git 并不会将 HEAD 引用指向该远程引用。</p>
<h2 id="包文件"><a href="#包文件" class="headerlink" title="包文件"></a>包文件</h2><p>Git 最初向磁盘中存储对象时所使用的格式被称为<strong>“松散（loose）”对象格式</strong>。但是，Git 会时不时地<strong>将多个这些对象打包成一个称为“包文件（packfile）</strong>”的二进制文件，以节省空间和提高效率。当版本库中有太多的松散对象，或者你手动执行 git gc 命令，或者你向远程服务器执行推送时，Git 都会这样做。</p>
<p>包文件包含了刚才从文件系统中移除的所有对象的内容。索引文件包含了包文件的偏移信息，我们通过索引文件就可以快速定位任意一个指定对象。</p>
<p>同样有趣的地方在于，最新版本完整保存了文件内容，而原始的版本反而是以差异方式保存的——这是因为大部分情况下需要快速访问文件的最新版本。</p>
<h2 id="引用规格"><a href="#引用规格" class="headerlink" title="引用规格"></a>引用规格</h2><p>我们已经使用过一些诸如远程分支到本地引用的简单映射方式，但这种映射可以更复杂。</p>
<p>添加一个远程版本库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[remote &quot;origin&quot;]</div><div class="line">url = https://github.com/schacon/simplegit-progit</div><div class="line">fetch = +refs/heads/*:refs/remotes/origin/*</div></pre></td></tr></table></figure></p>
<p>引用规格的格式由一个可选的 + 号和紧随其后的 \<src>:\<dst> 组成，其中 \<src> 是一个模式（pattern），代表远程版本库中的引用；\<dst> 是那些远程引用在本地所对应的位置。+ 号告诉 Git 即使在不能快进的情况下也要（强制）更新引用</dst></src></dst></src></p>
<h3 id="引用规格推送"><a href="#引用规格推送" class="headerlink" title="引用规格推送"></a>引用规格推送</h3><p>如果 QA 团队想把他们的 master 分支推送到远程服务器的 qa/master 分支上，可以运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin master:refs/heads/qa/master</div></pre></td></tr></table></figure></p>
<p>如果他们希望 Git 每次运行 git push origin 时都像上面这样推送，可以在他们的配置文件中添加一条 push值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[remote &quot;origin&quot;]</div><div class="line">url = https://github.com/schacon/simplegit-progit</div><div class="line">fetch = +refs/heads/*:refs/remotes/origin/*</div><div class="line">push = refs/heads/master:refs/heads/qa/master</div></pre></td></tr></table></figure></p>
<h3 id="删除引用"><a href="#删除引用" class="headerlink" title="删除引用"></a>删除引用</h3><p>你还可以借助类似下面的命令通过引用规格从远程服务器上删除引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin :topic</div></pre></td></tr></table></figure></p>
<p>因为引用规格（的格式）是 \<src>:\<dst>，所以上述命令把 \<src> 留空，意味着把远程版本库的 topic 分支<br>定义为空值，也就是删除它。</src></dst></src></p>
<h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h2><p>Git 可以通过两种主要的方式在版本库之间传输数据：“哑（dumb）”协议和“智能（smart）”协议。</p>
<h3 id="哑协议"><a href="#哑协议" class="headerlink" title="哑协议"></a>哑协议</h3><p>如果你正在架设一个基于 HTTP 协议的只读版本库，一般而言这种情况下使用的就是哑协议。</p>
<h3 id="智能协议"><a href="#智能协议" class="headerlink" title="智能协议"></a>智能协议</h3><p>智能协议是更常用的传送数据的方法，但它需要在服务端运行一个进程，而这也是 Git 的智能之处——它可以读取本地数据，理解客户端有什么和需要什么，并为它生成合适的包文件。总共有两组进程用于传输数据，它们分别负责上传和下载数据。</p>
<h2 id="维护与数据恢复"><a href="#维护与数据恢复" class="headerlink" title="维护与数据恢复"></a>维护与数据恢复</h2><h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><p>Git 会不定时地自动运行一个叫做 “auto gc” 的命令。大多数时候，这个命令并不会产生效果。然而，如果有太多松散对象（不在包文件中的对象）或者太多包文件，Git 会运行一个完整的 git gc 命令。“gc” 代表垃圾回收，这个命令会做以下事情：收集所有松散对象并将它们放置到包文件中，将多个包文件合并为一个大的包文件，移除与任何提交都不相关的陈旧对象。</p>
<h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>在你使用 Git 的时候，你可能会意外丢失一次提交。通常这是因为你强制删除了正在工作的分支，但是最后却发现你还需要这个分支；亦或者硬重置了一个分支，放弃了你想要的提交。如果这些事情已经发生，该如何找回你的提交呢？</p>
<p>最方便，也是最常用的方法，是使用一个名叫 <code>git reflog</code> 的工具。当你正在工作时，Git 会默默地记录每一次你改变 HEAD 时它的值。每一次你提交或改变分支，引用日志都会被更新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Pro Git》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="https://www.liuin.cn/tags/Git/"/>
    
  </entry>
  
</feed>
