<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sixzeroo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.liuin.cn/"/>
  <updated>2018-05-04T13:42:10.000Z</updated>
  <id>https://www.liuin.cn/</id>
  
  <author>
    <name>Sixzeroo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>APUE 进程间通信</title>
    <link href="https://www.liuin.cn/2018/05/04/APUE-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://www.liuin.cn/2018/05/04/APUE-进程间通信/</id>
    <published>2018-05-04T06:00:08.000Z</published>
    <updated>2018-05-04T13:42:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第15章 进程间通信 笔记</p>
<a id="more"></a>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道是UNX系统IPC的最古老形式,所有UNX系统都提供此种通信机制。</p>
<p>管道有以下两种局限性：</p>
<ol>
<li>历史上,它们是半双工的(即数据只能在一个方向上流动)。现在,某些系统提供全双工管道,但是为了最佳的可移植性,我们决不应预先假定系统支持全双工管道</li>
<li>管道只能在具有公共祖先的两个进程之间使用。通常,一个管道由一个进程创建,在进程调用fork之后,这个管道就能在父进程和子进程之间使用了。</li>
</ol>
<p>每当在管道中键入一个命令序列,让shell执行时,shell都会为每一条命令单独创建一个进程,然后用管道将前一条命令进程的标准输出与后一条命令的标准输入相连接。</p>
<p>管道是通过调用pipe函数创建的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</div><div class="line"></div><div class="line">Returns: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</div></pre></td></tr></table></figure>
<p>经由参数fd返回两个文件描述符:fd[0]为读而打开,fd[1]为写而打开。fd[1]的输出是fd[0]的输入。</p>
<p>单个进程中的管道几乎没有任何用处。通常,进程会先调用pipe,接着调用fork,从而创建从父进程到子进程的IPC通道,反之亦然</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254214499352.jpg" alt=""></p>
<h2 id="函数popen和pclose"><a href="#函数popen和pclose" class="headerlink" title="函数popen和pclose"></a>函数popen和pclose</h2><p>常见的操作是创建一个连接到另一个进程的管道,然后读其输出或向其输入端发送数据,为此,标准I/O库提供了两个函数 popen和 pclose。这两个函数实现的操作是:创建一个管道,fork一个子进程,关闭未使用的管道端,执行一个shell运行命令,然后等待命令终止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">`<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function">FILE *<span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</div><div class="line"><span class="comment">// Returns: ﬁle pointer if OK, NULL on error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *fp)</span></span>; </div><div class="line"><span class="comment">// Returns: termination status of cmdstring, or −1 on error</span></div></pre></td></tr></table></figure>
<p>函数 popen先执行fork,然后调用exec执行cstring,并且返回一个标准I/O文件指针。如果type是”r”,则文件指针连接到cstring的标准输出。如果type是”w”,则文件指针连接到 cmdstring的标准输入，表示写FILE中的东西</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254216672075.jpg" alt=""></p>
<p>可以将最后一个参数的使用方法和fopen类比，如果type是”r”,则返回的文件指针是可读的,如果type是”w”,则是可写的</p>
<h2 id="协同进程"><a href="#协同进程" class="headerlink" title="协同进程"></a>协同进程</h2><p>UNIX系统过滤程序从标准输入读取数据,向标准输出写数据。几个过滤程序通常在shell管道中线性连接。当一个过滤程序既产生某个过滤程序的输入,又读取该过滤程序的输出时,它就变成了协同进程(coprocess)。</p>
<p>协同进程通常在shell的后台运行,其标准输入和标准输出通过管道连接到另一个程序。</p>
<p>popen只提供连接到另一个进程的标准输入或标准输出的一个单向管道,而协同进程则有连接到另一个进程的两个单向管道:一个接到其标准输入,另一个则来自其标准输出。</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254220325027.jpg" alt=""></p>
<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>FIFO有时被称为命名管道。未命名的管道只能在两个相关的进程之间使用,而且这两个相关的进程还要有一个共同的创建了它们的祖先进程。但是,通过FIFO,不相关的进程也能交换数据。</p>
<p>FIFO是一种文件类型。通过stat结构的st<em>mode成员的编码可以知道文件是否是FIFO类型。可以用S</em> ISFTEO宏对此进行测试。</p>
<p>创建FIFO类似于创建文件。确实,FIFO的路径名存在于文件系统中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>当我们用 mkfifo或者 mkfifoat创建FIFO时,要用open来打开它。设置非阻塞以及对错误的处理和普通文件的处理是一样的。</p>
<p>FIFO有以下两种用途</p>
<ul>
<li>shell命令使用FIFO将数据从一条管道传送到另一条时,无需创建中间临时文件</li>
<li>客户进程服务器进程应用程序中,FIFO用作汇聚点,在客户进程和服务器进程二者之间传递数据</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-05-04-15254224287657.jpg" alt=""></p>
<h2 id="XSI-IPC"><a href="#XSI-IPC" class="headerlink" title="XSI IPC"></a>XSI IPC</h2><p>有3种称作XSI IPC的IPC:消息队列、信号量以及共享存储器。它们之间有很多相似之处</p>
<h3 id="标识符与键"><a href="#标识符与键" class="headerlink" title="标识符与键"></a>标识符与键</h3><p>每个内核中的IPC结构(消息队列、信号量或共享存储段)都用一个非负整数的标识符(identifier)加以引|用。</p>
<p>标识符是IPC对象的内部名。为使多个合作进程能够在同一IPC对象上汇聚,需要提供一个外部命名方案。为此,每个IPC对象都与一个键(key)相关联,将这个键作为该对象的外部名。键的数据结构是<code>key_t</code></p>
<p>有多种方法使客户进程和服务器进程在同一IPC结构上汇聚：</p>
<ol>
<li>服务器进程可以指定键IPC_PRIVATE创建一个新IPC结构,将返回的标识符存放在某处(如一个文件)以便客户进程取用。</li>
<li>可以在一个公用头文件中定义一个客户进程和服务器进程都认可的键。</li>
<li>客户进程和服务器进程认同一个路径名和项目ID，接着调用函数ftok将这两个值变成一个键</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">key_t</span> ftok(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> id);</div><div class="line"></div><div class="line"><span class="comment">// Returns: key if OK, (key_t)−1 on error</span></div></pre></td></tr></table></figure>
<h3 id="权限结构"><a href="#权限结构" class="headerlink" title="权限结构"></a>权限结构</h3><p>XSI IPC为每一个IPC结构关联了一个ipc_perm结构。该结构规定了权限和所有者,它至少包括下列成员:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct ipc_perm &#123; </div><div class="line">    uid_t uid; /* owner’s effective user ID */ </div><div class="line">    gid_t gid; /* owner’s effective group ID */ </div><div class="line">    uid_t cuid; /* creator’s effective user ID */ </div><div class="line">    gid_t cgid; /* creator’s effective group ID */ </div><div class="line">    mode_t mode; /* access modes */ </div><div class="line">    .</div><div class="line">    .</div><div class="line">    .</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在创建IPC结构时,对所有字段都赋初值。对于任何IPC结构都不存在执行权限</p>
<h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><p>XSI IPC的一个基本问题是:<strong>IPC结构是在系统范围内起作用的,没有引用计数</strong>。例如,如果进程创建了一个消息队列,并且在该队列中放入了几则消息,然后终止,那么该消息队列及其内容不会被删除。它们会一直留在系统中直至发生下列动作为止:由某个进程调用 msgrcv或msct1读消息或删除消息队列;或某个进程执行 ipcri(1)命令删除消息队列;或正在自举的系统删除消息队列。</p>
<p>将此与管道相比,当最后一个引用管道的进程终止时,管道就被完全地删除了。对于FIFO而言,在最后一个引用FIFO的进程终止时,虽然FIFO的名字仍保留在系统中,直至被显式地删除,但是留在FIFO中的数据已被删除了</p>
<p>XSI IPC的另一个问题是:这些IPC结构在文件系统中没有名字，为了支持这些IPC对象，系统增加了许多的系统调用</p>
<p>因为这些形式的IPC不使用文件描述符,所以<strong>不能对它们使用多路转接I/O函数</strong></p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是消息的链接表,存储在内核中,由消息队列标识符标识。</p>
<p><code>msgget</code>用于创建一个新队列或打开一个现有队列。<code>msgsnd</code>将新消息添加到队列尾端。每个消息包含一个正的长整型类型的字段、一个非负的长度以及实际数据字节数(对应于长度),所有这些都在将消息添加到队列时,传送给<code>msgsnd</code>。 <code>msgrcv</code>用于从队列中取消息。我们并不定要以先进先出次序取消息,也可以按消息的类型字段取消息。</p>
<p>每个队列有一个msqid_ds结构与其相关联</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254293881565.jpg" alt=""></p>
<p>创建一个队列或者打开一个现有队列函数<code>msgget</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: message queue ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>msgctl函数对队列执行多种操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf )</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>cmd参数指定对msqid队列要执行的命令：</p>
<ul>
<li>IPC_STAT  获取此队列的msqid_ds结构</li>
<li>IPC_SET  设置队列结构</li>
<li>IPC_RMID  从系统中删除该消息队列以及仍在该消息队列中的所有数据</li>
</ul>
<p>调用msgsnd将数据放到消息队列中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>消息类型结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> mymesg &#123; </div><div class="line">    <span class="keyword">long</span> mtype; <span class="comment">/* positive message type */</span> </div><div class="line">    <span class="keyword">char</span> mtext[<span class="number">512</span>]; <span class="comment">/* message data, of length nbytes */</span> </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>msgrcv从队列中取用消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> msgrcv(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes, <span class="keyword">long</span> type, <span class="keyword">int</span> ﬂag); </div><div class="line"></div><div class="line"><span class="comment">// Returns: size of data portion of message if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量与已经介绍过的IPC机构(管道、FIFO以及消息列队)不同。它是一个计数器,用于为多个进程提供对共享数据对象的访问</p>
<p>为了正确地实现信号量,信号量值的测试及减1操作应当是原子操作。为此,信号量通常是在内核中实现的</p>
<p>常用的信号量形式被称为二元信号量(binary semaphore)。它控制单个资源,其初始值为1。但是,一般而言,信号量的初值可以是任意一个正值,该值表明有多少个共享资源单位可供共享应用。</p>
<p>下面3个特性造成了XSI信号量比较复杂：</p>
<ol>
<li>信号量并非是单个非负值,而必需定义为含有一个或多个信号量值的集合。</li>
<li>信号量的创建(semget)是独立于它的初始化(sectl)的。这是一个致命的缺点,因为不能原子地创建一个信号量集合,并且对该集合中的各个信号量值赋初值。</li>
<li>即使没有进程正在使用各种形式的XSI IPO,它们仍然是存在的。有的程序在终止时并没有释放已经分配给它的信号量,所以我们不得不为这种程序担心。</li>
</ol>
<p>当我们想使用XSI信号量时,首先需要通过调用函数 semget来获得一个信号量ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: semaphore ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>semctl函数包含对信号量的各种操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ... <span class="comment">/* union semun arg */</span> )</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: (see following)</span></div></pre></td></tr></table></figure></p>
<p>函数semop自动执行信号集合上面的操作数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">struct</span> sembuf semoparray[], <span class="keyword">size_t</span> nops)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>参数 semoparray是一个指针,它指向一个由 sembuf结构表示的信号量操作数组:</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254305267397.jpg" alt=""></p>
<h2 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h2><p>共享存储允许两个或多个进程共享一个给定的存储区。因为数据不需要在客户进程和服务器进程之间复制,所以这是最快的一种IPC。使用共享存储时要掌握的唯一窍门是,在多个进程之间同步访问一个给定的存储区。若服务器进程正在将数据放入共享存储区,则在它做完这一操作之前,客户进程不应当去取这些数据。通常,信号量用于同步共享存储访问。</p>
<p>我们已经看到了共享存储的一种形式,就是在多个进程将同一个文件映射到它们的地址空间的时候。XSI共享存储和内存映射的文件的不同之处在于,前者没有相关的文件。XSI共享存储段是内存的匿名段</p>
<p>内核为每一个共享存储段维护一个结构，包含以下成员：</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254405323155.jpg" alt=""></p>
<p>使用函数shmgget获取一个共享存储标识符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: shared memory ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>函数shmctl对共享存储段执行多种操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf )</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>一旦创建了一个共享存储段,进程就可调用 shmat将其连接到它的地址空间中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to shared memory segment if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>共享存储段连接到调用进程的哪个地址上与addr参数以及flag中是否指定SHM_RND位有关</p>
<ul>
<li>如果addr为0,则此段连接到由内核选择的第一个可用地址上。这是推荐的使用方式。</li>
<li>如果add非0,并且没有指定 SHM_RND,则此段连接到addr所指定的地址上。</li>
<li>如果add非0,并且指定了 SHM_RND,则此段连接到(addr-( addr mod SHMLBA))所表示的地址上。 SHM_RND命令的意思是“取整”。 SHMLBA的意思是“低边界地址倍数”,它总是2的乘方。该算式是将地址向下取最近1个 SHMLBA的倍数。</li>
</ul>
<p>当对共享存储段的操作已经结束时,则调用 shmdt与该段分离。注意,这<strong>并不从系统中删除其标识符以及其相关的数据结构</strong>。该标识符仍然存在,直至某个进程(一般是服务器进程)带IPC_RMID命令的调用shmctl特地删除它为止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *addr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>回忆一下mmap函数,它可将一个文件的若干部分映射至进程地址空间。这在概念上类似于用 shmat XSI IPC函数连接一个共享存储段。两者之间的主要区别是,用mmap映射的存储段是与文件相关联的,而XSI共享存储段则并无这种关联。</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254410116645.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第15章 进程间通信 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 高级I/O</title>
    <link href="https://www.liuin.cn/2018/05/04/APUE-%E9%AB%98%E7%BA%A7I-O/"/>
    <id>https://www.liuin.cn/2018/05/04/APUE-高级I-O/</id>
    <published>2018-05-04T02:25:32.000Z</published>
    <updated>2018-05-04T05:45:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第14章 高级I/O 笔记</p>
<a id="more"></a>
<h2 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h2><p>将系统调用分成两类:“低速”系统调用和其他。低速系统调用是可能会<strong>使进程永远阻塞的一类系统调用</strong>,包括:</p>
<ul>
<li>如果某些文件类型(如读管道、终端设备和网络设备)的数据并不存在,读操作可能会使调用者永远阻塞;</li>
<li>如果数据不能被相同的文件类型立即接受(如管道中无空间、网络流控制),写操作可能会使调用者永远阻塞</li>
<li>在某种条件发生之前打开某些文件类型可能会发生阻塞(如要打开一个终端设备,需要先等待与之连接的调制解调器应答,又如若以只写模式打开FIFO,那么在没有其他进程已用读模式打开该FIFO时也要等待)</li>
<li>对已经加上强制性记录锁的文件进行读写</li>
<li>某些ioctl操作;</li>
<li>某些进程间通信函数</li>
</ul>
<p>虽然读写磁盘文件会暂时阻塞调用者,但并不能将与磁盘I/O有关的系统调用视为“低速”。</p>
<p>非阻塞IO使我们可以发出open、read和 write这样的IO操作,并使这些操作不会永远阻塞。如果这种操作不能完成,则调用立即出错返回,表示该操作如继续执行将阻塞。</p>
<p>对于一个给定的描述符,有两种为其指定非阻塞I/O的方法。</p>
<ol>
<li>如果调用open获得描述符,则可指定<code>O_NONBLOCK</code>标志</li>
<li>对于已经打开的一个描述符,则可调用<code>fcntl</code>,由该函数打开<code>O_NONBLOCK</code>文件状态标志</li>
</ol>
<h2 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h2><p>记录锁(record locking)的功能是：当第一个进程正在读或修改文件的某个部分时,使用记录锁可以阻止其他进程修改同一文件区。对于UNIX系统而言,“记录”这个词是一种误用,因为UNIX系统内核根本没有使用文件记录这种概念。一个更适合的术语可能是字节范围锁(byte-range locking),因为它锁定的只是文件中的一个区域(也可能是整个文件)</p>
<p>设置记录锁的方法是使用fcntl函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* struct flock *ﬂockptr */</span> )</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: depends on cmd if OK (see following), −1 on error</span></div></pre></td></tr></table></figure></p>
<p>对于记录锁,cmd是<code>F_GETLK</code>、<code>F_SELK</code>或<code>F_SETLKW</code>。第三个参数(我们将调用<code>flockptr</code>)是一个指向flock结构的指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct flock &#123; </div><div class="line">    short l_type; /* F_RDLCK, F_WRLCK, or F_UNLCK */ </div><div class="line">    short l_whence; /* SEEK_SET, SEEK_CUR, or SEEK_END */ </div><div class="line">    off_t l_start; /* offset in bytes, relative to l_whence */ </div><div class="line">    off_t l_len; /* length, in bytes; 0 means lock to EOF */ </div><div class="line">    pid_t l_pid; /* returned with F_GETLK */ </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>flock结构说明如下：</p>
<ul>
<li>所希望的锁类型:<code>F_RDLCK</code>(共享读锁)、<code>F_WRLCK</code>(独占性写锁)或<code>F_UNLCK</code>(解锁个区域)。</li>
<li>要加锁或解锁区域的起始字节偏移量(<code>l_start</code>和<code>l_whence</code>)。</li>
<li>区域的字节长度(1_1en)。</li>
<li>进程的ID(l_pid)持有的锁能阻塞当前进程(仅由F_GETLK返回)</li>
</ul>
<p>上面提到了两种类型的锁:共享读锁和独占性写锁。基本规则是:任意多个进程在一个给定的字节上可以有一把共享的读锁,但是在一个给定字节上只能有一个进程有把独占写锁。</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254024702844.jpg" alt=""></p>
<p>在设置或释放文件上的一把锁时,系统按要求组合或分裂相邻区。其中一个部分解锁的时候进程分裂，再次将这个区域加锁的时候进行合并。</p>
<blockquote>
<p>锁的隐含继承和释放</p>
</blockquote>
<p>关于记录锁的自动继承和释放有3条规则：</p>
<ol>
<li>锁与进程和文件两者相关联。这有两重含义:第一重很明显,当一个进程终止时,它所建立的锁全部释放;第二重则不太明显,无论一个描述符何时关闭,<strong>该进程通过这一描述符引用的文件上的任何一把锁都会释放</strong>(这些锁都是该进程设置的)。</li>
<li>由fork产生的子进程不继承父进程所设置的锁</li>
<li>在执行exec后,新程序可以继承原执行程序的锁。但是注意,如果对一个文件描述符设置了执行时关闭标志,那么当作为exec的一部分关闭该文件描述符时,将释放相应文件的所有锁。</li>
</ol>
<blockquote>
<p>FreeBSD实现</p>
</blockquote>
<p><img src="https://data2.liuin.cn/2018-05-04-15254027539830.jpg" alt=""></p>
<h2 id="I-O多路转接"><a href="#I-O多路转接" class="headerlink" title="I/O多路转接"></a>I/O多路转接</h2><p>有的时候我们需要从多个文件描述符读的时候，我们不能在任一个描述符上进行阻塞读(read),否则可能会因为被阻塞在一个描述符的读操作上而导致另一个描述符即使有数据也无法处理。</p>
<p>一种比较好的技术是使用I/O多路转接(I/O multiplexing)。为了使用这种技术,先构造一张我们感兴趣的描述符(通常都不止一个)的列表,然后调用一个函数,直到这些描述符中的一个已准备好进行I/O时,该函数才返回。</p>
<h3 id="函数select和pselect"><a href="#函数select和pselect" class="headerlink" title="函数select和pselect"></a>函数select和pselect</h3><p>在所有POSIX兼容的平台上, select函数使我们可以执行I/O多路转接。传给se1ect的参数告诉内核:</p>
<ul>
<li>我们所关心的描述符:</li>
<li>对于每个描述符我们所关心的条件(是否想从一个给定的描述符读,是否想写一个给定的描述符,是否关心一个给定描述符的异常条件)</li>
<li>愿意等待多长时间(可以永远等待、等待一个固定的时间或者根本不等待)</li>
<li>从se1ect返回时,内核告诉我们已准备好的描述符的总数量</li>
<li>对于读、写或异常这3个条件中的每一个,哪些描述符已准备好</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *<span class="keyword">restrict</span> readfds, fd_set *<span class="keyword">restrict</span> writefds, fd_set *<span class="keyword">restrict</span> exceptfds, <span class="keyword">struct</span> timeval *<span class="keyword">restrict</span> tvptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, −1 on error</span></div></pre></td></tr></table></figure>
<p>中间3个参数 readfds、 writefds和exceptfds是指向描述符集的指针。这3个描述符集说明了我们关心的可读、可写或处于异常条件的描述符集合。每个描述符集存储在一个<code>fd_set</code>数据类型中。这个数据类型是由实现选择的,它可以为每一个可能的描述符保持一位。</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254037628736.jpg" alt=""></p>
<p>对于<code>fd_set</code>数据类型,唯一可以进行的处理是:分配一个这种类型的变量,将这种类型的一个变量值赋给同类型的另一个变量,或对这种类型的变量使用下列4个函数中的一个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</div><div class="line"><span class="comment">// Returns: nonzero if fd is in set, 0 otherwise</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;</div></pre></td></tr></table></figure>
<p>另外一个select函数的变体pselect：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *<span class="keyword">restrict</span> readfds, fd_set *<span class="keyword">restrict</span> writefds, fd_set *<span class="keyword">restrict</span> exceptfds, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> sigmask)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, −1 on error</span></div></pre></td></tr></table></figure>
<p>和select的不同点在于：</p>
<ul>
<li>超时使用的数据结构不一样，能够提供更加精准的超时时间</li>
<li>超时值被声明为const，保证了pselect不会改变这一个值</li>
<li>可使用可选信号屏蔽字</li>
</ul>
<h3 id="函数poll"><a href="#函数poll" class="headerlink" title="函数poll"></a>函数poll</h3><p>poll函数和select差不多，就是函数的接口不一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd fdarray[], <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, −1 on error</span></div></pre></td></tr></table></figure>
<p>与 select不同,pol1不是为每个条件(可读性、可写性和异常条件)构造一个描述符集,而是构造一个po11fd结构的数组,每个数组元素指定一个描述符编号以及我们对该描述符感兴趣的条件。</p>
<h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h2><p>在用异步I/O的时候,要通过选择来灵活处理多个并发操作,这会使应用程序的设计复杂化。更简单的做法可能是使用多线程,使用同步模型来编写程序,并让这些线程以异步的方式运行。</p>
<p>使用POSIX异步I/O接口，会带来这些麻烦：</p>
<ul>
<li>每个异步操作有3处可能产生错误的地方:一处在操作提交的部分,一处在操作本身的结果,还有一处在用于决定异步操作状态的函数中。</li>
<li>设计大量额外的设置和处理规则</li>
<li>从错误中恢复会比较困难</li>
</ul>
<h2 id="函数readv和writev"><a href="#函数readv和writev" class="headerlink" title="函数readv和writev"></a>函数readv和writev</h2><p>readv和 writev函数用于在一次函数调用中读、写多个非连续缓冲区。有时也将这两个函数称为散布读(scatter read)和聚集写(gather write)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> readv(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">struct</span> iovec *iov, <span class="keyword">int</span> iovcnt);</div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> writev(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">struct</span> iovec *iov, <span class="keyword">int</span> iovcnt);</div><div class="line"></div><div class="line"><span class="comment">// Both return: number of bytes read or written, −1 on error</span></div></pre></td></tr></table></figure>
<p>其中中间参数的数据结构iov如下：</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254044988663.jpg" alt=""></p>
<h2 id="函数readn和writen"><a href="#函数readn和writen" class="headerlink" title="函数readn和writen"></a>函数readn和writen</h2><p>管道、FIFO以及某些设备(特别是终端和网络)有下列两种性质</p>
<ol>
<li>一次read操作所返回的数据可能少于所要求的数据,即使还没达到文件尾端也可能是这样。这不是一个错误,应当继续读该设备。</li>
<li>一次 write操作的返回值也可能少于指定输出的字节数。</li>
</ol>
<p>下面两个函数 readn和 writen的功能分别是读、写指定的N字节数据,并处理返回值可能小于要求值的情况。这两个函数只是按需多次调用xead和 write直至读、写了N字节数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span> </span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); </div><div class="line"><span class="keyword">ssize_t</span> writen(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); </div><div class="line"></div><div class="line"><span class="comment">// Both return: number of bytes read or written, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="存储映射I-O"><a href="#存储映射I-O" class="headerlink" title="存储映射I/O"></a>存储映射I/O</h2><p>存储映射I/O(memory-mapped I/O)能<strong>将一个磁盘文件映射到存储空间中的一个缓冲区上</strong>。于是,当从缓冲区中取数据时,就相当于读文件中的相应字节。与此类似,将数据存入缓冲区时相应字节就自动写入文件。这样,就可以在不使用read和 write的情况下执行I/O。</p>
<p>为了使用这种功能,应首先告诉内核将一个给定的文件映射到一个存储区域中。这是由mmap函数实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> ﬂag, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> off )</span></span>; </div><div class="line"><span class="comment">// Returns: starting address of mapped region if OK, MAP_FAILED on error</span></div></pre></td></tr></table></figure>
<p>addr参数用于指定映射存储区的起始地址。通常将其设置为0,这表示由系统选择该映射区的起始地址。此函数的返回值是该映射区的起始地址。</p>
<p>fd参数是指定要被映射文件的描述符。在文件映射到地址空间之前,必须先打开该文件。len参数是映射的字节数,off是要映射字节在文件中的起始偏移量</p>
<p>prot参数指定了映射存储区的保护要求</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254123464536.jpg" alt=""></p>
<p>存储映射文件的基本情况</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254124013724.jpg" alt=""></p>
<p>flag参数可以使用的属性：</p>
<ul>
<li>MAP_FIXED  返回值必须等于addr。因为这不利于可移植性,所以不鼓励使用此标志。</li>
<li>MAP_SHARED  这一标志描述了本进程对映射区所进行的存储操作的配置。此标志指定存储操作修改映射文件,也就是,存储操作相当于对该文件的 write</li>
<li>MAP_PRIVATE  本标志说明,对映射区的存储操作导致创建该映射文件的一个私有副本</li>
</ul>
<p>off的值和addr的值(如果指定了 MAP_FIXED)通常被要求是系统虚拟存储页长度的倍数</p>
<p>与映射区相关的信号有 SIGSEGV和 SIGBUS:</p>
<ul>
<li>信号 SIGSEGV通常用于指示进程试图访问对它不可用的存储区。如果映射存储区被map指定成了只读的,那么进程试图将数据存入这个映射存储区的时候,也会产生此信号。</li>
<li>如果映射区的某个部分在访问时已不存在,则产生 SIGBUS信号。例如,假设用文件长度映射了一个文件,但在引用该映射区之前,另一个进程已将该文件截断。此时,如果进程试图访问对应于该文件已截去部分的映射区,将会接收到 SIGBUS信号</li>
</ul>
<p><strong>子进程能通过fork继承存储映射区</strong>(因为子进程复制父进程地址空间,而存储映射区是该地址空间的一个部分），新程序则不能通过exec继承存储映射区</p>
<p>调用mprotect可以更改一个现有映射的权限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>如果共享映射中的页已修改,那么可以调用 msync将该页冲洗到被映射的文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> ﬂags)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>如果映射是私有的,那么不修改被映射的文件。与其他存储映射函数一样,地址必须与页边界对齐。</p>
<p>当进程终止时,会自动解除存储映射区的映射,或者直接调用 munmap函数也可以解除映射区。关闭映射存储区时使用的文件描述符并不解除映射区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第14章 高级I/O 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 守护进程</title>
    <link href="https://www.liuin.cn/2018/05/04/APUE-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
    <id>https://www.liuin.cn/2018/05/04/APUE-守护进程/</id>
    <published>2018-05-04T01:06:24.000Z</published>
    <updated>2018-05-04T01:35:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第13章 守护进程 笔记</p>
<a id="more"></a>
<p>守护进程(daemon)是生存期长的一种进程。它们常常在系统引导装入时启动,仅在系统关闭时才终止。因为它们没有控制终端,所以说它们是在后台运行的。UNIX系统有很多守护进程,它们执行日常事务活动。</p>
<h2 id="守护进程的特征"><a href="#守护进程的特征" class="headerlink" title="守护进程的特征"></a>守护进程的特征</h2><p>系统进程依赖于操作系统实现。父进程ID为0的各进程通常是内核进程,它们作为系统引导装入过程的一部分而启动。(init是个例外,它是一个由内核在引导装入时启动的用户层次的命令。)内核进程是特殊的,通常存在于系统的整个生命期中。它们以超级用户特权运行,无控制终端,无命令行。</p>
<p>对于需要在进程上下文执行工作但却不被用户层进程上下文调用的每一个内核组件,通常有它自己的内核守护进程。例如,在Linux中</p>
<ul>
<li><code>kswapd</code>守护进程也称为内存换页守护进程。它支持虚拟内存子系统在经过一段时间后将脏页面慢慢地写回磁盘来回收这些页面</li>
<li><code>f1ush</code>守护进程在可用内存达到设置的最小阅值时将脏页面冲洗至磁盘。它也定期地将脏页面冲洗回磁盘来减少在系统出现故障时发生的数据丢失。多个冲洗守护进程可以同时存在,每个写回的设备都有一个冲洗守护进程。</li>
<li><code>sync_supers</code>守护进程定期将文件系统元数据冲洗至磁盘。</li>
<li><code>jbd</code>守护进程帮助实现了ext4文件系统中的日志功能。</li>
<li><code>cron</code>守护进程在定期安排的日期和时间执行命令。许多系统管理任务是通过<code>cron</code>每隔一段固定的时间就运行相关程序而得以实现的。</li>
<li><code>atd</code>守护进程与cron类似,它允许用户在指定的时间执行任务,但是每个任务它只执行一次,而非在定期安排的时间反复执行。</li>
<li><code>cupsa</code>守护进程是个打印假脱机进程,它处理对系统提出的各个打印请求。</li>
<li><code>sshd</code>守护进程提供了安全的远程登录和执行设施注意,大多数守护进程都以超级用户(root)特权运行。所有的守护进程都没有控制终端其终端名设置为问号。</li>
</ul>
<p>内核守护进程以无控制终端方式启动。用户层守护进程缺少控制终端可能是守护进程调用了 setid的结果。</p>
<h2 id="编程规则"><a href="#编程规则" class="headerlink" title="编程规则"></a>编程规则</h2><p>在编写守护进程程序时需遵循一些基本规则,以防止产生不必要的交互作用。下面先说明这些规则,</p>
<ol>
<li>首先要做的是调用<code>umask</code>将文件模式创建屏蔽字设置为一个已知值(通常是0)。由继承得来的文件模式创建屏蔽字可能会被设置为拒绝某些权限。如果守护进程要创建文件,那么它可能要设置特定的权限。</li>
<li>调用fork,然后使父进程exit。这样做实现了下面几点。第一,如果该守护进程是作为一条简单的shell命令启动的,那么父进程终止会让shell认为这条命令已经执行完毕。第二,虽然子进程继承了父进程的进程组ID,但获得了一个新的进程ID,这就保证了子进程不是一个进程组的组长进程。这是下面将要进行的setid调用的先决条件。</li>
<li>调用setid创建一个新会话，执行3步：成为新会话的首进程、成为新进程组的组长进程、没有控制终端</li>
<li>将当前工作目录更改为根目录</li>
<li>关闭不再需要的文件描述符</li>
<li>某些守护进程打开<code>/dev/null</code>使其具有文件描述符0、1和2,这样,任何一个试图读标准输入、写标准输出或标准错误的库例程都不会产生任何效果。因为守护进程并不与终端设备相关联所以其输出无处显示,也无处从交互式用户那里接收输入。</li>
</ol>
<h2 id="出错记录"><a href="#出错记录" class="headerlink" title="出错记录"></a>出错记录</h2><p>守护进程存在的一个问题是如何处理出错消息。因为它本就不应该有控制终端,所以不能只是简单地写到标准错误上。我们不希望所有守护进程都写到控制台设备上,因为在很多工作站上控制台设备都运行着一个窗口系统。我们也不希望每个守护进程将它自己的出错消息写到一个单独的文件中。对任何一个系统管理人员而言,如果要关心哪一个守护进程写到哪一个记录文件中并定期地检查这些文件,那么一定会使他感到头痛。所以,需要有一个集中的守护进程出错记录设施。</p>
<p>BSD的<code>sys1og</code>设施得到了广泛的应用。大多数守护进程都使用这一设施</p>
<p>有下面3种产生日志消息的方法：</p>
<ol>
<li>内核例程可以调用log函数</li>
<li>大多数用户进程(守护进程)调用sys1og(3)函数来产生日志消息</li>
<li>无论一个用户进程是在此主机上,还是在通过TCP/IP网络连接到此主机的其他主机上,都可将日志消息发向UDP端口514。</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-05-04-15253968653919.jpg" alt=""></p>
<p>通常, syslogd守护进程读取所有3种格式的日志消息。此守护进程在启动时读一个配置文件,其文件名一般为<code>/etc/sys1og.conf</code>,该文件决定了不同种类的消息应送向何处。例如,紧急消息可发送至系统管理员(若已登录),并在控制台上打印,而警告消息则可记录到一个文件中。</p>
<p>该设施的接口是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">openlog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ident, <span class="keyword">int</span> option, <span class="keyword">int</span> facility)</span></span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">(<span class="keyword">void</span>)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setlogmask</span><span class="params">(<span class="keyword">int</span> maskpri)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: previous log priority mask value</span></div></pre></td></tr></table></figure></p>
<h2 id="单实例守护进程"><a href="#单实例守护进程" class="headerlink" title="单实例守护进程"></a>单实例守护进程</h2><p>为了正常运作,某些守护进程会实现为,在任一时刻只运行该守护进程的一个副本。例如,这种守护进程可能需要排它地访问一个设备。对cron守护进程而言,如果同时有多个实例运行,那么每个副本都可能试图开始某个预定的操作,于是造成该操作的重复执行,这很可能导致出错。</p>
<p>文件和记录锁机制为一种方法提供了基础,该方法保证一个守护进程只有一个副本在运行。</p>
<h2 id="守护进程的惯例"><a href="#守护进程的惯例" class="headerlink" title="守护进程的惯例"></a>守护进程的惯例</h2><p>在UNIX系统中,守护进程遵循下列通用惯例：</p>
<ol>
<li>若守护进程使用锁文件,那么该文件通常存储在<code>/var/run</code>目录中</li>
<li>若守护进程支持配置选项,那么配置文件通常存放在<code>/etc</code>目录中</li>
<li>守护进程可用命令行启动,但通常它们是由系统初始化脚本之一(<code>/etc/rc*</code>或<code>etc/init.d/*</code>)启动的。如果在守护进程终止时,应当自动地重新启动它,则我们可在<code>/etc/inittab</code>中为该守护进程包括 respawn记录项,这样,init就将重新启动该守护进程。</li>
<li>若一个守护进程有一个配置文件,那么当该守护进程启动时会读该文件,但在此之后般就不会再查看它。若某个管理员更改了配置文件,那么该守护进程可能需要被停止,然后再启动,以使配置文件的更改生效。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第13章 守护进程 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 线程控制</title>
    <link href="https://www.liuin.cn/2018/05/02/APUE-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://www.liuin.cn/2018/05/02/APUE-线程控制/</id>
    <published>2018-05-02T09:15:42.000Z</published>
    <updated>2018-05-03T13:33:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第12章 线程控制 笔记</p>
<a id="more"></a>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>pthread接口允许我们通过设置每个对象关联的不同属性来细调线程和同步对象的行为。通常,管理这些属性的函数都遵循相同的模式</p>
<ul>
<li>每个对象与它自己类型的属性对象进行关联</li>
<li>有一个初始化函数,把属性设置为默认值。</li>
<li>还有一个销毁属性对象的函数。</li>
<li>每个属性都有一个从属性对象中获取属性值的函数</li>
<li>每一个属性都有一个设置属性值的函数</li>
</ul>
<p>可以使用<code>pthread_attr_t</code>结构修改线程默认属性,并把这些属性与创建的线程联系起来。可以使用 <code>pthread_attr_init</code>函数初始化<code>pthread_attr_t</code>结构。在调用<code>pthread_attr_init</code>以后, <code>pthread_attr_t</code>结构所包含的就是操作系统实现支持的所有线程属性的默认值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>POSIX.1定义的线程属性：</p>
<p><img src="https://data2.liuin.cn/2018-05-02-15252530369029.jpg" alt=""></p>
<p>对<code>detachstate</code>属性进行管理的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *detachstate)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> detachstate)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>对线程栈属性进行管理的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstack</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">void</span> **<span class="keyword">restrict</span> stackaddr, <span class="keyword">size_t</span> *<span class="keyword">restrict</span> stacksize)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstack</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *stackaddr, <span class="keyword">size_t</span> stacksize)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>对于进程来说,虚地址空间的大小是固定的。因为进程中只有一个栈,所以它的大小通常不是问题。但对于线程来说,同样大小的虚地址空间必须被所有的线程栈共享。如果应用程序使用了许多线程,以致这些线程栈的累计大小超过了可用的虚地址空间,就需要减少默认的线程栈大小。</p>
<p>另一方面,如果线程调用的函数分配了大量的自动变量,或者调用的函数涉及许多很深的栈帧(stack frame),那么需要的栈大小可能要比默认的大。</p>
<p>如果线程栈的虚地址空间都用完了,那可以使用ma1loc或者mnap来为可替代的栈分配空间,并用<code>pthread _attr__setstack</code>函数来改变新建线程的栈位置。</p>
<p>管理线程属性<code>stacksize</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstacksize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">size_t</span> *<span class="keyword">restrict</span> stacksize)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstacksize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> stacksize)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>如果希望改变默认的栈大小,但又不想自己处理线程栈的分配问题,这时使用 <code>pthread_attr_setstacksize</code>函数就非常有用。</p>
<p>管理线程属性<code>guardsize</code>属性的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getguardsize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">size_t</span> *<span class="keyword">restrict</span> guardsize)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setguardsize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> guardsize)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h2 id="同步属性"><a href="#同步属性" class="headerlink" title="同步属性"></a>同步属性</h2><h3 id="互斥量属性"><a href="#互斥量属性" class="headerlink" title="互斥量属性"></a>互斥量属性</h3><p>互斥量属性是用<code>pthread_mutexattr_t</code>结构表示的，其初始化和销毁函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>值得注意的3个属性是:进程共享属性、健壮属性以及类型属性</p>
<p>存在这样的机制:允许相互独立的多个进程把同一个内存数据块映射到它们各自独立的地址空间中。就像多个线程访问共享数据一样,多个进程访问共享数据通常也需要同步。如果进程共享互斥量属性设置为<code>PTHREAD_PROCESS_SHARED</code>,从多个进程彼此之间共享的内存数据块中分配的互斥量就可以用于这些进程的同步</p>
<p>获得和修改进程共享属性的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>进程共享互斥量属性设置为<code>PTHREAD_PROCESS_PRIVATE</code>时,允许pthread线程库提供更有效的互斥量实现,这在多线程应用程序中是默认的情况。在多个进程共享多个互斥量的情况下,pthread线程库可以限制开销较大的互斥量实现。</p>
<p>互斥量健壮属性与在多个进程间共享的互斥量有关。这意味着,当持有互斥量的进程终止时需要解决互斥量状态恢复的问题。这种情况发生时,互斥量处于锁定状态,恢复起来很困难。</p>
<p>获取和设置互斥量健壮属性的函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getrobust</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> robust)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setrobust</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> robust)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure></p>
<h3 id="读写锁属性"><a href="#读写锁属性" class="headerlink" title="读写锁属性"></a>读写锁属性</h3><p>读写锁和互斥量类似，都有属性，用数据结构<code>pthread_rwlockattr_t</code>表示，初始化和反初始化函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_init</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_destroy</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>读写锁支持的唯一属性是进程共享属性。它与互斥量的进程共享属性是相同的。有一对函数用于读取和设置读写锁的进程共享属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_setpshared</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="条件变量属性"><a href="#条件变量属性" class="headerlink" title="条件变量属性"></a>条件变量属性</h3><p>目前定义了条件变量的两个属性:<strong>进程共享属性和时钟属性</strong>，用数据结构<code>pthread_condattr_t</code>表示，初始化和反初始化函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_init</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_destroy</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>获取和设置进程共享属性的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_setpshared</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>时钟属性控制计算<code>pthread_cond_timedwait</code>函数的超时参数(sp)时采用的是哪个时钟，相关函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_getclock</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">clockid_t</span> *<span class="keyword">restrict</span> clock_id)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_setclock</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr, <span class="keyword">clockid_t</span> clock_id)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="屏障属性"><a href="#屏障属性" class="headerlink" title="屏障属性"></a>屏障属性</h3><p>初始化和反初始化函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_init</span><span class="params">(<span class="keyword">pthread_barrierattr_t</span> *attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_destroy</span><span class="params">(<span class="keyword">pthread_barrierattr_t</span> *attr)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>目前定义的屏障属性只有进程共享属性,它控制着屏障是可以被多进程的线程使用,还是只能被初始化屏障的进程内的多线程使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_barrierattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_setpshared</span><span class="params">(<span class="keyword">pthread_barrierattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h2 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h2><p>多个控制线程在相同的时间有可能调用相同的函数。如果一个函数在相同的时间点可以被多个线程安全地调用,就称该函数是线程安全的。</p>
<p>如果一个函数对多个线程来说是可重入的,就说这个函数就是线程安全的。但这并不能说明对信号处理程序来说该函数也是可重入的。如果函数对异步信号处理程序的重入是安全的,那么就可以说函数是异步信号安全的。</p>
<h2 id="线程特定数据"><a href="#线程特定数据" class="headerlink" title="线程特定数据"></a>线程特定数据</h2><p>线程特定数据( thread-specific data),也称为<strong>线程私有数据</strong>( thread-private data.),是存储和查询某个特定线程相关数据的一种机制。我们把这种数据称为线程特定数据或线程私有数据的原因是,我们希望每个线程可以访问它自己单独的数据副本,而不需要担心与其他线程的同步访问问题</p>
<p>设置线程私有数据的原因：</p>
<ol>
<li>有时候需要维护基于每线程(per-thread)的数据，即使线程ID确实是小而连续的整数,我们可能还希望有一些额外的保护,防止某个线程的数据与其他线程的数据相混淆。</li>
<li>它提供了让基于进程的接口适应多线程环境的机制。一个很明显的例子就是errno，以前的接口(线程出现以前)把errno定义为进程上下文中全局可访问的整数。系统调用和库例程在调用或执行失败时设置把它作为操作失败时的附属结果。为了让线程也能够使用那些原本基于进程的系统调用和库例程, errno被重新定义为线程私有数据。这样,一个线程做了重置 errno的操作也不会影响进程中其他线程的 errno值。</li>
</ol>
<p>在分配线程特定数据之前,需要创建与该数据关联的键。这个键将用于获取对线程特定数据的访问。使用 <code>pthread_key_create</code>创建一个键</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt; </div><div class="line"></div><div class="line">int pthread_key_create(pthread_key_t *keyp, void (*destructor)(void *)); </div><div class="line"></div><div class="line">// Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
<p>创建的键存储在keyp指向的内存单元中,这个键可以被进程中的所有线程使用,但<strong>每个线程把这个键与不同的线程特定数据地址进行关联</strong>。创建新键时,每个线程的数据地址设为空值。</p>
<p>除了创建键以外, pthread<em>key</em> create可以为该键关联一个可选择的析构函数。当这个线程退出时,如果数据地址已经被置为非空值,那么析构函数就会被调用,它唯一的参数就是该数据地址。如果传入的析构函数为空,就表明没有析构函数与这个键关联。</p>
<p>线程通常使用malloc为线程特定数据分配内存。析构函数通常释放已分配的内存。如果线程在没有释放内存之前就退出了,那么这块内存就会丢失,即线程所属进程就出现了内存泄漏。</p>
<p>线程退出时,线程特定数据的析构函数将按照操作系统实现中定义的顺序被调用。析构函数可能会调用另一个函数,该函数可能会创建新的线程特定数据,并且把这个数据与当前的键关联起来。当所有的析构函数都调用完成以后,系统会检查是否还有非空的线程特定数据值与键关联,如果有的话,再次调用析构函数。</p>
<p>对所有的线程,我们都可以通过调用<code>pthread_key_de1ete</code>来取消键与线程特定数据值之间的关联关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_delete</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>上述函数不会激活与键关联的析构函数</p>
<p>需要确保分配的键并不会由于在初始化阶段的竞争而发生变动。解决这种竞争的方法是使用<code>pthread_once</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line"></div><div class="line">pthread_once_t initﬂag = PTHREAD_ONCE_INIT;</div><div class="line"></div><div class="line">int pthread_once(pthread_once_t *initﬂag, void (*initfn)(void));</div><div class="line"></div><div class="line">// Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
<p>initflag必须是一个非本地变量(如全局变量或静态变量),而且必须初始化为<code>PTHREAD_ONCE_INIT</code>。如果每个线程都调用 pthread_once,系统就能保证初始化例程initfn只被调用一次,即系统首次调用 pthread_once时。</p>
<p>键一旦创建以后,就可以通过调用<code>pthread_setspecific</code>函数把键和线程特定数据关联起来。可以通过 <code>pthread_ getspecific</code>函数获得线程特定数据的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: thread-speciﬁc data value or NULL if no value has been associated with the key</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key, <span class="keyword">const</span> <span class="keyword">void</span> *value)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h2 id="取消选项"><a href="#取消选项" class="headerlink" title="取消选项"></a>取消选项</h2><p>有两个线程属性并没有包含在<code>pthread_attr_t</code>结构中,它们是可取消状态和可取消类型。这两个属性影响着线程在响应<code>pthread_ cancel</code>函数调用时所呈现的行为</p>
<p>可取消状态属性可以是<code>PTHREAD_CANCEL_ENABLE</code>,也可以是<code>PTHREAD_CANCEL_DISABLE</code>，线程可以通过调用`pthread_setcancel_state修改它的可取消状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcancelstate</span><span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span> *oldstate)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p><code>pthread_setcancel_state</code>把当前的可取消状态设置为state,把原来的可取消状态存储在由oldstate指向的内存单元,<strong>这两步是一个原子操作</strong>。</p>
<p><code>pthread_cancel</code>调用并不等待线程终止。在默认情况下,线程在取消请求发出以后还是继续运行,直到线程到达某个取消点。取消点是线程检查它是否被取消的一个位置,如果取消了,则按照请求行事。</p>
<p>线程启动时默认的可取消状态是<code>PTHREAD_CANCEL_ENABLE</code>。当状态设为<code>PTHREAD_CANCEL_DISABLE</code>时,对<code>pthread_cancel</code>的调用并不会杀死线程。相反,取消请求对这个线程来说还处于挂起状态,当取消状态变为<code>PTHREAD_CANCEL_ENABLE</code>时,线程将在下一个取消点上对所有挂起的取消请求进行处理</p>
<p>可以调用<code>pthread_testcancel</code>函数在程序中添加自己的取消点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_testcancel</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>默认的取消类型也称为推迟取消。调用<code>pthread_cancel</code>以后,在线程到达取消点之前,并不会出现真正的取消。可以通过调用<code>pthread_setcanceltype</code>来修改取消类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> *oldtype)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>有两种取消类型：推迟取消和异步取消，异步取消与推迟取消不同,因为使用异步取消时,线程可以在任意时间撤消,不是非得遇到取消点才能被取消</p>
<h2 id="线程和信号"><a href="#线程和信号" class="headerlink" title="线程和信号"></a>线程和信号</h2><p>每个线程都有自己的信号屏蔽字,但是信号的处理是进程中所有线程共享的。这意味着单个线程可以阻止某些信号,但当某个线程修改了与某个给定信号相关的处理行为以后,所有的线程都必须共享这个处理行为的改变。这样,如果一个线程选择忽略某个给定信号,那么另一个线程就可以通过以下两种方式撤消上述线程的信号选择:恢复信号的默认处理行为,或者为信号设置个新的信号处理程序</p>
<p>进程使用<code>sigprocmask</code>函数来阻止信号发送。线程使用的函数是<code>pthread_sigmask</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_sigmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> oset)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>pthread_sigmask函数与sigprocmask函数基本相同,不过pthread_sigmask工作在线程中,而且失败时返回错误码,不再像sigprocmask中那样设置errno并返回-1。set参数包含线程用于修改信号屏蔽字的信号集。how参数可以取下列3个值之一: SIG_BLOCK,把信号集添加到线程信号屏蔽字中, SIG_SETMASK,用信号集替换线程的信号屏蔽字;SIG_UNBLOCK,从线程信号屏蔽字中移除信号集。如果oset参数不为空,线程之前的信号屏蔽字就存储在它指向的siget_t结构中。线程可以通过把set参数设置为NULL,并把oser参数设置为si gset_t结构的地址,来获取当前的信号屏蔽字。这种情况中的how参数会被忽略</p>
<p>线程可以通过调用sigwait等待一个或多个信号的出现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigwait</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">int</span> *<span class="keyword">restrict</span> signop)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>set参数指定了线程等待的信号集。返回时, signop指向的整数将包含发送信号的数量</p>
<p>为了避免错误行为发生,线程在调用sigwait之前,必须阻塞那些它正在等待的信号</p>
<p>sigwait函数会原子地取消信号集的阻塞状态,直到有新的信号被递送</p>
<p>要把信号发送给进程,可以调用ki11。要把信号发送给线程,可以调用 pthread_kill<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_kill</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">int</span> signo)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure></p>
<h2 id="线程和fork"><a href="#线程和fork" class="headerlink" title="线程和fork"></a>线程和fork</h2><p>当线程调用fork时，就为子进程创建整个进程地址空间的副本</p>
<p>子进程通过继承整个地址空间的副本,还从父进程那儿继承了每个互斥量、读写锁和条件变量的状态。如果父进程包含一个以上的线程,子进程在fork返回以后,如果紧接着不是马上调用exec的话,就需要清理锁状态</p>
<p>在子进程内部,只存在一个线程,它是由父进程中调用fork的线程的副本构成的。</p>
<p>在多线程的进程中,为了避免不一致状态的问题, POSIX.1声明,在fork返回和子进程调用其中一个exec函数之间,子进程只能调用异步信号安全的函数。这就限制了在调用exec之前子进程能做什么,但不涉及子进程中锁状态的问题。</p>
<p>要清除锁状态，可以通过调用pthread_atfork函数建立fork处理程序</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt; </div><div class="line"></div><div class="line">int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void)); </div><div class="line"></div><div class="line">// Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
<p>用pthread_atfork函数最多可以安装3个帮助清理锁的函数。 <code>prepare_fork</code>处理程序由父进程在fork创建子进程前调用。这个fork处理程序的任务是<strong>获取父进程定义的所有锁</strong>。 <code>parent_fork</code>处理程序是在fork创建子进程以后、返回之前在父进程上下文中调用的。这个fok处理程序的任务是对<code>prepare_fork</code>处理程序获取的所有锁进行解锁。<code>child_fork</code>处理程序在fork返回之前在子进程上下文中调用。与 <code>parent_fork</code>处理程序一样, <code>child_fork</code>处理程序也必须释放<code>prepare_fork</code>处理程序获取的所有锁</p>
<h2 id="线程和I-O"><a href="#线程和I-O" class="headerlink" title="线程和I/O"></a>线程和I/O</h2><p>在多线程环境下，使用的都是pread和pwrite函数，这些函数都是源自操作，使得多线程下所有线程可以共享相同的文件描述符。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第12章 线程控制 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 线程</title>
    <link href="https://www.liuin.cn/2018/05/02/APUE-%E7%BA%BF%E7%A8%8B/"/>
    <id>https://www.liuin.cn/2018/05/02/APUE-线程/</id>
    <published>2018-05-02T06:34:59.000Z</published>
    <updated>2018-05-02T07:35:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第11章 线程 笔记</p>
<a id="more"></a>
<h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p>在程序设计时就可以把进程设计成在某一时刻能够做不止一件事,每个线程处理各自独立的任务。这种方法有很多好处。</p>
<ul>
<li>通过为每种事件类型分配单独的处理线程,可以简化处理异步事件的代码。每个线程在进行事件处理时可以采用同步编程模式,同步编程模式要比异步编程模式简单得多。</li>
<li>多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享，而多个线程自动地可以访问相同的存储地址空间和文件描述符</li>
<li>有些问题可以分解从而提高整个程序的吞吐量。在只有一个控制线程的情况下,一个单线程进程要完成多个任务,只需要把这些任务串行化。但有多个控制线程时,相互独立的任务的处理就可以交叉进行,此时只需要为每个任务分配一个单独的线程。</li>
<li>交互的程序同样可以通过使用多线程来改善响应时间,多线程可以把程序中处理用户输入输出的部分与其他部分分开。</li>
</ul>
<p>处理器的数量并不影响程序结构,所以不管处理器的个数多少,程序都可以通过使用线程得以简化。</p>
<p>每个线程都包含有表示执行环境所必需的信息,其中包括进程中标识线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、 errno变量以及线程私有数据</p>
<p>一个进程的所有信息对该进程的所有线程都是共享的,包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符</p>
<h2 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h2><p>就像每个进程有一个进程ID一样,每个线程也有一个线程ID。进程ID在整个系统中是唯一的,但线程ID不同,线程ID只有在它所属的进程上下文中才有意义。</p>
<p>线程ID是用pthread_t数据类型来表示的,实现的时候可以用一个结构来代表pthread_t数据类型,所以可移植的操作系统实现不能把它作为整数处理。因此必须使用一个函数来对两个线程ID进行比较:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> tid1, <span class="keyword">pthread_t</span> tid2)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: nonzero if equal, 0 otherwise</span></div></pre></td></tr></table></figure>
<p>线程可以通过调用 pthread_se1f函数获得自身的线程ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: the thread ID of the calling thread</span></div></pre></td></tr></table></figure>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>新增的线程可以通过调用 pthread_create函数创建。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt; </div><div class="line"></div><div class="line">int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(*start_rtn)(void *), void *restrict arg); </div><div class="line"></div><div class="line">// Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
<p>当pthread_create成功返回时,新创建线程的线程ID会被设置成<code>tidp</code>指向的内存单元，<code>attr</code>参数用于定制各种不同的线程属性。新创建的线程从<code>start_rtn</code>函数的地址开始运行,该函数只有一个无类型指针参数<code>arg</code>。如果需要向<code>start_run</code>函数传递的参数有一个以上,那么需要把这些参数放到一个结构中,然后把这个结构的地址作为<code>arg</code>参数传入</p>
<p>线程创建时并不能保证哪个线程会先运行:是新创建的线程,还是调用线程。新创建的线程可以访问进程的地址空间,并且继承调用线程的浮点环境和信号屏蔽字,但是该线程的挂起信号集会被清除。</p>
<p>注意, pthread函数在调用失败时通常会返回错误码,它们并不像其他的 POSIX函数一样设置 errno。每个线程都提供 errno的副本,这只是为了与使用 errno的现有函数兼容。</p>
<h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>单个线程可以通过3种方式退出,因此可以在不终止整个进程的情况下,停止它的控制流。</p>
<ol>
<li>线程可以简单地从启动例程中返回,返回值是线程的退出码。</li>
<li>线程可以被同一进程中的其他线程取消。</li>
<li>线程调用 pthread_ex1t</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *rval_ptr)</span></span>;</div></pre></td></tr></table></figure>
<p><code>rval_ptr</code>参数是一个无类型指针,与传给启动例程的单个参数类似。进程中的其他线程也可以通过调用 <code>pthread_join</code>函数访问到这个指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **rval_ptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>调用线程将一直阻塞,直到指定的线程调用<code>pthread_exit</code>，从启动例程中返回或者被取消。如果线程简单地从它的启动例程返回, <code>rval_ptr</code>就包含返回码。如果线程被取消,由<code>rval_ pir</code>指定的内存单元就设置为<code>PTHREAD_CANCELED</code></p>
<p>可以通过调用<code>pthread_join</code>自动把线程置于分离状态(马上就会讨论到),这样资源就可以恢复。如果线程已经处于分离状态, <code>pthread_join</code>调用就会失败,返回<code>EINVAL</code>,尽管这种行为是与具体实现相关的。</p>
<p>如果对线程的返回值并不感兴趣,那么可以把 rval_ptr设置为NULL。在这种情况下,调用pthread_join函数可以等待指定的线程终止,但并不获取线程的终止状态。</p>
<p>线程可以通过调用<code>pthread_cancel</code>函数来请求取消同一进程中的其他线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>线程可以安排它退出时需要调用的函数,这与进程在退出时可以用<code>atexit</code>函数安排退出是类似的。这样的函数称为线程清理处理程序( thread cleanup handler)。一个线程可以建立多个清理处理程序。处理程序记录在栈中,也就是说,它们的<strong>执行顺序与它们注册时相反</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line"></div><div class="line">void pthread_cleanup_push(void (*rtn)(void *), void *arg);</div><div class="line"></div><div class="line">void pthread_cleanup_pop(int execute);</div></pre></td></tr></table></figure>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当一个线程可以修改的变量,其他线程也可以读取或者修改的时候,我们就需要对这些线程进行同步,确保它们在访问变量的存储内容时不会访问到无效的值。</p>
<p>当一个线程修改变量时,其他线程在读取这个变量时可能会看到一个不一致的值。在变量修改时间多于一个存储器访问周期的处理器结构中,当存储器读与存储器写这两个周期交叉时,这种不一致就会出现。</p>
<p>为了解决这个问题,线程不得不使用锁,同一时间只允许一个线程访问该变量</p>
<p><img src="https://data2.liuin.cn/2018-05-02-15252443887056.jpg" alt=""></p>
<p>两个或多个线程试图在同一时间修改同一变量时,也需要进行同步</p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>可以使用 pthread的互斥接口来保护数据,确保同一时间只有一个线程访问数据。<strong>互斥量(mutex)</strong>从本质上说是一把锁,在访问共享资源前对互斥量进行设置(加锁),在访问完成后释放(解锁)互斥量。</p>
<p>互斥变量是用<code>pthread_mutex_t</code>数据类型表示的，使用互斥量之前必须要初始化，动态分配的互斥量在释放内存之前要调用<code>pthread_mutex_destory</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>要用默认的属性初始化互斥量,只需把attr设为NULL。</p>
<p>对互斥量进行加锁,需要调用<code>pthread_mutex_lock</code>。如果互斥量已经上锁,调用线程将阻塞直到互斥量被解锁。对互斥量解锁,需要调用<code>pthread_mutex_un1ock</code>。</p>
<p>如果线程不希望被阻塞,它可以使用<code>pthread_mutex_try1ock</code>尝试对互斥量进行加锁。如果调用 <code>pthread_mutex_try1ock</code>时互斥量处于未锁住状态,那么<code>pthread_mutex_try1ock</code>将锁住互斥量,不会出现阻塞直接返回0,否则<code>pthread_mutex_try1ock</code>就会失败,不能锁住互斥量,返回 EBUSY。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>如果线程试图对同一个互斥量加锁两次,那么它自身就会陷入死锁状态,可以通过仔细控制互斥量加锁的顺序来避免死锁的发生。例如,假设需要对两个互斥量A和B同时加锁。如果所有线程总是在对互斥量B加锁之前锁住互斥量A,那么使用这两个互斥量就不会产生死锁(当然在其他的资源上仍可能出现死锁)。</p>
<p>采用顺序加锁的形式避免死锁。</p>
<h3 id="函数pthread-mutex-timelock"><a href="#函数pthread-mutex-timelock" class="headerlink" title="函数pthread_mutex_timelock"></a>函数pthread_mutex_timelock</h3><p>当线程试图获取一个已加锁的互斥量时,<code>pthread_mutex_timedlock</code>互斥量原语允许绑定线程阻塞时间。 <code>pthread_mutex_timedlock</code>函数与<code>pthread_mutex_timedlock</code>是基本等价的,但是在达到超时时间值时,<code>pthread_mutex_timedlock</code>不会对互斥量进行加锁,而是返回错误码 ETIME_DOUT。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; #include &lt;time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_timedlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁( reader-writer lock)与互斥量类似,不过读写锁允许更高的并行性。互斥量要么是锁住状态,要么就是不加锁状态,而且一次只有一个线程可以对其加锁。读写锁可以有3种状态:读模式下加锁状态,写模式下加锁状态,不加锁状态。一次只有一个线程可以占有写模式的读写锁,但是多个线程可以同时占有读模式的读写锁</p>
<p>读写锁非常适合于对数据结构读的次数远大于写的情况。读写锁也叫做共享互斥锁( shared-exclusive lock)。</p>
<p>初始化和销毁读写锁的函数和互斥量类似<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure></p>
<p>要在读模式下锁定读写锁,需要调用<code>pthread_rwlock_rdlock</code>。要在写模式下锁定读写锁,需要调用 <code>pthread_rwlock_wrlock</code>。不管以何种方式锁住读写锁,都可以调用<code>pthread_rw1ock_unlock</code>进行解锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>读写锁原语的条件版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="带有超时的读写锁"><a href="#带有超时的读写锁" class="headerlink" title="带有超时的读写锁"></a>带有超时的读写锁</h3><p>与互斥量一样，读写锁也有带有超时条件的加锁函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; #include &lt;time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedwrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量是线程可用的另一种同步机制。条件变量给多个线程提供了一个会合的场所。条件变量与互斥量一起使用时,允许线程以无竞争的方式等待特定的条件发生。</p>
<p>条件本身是由互斥量保护的。<strong>线程在改变条件状态之前必须首先锁住互斥量</strong>。</p>
<p>条件变量使用的数据结构<code>pthread_cond_t</code>，同理也有初始化和销毁的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>我们使用<code>pthread_cond_wait</code>等待条件变量变为真。如果在给定的时间内条件不能满足那么会生成一个返回错误码的变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>有两个函数可以用于通知线程条件已经满足。<code>pthread_cond_signa1</code>函数至少能唤醒一个等待该条件的线程,而<code>pthread_cond_broadcast</code>函数则能唤醒等待该条件的所有线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁与互斥量类似,但它不是通过休眠使进程阻塞,而是在获取锁之前一直处于忙等(自旋)阻塞状态。自旋锁可用于以下情况:锁被持有的时间短,而且线程并不希望在重新调度上花费太多的成本</p>
<p>自旋锁通常作为底层原语用于实现其他类型的锁。</p>
<p>当自旋锁用在非抢占式内核中时是非常有用的:除了提供互斥机制以外,它们会阻塞中断这样中断处理程序就不会让系统陷入死锁状态,因为它需要获取已被加锁的自旋锁(把中断想成是另一种抢占)。在这种类型的内核中,中断处理程序不能休眠,因此它们能用的同步原语只能是自旋锁。</p>
<p>初始化和销毁函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_init</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock, <span class="keyword">int</span> pshared)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_destroy</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>加锁解锁函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_lock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_trylock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_unlock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>屏障(barrier)是用户<strong>协调多个线程并行工作的同步机制</strong>。屏障允许每个线程等待,直到所有的合作线程都到达某一点,然后从该点继续执行。我们已经看到一种屏障,<code>pthread_jo1n</code>函数就是一种屏障,允许一个线程等待,直到另一个线程退出。</p>
<p>但是屏障对象的概念更广,它们允许任意数量的线程等待,直到所有的线程完成处理工作而线程不需要退出。所有线程达到屏障后可以接着工作。</p>
<p>初始化和销毁函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_init</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *<span class="keyword">restrict</span> barrier, <span class="keyword">const</span> <span class="keyword">pthread_barrierattr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_destroy</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>初始化屏障时,可以使用<code>count</code>参数指定在允许所有线程继续运行之前,必须到达屏障的线程数目。使用<code>attr</code>参数指定屏障对象的属性,设置atmr为NULL,用默认属性初始化屏障。</p>
<p>可以使用<code>pthread_barrier_wait</code>函数来表明,线程已完成工作,准备等所有其他线程赶上来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_wait</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 or PTHREAD_BARRIER_SERIAL_THREAD if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>一旦达到屏障计数值,而且线程处于非阻塞状态,屏障就可以被重用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第11章 线程 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 进程关系</title>
    <link href="https://www.liuin.cn/2018/05/01/APUE-%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/"/>
    <id>https://www.liuin.cn/2018/05/01/APUE-进程关系/</id>
    <published>2018-05-01T02:55:38.000Z</published>
    <updated>2018-05-01T06:28:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第9章 进程关系 笔记</p>
<a id="more"></a>
<h2 id="终端登录"><a href="#终端登录" class="headerlink" title="终端登录"></a>终端登录</h2><p>我们现在描述的过程用于经由终端登录至UNIX系统。该过程几乎与所使用的终端类型无关,所使用的终端可以是基于字符的终端、仿真基于字符终端的图形终端,或者运行窗口系统的图形终端。</p>
<ol>
<li>BSD终端登录</li>
</ol>
<p>系统管理者创建通常名为/etc/ttys的文件,其中,每个终端设备都有一行,每一行说明设备名和传到 getty程序的参数。</p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251450557245.jpg" alt=""></p>
<p>1ogin能处理多项工作。因为它得到了用户名,所以能调用<code>getpwnam</code>取得相应用户的口令文件登录项。然后调用<code>getpass</code>以显示提示“ Password:”,接着读用户键入的口令(自然,禁止回显用户键入的口令)。它调用 <code>crypt</code>将用户键入的口令加密,并与该用户在阴影口令文件中登录项的<code>pw_passwd</code>字段相比较。如果用户几次键入的口令都无效,则<code>1ogin</code>以参数1调用<code>exit</code>表示登录过程失败。父进程(init)了解到子进程的终止情况后,将再次调用<code>fork</code>,其后又执行了<code>getty</code>,对此终端重复上述过程。</p>
<p>如果用户正确登录，login就将完成如下工作：</p>
<ol>
<li>将当前工作目录更改为该用户的起始目录(chdir)。</li>
<li>调用 chown更改该终端的所有权,使登录用户成为它的所有者。将对该终端设备的访问权限改变成“用户读和写”。</li>
<li>调用setgid及initgroups设置进程的组ID</li>
<li>用login得到的所有信息初始化环境:起始目录(HOME)、shell(SHEL)用户名(USER和 LOGNAME)以及一个系统默认路径(PATH)。</li>
<li>1ogin进程更改为登录用户的用户ID( setuid)并调用该用户的登录 shell</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-05-01-15251453247541.jpg" alt=""></p>
<h2 id="网络登录"><a href="#网络登录" class="headerlink" title="网络登录"></a>网络登录</h2><p>通过串行终端登录至系统和经由网络登录至系统两者之间的主要(物理上的)区别是:网络登录时,在终端和计算机之间的连接不再是点到点的。在网络登录情况下,1ogin仅仅是一种可用的服务,这与其他网络服务(如FIP或SMIP)的性质相同</p>
<p>为使同一个软件既能处理终端登录,又能处理网络登录,系统使用了一种称为伪终端( pseudo terminal)的软件驱动程序,它仿真串行终端的运行行为,并将终端操作映射为网络操作,反之亦然。</p>
<ol>
<li>BSD网络登录</li>
</ol>
<p>作为系统启动的一部分,init调用一个 shell,,使其执行shell脚本/etc/rc。由此shell脚本启动一个守护进程 inetd。一旦此shell脚本终止, inetd的父进程就变成init。 inetd等待TCP/IP连接请求到达主机,而当一个连接请求到达时,它执行一次fork,然后生成的子进程exec适当的程序。</p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251533208482.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251534277316.jpg" alt=""></p>
<p>当通过终端或网络登录时,我们得到一个登录shell,其标准输入、标准输出和标准错误要么连接到一个终端设备,要么连接到一个伪终端设备上。</p>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><p>进程组是一个或多个进程的集合。通常,它们是在同一作业中结合起来的,同一进程组中的各进程接收来自同一终端的各种信号。每个进程组有一个唯一的进程组ID。进程组ID类似于进程ID——它是一个正整数,并可存放在pid_t数据类型中。函数 getpgrp返回调用进程的进程组ID。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getpgrp(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: process group ID of calling process</span></div></pre></td></tr></table></figure>
<p>getpgid函数返回指定进程所在的进程组ID：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getpgid(<span class="keyword">pid_t</span> pid);</div><div class="line"></div><div class="line"><span class="comment">// Returns: process group ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>每个进程组有一个组长进程。组长进程的进程组ID等于其进程ID。</p>
<p>进程组组长可以创建一个进程组、创建该组中的进程,然后终止。<strong>只要在某个进程组中有个进程存在,则该进程组就存在,这与其组长进程是否终止无关</strong>。从进程组创建开始到其中最后一个进程离开为止的时间区间称为进程组的生命期。某个进程组中的最后一个进程可以终止,也可以转移到另一个进程组</p>
<p>进程调用setpgid可以加入一个现有的进程组或者创建一个新进程组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>一个进程只能为它自己或它的子进程设置进程组ID。在它的子进程调用了exec后,它就不再更改该子进程的进程组ID</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话( session)是一个或多个进程组的集合</p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251538207763.jpg" alt=""></p>
<p>通常是由shell管道将几个进程编成一组的。</p>
<p>进程调用setsid函数建立一个新会话</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> setsid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: process group ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>如果调用此函数的进程不是一个进程组的组长,则此函数创建个新会话。具体会发生以下3件事。</p>
<ol>
<li>进程变成新会话的会话首进程( session leader,会话首进程是创建该会话的进程)。此时,该进程是新会话中的唯一进程</li>
<li>该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID。</li>
<li>该进程没有控制终端(下一节讨论控制终端)。如果在调用 setid之前该进程有一个控制终端,那么这种联系也被切断。</li>
</ol>
<p>如果该调用进程已经是一个进程组的组长,则此函数返回出错。为了保证不处于这种情况,通常先调用fork,然后使其父进程终止,而子进程则继续。因为子进程继承了父进程的进程组ID,而其进程ID则是新分配的,两者不可能相等,这就保证了子进程不是一个进程组的组长</p>
<p>会话首进程是具有唯一进程ID的单个进程,所以可以将会话首进程的进程ID视为会话ID</p>
<p>getsid函数返回会话首进程的进程组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getsid(<span class="keyword">pid_t</span> pid); </div><div class="line"></div><div class="line"><span class="comment">// Returns: session leader’s process group ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>如若pid是0, getsid返回调用进程的会话首进程的进程组ID。出于安全方面的考虑些实现有如下限制:如若pid并不属于调用者所在的会话,那么调用进程就不能得到该会话首进程的进程组ID</p>
<h2 id="控制终端"><a href="#控制终端" class="headerlink" title="控制终端"></a>控制终端</h2><p>会话和进程组还有一些其他特性</p>
<ul>
<li>一个会话可以有一个控制终端(controlling terminal)。这通常是终端设备(在终端登录情况下)或伪终端设备(在网络登录情况下)。</li>
<li>建立与控制终端连接的会话首进程被称为控制进程(controlling process)</li>
<li>一个会话中的几个进程组可被分成一个前台进程组(foreground process group)以及一个或多个后台进程组(background process group)</li>
<li>如果一个会话有一个控制终端,则它有一个前台进程组,其他进程组为后台进程组</li>
<li>无论何时键入终端的中断键(常常是Delete或Ctrl+C),都会将中断信号发送至前台进程组的所有进程。</li>
<li>无论何时键入终端的退出键(常常是Ctrl+),都会将退出信号发送至前台进程组的所有进程。</li>
<li>如果终端接口检测到调制解调器(或网络)已经断开连接,则将挂断信号发送至控制进程〔会话首进程)</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-05-01-15251544917844.jpg" alt=""></p>
<p>有时不管标准输入、标准输出是否重定向,程序都要与控制终端交互作用。保证程序能与控制终端对话的方法是open文件/dev/tty。在内核中,此特殊文件是控制终端的同义语。自然地,如果程序没有控制终端,则对于此设备的open将失败。</p>
<h2 id="函数tcgetpgrp、tcsetpgrp和tcgetsid"><a href="#函数tcgetpgrp、tcsetpgrp和tcgetsid" class="headerlink" title="函数tcgetpgrp、tcsetpgrp和tcgetsid"></a>函数tcgetpgrp、tcsetpgrp和tcgetsid</h2><p>需要有一种方法来通知内核哪一个进程组是前台进程组,这样,终端设备驱动程序就能知道将终端输入和终端产生的信号发送到何处</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> tcgetpgrp(<span class="keyword">int</span> fd); </div><div class="line"></div><div class="line"><span class="comment">// Returns: process group ID of foreground process group if OK, −1 on error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsetpgrp</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">pid_t</span> pgrpid)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>函数tcgetpgrp返回前台进程组ID,它与在fd上打开的终端相关联</p>
<p>如果进程有一个控制终端,则该进程可以调用 tcsetpgrp将前台进程组ID设置为pergid值应当是在同一会话中的一个进程组的ID。fd必须引用该会话的控制终端。</p>
<p>给出控制TTY的文件描述符,通过 tcgetsid函数,应用程序就能获得会话首进程的进程组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> tcgetsid(<span class="keyword">int</span> fd); </div><div class="line"></div><div class="line"><span class="comment">// Returns: session leader’s process group ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h2><p>作业控制允许<strong>在一个终端上启动多个作业(进程组)</strong>，它控制哪一个作业可以访问该终端以及哪些作业在后台运行。作业控制要求以下3种形式的支持。</p>
<ol>
<li>支持作业控制的 shell</li>
<li>内核中的终端驱动程序必须支持作业控制。</li>
<li>内核必须提供对某些作业控制信号的支持。</li>
</ol>
<p>从 shell使用作业控制功能的角度观察,用户可以在前台或后台启动一个作业。一个作业只是几个进程的集合,通常是一个进程管道。</p>
<p>当启动一个后台作业时，shell赋予其一个作业标识符，并打印一个或者多个进程ID，如下图所示：</p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251551733307.jpg" alt=""></p>
<p>我们可以键入一个影响前台作业的特殊字符—挂起键(通常采用Ctrl+z),与终端驱动程序进行交互作用。键入此字符使终端驱动程序将信号SIGTSTP发送至前台进程组中的所有进程,后台进程组作业则不受影响。实际上有3个特殊字符可使终端驱动程序产生信号,并将它们发送至前台进程组，他们是：</p>
<ul>
<li>中断字符(一般采用Delete或Ctrl+C)产生 SIGINT</li>
<li>退出字符(一般采用Ctrl+)产生 SIGQUIT</li>
<li>挂起字符(一般采用Ctrl+Z)产生 SIGTSTE。</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-05-01-15251552824446.jpg" alt=""></p>
<p>是否需要作业控制是一个有争议的问题。作业控制是在窗口终端广泛得到应用之前设计和实现的。很多人认为设计得好的窗口系统已经免除了对作业控制的需要。某些人抱怨作业控制的实现要求得到内核、终端驱动程序、 shell以及某些应用程序的支持,是吃力不讨好的事情。</p>
<h2 id="shell-执行程序"><a href="#shell-执行程序" class="headerlink" title="shell 执行程序"></a>shell 执行程序</h2><p><img src="https://data2.liuin.cn/2018-05-01-15251555962605.jpg" alt=""></p>
<h2 id="孤儿进程组"><a href="#孤儿进程组" class="headerlink" title="孤儿进程组"></a>孤儿进程组</h2><p>我们曾提及,一个其父进程己终止的进程称为孤儿进程( orphan process),这种进程由init进程“收养”。现在我们要说明整个进程组也可成为“孤儿”,以及POSIX.1如何处理它。</p>
<p>POSIX.1将孤儿进程组( orphaned process group)定义为:该组中每个成员的父进程要么是该组的一个成员,要么不是该组所属会话的成员。对孤儿进程组的另一种描述可以是:一个进程组不是孤儿进程组的条件是——该组中有一个进程,其父进程在属于同一会话的另一个组中。如果进程组不是孤儿进程组那么在属于同一会话的另一个组中的父进程就有机会重新启动该组中停止的进程。在这里,进程组中每一个进程的父进程(例如,进程6100的父进程是进程1)都属于另一个会话。所以此进程组是孤儿进程组</p>
<p>父进程终止后,进程组包含一个停止的进程,进程组成为孤儿进程组,POSIX.1要求向新孤儿进程组中处于停止状态的每一个进程发送挂断信号( SIGHUP),接着又向其发送继续信号( SIGCONT)。</p>
<p>在处理了挂断信号后,子进程继续。对挂断信号的系统默认动作是终止该进程,为此必须提供一个信号处理程序以捕捉该信号。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第9章 进程关系 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 进程控制</title>
    <link href="https://www.liuin.cn/2018/04/30/APUE-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://www.liuin.cn/2018/04/30/APUE-进程控制/</id>
    <published>2018-04-30T08:07:20.000Z</published>
    <updated>2018-05-01T02:38:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第8章 进程控制 笔记</p>
<a id="more"></a>
<h2 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h2><p>每个进程都有一个非负整型表示的唯一进程ID。因为进程ID标识符总是唯一的,常将其用作其他标识符的一部分以保证其唯一性。</p>
<p>虽然是唯一的,但是<strong>进程ID是可复用的</strong>。当一个进程终止后,其进程ID就成为复用的候选者。大多数UNIX系统实现延迟复用算法,使得赋予新建进程的DD不同于最近终止进程所使用的ID。这防止了将新进程误认为是使用同一ID的某个已终止的先前进程。</p>
<p>系统中有一些专用进程,但具体细节随实现而不同。<strong>ID为0的进程通常是调度进程,常常被称为交换进程</strong>(swapper)。该进程是内核的一部分,它并不执行任何磁盘上的程序,因此也被称为系统进程。</p>
<p>进程ID为1通常是init进程,在自举过程结束时由内核调用。该进程的程序文件在UNIX的早期版本中是/etc/init,在较新版本中是/sbin/init。此进程负责在自举内核后启动一个UNIX系统。init通常读取与系统有关的初始化文件(/etc/rc*文件或/etc/inittab文件,以及在/etc/init.d中的文件),并将系统引导到一个状态(如多用户)。init进程决不会终止。它是一个普通的用户进程(与交换进程不同,它不是内核中的系统进程),但是它以超级用户特权运行。</p>
<p>每个UNIX系统实现都有它自己的一套提供操作系统服务的内核进程,例如,在某些UNIX的虚拟存储器实现中,进程ID2是页守护进程( page daemon),此进程负责支持虚拟存储器系统的分页操作。</p>
<p>返回进程标识符的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: process ID of calling process</span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getppid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: parent process ID of calling process</span></div><div class="line"></div><div class="line"><span class="keyword">uid_t</span> getuid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: real user ID of calling process</span></div><div class="line"></div><div class="line"><span class="keyword">uid_t</span> geteuid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: effective user ID of calling process</span></div><div class="line"></div><div class="line"><span class="keyword">gid_t</span> getgid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: real group ID of calling process</span></div><div class="line"></div><div class="line"><span class="keyword">gid_t</span> getegid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: effective group ID of calling process</span></div></pre></td></tr></table></figure>
<h2 id="函数fork"><a href="#函数fork" class="headerlink" title="函数fork"></a>函数fork</h2><p>一个现有进程调用fork函数创建一个新的进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 in child, process ID of child in parent, −1 on error</span></div></pre></td></tr></table></figure>
<p>由fork创建的新进程被称为子进程( child process) fork函数被调用一次,但返回两次。两次返回的区别是子进程的返回值是0,而父进程的返回值则是新建子进程的进程ID。</p>
<p>将子进程ID返回给父进程的理由是:因为一个进程的子进程可以有多个,<strong>并且没有一个函数使一个进程可以获得其所有子进程的进程ID</strong>。fork使子进程得到返回值0的理由是:一个进程只会有一个父进程,所以子进程总是可以调用 getppid以获得其父进程的进程ID(进程ID0总是由内核交换进程使用,所以一个子进程的进程ID不可能为0)</p>
<p>子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。</p>
<p>由于在fork之后经常跟随着exec,所以现在的很多实现并不执行一个父进程数据段栈和堆的完全副本。作为替代,使用了<strong>写时复制</strong>( copy-on-write,COW)技术。这些区域由父进程和子进程共享,而且内核将它们的访问权限改变为只读。如果父进程和子进程中的任一个试图修改这些区域,则内核只为修改区域的那块内存制作一个副本,通常是虚拟存储系统中的一“页”。</p>
<p>一般来说,在fork之后是父进程先执行还是子进程先执行是不确定的,这取决于内核所使用的调度算法。如果要求父进程和子进程之间相互同步,则要求某种形式的进程间通信。</p>
<blockquote>
<p>strlen 和 sizeof 的区别</p>
</blockquote>
<p>str1en计算不包含终止nul字节的字符串长度,而sizeof则计算包括终止nul字节的缓冲区长度。两者之间的另一个差别是,使用strlen需进行一次函数调用,而对于sizeof而言,因为缓冲区已用已知字符串进行初始化,其长度是固定的,所以 sizeof是在编译时计算缓冲区长度。</p>
<blockquote>
<p>文件共享</p>
</blockquote>
<p>fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中。我们说“复制”是因为对每个文件描述符来说,就好像执行了dup函数。<strong>父进程和子进程每个相同的打开描述符共享一个文件表项</strong>，因此他们共享的是一个文件偏移量。</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250766871953.jpg" alt=""></p>
<p>如果父进程和子进程写同一描述符指向的文件,但又没有任何形式的同步(如使父进程等待子进程),那么它们的输出就会相互混合(假定所用的描述符是在foxk之前打开的)。</p>
<p>在fork之后处理文件描述符有以下两种情况：</p>
<ol>
<li>父进程等待子进程完成</li>
<li>父进程和子进程各自执行不同的程序段</li>
</ol>
<p>除了打开文件之外,<strong>子进程继承父进程的属性</strong>有：</p>
<ul>
<li>实际用户ID、实际组ID、有效用户ID、有效组ID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>会话ID</li>
<li>控制终端</li>
<li>设置用户ID标志和设置组ID标志</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字</li>
<li>信号屏蔽和安排</li>
<li>对任一打开文件描述符的执行时关闭( close-on-exec)标志</li>
<li>环境</li>
<li>连接的共享存储段</li>
<li>存储映像</li>
<li>资源限制</li>
</ul>
<p>父进程和子进程的区别如下：</p>
<ul>
<li>fork的返回值不同</li>
<li>进程ID不同</li>
<li>这两个进程的父进程ID不同:子进程的父进程ID是创建它的进程的ID,而父进程的父进程ID则不变。</li>
<li>进程的 tms_utime、 tms_stime、 tms_cutime和tms_ultime的值设置为0</li>
<li>子进程不继承父进程设置的文件锁</li>
<li>子进程的未处理闹钟被清除</li>
<li>子进程的未处理信号集设置为空集</li>
</ul>
<p>使fork失败的原因主要有以下几个：</p>
<ol>
<li>系统中已经有了太多的进程</li>
<li>该实际用户ID的进程总数超过了系统限制</li>
</ol>
<p>fork有如下两种用法：</p>
<ol>
<li>一个父进程希望复制自己,使父进程和子进程同时执行不同的代码段</li>
<li>一个进程要执行一个不同的程序</li>
</ol>
<h2 id="函数vfork"><a href="#函数vfork" class="headerlink" title="函数vfork"></a>函数vfork</h2><p>vfork函数的调用序列和返回值与fork相同,但两者的语义不同</p>
<p>vfork函数用于创建一个新进程,而该新进程的目的是exec一个新程序。但是它并不将父进程的地址空间完全复制到子进程中,因为子进程会立即调用exec(或exit),于是也就<strong>不会引用该地址空间</strong>。不过在子进程调用exec或exit之前,它在父进程的空间中运行。这种优化工作方式在某些UNIX系统的实现中提高了效率,但如果子进程修改数据(除了用于存放 vfork返回值的变量)、进行函数调用、或者没有调用exec或exit就返回都可能会带来未知的结果。(就像上一节中提及的,实现采用写时复制技术以提高fork之后跟随exec操作的效率,但是不复制比部分复制还是要快一些)</p>
<p>vfork和fork之间的另一个区别是: vfork保证子进程先运行,在它调用exec或exit之后父进程才可能被调度运行,当子进程调用这两个函数中的任意一个时,父进程会恢复运行。</p>
<h2 id="函数exit"><a href="#函数exit" class="headerlink" title="函数exit"></a>函数exit</h2><p>进程有5种正常终止和3种异常终止的方式，5种正常终止的方式如下：</p>
<ol>
<li>从main返回</li>
<li>调用exit</li>
<li>调用_exit或_Exit</li>
<li>最后一个线程从其启动例程返回</li>
<li>从最后一个线程调用 pthread_exit</li>
</ol>
<p>3种异常终止方式：</p>
<ol>
<li>调用 abort</li>
<li>接到一个信号</li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<p>不管进程如何终止,最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开描述符,释放它所使用的存储器等。</p>
<p>对上述任意一种终止情形,我们都希望终止进程能够通知其父进程它是如何终止的。对于3个终止函数(exit、_exit和_Exit),实现这一点的方法是,将其退出状态( exit status)作为参数传送给函数。在异常终止情况,内核(不是进程本身)<strong>产生一个指示其异常终止原因的终止状态</strong>( termination status)。在任意一种情况下,该终止进程的父进程都能用wait或wa1tpid函数(将在下一节说明)取得其终止状态。</p>
<p>上面说明了子进程将其终止状态返回给其父进程，但是如果父进程在子进程之前终止,又将如何呢?其回答是:<strong>对于父进程已经终止的所有进程,它们的父进程都改变为init进程</strong>。我们称这些进程由init进程收养。其操作过程大致是:在一个进程终止时,内核逐个检查所有活动进程,以判断它是否是正要终止进程的子进程,如果是,则该进程的父进程ID就更改为1(init进程的ID)。这种处理方法保证了每个进程有一个父进程。</p>
<p>如果子进程在父进程之前终止,那么父进程又如何能在做相应检查时得到子进程的终止状态呢?如果子进程完全消失了,父进程在最终准备好检查子进程是否终止时是无法获取它的终止状态的。内核为每个终止子进程保存了一定量的信息,所以当终止进程的父进程调用wait或 waitpid时,可以得到这些信息。</p>
<p>在UNIX术语中,一个已经终止、但是其父进程尚未对其进行善后处理(获取终止子进程的有关信息、释放它仍占用的资源)的进程被称为<strong>僵死进程</strong>( zombie.)。Ps()命令将僵死进程的状态打印为Z。如果编写一个长期运行的程序,它fork了很多子进程,那么除非父进程等待取得子进程的终止状态,不然这些子进程终止后就会变成僵死进程</p>
<p>最后一个要考虑的问题是:一个由init进程收养的进程终止时会发生什么?它会不会变成一个僵死进程?对此问题的回答是“否”,因为init被编写成无论何时只要有一个子进程终止,init就会调用一个wait函数取得其终止状态。这样也就防止了在系统中塞满僵死进程。</p>
<h2 id="函数wait-和-waitpid"><a href="#函数wait-和-waitpid" class="headerlink" title="函数wait 和 waitpid"></a>函数wait 和 waitpid</h2><p>当一个进程正常或异常终止时,内核就向其父进程发送 SIGCHLD信号。因为子进程终止是个异步事件(这可以在父进程运行的任何时候发生),所以这种信号也是内核向父进程发的异步通知。父进程可以选择忽略该信号,或者提供一个该信号发生时即被调用执行的函数(信号处理程序)。对于这种信号的系统默认动作是忽略它。</p>
<p>现在我们要知道的是调用wait和waitpid时进程都发生什么：</p>
<ul>
<li>如果其所有子进程都还在运行,则阻塞。</li>
<li>如果一个子进程已终止,正等待父进程获取其终止状态,则取得该子进程的终止状态立即返回</li>
<li>如果它没有任何子进程,则立即出错返回。</li>
</ul>
<p>如果进程由于接收到 SIGCHLD信号而调用wait,我们期望wait会立即返回。但是如果在间点调用wait,则进程可能会阻塞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *statloc); </div><div class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options); </div><div class="line"></div><div class="line"><span class="comment">// Both return: process ID if OK, 0 (see later), or −1 on error</span></div></pre></td></tr></table></figure>
<p>两个函数的区别如下：</p>
<ul>
<li>在一个子进程终止前,wait使其调用者阻塞,而 waitpid有一选项,可使调用者不阻塞</li>
<li>waitpid并不等待在其调用之后的第一个终止子进程,它有若千个选项,可以控制它所等待的进程</li>
</ul>
<p>这两个函数的参数statloc是一个整型指针。如果statloc不是一个空指针,则终止进程的终止状态就存放在它所指向的单元内。如果不关心终止状态,则可将该参数指定为空指针</p>
<p>对于waitpid函数中pid参数的作用解释如下。</p>
<ul>
<li>pid == -1  等待任一子进程。此种情况下, waitpid与wait等效</li>
<li>pid &gt; 0  等待进程ID与pid相等的子进程</li>
<li>pid == 0  等待组ID等于调用进程组ID的任一子进程。</li>
<li>pid &lt; -1  等待组ID等于pid绝对值的任一子进程</li>
</ul>
<p>waitpid函数返回终止子进程的进程ID,并将该子进程的终止状态存放在由saoc指向的存储单元中。</p>
<p>options参数可以使我们能够进一步控制waitpid函数的操作</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250876888707.jpg" alt=""></p>
<h2 id="函数waitid"><a href="#函数waitid" class="headerlink" title="函数waitid"></a>函数waitid</h2><p>另一个取得进程终止状态的函数waited,此函数类似于 waitpid,但提供了更多的灵活性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">waitid</span><span class="params">(<span class="keyword">idtype_t</span> idtype, <span class="keyword">id_t</span> id, <span class="keyword">siginfo_t</span> *infop, <span class="keyword">int</span> options)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>与 waitpid相似, waitid允许一个进程指定要等待的子进程。但它使用两个单独的参数表示要等待的子进程所属的类型,而不是将此与进程DD或进程组ID组合成一个参数。</p>
<p>idtype参数：</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250878149783.jpg" alt=""></p>
<p>options参数：</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250878305949.jpg" alt=""></p>
<h2 id="函数wait3和wait4"><a href="#函数wait3和wait4" class="headerlink" title="函数wait3和wait4"></a>函数wait3和wait4</h2><p>wait3和wait4提供的功能比上面的函数多一个，该参数允许内核返回由终止进程及其所有子进程使用的资源概况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> wait3(<span class="keyword">int</span> *statloc, <span class="keyword">int</span> options, <span class="keyword">struct</span> rusage *rusage);</div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> wait4(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options, <span class="keyword">struct</span> rusage *rusage);</div><div class="line"></div><div class="line"><span class="comment">// Both return: process ID if OK, 0, or −1 on error</span></div></pre></td></tr></table></figure>
<p>资源统计信息包括用户CPU时间总量、系统CPU时间总量、缺页次数、接收到信号的次数等。</p>
<h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><p>当多个进程都企图对共享数据进行某种处理,而最后的结果又取决于进程运行的顺序时,我们认为发生了竞争条件(race condition)。如果在fork之后的某种逻辑显式或隐式地依赖于在fork之后是父进程先运行还是子进程先运行,那么fork函数就会是竞争条件活跃的滋生地</p>
<p>如果一个进程希望等待一个子进程终止,则它必须调用wait函数中的一个。如果一个进程要等待其父进程终止,则可使用下列形式的循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">while</span>(getppid() != <span class="number">1</span>)</div><div class="line">    sleep(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>这种形式的循环称为轮询( polling),它的问题是浪费了CPU时间,因为调用者每隔1s都被唤醒,然后进行条件测试</p>
<p>为了避免竞争条件和轮询,在多个进程之间需要有某种形式的信号发送和接收的方法。在UNIX中可以使用信号机制。各种形式的进程间通信(IPC)也可使用。</p>
<h2 id="函数exec"><a href="#函数exec" class="headerlink" title="函数exec"></a>函数exec</h2><p>用fork函数创建新的子进程后,子进程往往要调用一种exec函数以执行另个程序。当进程调用一种exec函数时,该进程执行的程序完全替换为新程序,而新程序则从其main函数开始执行。因为调用exec并不创建新进程,所以前后的进程ID并未改变。<strong>exec只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段</strong>。</p>
<p>有7中不同的exec函数可以使用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span> )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ...<span class="comment">/* (char *)0, char *const envp[] */</span> )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ﬁlename, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span> )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ﬁlename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fexecve</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All seven return: −1 on error, no return on success</span></div></pre></td></tr></table></figure></p>
<p>这些函数之间的第一个区别是前4个函数取路径名作为参数,后两个函数则取文件名作为参数,最后一个取文件描述符作为参数。</p>
<p>第二个区别与参数表的传递有关(1表示列表list,v表示矢量vector)。函数exec1、exec1p和 execle要求将新程序的每个命令行参数都说明为一个单独的参数。这种参数表以空指针结尾。对于另外4个函数( execv、 execvp、execve和 fexecve),则应先构造一个指向各参数的指针数组,然后将该数组地址作为这4个函数的参数。</p>
<p>最后一个区别与向新程序传递环境表相关。以e结尾的3个函数(eXec1e、 execve和 fexecve)可以传递一个指向环境字符串指针数组的指针。其他4个函数则使用调用进程中的 environ变量为新程序复制现有的环境</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15251006856272.jpg" alt=""></p>
<p>前面曾提及,在执行exec后,进程ID没有改变。但新程序从调用进程继承了的下列属性:</p>
<ul>
<li>进程ID和父进程ID</li>
<li>实际用户ID和实际组ID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>会话ID</li>
<li>控制终端</li>
<li>闹钟尚余留的时间</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字</li>
<li>文件锁</li>
<li>进程信号屏蔽</li>
<li>未处理信号</li>
<li>资源限制</li>
<li>nice值</li>
<li>tms_utime、tms_stime、tms_cutime以及tms_ctime值</li>
</ul>
<p>在很多UNIX实现中,这7个函数中只有<code>execve</code>是内核的系统调用。另外6个只是库函数它们最终都要调用该系统调用。</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15251008959267.jpg" alt=""></p>
<h2 id="更改用户ID和更改组ID"><a href="#更改用户ID和更改组ID" class="headerlink" title="更改用户ID和更改组ID"></a>更改用户ID和更改组ID</h2><p>在UNIX系统中,特权(如能改变当前日期的表示法)以及访问控制(如熊否读、写一个特定文件),是基于用户ID和组ID的。当程序需要增加特权,或需要访问当前并不允许访问的资源时,我们需要更换自己的用户ID或组ID,使得新ID具有合适的特权或访问权限。与此类似当程序需要降低其特权或阻止对某些资源的访问时,也需要更换用户ID或组ID,新ID不具有相应特权或访问这些资源的能力</p>
<p>在设计应用时,我们总是试图使用<strong>最小特权( least privilege)模型</strong>。依照此模型我们的程序应当只具有为完成给定任务所需的最小特权。这降低了由恶意用户试图哄骗我们的程序以未预料的方式使用特权造成的安全性风险</p>
<p>设置用户ID和组ID的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>使用时注意如下：</p>
<ul>
<li>若进程具有超级用户特权,则 setuid函数将实际用户ID、有效用户ID以及保存的设置用户ID设置为uid</li>
<li>若进程没有超级用户特权,但是uid等于实际用户ID或保存的设置用户ID,则 setid只将有效用户ID设置为uid。不更改实际用户ID和保存的设置用户ID</li>
<li>如果上面两个条件都不满足,则 errno设置为 EPERM,并返回-1</li>
</ul>
<p>关于内核所维护的3个ID，需要注意的事项如下：</p>
<ul>
<li>只有超级用户才可以更改实际用户ID，通常,实际用户ID是在用户登录时,由1ogin(1)程序设置的,而且决不会改变它。</li>
<li>仅当对程序文件设置了设置用户ID位时,exec函数才设置有效用户ID</li>
<li>保存的设置用户ID是由exec复制有效用户ID而得到的</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-04-30-15251013810789.jpg" alt=""></p>
<ol>
<li>函数setreuid和setregid</li>
</ol>
<p>其功能是交换实际用户ID和有效用户ID的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setreuid</span><span class="params">(<span class="keyword">uid_t</span> ruid, <span class="keyword">uid_t</span> euid)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setregid</span><span class="params">(<span class="keyword">gid_t</span> rgid, <span class="keyword">gid_t</span> egid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<ol>
<li>函数seteuid和setegid</li>
</ol>
<p>它们类似于 setuid和 setgid,但只更改有效用户ID和有效组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>各个函数之间的区别</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15251015827722.jpg" alt=""></p>
<h2 id="解释器文件"><a href="#解释器文件" class="headerlink" title="解释器文件"></a>解释器文件</h2><p>所有现今的UNIX系统都支持解释器文件(interpreter file)。这种文件是文本文件,其起始行的形式是：</p>
<p><code>#! pathname [optional-argument]</code></p>
<p>最常见的如下：</p>
<p><code>#! /bin/sh</code></p>
<p>对这种文件的识别是由内核作为exec系统调用处理的一部分来完成的。内核使调用exec函数的进程<strong>实际执行的并不是该解释器文件,而是在该解释器文件第一行中 pathname所指定的文件</strong>。一定要将解释器文件(文本文件,它以#!开头)和解释器(由该解释器文件第一行中的 pathname指定)区分开来</p>
<p>当内核exec解释器(/home/sar/bin/echoarg)时,argv[0]是该解释器的 pathname,argv[1]是解释器文件中的可选参数</p>
<h2 id="函数system"><a href="#函数system" class="headerlink" title="函数system"></a>函数system</h2><p>ISO C定义了system函数,但是其操作对系统的依赖性很强</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: (see below)</span></div></pre></td></tr></table></figure>
<p>如果 cmdstring是一个空指针,则仅当命令处理程序可用时, system返回非0值,这一特征可以确定在一个给定的操作系统上是否支持 system函数。在UNIX中, system总是可用的。</p>
<p>因为 system在其实现中调用了fork、exec和 waitpid,因此有3种返回值<br>(1)fork失败或者 waitpid返回除 EINTR之外的出错,则 system返回-1,并且设置errno以指示错误类型。<br>(2)如果 exec失败(表示不能执行shel1),则其返回值如同 shell执行了exit(127)一样<br>(3)否则所有3个函数(fork、exec和 waitpid)都成功,那么 system的返回值是 shell的终止状态,其格式已在 waitpid中说明。</p>
<p>使用 system而不是直接使用fork和exec的优点是: system进行了所需的各种出错处理以及各种信号处理</p>
<h2 id="进程会计"><a href="#进程会计" class="headerlink" title="进程会计"></a>进程会计</h2><p>大多数UNIX系统提供了一个选项以进行进程会计( process accounting)处理。启用该选项后,每当进程结束时内核就写一个会计记录。典型的会计记录包含总量较小的二进制数据,一般包括命令名、所使用的CPU时间总量、用户ID和组ID、启动时间等。</p>
<p>一个至今没有说明的函数(acct)启用和禁用进程会计。唯一使用这一函数的是 accton(8)命令(这是在几种平台上都类似的少数几条命令中的一条)。超级用户执行一个带路径名参数的accton命令启用会计处理。会计记录写到指定的文件中</p>
<p>会计记录结构定义在头文件<sys acct.h="">中，每个系统都有不同，但是基本样式如下：</sys></p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251417041152.jpg" alt=""></p>
<p>会计记录所需的各个数据(各CPU时间、传输的字符数等)都由内核保存在进程表中,并在个新进程被创建时初始化(如fork之后在子进程中)。进程终止时写一个会计记录。</p>
<p>这产生两个后果:</p>
<p>第一,我们不能获取永远不终止的进程的会计记录。像init这样的进程在系统生命周期中直在运行,并不产生会计记录。这也同样适合于内核守护进程,它们通常不会终止<br>第二,在会计文件中记录的顺序对应于进程终止的顺序,而不是它们启动的顺序。</p>
<h2 id="用户标识"><a href="#用户标识" class="headerlink" title="用户标识"></a>用户标识</h2><p>任一进程都可以得到其实际用户ID和有效用户ID及组ID。但是,我们有时希望找到运行该程序用户的登录名。</p>
<p>系统通常记录用户登录时使用的名字(见68节),用get1ogin函数可以获取此登录名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getlogin</span><span class="params">(<span class="keyword">void</span>)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to string giving login name if OK, NULL on error</span></div></pre></td></tr></table></figure>
<p>如果调用此函数的进程没有连接到用户登录时所用的终端,则函数会失败。通常称这些进程为守护进程(daemon)</p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>UNX系统历史上对进程提供的只是基于调度优先级的粗粒度的控制。调度策略和调度优先级是由内核确定的。<strong>进程可以通过调整nice值选择以更低优先级运行</strong>(通过调整nice值降低它对CPU的占有,因此该进程是“友好的”)。只有特权进程允许提高调度权限</p>
<p>Single UNIX Specification中nice值的范围在0~(2*NZERO)-1之间,有些实现支持0~2*NERO。nice值越小,优先级越高。虽然这看起来有点倒退,但实际上是有道理的:你越友好,你的调度优先级就越低。 NERO是系统默认的nice值。</p>
<p>进程可以通过nice函数获取或更改它的nice值。使用这个函数,进程只能影响自己的nce值,不能影响任何其他进程的nice值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">nice</span><span class="params">(<span class="keyword">int</span> incr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: new nice value − NZERO if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>getpriority函数可以像nice函数那样用于获取进程的nice值,但是 getpriority还可以获取一组相关进程的nice值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: nice value between −NZERO and NZERO−1 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>setpriority函数可用于为进程、进程组和属于特定用户ID的所有进程设置优先级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who, <span class="keyword">int</span> value)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h2><p>我们可以度量的3个时间:墙上时钟时间、用户CPU时间和系统CPU时间。任一进程都可调用 times函数获得它自己以及已终止子进程的土述值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">clock_t</span> times(<span class="keyword">struct</span> tms *buf );</div><div class="line"></div><div class="line"><span class="comment">// Returns: elapsed wall clock time in clock ticks if OK, −1 on error</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第8章 进程控制 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 进程环境</title>
    <link href="https://www.liuin.cn/2018/04/29/APUE-%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/"/>
    <id>https://www.liuin.cn/2018/04/29/APUE-进程环境/</id>
    <published>2018-04-29T10:30:25.000Z</published>
    <updated>2018-04-30T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第7章 进程环境 笔记</p>
<a id="more"></a>
<h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>C程序总是从main函数开始执行，main函数的原型是：</p>
<p><code>int main(int argc, char *argv);</code></p>
<p>其中，argc是命令行参数的数目，argv是指向参数的各个指针所构成的数组</p>
<p>当内核执行C程序时(使用一个exec函数),在调用main前先调用一个特殊的启动例程。可执行程序文件将此启动例程指定为程序的起始地址—这是由连接编辑器设置的,而连接编辑器则由C编译器调用。启动例程从内核取得命令行参数和环境变量值,然后为按上述方式调用main函数做好安排。</p>
<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>有8种方法使得进程终止(termination)，其中5种为正常终止：</p>
<ol>
<li>从main返回</li>
<li>调用exit</li>
<li>调用_exit或_Exit</li>
<li>最后一个线程从其启动例程返回</li>
<li>从最后一个线程调用 pthread_exit</li>
</ol>
<p>异常终止有3种方式,它们是:</p>
<ol>
<li>调用 abort</li>
<li>接到一个信号</li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<blockquote>
<p>退出函数</p>
</blockquote>
<p>3个函数用于正常终止一个程序:_exit和_Exit立即进入内核,exit则先执行一些清理处理,然后返回内核。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>; </div><div class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</div></pre></td></tr></table></figure>
<p><code>exit</code>函数总是执行一个标准I/O库的清理关闭操作:对于所有打开流调用fc1ose函数。这造成输出缓冲中的所有数据都被冲洗(写到文件上)</p>
<p>3个退出函数都带一个整型参数,称为终止状态(或退出状态, exit status)。大多数UNIX系统 shell都提供检查进程终止状态的方法。</p>
<blockquote>
<p>函数atexit</p>
</blockquote>
<p>按照ISO C的规定,一个进程可以登记多至32个函数,这些函数将由exit自动调用。我们称这些函数为终止处理程序( exit handler),并调用 atexit函数来登记这些函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">int atexit(void (*func)(void));</div><div class="line"></div><div class="line">// Returns: 0 if OK, nonzero on error</div></pre></td></tr></table></figure>
<p>其中, <code>atexit</code>的参数是一个函数地址,当调用此函数时无需向它传递任何参数,也不期望它返回一个值。exit调用这些函数的顺序与它们登记时候的顺序相反。同一函数如若登记多次也会被调用多次。</p>
<p>exit首先调用各终止程序，然后关闭（通过fclose）所有打开的流</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250569958373.jpg" alt=""></p>
<p>注意,内核使程序执行的唯一方法是调用一个eXec函数。进程自愿终止的唯一方法是显式或隐式地(通过调用exit)调用exit或Exit。进程也可非自愿地由一个信号使其终止</p>
<p>atexit函数有点像析构函数的意思</p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>当执行一个程序时,调用exec的进程可将命令行参数传递给该新程序。</p>
<p>ISO C和POSIX.1都要求argv[argc]是一个空指针。这就使我们可以将参数处理循环改写为</p>
<p><code>for(i = 0; argv[i] != NULL; i++)</code></p>
<h2 id="环境表"><a href="#环境表" class="headerlink" title="环境表"></a>环境表</h2><p>每个程序都接收到一张环境表。与参数表一样,<strong>环境表也是一个字符指针数组</strong>,其中每个指针包含一个以null结束的C字符串的地址。全局变量 environ则包含了该指针数组的地址</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250572321583.jpg" alt=""></p>
<h2 id="C程序的存储空间布局"><a href="#C程序的存储空间布局" class="headerlink" title="C程序的存储空间布局"></a>C程序的存储空间布局</h2><p>C程序一直由以下几个部分组成：</p>
<ul>
<li>正文段。这是由CPU执行的机器指令部分。通常,正文段是可共享的</li>
<li>初始化数据段。通常将此段称为数据段,它包含了程序中需明确地赋初值的变量</li>
<li>未初始化数据段。通常将此段称为bss段,这一名称来源于早期汇编程序一个操作符,意思是“由符号开始的块”( block started by symbol),在程序开始执行之前,<strong>内核将此段中的数据初始化为0或空指针</strong>。</li>
<li>栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。</li>
<li>堆。通常在堆中进行动态存储分配。</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-04-30-15250574049036.jpg" alt=""></p>
<p>栈顶和堆顶的虚拟地址空间很大。</p>
<p>未初始化数据段的内容并不存放在磁盘程序文件中。其原因是,内核在程序开始运行前将它们都设置为0。需要存放在磁盘程序文件中的段只有正文段和初始化数据段</p>
<h2 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h2><p>共享库使得<strong>可执行文件中不再需要包含公用的库函数</strong>,而只需在所有进程都可引用的存储区中保存这种库例程的一个副本。程序第一次执行或者第一次调用某个库函数时,<strong>用动态链接方法将程序与共享库函数相链接</strong>。这减少了每个可执行文件的长度,但增加了一些运行时间开销。这种时间开销发生在该程序第一次被执行时,或者每个共享库函数第一次被调用时。共享库的另一个优点是<strong>可以用库函数的新版本代替老版本而无需对使用该库的程序重新连接编辑</strong>(假定参数的数目和类型都没有发生改变)</p>
<h2 id="存储空间分配"><a href="#存储空间分配" class="headerlink" title="存储空间分配"></a>存储空间分配</h2><p>ISO C说明了3个用于存储空间动态分配的函数</p>
<ol>
<li>ma11oc,分配指定字节数的存储区。此存储区中的初始值不确定。</li>
<li>cal1oc,为指定数量指定长度的对象分配存储空间。该空间中的每一位(bit)都初始化为0</li>
<li>rea11oc,增加或减少以前分配区的长度。当增加长度时,可能需将以前分配区的内容移到另一个足够大的区域,以便在尾端提供增加的存储区,而新增区域内的初始值则不确定。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nobj, <span class="keyword">size_t</span> size)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> newsize)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All three return: non-null pointer if OK, NULL on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</div></pre></td></tr></table></figure>
<p>这3个分配函数所返回的指针一定是适当对齐的,使其可用于任何数据对象。</p>
<p>函数free释放ptr指向的存储空间。被释放的空间通常被送入可用存储区池,以后,可在用上述3个分配函数时再分配。</p>
<p>这些分配例程通常用sbrk(2)系统调用实现。该系统调用扩充(或缩小)进程的堆。</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境字符串的形式是 <code>name=value</code></p>
<p>UNIX内核并不查看这些字符串,它们的解释完全取决于各个应用程序。</p>
<p>可以使用getenv函数获得环境变量的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to value associated with name, NULL if not found</span></div></pre></td></tr></table></figure>
<p>此函数返回一个指针,它指向<code>name=value</code>字符串中的 value。</p>
<p>设置环境变量的三个函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, nonzero on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> rewrite)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>用法：</p>
<ul>
<li>putenv取形式为<code>name=value</code>的字符串,将其放到环境表中。如果name已经存在,则先删除其原来的定义。</li>
<li>setenv将name设置为value。</li>
<li>unsetenv删除name的定义</li>
</ul>
<h2 id="函数setjmp和longjmp"><a href="#函数setjmp和longjmp" class="headerlink" title="函数setjmp和longjmp"></a>函数setjmp和longjmp</h2><p>在C中,goto语句是不能跨越函数的,而执行这种类型跳转功能的是函数 setjmp和1ongjmp两个函数对于处理发生在很深层嵌套函数调用中的出错情况是非常有用的</p>
<p>setjmp和1ongjmp函数可以看成一个非局部goto函数。非局部指的是这不是由普通的C语言goto语句在一个函数内实施的跳转,而是在栈上跳过若于调用帧,返回到当前函数调用路径上的某一个函数中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if called directly, nonzero if returning from a call to longjmp</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="函数getrlimit和setrlimit"><a href="#函数getrlimit和setrlimit" class="headerlink" title="函数getrlimit和setrlimit"></a>函数getrlimit和setrlimit</h2><p>每个进程都有一组资源限制,其中一些可以用getrlimit和 setrlimit函数查询和更改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">struct</span> rlimit *rlptr)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> <span class="keyword">struct</span> rlimit *rlptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第7章 进程环境 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 系统数据文件和信息</title>
    <link href="https://www.liuin.cn/2018/04/28/APUE-%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E4%BF%A1%E6%81%AF/"/>
    <id>https://www.liuin.cn/2018/04/28/APUE-系统数据文件和信息/</id>
    <published>2018-04-28T11:26:36.000Z</published>
    <updated>2018-04-30T08:06:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第6章 系统数据文件和信息 笔记</p>
<a id="more"></a>
<h2 id="口令文件"><a href="#口令文件" class="headerlink" title="口令文件"></a>口令文件</h2><p>UNX系统口令文件(POSX1则将其称为用户数据库)包含了如下图所示的各字段,这些字段包含在<pwd.h>中定义的 passwd结构中。</pwd.h></p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250520434469.jpg" alt=""></p>
<p>由于历史原因,口令文件是<code>/etc/passwd</code>,而且是一个ASCII文件。字段之间用冒号分隔。</p>
<p>关于这些信息有以下这些注意事项：</p>
<ul>
<li>通常有一个用户名为root的登录项,其用户ID是0(超级用户）</li>
<li>加密口令包含一个字段，现在出于安全的考虑把加密口令存放在另一个文件中</li>
<li>口令文件项中的某些字段可能是空。如果加密口令字段为空,这通常就意味着该用户没有口令(不推荐这样做)。 </li>
<li>shel字段包含了一个可执行程序名,它被用作该用户的登录 shell.若该字段为空,则取系统默认值,通常是<code>/bin/sh</code>。</li>
<li>为了阻止一个特定用户登录系统,除使用/dev/nu11外,还有若干种替代方法。</li>
</ul>
<p>有两个获取口令文件项的函数。在给出用户登录名或数值用户ID后,这两个函数就能查看相关项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> passwd *<span class="title">getpwuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> passwd *<span class="title">getpwnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
<p>如果想要查看整个口令文件，下面3个函数可以用于此目的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> passwd *<span class="title">getpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer if OK, NULL on error or end of ﬁle</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">endpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>调用<code>getpwent</code>时,它返回口令文件中的下一个记录项。函数<code>setpwent</code>反绕它所使用的文件（倒回到所有口令文件的开始）, <code>endpwent</code>则关闭这些文件</p>
<h2 id="阴影口令"><a href="#阴影口令" class="headerlink" title="阴影口令"></a>阴影口令</h2><p>加密口令是经单向加密算法处理过的用户口令副本。因为此算法是单向的,所以不能从加密口令猜测到原来的口令。</p>
<p>现在,某些系统将加密口令存放在另个通常称为阴影口令( shadow password)的文件中。该文件至少要包含用户名和加密囗令。</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250527613967.jpg" alt=""></p>
<p>阴影口令文件不应是一般用户可以读取的。仅有少数几个程序需要访问加密口令,如1ogin(1)和 passwd(1),这些程序常常是设置用户ID为root的程序。</p>
<h2 id="组文件"><a href="#组文件" class="headerlink" title="组文件"></a>组文件</h2><p>UNIX组文件中包含如下的字段，这些字段在<grp.h>所定义的group的数据结构中</grp.h></p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250528423155.jpg" alt=""></p>
<p>查看组名或数值组ID：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> group *<span class="title">getgrgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>; </div><div class="line"><span class="function"><span class="keyword">struct</span> group *<span class="title">getgrnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
<p>和用户信息一样查看所有组文件函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> group *<span class="title">getgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>; </div><div class="line"><span class="comment">// Returns: pointer if OK, NULL on error or end of ﬁle</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">endgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="附属组ID"><a href="#附属组ID" class="headerlink" title="附属组ID"></a>附属组ID</h2><p>我们不仅可以属于口令文件记录项中组ID所对应的组,也可属于多至16个另外的组。文件访问权限检查相应被修改为:不仅将进程的有效组ID与文件的组ID相比较,而且也将所有附属组ID与文件的组ID进行比较</p>
<p>使用附属组ID的优点是不必再显式地经常更改组。一个用户会参与多个项目,因此也就要同时属于多个组,此类情况是常有的。</p>
<p>以下3个函数用于获取和设置附属组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getgroups</span><span class="params">(<span class="keyword">int</span> gidsetsize, <span class="keyword">gid_t</span> grouplist[])</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: number of supplementary group IDs if OK, −1 on error</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt; /* on Linux */ </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; /* on FreeBSD, Mac OS X, and Solaris */ </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgroups</span><span class="params">(<span class="keyword">int</span> ngroups, <span class="keyword">const</span> <span class="keyword">gid_t</span> grouplist[])</span></span>; </div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt; /* on Linux and Solaris */ </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; /* on FreeBSD and Mac OS X */ </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">initgroups</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *username, <span class="keyword">gid_t</span> basegid)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p><code>getgroups</code>将进程所属用户的各附属组ID填写到数组<code>grouplist</code>中,填写入该数组的附属组ID数最多为 <code>gidsetsize</code>个。实际填写到数组中的附属组ID数由函数返回。</p>
<p><code>setgroups</code>可由超级用户调用以便为调用进程设置附属组ID表。<code>grouplist</code>是组ID数组,而 <code>ngroups</code>说明了数组中的元素数。 <code>ngroups</code>的值不能大于 NGROUPS_MAX.</p>
<h2 id="登录账户记录"><a href="#登录账户记录" class="headerlink" title="登录账户记录"></a>登录账户记录</h2><p>大多数UNIX系统都提供下列两个数据文件:utmp文件记录当前登录到系统的各个用户;wtmp文件跟踪各个登录和注销事件。</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250533552178.jpg" alt=""></p>
<h2 id="系统标识"><a href="#系统标识" class="headerlink" title="系统标识"></a>系统标识</h2><p>有一个uname函数,它返回与主机和操作系统有关的信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/utsname.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">uname</span><span class="params">(<span class="keyword">struct</span> utsname *name)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: non-negative value if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="时间和日期例程"><a href="#时间和日期例程" class="headerlink" title="时间和日期例程"></a>时间和日期例程</h2><p>由UNIX内核提供的基本时间服务是计算自协调世界时公元1970年1月1日00：00：00这一特定时间以来经过的秒数。</p>
<p>用数据结构<code>time_t</code>表示，据类型 time_t表示的,我们称它们为日历时间。日历时间包括时间和日期。UNIX在这方面与其他操作系统的区别是:(a)以协调统一时间而非本地时间计时;(b)可自动进行转换,如变换到夏令时;(c)将时间和日期作为一个量值保存。</p>
<p><code>time</code>函数返回当前时间和日期</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">time_t</span> time(<span class="keyword">time_t</span> *calptr);</div><div class="line"></div><div class="line"><span class="comment">// Returns: value of time if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>时间值作为函数值返回。如果参数非空,则时间值也存放在由calptr指向的单元内</p>
<p>关于日期和时间，有许多相关的函数，以下列出其中一些函数的关系：</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250538112744.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第6章 系统数据文件和信息 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 标准I/O库</title>
    <link href="https://www.liuin.cn/2018/04/27/APUE-%E6%A0%87%E5%87%86I-O%E5%BA%93/"/>
    <id>https://www.liuin.cn/2018/04/27/APUE-标准I-O库/</id>
    <published>2018-04-27T15:31:13.000Z</published>
    <updated>2018-04-29T11:05:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第5章 标准I/O库 笔记</p>
<a id="more"></a>
<h2 id="流和FILE对象"><a href="#流和FILE对象" class="headerlink" title="流和FILE对象"></a>流和FILE对象</h2><p>之前所描述的所有I/O函数都是围绕文件描述符的。当打开一个文件时,即返回一个文件描述符,然后该文件描述符就用于后续的I/O操作。而对于标准I/O库,它们的操作是围绕流(stream)进行。当标准I/O库打开或者创建一个文件时，我们已使一个流与一个文件相关联</p>
<p>对于ASCI字符集,一个字符用一个字节表示。对于国际字符集,一个字符可用多个字节表示。标准IO文件流可用于单字节或多字节(“宽”)字符集。流的定向( stream’s orientation)决定了所读、写的字符是单字节还是多字节的。fwide函数用于设置流的定向</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE *fp, <span class="keyword">int</span> mode)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: positive if stream is wide oriented, negative if stream is byte oriented, or 0 if stream has no orientation</span></div></pre></td></tr></table></figure>
<p><code>mode</code>参数设置为负时为字节定向、为正时为宽定向、为0时不设置流的定向、但是返回该流定向的值</p>
<p>当打开一个流时,标准IO函数 fopen返回一个指向FILE对象的指针。为了引用一个流，需将FILE指针作为参数传给每个标准I/O函数。</p>
<h2 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h2><p>对一个进程预定义了3个流,并且这3个流可以自动地被进程使用,它们是:标准输入、标准输出和标准错误。这些流引用的文件与文件描述符 STDIN_FILENO、 STDOUT_FILENO和STDERR_FILENO所引用的相同。</p>
<h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>标准I/O库提供缓冲的目的是尽可能减少使用read和write调用的次数。标准I/O库最令人迷人的也是其缓冲：</p>
<p>标准I/O提供了以下3种类型的缓冲：</p>
<ol>
<li>全缓冲。在这种情况下,在填满标准I/O缓冲区后才进行实际I/O操作。</li>
</ol>
<p>术语冲洗(flush)说明标准I/O缓冲区的写操作。缓冲区可由标准I/O例程自动地冲洗,或者可以调用函数ff1ush冲洗一个流。</p>
<ol>
<li>行缓冲，在这种情况下,当在输入和输出中遇到换行符时,标准I/O库执行I/O操作。当流涉及一个终端时(如标准输入和标准输出),通常使用行缓冲。</li>
</ol>
<p>对于行缓冲有两个限制。第一,因为标准/O库用来收集每一行的缓冲区的长度是固定的,所以只要填满了缓冲区,那么即使还没有写一个换行符,也进行O操作。第二,任何时候只要通过标准I/O库要求从(a)一个不带缓冲的流,或者(b)一个行缓冲的流(它从内核请求需要数据)得到输入数据,那么就会冲洗所有行缓冲输出流。</p>
<ol>
<li>不带缓冲。标准I/O库不对字符进行缓冲存储。</li>
</ol>
<p>对任何一个给定的流,如果我们并不喜欢这些系统默认,则可调用下列两个函数中的一个更改缓冲类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf )</span></span>;   <span class="comment">// 打开或者关闭缓冲机制</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, nonzero on error</span></div></pre></td></tr></table></figure>
<p>使用setvbuf，我们可以精确说明所需的缓冲类型。这是用<code>mode</code>参数实现的：_IOFBF 全缓冲  _IOLBF  行缓冲  _IONBF  不带缓冲</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247582189497.jpg" alt=""></p>
<p>任何时候，我们可以强制冲洗一个流：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, EOF on error</span></div></pre></td></tr></table></figure></p>
<h2 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h2><p>下列3个函数打开一个标准I/O流</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>; </div><div class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type, FILE *<span class="keyword">restrict</span> fp)</span></span>; </div><div class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All three return: ﬁle pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
<p>3个函数的区别如下：</p>
<ol>
<li>fopen函数打开路径名为pathname的一个指定的文件。</li>
<li>freopen函数在一个指定的流上打开一个指定的文件,如若该流已经打开,则先关闭该流。若该流已经定向,则使用 freopen清除该定向。此函数一般用于将一个指定的文件打开为一个预定义的流:标准输入、标准输出或标准错误。</li>
<li>fopen函数取一个已有的文件描述符，并使一个标准的I/O流与改描述符相结合</li>
</ol>
<p><code>type</code>参数指定对该流的读写方式</p>
<p><img src="https://data2.liuin.cn/2018-04-29-15249858189861.jpg" alt=""></p>
<p>使用字符b作为type的部分,这使得标准I/O系统可以区分文本文件和二进制文件。因为UNIX内核并不对这两种文件进行区分,所以在UNIX系统环境下指定字符b作为type的部分实际上并无作用。</p>
<p>调用<code>fclose</code>关闭一个打开的流：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, EOF on error</span></div></pre></td></tr></table></figure>
<h2 id="读和写流"><a href="#读和写流" class="headerlink" title="读和写流"></a>读和写流</h2><p>一旦打开了流,则可在3种不同类型的非格式化I/O中进行选择,对其进行读、写操作：</p>
<ol>
<li>每次一个字符I/O</li>
<li>每次一行I/O</li>
<li>直接I/O</li>
</ol>
<blockquote>
<p>输入函数</p>
</blockquote>
<p>以下3个函数可以用于一次读一个字符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All three return: next character if OK, EOF on end of ﬁle or error</span></div></pre></td></tr></table></figure>
<p>函数getchar等同于getc(stdin)。前两个函数的区别是，getc可以被实现为宏，而fgetc不能被实现为宏</p>
<p>注意,不管是出错还是到达文件尾端,这3个函数都返回同样的值。为了区分这两种不同的情况,必须调用 ferror或feof。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: nonzero (true) if condition is true, 0 (false) otherwise </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *fp)</span></span>;</div></pre></td></tr></table></figure>
<p>大多数情况下，每一个流的FILE对象中都维护了两个标志：出错标志和文件结束标志。调用clearerr可以清楚这些标志。</p>
<p>从流中读取数据以后,可以调用 ungetc将字符再压送回流中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: c if OK, EOF on error</span></div></pre></td></tr></table></figure>
<blockquote>
<p>输出函数</p>
</blockquote>
<p>对应于上面每一个输入函数都有一个输出函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All three return: c if OK, EOF on error</span></div></pre></td></tr></table></figure>
<h2 id="每一行-I-O"><a href="#每一行-I-O" class="headerlink" title="每一行 I/O"></a>每一行 I/O</h2><p>以下两个函数提供每次输入一行的功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> n, FILE *<span class="keyword">restrict</span> fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *buf )</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: buf if OK, NULL on end of ﬁle or error</span></div></pre></td></tr></table></figure>
<p>这两个函数都指定了缓冲区的地址,读入的行将送入其中。gets从标准输入读,而fgets从指定的流读</p>
<p>对于 fgets,必须指定缓冲的长度n。此函数一直读到下一个换行符为止,但是不超过n个字符,读入的字符被送入缓冲区。</p>
<p>gets是一个不推荐使用的函数。其问题是调用者在使用qets时不能指定缓冲区的长度。这样就可能造成缓冲区溢出(如若该行长于缓冲区长度),写到缓冲区之后的存储空间中,从而产生不可预料的后果。这种缺陷可以被利用制作蠕虫病毒。</p>
<p>fputs和puts提供每次输出一行的功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> str, FILE *<span class="keyword">restrict</span> fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: non-negative value if OK, EOF on error</span></div></pre></td></tr></table></figure>
<p>函数 fputs将一个以nul字节终止的字符串写到指定的流,尾端的终止符nu不写出。</p>
<h2 id="二进制I-O"><a href="#二进制I-O" class="headerlink" title="二进制I/O"></a>二进制I/O</h2><p>之前提到的I/O函数函数以一次一个字符或一次一行的方式进行操作。如果进行二进制I/O操作,那么我们更愿意一次读或写一个完整的结构。</p>
<p>有下面两个函数提供二进制的I/O操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp);</div><div class="line"></div><div class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp);</div><div class="line"></div><div class="line"><span class="comment">// Both return: number of objects read or written</span></div></pre></td></tr></table></figure>
<p>这些函数有两个用法：</p>
<ol>
<li>读写二进制数组</li>
<li>读写自定义的一个结构体</li>
</ol>
<p>其中参数<code>nobj</code>表示要读写的对象的个数</p>
<p>使用二进制I/O的基本问题是,它只能用于读在同一系统上已写的数据。这样就导致了一个问题：在一个系统写的数据要在另一个系统上进行处理。在这种环境下,这两个函数可能就不能正常工作,其原因是:</p>
<ol>
<li>在一个结构中,同一成员的偏移量可能随编译程序和系统的不同而不同(由于不同的对齐要求)。</li>
<li>用来存储多字节整数和浮点值的二进制格式在不同的系统结构间也可能不同</li>
</ol>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>在UNIX中,标准I/O库最终都要调用I/O例程来实现（read、write）。每个标准I/O流都有一个与其相关联的文件描述符,可以对一个流调用<code>fi1eno</code>函数以获得其描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: the ﬁle descriptor associated with the stream</span></div></pre></td></tr></table></figure>
<h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><p>标准I/O库提供两个函数来创建临时文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to unique pathname</span></div><div class="line"></div><div class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: ﬁle pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
<p>tmpnam函数产生一个与现有文件名不同的一个有效路径名字符串。每次调用它时,都产生个不同的路径名,最多调用次数是 TMP_MAX</p>
<p>若ptr是NULL,则所产生的路径名存放在一个静态区中,指向该静态区的指针作为函数值返回。</p>
<p>tmpfile创建一个临时二进制文件(类型wb+),在关闭该文件或程序结束时将自动删除这种文件</p>
<p>tmpfi1e函数经常使用的标准UNIX技术是先调用 tmpnam产生一个唯一的路径名,然后用该路径名创建一个文件,并立即un1ink它。</p>
<h2 id="内存流"><a href="#内存流" class="headerlink" title="内存流"></a>内存流</h2><p>标准I/O库把数据缓存在内存中,因此每次一字符和每次一行的I/O更有效。我们也可以通过调用 setbuf或 setvbuf函数让IO库使用我们自己的缓冲区。</p>
<p>有3个函数可以用于内存流的创建，第一个函数是fmemopen函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function">FILE *<span class="title">fmemopen</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: stream pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第5章 标准I/O库 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 文件和目录</title>
    <link href="https://www.liuin.cn/2018/04/26/APUE-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
    <id>https://www.liuin.cn/2018/04/26/APUE-文件和目录/</id>
    <published>2018-04-26T06:08:38.000Z</published>
    <updated>2018-04-26T08:17:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第4章 文件和目录 笔记</p>
<a id="more"></a>
<h2 id="函数stat、fstat、fstatat和lstat"><a href="#函数stat、fstat、fstatat和lstat" class="headerlink" title="函数stat、fstat、fstatat和lstat"></a>函数stat、fstat、fstatat和lstat</h2><p>返回文件信息的主要有4个函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">struct</span> stat *buf )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname,<span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All four return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>一旦给出pathname：</p>
<ul>
<li>stat将返回与此命名文件有关的信息结构：</li>
<li>fstat函数获得已在描述符fd上打开文件的有关信息</li>
<li>1stat函数类似于stat,但是当命名的文件是一个符号链接时,1stat返回该符号链接的有关信息,而不是由该符号链接引用的文件的信息。</li>
<li>fstatat函数为一个相对于当前打开目录(由fd参数指向)的路径名返回文件统计信息。</li>
</ul>
<p>第二个参数buf是一个指针，其指向一个我们必须提供的结构。函数来填充由buf指向的结构。其基本格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> stat &#123; </div><div class="line">    <span class="keyword">mode_t</span> st_mode; <span class="comment">/* file type &amp; mode (permissions) */</span> </div><div class="line">    <span class="keyword">ino_t</span> st_ino; <span class="comment">/* i-node number (serial number) */</span> </div><div class="line">    <span class="keyword">dev_t</span> st_dev; <span class="comment">/* device number (file system) */</span> </div><div class="line">    <span class="keyword">dev_t</span> st_rdev; <span class="comment">/* device number for special files */</span> </div><div class="line">    <span class="keyword">nlink_t</span> st_nlink; <span class="comment">/* number of links */</span> </div><div class="line">    <span class="keyword">uid_t</span> st_uid; <span class="comment">/* user ID of owner */</span> </div><div class="line">    <span class="keyword">gid_t</span> st_gid; <span class="comment">/* group ID of owner */</span> </div><div class="line">    <span class="keyword">off_t</span> st_size; <span class="comment">/* size in bytes, for regular files */</span> </div><div class="line">    <span class="keyword">struct</span> timespec st_atim; <span class="comment">/* time of last access */</span> </div><div class="line">    <span class="keyword">struct</span> timespec st_mtim; <span class="comment">/* time of last modification */</span> </div><div class="line">    <span class="keyword">struct</span> timespec st_ctim; <span class="comment">/* time of last file status change */</span> </div><div class="line">    <span class="keyword">blksize_t</span> st_blksize; <span class="comment">/* best I/O block size */</span> </div><div class="line">    <span class="keyword">blkcnt_t</span> st_blocks; <span class="comment">/* number of disk blocks allocated */</span> </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>UNIX系统的大多数文件是普通文件或目录,但是也有另外一些文件类型。文件类型包括如下几种：</p>
<ol>
<li>普通文件（regular file）文本文件或者二进制文件</li>
<li>目录文件（directory file），对一个目录文件具有读权限的任一进程都可以读该目录的内容,但只有内核可以直接写目录文件。</li>
<li>块特殊文件（block special file），这种类型的文件提供对设备(如磁盘)带缓冲的访问,</li>
<li>字符特殊文件(character special file)。这种类型的文件提供对设备不带缓冲的访问</li>
<li>FIFO，用于进程间通信的命名管道</li>
<li>套接字（socket），用于网络间进程通信</li>
<li>符号链接（symbol link），这种类型的文件指向另一个文件</li>
</ol>
<p>文件类型信息包含在stat结构的 st_mode成员中。也可以使用自带的宏确定的文件类型</p>
<h2 id="设置用户ID和设置组ID"><a href="#设置用户ID和设置组ID" class="headerlink" title="设置用户ID和设置组ID"></a>设置用户ID和设置组ID</h2><p>和一个进程相关联的ID有6个：</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247249639065.jpg" alt=""></p>
<ul>
<li>实际用户ID和实际组ID标识我们究竟是谁。这两个字段在登录时取自口令文件中的登录项。通常,在一个登录会话期间这些值并不改变,但是超级用户进程有办法改变</li>
<li>有效用户ID、有效组IDD以及附属组ID决定了我们的文件访问权限</li>
<li>保存的设置用户ID和保存的设置组ID在执行一个程序时包含了有效用户ID和有效组ID的副本</li>
</ul>
<p>通常,有效用户ID等于实际用户ID,有效组ID等于实际组ID</p>
<p>每个文件有一个所有者和组所有者,所有者由stat结构中的<code>st_uid</code>指定,组所有者则由<code>st_gid</code>指定</p>
<h2 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a>文件访问权限</h2><p>st_mode值也包含了对文件的访问权限位。当提及文件时,指的是前面所提到的任何类型的文件。所有文件类型(目录、字符特别文件等)都有访问权限( access permission)。</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247252761376.jpg" alt=""></p>
<p>3类访问权限的使用方式如下：</p>
<ul>
<li>我们用名字打开任一类型的文件时,对该名字中包含的每一个目录,包括它可能隐含的当前工作目录都应具有执行权限。这就是为什么对于目录其执行权限位常被称为搜索位的原因</li>
<li>对于一个文件的读权限决定了我们是否能够打开现有文件进行读操作</li>
<li>对于一个文件的写权限决定了我们是否能够打开现有文件进行写操作</li>
<li>为了在open函数中对一个文件指定O_TRUNC标志,必须对该文件具有写权限</li>
<li>为了在一个目录中创建一个新文件,必须对该目录具有写权限和执行权限</li>
<li>为了删除一个现有文件,必须对包含该文件的目录具有写权限和执行权限。</li>
</ul>
<p>进程每次打开、创建或者删除一个文件的时候，内核就对文件进行访问权限测试。</p>
<p>内核测试的具体内容：</p>
<ol>
<li>若进程的有效用户ID是0(超级用户),则允许访问。这给予了超级用户对整个文件系统进行处理的最充分的自由</li>
<li>若进程的有效用户ID等于文件的所有者ID(也就是进程拥有此文件),那么如果所有者适当的访问权限位被设置,则允许访问;否则拒绝访问。</li>
<li>若进程的有效组ID或进程的附属组ID之一等于文件的组ID,那么如果组适当的访问权限位被设置,则允许访问;否则拒绝访问。</li>
<li>若其他用户适当的访问权限位被设置,则允许访问;否则拒绝访问</li>
</ol>
<h2 id="新文件和目录的所有权"><a href="#新文件和目录的所有权" class="headerlink" title="新文件和目录的所有权"></a>新文件和目录的所有权</h2><p>新文件的用户ID设置为进程的有效用户ID。</p>
<p>关于组ID，POSIX实现有两种方案：</p>
<ul>
<li>进程有效组ID</li>
<li>所在目录的组ID</li>
</ul>
<h2 id="函数access和faccessat"><a href="#函数access和faccessat" class="headerlink" title="函数access和faccessat"></a>函数access和faccessat</h2><p>正如前面所说,当用open函数打开一个文件时,内核以进程的有效用户ID和有效组ID为基础执行其访问权限测试。有时,进程也希望按其实际用户ID和实际组ID来测试其访问能力。</p>
<p><code>access</code>和 <code>faccessat</code>函数是按实际用户ID和实际组ID进行访问权限测试的。(该测试也分成4步）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccessat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p><code>flag</code>参数可以用于改变<code>faccessat</code>的行为,如果<code>fag</code>设置为<code>AT_EACCESS</code>,访问检查用的是调用进程的有效用户ID和有效组D,而不是实际用户ID和实际组ID</p>
<h2 id="函数umask"><a href="#函数umask" class="headerlink" title="函数umask"></a>函数umask</h2><p><code>umask</code>函数为进程设置文件模式创建屏蔽字,并返回之前的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">mode_t</span> umask(<span class="keyword">mode_t</span> cmask);</div><div class="line"></div><div class="line"><span class="comment">// Returns: previous ﬁle mode creation mask</span></div></pre></td></tr></table></figure>
<p><code>cmask</code>是9个权限访问为常量（S_IRUSR、S_IWUSR）的若干个或组成的</p>
<p>在进程创建一个新文件或新目录时,就一定会使用文件模式创建屏蔽字</p>
<p>UNX系统的大多数用户从不处理他们的 umask值。通常在登录时,由 shell的启动文件设置一次,然后,再不改变。</p>
<p>用户可以设置 umask值以控制他们所创建文件的默认权限。该值表示成八进制数,一位代表一种要屏蔽的权限,这示于图4-10中。设置了相应位后,它所对应的权限就会被拒绝常用的几种 umask值是002、022和027。002阻止其他用户写入你的文件,022阻止同组成员和其他用户写入你的文件,027阻止同组成员写你的文件以及其他用户读、写或执行你的文件。</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247265122569.jpg" alt=""></p>
<h2 id="函数chmod、fchmod和fchmodat"><a href="#函数chmod、fchmod和fchmodat" class="headerlink" title="函数chmod、fchmod和fchmodat"></a>函数chmod、fchmod和fchmodat</h2><p>chmod、fchmod和fchmodat这3个函数使我们可以更改现有文件的访问权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmodat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All three return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>chmod函数在指定的文件上进行操作,而fchmod函数则对已打开的文件进行操作。fchmodat函数与chmod函数在下面两种情况下是相同的:一种是 pathname参数为绝对路径另一种是/参数取值为 AT_FDCWD而 pathname参数为相对路径。</p>
<p>为了改变一个文件的权限位,进程的有效用户ID必须等于文件的所有者ID,或者该进程必须具有超级用户权限。</p>
<h2 id="粘着位"><a href="#粘着位" class="headerlink" title="粘着位"></a>粘着位</h2><p>在UNIX尚未使用请求分页式技术的早期版本中, S_ISVTX位被称为粘着位( sticky bit)。如果一个可执行程序文件的这一位被设置了,那么当该程序第一次被执行,在其终止时,程序正文部分的一个副本仍被保存在交换区(程序的正文部分是机器指令)。这使得下次执行该程序时能较快地将其装载入内存。</p>
<p>后来的UNIX版本称它为保存正文位( saved-text bit),因此也就有了常量S_ISVTX。现今较新的UNX系统大多数都配置了虚拟存储系统以及快速文件系统,所以不再需要使用这种技术</p>
<p>现在粘着位的使用方法是：<br>如果对一个目录设置了粘着位,只有对该目录具有写权限的用户并且满足下列条件之一,才能删除或重命名该目录下的文件</p>
<ul>
<li>拥有此文件</li>
<li>拥有此目录</li>
<li>是超级用户</li>
</ul>
<h2 id="函数chown、fchown、fchownat和lchown"><a href="#函数chown、fchown、fchownat和lchown" class="headerlink" title="函数chown、fchown、fchownat和lchown"></a>函数chown、fchown、fchownat和lchown</h2><p>下面几个chown函数可用于更改文件的用户ID和组ID。如果两个参数 owner或 group中的任意一个是-1,则对应的ID不变</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchownat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>; All four <span class="keyword">return</span>: </div><div class="line"></div><div class="line"><span class="comment">// 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>基于BSD的系统一直规定只有超级用户才能更改一个文件的所有者这样做的原因是防止用户改变其文件的所有者从而摆脱磁盘空间限额对他们的限制。 System V则允许任一用户更改他们所拥有的文件的所有者。</p>
<h2 id="文件长度"><a href="#文件长度" class="headerlink" title="文件长度"></a>文件长度</h2><p><code>stat</code>结构成员<code>st_size</code>表示以字节为单位的文件的长度。此字段只对普通文件、目录文件和符号链接有意义。</p>
<p>对于普通文件,其文件长度可以是0；对于目录,文件长度通常是一个数(如16或512)的整倍数；对于符号链接,文件长度是在文件名中的实际字节数。</p>
<p>现今,大多数现代的UNIⅨ系统提供字段stb1ks1ze和st_b1ocks。其中,第一个是对文件I/O较合适的块长度,第二个是所分配的实际512字节块块数。</p>
<blockquote>
<p>文件空洞</p>
</blockquote>
<p>空洞是由所设置的文件偏移量超过文件尾端，并写入了某些数据造成的。</p>
<h2 id="文件截断"><a href="#文件截断" class="headerlink" title="文件截断"></a>文件截断</h2><p>有时我们需要在文件尾端处截去一些数据以缩短文件。将一个文件的长度截断为0是一个特例,在打开文件时使用 O_TRUNC标志可以做到这一点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">off_t</span> length)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>这两个函数将一个现有文件长度截断为 length。如果该文件以前的长度大于 length,则超过length以外的数据就不再能访问。如果以前的长度小于 length,文件长度将增加,在以前的文件尾端和新的文件尾端之间的数据将读作0(也就是可能在文件中创建了一个空洞)</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>目前,正在使用的UNIX文件系统有多种实现。例如, Solaris支持多种不同类型的磁盘文件系统:传统的基于BSD的UNIX文件系统(称为UFS),读、写DOS格式软盘的文件系统(称为PCFS),以及读CD的文件系统(称为HSFS)。</p>
<p>我们可以把一个磁盘分成一个或多个分区。每个分区可以包含一个文件系统，i节点是固定长度的记录项,它包含有关文件的大部分信息。</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247278022212.jpg" alt=""></p>
<p>更仔细地观察一个柱面组的i节点和数据块部分：</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247278729393.jpg" alt=""></p>
<p>在图中有两个目录项指向同一个i节点。每个i节点中都有一个链接计数,其值是指向该i节点的目录项数。只有当链接计数减少至0时,才可删除该文件(也就是可以释放该文件占用的数据块)。这就是为什么“解除对一个文件的链接”操作并不总是意味着“释放该文件占用的磁盘块”的原因。这也是为什么删除一个目录项的函数被称之为<code>un1ink</code></p>
<p>另外一种链接类型称为符号链接( symbolic link)。符号链接文件的实际内容(在数据块中)包含了该符号链接所指向的文件的名字。</p>
<p>节点包含了文件有关的所有信息:文件类型、文件访问权限位、文件长度和指向文件数据块的指针等。stat结构中的大多数信息都取自i节点。只有两项重要数据存放在目录项中:文件名和节点编号。</p>
<p>因为目录项中的i节点编号指向同一文件系统中的相应i节点,<strong>一个目录项不能指向另个文件系统的i节点</strong>。这就是为什么1n(1)命令不能跨越文件系统的原因</p>
<p>当在不更换文件系统的情况下为一个文件重命名时,该文件的实际内容并未移动,只需构造一个指向现有i节点的新目录项,并删除老的目录项。链接计数不会改变。</p>
<p>我们说明了普通文件链接计数的概念，对于目录的链接计数相关方法如下：</p>
<p>任何一个叶目录(不包含任何其他目录的目录)的链接计数总是2,数值2来自于命名该目录( testdir)的目录项以及在该目录中的.项。在父目录中的每一个子目录都使该父目录的链接计数增加1</p>
<h2 id="函数link、linkat、unlink、unlinkat和remove"><a href="#函数link、linkat、unlink、unlinkat和remove" class="headerlink" title="函数link、linkat、unlink、unlinkat和remove"></a>函数link、linkat、unlink、unlinkat和remove</h2><p>创建一个指向现有文件的链接的方法是使用linke或者linkat函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">linkat</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">int</span> nfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>这两个函数创建一个新目录项<code>newpath</code>,它引用现有文件 <code>existingpath</code></p>
<p>为了删除一个现有的目录项、可以调用unlink函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlinkat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>这两个函数删除目录项,并将由pathname所引用文件的链接计数减1。如果对该文件还有其他链接,则仍可通过其他链接访问该文件的数据。如果出错,则不对该文件做任何更改。</p>
<p>我们在前面已经提及,为了解除对文件的链接,必须对包含该目录项的目录具有写和执行权限。如果对该目录设置了粘着位,则对该目录必须具有写权限,并且具备下面三个条件之一:拥有该文件、拥有该目录或者具有超级用户权限</p>
<p>只有当链接计数达到0时,该文件的内容才可被删除。另一个条件也会阻止删除文件的内容——<strong>只要有进程打开了该文件,其内容也不能删除</strong>。关闭一个文件时,内核首先检查打开该文件的进程个数;如果这个计数达到0,内核再去检查其链接计数;如果计数也是0,那么就删除该文件的内容。</p>
<p>ulink的这种特性经常被程序用来确保即使是在程序崩溃时,它所创建的临时文件也不会遗留下来。进程用open或 creat创建一个文件,然后立即调用 unlink,因为该文件仍旧是打开的,所以不会将其内容删除。只有当进程关闭该文件或终止时，该文件的内容才被删除。</p>
<p>我们也可以用<code>remove</code>函数解除对一个文件或目录的链接。对于文件,<code>remove</code>的功能与<code>unlink</code>相同。对于目录,<code>remove</code>的功能与<code>rmdir</code>相同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="函数rename和renameat"><a href="#函数rename和renameat" class="headerlink" title="函数rename和renameat"></a>函数rename和renameat</h2><p>文件或目录可以用 rename函数或者 renameat函数进行重命名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">renameat</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">int</span> newfd,<span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2><p>符号链接是对一个文件的间接指针,它与上一节所述的硬链接有所不同,硬链接直接指向文件的i节点。引入符号链接的原因是为了避开硬链接的一些限制：</p>
<ul>
<li>硬链接通常要求链接和文件位于同一文件系统中。</li>
<li>只有超级用户才能创建指向目录的硬链接(在底层文件系统支持的情况下)。</li>
</ul>
<p>对符号链接以及它指向何种对象并无任何文件系统限制,任何用户都可以创建指向目录的符号链接。符号链接一般用于将一个文件或整个目录结构移到系统中另一个位置</p>
<h2 id="创建和读取符号链接"><a href="#创建和读取符号链接" class="headerlink" title="创建和读取符号链接"></a>创建和读取符号链接</h2><p>可以用symlink或symlikat函数创建一个符号链接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlinkat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>因为open函数跟随符号链接,所以需要有一种方法打开该链接本身,并读该链接中的名字read1ink和 readlinkat函数提供了这种功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> readlink(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize); </div><div class="line"><span class="keyword">ssize_t</span> readlinkat(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize); </div><div class="line"></div><div class="line"><span class="comment">// Both return: number of bytes read if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="文件的时间"><a href="#文件的时间" class="headerlink" title="文件的时间"></a>文件的时间</h2><p>每个文件属性所保存的实际精度依赖于文件系统的实现。对于把时间戳记录在秒级的文件系统来说,纳秒这个字段就会被填充为0。对于时间戳的记录精度高于秒级的文件系统来说,不足秒的值被转换成纳秒并记录在纳秒这个字段中。</p>
<p>每个文件维护3个时间字段：<br><img src="https://data2.liuin.cn/2018-04-26-15247296049968.jpg" alt=""></p>
<p>注意修改时间( st_mtim)和状态更改时间( st_ctim)之间的区别。修改时间是文件内容最后一次被修改的时间。状态更改时间是该文件的i节点最后一次被修改的时间。系统并不维护对一个i节点的最后一次访问时间,所以 access和stat函数并不更改这3个时间中的任一个。</p>
<h2 id="函数futimens、utimensat和utimes"><a href="#函数futimens、utimensat和utimes" class="headerlink" title="函数futimens、utimensat和utimes"></a>函数futimens、utimensat和utimes</h2><p>一个文件的访问和修改时间可以用以下几个函数更改。<code>futimens</code>和<code>utimensat</code>函数可以指定纳秒级精度的时间戳。用到的数据结构是与stat函数族相同的timespec结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimens</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>])</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimensat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>], <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="函数mkdir、mkdirat和rmdir"><a href="#函数mkdir、mkdirat和rmdir" class="headerlink" title="函数mkdir、mkdirat和rmdir"></a>函数mkdir、mkdirat和rmdir</h2><p>用 mkdir和 mkdirat函数创建目录,用rmdir函数删除目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdirat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>这两个函数创建一个新的空目录。其中,.和..目录项是自动创建的。所指定的文件访问权限mode由进程的文件模式创建屏蔽字修改。</p>
<p>用 <code>rmdir</code>函数可以删除一个空目录。空目录是只包含.和..这两项的目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="读目录"><a href="#读目录" class="headerlink" title="读目录"></a>读目录</h2><p>对某个目录具有访问权限的任一用户都可以读该目录,但是,为了防止文件系统产生混乱只有内核才能写目录。</p>
<p>读目录相关的系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>; </div><div class="line"><span class="function">DIR *<span class="title">fdopendir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: pointer if OK, NULL on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> dirent *<span class="title">readdir</span><span class="params">(DIR *dp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer if OK, NULL at end of directory or error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">telldir</span><span class="params">(DIR *dp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: current location in directory associated with dp </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekdir</span><span class="params">(DIR *dp, <span class="keyword">long</span> loc)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="函数chdir、fchdir和getcwd"><a href="#函数chdir、fchdir和getcwd" class="headerlink" title="函数chdir、fchdir和getcwd"></a>函数chdir、fchdir和getcwd</h2><p>每个进程都有一个当前工作目录,此目录是搜索所有相对路径名的起点(不以斜线开始的路径名为相对路径名)。当用户登录到UNIX系统时,其当前工作目录通常是口令文件(/etc/ passwd)中该用户登录项的第6个字段——用户的起始目录( home directory)。当前工作目录是进程的一个属性,起始目录则是登录名的一个属性</p>
<p>进程调用chdir和fchdir函数可以改变当前工作目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchdir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>我们需要一个函数,它从当前工作目录(.)开始,用.找到其上一级目录,然后读其目录项,直到该目录项中的i节点编号与工作目录i节点编号相同,这样地就找到了其对应的文件名按照这种方法,逐层上移,直到遇到根,这样就得到了当前工作目录完整的绝对路径名。很幸运,函数 getcwd就提供了这种功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: buf if OK, NULL on error</span></div></pre></td></tr></table></figure>
<h2 id="文件访问权限位小结"><a href="#文件访问权限位小结" class="headerlink" title="文件访问权限位小结"></a>文件访问权限位小结</h2><p><img src="https://data2.liuin.cn/2018-04-26-15247306715849.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第4章 文件和目录 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>I/O多路复用之Select、Poll和Epoll</title>
    <link href="https://www.liuin.cn/2018/04/20/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8BSelect%E3%80%81Poll%E5%92%8CEpoll/"/>
    <id>https://www.liuin.cn/2018/04/20/I-O多路复用之Select、Poll和Epoll/</id>
    <published>2018-04-20T12:45:23.000Z</published>
    <updated>2018-04-21T08:10:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期写一个在线聊天室的时候接触到epoll，加上之前腾讯面试的时候面试官有问到这一题。这里就对select、poll和epoll做一个总结，目的是让自己更加深入地理解，大部分内容来自网上，可能存在错误，欢迎大家指正。</p>
<a id="more"></a>
<h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p>之前在讲阻塞/非阻塞和同步/异步的理解的时候讲到，在Unix网络I/O中，有三种同步I/O方式：阻塞式I/O、非阻塞式I/O和I/O复用。</p>
<p>I/O多路复用简单来说就是对多个文件进行操作，<strong>通过一种机制一个进程能同时等待多个文件描述符</strong>，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回</p>
<p>select，poll，epoll都是I/O多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>
<h2 id="Linux内核的wakeup-callback机制"><a href="#Linux内核的wakeup-callback机制" class="headerlink" title="Linux内核的wakeup callback机制"></a>Linux内核的wakeup callback机制</h2><p>Linux内核的wakeup callback机制是I/O多路复用存在的本质。Linux内核通过睡眠队列来组织所有等待某个事件的task，而wakeup机制则可以异步唤醒整个睡眠队列上的task，每一个睡眠队列上的节点都拥有一个callback，wakeup逻辑在唤醒睡眠队列时，会遍历该队列链表上的每一个节点，调用每一个节点的callback，如果遍历过程中遇到某个节点是排他节点，则终止遍历，不再继续遍历后面的节点。</p>
<p>总体有两个逻辑：（1）睡眠等待逻辑；（2）唤醒逻辑。</p>
<blockquote>
<p>睡眠等待逻辑</p>
</blockquote>
<ul>
<li>select、poll、epoll_wait陷入内核，判断监控的fd是否有关心的事件发生了，如果没，则为当前task构建一个wait_entry节点，然后插入到监控fd的sleep_list</li>
<li>进入循环的schedule直到关心的事件发生了</li>
<li>关心的事件发生后，将当前task的wait_entry节点从socket的sleep_list中删除</li>
</ul>
<blockquote>
<p>唤醒逻辑</p>
</blockquote>
<ul>
<li>fd监听的事件发生了，然后fd顺序遍历其睡眠队列，依次调用每个wait_entry节点的callback函数</li>
<li>直到完成队列的遍历或遇到某个wait_entry节点是排他的才停止</li>
<li>一般情况下callback包含两个逻辑：1.wait_entry自定义的私有逻辑；2.唤醒的公共逻辑，主要用于将该wait_entry的task放入CPU的就绪队列，让CPU随后可以调度其执行。</li>
</ul>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</div></pre></td></tr></table></figure>
<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。nfds表示所有监视的文件描述符中最高的数+1，同时可以定义时间timeout，超过时间将返回0。</p>
<p>调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>当用户进程调用select的时候，select会将需要监控的readfds集合拷贝到内核空间（假设监控的仅仅是fd可读），然后遍历自己监控的fd_sk，挨个调用sk的poll逻辑以便检查该sk是否有可读事件，遍历完所有的sk后，如果没有任何一个sk可读，那么select会调用schedule_timeout进入schedule循环，使得process进入睡眠。如果在timeout时间内某个sk上有数据可读了，或者等待timeout了，则调用select的process会被唤醒，接下来select就是遍历监控的sk集合，挨个收集可读事件并返回给用户了</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。</p>
<p>但是通过上面实现的分析，select还存在的问题是：</p>
<ul>
<li>被监控的fds需要从用户空间拷贝到内核空间。为了减少数据拷贝带来的性能损坏，内核对被监控的fds集合大小做了限制，并且这个是通过宏控制的，大小不可改变(限制为1024)。</li>
<li>被监控的fds集合中，只要有一个有数据可读，整个socket集合就会被遍历一次调用sk的poll函数收集可读事件。由于当初的需求是朴素，仅仅关心是否有数据可读这样一个事件，当事件通知来的时候，由于数据的到来是异步的，我们不知道事件来的时候，有多少个被监控的socket有数据可读了，于是，只能挨个遍历每个socket来收集可读事件，但是我们希望的是能够从通知中得到有可读事件的fds列表，而不是需要遍历整个fds来收集</li>
</ul>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div></pre></td></tr></table></figure>
<p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的数组实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> pollfd &#123;</div><div class="line">   <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></div><div class="line">   <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span></div><div class="line">   <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>fd表示检测的文件描述符，要测试的条件由 events成员指定,函数在相应的 revents成员中返回该描述符的状态。和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>
<p>poll虽然解决了fds集合大小1024的限制问题，但是，它并没改变大量描述符数组被整体复制于用户态和内核态的地址空间之间，以及个别描述符就绪触发整体描述符集合的遍历的低效问题。poll随着监控的socket集合的增加性能线性下降，poll不适合用于大并发场景。</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>epoll含有的接口有三个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;   </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span></span></div><div class="line">                      <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout);</div></pre></td></tr></table></figure>
<blockquote>
<p>epoll_create</p>
</blockquote>
<p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</p>
<p>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽</p>
<blockquote>
<p>epoll_ctl</p>
</blockquote>
<p>对由<code>epfd</code>所引用的epoll实例进行操作，其中<code>op</code>表示操作类型(包含增删改)，<code>fd</code>表示操作的目标文件描述符，<code>event</code>和文件描述符相关联表示具体监听什么事件，以下是<code>event</code>的具体数据结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</div><div class="line">   <span class="keyword">void</span>        *ptr;</div><div class="line">   <span class="keyword">int</span>          fd;</div><div class="line">   <span class="keyword">uint32_t</span>     u32;</div><div class="line">   <span class="keyword">uint64_t</span>     u64;</div><div class="line">&#125; <span class="keyword">epoll_data_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> epoll_event &#123;</div><div class="line">   <span class="keyword">uint32_t</span>     events;      <span class="comment">/* 监听的事件属性，通常包含：读、写、出错、挂断等等 */</span></div><div class="line">   <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* 事件信息 */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>epoll_wait</p>
</blockquote>
<p>等待<code>epfd</code>所引用的epoll实例上的I/O就绪，同时用<code>events</code>来获得从内核得到的事件集合、<code>maxevents</code>表示传入的events有多少</p>
<p>函数返回以后可以遍历event数组，对已经就绪的I/O进行处理。</p>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>在每个事件的属性中可以设置对文件描述符的工作模式，有两种模式：水平触发LT（level trigger）和边沿出发ET（edge trigger）。LT模式是默认模式。两种模式的区别如下：</p>
<p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序可以不立即处理该事件</strong>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p>
<p>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序必须立即处理该事件</strong>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<p>对于可读事件而言，在ET模式下，如果某个socket有新的数据到达，那么该sk就会被排入epoll的ready_list，从而epoll_wait就一定能收到可读事件的通知(调用sk的poll逻辑一定能收集到可读事件)。于是，我们通常理解的缓冲区状态变化(从无到有)的理解是不准确的，准确的理解应该是是否有新的数据达到缓冲区。</p>
<p>而在LT模式下，某个sk被探测到有数据可读，那么该sk会被重新加入到read_list，那么在该sk的数据被全部取走前，下次调用epoll_wait就一定能够收到该sk的可读事件(调用sk的poll逻辑一定能收集到可读事件)，从而epoll_wait就能返回。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><blockquote>
<p>fds集合拷贝问题的解决</p>
</blockquote>
<p>细看select或poll的函数原型，我们会发现，每次调用select或poll都在重复地准备(集中处理)整个需要监控的fds集合。然而对于频繁调用的select或poll而言，fds集合的变化频率要低得多，我们没必要每次都重新准备(集中处理)整个fds集合。</p>
<p>于是，epoll引入了epoll_ctl系统调用，将高频调用的epoll_wait和低频的epoll_ctl隔离开。同时，epoll_ctl通过(EPOLL_CTL_ADD、EPOLL_CTL_MOD、EPOLL_CTL_DEL)三个操作来分散对需要监控的fds集合的修改，做到了有变化才变更，将select或poll高频、大块内存拷贝(集中处理)变成epoll_ctl的低频、小块内存的拷贝(分散处理)，避免了大量的内存拷贝。同时，对于高频epoll_wait的可读就绪的fd集合返回的拷贝问题，epoll通过内核与用户空间mmap(内存映射)同一块内存来解决。mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址（不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理地址），使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。</p>
<p>另外，epoll通过epoll_ctl来对监控的fds集合来进行增、删、改，那么必须涉及到fd的快速查找问题，于是，一个低时间复杂度的增、删、改、查的数据结构来组织被监控的fds集合是必不可少的了。在linux 2.6.8之前的内核，epoll使用hash来组织fds集合，于是在创建epoll fd的时候，epoll需要初始化hash的大小。于是epoll_create(int size)有一个参数size，以便内核根据size的大小来分配hash的大小。在linux 2.6.8以后的内核中，epoll使用红黑树来组织监控的fds集合，于是epoll_create(int size)的参数size实际上已经没有意义了。</p>
<blockquote>
<p>按需遍历就绪的fds集合</p>
</blockquote>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)</p>
<p>其优点主要有如下几点：</p>
<ul>
<li>监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于1024</li>
<li>IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>监视事件数量</p>
</blockquote>
<p>select受限于1024（依据系统而定），poll虽然数量上没有收到限制，但是因为需要轮询数量非常大的时候性能会下降，epoll在数量和性能上面都没有限制</p>
<blockquote>
<p>实现方式</p>
</blockquote>
<p>select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用 epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在 epoll_wait中进入睡眠的进程<br>虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的 时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间，这就是回调机制带来的性能提升。</p>
<blockquote>
<p>开销</p>
</blockquote>
<p>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内 部定义的等待队列），这也能节省不少的开销</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Unix网络编程》</li>
<li><a href="https://segmentfault.com/a/1190000003063859#articleHeader9" target="_blank" rel="external">https://segmentfault.com/a/1190000003063859#articleHeader9</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1005481" target="_blank" rel="external">https://cloud.tencent.com/developer/article/1005481</a></li>
<li><a href="http://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="external">http://www.cnblogs.com/Anker/p/3265058.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期写一个在线聊天室的时候接触到epoll，加上之前腾讯面试的时候面试官有问到这一题。这里就对select、poll和epoll做一个总结，目的是让自己更加深入地理解，大部分内容来自网上，可能存在错误，欢迎大家指正。&lt;/p&gt;
    
    </summary>
    
      <category term="开发随笔" scheme="https://www.liuin.cn/categories/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Unix" scheme="https://www.liuin.cn/tags/Unix/"/>
    
  </entry>
  
  <entry>
    <title>《Effective C++》 笔记</title>
    <link href="https://www.liuin.cn/2018/04/19/%E3%80%8AEffective-C-%E3%80%8B-%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.liuin.cn/2018/04/19/《Effective-C-》-笔记/</id>
    <published>2018-04-19T08:18:10.000Z</published>
    <updated>2018-04-29T11:30:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>《Effective C++》的副标题是改善程序与设计的55个具体做法。这本书用比较多的示例展示了很多改善C++程序的方法，值得一读。</p>
<a id="more"></a>
<h2 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h2><h3 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款01：视C++为一个语言联邦</h3><p>C++高效编程守则视状况而变化,取决于你使用C++的哪一部分。</p>
<h3 id="条款02：尽量以const，enum，inline替换-define"><a href="#条款02：尽量以const，enum，inline替换-define" class="headerlink" title="条款02：尽量以const，enum，inline替换#define"></a>条款02：尽量以const，enum，inline替换#define</h3><p>“宁可以编译器替换预处理器”</p>
<p>当我们以常量替换<code>#defines</code>,有两种特殊情况值得说说。第一是定义常量指针( constant pointers)。由于常量定义式通常被放在头文件内(以便被不同的源码含入),因此有必要将指针(而不只是指针所指之物)声明为<code>const</code></p>
<p>第二个值得注意的是<code>class</code>专属常量。为了将常量的作用域(scope)限制于<code>class</code>内,你必须让它成为 class一个成员(member);而为确保此常量至多只有一份实体,你必须让它成为一个<code>static</code>成员:</p>
<blockquote>
<p>重点</p>
<ul>
<li>对于单纯常量,最好以 const对象或 enums替换#defines</li>
<li>对于形似函数的宏( macros),最好改用 inline函数替换#defines</li>
</ul>
</blockquote>
<h3 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h3><p>const的一件奇妙的事情是，它允许你指定一个语义约束，而编译器会强制执行这项约束。</p>
<p>const语法虽然变化多端,但并不莫测高深。如果关键字const出现在星号左边,表示被指物是常量(底层const)；如果出现在星号右边,表示指针自身是常量(顶层const);如果出现在星号两边,表示被指物和指针两者都是常量。</p>
<p>const最具威力的用法是面对函数声明时的应用。在一个函数声明式内, const可以和函数返回值、各参数、函数自身(如果是成员函数)产生关联。</p>
<blockquote>
<p>const 成员函数</p>
</blockquote>
<p>将 const实施于成员函数的目的,是为了确认该成员函数可作用于 const对象身上。这一类成员函数之所以重要,基于两个理由。第一,它们使 class接口比较容易被理解。这是因为,得知哪个函数可以改动对象内容而哪个函数不行,很是重要。第二,它们使“操作 const对象”成为可能。</p>
<blockquote>
<p>重点</p>
<ul>
<li>将某些东西声明为 const可帮助编译器侦测出错误用法。 const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体</li>
<li>当 const和non- const成员函数有着实质等价的实现时,令non- const版本调用 const版本可避免代码重复。</li>
</ul>
</blockquote>
<h3 id="条款04：确认对象使用前已被初始化"><a href="#条款04：确认对象使用前已被初始化" class="headerlink" title="条款04：确认对象使用前已被初始化"></a>条款04：确认对象使用前已被初始化</h3><p>在某些语境下x保证被初始化(为0),但在其他语境中却不保证。<strong>读取未初始化的值会导致不明确行为</strong></p>
<p>对于内置类型之外的东西，初始化的任务落在了构造函数的身上。我们要确保每一个构造函数都将对象的每一个成员初始化。但是我们很容易混淆复制和初始化的而例子，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; b);</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> thea;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> theb;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">A::A(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; b)</div><div class="line">&#123;</div><div class="line">    thea = a;   <span class="comment">// 这些都是赋值，而非初始化</span></div><div class="line">    theb = b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>C++规定,对象的成员变量的初始化动作发生在进入构造函数本体之前。所以构造函数最好使用成员初值列进行初始化。</p>
<blockquote>
<p>重点</p>
<ul>
<li>为内置型对象进行手工初始化,因为C++不保证初始化它们。</li>
<li>构造函数最好使用成员初值列( member initialization list),而不要在构造函数本体内使用赋值操作( assignment)。初值列列出的成员变量,其排列次序应该和它们在 class中的声明次序相同。</li>
</ul>
</blockquote>
<h2 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h2><h3 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款05：了解C++默默编写并调用哪些函数</h3><p>如果你自己没声明,编译器就会为它声明(编译器版本的)一个copy构造函数、一个 copy assignment操作符和一个析构函数。此外如果你没有声明任何构造函数,编译器也会为你声明一个 default构造函数。所有这些函数都是 public且in1ine。</p>
<p>default构造函数和析构函数主要是给编译器一个地方用来放置“藏身幕后”的代码,像是调用 base classes和non-static成员变量的构造函数和析构函数。</p>
<p>至于copy构造函数和 copy assignment操作符,编译器创建的版本只是单纯地将来源对象的每一个non- static成员变量拷贝到目标对象。</p>
<blockquote>
<p>重点</p>
<ul>
<li>编译器可以暗自为 class创建default构造函数、copy构造函数、 copy assignment操作符,以及析构函数。</li>
</ul>
</blockquote>
<h3 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>如果你不希望 class支持某一特定机能,只要不声明对应函数就是了。但这个策略对copy构造函数和copy assignment操作符却不起作用</p>
<p>所有编译器产出的函数都是 public.为阻止这些函数被创建出来,你得自行声明它们,但这里并没有什么需求使你必须将它们声明为 public。因此你可以将cory构造函数或 copy assignment操作符声明为 private。藉由明确声明一个成员函数,你阻止了编译器暗自创建其专属版本;而令这些函数为 private,使你得以成功组织别人调用他</p>
<blockquote>
<p>重点</p>
<ul>
<li>为驳回编译器自动(暗自)提供的机能,可将相应的成员函数声明为 private并且不予实现。</li>
</ul>
</blockquote>
<h3 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h3><p>C++明白指出,当 derived class对象经由一个base class指针被删除,而该 base class带着一个non- virtual析构函数,其结果未有定义实际执行时通常发生的是对象的 derived成分没被销毁。</p>
<p>消除这个问题的做法很简单:给 base class一个 virtua析构函数</p>
<blockquote>
<p>重点</p>
<ul>
<li>polymorphic(带多态性质的) base classes应该声明一个 virtual析构函数。如果class带有任何 virtual函数,它就应该拥有一个 virtual析构函数。</li>
</ul>
</blockquote>
<h3 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h3><p>C++并不禁止析构函数吐出异常,但它不鼓励你这样做。理由是当有多个（比如在vector中）对象需要销毁的时候，第一个对象和第二个对象析构是都抛出异常，这种情况下程序不是结束执行就是导致未定义行为。</p>
<blockquote>
<p>重点</p>
<ul>
<li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常,析构函数应该捕捉任何异常,然后吞下它们(不传播)或结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应,那么 class应该提供一个普通函数(而非在析构函数中)执行该操作。</li>
</ul>
</blockquote>
<h3 id="条款09：绝不要在构造函数和析构函数中调用virtual函数"><a href="#条款09：绝不要在构造函数和析构函数中调用virtual函数" class="headerlink" title="条款09：绝不要在构造函数和析构函数中调用virtual函数"></a>条款09：绝不要在构造函数和析构函数中调用virtual函数</h3><p>在base class构造期间，virtual函数不是virtual函数。</p>
<blockquote>
<p>重点</p>
<ul>
<li>在构造和析构期间不要调用 virtual函数,因为这类调用从不下降至 derived class(比起当前执行构造函数和析构函数的那层)</li>
</ul>
</blockquote>
<h3 id="条款10：令operator-返回一个-reference-to-this"><a href="#条款10：令operator-返回一个-reference-to-this" class="headerlink" title="条款10：令operator= 返回一个 reference to *this"></a>条款10：令operator= 返回一个 reference to *this</h3><p>复制可以写成连锁形式：</p>
<p><code>x = y = z = 15;</code></p>
<p>同时赋值采用右结合律,所以上述连锁赋值被解析为:</p>
<p><code>x = (y = (z = 15));</code></p>
<p>为了实现“连锁赋值”,赋值操作符必须返回一个 reference指向操作符的左侧实参。</p>
<blockquote>
<p>重点</p>
<ul>
<li>令赋值( assignment)操作符返回一个 reference to *this。</li>
</ul>
</blockquote>
<h3 id="条款11：在operator-中处理“自我赋值”"><a href="#条款11：在operator-中处理“自我赋值”" class="headerlink" title="条款11：在operator= 中处理“自我赋值”"></a>条款11：在operator= 中处理“自我赋值”</h3><p>“自我赋值“发生在对象赋值给自己时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Widget &#123; ... &#125; ;</div><div class="line">Widget w;</div><div class="line">...</div><div class="line">w = w;</div></pre></td></tr></table></figure>
<p>这看起来有点愚蠢,但它合法,所以不要认定客户绝不会那么做。</p>
<p>自我赋值可能出现的一个问题是, operator=函数内的*this(赋值的目的端)和rhs有可能是同一个对象。果真如此 delete就不只是销毁当前对象的 bitmap,它也销毁rhs的 bitmap。</p>
<p>欲阻止这种错误,传统做法是藉由 operator=最前面的一个“证同测试( identitytest)”达到“自我赋值”的检验目的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>重点</p>
<ul>
<li>确保当对象自我赋值时 operator=有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及 copy-and-swap。</li>
<li>确定任何函数如果操作一个以上的对象,而其中多个对象是同一个对象时,其行为仍然正确。</li>
</ul>
</blockquote>
<h3 id="条款12：复制对象时勿忘其每一个成分"><a href="#条款12：复制对象时勿忘其每一个成分" class="headerlink" title="条款12：复制对象时勿忘其每一个成分"></a>条款12：复制对象时勿忘其每一个成分</h3><blockquote>
<p>重点</p>
<ul>
<li>Copying函数应该确保复制“对象内的所有成员变量”及“所有 base class成分”。</li>
<li>不要尝试以某个 copying函数实现另一个 copying函数。应该将共同机能放进第三个函数中,并由两个 coping函数共同调用。</li>
</ul>
</blockquote>
<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h3 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h3><p>有的时候我们我们使用工厂函数获得某个特定的对象的指针的时候，在使用完毕时候需要将其占用的空间释放，尽管我们有这个意识，但是在实际开发中，如果中间出现异常或者return可能会造成内存泄漏的现象。</p>
<p>为了确保使用工厂函数返回的资源总是被释放,我们需要将资源放进对象内,当控制流离开f,<strong>该对象的析构函数会自动释放那些资源</strong>。实际上这正是隐身于本条款背后的半边想法:把资源放进对象内,我们便可倚赖C++的“析构函数自动调用机制”确保资源被释放。(稍后讨论另半边想法。)</p>
<blockquote>
<p>重点</p>
<ul>
<li>为防止资源泄漏,请使用RAII对象,它们在构造函数中获得资源并在析构函数中释放资源</li>
<li>两个常被使用的 RAII classes分别是trl::shared_ptr和 auto_ptr。前者通常是较佳选择,因为其copy行为比较直观。若选择 auto_ptr,复制动作会使它(被复制物)指向null</li>
</ul>
</blockquote>
<h3 id="条款14：在资源管理类中小心coping行为"><a href="#条款14：在资源管理类中小心coping行为" class="headerlink" title="条款14：在资源管理类中小心coping行为"></a>条款14：在资源管理类中小心coping行为</h3><p>我们使用C API管理一个互斥对象的时候，有lock和unlock两个函数可以用；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(Mutex* pm)</span></span>;     <span class="comment">// 锁定</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(Mutex* pm)</span></span>;   <span class="comment">// 解锁</span></div></pre></td></tr></table></figure>
<p>为了确保不会忘记解锁一个互斥量，我们可以使用上一个条款的建议，创建一个对象来管理这个互斥量，使得“资源在构造期间获得，在析构期间释放”</p>
<p>但是如果这个对象发生复制的时候怎么办？大多时候有以下两种可行的方案：</p>
<ul>
<li>禁止复制</li>
<li>对底层资源祭出“引用计数法”（reference-count）</li>
</ul>
<blockquote>
<p>重点</p>
<ul>
<li>复制RAII对象必须一并复制它所管理的资源,所以资源的copying行为决定RAII对象的copying行为。</li>
<li>普遍而常见的 Rail class copying行为是:抑制 copying、施行引用计数法( reference counting)。不过其他行为也都可能被实现</li>
</ul>
</blockquote>
<h3 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h3><p>资源管理类( resource-managing classes)很棒。它们是你对抗资源泄漏的堡垒。排除此等泄漏是良好设计系统的根本性质。在一个完美世界中你将倚赖这样的classes来处理和资源之间的所有互动,而不是玷污双手直接处理原始资源(rawresources)。但这个世界并不完美。许多APIs直接指涉资源,所以除非你发誓(这其实是一种少有实际价值的举动)永不录用这样的APls,否则只得绕过资源管理对象( resource-managing objects)直接访问原始资源( raw resources)。</p>
<p>由于有时候还是必须取得RAI对象内的原始资源,某些 RAII class设计者于是联想到“将油脂涂在滑轨上”,做法是提供一个显示转换函数或者隐式转换函数。</p>
<blockquote>
<p>重点</p>
<ul>
<li>APIs往往要求访问原始资源( raw resources),所以每一个 RAII class应该提供一个“取得其所管理之资源”的办法。</li>
<li>对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全,但隐式转换对客户比较方便。</li>
</ul>
</blockquote>
<h3 id="条款16：成对使用new和delete时要采取相同格式"><a href="#条款16：成对使用new和delete时要采取相同格式" class="headerlink" title="条款16：成对使用new和delete时要采取相同格式"></a>条款16：成对使用new和delete时要采取相同格式</h3><p>当你使用new(也就是通过new动态生成一个对象),有两件事发生。第内存被分配出来(通过名为 operator new的函数)。第二,针对此内存会有一个(或更多)构造函数被调用。</p>
<p>当你使用 delete,也有两件事发生:针对此内存会有一个(或更多)析构函数被调用,然后内存才被释放(通过名为 operator delete的函数)。</p>
<p>delete的最大问题在于:即将被删除的内存之内究竟存有多少对象?这个问题的答案决定了有多少个析构函数必须被调用起来。实际上这个问题可以更简单些:即将被删除的那个指针,所指的是单一对象或对象数组?这是个必不可缺的问题,因为单一对象的内存布局一般而言不同于数组的内存布局。</p>
<p>所以在成对使用new和delete的时候要采取相同的形式</p>
<blockquote>
<p>重点</p>
<ul>
<li>如果你在new表达式中使用[],必须在相应的de1ete表达式中也使用[]。如果你在new表达式中不使用[],一定不要在相应的 delete表达式中使用[]</li>
</ul>
</blockquote>
<h3 id="条款17：以独立语句将newed对象置入智能指针"><a href="#条款17：以独立语句将newed对象置入智能指针" class="headerlink" title="条款17：以独立语句将newed对象置入智能指针"></a>条款17：以独立语句将newed对象置入智能指针</h3><blockquote>
<p>重点</p>
<ul>
<li>以独立语句将 newed对象存储于(置入)智能指针内。如果不这样做,一旦异常被抛出,有可能导致难以察觉的资源泄漏。</li>
</ul>
</blockquote>
<h2 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h2><h3 id="条款18：让接口容易被正确使用，不容易被误用"><a href="#条款18：让接口容易被正确使用，不容易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不容易被误用"></a>条款18：让接口容易被正确使用，不容易被误用</h3><p>欲开发一个“容易被正确使用,不容易被误用”的接口,首先必须考虑客户可能做出什么样的错误。</p>
<p>预防客户错误的另一个办法是,限制类型内什么事可做,什么事不能做。常见的限制是加上 const。例如，以const修饰operator* 的返回类型可以阻止客户因“用户自定义类型”而犯错：</p>
<p><code>if( a * b = c ) ...</code>原意应该为做一次比较动作</p>
<p>下面是另一个一般性准则“让 types容易被正确使用,不容易被误用”的表现形式“除非有好理由,否则应该尽量令你的 types的行为与内置 types一致”。客户已经知道像int这样的type有些什么行为,所以你应该努力让你的 types在合样合理的前提下也有相同表现。</p>
<blockquote>
<p>重点</p>
<ul>
<li>好的接口很容易被正确使用,不容易被误用。你应该在你的所有接口中努力达成这些性质。</li>
<li>“促进正确使用”的办法包括接口的一致性,以及与内置类型的行为兼容。</li>
<li>“阻止误用”的办法包括建立新类型、限制类型上的操作,束缚对象值,以及消除客户的资源管理责任</li>
</ul>
</blockquote>
<h3 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款19：设计class犹如设计type</h3><p>设计优秀的 classes是一项艰巨的工作,因为设计好的 types是一项艰巨的工作。好的 types有自然的语法,直观的语义,以及一或多个高效实现品。在C++中,一个不良规划下的 class定义恐怕无法达到上述任何一个目标。甚至 class的成员函数的效率都有可能受到它们“如何被声明”的影响。</p>
<p>设计一个class需要思考如下的一些问题：</p>
<ul>
<li>新type的对象应该如何被创建和销毁?这会影响到你的 class的构造函数和析构函数以及内存分配函数和释放函数( operator new, operator new[], operator delete和 operator delete[])的设计,当然前提是如果你打算撰写它们。</li>
<li>对象的初始化和对象的赋值该有什么样的差别?这个答案决定你的构造函数和赋值操作符的行为,以及其间的差异。</li>
<li>新type的对象如果被 passed by value(以值传递),意味着什么?记住,copy构造函数用来定义一个type的 pass-by-value该如何实现。</li>
<li>什么是新“type”的合法值</li>
<li>你的新type需要配合某个继承图系( inheritance graph)吗?</li>
</ul>
<h3 id="条款20：宁以pass-by-reference-to-const-替换-pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const-替换-pass-by-value" class="headerlink" title="条款20：宁以pass-by-reference-to-const 替换 pass-by-value"></a>条款20：宁以pass-by-reference-to-const 替换 pass-by-value</h3><p>一般情况下，使用pass-by-reference-to-const能够调用更少的构造函数和析构函数，从而使得程序更加高效。</p>
<p>以by reference方式传递参数也可以避免 slicing(对象切割)问题。当一个 derived class对象以 by value方式传递并被视为一个 base class对象, base class的copy构造函数会被调用,而“造成此对象的行为像个 derived class对象”的那些特化性质全被切割掉了,仅仅留下一个 base class对象。</p>
<p>但是如果你有个对象属于内置类型(例如int), pass by value往往比 pass by reference的效率高些。对内置类型而言,当你有机会选择采用 pass-by-value或 pass-by-reference-to-const时,选择 pass-by-value并非没有道理。这个忠告也适用于STL的迭代器和函数对象,因为习惯上它们都被设计为passed by value。迭代器和函数对象的实践者有责任看看它们是否高效且不受切割问题</p>
<blockquote>
<p>重点</p>
<ul>
<li>尽量以 pass-by-reference-to-const替换 pass-by-value。前者通常比较高效,并可避免切割问题( slicing problem)</li>
<li>以上规则并不适用于内置类型,以及STL的迭代器和函数对象。对它们而言,pas- by-value往往比较适当。</li>
</ul>
</blockquote>
<h3 id="条款21：必须返回对象的时，别妄想返回其reference"><a href="#条款21：必须返回对象的时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象的时，别妄想返回其reference"></a>条款21：必须返回对象的时，别妄想返回其reference</h3><blockquote>
<p>重点</p>
<ul>
<li></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Effective C++》的副标题是改善程序与设计的55个具体做法。这本书用比较多的示例展示了很多改善C++程序的方法，值得一读。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C/C++" scheme="https://www.liuin.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>APUE 信号</title>
    <link href="https://www.liuin.cn/2018/04/18/APUE-%E4%BF%A1%E5%8F%B7/"/>
    <id>https://www.liuin.cn/2018/04/18/APUE-信号/</id>
    <published>2018-04-18T13:37:51.000Z</published>
    <updated>2018-04-19T01:28:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第10章 信号 笔记</p>
<a id="more"></a>
<p>信号是软件中断。很多比较重要的应用程序都需处理信号。信号提供了一种<strong>处理异步事件</strong>的方法,例如,终端用户键入中断键,会通过信号机制停止一个程序,或及早终止管道中的下一个程序。</p>
<h2 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h2><p>每个信号都有一个名字，这些名字都以3个字符SIG开头，比如：SIGINT中断信号、SIGABRT夭折信号、SIGALRM闹钟信号。</p>
<p>产生信号的条件：</p>
<ul>
<li>当用户按某些终端键时,引发终端产生的信号。</li>
<li>硬件异常产生信号:除数为0、无效的内存引用等。</li>
<li>进程调用ki11(2)函数可将任意信号发送给另一个进程或进程组。</li>
<li>用户可用ki11(1)命令将信号发送给其他进程</li>
<li>当检测到某种软件条件已经发生,并应将其通知有关进程时也产生信号</li>
</ul>
<p>信号是异步事件的经典实例。产生信号的事件对进程而言是随机出现的。进程不能简单地测试一个变量(如 errno)来判断是否发生了一个信号,而是必须告诉内核“在此信号发生时,请执行下列操作”。</p>
<p>在某个信号出现时,可以告诉内核按下列3种方式之一进行处理,我们称之为信号的处理或与信号相关的动作：</p>
<ul>
<li>忽略此信号，有两种信号不能被忽略，它们是 SIGKILL和 SIGSTOP。这两种信号不能被忽略的原因是:它们向内核和超级用户提供了使进程终止或停止的可靠方法。</li>
<li>捕捉信号，通知内核在某种信号发生时,调用一个用户函数。在用户函数中,可执行用户希望对这种事件进行的处理。</li>
<li>执行系统默认操作</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-04-18-15240592901538.jpg" alt=""></p>
<h2 id="函数signal"><a href="#函数signal" class="headerlink" title="函数signal"></a>函数signal</h2><p>UNX系统信号机制最简单的接口是 signa1函数，其用于捕获信号，并捕获以后发生什么事情。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> signo, <span class="keyword">void</span> (*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>); </div><div class="line"></div><div class="line"><span class="comment">//Returns: previous disposition of signal (see following) if OK, SIG_ERR on error</span></div></pre></td></tr></table></figure>
<p><code>signo</code>参数是信号名。<code>func</code>的值是常量SIG_IGN、常量SIG_DEL或当接到此信号后要调用的函数的地址。<code>SIG_IGN</code>表示向内核表示忽略此信号(记住有两个信号 SIGKILI和 SIGSTOP不能忽略)。SIG_DEL表示接到此信号后的动作是系统默认动作。</p>
<p>当指定函数地址时，则在信号发生时，调用该函数，我们称这种处理为捕获该信号，称此函数为信号处理程序( signal handler)或信号捕捉函数 (signal-catching function)</p>
<blockquote>
<p>程序启动</p>
</blockquote>
<p>当执行一个程序时,所有信号的状态都是系统默认或忽略。通常所有信号都被设置为它们的默认动作,除非调用exec的进程忽略该信号。确切地讲,<strong>exec函数将原先设置为要捕捉的信号都更改为默认动作</strong>,其他信号的状态则不变(一个进程原先要捕捉的信号,当其执行一个新程序后,就不能再捕捉了,因为信号捕捉函数的地址很可能在所执行的新程序文件中已无意义)。</p>
<blockquote>
<p>进程创建</p>
</blockquote>
<p>当一个进程调用fork时,其子进程继承父进程的信号处理方式。因为子进程在开始时复制了父进程内存映像,所以信号捕捉函数的地址在子进程中是有意义的</p>
<h2 id="不可靠信号"><a href="#不可靠信号" class="headerlink" title="不可靠信号"></a>不可靠信号</h2><p>在早期的UNX版本中(如V7),信号是不可靠的。不可靠在这里指的是,信号可能会丢失。一个信号发生了,但进程却可能一直不知道这一点。同时,进程对信号的控制能力也很差,它能捕捉信号或忽略它。有时用户希望通知内核阻塞某个信号:不要忽略该信号,在其发生时记住它然后在进程做好了准备时再通知它。这种阻塞信号的能力当时并不具备</p>
<p>这些早期版本的另一个问题是:在进程不希望某种信号发生时,它不能关闭该信号。进程能做的一切就是忽略该信号。</p>
<h2 id="中断的系统调用"><a href="#中断的系统调用" class="headerlink" title="中断的系统调用"></a>中断的系统调用</h2><p>早期UNX系统的一个特性是:如果进程在执行一个低速系统调用而阻塞期间捕捉到一个信号,则该系统调用就被中断不再继续执行。该系统调用返回出错,其erno设置为EINTR。</p>
<p>为了支持这种特性,将系统调用分成两类:低速系统调用和其他系统调用。低速系统调用是可能会使进程永远阻塞的类系统调用。</p>
<p>可以用中断系统调用这种方法来处理的一个例子是:一个进程启动了读终端操作,而使用该终端设备的用户却离开该终端很长时间。在这种情况下,进程可能处于阻塞状态几个小时甚至数天,除非系统停机,否则一直如此</p>
<h2 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h2><p>进程捕捉到信号并对其进行处理时,进程正在执行的正常指令序列就被信号处理程序临时中断,它首先执行该信号处理程序中的指令。如果从信号处理程序返回,则继续执行在捕捉到信号时进程正在执行的正常指令序列(这类似于发生硬件中断时所做的)。但在信号处理程序中,<strong>不能判断捕捉到信号时进程执行到何处</strong>。</p>
<p>在信号处理函数中保证调用安全的函数（可以被安全中断的函数），这些函数是<strong>可重入的</strong>并被称之为<strong>异步信号安全的</strong></p>
<p>大多数函数是不可重入的,因为<br>(a)已知它们使用静态数据结构;<br>(b)它们调用mal1oc或free;<br>(c)它们是标准I/O函数。标准IO库的很多实现都以不可重入方式使用全局数据结构</p>
<h2 id="可靠信号术语与语义"><a href="#可靠信号术语与语义" class="headerlink" title="可靠信号术语与语义"></a>可靠信号术语与语义</h2><p>我们需要先定义一些在讨论信号时会用到的术语。首先,当造成信号的事件发生时,为进程产生一个信号(或向一个进程发送一个信号)。事件可以是硬件异常(如除以0)、软件条件(如a1arm定时器超时)、终端产生的信号或调用ki11函数。当一个信号产生时,<strong>内核通常在进程表中以某种形式设置一个标志</strong>。</p>
<p>当对信号采取了这种动作时,我们说向进程递送了一个信号。在信号产生(generation)和递送(delivery)之间的时间间隔内,称信号是<strong>未决的</strong>(pending)</p>
<p>进程可以选用“阻塞信号递送”。如果为进程产生了一个阻塞的信号,而且对该信号的动作是系统默认动作或捕捉该信号,则为该进程将此信号保持为未决状态,直到该进程对此信号解除了阻塞,或者将对此信号的动作更改为忽略。内核在递送一个原来被阻塞的信号给进程时(而不是在产生该信号时),才决定对它的处理方式。于是进程在信号递送给它之前仍可改变对该信号的动作。进程调用<code>sigpending</code>函数来判定哪些信号是设置为阻塞并处于未决状态的。</p>
<p>每个进程都有一个信号屏蔽字( signal mask.),它规定了当前要阻塞递送到该进程的信号集。对于每种可能的信号,该屏蔽字中都有一位与之对应。对于某种信号,若其对应位已设置,则它当前是被阻塞的。进程可以调用 <code>sigprocmask</code>来检测和更改其当前信号屏蔽字。</p>
<h2 id="函数kill和raise"><a href="#函数kill和raise" class="headerlink" title="函数kill和raise"></a>函数kill和raise</h2><p>ki11函数将信号发送给进程或进程组。 ralse函数则允许进程向自身发送信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signo)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>进程将信号发送给其他进程需要权限。超级用户可将信号发送给任一进程。对于非超级用户,其基本规则是发送者的实际用户DD或有效用户ID必须等于接收者的实际用户ID或有效用户ID。</p>
<h2 id="函数alarm和pause"><a href="#函数alarm和pause" class="headerlink" title="函数alarm和pause"></a>函数alarm和pause</h2><p>使用alarm函数可以设置一个定时器(闹钟时间),在将来的某个时刻该定时器会超时。当定时器超时时,产生 SIGALRM信号。如果忽略或不捕捉此信号,则其默认动作是终止调用该a1arm函数的进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 or number of seconds until previously set alarm</span></div></pre></td></tr></table></figure>
<p>每个进程只能有一个闹钟时间。如果在调用a1arm时,之前已为该进程注册的闹钟时间还没有超时,则该闹钟时间的余留值作为本次a1arm函数调用的值返回。以前注册的闹钟时间则被新值代替。</p>
<p>如果有以前注册的尚未超过的闹钟时间,而且本次调用的 seconds值是0,则取消以前的闹钟时间,其余留值仍作为a1arm函数的返回值</p>
<p>pause函数使调用进程挂起直至捕捉到一个信号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: −1 with errno set to EINTR</span></div></pre></td></tr></table></figure>
<p>只有执行了一个信号处理程序并返回时，pause才返回</p>
<h2 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h2><p>我们需要有一个能表示多个信号—信号集(signal set)的数据类型。我们将在sigprocmask类函数中使用这种数据类型,以便告诉内核不允许发生该信号集中的信号。不同的信号的编号可能超过一个整型量所包含的位数,所以一般而言,不能用整型量中的一位代表一种信号,也就是不能用一个整型量表示信号集。POSIX 定义数据类型sigset_t以包含一个信号集,并且定义了下列5个处理信号集的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All four return: 0 if OK, −1 on error int sigismember(const sigset_t *set, int signo); Returns: 1 if true, 0 if false, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="函数sigprocmask"><a href="#函数sigprocmask" class="headerlink" title="函数sigprocmask"></a>函数sigprocmask</h2><p>调用函数<code>sigprocmask</code>可以检测或更改,或同时进行检测和更改进程的信号屏蔽字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> oset)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>如果oset为是非空指针，则进程当前的信号屏蔽字通过oset返回<br>其次,若ser是一个非空指针,则参数how指示如何修改当前信号屏蔽字。主要的操作有并集、交集、替代</p>
<p>在调用<code>sigprocmask</code>后如果有任何未决的、不再阻塞的信号,则在<code>sigprocmask</code>返回前至少将其中之一递送给该进程</p>
<h2 id="函数sigpending"><a href="#函数sigpending" class="headerlink" title="函数sigpending"></a>函数sigpending</h2><p><code>sigpending</code>函数返回一信号集,对于调用进程而言,其中的各信号是阻塞不能递送的,因而也一定是当前未决的。该信号集通过set参数返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="函数sigaction"><a href="#函数sigaction" class="headerlink" title="函数sigaction"></a>函数sigaction</h2><p><code>sigaction</code>函数的功能是检查或修改(或检查并修改)与指定信号相关联的处理动作。此函数取代了UNX早期版本使用的 signa1函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> <span class="keyword">struct</span> sigaction *<span class="keyword">restrict</span> act, <span class="keyword">struct</span> sigaction *<span class="keyword">restrict</span> oact)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>参数signo是要检测或修改其具体动作的信号编号。若act指针非空,则要修改其动作。如果oact指针非空,则系统经由oact指针返回该信号的上一个动作。</p>
<h2 id="函数abort"><a href="#函数abort" class="headerlink" title="函数abort"></a>函数abort</h2><p>abort函数的功能是使程序异常终止，此函数将 SIGABRT信号发送给调用进程(进程不应忽略此信号)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// This function never returns</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第10章 信号 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>Unix 进程间通信</title>
    <link href="https://www.liuin.cn/2018/04/13/Unix-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://www.liuin.cn/2018/04/13/Unix-进程间通信/</id>
    <published>2018-04-13T14:52:23.000Z</published>
    <updated>2018-04-18T13:34:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结Unix下进程间通信的几种方式及其特点</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="进程同步和进程通信的区别"><a href="#进程同步和进程通信的区别" class="headerlink" title="进程同步和进程通信的区别"></a>进程同步和进程通信的区别</h3><p>关于这个问题，网络和很多书籍上把这两者混为一谈，对于这两者的区别，说法也有很多种。</p>
<p>其中一种说法是：</p>
<blockquote>
<p>进程互斥、同步与通信的关系：进程竞争资源时要实施互斥，互斥是一种特殊的同步，实质上需要解决好进程同步问题，进程同步是一种进程通信，由此看来，进程互斥、同步都可以看做进程的通信</p>
</blockquote>
<p>个人比较认同是以下这种说法：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行</li>
<li>进程通信：进程间传输信息</li>
</ul>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<p>在进程同步中介绍的信号量也属于进程通信的一种方式，但是属于低级别的进程通信，因为它传输的信息非常小。</p>
<h3 id="消息传递与共享内存"><a href="#消息传递与共享内存" class="headerlink" title="消息传递与共享内存"></a>消息传递与共享内存</h3><p>消息传递提供一种机制以允许进程不必通过共享地址空间来实现通信和同步，消息传递工具提供至少两种操作:发送(消息)和接收(消息)。由进程发送的消息可以是定长的或变长的。</p>
<p>操作系统提供用于通信的通道，进程通过读写这个通道进行通信。</p>
<p>Unix中基于消息传递实现的IPC有：管道、FIFO、消息队列以及网络间的Socket通信</p>
<p>共享内存的进程间通信需要通信进程建立共享内存区域。通常,一块共享内存区域驻留在生成共享内存段进程的地址空间。其他希望使用这个共享内存段进行通信的进程必须将此放到它们自己的地址空间上。</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道用于有亲缘关系的两个进程（父子进程）进行通信，写进程在管道的尾端写入数据，读进程在管道的首端读出数据。管道提供了简单的流控制机制，进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。</p>
<p>通常,一个管道由一个进程创建,在进程调用fork之后,这个管道就能在父进程和子进程之间使用了。</p>
<p>管道存在以下这些局限性：</p>
<ol>
<li>历史上,它们是半双工的(即数据只能在一个方向上流动)。现在,某些系统提供全双工管道,但是为了最佳的可移植性,我们决不应预先假定系统支持全双工管道</li>
<li>管道只能在具有公共祖先的两个进程之间使用。</li>
</ol>
<p>在Unix中管道是通过调用<code>pipe</code>函数创建的。对于一个从子进程到父进程的管道,父进程关闭fd[1],子进程关闭fd[0]。</p>
<p><img src="https://data2.liuin.cn/2018-04-18-15240546357016.jpg" alt=""></p>
<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>FIFO有时被称为命名管道。未命名的管道只能在两个相关的进程之间使用,而且这两个相关的进程还要有一个共同的创建了它们的祖先进程。但是,通过FIFO,不相关的进程也能交换数据。</p>
<p>在Unix中使用<code>mkfifo</code>或者<code>mkfifoat</code>创建FIFO，使用<code>open</code>打开，使用正常文件的I/O函数对FIFO进行读写操作实现进程间通信的目的。</p>
<p>使用FIFO实现两进程间通信的例子：</p>
<p><img src="https://data2.liuin.cn/2018-04-18-15240551859039.jpg" alt=""></p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是消息的链接表,存储在内核中,由消息队列标识符标识。</p>
<p>在Unix中使用<code>msgget</code>用于创建一个新队列或打开一个现有队列、<code>msgsnd</code>将新消息添加到队列尾端。<code>mmsgrcv</code>用于从队列中取消息。我们并不定要以先进先出次序取消息,也可以按消息的类型字段取消息。<br>每个消息包含一个正的长整型类型的字段、一个非负的长度以及实际数据字节数(对应于长度),所有这些都在将消息添加到队列时,传送给 msgsna。</p>
<p>消息队列相比于其他方式有很多优点：它提供有格式的字节流，减少了开发人员的工作量；消息具有类型（system V）或优先级（posix）</p>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>Socket 是网络进程间通信的一种，我们将描述套接字网络进程间通信接口,进程用该接口能够和其他进程通信,无论它们是在同一台计算机上还是在不同的计算机上。实际上,这正是套接字接口的设计目标之一。</p>
<p>Socket自身携带同步机制，不需要额外的方式来辅助实现同步。</p>
<p>在Unix中使用<code>socket</code>、<code>bind</code>、<code>connect</code>、<code>listen</code>、<code>accept</code>等一系列系统调用建立连接并进行通信。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量是一个计数器，用于多进程提供对共享数据对象的访问。</p>
<p>为了获得共享资源,进程需要执行下列操作。</p>
<ol>
<li>测试控制该资源的信号量</li>
<li>若此信号量的值为正,则进程可以使用该资源。在这种情况下,进程会将信号量值减1,表示它使用了一个资源单位。</li>
<li>否则,若此信号量的值为0,则进程进入休眠状态,直至信号量值大于0。进程被唤醒后,它返回至步骤(1)。</li>
</ol>
<p>当进程不再使用由一个信号量控制的共享资源时,该信号量值增1。如果有进程正在休眠等待此信号量,则唤醒它们。</p>
<p>为了正确地实现信号量,信号量值的测试及减1操作应当是原子操作。为此,信号量通常是在内核中实现的。</p>
<p>因为只能传递简单的数据，所以信号量常常只是用来进行进程间的同步。</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享存储允许两个或多个进程共享一个给定的存储区。因为数据不需要在客户进程和服务器进程之间复制,所以这是最快的一种IPC。</p>
<p>不过使用共享内存的时候要注意保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>管道</td>
<td>创建简单</td>
<td>容量有限、速度慢、只能用于父子进程通讯、半双工通信方式</td>
</tr>
<tr>
<td>FIFO</td>
<td>克服了管道没有名字的限制、允许无亲缘关系进程间的通信</td>
<td>速度慢</td>
</tr>
<tr>
<td>消息队列</td>
<td>承载信息量比较多、能够承载有格式的字节流</td>
<td>容量受到系统限制</td>
</tr>
<tr>
<td>Socket</td>
<td>能够实现网络间进程的通信</td>
<td>实现比较复杂</td>
</tr>
<tr>
<td>信号量</td>
<td>能够比较好地解决同步问题</td>
<td>传递的信息较少，只能用于同步</td>
</tr>
<tr>
<td>共享内存</td>
<td>速度快</td>
<td>要解决线程安全的问题</td>
</tr>
</tbody>
</table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Unix环境高级编程》</li>
<li>《Unix-Linux编程实践教程》</li>
<li>《操作系统概念》</li>
<li><a href="http://www.cnblogs.com/youngforever/p/3250270.html" target="_blank" rel="external">http://www.cnblogs.com/youngforever/p/3250270.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结Unix下进程间通信的几种方式及其特点&lt;/p&gt;
    
    </summary>
    
      <category term="开发随笔" scheme="https://www.liuin.cn/categories/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>同步/异步与阻塞/非阻塞的理解</title>
    <link href="https://www.liuin.cn/2018/04/09/%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E4%B8%8E%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://www.liuin.cn/2018/04/09/同步-异步与阻塞-非阻塞的理解/</id>
    <published>2018-04-09T02:57:32.000Z</published>
    <updated>2018-04-09T03:02:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期在了解网络编程的时候对同步/异步和阻塞/非阻塞这些概念有一些混淆，所查了一些资料总结了这篇文章。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于同步/异步与阻塞/非阻塞的理解可能各个领域的人的回答是不一样的，在网络上也有各种各样的说法。这其实是因为不同的人的知识背景不同，并且在讨论这个问题的时候上下文(context)也不相同。本文主要结合网络上的观点以及一些书籍谈谈对同步/异步与阻塞/非阻塞大致概念上的理解，以及在Linux Network IO上的这四个概念的情况。</p>
<h2 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h2><p>同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)</p>
<p>所谓同步，就是在发出一个<strong>调用</strong>时，在没有得到结果之前，该<strong>调用</strong>就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由<strong>调用者</strong>主动等待这个<strong>调用</strong>的结果。</p>
<p>而异步则是相反，<strong>调用</strong>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<strong>调用</strong>发出后，<strong>被调用者</strong>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
<p>打一个不恰当的比方：</p>
<blockquote>
<p>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p>
</blockquote>
<h2 id="阻塞-非阻塞"><a href="#阻塞-非阻塞" class="headerlink" title="阻塞/非阻塞"></a>阻塞/非阻塞</h2><p>阻塞和非阻塞关注的是程序在<strong>等待调用结果（消息，返回值）时的状态</strong>.</p>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<p>例子：</p>
<blockquote>
<p>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。</p>
</blockquote>
<p>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>
<p>把自己挂起可以是在电话里面一直等着老板回信（同步阻塞），也可以是挂掉电话以后一直等着老板回电过来（异步阻塞）。先玩一会儿可以是电话接通着你去玩一会儿（同步非阻塞），也可以是电话挂了你去玩老板回电给你的时候你回来接（异步非阻塞）。</p>
<p>阻塞和非阻塞描述的是一种状态，同步与非同步描述的是行为方式。</p>
<h2 id="Unix-网络IO"><a href="#Unix-网络IO" class="headerlink" title="Unix 网络IO"></a>Unix 网络IO</h2><p>POSIX对同步I/O和异步I/O的定义如下：</p>
<ul>
<li>同步I/O操作( synchronous I/O opetation) 导致请求进程阻塞,直到I/O操作完成</li>
<li>异步IO操作( asynchronous I/O opetation) 不导致请求进程阻塞。</li>
</ul>
<p>在Unix中有四种常用的网络IO模型：</p>
<ul>
<li>阻塞式I/O</li>
<li>非阻塞式I/O</li>
<li>I/O复用</li>
<li>异步I/O</li>
</ul>
<p>其中前者都是同步I/O</p>
<h3 id="阻塞式I-O"><a href="#阻塞式I-O" class="headerlink" title="阻塞式I/O"></a>阻塞式I/O</h3><p>默认情况下，所有套接字都是阻塞的。在下面展示recvfrom系统调用中把数据接收过程分成两个阶段：1. 等待数据 2. 数据复制到用户空间。</p>
<p><img src="https://data2.liuin.cn/2018-04-09-15232418188483.jpg" alt=""></p>
<p>在等待过程中，进程不能做其他事情，所以是阻塞式的。什么时候调用结束：有结果或者报错的时候，调用才结束，所以是同步的。</p>
<h3 id="非阻塞式I-O"><a href="#非阻塞式I-O" class="headerlink" title="非阻塞式I/O"></a>非阻塞式I/O</h3><p><img src="https://data2.liuin.cn/2018-04-09-15232420864225.jpg" alt=""></p>
<p>在非阻塞式I/O中进程在进行系统调用recvfrom的时候，如果数据没有准备好线程不会等待，而是不断询问，直到数据准备好，复制数据到用户空间以后，接受数据这个动作才算完成。</p>
<p>因为线程不是一直在等待数据返回，其中也可以做其他的事情，所以是非阻塞式的，对于接受数据这个动作，进程会不断询问，知道最后有结果才算结束，所以是同步式的。</p>
<h3 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h3><p><img src="https://data2.liuin.cn/2018-04-09-15232424437721.jpg" alt=""></p>
<p>我们阻塞于 select调用,等待数据报套接字变为可读。当se1ect返回套接字可读这一条件时,我们调用 recvfrom把所读数据报复制到应用进程缓冲区。</p>
<h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><p><img src="https://data2.liuin.cn/2018-04-09-15232425049293.jpg" alt=""></p>
<p>异步I/O的工作模式时:告知内核启动某个操作,并让内核在整个操作(包括将数据从内核复制到我们自己的缓冲区)完成后通知我们。所以进程不需要一直询问其数据是否准备好</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><img src="https://data2.liuin.cn/2018-04-09-15232425884264.jpg" alt=""></p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://www.zhihu.com/question/19732473/answer/20851256" target="_blank" rel="external">https://www.zhihu.com/question/19732473/answer/20851256</a></li>
<li>《Unix 网络编程》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期在了解网络编程的时候对同步/异步和阻塞/非阻塞这些概念有一些混淆，所查了一些资料总结了这篇文章。&lt;/p&gt;
    
    </summary>
    
      <category term="开发随笔" scheme="https://www.liuin.cn/categories/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Unix" scheme="https://www.liuin.cn/tags/Unix/"/>
    
  </entry>
  
  <entry>
    <title>Github分布式爬虫——数据分析</title>
    <link href="https://www.liuin.cn/2018/04/07/Github%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <id>https://www.liuin.cn/2018/04/07/Github分布式爬虫——数据分析/</id>
    <published>2018-04-07T01:54:54.000Z</published>
    <updated>2018-04-07T02:00:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>对Github分布式爬虫爬取的20w用户信息和40w仓库信息进行简单的分析和统计</p>
<a id="more"></a>
<p>这里爬取的数据主要有两大类：用户数据和仓库数据，此次分析的数据量：256171用户数据，434994仓库数据</p>
<h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><h3 id="全球用户榜单"><a href="#全球用户榜单" class="headerlink" title="全球用户榜单"></a>全球用户榜单</h3><h4 id="Followers人数榜"><a href="#Followers人数榜" class="headerlink" title="Followers人数榜"></a>Followers人数榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/1024025" alt=""></td>
<td><a href="https://github.com/torvalds" target="_blank" rel="external">https://github.com/torvalds</a></td>
<td>6</td>
<td>2</td>
<td>70400</td>
<td>0</td>
<td>8</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/66577" alt=""></td>
<td><a href="https://github.com/JakeWharton" target="_blank" rel="external">https://github.com/JakeWharton</a></td>
<td>95</td>
<td>228</td>
<td>45000</td>
<td>12</td>
<td>3541</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/905434" alt=""></td>
<td><a href="https://github.com/ruanyf" target="_blank" rel="external">https://github.com/ruanyf</a></td>
<td>48</td>
<td>206</td>
<td>38200</td>
<td>0</td>
<td>1645</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/25254" alt=""></td>
<td><a href="https://github.com/tj" target="_blank" rel="external">https://github.com/tj</a></td>
<td>273</td>
<td>2000</td>
<td>34400</td>
<td>46</td>
<td>3310</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/499550" alt=""></td>
<td><a href="https://github.com/yyx990803" target="_blank" rel="external">https://github.com/yyx990803</a></td>
<td>141</td>
<td>779</td>
<td>29200</td>
<td>90</td>
<td>2553</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/110953" alt=""></td>
<td><a href="https://github.com/addyosmani" target="_blank" rel="external">https://github.com/addyosmani</a></td>
<td>295</td>
<td>807</td>
<td>29000</td>
<td>254</td>
<td>928</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/810438" alt=""></td>
<td><a href="https://github.com/gaearon" target="_blank" rel="external">https://github.com/gaearon</a></td>
<td>227</td>
<td>1300</td>
<td>27200</td>
<td>171</td>
<td>3019</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/39191" alt=""></td>
<td><a href="https://github.com/paulirish" target="_blank" rel="external">https://github.com/paulirish</a></td>
<td>266</td>
<td>723</td>
<td>25600</td>
<td>245</td>
<td>2375</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/170270" alt=""></td>
<td><a href="https://github.com/sindresorhus" target="_blank" rel="external">https://github.com/sindresorhus</a></td>
<td>975</td>
<td>2500</td>
<td>23600</td>
<td>50</td>
<td>4753</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/119893" alt=""></td>
<td><a href="https://github.com/kennethreitz" target="_blank" rel="external">https://github.com/kennethreitz</a></td>
<td>141</td>
<td>1900</td>
<td>21200</td>
<td>197</td>
<td>5626</td>
</tr>
</tbody>
</table>
<h4 id="Following人数榜"><a href="#Following人数榜" class="headerlink" title="Following人数榜"></a>Following人数榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/3076393" alt=""></td>
<td><a href="https://github.com/KevinHock" target="_blank" rel="external">https://github.com/KevinHock</a></td>
<td>19</td>
<td>198</td>
<td>1300</td>
<td>284000</td>
<td>639</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/5877145" alt=""></td>
<td><a href="https://github.com/angusshire" target="_blank" rel="external">https://github.com/angusshire</a></td>
<td>8</td>
<td>217000</td>
<td>10300</td>
<td>230000</td>
<td>30</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/6508763" alt=""></td>
<td><a href="https://github.com/dalinhuang99" target="_blank" rel="external">https://github.com/dalinhuang99</a></td>
<td>20</td>
<td>75</td>
<td>3200</td>
<td>162000</td>
<td>1293</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/3604053" alt=""></td>
<td><a href="https://github.com/cusspvz" target="_blank" rel="external">https://github.com/cusspvz</a></td>
<td>109</td>
<td>1200</td>
<td>6600</td>
<td>130000</td>
<td>90</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/6673982" alt=""></td>
<td><a href="https://github.com/MichalPaszkiewicz" target="_blank" rel="external">https://github.com/MichalPaszkiewicz</a></td>
<td>60</td>
<td>558</td>
<td>4600</td>
<td>72700</td>
<td>172</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/418638" alt=""></td>
<td><a href="https://github.com/nfultz" target="_blank" rel="external">https://github.com/nfultz</a></td>
<td>70</td>
<td>2500</td>
<td>2600</td>
<td>61600</td>
<td>2141</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/14251570" alt=""></td>
<td><a href="https://github.com/mstraughan86" target="_blank" rel="external">https://github.com/mstraughan86</a></td>
<td>15</td>
<td>454</td>
<td>3400</td>
<td>60500</td>
<td>299</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/32831059" alt=""></td>
<td><a href="https://github.com/opengiineer" target="_blank" rel="external">https://github.com/opengiineer</a></td>
<td>19</td>
<td>90</td>
<td>1600</td>
<td>55700</td>
<td>46</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/778015" alt=""></td>
<td><a href="https://github.com/ahmetabdi" target="_blank" rel="external">https://github.com/ahmetabdi</a></td>
<td>130</td>
<td>4100</td>
<td>448</td>
<td>53300</td>
<td>1954</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/4107768" alt=""></td>
<td><a href="https://github.com/brunocasanova" target="_blank" rel="external">https://github.com/brunocasanova</a></td>
<td>46</td>
<td>152</td>
<td>2400</td>
<td>48300</td>
<td>13</td>
</tr>
</tbody>
</table>
<h4 id="Stars榜"><a href="#Stars榜" class="headerlink" title="Stars榜"></a>Stars榜</h4><p>看看谁收藏的仓库最多</p>
<table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/5877145" alt=""></td>
<td><a href="https://github.com/angusshire" target="_blank" rel="external">https://github.com/angusshire</a></td>
<td>8</td>
<td>217000</td>
<td>10300</td>
<td>230000</td>
<td>30</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1610158" alt=""></td>
<td><a href="https://github.com/mcanthony" target="_blank" rel="external">https://github.com/mcanthony</a></td>
<td>4300</td>
<td>42500</td>
<td>375</td>
<td>12700</td>
<td>21</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/3947125" alt=""></td>
<td><a href="https://github.com/maoabc1818" target="_blank" rel="external">https://github.com/maoabc1818</a></td>
<td>9</td>
<td>32200</td>
<td>121</td>
<td>95</td>
<td>2</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/391299" alt=""></td>
<td><a href="https://github.com/JT5D" target="_blank" rel="external">https://github.com/JT5D</a></td>
<td>210</td>
<td>29300</td>
<td>276</td>
<td>6200</td>
<td>0</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/500775" alt=""></td>
<td><a href="https://github.com/reduxionist" target="_blank" rel="external">https://github.com/reduxionist</a></td>
<td>15</td>
<td>25800</td>
<td>174</td>
<td>429</td>
<td>62</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/6948067" alt=""></td>
<td><a href="https://github.com/pranavlathigara" target="_blank" rel="external">https://github.com/pranavlathigara</a></td>
<td>1200</td>
<td>24600</td>
<td>793</td>
<td>14900</td>
<td>130</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/2882" alt=""></td>
<td><a href="https://github.com/nikolay" target="_blank" rel="external">https://github.com/nikolay</a></td>
<td>12</td>
<td>23100</td>
<td>243</td>
<td>349</td>
<td>469</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/3759759" alt=""></td>
<td><a href="https://github.com/denji" target="_blank" rel="external">https://github.com/denji</a></td>
<td>1300</td>
<td>22500</td>
<td>181</td>
<td>397</td>
<td>305</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/24416962" alt=""></td>
<td><a href="https://github.com/roscopecoltran" target="_blank" rel="external">https://github.com/roscopecoltran</a></td>
<td>156</td>
<td>21000</td>
<td>121</td>
<td>4400</td>
<td>599</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/6257454" alt=""></td>
<td><a href="https://github.com/Jerzerak" target="_blank" rel="external">https://github.com/Jerzerak</a></td>
<td>1</td>
<td>18900</td>
<td>54</td>
<td>0</td>
<td>3</td>
</tr>
</tbody>
</table>
<h4 id="Reps榜"><a href="#Reps榜" class="headerlink" title="Reps榜"></a>Reps榜</h4><p>Github上创建仓库最多的人在这里</p>
<table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/675997" alt=""></td>
<td><a href="https://github.com/pombredanne" target="_blank" rel="external">https://github.com/pombredanne</a></td>
<td>40600</td>
<td>6500</td>
<td>149</td>
<td>87</td>
<td>2558</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/1732196" alt=""></td>
<td><a href="https://github.com/carriercomm" target="_blank" rel="external">https://github.com/carriercomm</a></td>
<td>20400</td>
<td>12900</td>
<td>72</td>
<td>176</td>
<td>151</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/14135456" alt=""></td>
<td><a href="https://github.com/digideskio" target="_blank" rel="external">https://github.com/digideskio</a></td>
<td>18000</td>
<td>88</td>
<td>120</td>
<td>3900</td>
<td>113</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/431924" alt=""></td>
<td><a href="https://github.com/guoyu07" target="_blank" rel="external">https://github.com/guoyu07</a></td>
<td>11600</td>
<td>91</td>
<td>20</td>
<td>1000</td>
<td>112</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/12729391" alt=""></td>
<td><a href="https://github.com/modulexcite" target="_blank" rel="external">https://github.com/modulexcite</a></td>
<td>10700</td>
<td>4200</td>
<td>30</td>
<td>192</td>
<td>15</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/1218365" alt=""></td>
<td><a href="https://github.com/PlumpMath" target="_blank" rel="external">https://github.com/PlumpMath</a></td>
<td>10100</td>
<td>508</td>
<td>31</td>
<td>147</td>
<td>103</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/3380677" alt=""></td>
<td><a href="https://github.com/carabina" target="_blank" rel="external">https://github.com/carabina</a></td>
<td>9300</td>
<td>8700</td>
<td>83</td>
<td>5</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/4687038" alt=""></td>
<td><a href="https://github.com/jorik041" target="_blank" rel="external">https://github.com/jorik041</a></td>
<td>9200</td>
<td>53</td>
<td>20</td>
<td>129</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1332574" alt=""></td>
<td><a href="https://github.com/treejames" target="_blank" rel="external">https://github.com/treejames</a></td>
<td>8000</td>
<td>6900</td>
<td>93</td>
<td>897</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/498130" alt=""></td>
<td><a href="https://github.com/mehulsbhatt" target="_blank" rel="external">https://github.com/mehulsbhatt</a></td>
<td>7400</td>
<td>364</td>
<td>23</td>
<td>9</td>
<td>104</td>
</tr>
</tbody>
</table>
<h4 id="Contribution榜"><a href="#Contribution榜" class="headerlink" title="Contribution榜"></a>Contribution榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/3244" alt=""></td>
<td><a href="https://github.com/robertbrook" target="_blank" rel="external">https://github.com/robertbrook</a></td>
<td>67</td>
<td>32</td>
<td>63</td>
<td>114</td>
<td>539804</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/20975616" alt=""></td>
<td><a href="https://github.com/SimiCode" target="_blank" rel="external">https://github.com/SimiCode</a></td>
<td>24</td>
<td>11</td>
<td>5</td>
<td>15</td>
<td>377077</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/751143" alt=""></td>
<td><a href="https://github.com/jasoncalabrese" target="_blank" rel="external">https://github.com/jasoncalabrese</a></td>
<td>75</td>
<td>50</td>
<td>64</td>
<td>19</td>
<td>357587</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/56100" alt=""></td>
<td><a href="https://github.com/kinlane" target="_blank" rel="external">https://github.com/kinlane</a></td>
<td>222</td>
<td>242</td>
<td>346</td>
<td>588</td>
<td>199240</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/415831" alt=""></td>
<td><a href="https://github.com/talos" target="_blank" rel="external">https://github.com/talos</a></td>
<td>113</td>
<td>95</td>
<td>143</td>
<td>7</td>
<td>115891</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/283441" alt=""></td>
<td><a href="https://github.com/honzajavorek" target="_blank" rel="external">https://github.com/honzajavorek</a></td>
<td>87</td>
<td>167</td>
<td>128</td>
<td>93</td>
<td>80301</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1006477" alt=""></td>
<td><a href="https://github.com/felixonmars" target="_blank" rel="external">https://github.com/felixonmars</a></td>
<td>420</td>
<td>369</td>
<td>806</td>
<td>149</td>
<td>70179</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/1317792" alt=""></td>
<td><a href="https://github.com/xndcn" target="_blank" rel="external">https://github.com/xndcn</a></td>
<td>33</td>
<td>86</td>
<td>67</td>
<td>8</td>
<td>67634</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/3935007" alt=""></td>
<td><a href="https://github.com/ojengwa" target="_blank" rel="external">https://github.com/ojengwa</a></td>
<td>293</td>
<td>469</td>
<td>67</td>
<td>8</td>
<td>49621</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/10103766" alt=""></td>
<td><a href="https://github.com/SergioChan" target="_blank" rel="external">https://github.com/SergioChan</a></td>
<td>47</td>
<td>372</td>
<td>982</td>
<td>598</td>
<td>42202</td>
</tr>
</tbody>
</table>
<p>365天，天天绿是种怎样的体验？</p>
<h3 id="中国用户榜单"><a href="#中国用户榜单" class="headerlink" title="中国用户榜单"></a>中国用户榜单</h3><p>这里只是通过location中”China”、”Shanghai”类似的关键词对中国用户进行区分，所以可能有遗漏的地方，还请谅解。此次统计的中国用户数据有18011</p>
<h4 id="Followers人数榜-1"><a href="#Followers人数榜-1" class="headerlink" title="Followers人数榜"></a>Followers人数榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/905434" alt=""></td>
<td><a href="https://github.com/ruanyf" target="_blank" rel="external">https://github.com/ruanyf</a></td>
<td>48</td>
<td>206</td>
<td>38200</td>
<td>0</td>
<td>1645</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/499550" alt=""></td>
<td><a href="https://github.com/yyx990803" target="_blank" rel="external">https://github.com/yyx990803</a></td>
<td>141</td>
<td>779</td>
<td>29200</td>
<td>90</td>
<td>2553</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/2503423" alt=""></td>
<td><a href="https://github.com/daimajia" target="_blank" rel="external">https://github.com/daimajia</a></td>
<td>63</td>
<td>2900</td>
<td>20000</td>
<td>241</td>
<td>21</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/470058" alt=""></td>
<td><a href="https://github.com/michaelliao" target="_blank" rel="external">https://github.com/michaelliao</a></td>
<td>61</td>
<td>81</td>
<td>19700</td>
<td>0</td>
<td>297</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/327019" alt=""></td>
<td><a href="https://github.com/JacksonTian" target="_blank" rel="external">https://github.com/JacksonTian</a></td>
<td>229</td>
<td>583</td>
<td>15500</td>
<td>151</td>
<td>805</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/1169522" alt=""></td>
<td><a href="https://github.com/Trinea" target="_blank" rel="external">https://github.com/Trinea</a></td>
<td>24</td>
<td>1500</td>
<td>14100</td>
<td>38</td>
<td>80</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/2267900" alt=""></td>
<td><a href="https://github.com/stormzhang" target="_blank" rel="external">https://github.com/stormzhang</a></td>
<td>5</td>
<td>1500</td>
<td>12800</td>
<td>91</td>
<td>9</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/97227" alt=""></td>
<td><a href="https://github.com/lifesinger" target="_blank" rel="external">https://github.com/lifesinger</a></td>
<td>2</td>
<td>278</td>
<td>12000</td>
<td>13</td>
<td>1</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/729648" alt=""></td>
<td><a href="https://github.com/cloudwu" target="_blank" rel="external">https://github.com/cloudwu</a></td>
<td>102</td>
<td>63</td>
<td>11700</td>
<td>1</td>
<td>690</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/472311" alt=""></td>
<td><a href="https://github.com/phodal" target="_blank" rel="external">https://github.com/phodal</a></td>
<td>254</td>
<td>1700</td>
<td>11100</td>
<td>15</td>
<td>5924</td>
</tr>
</tbody>
</table>
<h4 id="Following人数榜-1"><a href="#Following人数榜-1" class="headerlink" title="Following人数榜"></a>Following人数榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/3693121" alt=""></td>
<td><a href="https://github.com/fordream" target="_blank" rel="external">https://github.com/fordream</a></td>
<td>724</td>
<td>21</td>
<td>919</td>
<td>19800</td>
<td>1</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/17972943" alt=""></td>
<td><a href="https://github.com/Vermisse" target="_blank" rel="external">https://github.com/Vermisse</a></td>
<td>15</td>
<td>25</td>
<td>2300</td>
<td>10400</td>
<td>102</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/93859" alt=""></td>
<td><a href="https://github.com/technologiclee" target="_blank" rel="external">https://github.com/technologiclee</a></td>
<td>149</td>
<td>844</td>
<td>374</td>
<td>9500</td>
<td>6</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/15626022" alt=""></td>
<td><a href="https://github.com/shenzhoudance" target="_blank" rel="external">https://github.com/shenzhoudance</a></td>
<td>599</td>
<td>6</td>
<td>108</td>
<td>7700</td>
<td>2373</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/10573715" alt=""></td>
<td><a href="https://github.com/kotobukki" target="_blank" rel="external">https://github.com/kotobukki</a></td>
<td>15</td>
<td>68</td>
<td>111</td>
<td>7500</td>
<td>889</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/29220207" alt=""></td>
<td><a href="https://github.com/vincentpanqi" target="_blank" rel="external">https://github.com/vincentpanqi</a></td>
<td>1800</td>
<td>714</td>
<td>47</td>
<td>5600</td>
<td>102</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/1727724" alt=""></td>
<td><a href="https://github.com/ovwane" target="_blank" rel="external">https://github.com/ovwane</a></td>
<td>220</td>
<td>1100</td>
<td>120</td>
<td>5500</td>
<td>329</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/9153294" alt=""></td>
<td><a href="https://github.com/pisual" target="_blank" rel="external">https://github.com/pisual</a></td>
<td>39</td>
<td>62</td>
<td>917</td>
<td>4900</td>
<td>122</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/23236638" alt=""></td>
<td><a href="https://github.com/youkaichao" target="_blank" rel="external">https://github.com/youkaichao</a></td>
<td>39</td>
<td>0</td>
<td>58</td>
<td>4800</td>
<td>113</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/7576876" alt=""></td>
<td><a href="https://github.com/bloodycoder" target="_blank" rel="external">https://github.com/bloodycoder</a></td>
<td>73</td>
<td>34</td>
<td>162</td>
<td>4200</td>
<td>390</td>
</tr>
</tbody>
</table>
<h4 id="Stars榜-1"><a href="#Stars榜-1" class="headerlink" title="Stars榜"></a>Stars榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1041542" alt=""></td>
<td><a href="https://github.com/weimingtom" target="_blank" rel="external">https://github.com/weimingtom</a></td>
<td>2100</td>
<td>9100</td>
<td>172</td>
<td>1800</td>
<td>1724</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/2041398" alt=""></td>
<td><a href="https://github.com/jiangplus" target="_blank" rel="external">https://github.com/jiangplus</a></td>
<td>28</td>
<td>8800</td>
<td>85</td>
<td>115</td>
<td>13</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1024948" alt=""></td>
<td><a href="https://github.com/DavidAlphaFox" target="_blank" rel="external">https://github.com/DavidAlphaFox</a></td>
<td>346</td>
<td>7800</td>
<td>167</td>
<td>83</td>
<td>1122</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/480859" alt=""></td>
<td><a href="https://github.com/mayulu" target="_blank" rel="external">https://github.com/mayulu</a></td>
<td>12</td>
<td>7700</td>
<td>133</td>
<td>616</td>
<td>14</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/4370703" alt=""></td>
<td><a href="https://github.com/hzy87email" target="_blank" rel="external">https://github.com/hzy87email</a></td>
<td>73</td>
<td>7700</td>
<td>77</td>
<td>167</td>
<td>3</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1468284" alt=""></td>
<td><a href="https://github.com/se77en" target="_blank" rel="external">https://github.com/se77en</a></td>
<td>197</td>
<td>7600</td>
<td>119</td>
<td>455</td>
<td>0</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/12030169" alt=""></td>
<td><a href="https://github.com/JaredYeDH" target="_blank" rel="external">https://github.com/JaredYeDH</a></td>
<td>166</td>
<td>7400</td>
<td>45</td>
<td>636</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/10380759" alt=""></td>
<td><a href="https://github.com/xhs" target="_blank" rel="external">https://github.com/xhs</a></td>
<td>20</td>
<td>7200</td>
<td>43</td>
<td>119</td>
<td>10</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/1881113" alt=""></td>
<td><a href="https://github.com/paladin74" target="_blank" rel="external">https://github.com/paladin74</a></td>
<td>618</td>
<td>7100</td>
<td>52</td>
<td>901</td>
<td>1</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/3856" alt=""></td>
<td><a href="https://github.com/mrluanma" target="_blank" rel="external">https://github.com/mrluanma</a></td>
<td>12</td>
<td>7000</td>
<td>126</td>
<td>541</td>
<td>36</td>
</tr>
</tbody>
</table>
<h4 id="Reps榜-1"><a href="#Reps榜-1" class="headerlink" title="Reps榜"></a>Reps榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/10938976" alt=""></td>
<td><a href="https://github.com/skyformat99" target="_blank" rel="external">https://github.com/skyformat99</a></td>
<td>6000</td>
<td>143</td>
<td>98</td>
<td>3200</td>
<td>134</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/1203820" alt=""></td>
<td><a href="https://github.com/tempbottle" target="_blank" rel="external">https://github.com/tempbottle</a></td>
<td>4200</td>
<td>59</td>
<td>21</td>
<td>18</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/8662447" alt=""></td>
<td><a href="https://github.com/JamesLinus" target="_blank" rel="external">https://github.com/JamesLinus</a></td>
<td>4100</td>
<td>1600</td>
<td>89</td>
<td>3300</td>
<td>181</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/12955801" alt=""></td>
<td><a href="https://github.com/hu19891110" target="_blank" rel="external">https://github.com/hu19891110</a></td>
<td>3600</td>
<td>90</td>
<td>11</td>
<td>112</td>
<td>107</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/452743" alt=""></td>
<td><a href="https://github.com/WilliamRen" target="_blank" rel="external">https://github.com/WilliamRen</a></td>
<td>2900</td>
<td>3200</td>
<td>32</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/3414057" alt=""></td>
<td><a href="https://github.com/chagge" target="_blank" rel="external">https://github.com/chagge</a></td>
<td>2300</td>
<td>8</td>
<td>16</td>
<td>669</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/6813552" alt=""></td>
<td><a href="https://github.com/forging2012" target="_blank" rel="external">https://github.com/forging2012</a></td>
<td>2200</td>
<td>789</td>
<td>8</td>
<td>71</td>
<td>151</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1041542" alt=""></td>
<td><a href="https://github.com/weimingtom" target="_blank" rel="external">https://github.com/weimingtom</a></td>
<td>2100</td>
<td>9100</td>
<td>172</td>
<td>1800</td>
<td>1724</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/23429527" alt=""></td>
<td><a href="https://github.com/isuhao" target="_blank" rel="external">https://github.com/isuhao</a></td>
<td>2000</td>
<td>153</td>
<td>62</td>
<td>2700</td>
<td>282</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/5791117" alt=""></td>
<td><a href="https://github.com/ycaihua" target="_blank" rel="external">https://github.com/ycaihua</a></td>
<td>1900</td>
<td>109</td>
<td>38</td>
<td>589</td>
<td>133</td>
</tr>
</tbody>
</table>
<h4 id="Contribution榜-1"><a href="#Contribution榜-1" class="headerlink" title="Contribution榜"></a>Contribution榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1006477" alt=""></td>
<td><a href="https://github.com/felixonmars" target="_blank" rel="external">https://github.com/felixonmars</a></td>
<td>420</td>
<td>369</td>
<td>806</td>
<td>149</td>
<td>70179</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/10103766" alt=""></td>
<td><a href="https://github.com/SergioChan" target="_blank" rel="external">https://github.com/SergioChan</a></td>
<td>47</td>
<td>372</td>
<td>982</td>
<td>598</td>
<td>42202</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/12693644" alt=""></td>
<td><a href="https://github.com/dragon-yuan" target="_blank" rel="external">https://github.com/dragon-yuan</a></td>
<td>16</td>
<td>109</td>
<td>35</td>
<td>50</td>
<td>18591</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/8347202" alt=""></td>
<td><a href="https://github.com/fengss" target="_blank" rel="external">https://github.com/fengss</a></td>
<td>30</td>
<td>67</td>
<td>15</td>
<td>1</td>
<td>12560</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/9410171" alt=""></td>
<td><a href="https://github.com/xieguigang" target="_blank" rel="external">https://github.com/xieguigang</a></td>
<td>41</td>
<td>115</td>
<td>136</td>
<td>143</td>
<td>10999</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/9280577" alt=""></td>
<td><a href="https://github.com/csjunxu" target="_blank" rel="external">https://github.com/csjunxu</a></td>
<td>194</td>
<td>81</td>
<td>35</td>
<td>51</td>
<td>9935</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/559179" alt=""></td>
<td><a href="https://github.com/airyland" target="_blank" rel="external">https://github.com/airyland</a></td>
<td>183</td>
<td>1400</td>
<td>996</td>
<td>175</td>
<td>8852</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/11537812" alt=""></td>
<td><a href="https://github.com/yutiansut" target="_blank" rel="external">https://github.com/yutiansut</a></td>
<td>216</td>
<td>1100</td>
<td>298</td>
<td>8</td>
<td>7311</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/1826685" alt=""></td>
<td><a href="https://github.com/lloydzhou" target="_blank" rel="external">https://github.com/lloydzhou</a></td>
<td>92</td>
<td>556</td>
<td>52</td>
<td>69</td>
<td>6729</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/8784712" alt=""></td>
<td><a href="https://github.com/egoist" target="_blank" rel="external">https://github.com/egoist</a></td>
<td>647</td>
<td>2700</td>
<td>3600</td>
<td>40</td>
<td>6236</td>
</tr>
</tbody>
</table>
<h3 id="个人网站中顶级域名分布情况"><a href="#个人网站中顶级域名分布情况" class="headerlink" title="个人网站中顶级域名分布情况"></a>个人网站中顶级域名分布情况</h3><p><img src="https://data2.liuin.cn/2018-04-01-15225621477939.jpg" alt=""></p>
<h3 id="用户公布邮箱情况"><a href="#用户公布邮箱情况" class="headerlink" title="用户公布邮箱情况"></a>用户公布邮箱情况</h3><p><img src="https://data2.liuin.cn/2018-04-01-15225624252077.jpg" alt=""></p>
<h3 id="用户所在公司情况"><a href="#用户所在公司情况" class="headerlink" title="用户所在公司情况"></a>用户所在公司情况</h3><p>公布公司的前8</p>
<p><img src="https://data2.liuin.cn/2018-04-01-15225631364406.jpg" alt=""></p>
<p>云图</p>
<p><img src="https://data2.liuin.cn/2018-04-01-15225635127953.jpg" alt=""></p>
<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><h3 id="Stars榜-2"><a href="#Stars榜-2" class="headerlink" title="Stars榜"></a>Stars榜</h3><table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/freeCodeCamp/freeCodeCamp" target="_blank" rel="external">freeCodeCamp/freeCodeCamp</a></td>
<td><a href="https://github.com/freeCodeCamp" target="_blank" rel="external">freeCodeCamp</a></td>
<td>JavaScript</td>
<td>291895</td>
<td>13667</td>
<td>11334</td>
</tr>
<tr>
<td><a href="https://github.com/twbs/bootstrap" target="_blank" rel="external">twbs/bootstrap</a></td>
<td><a href="https://github.com/twbs" target="_blank" rel="external">twbs</a></td>
<td>CSS</td>
<td>123341</td>
<td>58717</td>
<td>17645</td>
</tr>
<tr>
<td><a href="https://github.com/EbookFoundation/free-programming-books" target="_blank" rel="external">EbookFoundation/free-programming-books</a></td>
<td><a href="https://github.com/EbookFoundation" target="_blank" rel="external">EbookFoundation</a></td>
<td></td>
<td>103480</td>
<td>26331</td>
<td>4634</td>
</tr>
<tr>
<td><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">tensorflow/tensorflow</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>C++</td>
<td>95028</td>
<td>60694</td>
<td>30887</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/react" target="_blank" rel="external">facebook/react</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>92602</td>
<td>17473</td>
<td>9773</td>
</tr>
<tr>
<td><a href="https://github.com/vuejs/vue" target="_blank" rel="external">vuejs/vue</a></td>
<td><a href="https://github.com/vuejs" target="_blank" rel="external">vuejs</a></td>
<td>JavaScript</td>
<td>89447</td>
<td>13129</td>
<td>2581</td>
</tr>
<tr>
<td><a href="https://github.com/sindresorhus/awesome" target="_blank" rel="external">sindresorhus/awesome</a></td>
<td><a href="https://github.com/sindresorhus" target="_blank" rel="external">sindresorhus</a></td>
<td></td>
<td>82141</td>
<td>10785</td>
<td>725</td>
</tr>
<tr>
<td><a href="https://github.com/getify/You-Dont-Know-JS" target="_blank" rel="external">getify/You-Dont-Know-JS</a></td>
<td><a href="https://github.com/getify" target="_blank" rel="external">getify</a></td>
<td></td>
<td>78848</td>
<td>14404</td>
<td>1465</td>
</tr>
<tr>
<td><a href="https://github.com/d3/d3" target="_blank" rel="external">d3/d3</a></td>
<td><a href="https://github.com/d3" target="_blank" rel="external">d3</a></td>
<td>JavaScript</td>
<td>74472</td>
<td>19024</td>
<td>4132</td>
</tr>
<tr>
<td><a href="https://github.com/airbnb/javascript" target="_blank" rel="external">airbnb/javascript</a></td>
<td><a href="https://github.com/airbnb" target="_blank" rel="external">airbnb</a></td>
<td>JavaScript</td>
<td>68833</td>
<td>13127</td>
<td>1607</td>
</tr>
</tbody>
</table>
<h3 id="Forks榜"><a href="#Forks榜" class="headerlink" title="Forks榜"></a>Forks榜</h3><table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/jtleek/datasharing" target="_blank" rel="external">jtleek/datasharing</a></td>
<td><a href="https://github.com/jtleek" target="_blank" rel="external">jtleek</a></td>
<td></td>
<td>4332</td>
<td>184409</td>
<td>29</td>
</tr>
<tr>
<td><a href="https://github.com/rdpeng/ProgrammingAssignment2" target="_blank" rel="external">rdpeng/ProgrammingAssignment2</a></td>
<td><a href="https://github.com/rdpeng" target="_blank" rel="external">rdpeng</a></td>
<td>R</td>
<td>528</td>
<td>110145</td>
<td>7</td>
</tr>
<tr>
<td><a href="https://github.com/octocat/Spoon-Knife" target="_blank" rel="external">octocat/Spoon-Knife</a></td>
<td><a href="https://github.com/octocat" target="_blank" rel="external">octocat</a></td>
<td>HTML</td>
<td>10043</td>
<td>97471</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">tensorflow/tensorflow</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>C++</td>
<td>95028</td>
<td>60694</td>
<td>30887</td>
</tr>
<tr>
<td><a href="https://github.com/twbs/bootstrap" target="_blank" rel="external">twbs/bootstrap</a></td>
<td><a href="https://github.com/twbs" target="_blank" rel="external">twbs</a></td>
<td>CSS</td>
<td>123341</td>
<td>58717</td>
<td>17645</td>
</tr>
<tr>
<td><a href="https://github.com/SmartThingsCommunity/SmartThingsPublic" target="_blank" rel="external">SmartThingsCommunity/SmartThingsPublic</a></td>
<td><a href="https://github.com/SmartThingsCommunity" target="_blank" rel="external">SmartThingsCommunity</a></td>
<td>Groovy</td>
<td>853</td>
<td>38018</td>
<td>2448</td>
</tr>
<tr>
<td><a href="https://github.com/rdpeng/RepData_PeerAssessment1" target="_blank" rel="external">rdpeng/RepData_PeerAssessment1</a></td>
<td><a href="https://github.com/rdpeng" target="_blank" rel="external">rdpeng</a></td>
<td></td>
<td>69</td>
<td>29883</td>
<td>13</td>
</tr>
<tr>
<td><a href="https://github.com/github/gitignore" target="_blank" rel="external">github/gitignore</a></td>
<td><a href="https://github.com/github" target="_blank" rel="external">github</a></td>
<td></td>
<td>63853</td>
<td>29259</td>
<td>2738</td>
</tr>
<tr>
<td><a href="https://github.com/angular/angular.js" target="_blank" rel="external">angular/angular.js</a></td>
<td><a href="https://github.com/angular" target="_blank" rel="external">angular</a></td>
<td>JavaScript</td>
<td>58232</td>
<td>28872</td>
<td>8755</td>
</tr>
<tr>
<td><a href="https://github.com/EbookFoundation/free-programming-books" target="_blank" rel="external">EbookFoundation/free-programming-books</a></td>
<td><a href="https://github.com/EbookFoundation" target="_blank" rel="external">EbookFoundation</a></td>
<td></td>
<td>103480</td>
<td>26331</td>
<td>4634</td>
</tr>
</tbody>
</table>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>stars排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/torvalds/linux" target="_blank" rel="external">torvalds/linux</a></td>
<td><a href="https://github.com/torvalds" target="_blank" rel="external">torvalds</a></td>
<td>C</td>
<td>57191</td>
<td>21032</td>
<td>744803</td>
</tr>
<tr>
<td><a href="https://github.com/firehol/netdata" target="_blank" rel="external">firehol/netdata</a></td>
<td><a href="https://github.com/firehol" target="_blank" rel="external">firehol</a></td>
<td>C</td>
<td>28607</td>
<td>2389</td>
<td>6690</td>
</tr>
<tr>
<td><a href="https://github.com/antirez/redis" target="_blank" rel="external">antirez/redis</a></td>
<td><a href="https://github.com/antirez" target="_blank" rel="external">antirez</a></td>
<td>C</td>
<td>28340</td>
<td>10916</td>
<td>6679</td>
</tr>
<tr>
<td><a href="https://github.com/git/git" target="_blank" rel="external">git/git</a></td>
<td><a href="https://github.com/git" target="_blank" rel="external">git</a></td>
<td>C</td>
<td>21665</td>
<td>12634</td>
<td>50674</td>
</tr>
<tr>
<td><a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="external">Bilibili/ijkplayer</a></td>
<td><a href="https://github.com/Bilibili" target="_blank" rel="external">Bilibili</a></td>
<td>C</td>
<td>18374</td>
<td>5191</td>
<td>2584</td>
</tr>
<tr>
<td><a href="https://github.com/php/php-src" target="_blank" rel="external">php/php-src</a></td>
<td><a href="https://github.com/php" target="_blank" rel="external">php</a></td>
<td>C</td>
<td>16996</td>
<td>4745</td>
<td>107206</td>
</tr>
<tr>
<td><a href="https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System" target="_blank" rel="external">SamyPesse/How-to-Make-a-Computer-Operating-System</a></td>
<td><a href="https://github.com/SamyPesse" target="_blank" rel="external">SamyPesse</a></td>
<td>C</td>
<td>16957</td>
<td>3015</td>
<td>243</td>
</tr>
<tr>
<td><a href="https://github.com/wg/wrk" target="_blank" rel="external">wg/wrk</a></td>
<td><a href="https://github.com/wg" target="_blank" rel="external">wg</a></td>
<td>C</td>
<td>15386</td>
<td>1245</td>
<td>72</td>
</tr>
<tr>
<td><a href="https://github.com/ggreer/the_silver_searcher" target="_blank" rel="external">ggreer/the_silver_searcher</a></td>
<td><a href="https://github.com/ggreer" target="_blank" rel="external">ggreer</a></td>
<td>C</td>
<td>14854</td>
<td>954</td>
<td>1974</td>
</tr>
<tr>
<td><a href="https://github.com/kripken/emscripten" target="_blank" rel="external">kripken/emscripten</a></td>
<td><a href="https://github.com/kripken" target="_blank" rel="external">kripken</a></td>
<td>C</td>
<td>14373</td>
<td>1704</td>
<td>18154</td>
</tr>
</tbody>
</table>
<p>forks排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/torvalds/linux" target="_blank" rel="external">torvalds/linux</a></td>
<td><a href="https://github.com/torvalds" target="_blank" rel="external">torvalds</a></td>
<td>C</td>
<td>57191</td>
<td>21032</td>
<td>744803</td>
</tr>
<tr>
<td><a href="https://github.com/git/git" target="_blank" rel="external">git/git</a></td>
<td><a href="https://github.com/git" target="_blank" rel="external">git</a></td>
<td>C</td>
<td>21665</td>
<td>12634</td>
<td>50674</td>
</tr>
<tr>
<td><a href="https://github.com/antirez/redis" target="_blank" rel="external">antirez/redis</a></td>
<td><a href="https://github.com/antirez" target="_blank" rel="external">antirez</a></td>
<td>C</td>
<td>28340</td>
<td>10916</td>
<td>6679</td>
</tr>
<tr>
<td><a href="https://github.com/arduino/Arduino" target="_blank" rel="external">arduino/Arduino</a></td>
<td><a href="https://github.com/arduino" target="_blank" rel="external">arduino</a></td>
<td>C</td>
<td>7936</td>
<td>6184</td>
<td>6649</td>
</tr>
<tr>
<td><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July" target="_blank" rel="external">julycoding/The-Art-Of-Programming-By-July</a></td>
<td><a href="https://github.com/julycoding" target="_blank" rel="external">julycoding</a></td>
<td>C</td>
<td>13544</td>
<td>5666</td>
<td>3630</td>
</tr>
<tr>
<td><a href="https://github.com/MarlinFirmware/Marlin" target="_blank" rel="external">MarlinFirmware/Marlin</a></td>
<td><a href="https://github.com/MarlinFirmware" target="_blank" rel="external">MarlinFirmware</a></td>
<td>C</td>
<td>3615</td>
<td>5340</td>
<td>9015</td>
</tr>
<tr>
<td><a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="external">Bilibili/ijkplayer</a></td>
<td><a href="https://github.com/Bilibili" target="_blank" rel="external">Bilibili</a></td>
<td>C</td>
<td>18374</td>
<td>5191</td>
<td>2584</td>
</tr>
<tr>
<td><a href="https://github.com/php/php-src" target="_blank" rel="external">php/php-src</a></td>
<td><a href="https://github.com/php" target="_blank" rel="external">php</a></td>
<td>C</td>
<td>16996</td>
<td>4745</td>
<td>107206</td>
</tr>
<tr>
<td><a href="https://github.com/esp8266/Arduino" target="_blank" rel="external">esp8266/Arduino</a></td>
<td><a href="https://github.com/esp8266" target="_blank" rel="external">esp8266</a></td>
<td>C</td>
<td>7063</td>
<td>4378</td>
<td>2697</td>
</tr>
<tr>
<td><a href="https://github.com/FFmpeg/FFmpeg" target="_blank" rel="external">FFmpeg/FFmpeg</a></td>
<td><a href="https://github.com/FFmpeg" target="_blank" rel="external">FFmpeg</a></td>
<td>C</td>
<td>10314</td>
<td>4377</td>
<td>90611</td>
</tr>
</tbody>
</table>
<h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><p>stars排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">tensorflow/tensorflow</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>C++</td>
<td>95028</td>
<td>60694</td>
<td>30887</td>
</tr>
<tr>
<td><a href="https://github.com/electron/electron" target="_blank" rel="external">electron/electron</a></td>
<td><a href="https://github.com/electron" target="_blank" rel="external">electron</a></td>
<td>C++</td>
<td>58531</td>
<td>7642</td>
<td>18669</td>
</tr>
<tr>
<td><a href="https://github.com/apple/swift" target="_blank" rel="external">apple/swift</a></td>
<td><a href="https://github.com/apple" target="_blank" rel="external">apple</a></td>
<td>C++</td>
<td>43250</td>
<td>6795</td>
<td>68510</td>
</tr>
<tr>
<td><a href="https://github.com/nwjs/nw.js" target="_blank" rel="external">nwjs/nw.js</a></td>
<td><a href="https://github.com/nwjs" target="_blank" rel="external">nwjs</a></td>
<td>C++</td>
<td>33478</td>
<td>3731</td>
<td>3188</td>
</tr>
<tr>
<td><a href="https://github.com/x64dbg/x64dbg" target="_blank" rel="external">x64dbg/x64dbg</a></td>
<td><a href="https://github.com/x64dbg" target="_blank" rel="external">x64dbg</a></td>
<td>C++</td>
<td>33242</td>
<td>684</td>
<td>3923</td>
</tr>
<tr>
<td><a href="https://github.com/bitcoin/bitcoin" target="_blank" rel="external">bitcoin/bitcoin</a></td>
<td><a href="https://github.com/bitcoin" target="_blank" rel="external">bitcoin</a></td>
<td>C++</td>
<td>30209</td>
<td>18101</td>
<td>16629</td>
</tr>
<tr>
<td><a href="https://github.com/google/protobuf" target="_blank" rel="external">google/protobuf</a></td>
<td><a href="https://github.com/google" target="_blank" rel="external">google</a></td>
<td>C++</td>
<td>24950</td>
<td>7150</td>
<td>5557</td>
</tr>
<tr>
<td><a href="https://github.com/BVLC/caffe" target="_blank" rel="external">BVLC/caffe</a></td>
<td><a href="https://github.com/BVLC" target="_blank" rel="external">BVLC</a></td>
<td>C++</td>
<td>23550</td>
<td>14390</td>
<td>4118</td>
</tr>
<tr>
<td><a href="https://github.com/opencv/opencv" target="_blank" rel="external">opencv/opencv</a></td>
<td><a href="https://github.com/opencv" target="_blank" rel="external">opencv</a></td>
<td>C++</td>
<td>23493</td>
<td>16901</td>
<td>23654</td>
</tr>
<tr>
<td><a href="https://github.com/rethinkdb/rethinkdb" target="_blank" rel="external">rethinkdb/rethinkdb</a></td>
<td><a href="https://github.com/rethinkdb" target="_blank" rel="external">rethinkdb</a></td>
<td>C++</td>
<td>20993</td>
<td>1665</td>
<td>33382</td>
</tr>
</tbody>
</table>
<p>forks排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">tensorflow/tensorflow</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>C++</td>
<td>95028</td>
<td>60694</td>
<td>30887</td>
</tr>
<tr>
<td><a href="https://github.com/bitcoin/bitcoin" target="_blank" rel="external">bitcoin/bitcoin</a></td>
<td><a href="https://github.com/bitcoin" target="_blank" rel="external">bitcoin</a></td>
<td>C++</td>
<td>30209</td>
<td>18101</td>
<td>16629</td>
</tr>
<tr>
<td><a href="https://github.com/opencv/opencv" target="_blank" rel="external">opencv/opencv</a></td>
<td><a href="https://github.com/opencv" target="_blank" rel="external">opencv</a></td>
<td>C++</td>
<td>23493</td>
<td>16901</td>
<td>23654</td>
</tr>
<tr>
<td><a href="https://github.com/BVLC/caffe" target="_blank" rel="external">BVLC/caffe</a></td>
<td><a href="https://github.com/BVLC" target="_blank" rel="external">BVLC</a></td>
<td>C++</td>
<td>23550</td>
<td>14390</td>
<td>4118</td>
</tr>
<tr>
<td><a href="https://github.com/electron/electron" target="_blank" rel="external">electron/electron</a></td>
<td><a href="https://github.com/electron" target="_blank" rel="external">electron</a></td>
<td>C++</td>
<td>58531</td>
<td>7642</td>
<td>18669</td>
</tr>
<tr>
<td><a href="https://github.com/google/protobuf" target="_blank" rel="external">google/protobuf</a></td>
<td><a href="https://github.com/google" target="_blank" rel="external">google</a></td>
<td>C++</td>
<td>24950</td>
<td>7150</td>
<td>5557</td>
</tr>
<tr>
<td><a href="https://github.com/apple/swift" target="_blank" rel="external">apple/swift</a></td>
<td><a href="https://github.com/apple" target="_blank" rel="external">apple</a></td>
<td>C++</td>
<td>43250</td>
<td>6795</td>
<td>68510</td>
</tr>
<tr>
<td><a href="https://github.com/cocos2d/cocos2d-x" target="_blank" rel="external">cocos2d/cocos2d-x</a></td>
<td><a href="https://github.com/cocos2d" target="_blank" rel="external">cocos2d</a></td>
<td>C++</td>
<td>11759</td>
<td>6496</td>
<td>36641</td>
</tr>
<tr>
<td><a href="https://github.com/ArduPilot/ardupilot" target="_blank" rel="external">ArduPilot/ardupilot</a></td>
<td><a href="https://github.com/ArduPilot" target="_blank" rel="external">ArduPilot</a></td>
<td>C++</td>
<td>3110</td>
<td>6153</td>
<td>31379</td>
</tr>
<tr>
<td><a href="https://github.com/dmlc/xgboost" target="_blank" rel="external">dmlc/xgboost</a></td>
<td><a href="https://github.com/dmlc" target="_blank" rel="external">dmlc</a></td>
<td>C++</td>
<td>11406</td>
<td>5192</td>
<td>3254</td>
</tr>
</tbody>
</table>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>stars排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">ReactiveX/RxJava</a></td>
<td><a href="https://github.com/ReactiveX" target="_blank" rel="external">ReactiveX</a></td>
<td>Java</td>
<td>32001</td>
<td>5594</td>
<td>5328</td>
</tr>
<tr>
<td><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="external">iluwatar/java-design-patterns</a></td>
<td><a href="https://github.com/iluwatar" target="_blank" rel="external">iluwatar</a></td>
<td>Java</td>
<td>31422</td>
<td>10072</td>
<td>2022</td>
</tr>
<tr>
<td><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="external">elastic/elasticsearch</a></td>
<td><a href="https://github.com/elastic" target="_blank" rel="external">elastic</a></td>
<td>Java</td>
<td>29931</td>
<td>10408</td>
<td>30528</td>
</tr>
<tr>
<td><a href="https://github.com/square/retrofit" target="_blank" rel="external">square/retrofit</a></td>
<td><a href="https://github.com/square" target="_blank" rel="external">square</a></td>
<td>Java</td>
<td>27182</td>
<td>5311</td>
<td>1569</td>
</tr>
<tr>
<td><a href="https://github.com/square/okhttp" target="_blank" rel="external">square/okhttp</a></td>
<td><a href="https://github.com/square" target="_blank" rel="external">square</a></td>
<td>Java</td>
<td>25870</td>
<td>6054</td>
<td>3147</td>
</tr>
<tr>
<td><a href="https://github.com/google/guava" target="_blank" rel="external">google/guava</a></td>
<td><a href="https://github.com/google" target="_blank" rel="external">google</a></td>
<td>Java</td>
<td>23154</td>
<td>5323</td>
<td>4676</td>
</tr>
<tr>
<td><a href="https://github.com/spring-projects/spring-boot" target="_blank" rel="external">spring-projects/spring-boot</a></td>
<td><a href="https://github.com/spring-projects" target="_blank" rel="external">spring-projects</a></td>
<td>Java</td>
<td>22927</td>
<td>17555</td>
<td>16129</td>
</tr>
<tr>
<td><a href="https://github.com/PhilJay/MPAndroidChart" target="_blank" rel="external">PhilJay/MPAndroidChart</a></td>
<td><a href="https://github.com/PhilJay" target="_blank" rel="external">PhilJay</a></td>
<td>Java</td>
<td>21393</td>
<td>5939</td>
<td>1938</td>
</tr>
<tr>
<td><a href="https://github.com/kdn251/interviews" target="_blank" rel="external">kdn251/interviews</a></td>
<td><a href="https://github.com/kdn251" target="_blank" rel="external">kdn251</a></td>
<td>Java</td>
<td>21348</td>
<td>3503</td>
<td>370</td>
</tr>
<tr>
<td><a href="https://github.com/bumptech/glide" target="_blank" rel="external">bumptech/glide</a></td>
<td><a href="https://github.com/bumptech" target="_blank" rel="external">bumptech</a></td>
<td>Java</td>
<td>21032</td>
<td>4132</td>
<td>2190</td>
</tr>
</tbody>
</table>
<p>forks排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/spring-projects/spring-boot" target="_blank" rel="external">spring-projects/spring-boot</a></td>
<td><a href="https://github.com/spring-projects" target="_blank" rel="external">spring-projects</a></td>
<td>Java</td>
<td>22927</td>
<td>17555</td>
<td>16129</td>
</tr>
<tr>
<td><a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="external">spring-projects/spring-framework</a></td>
<td><a href="https://github.com/spring-projects" target="_blank" rel="external">spring-projects</a></td>
<td>Java</td>
<td>20126</td>
<td>13328</td>
<td>16384</td>
</tr>
<tr>
<td><a href="https://github.com/apache/incubator-dubbo" target="_blank" rel="external">apache/incubator-dubbo</a></td>
<td><a href="https://github.com/apache" target="_blank" rel="external">apache</a></td>
<td>Java</td>
<td>17706</td>
<td>12714</td>
<td>2201</td>
</tr>
<tr>
<td><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="external">elastic/elasticsearch</a></td>
<td><a href="https://github.com/elastic" target="_blank" rel="external">elastic</a></td>
<td>Java</td>
<td>29931</td>
<td>10408</td>
<td>30528</td>
</tr>
<tr>
<td><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="external">iluwatar/java-design-patterns</a></td>
<td><a href="https://github.com/iluwatar" target="_blank" rel="external">iluwatar</a></td>
<td>Java</td>
<td>31422</td>
<td>10072</td>
<td>2022</td>
</tr>
<tr>
<td><a href="https://github.com/eugenp/tutorials" target="_blank" rel="external">eugenp/tutorials</a></td>
<td><a href="https://github.com/eugenp" target="_blank" rel="external">eugenp</a></td>
<td>Java</td>
<td>4950</td>
<td>8411</td>
<td>7809</td>
</tr>
<tr>
<td><a href="https://github.com/zxing/zxing" target="_blank" rel="external">zxing/zxing</a></td>
<td><a href="https://github.com/zxing" target="_blank" rel="external">zxing</a></td>
<td>Java</td>
<td>18000</td>
<td>7345</td>
<td>3425</td>
</tr>
<tr>
<td><a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="external">nostra13/Android-Universal-Image-Loader</a></td>
<td><a href="https://github.com/nostra13" target="_blank" rel="external">nostra13</a></td>
<td>Java</td>
<td>16040</td>
<td>6476</td>
<td>1025</td>
</tr>
<tr>
<td><a href="https://github.com/checkstyle/checkstyle" target="_blank" rel="external">checkstyle/checkstyle</a></td>
<td><a href="https://github.com/checkstyle" target="_blank" rel="external">checkstyle</a></td>
<td>Java</td>
<td>3597</td>
<td>6402</td>
<td>7658</td>
</tr>
<tr>
<td><a href="https://github.com/netty/netty" target="_blank" rel="external">netty/netty</a></td>
<td><a href="https://github.com/netty" target="_blank" rel="external">netty</a></td>
<td>Java</td>
<td>13422</td>
<td>6122</td>
<td>8723</td>
</tr>
</tbody>
</table>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>stars排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/vinta/awesome-python" target="_blank" rel="external">vinta/awesome-python</a></td>
<td><a href="https://github.com/vinta" target="_blank" rel="external">vinta</a></td>
<td>Python</td>
<td>47930</td>
<td>9270</td>
<td>1222</td>
</tr>
<tr>
<td><a href="https://github.com/rg3/youtube-dl" target="_blank" rel="external">rg3/youtube-dl</a></td>
<td><a href="https://github.com/rg3" target="_blank" rel="external">rg3</a></td>
<td>Python</td>
<td>35575</td>
<td>6532</td>
<td>16048</td>
</tr>
<tr>
<td><a href="https://github.com/toddmotto/public-apis" target="_blank" rel="external">toddmotto/public-apis</a></td>
<td><a href="https://github.com/toddmotto" target="_blank" rel="external">toddmotto</a></td>
<td>Python</td>
<td>35115</td>
<td>3319</td>
<td>1760</td>
</tr>
<tr>
<td><a href="https://github.com/jakubroztocil/httpie" target="_blank" rel="external">jakubroztocil/httpie</a></td>
<td><a href="https://github.com/jakubroztocil" target="_blank" rel="external">jakubroztocil</a></td>
<td>Python</td>
<td>34746</td>
<td>2362</td>
<td>965</td>
</tr>
<tr>
<td><a href="https://github.com/nvbn/thefuck" target="_blank" rel="external">nvbn/thefuck</a></td>
<td><a href="https://github.com/nvbn" target="_blank" rel="external">nvbn</a></td>
<td>Python</td>
<td>34601</td>
<td>1723</td>
<td>1463</td>
</tr>
<tr>
<td><a href="https://github.com/pallets/flask" target="_blank" rel="external">pallets/flask</a></td>
<td><a href="https://github.com/pallets" target="_blank" rel="external">pallets</a></td>
<td>Python</td>
<td>34411</td>
<td>10562</td>
<td>3205</td>
</tr>
<tr>
<td><a href="https://github.com/django/django" target="_blank" rel="external">django/django</a></td>
<td><a href="https://github.com/django" target="_blank" rel="external">django</a></td>
<td>Python</td>
<td>32956</td>
<td>13953</td>
<td>25601</td>
</tr>
<tr>
<td><a href="https://github.com/tensorflow/models" target="_blank" rel="external">tensorflow/models</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>Python</td>
<td>32262</td>
<td>17985</td>
<td>2109</td>
</tr>
<tr>
<td><a href="https://github.com/josephmisiti/awesome-machine-learning" target="_blank" rel="external">josephmisiti/awesome-machine-learning</a></td>
<td><a href="https://github.com/josephmisiti" target="_blank" rel="external">josephmisiti</a></td>
<td>Python</td>
<td>31793</td>
<td>7780</td>
<td>1033</td>
</tr>
<tr>
<td><a href="https://github.com/requests/requests" target="_blank" rel="external">requests/requests</a></td>
<td><a href="https://github.com/requests" target="_blank" rel="external">requests</a></td>
<td>Python</td>
<td>31508</td>
<td>5824</td>
<td>5416</td>
</tr>
</tbody>
</table>
<p>forks排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/tensorflow/models" target="_blank" rel="external">tensorflow/models</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>Python</td>
<td>32262</td>
<td>17985</td>
<td>2109</td>
</tr>
<tr>
<td><a href="https://github.com/shadowsocks/shadowsocks" target="_blank" rel="external">shadowsocks/shadowsocks</a></td>
<td><a href="https://github.com/shadowsocks" target="_blank" rel="external">shadowsocks</a></td>
<td>Python</td>
<td>24278</td>
<td>15499</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://github.com/django/django" target="_blank" rel="external">django/django</a></td>
<td><a href="https://github.com/django" target="_blank" rel="external">django</a></td>
<td>Python</td>
<td>32956</td>
<td>13953</td>
<td>25601</td>
</tr>
<tr>
<td><a href="https://github.com/scikit-learn/scikit-learn" target="_blank" rel="external">scikit-learn/scikit-learn</a></td>
<td><a href="https://github.com/scikit-learn" target="_blank" rel="external">scikit-learn</a></td>
<td>Python</td>
<td>27088</td>
<td>13623</td>
<td>22684</td>
</tr>
<tr>
<td><a href="https://github.com/ansible/ansible" target="_blank" rel="external">ansible/ansible</a></td>
<td><a href="https://github.com/ansible" target="_blank" rel="external">ansible</a></td>
<td>Python</td>
<td>29373</td>
<td>10728</td>
<td>36562</td>
</tr>
<tr>
<td><a href="https://github.com/pallets/flask" target="_blank" rel="external">pallets/flask</a></td>
<td><a href="https://github.com/pallets" target="_blank" rel="external">pallets</a></td>
<td>Python</td>
<td>34411</td>
<td>10562</td>
<td>3205</td>
</tr>
<tr>
<td><a href="https://github.com/keras-team/keras" target="_blank" rel="external">keras-team/keras</a></td>
<td><a href="https://github.com/keras-team" target="_blank" rel="external">keras-team</a></td>
<td>Python</td>
<td>27833</td>
<td>10213</td>
<td>4442</td>
</tr>
<tr>
<td><a href="https://github.com/udacity/fullstack-nanodegree-vm" target="_blank" rel="external">udacity/fullstack-nanodegree-vm</a></td>
<td><a href="https://github.com/udacity" target="_blank" rel="external">udacity</a></td>
<td>Python</td>
<td>202</td>
<td>9370</td>
<td>53</td>
</tr>
<tr>
<td><a href="https://github.com/vinta/awesome-python" target="_blank" rel="external">vinta/awesome-python</a></td>
<td><a href="https://github.com/vinta" target="_blank" rel="external">vinta</a></td>
<td>Python</td>
<td>47930</td>
<td>9270</td>
<td>1222</td>
</tr>
<tr>
<td><a href="https://github.com/odoo/odoo" target="_blank" rel="external">odoo/odoo</a></td>
<td><a href="https://github.com/odoo" target="_blank" rel="external">odoo</a></td>
<td>Python</td>
<td>9200</td>
<td>7889</td>
<td>115520</td>
</tr>
</tbody>
</table>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>stars排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/freeCodeCamp/freeCodeCamp" target="_blank" rel="external">freeCodeCamp/freeCodeCamp</a></td>
<td><a href="https://github.com/freeCodeCamp" target="_blank" rel="external">freeCodeCamp</a></td>
<td>JavaScript</td>
<td>291895</td>
<td>13667</td>
<td>11334</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/react" target="_blank" rel="external">facebook/react</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>92602</td>
<td>17473</td>
<td>9773</td>
</tr>
<tr>
<td><a href="https://github.com/vuejs/vue" target="_blank" rel="external">vuejs/vue</a></td>
<td><a href="https://github.com/vuejs" target="_blank" rel="external">vuejs</a></td>
<td>JavaScript</td>
<td>89447</td>
<td>13129</td>
<td>2581</td>
</tr>
<tr>
<td><a href="https://github.com/d3/d3" target="_blank" rel="external">d3/d3</a></td>
<td><a href="https://github.com/d3" target="_blank" rel="external">d3</a></td>
<td>JavaScript</td>
<td>74472</td>
<td>19024</td>
<td>4132</td>
</tr>
<tr>
<td><a href="https://github.com/airbnb/javascript" target="_blank" rel="external">airbnb/javascript</a></td>
<td><a href="https://github.com/airbnb" target="_blank" rel="external">airbnb</a></td>
<td>JavaScript</td>
<td>68833</td>
<td>13127</td>
<td>1607</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/react-native" target="_blank" rel="external">facebook/react-native</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>62128</td>
<td>14129</td>
<td>13166</td>
</tr>
<tr>
<td><a href="https://github.com/angular/angular.js" target="_blank" rel="external">angular/angular.js</a></td>
<td><a href="https://github.com/angular" target="_blank" rel="external">angular</a></td>
<td>JavaScript</td>
<td>58232</td>
<td>28872</td>
<td>8755</td>
</tr>
<tr>
<td><a href="https://github.com/jquery/jquery" target="_blank" rel="external">jquery/jquery</a></td>
<td><a href="https://github.com/jquery" target="_blank" rel="external">jquery</a></td>
<td>JavaScript</td>
<td>48560</td>
<td>15318</td>
<td>6316</td>
</tr>
<tr>
<td><a href="https://github.com/nodejs/node" target="_blank" rel="external">nodejs/node</a></td>
<td><a href="https://github.com/nodejs" target="_blank" rel="external">nodejs</a></td>
<td>JavaScript</td>
<td>47212</td>
<td>9904</td>
<td>21744</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/create-react-app" target="_blank" rel="external">facebook/create-react-app</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>46391</td>
<td>9259</td>
<td>1484</td>
</tr>
</tbody>
</table>
<p>forks排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/angular/angular.js" target="_blank" rel="external">angular/angular.js</a></td>
<td><a href="https://github.com/angular" target="_blank" rel="external">angular</a></td>
<td>JavaScript</td>
<td>58232</td>
<td>28872</td>
<td>8755</td>
</tr>
<tr>
<td><a href="https://github.com/udacity/frontend-nanodegree-resume" target="_blank" rel="external">udacity/frontend-nanodegree-resume</a></td>
<td><a href="https://github.com/udacity" target="_blank" rel="external">udacity</a></td>
<td>JavaScript</td>
<td>915</td>
<td>25814</td>
<td>84</td>
</tr>
<tr>
<td><a href="https://github.com/d3/d3" target="_blank" rel="external">d3/d3</a></td>
<td><a href="https://github.com/d3" target="_blank" rel="external">d3</a></td>
<td>JavaScript</td>
<td>74472</td>
<td>19024</td>
<td>4132</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/react" target="_blank" rel="external">facebook/react</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>92602</td>
<td>17473</td>
<td>9773</td>
</tr>
<tr>
<td><a href="https://github.com/jquery/jquery" target="_blank" rel="external">jquery/jquery</a></td>
<td><a href="https://github.com/jquery" target="_blank" rel="external">jquery</a></td>
<td>JavaScript</td>
<td>48560</td>
<td>15318</td>
<td>6316</td>
</tr>
<tr>
<td><a href="https://github.com/nightscout/cgm-remote-monitor" target="_blank" rel="external">nightscout/cgm-remote-monitor</a></td>
<td><a href="https://github.com/nightscout" target="_blank" rel="external">nightscout</a></td>
<td>JavaScript</td>
<td>439</td>
<td>15228</td>
<td>4505</td>
</tr>
<tr>
<td><a href="https://github.com/mrdoob/three.js" target="_blank" rel="external">mrdoob/three.js</a></td>
<td><a href="https://github.com/mrdoob" target="_blank" rel="external">mrdoob</a></td>
<td>JavaScript</td>
<td>40668</td>
<td>15152</td>
<td>22927</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/react-native" target="_blank" rel="external">facebook/react-native</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>62128</td>
<td>14129</td>
<td>13166</td>
</tr>
<tr>
<td><a href="https://github.com/freeCodeCamp/freeCodeCamp" target="_blank" rel="external">freeCodeCamp/freeCodeCamp</a></td>
<td><a href="https://github.com/freeCodeCamp" target="_blank" rel="external">freeCodeCamp</a></td>
<td>JavaScript</td>
<td>291895</td>
<td>13667</td>
<td>11334</td>
</tr>
<tr>
<td><a href="https://github.com/vuejs/vue" target="_blank" rel="external">vuejs/vue</a></td>
<td><a href="https://github.com/vuejs" target="_blank" rel="external">vuejs</a></td>
<td>JavaScript</td>
<td>89447</td>
<td>13129</td>
<td>2581</td>
</tr>
</tbody>
</table>
<h3 id="语言使用比例"><a href="#语言使用比例" class="headerlink" title="语言使用比例"></a>语言使用比例</h3><p>stars 超过100的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229847469176.jpg" alt=""></p>
<p>stars 超过1000的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229848318605.jpg" alt=""></p>
<p>stars 超过10000的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229848710272.jpg" alt=""></p>
<p>forks 超过100的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229849187089.jpg" alt=""></p>
<p>forks 超过1000的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229849529776.jpg" alt=""></p>
<p>forks 超过10000的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229849860861.jpg" alt=""></p>
<p>欢迎大家Star我的<a href="https://github.com/Sixzeroo/GithubCrawler" target="_blank" rel="external">Github项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对Github分布式爬虫爬取的20w用户信息和40w仓库信息进行简单的分析和统计&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.liuin.cn/categories/python/"/>
    
    
      <category term="python" scheme="https://www.liuin.cn/tags/python/"/>
    
      <category term="爬虫" scheme="https://www.liuin.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Github分布式爬虫——实现</title>
    <link href="https://www.liuin.cn/2018/04/05/Github%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.liuin.cn/2018/04/05/Github分布式爬虫——实现/</id>
    <published>2018-04-05T11:40:54.000Z</published>
    <updated>2018-04-07T01:54:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用Redis实现分布式爬虫</p>
<a id="more"></a>
<p>主要使用Scrapy、Redis、MongoDB实现，Scrapy作为异步爬虫框架、Redis实现分布式以及Cookies池的存储，MongoDB实现底层数据存储</p>
<h2 id="分布式示意图"><a href="#分布式示意图" class="headerlink" title="分布式示意图"></a>分布式示意图</h2><p><img src="https://data2.liuin.cn/2018-03-25-15219437958574.jpg" alt=""></p>
<p>主机中安装Redis和MongoDB</p>
<p>Redis中存储：</p>
<ul>
<li>所有Scrapy爬虫的待爬取队列</li>
<li>去重用的已发出Request指纹</li>
</ul>
<p>MongoDB负责最终数据的存储</p>
<p>可创建多个Scrapy从机进行爬取，实现分布式。</p>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul>
<li>共享爬取队列实现分布式</li>
<li>生成Request的指纹实现分布式的去重</li>
<li>随机指定User-Agent</li>
<li>通过Redis实现Cookies池并进行更新</li>
</ul>
<h2 id="分布式实现"><a href="#分布式实现" class="headerlink" title="分布式实现"></a>分布式实现</h2><h3 id="请求队列"><a href="#请求队列" class="headerlink" title="请求队列"></a>请求队列</h3><p>各个分布式爬虫共同维护一个Request请求队列，使用的是Redis的list。队列可以实现FIFO，LIFO或者优先级队列。</p>
<p>爬取的时候一开始使用的是优先级队列，但是后来因为不好设置优先级，导致最后都是User的item，导致Rep的饥饿现象，所以到后面换成FIFO队列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FifoQueue</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="string">"""Per-spider FIFO queue"""</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""Return the length of the queue"""</span></div><div class="line">        <span class="keyword">return</span> self.server.llen(self.key)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, request)</span>:</span></div><div class="line">        <span class="string">"""Push a request"""</span></div><div class="line">        self.server.lpush(self.key, self._encode_request(request))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self, timeout=<span class="number">0</span>)</span>:</span></div><div class="line">        <span class="string">"""Pop a request"""</span></div><div class="line">        <span class="keyword">if</span> timeout &gt; <span class="number">0</span>:</div><div class="line">            data = self.server.brpop(self.key, timeout)</div><div class="line">            <span class="keyword">if</span> isinstance(data, tuple):</div><div class="line">                data = data[<span class="number">1</span>]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            data = self.server.rpop(self.key)</div><div class="line">        <span class="keyword">if</span> data:</div><div class="line">            <span class="keyword">return</span> self._decode_request(data)</div></pre></td></tr></table></figure>
<p>同时需要设置request队列的大小限制，因为爬取Github页面的时候可能爬取一个star列表以后就会产生几十个Request，这样很容易把Redis的队列挤爆：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">enqueue_request</span><span class="params">(self, request)</span>:</span></div><div class="line">    <span class="comment"># set upper limit of request num</span></div><div class="line">    <span class="keyword">if</span> len(self.queue) &gt; REQUEST_NUM:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.dont_filter <span class="keyword">and</span> self.df.request_seen(request):</div><div class="line">        self.df.log(request, self.spider)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">if</span> self.stats:</div><div class="line">        self.stats.inc_value(<span class="string">'scheduler/enqueued/redis'</span>, spider=self.spider)</div><div class="line">    self.queue.push(request)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>没有设置数量大小的时候，1G内存的主机跑一个多小时之后就挂掉了：</p>
<p><img src="https://data2.liuin.cn/2018-03-21-15215617499559.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-20-15215615819339.jpg" alt=""></p>
<h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><p>为了使用共同的请求队列，所以需要重写Scheduler，重写的Scheduler负责把要爬取的request放入队列以及从队列中找出request进行爬取</p>
<h3 id="去重集合"><a href="#去重集合" class="headerlink" title="去重集合"></a>去重集合</h3><p>本地爬虫通常需要解决一个去重问题，通常使用的是数据库查询，爬取之前判断url是否请求过。分布式爬虫就是在这个的基础上共用一个去重集合，使用的是Redis的set。</p>
<p>判断一个Request是否已经爬取过，这里不是使用url，因为不同的url可能代表的是同一种资源，比如：<code>http://www.example.com/query?cat=222&amp;id=111</code>和<code>http://www.example.com/query?cat=222&amp;id=111</code> 事实表示的是一个东西。此外，发出的Request还可能与当时的Cookie有关，因为里面还会有用户信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 计算Request指纹判断有没有重复</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_seen</span><span class="params">(self, request)</span>:</span></div><div class="line">    fp = self.request_fingerprint(request)</div><div class="line">    <span class="keyword">if</span> USEBLOOMFILTER == <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">if</span> self.bf.isContains(fp):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.bf.insert(fp)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="comment"># This returns the number of values added, zero if already exists.</span></div><div class="line">        added = self.server.sadd(self.key, fp)</div><div class="line">        <span class="keyword">return</span> added == <span class="number">0</span></div></pre></td></tr></table></figure>
<p>这里采用的方案是生成一个Request的指纹，实际上是把request的url，method和指定的header使用sha1算法得到一个hash值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Request 指纹计算方法</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_fingerprint</span><span class="params">(request, include_headers=None)</span>:</span></div><div class="line">    <span class="keyword">if</span> include_headers:</div><div class="line">        include_headers = tuple(to_bytes(h.lower())</div><div class="line">                                 <span class="keyword">for</span> h <span class="keyword">in</span> sorted(include_headers))</div><div class="line">    cache = _fingerprint_cache.setdefault(request, &#123;&#125;)</div><div class="line">    <span class="keyword">if</span> include_headers <span class="keyword">not</span> <span class="keyword">in</span> cache:</div><div class="line">        fp = hashlib.sha1()</div><div class="line">        fp.update(to_bytes(request.method))</div><div class="line">        fp.update(to_bytes(canonicalize_url(request.url)))</div><div class="line">        fp.update(request.body <span class="keyword">or</span> <span class="string">b''</span>)</div><div class="line">        <span class="keyword">if</span> include_headers:</div><div class="line">            <span class="keyword">for</span> hdr <span class="keyword">in</span> include_headers:</div><div class="line">                <span class="keyword">if</span> hdr <span class="keyword">in</span> request.headers:</div><div class="line">                    fp.update(hdr)</div><div class="line">                    <span class="keyword">for</span> v <span class="keyword">in</span> request.headers.getlist(hdr):</div><div class="line">                        fp.update(v)</div><div class="line">        cache[include_headers] = fp.hexdigest()</div><div class="line">    <span class="keyword">return</span> cache[include_headers]</div></pre></td></tr></table></figure>
<h2 id="反反爬虫策略"><a href="#反反爬虫策略" class="headerlink" title="反反爬虫策略"></a>反反爬虫策略</h2><h3 id="随机User-Agent"><a href="#随机User-Agent" class="headerlink" title="随机User-Agent"></a>随机User-Agent</h3><p>使用中间件实现随机User-Agent，随机替换掉request的header的User-Agent参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitHubUserAgentMiddleware</span><span class="params">(UserAgentMiddleware)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></div><div class="line">        agent = random.choice(agents)</div><div class="line">        request.headers[<span class="string">'User-Agent'</span>] = agent</div></pre></td></tr></table></figure>
<h3 id="Cookies池"><a href="#Cookies池" class="headerlink" title="Cookies池"></a>Cookies池</h3><p>首先使用多账号模拟登录，获取到很多已登录账号的cookies，放入到Redis的hashset中，各个爬虫共用这一个Cookies池。爬虫同样实现一个中间件，替换Request的Cookies。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Cookie 中间件</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitHubCookieMiddleware</span><span class="params">(RetryMiddleware)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,settings)</span>:</span></div><div class="line">        RetryMiddleware.__init__(self,settings)</div><div class="line">        self.rconn = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, db=<span class="number">3</span>)</div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></div><div class="line">        <span class="keyword">return</span> cls(crawler.settings)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></div><div class="line">        keys = self.rconn.hkeys(REDIS_COOKIE)</div><div class="line">        <span class="keyword">if</span>(len(keys) == <span class="number">0</span>):</div><div class="line">            print(<span class="string">"cookies don't work!"</span>)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        key = random.choice(keys)</div><div class="line">        <span class="comment"># 获取最新cookie</span></div><div class="line">        value = self.rconn.hget(REDIS_COOKIE, key)</div><div class="line">        <span class="keyword">if</span>( isinstance(value, bytes) ):</div><div class="line">            value = value.decode(<span class="string">'utf-8'</span>)</div><div class="line">        cookies = json.loads(value)</div><div class="line">        request.cookies = cookies</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一个为了了解分布式工作原理而做的一个小的项目，其中很多地方存在缺陷，欢迎大家在Github上留建议：</p>
<p><a href="https://github.com/Sixzeroo/GithubCrawler" target="_blank" rel="external">https://github.com/Sixzeroo/GithubCrawler</a></p>
<p>同时也可以查看下一篇关于Github用户和仓库数据分析的文章</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Redis实现分布式爬虫&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.liuin.cn/categories/python/"/>
    
    
      <category term="python" scheme="https://www.liuin.cn/tags/python/"/>
    
      <category term="爬虫" scheme="https://www.liuin.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 题解——Redundant Connection II</title>
    <link href="https://www.liuin.cn/2018/03/28/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Redundant-Connection-II/"/>
    <id>https://www.liuin.cn/2018/03/28/LeetCode-题解——Redundant-Connection-II/</id>
    <published>2018-03-28T07:09:37.000Z</published>
    <updated>2018-03-28T07:12:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题解——Redundant Connection II</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个有向图，求其有向的最小生成树（除了根节点之外所有的节点都有一条入边指向它），同时给出的有向图刚好只多出一条边</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>前一道题是求只多出一条边的无向图的最小生成树，使用并查集很容易就能够求解。</p>
<p>这一道有向图的题就比较复杂一点了，有向图的最小生成树又叫最小树形图，常规算法是使用<a href="https://www.liuin.cn/2017/03/25/%E5%88%9D%E8%AF%86-%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95/">朱刘算法</a>。这里因为只多出一条边，所以不用这么麻烦。</p>
<p>总共有三种情况：</p>
<ol>
<li>有环，但是没有入度为2的节点</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-03-28-15222211302563.jpg" alt=""></p>
<ol>
<li>有环，同时有入度为2的节点</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-03-28-15222211412345.jpg" alt=""></p>
<ol>
<li>无环，有入度为2的节点</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-03-28-15222211561578.jpg" alt=""></p>
<p>第一种情况，按照无向图的处理方式进行就行了，使用并查集返回最后一条形成环的边。</p>
<p>后面两种情况，首先要找到入度为2的节点，选出指向这个节点的两条边，处理完其他的边以后处理这两条边，使用并查集找出最后一个连接的两个节点已经在同一集合中的边</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> par[<span class="number">3000</span>];</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">            par[i] = i;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> par[x] = find(par[x]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></div><div class="line">    &#123;</div><div class="line">        x = find(x);</div><div class="line">        y = find(y);</div><div class="line">        <span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</div><div class="line">        par[y] = x;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 并查集</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findRedundantDirectedConnection(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</div><div class="line">        <span class="keyword">int</span> len = edges.size();</div><div class="line">        init(len);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegre(len, <span class="number">0</span>), outdegre(len, <span class="number">0</span>);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; problem_edge;</div><div class="line">        <span class="keyword">int</span> node = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 统计入度，找到入度为2的点</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:edges)</div><div class="line">        &#123;</div><div class="line">            indegre[i[<span class="number">1</span>]]++;</div><div class="line">            <span class="keyword">if</span>(indegre[i[<span class="number">1</span>]] == <span class="number">2</span>) node = i[<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:edges)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i[<span class="number">1</span>] == node)</div><div class="line">            &#123;</div><div class="line">                problem_edge.push_back(i);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 有环的情况</span></div><div class="line">            <span class="keyword">int</span> a = find(i[<span class="number">0</span>]), b= find(i[<span class="number">1</span>]);</div><div class="line">            <span class="keyword">if</span>(a == b) </div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">            unite(i[<span class="number">0</span>], i[<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 无环的情况，从入度为2的节点入手</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:problem_edge)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> a = find(i[<span class="number">0</span>]), b= find(i[<span class="number">1</span>]);</div><div class="line">            <span class="keyword">if</span>(a == b) <span class="keyword">return</span> i;</div><div class="line">            <span class="keyword">else</span> unite(a,b);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题解——Redundant Connection II&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.liuin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="图论" scheme="https://www.liuin.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="LeetCode" scheme="https://www.liuin.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析——内存分配</title>
    <link href="https://www.liuin.cn/2018/03/23/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>https://www.liuin.cn/2018/03/23/Redis源码剖析——内存分配/</id>
    <published>2018-03-23T10:43:53.000Z</published>
    <updated>2018-03-23T11:12:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>内存分配是程序需要解决的一个大问题，也应该是剖析一个程序的源码最基础最关键的部分之一。</p>
<a id="more"></a>
<p>Redis的内存分配主要是在C语言中对内存处理的函数：malloc、realloc、free的基础加了一些封装和异常的处理。</p>
<p>其特点主要有以下三点：</p>
<ol>
<li>添加对使用内存的统计，在分配和释放内存的时候都会更新记录使用内存的量</li>
<li>支持线程安全模式，通过锁的机制对use_memory进行控制，避免其出现脏数据的可能</li>
<li>增添对内存溢出的处理</li>
</ol>
<p>首先Redis源码中与内存分配相关的以下全局变量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>;    <span class="comment">// 使用的内存大小</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> zmalloc_thread_safe = <span class="number">0</span>;   <span class="comment">// 线程安全模式状态</span></div><div class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;   <span class="comment">// 为此服务器</span></div></pre></td></tr></table></figure></p>
<h2 id="内存分配相关功能函数"><a href="#内存分配相关功能函数" class="headerlink" title="内存分配相关功能函数"></a>内存分配相关功能函数</h2><p>Redis中和内存分配相关的功能函数主要有以下这些：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void *zmalloc(size_t size);   </div><div class="line">void *zcalloc(size_t size);</div><div class="line">void *zrealloc(void *ptr, size_t size);</div><div class="line">void zfree(void *ptr);</div><div class="line">char *zstrdup(const char *s);  // 封装的字符复制函数</div><div class="line">size_t zmalloc_used_memory(void);   // 获取使用的内存大小</div><div class="line">void zmalloc_enable_thread_safeness(void);    // 开启线程安全模式</div><div class="line">void zmalloc_set_oom_handler(void (*oom_handler)(size_t));   // 自定义的内存溢出处理方法</div><div class="line">float zmalloc_get_fragmentation_ratio(size_t rss);  // 使用内存和所给内存之比</div><div class="line">size_t zmalloc_get_rss(void);  // 获取rss信息</div><div class="line">size_t zmalloc_get_private_dirty(void);   // 获取实际物理分配的内存</div></pre></td></tr></table></figure></p>
<h2 id="内存申请与调整"><a href="#内存申请与调整" class="headerlink" title="内存申请与调整"></a>内存申请与调整</h2><p>Redis中和内存申请相关的函数主要是zmalloc、zcalloc和zrealloc，分别是对C语言中的malloc、calloc和realloc的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对malloc进行封装，加上异常处理和内存统计</span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="comment">// 多申请的内存用于存储次块空间大小</span></div><div class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</div><div class="line"></div><div class="line">    <span class="comment">// 内存溢出</span></div><div class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</div><div class="line">    <span class="comment">// 进行内存统计</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</div><div class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size+PREFIX_SIZE);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</div><div class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 封装重新分配内存函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="keyword">void</span> *realptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">size_t</span> oldsize;</div><div class="line">    <span class="keyword">void</span> *newptr;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zmalloc(size);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="comment">// 原来所使用空间的大小</span></div><div class="line">    oldsize = zmalloc_size(ptr);</div><div class="line">    <span class="comment">// 重新分配新的空间</span></div><div class="line">    newptr = <span class="built_in">realloc</span>(ptr,size);</div><div class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</div><div class="line"></div><div class="line">    <span class="comment">// 更新保存的使用内存值</span></div><div class="line">    update_zmalloc_stat_free(oldsize);</div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(newptr));</div><div class="line">    <span class="keyword">return</span> newptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</div><div class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</div><div class="line">    newptr = <span class="built_in">realloc</span>(realptr,size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</div><div class="line"></div><div class="line">    *((<span class="keyword">size_t</span>*)newptr) = size;</div><div class="line">    update_zmalloc_stat_free(oldsize);</div><div class="line">    update_zmalloc_stat_alloc(size);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先要注意的是对内存溢出的处理，可以自定义处理函数，其默认的处理方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 默认溢出处理方法</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zmalloc_default_oom</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"zmalloc: Out of memory trying to allocate %zu bytes\n"</span>,</div><div class="line">        size);</div><div class="line">    fflush(<span class="built_in">stderr</span>);</div><div class="line">    <span class="built_in">abort</span>();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 内存溢出处理方法</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*zmalloc_oom_handler)</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= zmalloc_default_oom;</div></pre></td></tr></table></figure>
<p>然后我们可以看到每次在调整内存的时候，都会对全局变量use_memory进行改变，调整是以<code>sizeof(long)</code>的整数倍进行调整的。在改变use_memory的时候会判断是否在线程安全模式下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 更新使用的内存数量值</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) do &#123; \</span></div><div class="line">    size_t _n = (__n); \</div><div class="line">    <span class="comment">// _n调整为size(long)的整数倍</span></div><div class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</div><div class="line">    <span class="comment">// 线程安全模式，原子性增加使用内存大小 （加锁）</span></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \</div><div class="line">        update_zmalloc_stat_add(_n); \</div><div class="line">    <span class="comment">// 不使用线程安全模式，直接增加</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123; \</div><div class="line">        used_memory += _n; \</div><div class="line">    &#125; \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_add(__n) do &#123; \</span></div><div class="line">    pthread_mutex_lock(&amp;used_memory_mutex); \</div><div class="line">    used_memory += (__n); \</div><div class="line">    pthread_mutex_unlock(&amp;used_memory_mutex); \</div><div class="line">&#125; while(0)</div></pre></td></tr></table></figure>
<h2 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h2><p>内存释放部分和申请部分类似，主要是对free函数的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取内存占用空间大小</span></div><div class="line"><span class="keyword">size_t</span> zmalloc_size(<span class="keyword">void</span> *ptr) &#123;</div><div class="line">    <span class="comment">// 减去统计内存大小的部分</span></div><div class="line">    <span class="keyword">void</span> *realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</div><div class="line">    <span class="keyword">size_t</span> size = *((<span class="keyword">size_t</span>*)realptr);</div><div class="line">    <span class="comment">/* Assume at least that all the allocations are padded at sizeof(long) by</span></div><div class="line">     * the underlying allocator. */</div><div class="line">    <span class="comment">// 调整为sizeof(long)的整数倍，方便对齐</span></div><div class="line">    <span class="keyword">if</span> (size&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) size += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(size&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>));</div><div class="line">    <span class="keyword">return</span> size+PREFIX_SIZE;</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">// 封装对系统的free调用</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="keyword">void</span> *realptr;</div><div class="line">    <span class="keyword">size_t</span> oldsize;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="comment">// 减少对内存的计数</span></div><div class="line">    update_zmalloc_stat_free(zmalloc_size(ptr));</div><div class="line">    <span class="built_in">free</span>(ptr);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</div><div class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</div><div class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</div><div class="line">    <span class="built_in">free</span>(realptr);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对use_memory的操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 释放内存以后对内存空间统计变量的改变</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_free(__n) do &#123; \</span></div><div class="line">    size_t _n = (__n); \</div><div class="line">    <span class="comment">// 以sizeof(long)的整数倍进行调整</span></div><div class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</div><div class="line">    <span class="comment">// 线程安全模式</span></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \</div><div class="line">        update_zmalloc_stat_sub(_n); \</div><div class="line">    &#125; <span class="keyword">else</span> &#123; \</div><div class="line">        used_memory -= _n; \</div><div class="line">    &#125; \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><p>除了最基本的一些内存分配的函数以外，还实现了一些辅助函数(如复制字符串、获取已经使用内存的大小）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 复制字符串操作</span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</div><div class="line">    <span class="keyword">size_t</span> l = <span class="built_in">strlen</span>(s)+<span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> *p = zmalloc(l);</div><div class="line"></div><div class="line">    <span class="comment">// 调用字符复制函数</span></div><div class="line">    <span class="built_in">memcpy</span>(p,s,l);</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取已经使用的内存大小</span></div><div class="line"><span class="keyword">size_t</span> zmalloc_used_memory(<span class="keyword">void</span>) &#123;</div><div class="line">    <span class="keyword">size_t</span> um;</div><div class="line"></div><div class="line">    <span class="comment">// 线程安全模式</span></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__ATOMIC_RELAXED) || defined(HAVE_ATOMIC)</span></div><div class="line">        um = update_zmalloc_stat_add(<span class="number">0</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        pthread_mutex_lock(&amp;used_memory_mutex);</div><div class="line">        um = used_memory;</div><div class="line">        pthread_mutex_unlock(&amp;used_memory_mutex);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 非线程安全情况下，直接赋值</span></div><div class="line">        um = used_memory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> um;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存分配是程序需要解决的一个大问题，也应该是剖析一个程序的源码最基础最关键的部分之一。&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="https://www.liuin.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
</feed>
