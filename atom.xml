<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sixzeroo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.liuin.cn/"/>
  <updated>2018-04-09T03:02:32.000Z</updated>
  <id>https://www.liuin.cn/</id>
  
  <author>
    <name>Sixzeroo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>同步/异步与阻塞/非阻塞的理解</title>
    <link href="https://www.liuin.cn/2018/04/09/%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E4%B8%8E%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://www.liuin.cn/2018/04/09/同步-异步与阻塞-非阻塞的理解/</id>
    <published>2018-04-09T02:57:32.000Z</published>
    <updated>2018-04-09T03:02:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期在了解网络编程的时候对同步/异步和阻塞/非阻塞这些概念有一些混淆，所查了一些资料总结了这篇文章。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于同步/异步与阻塞/非阻塞的理解可能各个领域的人的回答是不一样的，在网络上也有各种各样的说法。这其实是因为不同的人的知识背景不同，并且在讨论这个问题的时候上下文(context)也不相同。本文主要结合网络上的观点以及一些书籍谈谈对同步/异步与阻塞/非阻塞大致概念上的理解，以及在Linux Network IO上的这四个概念的情况。</p>
<h2 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h2><p>同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)</p>
<p>所谓同步，就是在发出一个<strong>调用</strong>时，在没有得到结果之前，该<strong>调用</strong>就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由<strong>调用者</strong>主动等待这个<strong>调用</strong>的结果。</p>
<p>而异步则是相反，<strong>调用</strong>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<strong>调用</strong>发出后，<strong>被调用者</strong>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
<p>打一个不恰当的比方：</p>
<blockquote>
<p>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p>
</blockquote>
<h2 id="阻塞-非阻塞"><a href="#阻塞-非阻塞" class="headerlink" title="阻塞/非阻塞"></a>阻塞/非阻塞</h2><p>阻塞和非阻塞关注的是程序在<strong>等待调用结果（消息，返回值）时的状态</strong>.</p>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<p>例子：</p>
<blockquote>
<p>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。</p>
</blockquote>
<p>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>
<p>把自己挂起可以是在电话里面一直等着老板回信（同步阻塞），也可以是挂掉电话以后一直等着老板回电过来（异步阻塞）。先玩一会儿可以是电话接通着你去玩一会儿（同步非阻塞），也可以是电话挂了你去玩老板回电给你的时候你回来接（异步非阻塞）。</p>
<p>阻塞和非阻塞描述的是一种状态，同步与非同步描述的是行为方式。</p>
<h2 id="Unix-网络IO"><a href="#Unix-网络IO" class="headerlink" title="Unix 网络IO"></a>Unix 网络IO</h2><p>POSIX对同步I/O和异步I/O的定义如下：</p>
<ul>
<li>同步I/O操作( synchronous I/O opetation) 导致请求进程阻塞,直到I/O操作完成</li>
<li>异步IO操作( asynchronous I/O opetation) 不导致请求进程阻塞。</li>
</ul>
<p>在Unix中有四种常用的网络IO模型：</p>
<ul>
<li>阻塞式I/O</li>
<li>非阻塞式I/O</li>
<li>I/O复用</li>
<li>异步I/O</li>
</ul>
<p>其中前者都是同步I/O</p>
<h3 id="阻塞式I-O"><a href="#阻塞式I-O" class="headerlink" title="阻塞式I/O"></a>阻塞式I/O</h3><p>默认情况下，所有套接字都是阻塞的。在下面展示recvfrom系统调用中把数据接收过程分成两个阶段：1. 等待数据 2. 数据复制到用户空间。</p>
<p><img src="https://data2.liuin.cn/2018-04-09-15232418188483.jpg" alt=""></p>
<p>在等待过程中，进程不能做其他事情，所以是阻塞式的。什么时候调用结束：有结果或者报错的时候，调用才结束，所以是同步的。</p>
<h3 id="非阻塞式I-O"><a href="#非阻塞式I-O" class="headerlink" title="非阻塞式I/O"></a>非阻塞式I/O</h3><p><img src="https://data2.liuin.cn/2018-04-09-15232420864225.jpg" alt=""></p>
<p>在非阻塞式I/O中进程在进行系统调用recvfrom的时候，如果数据没有准备好线程不会等待，而是不断询问，直到数据准备好，复制数据到用户空间以后，接受数据这个动作才算完成。</p>
<p>因为线程不是一直在等待数据返回，其中也可以做其他的事情，所以是非阻塞式的，对于接受数据这个动作，进程会不断询问，知道最后有结果才算结束，所以是同步式的。</p>
<h3 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h3><p><img src="https://data2.liuin.cn/2018-04-09-15232424437721.jpg" alt=""></p>
<p>我们阻塞于 select调用,等待数据报套接字变为可读。当se1ect返回套接字可读这一条件时,我们调用 recvfrom把所读数据报复制到应用进程缓冲区。</p>
<h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><p><img src="https://data2.liuin.cn/2018-04-09-15232425049293.jpg" alt=""></p>
<p>异步I/O的工作模式时:告知内核启动某个操作,并让内核在整个操作(包括将数据从内核复制到我们自己的缓冲区)完成后通知我们。所以进程不需要一直询问其数据是否准备好</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><img src="https://data2.liuin.cn/2018-04-09-15232425884264.jpg" alt=""></p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://www.zhihu.com/question/19732473/answer/20851256" target="_blank" rel="external">https://www.zhihu.com/question/19732473/answer/20851256</a></li>
<li>《Unix 网络编程》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期在了解网络编程的时候对同步/异步和阻塞/非阻塞这些概念有一些混淆，所查了一些资料总结了这篇文章。&lt;/p&gt;
    
    </summary>
    
      <category term="开发随笔" scheme="https://www.liuin.cn/categories/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Unix" scheme="https://www.liuin.cn/tags/Unix/"/>
    
  </entry>
  
  <entry>
    <title>Github分布式爬虫——数据分析</title>
    <link href="https://www.liuin.cn/2018/04/07/Github%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <id>https://www.liuin.cn/2018/04/07/Github分布式爬虫——数据分析/</id>
    <published>2018-04-07T01:54:54.000Z</published>
    <updated>2018-04-07T02:00:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>对Github分布式爬虫爬取的20w用户信息和40w仓库信息进行简单的分析和统计</p>
<a id="more"></a>
<p>这里爬取的数据主要有两大类：用户数据和仓库数据，此次分析的数据量：256171用户数据，434994仓库数据</p>
<h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><h3 id="全球用户榜单"><a href="#全球用户榜单" class="headerlink" title="全球用户榜单"></a>全球用户榜单</h3><h4 id="Followers人数榜"><a href="#Followers人数榜" class="headerlink" title="Followers人数榜"></a>Followers人数榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/1024025" alt=""></td>
<td><a href="https://github.com/torvalds" target="_blank" rel="external">https://github.com/torvalds</a></td>
<td>6</td>
<td>2</td>
<td>70400</td>
<td>0</td>
<td>8</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/66577" alt=""></td>
<td><a href="https://github.com/JakeWharton" target="_blank" rel="external">https://github.com/JakeWharton</a></td>
<td>95</td>
<td>228</td>
<td>45000</td>
<td>12</td>
<td>3541</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/905434" alt=""></td>
<td><a href="https://github.com/ruanyf" target="_blank" rel="external">https://github.com/ruanyf</a></td>
<td>48</td>
<td>206</td>
<td>38200</td>
<td>0</td>
<td>1645</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/25254" alt=""></td>
<td><a href="https://github.com/tj" target="_blank" rel="external">https://github.com/tj</a></td>
<td>273</td>
<td>2000</td>
<td>34400</td>
<td>46</td>
<td>3310</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/499550" alt=""></td>
<td><a href="https://github.com/yyx990803" target="_blank" rel="external">https://github.com/yyx990803</a></td>
<td>141</td>
<td>779</td>
<td>29200</td>
<td>90</td>
<td>2553</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/110953" alt=""></td>
<td><a href="https://github.com/addyosmani" target="_blank" rel="external">https://github.com/addyosmani</a></td>
<td>295</td>
<td>807</td>
<td>29000</td>
<td>254</td>
<td>928</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/810438" alt=""></td>
<td><a href="https://github.com/gaearon" target="_blank" rel="external">https://github.com/gaearon</a></td>
<td>227</td>
<td>1300</td>
<td>27200</td>
<td>171</td>
<td>3019</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/39191" alt=""></td>
<td><a href="https://github.com/paulirish" target="_blank" rel="external">https://github.com/paulirish</a></td>
<td>266</td>
<td>723</td>
<td>25600</td>
<td>245</td>
<td>2375</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/170270" alt=""></td>
<td><a href="https://github.com/sindresorhus" target="_blank" rel="external">https://github.com/sindresorhus</a></td>
<td>975</td>
<td>2500</td>
<td>23600</td>
<td>50</td>
<td>4753</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/119893" alt=""></td>
<td><a href="https://github.com/kennethreitz" target="_blank" rel="external">https://github.com/kennethreitz</a></td>
<td>141</td>
<td>1900</td>
<td>21200</td>
<td>197</td>
<td>5626</td>
</tr>
</tbody>
</table>
<h4 id="Following人数榜"><a href="#Following人数榜" class="headerlink" title="Following人数榜"></a>Following人数榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/3076393" alt=""></td>
<td><a href="https://github.com/KevinHock" target="_blank" rel="external">https://github.com/KevinHock</a></td>
<td>19</td>
<td>198</td>
<td>1300</td>
<td>284000</td>
<td>639</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/5877145" alt=""></td>
<td><a href="https://github.com/angusshire" target="_blank" rel="external">https://github.com/angusshire</a></td>
<td>8</td>
<td>217000</td>
<td>10300</td>
<td>230000</td>
<td>30</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/6508763" alt=""></td>
<td><a href="https://github.com/dalinhuang99" target="_blank" rel="external">https://github.com/dalinhuang99</a></td>
<td>20</td>
<td>75</td>
<td>3200</td>
<td>162000</td>
<td>1293</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/3604053" alt=""></td>
<td><a href="https://github.com/cusspvz" target="_blank" rel="external">https://github.com/cusspvz</a></td>
<td>109</td>
<td>1200</td>
<td>6600</td>
<td>130000</td>
<td>90</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/6673982" alt=""></td>
<td><a href="https://github.com/MichalPaszkiewicz" target="_blank" rel="external">https://github.com/MichalPaszkiewicz</a></td>
<td>60</td>
<td>558</td>
<td>4600</td>
<td>72700</td>
<td>172</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/418638" alt=""></td>
<td><a href="https://github.com/nfultz" target="_blank" rel="external">https://github.com/nfultz</a></td>
<td>70</td>
<td>2500</td>
<td>2600</td>
<td>61600</td>
<td>2141</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/14251570" alt=""></td>
<td><a href="https://github.com/mstraughan86" target="_blank" rel="external">https://github.com/mstraughan86</a></td>
<td>15</td>
<td>454</td>
<td>3400</td>
<td>60500</td>
<td>299</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/32831059" alt=""></td>
<td><a href="https://github.com/opengiineer" target="_blank" rel="external">https://github.com/opengiineer</a></td>
<td>19</td>
<td>90</td>
<td>1600</td>
<td>55700</td>
<td>46</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/778015" alt=""></td>
<td><a href="https://github.com/ahmetabdi" target="_blank" rel="external">https://github.com/ahmetabdi</a></td>
<td>130</td>
<td>4100</td>
<td>448</td>
<td>53300</td>
<td>1954</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/4107768" alt=""></td>
<td><a href="https://github.com/brunocasanova" target="_blank" rel="external">https://github.com/brunocasanova</a></td>
<td>46</td>
<td>152</td>
<td>2400</td>
<td>48300</td>
<td>13</td>
</tr>
</tbody>
</table>
<h4 id="Stars榜"><a href="#Stars榜" class="headerlink" title="Stars榜"></a>Stars榜</h4><p>看看谁收藏的仓库最多</p>
<table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/5877145" alt=""></td>
<td><a href="https://github.com/angusshire" target="_blank" rel="external">https://github.com/angusshire</a></td>
<td>8</td>
<td>217000</td>
<td>10300</td>
<td>230000</td>
<td>30</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1610158" alt=""></td>
<td><a href="https://github.com/mcanthony" target="_blank" rel="external">https://github.com/mcanthony</a></td>
<td>4300</td>
<td>42500</td>
<td>375</td>
<td>12700</td>
<td>21</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/3947125" alt=""></td>
<td><a href="https://github.com/maoabc1818" target="_blank" rel="external">https://github.com/maoabc1818</a></td>
<td>9</td>
<td>32200</td>
<td>121</td>
<td>95</td>
<td>2</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/391299" alt=""></td>
<td><a href="https://github.com/JT5D" target="_blank" rel="external">https://github.com/JT5D</a></td>
<td>210</td>
<td>29300</td>
<td>276</td>
<td>6200</td>
<td>0</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/500775" alt=""></td>
<td><a href="https://github.com/reduxionist" target="_blank" rel="external">https://github.com/reduxionist</a></td>
<td>15</td>
<td>25800</td>
<td>174</td>
<td>429</td>
<td>62</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/6948067" alt=""></td>
<td><a href="https://github.com/pranavlathigara" target="_blank" rel="external">https://github.com/pranavlathigara</a></td>
<td>1200</td>
<td>24600</td>
<td>793</td>
<td>14900</td>
<td>130</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/2882" alt=""></td>
<td><a href="https://github.com/nikolay" target="_blank" rel="external">https://github.com/nikolay</a></td>
<td>12</td>
<td>23100</td>
<td>243</td>
<td>349</td>
<td>469</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/3759759" alt=""></td>
<td><a href="https://github.com/denji" target="_blank" rel="external">https://github.com/denji</a></td>
<td>1300</td>
<td>22500</td>
<td>181</td>
<td>397</td>
<td>305</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/24416962" alt=""></td>
<td><a href="https://github.com/roscopecoltran" target="_blank" rel="external">https://github.com/roscopecoltran</a></td>
<td>156</td>
<td>21000</td>
<td>121</td>
<td>4400</td>
<td>599</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/6257454" alt=""></td>
<td><a href="https://github.com/Jerzerak" target="_blank" rel="external">https://github.com/Jerzerak</a></td>
<td>1</td>
<td>18900</td>
<td>54</td>
<td>0</td>
<td>3</td>
</tr>
</tbody>
</table>
<h4 id="Reps榜"><a href="#Reps榜" class="headerlink" title="Reps榜"></a>Reps榜</h4><p>Github上创建仓库最多的人在这里</p>
<table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/675997" alt=""></td>
<td><a href="https://github.com/pombredanne" target="_blank" rel="external">https://github.com/pombredanne</a></td>
<td>40600</td>
<td>6500</td>
<td>149</td>
<td>87</td>
<td>2558</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/1732196" alt=""></td>
<td><a href="https://github.com/carriercomm" target="_blank" rel="external">https://github.com/carriercomm</a></td>
<td>20400</td>
<td>12900</td>
<td>72</td>
<td>176</td>
<td>151</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/14135456" alt=""></td>
<td><a href="https://github.com/digideskio" target="_blank" rel="external">https://github.com/digideskio</a></td>
<td>18000</td>
<td>88</td>
<td>120</td>
<td>3900</td>
<td>113</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/431924" alt=""></td>
<td><a href="https://github.com/guoyu07" target="_blank" rel="external">https://github.com/guoyu07</a></td>
<td>11600</td>
<td>91</td>
<td>20</td>
<td>1000</td>
<td>112</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/12729391" alt=""></td>
<td><a href="https://github.com/modulexcite" target="_blank" rel="external">https://github.com/modulexcite</a></td>
<td>10700</td>
<td>4200</td>
<td>30</td>
<td>192</td>
<td>15</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/1218365" alt=""></td>
<td><a href="https://github.com/PlumpMath" target="_blank" rel="external">https://github.com/PlumpMath</a></td>
<td>10100</td>
<td>508</td>
<td>31</td>
<td>147</td>
<td>103</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/3380677" alt=""></td>
<td><a href="https://github.com/carabina" target="_blank" rel="external">https://github.com/carabina</a></td>
<td>9300</td>
<td>8700</td>
<td>83</td>
<td>5</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/4687038" alt=""></td>
<td><a href="https://github.com/jorik041" target="_blank" rel="external">https://github.com/jorik041</a></td>
<td>9200</td>
<td>53</td>
<td>20</td>
<td>129</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1332574" alt=""></td>
<td><a href="https://github.com/treejames" target="_blank" rel="external">https://github.com/treejames</a></td>
<td>8000</td>
<td>6900</td>
<td>93</td>
<td>897</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/498130" alt=""></td>
<td><a href="https://github.com/mehulsbhatt" target="_blank" rel="external">https://github.com/mehulsbhatt</a></td>
<td>7400</td>
<td>364</td>
<td>23</td>
<td>9</td>
<td>104</td>
</tr>
</tbody>
</table>
<h4 id="Contribution榜"><a href="#Contribution榜" class="headerlink" title="Contribution榜"></a>Contribution榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/3244" alt=""></td>
<td><a href="https://github.com/robertbrook" target="_blank" rel="external">https://github.com/robertbrook</a></td>
<td>67</td>
<td>32</td>
<td>63</td>
<td>114</td>
<td>539804</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/20975616" alt=""></td>
<td><a href="https://github.com/SimiCode" target="_blank" rel="external">https://github.com/SimiCode</a></td>
<td>24</td>
<td>11</td>
<td>5</td>
<td>15</td>
<td>377077</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/751143" alt=""></td>
<td><a href="https://github.com/jasoncalabrese" target="_blank" rel="external">https://github.com/jasoncalabrese</a></td>
<td>75</td>
<td>50</td>
<td>64</td>
<td>19</td>
<td>357587</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/56100" alt=""></td>
<td><a href="https://github.com/kinlane" target="_blank" rel="external">https://github.com/kinlane</a></td>
<td>222</td>
<td>242</td>
<td>346</td>
<td>588</td>
<td>199240</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/415831" alt=""></td>
<td><a href="https://github.com/talos" target="_blank" rel="external">https://github.com/talos</a></td>
<td>113</td>
<td>95</td>
<td>143</td>
<td>7</td>
<td>115891</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/283441" alt=""></td>
<td><a href="https://github.com/honzajavorek" target="_blank" rel="external">https://github.com/honzajavorek</a></td>
<td>87</td>
<td>167</td>
<td>128</td>
<td>93</td>
<td>80301</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1006477" alt=""></td>
<td><a href="https://github.com/felixonmars" target="_blank" rel="external">https://github.com/felixonmars</a></td>
<td>420</td>
<td>369</td>
<td>806</td>
<td>149</td>
<td>70179</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/1317792" alt=""></td>
<td><a href="https://github.com/xndcn" target="_blank" rel="external">https://github.com/xndcn</a></td>
<td>33</td>
<td>86</td>
<td>67</td>
<td>8</td>
<td>67634</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/3935007" alt=""></td>
<td><a href="https://github.com/ojengwa" target="_blank" rel="external">https://github.com/ojengwa</a></td>
<td>293</td>
<td>469</td>
<td>67</td>
<td>8</td>
<td>49621</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/10103766" alt=""></td>
<td><a href="https://github.com/SergioChan" target="_blank" rel="external">https://github.com/SergioChan</a></td>
<td>47</td>
<td>372</td>
<td>982</td>
<td>598</td>
<td>42202</td>
</tr>
</tbody>
</table>
<p>365天，天天绿是种怎样的体验？</p>
<h3 id="中国用户榜单"><a href="#中国用户榜单" class="headerlink" title="中国用户榜单"></a>中国用户榜单</h3><p>这里只是通过location中”China”、”Shanghai”类似的关键词对中国用户进行区分，所以可能有遗漏的地方，还请谅解。此次统计的中国用户数据有18011</p>
<h4 id="Followers人数榜-1"><a href="#Followers人数榜-1" class="headerlink" title="Followers人数榜"></a>Followers人数榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/905434" alt=""></td>
<td><a href="https://github.com/ruanyf" target="_blank" rel="external">https://github.com/ruanyf</a></td>
<td>48</td>
<td>206</td>
<td>38200</td>
<td>0</td>
<td>1645</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/499550" alt=""></td>
<td><a href="https://github.com/yyx990803" target="_blank" rel="external">https://github.com/yyx990803</a></td>
<td>141</td>
<td>779</td>
<td>29200</td>
<td>90</td>
<td>2553</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/2503423" alt=""></td>
<td><a href="https://github.com/daimajia" target="_blank" rel="external">https://github.com/daimajia</a></td>
<td>63</td>
<td>2900</td>
<td>20000</td>
<td>241</td>
<td>21</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/470058" alt=""></td>
<td><a href="https://github.com/michaelliao" target="_blank" rel="external">https://github.com/michaelliao</a></td>
<td>61</td>
<td>81</td>
<td>19700</td>
<td>0</td>
<td>297</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/327019" alt=""></td>
<td><a href="https://github.com/JacksonTian" target="_blank" rel="external">https://github.com/JacksonTian</a></td>
<td>229</td>
<td>583</td>
<td>15500</td>
<td>151</td>
<td>805</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/1169522" alt=""></td>
<td><a href="https://github.com/Trinea" target="_blank" rel="external">https://github.com/Trinea</a></td>
<td>24</td>
<td>1500</td>
<td>14100</td>
<td>38</td>
<td>80</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/2267900" alt=""></td>
<td><a href="https://github.com/stormzhang" target="_blank" rel="external">https://github.com/stormzhang</a></td>
<td>5</td>
<td>1500</td>
<td>12800</td>
<td>91</td>
<td>9</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/97227" alt=""></td>
<td><a href="https://github.com/lifesinger" target="_blank" rel="external">https://github.com/lifesinger</a></td>
<td>2</td>
<td>278</td>
<td>12000</td>
<td>13</td>
<td>1</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/729648" alt=""></td>
<td><a href="https://github.com/cloudwu" target="_blank" rel="external">https://github.com/cloudwu</a></td>
<td>102</td>
<td>63</td>
<td>11700</td>
<td>1</td>
<td>690</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/472311" alt=""></td>
<td><a href="https://github.com/phodal" target="_blank" rel="external">https://github.com/phodal</a></td>
<td>254</td>
<td>1700</td>
<td>11100</td>
<td>15</td>
<td>5924</td>
</tr>
</tbody>
</table>
<h4 id="Following人数榜-1"><a href="#Following人数榜-1" class="headerlink" title="Following人数榜"></a>Following人数榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/3693121" alt=""></td>
<td><a href="https://github.com/fordream" target="_blank" rel="external">https://github.com/fordream</a></td>
<td>724</td>
<td>21</td>
<td>919</td>
<td>19800</td>
<td>1</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/17972943" alt=""></td>
<td><a href="https://github.com/Vermisse" target="_blank" rel="external">https://github.com/Vermisse</a></td>
<td>15</td>
<td>25</td>
<td>2300</td>
<td>10400</td>
<td>102</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/93859" alt=""></td>
<td><a href="https://github.com/technologiclee" target="_blank" rel="external">https://github.com/technologiclee</a></td>
<td>149</td>
<td>844</td>
<td>374</td>
<td>9500</td>
<td>6</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/15626022" alt=""></td>
<td><a href="https://github.com/shenzhoudance" target="_blank" rel="external">https://github.com/shenzhoudance</a></td>
<td>599</td>
<td>6</td>
<td>108</td>
<td>7700</td>
<td>2373</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/10573715" alt=""></td>
<td><a href="https://github.com/kotobukki" target="_blank" rel="external">https://github.com/kotobukki</a></td>
<td>15</td>
<td>68</td>
<td>111</td>
<td>7500</td>
<td>889</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/29220207" alt=""></td>
<td><a href="https://github.com/vincentpanqi" target="_blank" rel="external">https://github.com/vincentpanqi</a></td>
<td>1800</td>
<td>714</td>
<td>47</td>
<td>5600</td>
<td>102</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/1727724" alt=""></td>
<td><a href="https://github.com/ovwane" target="_blank" rel="external">https://github.com/ovwane</a></td>
<td>220</td>
<td>1100</td>
<td>120</td>
<td>5500</td>
<td>329</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/9153294" alt=""></td>
<td><a href="https://github.com/pisual" target="_blank" rel="external">https://github.com/pisual</a></td>
<td>39</td>
<td>62</td>
<td>917</td>
<td>4900</td>
<td>122</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/23236638" alt=""></td>
<td><a href="https://github.com/youkaichao" target="_blank" rel="external">https://github.com/youkaichao</a></td>
<td>39</td>
<td>0</td>
<td>58</td>
<td>4800</td>
<td>113</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/7576876" alt=""></td>
<td><a href="https://github.com/bloodycoder" target="_blank" rel="external">https://github.com/bloodycoder</a></td>
<td>73</td>
<td>34</td>
<td>162</td>
<td>4200</td>
<td>390</td>
</tr>
</tbody>
</table>
<h4 id="Stars榜-1"><a href="#Stars榜-1" class="headerlink" title="Stars榜"></a>Stars榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1041542" alt=""></td>
<td><a href="https://github.com/weimingtom" target="_blank" rel="external">https://github.com/weimingtom</a></td>
<td>2100</td>
<td>9100</td>
<td>172</td>
<td>1800</td>
<td>1724</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/2041398" alt=""></td>
<td><a href="https://github.com/jiangplus" target="_blank" rel="external">https://github.com/jiangplus</a></td>
<td>28</td>
<td>8800</td>
<td>85</td>
<td>115</td>
<td>13</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1024948" alt=""></td>
<td><a href="https://github.com/DavidAlphaFox" target="_blank" rel="external">https://github.com/DavidAlphaFox</a></td>
<td>346</td>
<td>7800</td>
<td>167</td>
<td>83</td>
<td>1122</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/480859" alt=""></td>
<td><a href="https://github.com/mayulu" target="_blank" rel="external">https://github.com/mayulu</a></td>
<td>12</td>
<td>7700</td>
<td>133</td>
<td>616</td>
<td>14</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/4370703" alt=""></td>
<td><a href="https://github.com/hzy87email" target="_blank" rel="external">https://github.com/hzy87email</a></td>
<td>73</td>
<td>7700</td>
<td>77</td>
<td>167</td>
<td>3</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1468284" alt=""></td>
<td><a href="https://github.com/se77en" target="_blank" rel="external">https://github.com/se77en</a></td>
<td>197</td>
<td>7600</td>
<td>119</td>
<td>455</td>
<td>0</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/12030169" alt=""></td>
<td><a href="https://github.com/JaredYeDH" target="_blank" rel="external">https://github.com/JaredYeDH</a></td>
<td>166</td>
<td>7400</td>
<td>45</td>
<td>636</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/10380759" alt=""></td>
<td><a href="https://github.com/xhs" target="_blank" rel="external">https://github.com/xhs</a></td>
<td>20</td>
<td>7200</td>
<td>43</td>
<td>119</td>
<td>10</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/1881113" alt=""></td>
<td><a href="https://github.com/paladin74" target="_blank" rel="external">https://github.com/paladin74</a></td>
<td>618</td>
<td>7100</td>
<td>52</td>
<td>901</td>
<td>1</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/3856" alt=""></td>
<td><a href="https://github.com/mrluanma" target="_blank" rel="external">https://github.com/mrluanma</a></td>
<td>12</td>
<td>7000</td>
<td>126</td>
<td>541</td>
<td>36</td>
</tr>
</tbody>
</table>
<h4 id="Reps榜-1"><a href="#Reps榜-1" class="headerlink" title="Reps榜"></a>Reps榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/10938976" alt=""></td>
<td><a href="https://github.com/skyformat99" target="_blank" rel="external">https://github.com/skyformat99</a></td>
<td>6000</td>
<td>143</td>
<td>98</td>
<td>3200</td>
<td>134</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/1203820" alt=""></td>
<td><a href="https://github.com/tempbottle" target="_blank" rel="external">https://github.com/tempbottle</a></td>
<td>4200</td>
<td>59</td>
<td>21</td>
<td>18</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/8662447" alt=""></td>
<td><a href="https://github.com/JamesLinus" target="_blank" rel="external">https://github.com/JamesLinus</a></td>
<td>4100</td>
<td>1600</td>
<td>89</td>
<td>3300</td>
<td>181</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/12955801" alt=""></td>
<td><a href="https://github.com/hu19891110" target="_blank" rel="external">https://github.com/hu19891110</a></td>
<td>3600</td>
<td>90</td>
<td>11</td>
<td>112</td>
<td>107</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/452743" alt=""></td>
<td><a href="https://github.com/WilliamRen" target="_blank" rel="external">https://github.com/WilliamRen</a></td>
<td>2900</td>
<td>3200</td>
<td>32</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/3414057" alt=""></td>
<td><a href="https://github.com/chagge" target="_blank" rel="external">https://github.com/chagge</a></td>
<td>2300</td>
<td>8</td>
<td>16</td>
<td>669</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/6813552" alt=""></td>
<td><a href="https://github.com/forging2012" target="_blank" rel="external">https://github.com/forging2012</a></td>
<td>2200</td>
<td>789</td>
<td>8</td>
<td>71</td>
<td>151</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1041542" alt=""></td>
<td><a href="https://github.com/weimingtom" target="_blank" rel="external">https://github.com/weimingtom</a></td>
<td>2100</td>
<td>9100</td>
<td>172</td>
<td>1800</td>
<td>1724</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/23429527" alt=""></td>
<td><a href="https://github.com/isuhao" target="_blank" rel="external">https://github.com/isuhao</a></td>
<td>2000</td>
<td>153</td>
<td>62</td>
<td>2700</td>
<td>282</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/5791117" alt=""></td>
<td><a href="https://github.com/ycaihua" target="_blank" rel="external">https://github.com/ycaihua</a></td>
<td>1900</td>
<td>109</td>
<td>38</td>
<td>589</td>
<td>133</td>
</tr>
</tbody>
</table>
<h4 id="Contribution榜-1"><a href="#Contribution榜-1" class="headerlink" title="Contribution榜"></a>Contribution榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1006477" alt=""></td>
<td><a href="https://github.com/felixonmars" target="_blank" rel="external">https://github.com/felixonmars</a></td>
<td>420</td>
<td>369</td>
<td>806</td>
<td>149</td>
<td>70179</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/10103766" alt=""></td>
<td><a href="https://github.com/SergioChan" target="_blank" rel="external">https://github.com/SergioChan</a></td>
<td>47</td>
<td>372</td>
<td>982</td>
<td>598</td>
<td>42202</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/12693644" alt=""></td>
<td><a href="https://github.com/dragon-yuan" target="_blank" rel="external">https://github.com/dragon-yuan</a></td>
<td>16</td>
<td>109</td>
<td>35</td>
<td>50</td>
<td>18591</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/8347202" alt=""></td>
<td><a href="https://github.com/fengss" target="_blank" rel="external">https://github.com/fengss</a></td>
<td>30</td>
<td>67</td>
<td>15</td>
<td>1</td>
<td>12560</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/9410171" alt=""></td>
<td><a href="https://github.com/xieguigang" target="_blank" rel="external">https://github.com/xieguigang</a></td>
<td>41</td>
<td>115</td>
<td>136</td>
<td>143</td>
<td>10999</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/9280577" alt=""></td>
<td><a href="https://github.com/csjunxu" target="_blank" rel="external">https://github.com/csjunxu</a></td>
<td>194</td>
<td>81</td>
<td>35</td>
<td>51</td>
<td>9935</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/559179" alt=""></td>
<td><a href="https://github.com/airyland" target="_blank" rel="external">https://github.com/airyland</a></td>
<td>183</td>
<td>1400</td>
<td>996</td>
<td>175</td>
<td>8852</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/11537812" alt=""></td>
<td><a href="https://github.com/yutiansut" target="_blank" rel="external">https://github.com/yutiansut</a></td>
<td>216</td>
<td>1100</td>
<td>298</td>
<td>8</td>
<td>7311</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/1826685" alt=""></td>
<td><a href="https://github.com/lloydzhou" target="_blank" rel="external">https://github.com/lloydzhou</a></td>
<td>92</td>
<td>556</td>
<td>52</td>
<td>69</td>
<td>6729</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/8784712" alt=""></td>
<td><a href="https://github.com/egoist" target="_blank" rel="external">https://github.com/egoist</a></td>
<td>647</td>
<td>2700</td>
<td>3600</td>
<td>40</td>
<td>6236</td>
</tr>
</tbody>
</table>
<h3 id="个人网站中顶级域名分布情况"><a href="#个人网站中顶级域名分布情况" class="headerlink" title="个人网站中顶级域名分布情况"></a>个人网站中顶级域名分布情况</h3><p><img src="https://data2.liuin.cn/2018-04-01-15225621477939.jpg" alt=""></p>
<h3 id="用户公布邮箱情况"><a href="#用户公布邮箱情况" class="headerlink" title="用户公布邮箱情况"></a>用户公布邮箱情况</h3><p><img src="https://data2.liuin.cn/2018-04-01-15225624252077.jpg" alt=""></p>
<h3 id="用户所在公司情况"><a href="#用户所在公司情况" class="headerlink" title="用户所在公司情况"></a>用户所在公司情况</h3><p>公布公司的前8</p>
<p><img src="https://data2.liuin.cn/2018-04-01-15225631364406.jpg" alt=""></p>
<p>云图</p>
<p><img src="https://data2.liuin.cn/2018-04-01-15225635127953.jpg" alt=""></p>
<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><h3 id="Stars榜-2"><a href="#Stars榜-2" class="headerlink" title="Stars榜"></a>Stars榜</h3><table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/freeCodeCamp/freeCodeCamp" target="_blank" rel="external">freeCodeCamp/freeCodeCamp</a></td>
<td><a href="https://github.com/freeCodeCamp" target="_blank" rel="external">freeCodeCamp</a></td>
<td>JavaScript</td>
<td>291895</td>
<td>13667</td>
<td>11334</td>
</tr>
<tr>
<td><a href="https://github.com/twbs/bootstrap" target="_blank" rel="external">twbs/bootstrap</a></td>
<td><a href="https://github.com/twbs" target="_blank" rel="external">twbs</a></td>
<td>CSS</td>
<td>123341</td>
<td>58717</td>
<td>17645</td>
</tr>
<tr>
<td><a href="https://github.com/EbookFoundation/free-programming-books" target="_blank" rel="external">EbookFoundation/free-programming-books</a></td>
<td><a href="https://github.com/EbookFoundation" target="_blank" rel="external">EbookFoundation</a></td>
<td></td>
<td>103480</td>
<td>26331</td>
<td>4634</td>
</tr>
<tr>
<td><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">tensorflow/tensorflow</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>C++</td>
<td>95028</td>
<td>60694</td>
<td>30887</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/react" target="_blank" rel="external">facebook/react</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>92602</td>
<td>17473</td>
<td>9773</td>
</tr>
<tr>
<td><a href="https://github.com/vuejs/vue" target="_blank" rel="external">vuejs/vue</a></td>
<td><a href="https://github.com/vuejs" target="_blank" rel="external">vuejs</a></td>
<td>JavaScript</td>
<td>89447</td>
<td>13129</td>
<td>2581</td>
</tr>
<tr>
<td><a href="https://github.com/sindresorhus/awesome" target="_blank" rel="external">sindresorhus/awesome</a></td>
<td><a href="https://github.com/sindresorhus" target="_blank" rel="external">sindresorhus</a></td>
<td></td>
<td>82141</td>
<td>10785</td>
<td>725</td>
</tr>
<tr>
<td><a href="https://github.com/getify/You-Dont-Know-JS" target="_blank" rel="external">getify/You-Dont-Know-JS</a></td>
<td><a href="https://github.com/getify" target="_blank" rel="external">getify</a></td>
<td></td>
<td>78848</td>
<td>14404</td>
<td>1465</td>
</tr>
<tr>
<td><a href="https://github.com/d3/d3" target="_blank" rel="external">d3/d3</a></td>
<td><a href="https://github.com/d3" target="_blank" rel="external">d3</a></td>
<td>JavaScript</td>
<td>74472</td>
<td>19024</td>
<td>4132</td>
</tr>
<tr>
<td><a href="https://github.com/airbnb/javascript" target="_blank" rel="external">airbnb/javascript</a></td>
<td><a href="https://github.com/airbnb" target="_blank" rel="external">airbnb</a></td>
<td>JavaScript</td>
<td>68833</td>
<td>13127</td>
<td>1607</td>
</tr>
</tbody>
</table>
<h3 id="Forks榜"><a href="#Forks榜" class="headerlink" title="Forks榜"></a>Forks榜</h3><table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/jtleek/datasharing" target="_blank" rel="external">jtleek/datasharing</a></td>
<td><a href="https://github.com/jtleek" target="_blank" rel="external">jtleek</a></td>
<td></td>
<td>4332</td>
<td>184409</td>
<td>29</td>
</tr>
<tr>
<td><a href="https://github.com/rdpeng/ProgrammingAssignment2" target="_blank" rel="external">rdpeng/ProgrammingAssignment2</a></td>
<td><a href="https://github.com/rdpeng" target="_blank" rel="external">rdpeng</a></td>
<td>R</td>
<td>528</td>
<td>110145</td>
<td>7</td>
</tr>
<tr>
<td><a href="https://github.com/octocat/Spoon-Knife" target="_blank" rel="external">octocat/Spoon-Knife</a></td>
<td><a href="https://github.com/octocat" target="_blank" rel="external">octocat</a></td>
<td>HTML</td>
<td>10043</td>
<td>97471</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">tensorflow/tensorflow</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>C++</td>
<td>95028</td>
<td>60694</td>
<td>30887</td>
</tr>
<tr>
<td><a href="https://github.com/twbs/bootstrap" target="_blank" rel="external">twbs/bootstrap</a></td>
<td><a href="https://github.com/twbs" target="_blank" rel="external">twbs</a></td>
<td>CSS</td>
<td>123341</td>
<td>58717</td>
<td>17645</td>
</tr>
<tr>
<td><a href="https://github.com/SmartThingsCommunity/SmartThingsPublic" target="_blank" rel="external">SmartThingsCommunity/SmartThingsPublic</a></td>
<td><a href="https://github.com/SmartThingsCommunity" target="_blank" rel="external">SmartThingsCommunity</a></td>
<td>Groovy</td>
<td>853</td>
<td>38018</td>
<td>2448</td>
</tr>
<tr>
<td><a href="https://github.com/rdpeng/RepData_PeerAssessment1" target="_blank" rel="external">rdpeng/RepData_PeerAssessment1</a></td>
<td><a href="https://github.com/rdpeng" target="_blank" rel="external">rdpeng</a></td>
<td></td>
<td>69</td>
<td>29883</td>
<td>13</td>
</tr>
<tr>
<td><a href="https://github.com/github/gitignore" target="_blank" rel="external">github/gitignore</a></td>
<td><a href="https://github.com/github" target="_blank" rel="external">github</a></td>
<td></td>
<td>63853</td>
<td>29259</td>
<td>2738</td>
</tr>
<tr>
<td><a href="https://github.com/angular/angular.js" target="_blank" rel="external">angular/angular.js</a></td>
<td><a href="https://github.com/angular" target="_blank" rel="external">angular</a></td>
<td>JavaScript</td>
<td>58232</td>
<td>28872</td>
<td>8755</td>
</tr>
<tr>
<td><a href="https://github.com/EbookFoundation/free-programming-books" target="_blank" rel="external">EbookFoundation/free-programming-books</a></td>
<td><a href="https://github.com/EbookFoundation" target="_blank" rel="external">EbookFoundation</a></td>
<td></td>
<td>103480</td>
<td>26331</td>
<td>4634</td>
</tr>
</tbody>
</table>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>stars排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/torvalds/linux" target="_blank" rel="external">torvalds/linux</a></td>
<td><a href="https://github.com/torvalds" target="_blank" rel="external">torvalds</a></td>
<td>C</td>
<td>57191</td>
<td>21032</td>
<td>744803</td>
</tr>
<tr>
<td><a href="https://github.com/firehol/netdata" target="_blank" rel="external">firehol/netdata</a></td>
<td><a href="https://github.com/firehol" target="_blank" rel="external">firehol</a></td>
<td>C</td>
<td>28607</td>
<td>2389</td>
<td>6690</td>
</tr>
<tr>
<td><a href="https://github.com/antirez/redis" target="_blank" rel="external">antirez/redis</a></td>
<td><a href="https://github.com/antirez" target="_blank" rel="external">antirez</a></td>
<td>C</td>
<td>28340</td>
<td>10916</td>
<td>6679</td>
</tr>
<tr>
<td><a href="https://github.com/git/git" target="_blank" rel="external">git/git</a></td>
<td><a href="https://github.com/git" target="_blank" rel="external">git</a></td>
<td>C</td>
<td>21665</td>
<td>12634</td>
<td>50674</td>
</tr>
<tr>
<td><a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="external">Bilibili/ijkplayer</a></td>
<td><a href="https://github.com/Bilibili" target="_blank" rel="external">Bilibili</a></td>
<td>C</td>
<td>18374</td>
<td>5191</td>
<td>2584</td>
</tr>
<tr>
<td><a href="https://github.com/php/php-src" target="_blank" rel="external">php/php-src</a></td>
<td><a href="https://github.com/php" target="_blank" rel="external">php</a></td>
<td>C</td>
<td>16996</td>
<td>4745</td>
<td>107206</td>
</tr>
<tr>
<td><a href="https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System" target="_blank" rel="external">SamyPesse/How-to-Make-a-Computer-Operating-System</a></td>
<td><a href="https://github.com/SamyPesse" target="_blank" rel="external">SamyPesse</a></td>
<td>C</td>
<td>16957</td>
<td>3015</td>
<td>243</td>
</tr>
<tr>
<td><a href="https://github.com/wg/wrk" target="_blank" rel="external">wg/wrk</a></td>
<td><a href="https://github.com/wg" target="_blank" rel="external">wg</a></td>
<td>C</td>
<td>15386</td>
<td>1245</td>
<td>72</td>
</tr>
<tr>
<td><a href="https://github.com/ggreer/the_silver_searcher" target="_blank" rel="external">ggreer/the_silver_searcher</a></td>
<td><a href="https://github.com/ggreer" target="_blank" rel="external">ggreer</a></td>
<td>C</td>
<td>14854</td>
<td>954</td>
<td>1974</td>
</tr>
<tr>
<td><a href="https://github.com/kripken/emscripten" target="_blank" rel="external">kripken/emscripten</a></td>
<td><a href="https://github.com/kripken" target="_blank" rel="external">kripken</a></td>
<td>C</td>
<td>14373</td>
<td>1704</td>
<td>18154</td>
</tr>
</tbody>
</table>
<p>forks排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/torvalds/linux" target="_blank" rel="external">torvalds/linux</a></td>
<td><a href="https://github.com/torvalds" target="_blank" rel="external">torvalds</a></td>
<td>C</td>
<td>57191</td>
<td>21032</td>
<td>744803</td>
</tr>
<tr>
<td><a href="https://github.com/git/git" target="_blank" rel="external">git/git</a></td>
<td><a href="https://github.com/git" target="_blank" rel="external">git</a></td>
<td>C</td>
<td>21665</td>
<td>12634</td>
<td>50674</td>
</tr>
<tr>
<td><a href="https://github.com/antirez/redis" target="_blank" rel="external">antirez/redis</a></td>
<td><a href="https://github.com/antirez" target="_blank" rel="external">antirez</a></td>
<td>C</td>
<td>28340</td>
<td>10916</td>
<td>6679</td>
</tr>
<tr>
<td><a href="https://github.com/arduino/Arduino" target="_blank" rel="external">arduino/Arduino</a></td>
<td><a href="https://github.com/arduino" target="_blank" rel="external">arduino</a></td>
<td>C</td>
<td>7936</td>
<td>6184</td>
<td>6649</td>
</tr>
<tr>
<td><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July" target="_blank" rel="external">julycoding/The-Art-Of-Programming-By-July</a></td>
<td><a href="https://github.com/julycoding" target="_blank" rel="external">julycoding</a></td>
<td>C</td>
<td>13544</td>
<td>5666</td>
<td>3630</td>
</tr>
<tr>
<td><a href="https://github.com/MarlinFirmware/Marlin" target="_blank" rel="external">MarlinFirmware/Marlin</a></td>
<td><a href="https://github.com/MarlinFirmware" target="_blank" rel="external">MarlinFirmware</a></td>
<td>C</td>
<td>3615</td>
<td>5340</td>
<td>9015</td>
</tr>
<tr>
<td><a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="external">Bilibili/ijkplayer</a></td>
<td><a href="https://github.com/Bilibili" target="_blank" rel="external">Bilibili</a></td>
<td>C</td>
<td>18374</td>
<td>5191</td>
<td>2584</td>
</tr>
<tr>
<td><a href="https://github.com/php/php-src" target="_blank" rel="external">php/php-src</a></td>
<td><a href="https://github.com/php" target="_blank" rel="external">php</a></td>
<td>C</td>
<td>16996</td>
<td>4745</td>
<td>107206</td>
</tr>
<tr>
<td><a href="https://github.com/esp8266/Arduino" target="_blank" rel="external">esp8266/Arduino</a></td>
<td><a href="https://github.com/esp8266" target="_blank" rel="external">esp8266</a></td>
<td>C</td>
<td>7063</td>
<td>4378</td>
<td>2697</td>
</tr>
<tr>
<td><a href="https://github.com/FFmpeg/FFmpeg" target="_blank" rel="external">FFmpeg/FFmpeg</a></td>
<td><a href="https://github.com/FFmpeg" target="_blank" rel="external">FFmpeg</a></td>
<td>C</td>
<td>10314</td>
<td>4377</td>
<td>90611</td>
</tr>
</tbody>
</table>
<h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><p>stars排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">tensorflow/tensorflow</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>C++</td>
<td>95028</td>
<td>60694</td>
<td>30887</td>
</tr>
<tr>
<td><a href="https://github.com/electron/electron" target="_blank" rel="external">electron/electron</a></td>
<td><a href="https://github.com/electron" target="_blank" rel="external">electron</a></td>
<td>C++</td>
<td>58531</td>
<td>7642</td>
<td>18669</td>
</tr>
<tr>
<td><a href="https://github.com/apple/swift" target="_blank" rel="external">apple/swift</a></td>
<td><a href="https://github.com/apple" target="_blank" rel="external">apple</a></td>
<td>C++</td>
<td>43250</td>
<td>6795</td>
<td>68510</td>
</tr>
<tr>
<td><a href="https://github.com/nwjs/nw.js" target="_blank" rel="external">nwjs/nw.js</a></td>
<td><a href="https://github.com/nwjs" target="_blank" rel="external">nwjs</a></td>
<td>C++</td>
<td>33478</td>
<td>3731</td>
<td>3188</td>
</tr>
<tr>
<td><a href="https://github.com/x64dbg/x64dbg" target="_blank" rel="external">x64dbg/x64dbg</a></td>
<td><a href="https://github.com/x64dbg" target="_blank" rel="external">x64dbg</a></td>
<td>C++</td>
<td>33242</td>
<td>684</td>
<td>3923</td>
</tr>
<tr>
<td><a href="https://github.com/bitcoin/bitcoin" target="_blank" rel="external">bitcoin/bitcoin</a></td>
<td><a href="https://github.com/bitcoin" target="_blank" rel="external">bitcoin</a></td>
<td>C++</td>
<td>30209</td>
<td>18101</td>
<td>16629</td>
</tr>
<tr>
<td><a href="https://github.com/google/protobuf" target="_blank" rel="external">google/protobuf</a></td>
<td><a href="https://github.com/google" target="_blank" rel="external">google</a></td>
<td>C++</td>
<td>24950</td>
<td>7150</td>
<td>5557</td>
</tr>
<tr>
<td><a href="https://github.com/BVLC/caffe" target="_blank" rel="external">BVLC/caffe</a></td>
<td><a href="https://github.com/BVLC" target="_blank" rel="external">BVLC</a></td>
<td>C++</td>
<td>23550</td>
<td>14390</td>
<td>4118</td>
</tr>
<tr>
<td><a href="https://github.com/opencv/opencv" target="_blank" rel="external">opencv/opencv</a></td>
<td><a href="https://github.com/opencv" target="_blank" rel="external">opencv</a></td>
<td>C++</td>
<td>23493</td>
<td>16901</td>
<td>23654</td>
</tr>
<tr>
<td><a href="https://github.com/rethinkdb/rethinkdb" target="_blank" rel="external">rethinkdb/rethinkdb</a></td>
<td><a href="https://github.com/rethinkdb" target="_blank" rel="external">rethinkdb</a></td>
<td>C++</td>
<td>20993</td>
<td>1665</td>
<td>33382</td>
</tr>
</tbody>
</table>
<p>forks排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">tensorflow/tensorflow</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>C++</td>
<td>95028</td>
<td>60694</td>
<td>30887</td>
</tr>
<tr>
<td><a href="https://github.com/bitcoin/bitcoin" target="_blank" rel="external">bitcoin/bitcoin</a></td>
<td><a href="https://github.com/bitcoin" target="_blank" rel="external">bitcoin</a></td>
<td>C++</td>
<td>30209</td>
<td>18101</td>
<td>16629</td>
</tr>
<tr>
<td><a href="https://github.com/opencv/opencv" target="_blank" rel="external">opencv/opencv</a></td>
<td><a href="https://github.com/opencv" target="_blank" rel="external">opencv</a></td>
<td>C++</td>
<td>23493</td>
<td>16901</td>
<td>23654</td>
</tr>
<tr>
<td><a href="https://github.com/BVLC/caffe" target="_blank" rel="external">BVLC/caffe</a></td>
<td><a href="https://github.com/BVLC" target="_blank" rel="external">BVLC</a></td>
<td>C++</td>
<td>23550</td>
<td>14390</td>
<td>4118</td>
</tr>
<tr>
<td><a href="https://github.com/electron/electron" target="_blank" rel="external">electron/electron</a></td>
<td><a href="https://github.com/electron" target="_blank" rel="external">electron</a></td>
<td>C++</td>
<td>58531</td>
<td>7642</td>
<td>18669</td>
</tr>
<tr>
<td><a href="https://github.com/google/protobuf" target="_blank" rel="external">google/protobuf</a></td>
<td><a href="https://github.com/google" target="_blank" rel="external">google</a></td>
<td>C++</td>
<td>24950</td>
<td>7150</td>
<td>5557</td>
</tr>
<tr>
<td><a href="https://github.com/apple/swift" target="_blank" rel="external">apple/swift</a></td>
<td><a href="https://github.com/apple" target="_blank" rel="external">apple</a></td>
<td>C++</td>
<td>43250</td>
<td>6795</td>
<td>68510</td>
</tr>
<tr>
<td><a href="https://github.com/cocos2d/cocos2d-x" target="_blank" rel="external">cocos2d/cocos2d-x</a></td>
<td><a href="https://github.com/cocos2d" target="_blank" rel="external">cocos2d</a></td>
<td>C++</td>
<td>11759</td>
<td>6496</td>
<td>36641</td>
</tr>
<tr>
<td><a href="https://github.com/ArduPilot/ardupilot" target="_blank" rel="external">ArduPilot/ardupilot</a></td>
<td><a href="https://github.com/ArduPilot" target="_blank" rel="external">ArduPilot</a></td>
<td>C++</td>
<td>3110</td>
<td>6153</td>
<td>31379</td>
</tr>
<tr>
<td><a href="https://github.com/dmlc/xgboost" target="_blank" rel="external">dmlc/xgboost</a></td>
<td><a href="https://github.com/dmlc" target="_blank" rel="external">dmlc</a></td>
<td>C++</td>
<td>11406</td>
<td>5192</td>
<td>3254</td>
</tr>
</tbody>
</table>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>stars排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">ReactiveX/RxJava</a></td>
<td><a href="https://github.com/ReactiveX" target="_blank" rel="external">ReactiveX</a></td>
<td>Java</td>
<td>32001</td>
<td>5594</td>
<td>5328</td>
</tr>
<tr>
<td><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="external">iluwatar/java-design-patterns</a></td>
<td><a href="https://github.com/iluwatar" target="_blank" rel="external">iluwatar</a></td>
<td>Java</td>
<td>31422</td>
<td>10072</td>
<td>2022</td>
</tr>
<tr>
<td><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="external">elastic/elasticsearch</a></td>
<td><a href="https://github.com/elastic" target="_blank" rel="external">elastic</a></td>
<td>Java</td>
<td>29931</td>
<td>10408</td>
<td>30528</td>
</tr>
<tr>
<td><a href="https://github.com/square/retrofit" target="_blank" rel="external">square/retrofit</a></td>
<td><a href="https://github.com/square" target="_blank" rel="external">square</a></td>
<td>Java</td>
<td>27182</td>
<td>5311</td>
<td>1569</td>
</tr>
<tr>
<td><a href="https://github.com/square/okhttp" target="_blank" rel="external">square/okhttp</a></td>
<td><a href="https://github.com/square" target="_blank" rel="external">square</a></td>
<td>Java</td>
<td>25870</td>
<td>6054</td>
<td>3147</td>
</tr>
<tr>
<td><a href="https://github.com/google/guava" target="_blank" rel="external">google/guava</a></td>
<td><a href="https://github.com/google" target="_blank" rel="external">google</a></td>
<td>Java</td>
<td>23154</td>
<td>5323</td>
<td>4676</td>
</tr>
<tr>
<td><a href="https://github.com/spring-projects/spring-boot" target="_blank" rel="external">spring-projects/spring-boot</a></td>
<td><a href="https://github.com/spring-projects" target="_blank" rel="external">spring-projects</a></td>
<td>Java</td>
<td>22927</td>
<td>17555</td>
<td>16129</td>
</tr>
<tr>
<td><a href="https://github.com/PhilJay/MPAndroidChart" target="_blank" rel="external">PhilJay/MPAndroidChart</a></td>
<td><a href="https://github.com/PhilJay" target="_blank" rel="external">PhilJay</a></td>
<td>Java</td>
<td>21393</td>
<td>5939</td>
<td>1938</td>
</tr>
<tr>
<td><a href="https://github.com/kdn251/interviews" target="_blank" rel="external">kdn251/interviews</a></td>
<td><a href="https://github.com/kdn251" target="_blank" rel="external">kdn251</a></td>
<td>Java</td>
<td>21348</td>
<td>3503</td>
<td>370</td>
</tr>
<tr>
<td><a href="https://github.com/bumptech/glide" target="_blank" rel="external">bumptech/glide</a></td>
<td><a href="https://github.com/bumptech" target="_blank" rel="external">bumptech</a></td>
<td>Java</td>
<td>21032</td>
<td>4132</td>
<td>2190</td>
</tr>
</tbody>
</table>
<p>forks排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/spring-projects/spring-boot" target="_blank" rel="external">spring-projects/spring-boot</a></td>
<td><a href="https://github.com/spring-projects" target="_blank" rel="external">spring-projects</a></td>
<td>Java</td>
<td>22927</td>
<td>17555</td>
<td>16129</td>
</tr>
<tr>
<td><a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="external">spring-projects/spring-framework</a></td>
<td><a href="https://github.com/spring-projects" target="_blank" rel="external">spring-projects</a></td>
<td>Java</td>
<td>20126</td>
<td>13328</td>
<td>16384</td>
</tr>
<tr>
<td><a href="https://github.com/apache/incubator-dubbo" target="_blank" rel="external">apache/incubator-dubbo</a></td>
<td><a href="https://github.com/apache" target="_blank" rel="external">apache</a></td>
<td>Java</td>
<td>17706</td>
<td>12714</td>
<td>2201</td>
</tr>
<tr>
<td><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="external">elastic/elasticsearch</a></td>
<td><a href="https://github.com/elastic" target="_blank" rel="external">elastic</a></td>
<td>Java</td>
<td>29931</td>
<td>10408</td>
<td>30528</td>
</tr>
<tr>
<td><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="external">iluwatar/java-design-patterns</a></td>
<td><a href="https://github.com/iluwatar" target="_blank" rel="external">iluwatar</a></td>
<td>Java</td>
<td>31422</td>
<td>10072</td>
<td>2022</td>
</tr>
<tr>
<td><a href="https://github.com/eugenp/tutorials" target="_blank" rel="external">eugenp/tutorials</a></td>
<td><a href="https://github.com/eugenp" target="_blank" rel="external">eugenp</a></td>
<td>Java</td>
<td>4950</td>
<td>8411</td>
<td>7809</td>
</tr>
<tr>
<td><a href="https://github.com/zxing/zxing" target="_blank" rel="external">zxing/zxing</a></td>
<td><a href="https://github.com/zxing" target="_blank" rel="external">zxing</a></td>
<td>Java</td>
<td>18000</td>
<td>7345</td>
<td>3425</td>
</tr>
<tr>
<td><a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="external">nostra13/Android-Universal-Image-Loader</a></td>
<td><a href="https://github.com/nostra13" target="_blank" rel="external">nostra13</a></td>
<td>Java</td>
<td>16040</td>
<td>6476</td>
<td>1025</td>
</tr>
<tr>
<td><a href="https://github.com/checkstyle/checkstyle" target="_blank" rel="external">checkstyle/checkstyle</a></td>
<td><a href="https://github.com/checkstyle" target="_blank" rel="external">checkstyle</a></td>
<td>Java</td>
<td>3597</td>
<td>6402</td>
<td>7658</td>
</tr>
<tr>
<td><a href="https://github.com/netty/netty" target="_blank" rel="external">netty/netty</a></td>
<td><a href="https://github.com/netty" target="_blank" rel="external">netty</a></td>
<td>Java</td>
<td>13422</td>
<td>6122</td>
<td>8723</td>
</tr>
</tbody>
</table>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>stars排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/vinta/awesome-python" target="_blank" rel="external">vinta/awesome-python</a></td>
<td><a href="https://github.com/vinta" target="_blank" rel="external">vinta</a></td>
<td>Python</td>
<td>47930</td>
<td>9270</td>
<td>1222</td>
</tr>
<tr>
<td><a href="https://github.com/rg3/youtube-dl" target="_blank" rel="external">rg3/youtube-dl</a></td>
<td><a href="https://github.com/rg3" target="_blank" rel="external">rg3</a></td>
<td>Python</td>
<td>35575</td>
<td>6532</td>
<td>16048</td>
</tr>
<tr>
<td><a href="https://github.com/toddmotto/public-apis" target="_blank" rel="external">toddmotto/public-apis</a></td>
<td><a href="https://github.com/toddmotto" target="_blank" rel="external">toddmotto</a></td>
<td>Python</td>
<td>35115</td>
<td>3319</td>
<td>1760</td>
</tr>
<tr>
<td><a href="https://github.com/jakubroztocil/httpie" target="_blank" rel="external">jakubroztocil/httpie</a></td>
<td><a href="https://github.com/jakubroztocil" target="_blank" rel="external">jakubroztocil</a></td>
<td>Python</td>
<td>34746</td>
<td>2362</td>
<td>965</td>
</tr>
<tr>
<td><a href="https://github.com/nvbn/thefuck" target="_blank" rel="external">nvbn/thefuck</a></td>
<td><a href="https://github.com/nvbn" target="_blank" rel="external">nvbn</a></td>
<td>Python</td>
<td>34601</td>
<td>1723</td>
<td>1463</td>
</tr>
<tr>
<td><a href="https://github.com/pallets/flask" target="_blank" rel="external">pallets/flask</a></td>
<td><a href="https://github.com/pallets" target="_blank" rel="external">pallets</a></td>
<td>Python</td>
<td>34411</td>
<td>10562</td>
<td>3205</td>
</tr>
<tr>
<td><a href="https://github.com/django/django" target="_blank" rel="external">django/django</a></td>
<td><a href="https://github.com/django" target="_blank" rel="external">django</a></td>
<td>Python</td>
<td>32956</td>
<td>13953</td>
<td>25601</td>
</tr>
<tr>
<td><a href="https://github.com/tensorflow/models" target="_blank" rel="external">tensorflow/models</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>Python</td>
<td>32262</td>
<td>17985</td>
<td>2109</td>
</tr>
<tr>
<td><a href="https://github.com/josephmisiti/awesome-machine-learning" target="_blank" rel="external">josephmisiti/awesome-machine-learning</a></td>
<td><a href="https://github.com/josephmisiti" target="_blank" rel="external">josephmisiti</a></td>
<td>Python</td>
<td>31793</td>
<td>7780</td>
<td>1033</td>
</tr>
<tr>
<td><a href="https://github.com/requests/requests" target="_blank" rel="external">requests/requests</a></td>
<td><a href="https://github.com/requests" target="_blank" rel="external">requests</a></td>
<td>Python</td>
<td>31508</td>
<td>5824</td>
<td>5416</td>
</tr>
</tbody>
</table>
<p>forks排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/tensorflow/models" target="_blank" rel="external">tensorflow/models</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>Python</td>
<td>32262</td>
<td>17985</td>
<td>2109</td>
</tr>
<tr>
<td><a href="https://github.com/shadowsocks/shadowsocks" target="_blank" rel="external">shadowsocks/shadowsocks</a></td>
<td><a href="https://github.com/shadowsocks" target="_blank" rel="external">shadowsocks</a></td>
<td>Python</td>
<td>24278</td>
<td>15499</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://github.com/django/django" target="_blank" rel="external">django/django</a></td>
<td><a href="https://github.com/django" target="_blank" rel="external">django</a></td>
<td>Python</td>
<td>32956</td>
<td>13953</td>
<td>25601</td>
</tr>
<tr>
<td><a href="https://github.com/scikit-learn/scikit-learn" target="_blank" rel="external">scikit-learn/scikit-learn</a></td>
<td><a href="https://github.com/scikit-learn" target="_blank" rel="external">scikit-learn</a></td>
<td>Python</td>
<td>27088</td>
<td>13623</td>
<td>22684</td>
</tr>
<tr>
<td><a href="https://github.com/ansible/ansible" target="_blank" rel="external">ansible/ansible</a></td>
<td><a href="https://github.com/ansible" target="_blank" rel="external">ansible</a></td>
<td>Python</td>
<td>29373</td>
<td>10728</td>
<td>36562</td>
</tr>
<tr>
<td><a href="https://github.com/pallets/flask" target="_blank" rel="external">pallets/flask</a></td>
<td><a href="https://github.com/pallets" target="_blank" rel="external">pallets</a></td>
<td>Python</td>
<td>34411</td>
<td>10562</td>
<td>3205</td>
</tr>
<tr>
<td><a href="https://github.com/keras-team/keras" target="_blank" rel="external">keras-team/keras</a></td>
<td><a href="https://github.com/keras-team" target="_blank" rel="external">keras-team</a></td>
<td>Python</td>
<td>27833</td>
<td>10213</td>
<td>4442</td>
</tr>
<tr>
<td><a href="https://github.com/udacity/fullstack-nanodegree-vm" target="_blank" rel="external">udacity/fullstack-nanodegree-vm</a></td>
<td><a href="https://github.com/udacity" target="_blank" rel="external">udacity</a></td>
<td>Python</td>
<td>202</td>
<td>9370</td>
<td>53</td>
</tr>
<tr>
<td><a href="https://github.com/vinta/awesome-python" target="_blank" rel="external">vinta/awesome-python</a></td>
<td><a href="https://github.com/vinta" target="_blank" rel="external">vinta</a></td>
<td>Python</td>
<td>47930</td>
<td>9270</td>
<td>1222</td>
</tr>
<tr>
<td><a href="https://github.com/odoo/odoo" target="_blank" rel="external">odoo/odoo</a></td>
<td><a href="https://github.com/odoo" target="_blank" rel="external">odoo</a></td>
<td>Python</td>
<td>9200</td>
<td>7889</td>
<td>115520</td>
</tr>
</tbody>
</table>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>stars排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/freeCodeCamp/freeCodeCamp" target="_blank" rel="external">freeCodeCamp/freeCodeCamp</a></td>
<td><a href="https://github.com/freeCodeCamp" target="_blank" rel="external">freeCodeCamp</a></td>
<td>JavaScript</td>
<td>291895</td>
<td>13667</td>
<td>11334</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/react" target="_blank" rel="external">facebook/react</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>92602</td>
<td>17473</td>
<td>9773</td>
</tr>
<tr>
<td><a href="https://github.com/vuejs/vue" target="_blank" rel="external">vuejs/vue</a></td>
<td><a href="https://github.com/vuejs" target="_blank" rel="external">vuejs</a></td>
<td>JavaScript</td>
<td>89447</td>
<td>13129</td>
<td>2581</td>
</tr>
<tr>
<td><a href="https://github.com/d3/d3" target="_blank" rel="external">d3/d3</a></td>
<td><a href="https://github.com/d3" target="_blank" rel="external">d3</a></td>
<td>JavaScript</td>
<td>74472</td>
<td>19024</td>
<td>4132</td>
</tr>
<tr>
<td><a href="https://github.com/airbnb/javascript" target="_blank" rel="external">airbnb/javascript</a></td>
<td><a href="https://github.com/airbnb" target="_blank" rel="external">airbnb</a></td>
<td>JavaScript</td>
<td>68833</td>
<td>13127</td>
<td>1607</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/react-native" target="_blank" rel="external">facebook/react-native</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>62128</td>
<td>14129</td>
<td>13166</td>
</tr>
<tr>
<td><a href="https://github.com/angular/angular.js" target="_blank" rel="external">angular/angular.js</a></td>
<td><a href="https://github.com/angular" target="_blank" rel="external">angular</a></td>
<td>JavaScript</td>
<td>58232</td>
<td>28872</td>
<td>8755</td>
</tr>
<tr>
<td><a href="https://github.com/jquery/jquery" target="_blank" rel="external">jquery/jquery</a></td>
<td><a href="https://github.com/jquery" target="_blank" rel="external">jquery</a></td>
<td>JavaScript</td>
<td>48560</td>
<td>15318</td>
<td>6316</td>
</tr>
<tr>
<td><a href="https://github.com/nodejs/node" target="_blank" rel="external">nodejs/node</a></td>
<td><a href="https://github.com/nodejs" target="_blank" rel="external">nodejs</a></td>
<td>JavaScript</td>
<td>47212</td>
<td>9904</td>
<td>21744</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/create-react-app" target="_blank" rel="external">facebook/create-react-app</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>46391</td>
<td>9259</td>
<td>1484</td>
</tr>
</tbody>
</table>
<p>forks排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/angular/angular.js" target="_blank" rel="external">angular/angular.js</a></td>
<td><a href="https://github.com/angular" target="_blank" rel="external">angular</a></td>
<td>JavaScript</td>
<td>58232</td>
<td>28872</td>
<td>8755</td>
</tr>
<tr>
<td><a href="https://github.com/udacity/frontend-nanodegree-resume" target="_blank" rel="external">udacity/frontend-nanodegree-resume</a></td>
<td><a href="https://github.com/udacity" target="_blank" rel="external">udacity</a></td>
<td>JavaScript</td>
<td>915</td>
<td>25814</td>
<td>84</td>
</tr>
<tr>
<td><a href="https://github.com/d3/d3" target="_blank" rel="external">d3/d3</a></td>
<td><a href="https://github.com/d3" target="_blank" rel="external">d3</a></td>
<td>JavaScript</td>
<td>74472</td>
<td>19024</td>
<td>4132</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/react" target="_blank" rel="external">facebook/react</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>92602</td>
<td>17473</td>
<td>9773</td>
</tr>
<tr>
<td><a href="https://github.com/jquery/jquery" target="_blank" rel="external">jquery/jquery</a></td>
<td><a href="https://github.com/jquery" target="_blank" rel="external">jquery</a></td>
<td>JavaScript</td>
<td>48560</td>
<td>15318</td>
<td>6316</td>
</tr>
<tr>
<td><a href="https://github.com/nightscout/cgm-remote-monitor" target="_blank" rel="external">nightscout/cgm-remote-monitor</a></td>
<td><a href="https://github.com/nightscout" target="_blank" rel="external">nightscout</a></td>
<td>JavaScript</td>
<td>439</td>
<td>15228</td>
<td>4505</td>
</tr>
<tr>
<td><a href="https://github.com/mrdoob/three.js" target="_blank" rel="external">mrdoob/three.js</a></td>
<td><a href="https://github.com/mrdoob" target="_blank" rel="external">mrdoob</a></td>
<td>JavaScript</td>
<td>40668</td>
<td>15152</td>
<td>22927</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/react-native" target="_blank" rel="external">facebook/react-native</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>62128</td>
<td>14129</td>
<td>13166</td>
</tr>
<tr>
<td><a href="https://github.com/freeCodeCamp/freeCodeCamp" target="_blank" rel="external">freeCodeCamp/freeCodeCamp</a></td>
<td><a href="https://github.com/freeCodeCamp" target="_blank" rel="external">freeCodeCamp</a></td>
<td>JavaScript</td>
<td>291895</td>
<td>13667</td>
<td>11334</td>
</tr>
<tr>
<td><a href="https://github.com/vuejs/vue" target="_blank" rel="external">vuejs/vue</a></td>
<td><a href="https://github.com/vuejs" target="_blank" rel="external">vuejs</a></td>
<td>JavaScript</td>
<td>89447</td>
<td>13129</td>
<td>2581</td>
</tr>
</tbody>
</table>
<h3 id="语言使用比例"><a href="#语言使用比例" class="headerlink" title="语言使用比例"></a>语言使用比例</h3><p>stars 超过100的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229847469176.jpg" alt=""></p>
<p>stars 超过1000的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229848318605.jpg" alt=""></p>
<p>stars 超过10000的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229848710272.jpg" alt=""></p>
<p>forks 超过100的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229849187089.jpg" alt=""></p>
<p>forks 超过1000的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229849529776.jpg" alt=""></p>
<p>forks 超过10000的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229849860861.jpg" alt=""></p>
<p>欢迎大家Star我的<a href="https://github.com/Sixzeroo/GithubCrawler" target="_blank" rel="external">Github项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对Github分布式爬虫爬取的20w用户信息和40w仓库信息进行简单的分析和统计&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.liuin.cn/categories/python/"/>
    
    
      <category term="python" scheme="https://www.liuin.cn/tags/python/"/>
    
      <category term="爬虫" scheme="https://www.liuin.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Github分布式爬虫——实现</title>
    <link href="https://www.liuin.cn/2018/04/05/Github%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.liuin.cn/2018/04/05/Github分布式爬虫——实现/</id>
    <published>2018-04-05T11:40:54.000Z</published>
    <updated>2018-04-07T01:54:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用Redis实现分布式爬虫</p>
<a id="more"></a>
<p>主要使用Scrapy、Redis、MongoDB实现，Scrapy作为异步爬虫框架、Redis实现分布式以及Cookies池的存储，MongoDB实现底层数据存储</p>
<h2 id="分布式示意图"><a href="#分布式示意图" class="headerlink" title="分布式示意图"></a>分布式示意图</h2><p><img src="https://data2.liuin.cn/2018-03-25-15219437958574.jpg" alt=""></p>
<p>主机中安装Redis和MongoDB</p>
<p>Redis中存储：</p>
<ul>
<li>所有Scrapy爬虫的待爬取队列</li>
<li>去重用的已发出Request指纹</li>
</ul>
<p>MongoDB负责最终数据的存储</p>
<p>可创建多个Scrapy从机进行爬取，实现分布式。</p>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul>
<li>共享爬取队列实现分布式</li>
<li>生成Request的指纹实现分布式的去重</li>
<li>随机指定User-Agent</li>
<li>通过Redis实现Cookies池并进行更新</li>
</ul>
<h2 id="分布式实现"><a href="#分布式实现" class="headerlink" title="分布式实现"></a>分布式实现</h2><h3 id="请求队列"><a href="#请求队列" class="headerlink" title="请求队列"></a>请求队列</h3><p>各个分布式爬虫共同维护一个Request请求队列，使用的是Redis的list。队列可以实现FIFO，LIFO或者优先级队列。</p>
<p>爬取的时候一开始使用的是优先级队列，但是后来因为不好设置优先级，导致最后都是User的item，导致Rep的饥饿现象，所以到后面换成FIFO队列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FifoQueue</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="string">"""Per-spider FIFO queue"""</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""Return the length of the queue"""</span></div><div class="line">        <span class="keyword">return</span> self.server.llen(self.key)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, request)</span>:</span></div><div class="line">        <span class="string">"""Push a request"""</span></div><div class="line">        self.server.lpush(self.key, self._encode_request(request))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self, timeout=<span class="number">0</span>)</span>:</span></div><div class="line">        <span class="string">"""Pop a request"""</span></div><div class="line">        <span class="keyword">if</span> timeout &gt; <span class="number">0</span>:</div><div class="line">            data = self.server.brpop(self.key, timeout)</div><div class="line">            <span class="keyword">if</span> isinstance(data, tuple):</div><div class="line">                data = data[<span class="number">1</span>]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            data = self.server.rpop(self.key)</div><div class="line">        <span class="keyword">if</span> data:</div><div class="line">            <span class="keyword">return</span> self._decode_request(data)</div></pre></td></tr></table></figure>
<p>同时需要设置request队列的大小限制，因为爬取Github页面的时候可能爬取一个star列表以后就会产生几十个Request，这样很容易把Redis的队列挤爆：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">enqueue_request</span><span class="params">(self, request)</span>:</span></div><div class="line">    <span class="comment"># set upper limit of request num</span></div><div class="line">    <span class="keyword">if</span> len(self.queue) &gt; REQUEST_NUM:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.dont_filter <span class="keyword">and</span> self.df.request_seen(request):</div><div class="line">        self.df.log(request, self.spider)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">if</span> self.stats:</div><div class="line">        self.stats.inc_value(<span class="string">'scheduler/enqueued/redis'</span>, spider=self.spider)</div><div class="line">    self.queue.push(request)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>没有设置数量大小的时候，1G内存的主机跑一个多小时之后就挂掉了：</p>
<p><img src="https://data2.liuin.cn/2018-03-21-15215617499559.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-20-15215615819339.jpg" alt=""></p>
<h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><p>为了使用共同的请求队列，所以需要重写Scheduler，重写的Scheduler负责把要爬取的request放入队列以及从队列中找出request进行爬取</p>
<h3 id="去重集合"><a href="#去重集合" class="headerlink" title="去重集合"></a>去重集合</h3><p>本地爬虫通常需要解决一个去重问题，通常使用的是数据库查询，爬取之前判断url是否请求过。分布式爬虫就是在这个的基础上共用一个去重集合，使用的是Redis的set。</p>
<p>判断一个Request是否已经爬取过，这里不是使用url，因为不同的url可能代表的是同一种资源，比如：<code>http://www.example.com/query?cat=222&amp;id=111</code>和<code>http://www.example.com/query?cat=222&amp;id=111</code> 事实表示的是一个东西。此外，发出的Request还可能与当时的Cookie有关，因为里面还会有用户信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 计算Request指纹判断有没有重复</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_seen</span><span class="params">(self, request)</span>:</span></div><div class="line">    fp = self.request_fingerprint(request)</div><div class="line">    <span class="keyword">if</span> USEBLOOMFILTER == <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">if</span> self.bf.isContains(fp):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.bf.insert(fp)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="comment"># This returns the number of values added, zero if already exists.</span></div><div class="line">        added = self.server.sadd(self.key, fp)</div><div class="line">        <span class="keyword">return</span> added == <span class="number">0</span></div></pre></td></tr></table></figure>
<p>这里采用的方案是生成一个Request的指纹，实际上是把request的url，method和指定的header使用sha1算法得到一个hash值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Request 指纹计算方法</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_fingerprint</span><span class="params">(request, include_headers=None)</span>:</span></div><div class="line">    <span class="keyword">if</span> include_headers:</div><div class="line">        include_headers = tuple(to_bytes(h.lower())</div><div class="line">                                 <span class="keyword">for</span> h <span class="keyword">in</span> sorted(include_headers))</div><div class="line">    cache = _fingerprint_cache.setdefault(request, &#123;&#125;)</div><div class="line">    <span class="keyword">if</span> include_headers <span class="keyword">not</span> <span class="keyword">in</span> cache:</div><div class="line">        fp = hashlib.sha1()</div><div class="line">        fp.update(to_bytes(request.method))</div><div class="line">        fp.update(to_bytes(canonicalize_url(request.url)))</div><div class="line">        fp.update(request.body <span class="keyword">or</span> <span class="string">b''</span>)</div><div class="line">        <span class="keyword">if</span> include_headers:</div><div class="line">            <span class="keyword">for</span> hdr <span class="keyword">in</span> include_headers:</div><div class="line">                <span class="keyword">if</span> hdr <span class="keyword">in</span> request.headers:</div><div class="line">                    fp.update(hdr)</div><div class="line">                    <span class="keyword">for</span> v <span class="keyword">in</span> request.headers.getlist(hdr):</div><div class="line">                        fp.update(v)</div><div class="line">        cache[include_headers] = fp.hexdigest()</div><div class="line">    <span class="keyword">return</span> cache[include_headers]</div></pre></td></tr></table></figure>
<h2 id="反反爬虫策略"><a href="#反反爬虫策略" class="headerlink" title="反反爬虫策略"></a>反反爬虫策略</h2><h3 id="随机User-Agent"><a href="#随机User-Agent" class="headerlink" title="随机User-Agent"></a>随机User-Agent</h3><p>使用中间件实现随机User-Agent，随机替换掉request的header的User-Agent参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitHubUserAgentMiddleware</span><span class="params">(UserAgentMiddleware)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></div><div class="line">        agent = random.choice(agents)</div><div class="line">        request.headers[<span class="string">'User-Agent'</span>] = agent</div></pre></td></tr></table></figure>
<h3 id="Cookies池"><a href="#Cookies池" class="headerlink" title="Cookies池"></a>Cookies池</h3><p>首先使用多账号模拟登录，获取到很多已登录账号的cookies，放入到Redis的hashset中，各个爬虫共用这一个Cookies池。爬虫同样实现一个中间件，替换Request的Cookies。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Cookie 中间件</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitHubCookieMiddleware</span><span class="params">(RetryMiddleware)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,settings)</span>:</span></div><div class="line">        RetryMiddleware.__init__(self,settings)</div><div class="line">        self.rconn = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, db=<span class="number">3</span>)</div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></div><div class="line">        <span class="keyword">return</span> cls(crawler.settings)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></div><div class="line">        keys = self.rconn.hkeys(REDIS_COOKIE)</div><div class="line">        <span class="keyword">if</span>(len(keys) == <span class="number">0</span>):</div><div class="line">            print(<span class="string">"cookies don't work!"</span>)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        key = random.choice(keys)</div><div class="line">        <span class="comment"># 获取最新cookie</span></div><div class="line">        value = self.rconn.hget(REDIS_COOKIE, key)</div><div class="line">        <span class="keyword">if</span>( isinstance(value, bytes) ):</div><div class="line">            value = value.decode(<span class="string">'utf-8'</span>)</div><div class="line">        cookies = json.loads(value)</div><div class="line">        request.cookies = cookies</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一个为了了解分布式工作原理而做的一个小的项目，其中很多地方存在缺陷，欢迎大家在Github上留建议：</p>
<p><a href="https://github.com/Sixzeroo/GithubCrawler" target="_blank" rel="external">https://github.com/Sixzeroo/GithubCrawler</a></p>
<p>同时也可以查看下一篇关于Github用户和仓库数据分析的文章</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Redis实现分布式爬虫&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.liuin.cn/categories/python/"/>
    
    
      <category term="python" scheme="https://www.liuin.cn/tags/python/"/>
    
      <category term="爬虫" scheme="https://www.liuin.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 题解——Redundant Connection II</title>
    <link href="https://www.liuin.cn/2018/03/28/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Redundant-Connection-II/"/>
    <id>https://www.liuin.cn/2018/03/28/LeetCode-题解——Redundant-Connection-II/</id>
    <published>2018-03-28T07:09:37.000Z</published>
    <updated>2018-03-28T07:12:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题解——Redundant Connection II</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个有向图，求其有向的最小生成树（除了根节点之外所有的节点都有一条入边指向它），同时给出的有向图刚好只多出一条边</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>前一道题是求只多出一条边的无向图的最小生成树，使用并查集很容易就能够求解。</p>
<p>这一道有向图的题就比较复杂一点了，有向图的最小生成树又叫最小树形图，常规算法是使用<a href="https://www.liuin.cn/2017/03/25/%E5%88%9D%E8%AF%86-%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95/">朱刘算法</a>。这里因为只多出一条边，所以不用这么麻烦。</p>
<p>总共有三种情况：</p>
<ol>
<li>有环，但是没有入度为2的节点</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-03-28-15222211302563.jpg" alt=""></p>
<ol>
<li>有环，同时有入度为2的节点</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-03-28-15222211412345.jpg" alt=""></p>
<ol>
<li>无环，有入度为2的节点</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-03-28-15222211561578.jpg" alt=""></p>
<p>第一种情况，按照无向图的处理方式进行就行了，使用并查集返回最后一条形成环的边。</p>
<p>后面两种情况，首先要找到入度为2的节点，选出指向这个节点的两条边，处理完其他的边以后处理这两条边，使用并查集找出最后一个连接的两个节点已经在同一集合中的边</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> par[<span class="number">3000</span>];</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">            par[i] = i;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> par[x] = find(par[x]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></div><div class="line">    &#123;</div><div class="line">        x = find(x);</div><div class="line">        y = find(y);</div><div class="line">        <span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</div><div class="line">        par[y] = x;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 并查集</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findRedundantDirectedConnection(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</div><div class="line">        <span class="keyword">int</span> len = edges.size();</div><div class="line">        init(len);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegre(len, <span class="number">0</span>), outdegre(len, <span class="number">0</span>);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; problem_edge;</div><div class="line">        <span class="keyword">int</span> node = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 统计入度，找到入度为2的点</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:edges)</div><div class="line">        &#123;</div><div class="line">            indegre[i[<span class="number">1</span>]]++;</div><div class="line">            <span class="keyword">if</span>(indegre[i[<span class="number">1</span>]] == <span class="number">2</span>) node = i[<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:edges)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i[<span class="number">1</span>] == node)</div><div class="line">            &#123;</div><div class="line">                problem_edge.push_back(i);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 有环的情况</span></div><div class="line">            <span class="keyword">int</span> a = find(i[<span class="number">0</span>]), b= find(i[<span class="number">1</span>]);</div><div class="line">            <span class="keyword">if</span>(a == b) </div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">            unite(i[<span class="number">0</span>], i[<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 无环的情况，从入度为2的节点入手</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:problem_edge)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> a = find(i[<span class="number">0</span>]), b= find(i[<span class="number">1</span>]);</div><div class="line">            <span class="keyword">if</span>(a == b) <span class="keyword">return</span> i;</div><div class="line">            <span class="keyword">else</span> unite(a,b);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题解——Redundant Connection II&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.liuin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="图论" scheme="https://www.liuin.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="LeetCode" scheme="https://www.liuin.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析——内存分配</title>
    <link href="https://www.liuin.cn/2018/03/23/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>https://www.liuin.cn/2018/03/23/Redis源码剖析——内存分配/</id>
    <published>2018-03-23T10:43:53.000Z</published>
    <updated>2018-03-23T11:12:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>内存分配是程序需要解决的一个大问题，也应该是剖析一个程序的源码最基础最关键的部分之一。</p>
<a id="more"></a>
<p>Redis的内存分配主要是在C语言中对内存处理的函数：malloc、realloc、free的基础加了一些封装和异常的处理。</p>
<p>其特点主要有以下三点：</p>
<ol>
<li>添加对使用内存的统计，在分配和释放内存的时候都会更新记录使用内存的量</li>
<li>支持线程安全模式，通过锁的机制对use_memory进行控制，避免其出现脏数据的可能</li>
<li>增添对内存溢出的处理</li>
</ol>
<p>首先Redis源码中与内存分配相关的以下全局变量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>;    <span class="comment">// 使用的内存大小</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> zmalloc_thread_safe = <span class="number">0</span>;   <span class="comment">// 线程安全模式状态</span></div><div class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;   <span class="comment">// 为此服务器</span></div></pre></td></tr></table></figure></p>
<h2 id="内存分配相关功能函数"><a href="#内存分配相关功能函数" class="headerlink" title="内存分配相关功能函数"></a>内存分配相关功能函数</h2><p>Redis中和内存分配相关的功能函数主要有以下这些：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void *zmalloc(size_t size);   </div><div class="line">void *zcalloc(size_t size);</div><div class="line">void *zrealloc(void *ptr, size_t size);</div><div class="line">void zfree(void *ptr);</div><div class="line">char *zstrdup(const char *s);  // 封装的字符复制函数</div><div class="line">size_t zmalloc_used_memory(void);   // 获取使用的内存大小</div><div class="line">void zmalloc_enable_thread_safeness(void);    // 开启线程安全模式</div><div class="line">void zmalloc_set_oom_handler(void (*oom_handler)(size_t));   // 自定义的内存溢出处理方法</div><div class="line">float zmalloc_get_fragmentation_ratio(size_t rss);  // 使用内存和所给内存之比</div><div class="line">size_t zmalloc_get_rss(void);  // 获取rss信息</div><div class="line">size_t zmalloc_get_private_dirty(void);   // 获取实际物理分配的内存</div></pre></td></tr></table></figure></p>
<h2 id="内存申请与调整"><a href="#内存申请与调整" class="headerlink" title="内存申请与调整"></a>内存申请与调整</h2><p>Redis中和内存申请相关的函数主要是zmalloc、zcalloc和zrealloc，分别是对C语言中的malloc、calloc和realloc的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对malloc进行封装，加上异常处理和内存统计</span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="comment">// 多申请的内存用于存储次块空间大小</span></div><div class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</div><div class="line"></div><div class="line">    <span class="comment">// 内存溢出</span></div><div class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</div><div class="line">    <span class="comment">// 进行内存统计</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</div><div class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size+PREFIX_SIZE);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</div><div class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 封装重新分配内存函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="keyword">void</span> *realptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">size_t</span> oldsize;</div><div class="line">    <span class="keyword">void</span> *newptr;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zmalloc(size);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="comment">// 原来所使用空间的大小</span></div><div class="line">    oldsize = zmalloc_size(ptr);</div><div class="line">    <span class="comment">// 重新分配新的空间</span></div><div class="line">    newptr = <span class="built_in">realloc</span>(ptr,size);</div><div class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</div><div class="line"></div><div class="line">    <span class="comment">// 更新保存的使用内存值</span></div><div class="line">    update_zmalloc_stat_free(oldsize);</div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(newptr));</div><div class="line">    <span class="keyword">return</span> newptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</div><div class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</div><div class="line">    newptr = <span class="built_in">realloc</span>(realptr,size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</div><div class="line"></div><div class="line">    *((<span class="keyword">size_t</span>*)newptr) = size;</div><div class="line">    update_zmalloc_stat_free(oldsize);</div><div class="line">    update_zmalloc_stat_alloc(size);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先要注意的是对内存溢出的处理，可以自定义处理函数，其默认的处理方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 默认溢出处理方法</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zmalloc_default_oom</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"zmalloc: Out of memory trying to allocate %zu bytes\n"</span>,</div><div class="line">        size);</div><div class="line">    fflush(<span class="built_in">stderr</span>);</div><div class="line">    <span class="built_in">abort</span>();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 内存溢出处理方法</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*zmalloc_oom_handler)</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= zmalloc_default_oom;</div></pre></td></tr></table></figure>
<p>然后我们可以看到每次在调整内存的时候，都会对全局变量use_memory进行改变，调整是以<code>sizeof(long)</code>的整数倍进行调整的。在改变use_memory的时候会判断是否在线程安全模式下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 更新使用的内存数量值</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) do &#123; \</span></div><div class="line">    size_t _n = (__n); \</div><div class="line">    <span class="comment">// _n调整为size(long)的整数倍</span></div><div class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</div><div class="line">    <span class="comment">// 线程安全模式，原子性增加使用内存大小 （加锁）</span></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \</div><div class="line">        update_zmalloc_stat_add(_n); \</div><div class="line">    <span class="comment">// 不使用线程安全模式，直接增加</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123; \</div><div class="line">        used_memory += _n; \</div><div class="line">    &#125; \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_add(__n) do &#123; \</span></div><div class="line">    pthread_mutex_lock(&amp;used_memory_mutex); \</div><div class="line">    used_memory += (__n); \</div><div class="line">    pthread_mutex_unlock(&amp;used_memory_mutex); \</div><div class="line">&#125; while(0)</div></pre></td></tr></table></figure>
<h2 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h2><p>内存释放部分和申请部分类似，主要是对free函数的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取内存占用空间大小</span></div><div class="line"><span class="keyword">size_t</span> zmalloc_size(<span class="keyword">void</span> *ptr) &#123;</div><div class="line">    <span class="comment">// 减去统计内存大小的部分</span></div><div class="line">    <span class="keyword">void</span> *realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</div><div class="line">    <span class="keyword">size_t</span> size = *((<span class="keyword">size_t</span>*)realptr);</div><div class="line">    <span class="comment">/* Assume at least that all the allocations are padded at sizeof(long) by</span></div><div class="line">     * the underlying allocator. */</div><div class="line">    <span class="comment">// 调整为sizeof(long)的整数倍，方便对齐</span></div><div class="line">    <span class="keyword">if</span> (size&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) size += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(size&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>));</div><div class="line">    <span class="keyword">return</span> size+PREFIX_SIZE;</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">// 封装对系统的free调用</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="keyword">void</span> *realptr;</div><div class="line">    <span class="keyword">size_t</span> oldsize;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="comment">// 减少对内存的计数</span></div><div class="line">    update_zmalloc_stat_free(zmalloc_size(ptr));</div><div class="line">    <span class="built_in">free</span>(ptr);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</div><div class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</div><div class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</div><div class="line">    <span class="built_in">free</span>(realptr);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对use_memory的操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 释放内存以后对内存空间统计变量的改变</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_free(__n) do &#123; \</span></div><div class="line">    size_t _n = (__n); \</div><div class="line">    <span class="comment">// 以sizeof(long)的整数倍进行调整</span></div><div class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</div><div class="line">    <span class="comment">// 线程安全模式</span></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \</div><div class="line">        update_zmalloc_stat_sub(_n); \</div><div class="line">    &#125; <span class="keyword">else</span> &#123; \</div><div class="line">        used_memory -= _n; \</div><div class="line">    &#125; \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><p>除了最基本的一些内存分配的函数以外，还实现了一些辅助函数(如复制字符串、获取已经使用内存的大小）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 复制字符串操作</span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</div><div class="line">    <span class="keyword">size_t</span> l = <span class="built_in">strlen</span>(s)+<span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> *p = zmalloc(l);</div><div class="line"></div><div class="line">    <span class="comment">// 调用字符复制函数</span></div><div class="line">    <span class="built_in">memcpy</span>(p,s,l);</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取已经使用的内存大小</span></div><div class="line"><span class="keyword">size_t</span> zmalloc_used_memory(<span class="keyword">void</span>) &#123;</div><div class="line">    <span class="keyword">size_t</span> um;</div><div class="line"></div><div class="line">    <span class="comment">// 线程安全模式</span></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__ATOMIC_RELAXED) || defined(HAVE_ATOMIC)</span></div><div class="line">        um = update_zmalloc_stat_add(<span class="number">0</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        pthread_mutex_lock(&amp;used_memory_mutex);</div><div class="line">        um = used_memory;</div><div class="line">        pthread_mutex_unlock(&amp;used_memory_mutex);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 非线程安全情况下，直接赋值</span></div><div class="line">        um = used_memory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> um;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存分配是程序需要解决的一个大问题，也应该是剖析一个程序的源码最基础最关键的部分之一。&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="https://www.liuin.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析——跳跃表</title>
    <link href="https://www.liuin.cn/2018/03/22/Redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    <id>https://www.liuin.cn/2018/03/22/Redis源码解析——跳跃表/</id>
    <published>2018-03-22T07:47:17.000Z</published>
    <updated>2018-03-23T10:40:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis使用跳跃表作为有序集合键的底层实现之一，跳跃表(skiplist)是一种有序数据结构,它通过在每个节点中维持多个指向其他节点的指针,从而达到快速访问节点的目的。</p>
<a id="more"></a>
<p>跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找,还可以通过顺序性操作来批量处理节点。在大部分情况下,跳跃表的效率可以和平衡树相媲美,并且因为跳跃表的实现比平衡树要来得更为简单,所以有不少程序都使用跳跃表来代替平衡树。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>一个跳跃表的整体结构如下：<br><img src="https://data2.liuin.cn/2018-03-22-15217053998776.jpg" alt=""></p>
<h3 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h3><p>跳跃表节点的数据结构定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 跳跃表节点</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplistNode &#123;</div><div class="line">    robj *obj;   <span class="comment">// 保存的值</span></div><div class="line">    <span class="keyword">double</span> score;  <span class="comment">// 节点分值</span></div><div class="line">    <span class="keyword">struct</span> zskiplistNode *backward;  <span class="comment">// 后退指针</span></div><div class="line">    <span class="comment">// 层</span></div><div class="line">    <span class="keyword">struct</span> zskiplistLevel &#123;    </div><div class="line">        <span class="keyword">struct</span> zskiplistNode *forward;   <span class="comment">// 前进指针</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;   <span class="comment">// 跨度</span></div><div class="line">    &#125; level[];</div><div class="line">&#125; zskiplistNode;</div></pre></td></tr></table></figure></p>
<ul>
<li>层：level数组包含多个元素,每个元素都包含一个指向其他节点的指针,程序可以通过这些层来加快访问其他节点的速度,一般来说,层的数量越多,访问其他节点的速度就越快</li>
<li>前进指针：每个层都有一个指向表尾方向的前进指针,用于从表头向表尾方向访问节点</li>
<li>跨度：表示两个节点之间的距离（前进指针指向节点和当前节点的距离）</li>
<li>后退指针：用于从表尾向表头访问节点</li>
<li>score分值：跳跃表中所有的节点按照分值进行排序</li>
<li>obj：保存的成员，一般为sds数据结构</li>
</ul>
<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 跳跃表</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplist &#123;</div><div class="line">    <span class="keyword">struct</span> zskiplistNode *header, *tail; <span class="comment">// 头结点、尾节点</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;  <span class="comment">// 长度</span></div><div class="line">    <span class="keyword">int</span> level; <span class="comment">// 最高层节点的层数</span></div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure>
<p>跳跃表记录了头结点和尾结点的指针、长度（即跳跃表中节点数目）和层数最大的节点的层数，注意表头节点的层高并不计算在内。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="创建跳跃表"><a href="#创建跳跃表" class="headerlink" title="创建跳跃表"></a>创建跳跃表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建跳跃表节点</span></div><div class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</div><div class="line">    <span class="comment">// 分配内存空间</span></div><div class="line">    zskiplistNode *zn = zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> zskiplistLevel));</div><div class="line">    <span class="comment">// 初始化</span></div><div class="line">    zn-&gt;score = score;</div><div class="line">    zn-&gt;obj = obj;</div><div class="line">    <span class="keyword">return</span> zn;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建跳跃表</span></div><div class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    zskiplist *zsl;</div><div class="line"></div><div class="line">    <span class="comment">// 分配内存空间</span></div><div class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</div><div class="line">    zsl-&gt;level = <span class="number">1</span>;</div><div class="line">    zsl-&gt;length = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 表头为32层的空节点，每一层都指向NULL</span></div><div class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</div><div class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</div><div class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</div><div class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">return</span> zsl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见：</p>
<ul>
<li>创建的跳跃表的初识level层数值为1</li>
<li>刚创建的跳跃表的头结点是一个有32层的空节点，其中每一层的forward都是NULL</li>
</ul>
<h3 id="跳跃表插入节点"><a href="#跳跃表插入节点" class="headerlink" title="跳跃表插入节点"></a>跳跃表插入节点</h3><p>跳跃表插入节点的部分有些复杂，需要改变节点前后节点的forward、backward指针以及长度等信息。其基本思想是：使用update表记录新节点在各层中forward指针指向它的节点，然后插入，同时改变这些复杂的指向关系。</p>
<p>其中rank数组是用来记录每一个节点再整个节点表中的排位信息，其是通过每层中的跨度计算得来的。</p>
<p>新插入的节点的层数是通过幂次定律决定的一个1-32的数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回一个1-32的层数值，使用幂次定律，越大的数出现的概率越小</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</div><div class="line">    <span class="comment">// 使用幂次定律，1/4概率</span></div><div class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</div><div class="line">        level += <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 跳跃表插入节点</span></div><div class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    <span class="comment">// 记录每一个节点的排位信息</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</div><div class="line">    <span class="keyword">int</span> i, level;</div><div class="line"></div><div class="line">    redisAssert(!isnan(score));</div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="comment">// 查找插入位置，从最高的层开始</span></div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></div><div class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</div><div class="line">        <span class="comment">// 遍历跳跃表</span></div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            <span class="comment">// 对比分值</span></div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                    <span class="comment">// 对比成员</span></div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>))) &#123;</div><div class="line">            <span class="comment">// 计算排位</span></div><div class="line">            rank[i] += x-&gt;level[i].span;</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 第i层将要和新节点连接的节点</span></div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* we assume the key is not already inside, since we allow duplicated</span></div><div class="line">     * scores, and the re-insertion of score and redis object should never</div><div class="line">     * happen since the caller of zslInsert() should test in the hash table</div><div class="line">     * if the element is already inside or not. */</div><div class="line">    <span class="comment">// 获取层数</span></div><div class="line">    level = zslRandomLevel();</div><div class="line">    <span class="comment">// 新的层数比原来所以节点的层数都大</span></div><div class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 初始化未使用的层</span></div><div class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</div><div class="line">            rank[i] = <span class="number">0</span>;</div><div class="line">            update[i] = zsl-&gt;header;</div><div class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</div><div class="line">        &#125;</div><div class="line">        zsl-&gt;level = level;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 创建指定层数的新节点</span></div><div class="line">    x = zslCreateNode(level,score,obj);</div><div class="line">    <span class="comment">// 使用update中的信息将为新的节点建立连接</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</div><div class="line">        <span class="comment">// 设置新节点的forward</span></div><div class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</div><div class="line">        <span class="comment">// 前面的节点的forward指向新节点</span></div><div class="line">        update[i]-&gt;level[i].forward = x;</div><div class="line"></div><div class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></div><div class="line">        <span class="comment">// 更新跨节点数量</span></div><div class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</div><div class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* increment span for untouched levels */</span></div><div class="line">    <span class="comment">// 没有和新节点接触的节点的跨度也要加一</span></div><div class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        update[i]-&gt;level[i].span++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 更新后退指针（新节点的后退指针+前面一个节点的后退指针）</span></div><div class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</div><div class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</div><div class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        zsl-&gt;tail = x;</div><div class="line">    <span class="comment">// 更新长度</span></div><div class="line">    zsl-&gt;length++;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="跳跃表删除节点"><a href="#跳跃表删除节点" class="headerlink" title="跳跃表删除节点"></a>跳跃表删除节点</h3><p>删除节点的方法差不多就是插入节点方法的反向操作，首先找到目标节点（通过update数组记录沿途节点），接触forward指针关系，更新跳跃表的层数和长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank */</span></div><div class="line"><span class="comment">// 跳跃表内部删除节点，update数组为forward指向本节点的数组</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslDeleteNode</span><span class="params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="comment">// 解除forward关系</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123;</div><div class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="number">1</span>;</div><div class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            update[i]-&gt;level[i].span -= <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 更新backward指针</span></div><div class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward) &#123;</div><div class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x-&gt;backward;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        zsl-&gt;tail = x-&gt;backward;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果删除的节点是层数最大的节点，则更新跳跃表的最大层数</span></div><div class="line">    <span class="keyword">while</span>(zsl-&gt;level &gt; <span class="number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level<span class="number">-1</span>].forward == <span class="literal">NULL</span>)</div><div class="line">        zsl-&gt;level--;</div><div class="line">    <span class="comment">// 跳跃表长度减一</span></div><div class="line">    zsl-&gt;length--;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Delete an element with matching score/object from the skiplist. */</span></div><div class="line"><span class="comment">// 跳跃表删除节点</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslDelete</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历跳跃表，找到目标节点，并记录沿途节点</span></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>)))</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* We may have multiple elements with the same score, what we need</span></div><div class="line">     * is to find the element with both the right score and object. */</div><div class="line">    <span class="comment">// 只有在分值和对象都相同的时候才删除</span></div><div class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</div><div class="line">    <span class="keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; equalStringObjects(x-&gt;obj,obj)) &#123;</div><div class="line">        zslDeleteNode(zsl, x, update);</div><div class="line">        zslFreeNode(x);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="跳跃表查找节点"><a href="#跳跃表查找节点" class="headerlink" title="跳跃表查找节点"></a>跳跃表查找节点</h3><p>跳跃表中查找节点相关的操作主要有获取排名、依据排名获取信息。其基本思想和插入节点找到插入位置一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通过分值和对象值获取排位信息，以1为起始值</span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *o)</span> </span>&#123;</div><div class="line">    zskiplistNode *x;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rank = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="comment">// 从最高层依次往下</span></div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,o) &lt;= <span class="number">0</span>))) &#123;</div><div class="line">            <span class="comment">// 排位增加</span></div><div class="line">            rank += x-&gt;level[i].span;</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* x might be equal to zsl-&gt;header, so test if obj is non-NULL */</span></div><div class="line">        <span class="comment">// 对象和分数值都相等</span></div><div class="line">        <span class="keyword">if</span> (x-&gt;obj &amp;&amp; equalStringObjects(x-&gt;obj,o)) &#123;</div><div class="line">            <span class="keyword">return</span> rank;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Finds an element by its rank. The rank argument needs to be 1-based. */</span></div><div class="line"><span class="comment">// 通过排位获取节点</span></div><div class="line"><span class="function">zskiplistNode* <span class="title">zslGetElementByRank</span><span class="params">(zskiplist *zsl, <span class="keyword">unsigned</span> <span class="keyword">long</span> rank)</span> </span>&#123;</div><div class="line">    zskiplistNode *x;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> traversed = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="comment">// 从最高层依次往下找</span></div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt;= rank)</div><div class="line">        &#123;</div><div class="line">            traversed += x-&gt;level[i].span;</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 找到相应的节点</span></div><div class="line">        <span class="keyword">if</span> (traversed == rank) &#123;</div><div class="line">            <span class="keyword">return</span> x;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用一张图能够简单表示这种查找行为，例如找到5这个节点：</p>
<p><img src="https://data2.liuin.cn/2018-03-22-56782.png" alt="56782"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis使用跳跃表作为有序集合键的底层实现之一，跳跃表(skiplist)是一种有序数据结构,它通过在每个节点中维持多个指向其他节点的指针,从而达到快速访问节点的目的。&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="https://www.liuin.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析——链表和字典</title>
    <link href="https://www.liuin.cn/2018/03/20/Redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.liuin.cn/2018/03/20/Redis源码解析——链表/</id>
    <published>2018-03-20T05:17:06.000Z</published>
    <updated>2018-03-26T05:01:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>链表和字典（dict）是比较常用的数据结构，但是C语言在底层并没有内置这种数据结构，这里通过源码查看这两个数据结构在Redis底层的实现</p>
<a id="more"></a>
<h2 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h2><p>Redis底层使用的是一个双端链表</p>
<p>链表节点结构定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 双端链表节点</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> listNode &#123;</div><div class="line">    <span class="keyword">struct</span> listNode *prev;  <span class="comment">// 前置节点</span></div><div class="line">    <span class="keyword">struct</span> listNode *next;  <span class="comment">// 后置节点</span></div><div class="line">    <span class="keyword">void</span> *value;   <span class="comment">// 节点值</span></div><div class="line">&#125; listNode;</div></pre></td></tr></table></figure></p>
<p>链表迭代器结构定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 双端链表迭代器</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> listIter &#123;</div><div class="line">    listNode *next; <span class="comment">// 迭代的指针</span></div><div class="line">    <span class="keyword">int</span> direction;  <span class="comment">// 迭代的方向</span></div><div class="line">&#125; listIter;</div></pre></td></tr></table></figure></p>
<p>通过迭代器可以比较容易对整个链表进行遍历，从而轻松实现查找等功能。</p>
<p>链表结构定义<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 双端链表</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">list</span> &#123;</div><div class="line">    listNode *head;  <span class="comment">// 头结点</span></div><div class="line">    listNode *tail;  <span class="comment">// 尾节点</span></div><div class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);  <span class="comment">// 节点值复制函数，可指定复制的方法</span></div><div class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);  <span class="comment">// 节点值释放函数</span></div><div class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);  <span class="comment">// 节点值对比函数</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;   <span class="comment">// 链表中所包含的节点数量</span></div><div class="line">&#125; <span class="built_in">list</span>;</div></pre></td></tr></table></figure></p>
<p>Redis底层中所包含的链表API都是对链表常用功能的实现，比如说插入、删除、搜索等，这里不在解释。</p>
<p>Redis的链表实现的特点有如下几个：</p>
<ul>
<li>双端，方便向前和向后便利</li>
<li>多态，链表节点使用void*指针来保存节点值,并且可以通过1ist结构的dup、free、 match三个属性为节点值设置类型特定函数,所以链表可以用于保存各种不同类型的值。</li>
</ul>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典,又称为符号表( symbol table)、关联数组( associative array)或映射(map),是种用于<strong>保存键值对(key- value pair)的抽象数据结构</strong>。</p>
<p>字典在Reds中的应用相当广泛,比如 Redis的数据库就是使用字典来作为底层实现的,对数据库的增、删、查、改操作也是构建在对字典的操作之上的。</p>
<h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><p>Redis的字典用哈希表作为底层实现，哈希表中含有哈希表节点，而每一个哈希表节点就保存了字典中的一个键值对。</p>
<blockquote>
<p>哈希表</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictht &#123;</div><div class="line">    dictEntry **table;  <span class="comment">// 哈希表的节点数组</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size; <span class="comment">// 哈希表大小</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;  <span class="comment">// 哈希表的大小掩码，用于计算索引值，总等于size-1</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used; <span class="comment">// 哈希表中含有的节点数</span></div><div class="line">&#125; dictht;</div></pre></td></tr></table></figure>
<p>sizemask属性的值总是等于size-1,这个属性和哈希值一起决定一个键应该被放到tab1e数组的哪个索引上面。</p>
<blockquote>
<p>哈希表节点</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 哈希表节点</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictEntry &#123;</div><div class="line">    <span class="keyword">void</span> *key;  <span class="comment">// 键  </span></div><div class="line">    <span class="keyword">union</span> &#123;  </div><div class="line">        <span class="keyword">void</span> *val;</div><div class="line">        <span class="keyword">uint64_t</span> u64;</div><div class="line">        <span class="keyword">int64_t</span> s64;</div><div class="line">        <span class="keyword">double</span> d;</div><div class="line">    &#125; v;   <span class="comment">// 值</span></div><div class="line">    <span class="keyword">struct</span> dictEntry *next;  <span class="comment">// 下一个哈希表结点，形成链表</span></div><div class="line">&#125; dictEntry;</div></pre></td></tr></table></figure>
<p>Redis中哈希表解决冲突的方法是拉链法，所以其中有next属性指向另一个哈希表节点的指针,这个指针可以将多个哈希值相同的键值对连接在一次,以此来解决键冲突( collision)的问题。</p>
<blockquote>
<p>字典</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dict &#123;</div><div class="line">    dictType *type;  <span class="comment">// 类型特定函数</span></div><div class="line">    <span class="keyword">void</span> *privdata;  <span class="comment">// 私有数据</span></div><div class="line">    dictht ht[<span class="number">2</span>];   <span class="comment">// 含有两个哈希表</span></div><div class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">// rehash 索引，当rehash不再运行的时候，值为-1</span></div><div class="line">    <span class="keyword">int</span> iterators;  <span class="comment">// 现在正在运行的迭代器数量</span></div><div class="line">&#125; dict;</div></pre></td></tr></table></figure>
<p>type属性和 privata属性是针对不同类型的键值对,为创建多态字典而设置的；ht属性是一个包含两个项的数组,数组中的每个项都是一个 dictht哈希表,一般情况下,字典只使用ht[0]哈希表,ht[1]哈希表只会在对ht[0]哈希表进行 rehash时使用。</p>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>把一个新的键值对加入到字典中，首先要根据key计算出哈希值和索引值，然后把新的哈希节点加到哈希表数组的指定索引上面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 计算哈希值</span></div><div class="line">    h = dictHashKey(d, key);</div><div class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</div><div class="line">        <span class="comment">// 计算索引值</span></div><div class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</div><div class="line">        <span class="comment">/* Search if this slot does not already contain the given key */</span></div><div class="line">        <span class="comment">// 查找key是否存在</span></div><div class="line">        he = d-&gt;ht[table].table[idx];</div><div class="line">        <span class="keyword">while</span>(he) &#123;</div><div class="line">            <span class="keyword">if</span> (dictCompareKeys(d, key, he-&gt;key))</div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">            he = he-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>Redis使用的是Murmur算法计算哈希值的，这种算法的优点在于,即使输人的键是有规律的,算法仍能给出一个很好的随机分布性,并且算法的计算速度也非常快。</p>
<h3 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h3><p>Redis采用的是链地址法( separate chaining)解决键冲突的，每个哈希表节点都有个next指针,多个哈希表节点可以用next指针构成一个单向链表,被分配到同一个索引上的多个节点可以用这个单向链表连接起来,这就解决了键冲突的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Allocate the memory and store the new entry */</span></div><div class="line">ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</div><div class="line">entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</div><div class="line">entry-&gt;next = ht-&gt;table[index];  <span class="comment">// 把新的哈希节点加入到哈希数组索引处，并放在链表的头结点处</span></div><div class="line">ht-&gt;table[index] = entry;</div><div class="line">ht-&gt;used++;</div></pre></td></tr></table></figure>
<p><img src="https://data2.liuin.cn/2018-03-20-15215263654971.jpg" alt=""></p>
<h3 id="重新散列（rehash）"><a href="#重新散列（rehash）" class="headerlink" title="重新散列（rehash）"></a>重新散列（rehash）</h3><p>当dict不断进行添加或删除等操作的时候，所保存的键值对也会不断的增加或者减少。为了使哈希表的负载因子（load factor）维持在合理的范围内，此时就需要对哈希表的大小进行相应的扩展或者收缩。</p>
<p>这个工作通过重新散列（rehash）来进行，执行的主要步骤如下：</p>
<ul>
<li>为dict的ht[1]哈希表分配合适的空间，空间的大小取决于要执行的操作和ht[0]哈希表中键值对的数量</li>
<li>对所有在ht[0]中的键值对重新计算哈希索引值，将他们转移到ht[1]中</li>
<li>释放ht[0]，将ht[1]设置为ht[0]</li>
</ul>
<p>其中负载因子的计算公式为：<code>load_factor = ht[0].used / ht[0].size</code></p>
<blockquote>
<p>渐进式rehash</p>
</blockquote>
<p>在进行rehash的过程中需要将所有的键值对从ht[0]迁移到ht[1]中，如果键值对的数量比较大的话，就会导致Redis需要停止一段时间的服务才能够完成这些操作，所以为了避免对服务性能造成影响，rehash并不是一次性的、集中式地完成的，而是分多次、渐进式完成的。</p>
<p>具体的步骤如下：</p>
<ul>
<li>为ht[1]分配空间，同时保留ht[0]和ht[1]两个哈希表</li>
<li>在dict中维持一个索引计数变量rehashldx，将其值设为0，表示开始rehash（不工作是为-1）</li>
<li>在rehash是，每对dict进行一次操作的时候，除了进行制定操作外还要ht[0]哈希表中rehashldx索引上的索引键值对转移的ht[1]上，完成以后将rehashldx加一</li>
<li>当完成了所有ht[0]到ht[1]键值对的转移工作时，表示完成了rehash，此时将rehashldx的值设为-1</li>
</ul>
<p>在渐进式rehash的过程中，dict同时拥有两个hash表，所以dict的删除、查找、更新等操作会在两个哈希表上同时进行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在rehash期间每进行一次操作，迁移一个索引中所有的键值对</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></div><div class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</div><div class="line">        dictEntry *de, *nextde;</div><div class="line"></div><div class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></div><div class="line">         * elements because ht[0].used != 0 */</div><div class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</div><div class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</div><div class="line">            d-&gt;rehashidx++;</div><div class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</div><div class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></div><div class="line">        <span class="comment">// 对每一个键值对重新计算hash值、index值，进行迁移</span></div><div class="line">        <span class="keyword">while</span>(de) &#123;</div><div class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</div><div class="line"></div><div class="line">            nextde = de-&gt;next;</div><div class="line">            <span class="comment">/* Get the index in the new hash table */</span></div><div class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</div><div class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</div><div class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</div><div class="line">            d-&gt;ht[<span class="number">0</span>].used--;</div><div class="line">            d-&gt;ht[<span class="number">1</span>].used++;</div><div class="line">            de = nextde;</div><div class="line">        &#125;</div><div class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</div><div class="line">        d-&gt;rehashidx++; <span class="comment">// 将rehashldx的值加一</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></div><div class="line">    <span class="comment">// 完成渐进式rehash工作</span></div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</div><div class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</div><div class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</div><div class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</div><div class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* More to rehash... */</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链表和字典（dict）是比较常用的数据结构，但是C语言在底层并没有内置这种数据结构，这里通过源码查看这两个数据结构在Redis底层的实现&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="https://www.liuin.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析——简单动态字符串(SDS)</title>
    <link href="https://www.liuin.cn/2018/03/19/Redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2-SDS/"/>
    <id>https://www.liuin.cn/2018/03/19/Redis源码解析——简单动态字符串-SDS/</id>
    <published>2018-03-19T10:45:00.000Z</published>
    <updated>2018-03-23T10:41:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>解析Redis的一个底层数据结构——简单动态数组，讨论起优点和不足</p>
<a id="more"></a>
<p>Redis没有直接使用C语言传统的字符串表示(以空字符结尾的字符数组),而是自己构建了一种名为<strong>简单动态字符串</strong>( simple dynamic string,SDS)的抽象类型,并将SDS用作 Redis的默认字符串表示。现在作者把这一个部分抽出来，单独做了一个项目，地址在<a href="https://github.com/antirez/sds" target="_blank" rel="external">这里</a></p>
<h2 id="数据结构定义定义"><a href="#数据结构定义定义" class="headerlink" title="数据结构定义定义"></a>数据结构定义定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sdshdr &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;   <span class="comment">// buf数组中已经使用的字节数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>;  <span class="comment">// buf数组中未使用的字节数量</span></div><div class="line">    <span class="keyword">char</span> buf[];         <span class="comment">// 字节数组，保存字符</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>SDS遵循C字符串以空字符结尾的惯例,保存空字符的1字节空间不计算在SDS的1en属性里面,并且为空字符分配额外的1字节空间,以及添加空字符到字符串末尾等操作</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><h3 id="获取字符串长度是常数级复杂度"><a href="#获取字符串长度是常数级复杂度" class="headerlink" title="获取字符串长度是常数级复杂度"></a>获取字符串长度是常数级复杂度</h3><p>C语言中获取字符串的长度需要把整个字符串都遍历一遍，而对于SDS来说，只需要访问len属性，将时间复杂度从O（N）降低到了O（1）</p>
<h3 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h3><p>除了获取字符串长度的复杂度高之外,C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出( buffer overflow)。C语言字符串进行拼接的时候如果不对原来的字符串分配足够的空间，容易造成溢出。</p>
<p>与C字符串不同,SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性:当SDS API需要对SDS进行修改时,API会先检查SDS的空间是否满足修改所需的要求,如果不满足的话,API会自动将SDS的空间扩展至执行修改所需的大小,然后才执行实际的修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 追加长度为len的字符串到buf的末尾</span></div><div class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh;</div><div class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</div><div class="line"></div><div class="line">    <span class="comment">// 扩展sds空间，确保其至少含有len+1个空间可以放置字符串</span></div><div class="line">    s = sdsMakeRoomFor(s,len);</div><div class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    <span class="comment">// 复制字符串</span></div><div class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</div><div class="line">    <span class="comment">// 更新长度</span></div><div class="line">    sh-&gt;len = curlen+len;</div><div class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>-len;</div><div class="line">    s[curlen+len] = <span class="string">'\0'</span>;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h3><p>C语言中，每次对字符串进行修改都要进行内存的重新分配，在SDS中使用<strong>空间预分配和惰性空间释放</strong>来减少内存重新分配的次数</p>
<blockquote>
<p>空间预分配</p>
</blockquote>
<p>SDS在执行空间扩展的时候将执行以下策略：</p>
<ul>
<li>如果对SDS进行修改之后,SDS的长度(也即是1en属性的值)将小于1MB,那么程序分配和1en属性同样大小的未使用空间,这时SDs1en属性的值将和free属性的值相同。</li>
<li>如果对SDs进行修改之后,SDS的长度将大于等于1MB,那么程序会分配1MB的未使用空间。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对sds中buf的长度进行扩展，至少有addlen+1长度的剩余空间</span></div><div class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh, *newsh;</div><div class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</div><div class="line">    <span class="keyword">size_t</span> len, newlen;</div><div class="line"></div><div class="line">    <span class="comment">// 目前剩余空间足够</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</div><div class="line">    len = sdslen(s);</div><div class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    newlen = (len+addlen);</div><div class="line">    <span class="comment">// 分配两倍空间</span></div><div class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</div><div class="line">        newlen *= <span class="number">2</span>;</div><div class="line">    <span class="comment">// 分配1M空间</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        newlen += SDS_MAX_PREALLOC;</div><div class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+newlen+<span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 更新剩余空间</span></div><div class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</div><div class="line">    <span class="keyword">return</span> newsh-&gt;buf;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>惰性空间释放</p>
</blockquote>
<p>惰性空间释放用于优化SDS的字符串缩短操作:当SDS的API需要缩短SDS保存的字符串时,程序并不立即使用内存重分配来回收缩短后多出来的字节,而是使用free属性将这些字节的数量记录起来,并等待将来使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 移除所有在s中出现过的cset字符</span></div><div class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    <span class="keyword">char</span> *start, *end, *sp, *ep;</div><div class="line">    <span class="keyword">size_t</span> len;</div><div class="line"></div><div class="line">    sp = start = s;</div><div class="line">    ep = end = s+sdslen(s)<span class="number">-1</span>;</div><div class="line">    <span class="keyword">while</span>(sp &lt;= end &amp;&amp; <span class="built_in">strchr</span>(cset, *sp)) sp++;</div><div class="line">    <span class="keyword">while</span>(ep &gt; start &amp;&amp; <span class="built_in">strchr</span>(cset, *ep)) ep--;</div><div class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep-sp)+<span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (sh-&gt;buf != sp) memmove(sh-&gt;buf, sp, len);</div><div class="line">    sh-&gt;buf[len] = <span class="string">'\0'</span>;</div><div class="line">    <span class="comment">// 并没有释放buf空间，而是增加free数量</span></div><div class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>+(sh-&gt;len-len);</div><div class="line">    sh-&gt;len = len;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>C字符串中的字符必须符合某种编码方式，并且除了字符串的末尾处，字符串里面不能包含空字符。使得C字符串只能保存文本数据,而不能保存像图片、音频、视频、压缩文件这样的二进制数据。</p>
<p>Redis可以适用于各种不同的使用场景,SDS的API都是二进制安全的(binary-safe),所有 SDS API都会以处理二进制的方式来处理SDs存放在buf数组里的数据</p>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><h3 id="API返回后不能确定内部是否重新分配了空间"><a href="#API返回后不能确定内部是否重新分配了空间" class="headerlink" title="API返回后不能确定内部是否重新分配了空间"></a>API返回后不能确定内部是否重新分配了空间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s = sdscat(s, <span class="string">"Hello world"</span>);</div></pre></td></tr></table></figure>
<p>s既是参数，又作为了返回值，原因是我们在调用sdscat函数之前不确定s的剩余空间是否足够分配出data长度的字节，如果不够的话，内部会重新malloc空间，然后把目前的sds包括头部全部挪过去，这样的话如果我们没有把返回的地址重新赋值给s,那么s实际上是失效的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解析Redis的一个底层数据结构——简单动态数组，讨论起优点和不足&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="https://www.liuin.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>初识Redis</title>
    <link href="https://www.liuin.cn/2018/03/19/%E5%88%9D%E8%AF%86Redis/"/>
    <id>https://www.liuin.cn/2018/03/19/初识Redis/</id>
    <published>2018-03-19T10:41:15.000Z</published>
    <updated>2018-03-19T11:16:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是我在认识Redis过程中的一些笔记</p>
<a id="more"></a>
<h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>官网的介绍：</p>
<blockquote>
<p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.</p>
</blockquote>
<p>简单来说就是一个数据存储在内存中的一个key-value存储系统。</p>
<p>通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。而键（key）只能是字符串类型（String）</p>
<h2 id="Redis有什么优势"><a href="#Redis有什么优势" class="headerlink" title="Redis有什么优势"></a>Redis有什么优势</h2><h3 id="支持多种数据结构k"><a href="#支持多种数据结构k" class="headerlink" title="支持多种数据结构k"></a>支持多种数据结构k</h3><p>key-value系统中的值支持多种数据结构：字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)。使得我们使用的时候更加方便，更容易和已有的代码进行整合</p>
<h3 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h3><p>redis使用rdb和aof做数据的持久化存储。主从数据同时，生成rdb文件，并利用缓冲区添加新的数据更新操作做对应的同步。将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</p>
<h3 id="性能好"><a href="#性能好" class="headerlink" title="性能好"></a>性能好</h3><p>因为数据是存储在内存中，所以读写速度非常高。Redis能读的速度是110000次/s,写的速度是81000次/s 。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>Redis的所有操作都是原子的，同时支持几个操作合并以后的原子性</p>
<h3 id="丰富的特性"><a href="#丰富的特性" class="headerlink" title="丰富的特性"></a>丰富的特性</h3><p>支持pulish/subscribe、key过期等特性</p>
<h2 id="Redis有什么缺点"><a href="#Redis有什么缺点" class="headerlink" title="Redis有什么缺点"></a>Redis有什么缺点</h2><h3 id="使用内存，资源有限"><a href="#使用内存，资源有限" class="headerlink" title="使用内存，资源有限"></a>使用内存，资源有限</h3><p>因为数据存储在内存中，单台机器的存储数据量跟机器本身的内存大小有很大的关系。虽然redis本身有key过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。</p>
<h2 id="Redis-适用场景"><a href="#Redis-适用场景" class="headerlink" title="Redis 适用场景"></a>Redis 适用场景</h2><p>Redis因为其性能非常，所以很多在普通数据上运行不够理想的功能使用Redis都能够得到比较好的效果</p>
<h3 id="需要快速排序的相关应用"><a href="#需要快速排序的相关应用" class="headerlink" title="需要快速排序的相关应用"></a>需要快速排序的相关应用</h3><p>像排行榜、过期项目这些功能需要我们快速排序并进行更新，我们就可以使用到Redis</p>
<h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p>在很多普通数据库中实现一个计数器的功能往往会遇到写入敏感等一些问题。这个在Redis中能够有很好的解决：Redis支持原子递增（atomic increment）</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Redis能够替代memcached，让你的缓存从只能存储数据变得能够更新数据，因此你不再需要每次都重新生成数据了。</p>
<h2 id="安装及使用"><a href="#安装及使用" class="headerlink" title="安装及使用"></a>安装及使用</h2><p>这里可以参考官方文档或者<a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="external">菜鸟教程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是我在认识Redis过程中的一些笔记&lt;/p&gt;
    
    </summary>
    
      <category term="开发随笔" scheme="https://www.liuin.cn/categories/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》笔记 高级主题部分</title>
    <link href="https://www.liuin.cn/2018/03/18/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98%E9%83%A8%E5%88%86/"/>
    <id>https://www.liuin.cn/2018/03/18/《C-Primer》笔记-高级主题部分/</id>
    <published>2018-03-18T11:17:21.000Z</published>
    <updated>2018-04-03T01:05:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》笔记 高级主题部分，时间关系只看了其中一部分</p>
<a id="more"></a>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>大型程序往往会使用多个独立开发的库,这些库又会定义大量的全局名字,如类、函数和模板等。当应用程序用到多个供应商提供的库时,不可避免地会发生某些名字相互冲突的情况。多个库将名字放置在全局命名空间中将引发命名空间污染( namespace pollution)。</p>
<p><strong>命名空间</strong>( namespace)为防止名字冲突提供了更加可控的机制。<strong>命名空间分割了全局命名空间,其中每个命名空间是一个作用域</strong>。通过在某个命名空间中定义库的名字,库的作者(以及用户1)可以避免全局名字固有的限制。</p>
<h3 id="命名空间定义"><a href="#命名空间定义" class="headerlink" title="命名空间定义"></a>命名空间定义</h3><p>一个命名空间的定义包含两部分:首先是关键字 name space,随后是命名空间的名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内,主要包括:类、变量(及其初始化操作)、函数(及其定义)、模板和其他命名空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> cplusplus_primer &#123; </div><div class="line">    <span class="keyword">class</span> Sales_data &#123; / * ... * /&#125;; </div><div class="line">    Sales_data <span class="keyword">operator</span>+(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;); </div><div class="line">    <span class="keyword">class</span> Query &#123; <span class="comment">/* ... */</span> &#125;; </div><div class="line">    <span class="keyword">class</span> Query_base &#123; <span class="comment">/* ... */</span>&#125;; </div><div class="line">&#125; <span class="comment">// like blocks, namespaces do not end with a semicolon</span></div></pre></td></tr></table></figure>
<blockquote>
<p>每一个命名空间都是一个作用域</p>
</blockquote>
<p>和其他作用域类似,命名空间中的每个名字都必须表示该空间内的唯一实体。因为不同命名空间的作用域不同,所以在不同命名空间内可以有相同名字的成员。</p>
<blockquote>
<p>命名空间可以不连续</p>
</blockquote>
<p>命名空间可以定义在几个不同的部分,这点与其他作用域不太一样。命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件组成一个命名空间。此时,命名空间的组织方式类似于我们管理自定义类及函数的方式</p>
<ul>
<li>命名空间的一部分成员的作用是定义类,以及声明作为类接口的函数及对象,则这些成员应该置于头文件中,这些头文件将被包含在使用了这些成员的文件中。</li>
<li>命名空间成员的定义部分则置于另外的源文件中</li>
</ul>
<blockquote>
<p>定义命名空间成员</p>
</blockquote>
<p>假定作用域中存在合适的声明语句,则命名空间中的代码可以使用同一命名空间定义的名字的简写形式:</p>
<blockquote>
<p>全局命名空间</p>
</blockquote>
<p>全局作用域中定义的名字(即在所有类、函数及命名空间之外定义的名字)也就是定义在<strong>全局命名空间</strong>( global namespace)中。全局命名空间以隐式的方式声明,并且在所有程序中都存在。全局作用域中定义的名字被隐式地添加到全局命名空间中。</p>
<h3 id="使用命名空间成员"><a href="#使用命名空间成员" class="headerlink" title="使用命名空间成员"></a>使用命名空间成员</h3><p>像 namespace_name:: member_name 这样使用命名空间的成员显然非常烦琐,特别是当命名空间的名字很长时尤其如此。幸运的是,我们可以通过一些其他更简便的方法使用命名空间的成员。</p>
<blockquote>
<p>命名空间的别名</p>
</blockquote>
<p>命名空间的别名( namespace alias)使得我们可以为命名空间的名字设定一个短得多的同义词。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> primer = cplusplus_primer;</div></pre></td></tr></table></figure>
<blockquote>
<p>using声明：扼要概述</p>
</blockquote>
<p>一条using声明( using declaration)语句一次只引入命名空间的一个成员。它使得我们可以清楚地知道程序中所用的到底是哪个名字。</p>
<p>using声明引入的名字遵守与过去一样的作用域规则:它的有效范围从uS1ng声明的地方开始,一直到 using声明所在的作用域结束为止。在此过程中,外层作用域的同名实体将被隐藏。未加限定的名字只能在 using声明所在的作用域以及其内层作用域中使用。</p>
<blockquote>
<p>using 指示</p>
</blockquote>
<p>using指示( using directive)和 using声明类似的地方是,我们可以使用命名空间名字的简写形式:和 using声明不同的地方是,我们无法控制哪些名字是可见的,因为所有名字都是可见的</p>
<p>using指示以关键字using开始,后面是关键字 namespace以及命名空间的名字。</p>
<blockquote>
<p>using 指示与作用域</p>
</blockquote>
<p>using指示引入的名字的作用域远比 using声明引入的名字的作用域复杂。如我们所知,uS1ng声明的名字的作用域与uS1ng声明语句本身的作用域一致,从效果上看就好像 using声明语句为命名空间的成员在当前作用域内创建了一个别名一样。</p>
<p>using指示所做的绝非声明别名这么简单。相反,<strong>它具有将命名空间成员提升到包含命名空间本身和using指示的最近作用域的能力</strong>。    </p>
<blockquote>
<p>类、命名空间与作用域</p>
</blockquote>
<p>对命名空间内部名字的查找遵循常规的查找规则:即由内向外依次查找每个外层作用域。外层作用域也可能是一个或多个嵌套的命名空间,直到最外层的全局命名空间查找过程终止。只有位于开放的块中且在使用点之前声明的名字才被考虑</p>
<h2 id="tuple类型"><a href="#tuple类型" class="headerlink" title="tuple类型"></a>tuple类型</h2><p>tuple是类似pair的模板。每个pair的成员类型都不相同,但每个pair都恰好有两个成员。不同 tuple类型的成员类型也不相同,但<strong>一个tup1e可以有任意数量的成员</strong>。每个确定的 tuple类型的成员数目是固定的,但一个tuple类型的成员数目可以与另一个 tuple类型不同。</p>
<p>当我们希望将一些数据组合成单一对象,但又不想麻烦地定义一个新数据结构来表示这些数据时,tup1e是非常有用的。</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209268356387.jpg" alt=""></p>
<p>我们可以将 tuple看作一个“快速而随意”的数据结构。</p>
<h3 id="定义和初始化tuple"><a href="#定义和初始化tuple" class="headerlink" title="定义和初始化tuple"></a>定义和初始化tuple</h3><p>当我们定义一个 tuple时,需要指出每个成员的类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD; <span class="comment">// all three members set to 0 tuple&lt;string,</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;, <span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; someVal(<span class="string">"constants"</span>, &#123;<span class="number">3.14</span>, <span class="number">2.718</span>&#125;, <span class="number">42</span>, &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);</div></pre></td></tr></table></figure>
<p>当我们创建一个tup1e对象时,可以使用 tuple的默认构造函数,它会对每个成员进行值初始化;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">// error</span></div><div class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;   <span class="comment">// OK</span></div></pre></td></tr></table></figure>
<p>类似 make_pair函数,标准库定义了 make_tuple函,我们还可以用它来生成 tuple对象。</p>
<blockquote>
<p>访问tuple的成员</p>
</blockquote>
<p>tuple的成员都是未命名的。要访问一个 tuple的成员,就要使用一个名为get的标准库函数模板。为了使用get,我们必须指定一个显式模板实参,它指出我们想要访问第几个成员。我们传递给qet一个tup1e对象,它返回指定成员的引用:</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209364781943.jpg" alt=""></p>
<p>尖括号中的值必须是一个整型常量表达式。</p>
<p>如果不知道一个tup1e准确的类型细节信息,可以用两个辅助类模板来查询tuple成员的数量和类型:</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209366456481.jpg" alt=""></p>
<blockquote>
<p>关系和相等运算符</p>
</blockquote>
<p>tuple 的关系和相等运算符的行为类似容器的对应操作。</p>
<h3 id="使用tuple返回多个值"><a href="#使用tuple返回多个值" class="headerlink" title="使用tuple返回多个值"></a>使用tuple返回多个值</h3><p>tuple的一个常见用途是从一个函数返回多个值。</p>
<blockquote>
<p>返回tuple的函数</p>
</blockquote>
<p><img src="https://data2.liuin.cn/2018-03-13-15209367806251.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》笔记 高级主题部分，时间关系只看了其中一部分&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C/C++" scheme="https://www.liuin.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 题解——Longest Valid Parentheses</title>
    <link href="https://www.liuin.cn/2018/03/18/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Longest-Valid-Parentheses/"/>
    <id>https://www.liuin.cn/2018/03/18/LeetCode-题解——Longest-Valid-Parentheses/</id>
    <published>2018-03-18T01:52:16.000Z</published>
    <updated>2018-03-18T02:18:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题解——Longest Valid Parentheses</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个括号字符串，求出其中匹配的子字符串的最大长度</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>一个思路是用动态规划思想：用数组dp[i]表示以s[i]结尾的匹配子字符串的长度，这样我们可以得到状态转移方程：</p>
<p><img src="https://data2.liuin.cn/2018-03-18-15213386227746.jpg" alt=""></p>
<p>其中后面一个分支表示的情况是，最后以后<code>)</code>跳过前面的已经能够匹配的子字符串能和其前面的<code>(</code>匹配</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = s.length(), res = <span class="number">0</span>;</div><div class="line">        <span class="comment">// len+1 数组，最前面一个当做0</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(len+<span class="number">1</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i&gt;<span class="number">1</span> &amp;&amp; s[i<span class="number">-1</span>] == <span class="string">')'</span> &amp;&amp; s[i<span class="number">-2</span>] == <span class="string">'('</span>) dp[i]=dp[i<span class="number">-2</span>] + <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(i&gt;<span class="number">1</span> &amp;&amp; s[i<span class="number">-1</span>] == <span class="string">')'</span> &amp;&amp; s[i<span class="number">-2</span>] == <span class="string">')'</span> &amp;&amp; s[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>] == <span class="string">'('</span>) dp[i] = dp[i<span class="number">-1</span>] + dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>] + <span class="number">2</span>;</div><div class="line">            res = max(res, dp[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="利用栈"><a href="#利用栈" class="headerlink" title="利用栈"></a>利用栈</h3><p>这种括号字符串的题目，大部分都能够用栈来解决，按照以往的思路：遇到左括号入栈、遇到右括号出栈，这样输入匹配的括号之后，栈里面的东西不多不少，如果此时我们记录，第一个入栈时的位置，那么最后一个出栈的时候就可以通过位置（index）计算其长度了。</p>
<p>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</div><div class="line">        <span class="keyword">int</span> len = s.length();</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        st.push(<span class="number">-1</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</div><div class="line">                st.push(i);</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                st.pop();</div><div class="line">                <span class="comment">// 栈为空的时候表示新的串匹配开始</span></div><div class="line">                <span class="keyword">if</span>(st.empty())</div><div class="line">                    st.push(i);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                &#123;</div><div class="line">                    res = max(res, i-st.top());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题解——Longest Valid Parentheses&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.liuin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="DP" scheme="https://www.liuin.cn/tags/DP/"/>
    
      <category term="LeetCode" scheme="https://www.liuin.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX 数学公式</title>
    <link href="https://www.liuin.cn/2018/03/16/LaTeX-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <id>https://www.liuin.cn/2018/03/16/LaTeX-数学公式/</id>
    <published>2018-03-16T09:16:44.000Z</published>
    <updated>2018-03-16T11:03:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>平时写Markdown的时候难免会遇到一些用数学公式的情况，这里总结一些常用数学公式的写法。</p>
<a id="more"></a>
<h2 id="数学结构"><a href="#数学结构" class="headerlink" title="数学结构"></a>数学结构</h2><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p>常用的上下标结构</p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211921156811.jpg" alt=""></p>
<table>
<thead>
<tr>
<th>公式</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$A_{ij} = 2^{i+j}$</code></td>
<td>$A_{ij} = 2^{i+j}$</td>
</tr>
<tr>
<td><code>$A = 90^\circ$</code></td>
<td>$A = 90^\circ$</td>
</tr>
<tr>
<td><code>$\int_0^1 f(t) \dif t = \iint_D g(x, y) \dif x \dif y$</code></td>
<td>$\int_0^1 f(t) \cos t = \iint_D g(x, y) \cos x \sin y$</td>
</tr>
</tbody>
</table>
<h3 id="上下画线与花括号"><a href="#上下画线与花括号" class="headerlink" title="上下画线与花括号"></a>上下画线与花括号</h3><ul>
<li>\overline和\underline命令可用来在公式的上方和下方划横线</li>
<li>\overbrace和\underbrace带上花括号</li>
</ul>
<table>
<thead>
<tr>
<th>公式</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\overline{a+b} = \overline a \overline b$</code></td>
<td>$\overline{a+b} = \overline a \overline b$</td>
</tr>
<tr>
<td><code>$\overbrace {a+b+c} = \underbrace{1+2+3}$</code></td>
<td>$\overbrace {a+b+c} = \underbrace{1+2+3}$</td>
</tr>
</tbody>
</table>
<h3 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h3><p>分式使用<code>\face{分子}{分母}</code>得到</p>
<table>
<thead>
<tr>
<th>公式</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\frac{1}{\frac 12 (a+b)} = \frac{2}{a+b}$</code></td>
<td>$\frac{1}{\frac 12 (a+b)} = \frac{2}{a+b}$</td>
</tr>
</tbody>
</table>
<h3 id="根式"><a href="#根式" class="headerlink" title="根式"></a>根式</h3><p>根式是又一种常见的数学结构,用单参数的命令<code>\sqrt</code>得到,同时可以带一个可选参数,表示开方的次数</p>
<table>
<thead>
<tr>
<th>公式</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\sqrt[n] {\frac{x^2 + \sqrt 2}{x+y}}$</code></td>
<td>$\sqrt[n] {\frac{x^2 + \sqrt 2}{x+y}}$</td>
</tr>
</tbody>
</table>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>各种外括号不同的矩阵：</p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211932205959.jpg" alt=""></p>
<p>在矩阵环境中,不同的列用符号&amp;分隔,行用\分隔,矩阵每列中元素居中对齐</p>
<table>
<thead>
<tr>
<th>公式</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$ A = \begin{pmatrix} a &amp; b &amp; c \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; a \end{pmatrix}$</code></td>
<td>$ A = \begin {pmatrix} a &amp; b &amp; c \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; a \end {pmatrix}$</td>
</tr>
<tr>
<td><code>$ A = \begin{bmatrix} a_{11} &amp; \dots &amp; a_{1n} \\  &amp; \ddots &amp; \vdots \\ 0 &amp; &amp; a_{nn} \end{bmatrix} $</code></td>
<td>$ A = \begin{bmatrix} a_{11} &amp; \dots &amp; a_{1n} \\  &amp; \ddots &amp; \vdots \\ 0 &amp; &amp; a_{nn} \end{bmatrix} $</td>
</tr>
</tbody>
</table>
<h2 id="符号与类型"><a href="#符号与类型" class="headerlink" title="符号与类型"></a>符号与类型</h2><h3 id="字母表和普通符号"><a href="#字母表和普通符号" class="headerlink" title="字母表和普通符号"></a>字母表和普通符号</h3><p><img src="https://data2.liuin.cn/2018-03-16-15211956280206.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211956379753.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211956477483.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211956663623.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211956803907.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211956929506.jpg" alt=""></p>
<h3 id="数学算子"><a href="#数学算子" class="headerlink" title="数学算子"></a>数学算子</h3><p><img src="https://data2.liuin.cn/2018-03-16-15211957120206.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211957244734.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211957348221.jpg" alt=""></p>
<h3 id="二元运算符与关系符"><a href="#二元运算符与关系符" class="headerlink" title="二元运算符与关系符"></a>二元运算符与关系符</h3><p><img src="https://data2.liuin.cn/2018-03-16-15211957624199.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211957708521.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211957833150.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211957967157.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211958049898.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211958460225.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211958550071.jpg" alt=""></p>
<h3 id="括号与定界符"><a href="#括号与定界符" class="headerlink" title="括号与定界符"></a>括号与定界符</h3><p><img src="https://data2.liuin.cn/2018-03-16-15211959051369.jpg" alt=""></p>
<h3 id="标点"><a href="#标点" class="headerlink" title="标点"></a>标点</h3><p><img src="https://data2.liuin.cn/2018-03-16-15211959300033.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211959403756.jpg" alt=""></p>
<h2 id="在Hexo中使用LaTeX编辑数学公式"><a href="#在Hexo中使用LaTeX编辑数学公式" class="headerlink" title="在Hexo中使用LaTeX编辑数学公式"></a>在Hexo中使用LaTeX编辑数学公式</h2><p>在Hexo中编辑数学公式一般用的是<a href="https://github.com/hexojs/hexo-math" target="_blank" rel="external">这个</a>插件</p>
<p>其中有一个比较坑的点就是，不能够识别<code>\</code>和<code>_</code>这些符号，因为其在Markdown语法中也有一些意义，所以在某些情况下使用的时候还要在前面加一个<code>\</code>进行转义：</p>
<ul>
<li>后面接<code>,</code> 各种括号的时候，前面<code>_</code>所表示符号前面要加<code>\</code>转义</li>
</ul>
<p>另外可以更换markdown的渲染引擎，参考<a href="https://jdhao.github.io/2017/10/06/hexo-markdown-latex-equation/" target="_blank" rel="external">这里</a></p>
<p>主要参考：《LaTeX 入门》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时写Markdown的时候难免会遇到一些用数学公式的情况，这里总结一些常用数学公式的写法。&lt;/p&gt;
    
    </summary>
    
      <category term="开发随笔" scheme="https://www.liuin.cn/categories/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="LaTeX" scheme="https://www.liuin.cn/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 题解——Substring with Concatenation of All Words</title>
    <link href="https://www.liuin.cn/2018/03/15/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Substring-with-Concatenation-of-All-Words/"/>
    <id>https://www.liuin.cn/2018/03/15/LeetCode-题解——Substring-with-Concatenation-of-All-Words/</id>
    <published>2018-03-15T03:21:04.000Z</published>
    <updated>2018-03-15T03:22:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题解——Substring with Concatenation of All Words</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个字符串，和一组匹配字符串（vector），其中每一个字符串的长度是相同的，后面的这一组字符串可以形成一个组合，比如[“ab”,”cd”]可以组合成的字符串有：”abcd” “cdab”。题目要求我们在给定的这个字符串中查找出现后面这些组合的子串的位置（给出首字母位置）</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目中给出的匹配字符串组中每一个字符串的长度是相同的这个条件降低了题目的难度，如果从普通的字符串匹配的思路下手的话，就是每次从原串截取对比的长度是一样的，然后截取的字符串可以分割成几个长度相同的子字符串，我们只要判断这几个字符子串是否都在给出的这组匹配字符串中就行了。</p>
<p>这里使用两个unordered_map(Hash实现，性能更优)来判断是否都在这组字符串中，第一个map存储匹配字符串组中的字符串和出现的次数（都是1），第二个map存储截取的字符串分割以后的子串（并且在匹配字符串组中）以及其出现的次数，如果其次数大于1，表示截取的这段不符合条件，进行下一次匹配。</p>
<p>map有两个作用：查找字符串；记录出现次数</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        <span class="comment">// 用来进行对比的map</span></div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; contrast;</div><div class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> s : words)</div><div class="line">        &#123;</div><div class="line">            contrast[s]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> slen = s.length(), wlen = words[<span class="number">0</span>].length(), wsize = words.size();</div><div class="line">        <span class="comment">// 依次截取一定长度的字符串进行匹配</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;slen-wsize*wlen+<span class="number">1</span>; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; tem;</div><div class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(; j&lt;wsize; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">// 分割以后的每一个字符串</span></div><div class="line">                <span class="built_in">string</span> stem = s.substr(i+j*wlen, wlen);</div><div class="line">                <span class="comment">// 判断是否在匹配字符串组中</span></div><div class="line">                <span class="keyword">if</span>(contrast.find(stem) != contrast.end())</div><div class="line">                &#123;</div><div class="line">                    tem[stem]++;</div><div class="line">                    <span class="comment">// 出现次数超过1，放弃</span></div><div class="line">                    <span class="keyword">if</span>(tem[stem] &gt; contrast[stem])</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(j == wsize)</div><div class="line">                res.push_back(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题解——Substring with Concatenation of All Words&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.liuin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://www.liuin.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Coursera 吴恩达机器学习 课程笔记</title>
    <link href="https://www.liuin.cn/2018/03/13/Coursera-%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.liuin.cn/2018/03/13/Coursera-吴恩达机器学习-课程笔记/</id>
    <published>2018-03-13T06:27:40.000Z</published>
    <updated>2018-03-16T11:01:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Coursera 吴恩达机器学习 课程笔记</p>
<a id="more"></a>
<h1 id="监督学习和无监督学习"><a href="#监督学习和无监督学习" class="headerlink" title="监督学习和无监督学习"></a>监督学习和无监督学习</h1><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>维基百科中的定义：</p>
<blockquote>
<p>监督式学习（英语：Supervised learning），是一个机器学习中的方法，可以由训练资料中学到或建立一个模式（函数 / learning model），并依此模式推测新的实例。训练资料是由输入物件（通常是向量）和预期输出所组成。函数的输出可以是一个连续的值（称为回归分析），或是预测一个分类标签（称作分类）</p>
</blockquote>
<p>在监督学习中, 我们的预测结果可以是连续值, 也可以是离散值. 我们根据这样的属性将监督学习氛围回归问题和分类问题.</p>
<h3 id="监督学习举例"><a href="#监督学习举例" class="headerlink" title="监督学习举例"></a>监督学习举例</h3><blockquote>
<p>回归问题</p>
</blockquote>
<p>通过给定的一个房子的面积来预测这个房子在市场中的价格. 这里的房子的面积就是特征, 房子的价格就是一个输出值. 为了解决这个问题, 我们获取了大量的房地产数据, 每一条数据都包含房子的面积及其对应价格. 第一, 我们的数据不仅包含房屋的面积, 还包含其对应的价格, 而我们的目标就是通过面积预测房价. 所以这应该是一个监督学习; 其次, 我们的输出数据房价可以看做是连续的值, 所以这个问题是一个回归问题.</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208368350754.jpg" alt=""></p>
<blockquote>
<p>分类问题</p>
</blockquote>
<p>我们的目标应该是要对数据进行分类. 现在我们的数据是有关乳腺癌的医学数据, 它包含了肿瘤的大小以及该肿瘤是良性的还是恶性的. 我们的目标是给定一个肿瘤的大小来预测它是良性还是恶性. 我们可以用0代表良性，1代表恶性. 这就是一个分类问题, 因为我们要预测的是一个离散值. </p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208368814648.jpg" alt=""></p>
<p>在这个例子中特征只有一个即瘤的大小。 对于大多数机器学习的问题, 特征往往有多个(上面的房价问题也是, 实际中特征不止是房子的面积). 例如下图， 有“年龄”和“肿瘤大小”两个特征。</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208369551948.jpg" alt=""></p>
<h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>在无监督学习中, 我们的数据并没有给出特定的标签, 例如上面例子中的房价或者是良性还是恶性. 我们目标也从预测某个值或者某个分类变成了寻找数据集中特殊的或者对我们来说有价值结构. </p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208370522571.jpg" alt=""></p>
<h3 id="无监督学习举例"><a href="#无监督学习举例" class="headerlink" title="无监督学习举例"></a>无监督学习举例</h3><blockquote>
<p>新闻分类</p>
</blockquote>
<p>Google News搜集网上的新闻，并且根据新闻的主题将新闻分成许多簇, 然后将在同一个簇的新闻放在一起。如图中红圈部分都是关于BP Oil Well各种新闻的链接，当打开各个新闻链接的时候，展现的都是关于BP Oil Well的新闻。</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208370968972.jpg" alt=""></p>
<blockquote>
<p>根据给定基因将人群分类</p>
</blockquote>
<p><img src="https://data2.liuin.cn/2018-03-12-15208371698906.jpg" alt=""></p>
<h1 id="单变量线性回归"><a href="#单变量线性回归" class="headerlink" title="单变量线性回归"></a>单变量线性回归</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="训练集"><a href="#训练集" class="headerlink" title="训练集"></a>训练集</h3><p>由训练样例(training example)组成的集合就是训练集(training set)</p>
<h3 id="假设函数"><a href="#假设函数" class="headerlink" title="假设函数"></a>假设函数</h3><p>使用某种学习算法对训练集的数据进行训练, 我们可以得到假设函数(Hypothesis Function)</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208382454378.jpg" alt=""></p>
<p>我们使用如下方法表示假设函数，</p>
<p>$$ {h_\theta(x)=\theta_0+\theta_1x} $$</p>
<p>以上这个模型就叫做单变量的线性回归(Linear Regression with One Variable).</p>
<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><h3 id="什么是代价函数"><a href="#什么是代价函数" class="headerlink" title="什么是代价函数"></a>什么是代价函数</h3><p>只要我们知道了假设函数, 我们就可以进行预测了. 关键是, 假设函数中有两个未知的量$\theta_0$,$\theta_1$. 当选择不同的$\theta_0$和$\theta_1$时, 我们模型的效果肯定是不一样的. 我们的想法是选择某个$\theta_0$和$\theta_1$，使得对于训练样例$(x,y)$，$h_\theta(x)$最“接近”$y$。越是接近, 代表这个假设函数越是准确, 这里我们选择均方误差来作为衡量标准, 即我们想要每个样例的估计值与真实值之间差的平方的均值最小:（其中$1/2$只是为了我们后面计算方便）</p>
<p>$$<br>{\mathop{min}\limits_{\theta_0,\theta_1}\frac{1}{2m}\sum_{i=0}^m\left(h_\theta(x^{(i)})-y^{(i)}\right)^2}<br>$$</p>
<p>记作：</p>
<p>$${J(\theta_0,\theta_1) = \frac{1}{2m}\sum_{i=0}^m\left(h_\theta(x^{(i)})-y^{(i)}\right)^2 }$$</p>
<p>这样就得到了我们的代价函数(cost function), 也就是我们的优化目标, 我们想要代价函数最小:</p>
<p>$$ \mathop{min}\limits_{\theta_0,\theta_1}J(\theta_0,\theta_1)$$</p>
<h3 id="代价函数和假设函数"><a href="#代价函数和假设函数" class="headerlink" title="代价函数和假设函数"></a>代价函数和假设函数</h3><p>对于不同的$\theta_1$，对应着不同的假设函数$h_\theta(x)$，于是就有了不同的代价函数$J (\theta_1)$的值。将这些点连接起来就可以得到$J(\theta_1)$和$\theta_1$关系的图像：</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208395529904.jpg" alt=""></p>
<p>我们的目标是找到一个$\theta$使得$J(\theta_1)$最小</p>
<p>如果我们考虑两个变量，能够绘制$J(\theta_0,\theta_1)$的图形如下</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208397051963.jpg" alt=""></p>
<p>由于3D图形不太方便我们研究，我们就使用二维的等高线(上图右上角教授写的contour plots/figures)，这样看上去比较清楚一些。越靠近中心表示$J(\theta_0,\theta_1)$值越小</p>
<h2 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h2><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>梯度下降算法是一种优化算法, 它可以帮助我们找到一个函数的局部极小值点. 它不仅仅可以用在线性回归模型中, 在机器学习许多其他的模型中也可以使用它. 对于我们现在研究的单变量线性回归来说, 我们想要使用梯度下降来找到最优的$\theta_0$,$\theta_1$。</p>
<p>它的思想是，首先随机选择两个$\theta_0$,$\theta_1$，不断改变他们的值使得$J(\theta)$最小，最终找到$J(\theta)$的最小点</p>
<p>可以把梯度下降的过程想象成下山坡, 如果想要尽可能快的下坡, 应该每次都往坡度最大的方向下山.</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208400482188.jpg" alt=""></p>
<p>算法过程：（要注意的是，算法是每次同时改变$\theta_0$和$\theta_1$的值）</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208401837391.jpg" alt=""></p>
<h3 id="梯度和学习率"><a href="#梯度和学习率" class="headerlink" title="梯度和学习率"></a>梯度和学习率</h3><p>学习率$\alpha$会影响梯度下降的幅度。如果$\alpha$的值太小，$\theta$的值每次会变化很小，那么梯度下降就会比较慢；相反，如果$\alpha$过大，$\theta$的值每次就会变化很大，有可能超过最低点，可能导致永远没法到达最低点。</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208404559020.jpg" alt=""></p>
<p>由于随着越来越接近最低点, 相应的梯度(绝对值)也会逐渐减小，所以每次下降程度就会越来越小, 我们并不需要减小$\alpha$的值来减小下降程度。</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208404858375.jpg" alt=""></p>
<h3 id="计算梯度"><a href="#计算梯度" class="headerlink" title="计算梯度"></a>计算梯度</h3><p>将偏导计算出来就得到了完整梯度下降算法：</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208405675961.jpg" alt=""></p>
<p>事实上，用于线性回归的代价函数总是一个凸函数(Convex Function)。这样的函数没有局部最优解，只有一个全局最优解。所以我们在使用梯度下降的时候，总会得到一个全局最优解。</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208406207656.jpg" alt=""></p>
<h1 id="多变量线性回归"><a href="#多变量线性回归" class="headerlink" title="多变量线性回归"></a>多变量线性回归</h1><h2 id="假设函数-1"><a href="#假设函数-1" class="headerlink" title="假设函数"></a>假设函数</h2><p>在之前的单变量线性回归中, 我们的问题只涉及到了房子面积这一个特征。在实际问题中, 会有很多特征. 例如, 除了房子面积, 还有房子的卧室数量, 房子的楼层数, 房子建筑年龄.</p>
<p>在单变量线性回归中假设函数为：</p>
<p>$${h_\theta(x)=\theta_0+\theta_1x}$$</p>
<p>现在对于多变量，可以设其假设函数为：</p>
<p>$${h_\theta(x)=\theta_0+\theta_1x_1+\theta_2x_2+…+\theta_nx_n}$$</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208613808836.jpg" alt=""></p>
<p>得到其向量表示：</p>
<p>$${h_\theta(x)=\theta_0x_0+\theta_1x_1+\theta_2x_2+…+\theta_nx_n= \theta^Tx}$$</p>
<h2 id="梯度下降-1"><a href="#梯度下降-1" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>多变量情况下的梯度下降其实没有区别, 只需要把对应的偏导数项换掉即可</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208618844580.jpg" alt=""></p>
<h2 id="特征处理"><a href="#特征处理" class="headerlink" title="特征处理"></a>特征处理</h2><h3 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h3><p>如果每个特征的范围相差的很大, 梯度下降会很慢. 为了解决这个问题, 我们在梯度下降之前应该对数据做特征归缩放(Feature Scaling)处理, 从而将所有的特征的数量级都在一个差不多的范围之内, 以加快梯度下降的速度.</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208619474872.jpg" alt=""></p>
<p>通常我们需要把特征都缩放到$[-1,1]$(附近)这个范围</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208619856026.jpg" alt=""></p>
<h3 id="均值均一化"><a href="#均值均一化" class="headerlink" title="均值均一化"></a>均值均一化</h3><p>还有一个特征处理的方法就是均值归一化(Mean normalization)</p>
<p>$${x_i=\frac{x_i-\mu_i}{max-min}}$$</p>
<h2 id="代价函数与学习率"><a href="#代价函数与学习率" class="headerlink" title="代价函数与学习率"></a>代价函数与学习率</h2><p>我们可以通过画出$\mathop{min}\limits_{\theta}J(\theta)$与迭代次数的关系来观察梯度下降的运行情况，</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209095236343.jpg" alt=""></p>
<p>出现下面两种情况，应该选择更小的学习率$\alpha$，</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209096625766.jpg" alt=""></p>
<p>注意：</p>
<ul>
<li>如果$\alpha$足够小，，那么$J(\theta)$在每次迭代之后都会减小</li>
<li>如果$\alpha$太小， 梯度下降会进行的非常缓慢.</li>
</ul>
<p>进行尝试的值：<br><img src="https://data2.liuin.cn/2018-03-13-15209097782077.jpg" alt=""></p>
<h2 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h2><p>多项式回归(Polynomial Regression)是研究一个因变量与一个或多个自变量间多项式的回归分析方法。如果自变量只有一个时，称为一元多项式回归；如果自变量有多个时，称为多元多项式回归。</p>
<p>我们可以将房屋的面积作为第一个特征, 面积的平方作为第二个特征, 面积的立方作为第三个特征:</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209102744925.jpg" alt=""></p>
<p>除了三次函数模型, 这里也可以选择平方根函数模型, 如下图所示</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209107024350.jpg" alt=""></p>
<h2 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h2><h3 id="正规方程介绍"><a href="#正规方程介绍" class="headerlink" title="正规方程介绍"></a>正规方程介绍</h3><p>之前我们一直是用的梯度下降求解最优值. 它的缺点就是需要进行很多次迭代才能得到全局最优解. 有没有更好的方法呢? 我们先来看一个最简单的例子, 假设现在的代价函数为$J(\theta)=a\theta^2+b\theta+c$，在导数等于0的时候取到最优解。</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209111273173.jpg" alt=""></p>
<p>下面我们介绍一种向量化的求解方法。首先, 在数据集前加上一列$X_0$，值都为1，然后将所有的变量都放入矩阵$X$中（包括加上的$x_0$）；再将输出值放入向量$y$中. 最后通过公式$$\theta=(X^TX)^{-1}X^Ty$$就可以算出最优解</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209221924071.jpg" alt=""></p>
<p>更通用的表达方式</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209222169590.jpg" alt=""></p>
<h3 id="梯度下降和正规方程的比较"><a href="#梯度下降和正规方程的比较" class="headerlink" title="梯度下降和正规方程的比较"></a>梯度下降和正规方程的比较</h3><p><img src="https://data2.liuin.cn/2018-03-13-15209222993254.jpg" alt=""></p>
<h3 id="正规方程不可逆的情况"><a href="#正规方程不可逆的情况" class="headerlink" title="正规方程不可逆的情况"></a>正规方程不可逆的情况</h3><p>使用正规方程还有一个问题就是$X^TX$可能存在不可逆的情况. 这个时候, 可能是因为我们使用了冗余的特征, 还有一个原因是我们使用了太多的特征(特征的数量超过了样本的数量). 对于这种情况我们可以删掉一些特征或者使用正则化(正则化在后面的课中讲).</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209223711085.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Coursera 吴恩达机器学习 课程笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="https://www.liuin.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》笔记 类设计者的工具部分</title>
    <link href="https://www.liuin.cn/2018/03/11/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7%E9%83%A8%E5%88%86/"/>
    <id>https://www.liuin.cn/2018/03/11/《C-Primer》笔记-类设计者的工具部分/</id>
    <published>2018-03-11T11:58:50.000Z</published>
    <updated>2018-03-13T02:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》笔记 类设计者的工具部分</p>
<a id="more"></a>
<h1 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h1><p>当定义一个类时,我们显式地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作,包括:拷贝构造函数( copy constructor)、拷贝赋值运算符( copy-assignment operator)、移动构造函数(moveconstructor)、移动赋值运算符(move-assignment operator)和析构函数( destructor)。</p>
<h2 id="拷贝、赋值与销毁"><a href="#拷贝、赋值与销毁" class="headerlink" title="拷贝、赋值与销毁"></a>拷贝、赋值与销毁</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>如果一个构造函数的第一个参数是自身类类型的引用,且任何额外参数都有默认值,则此构造函数是拷贝构造函数。</p>
<p>拷贝构造函数的第一个参数必须是一个引用类型,原因我们稍后解释。虽然我们可以定义个接受非 const引用的拷贝构造函数,但此参数几乎总是一个 const的引用。拷贝构造函数在几种情况下都会被隐式地使用。因此,拷贝构造函数通常不应该是 explicit的</p>
<blockquote>
<p>合成拷贝构造函数</p>
</blockquote>
<p>对某些类来说,合成拷贝构造函数( synthesized copy constructor)用来阻止我们拷贝该类类型的对象。而一般情况,<strong>合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中</strong>。</p>
<blockquote>
<p>拷贝初始化</p>
</blockquote>
<p>当使用直接初始化时,我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。当我们使用拷贝初始化(copy initialization)时,我们要求<strong>编译器将右侧运算对象拷贝到正在创建的对象中,如果需要的话还要进行类型转换</strong>。</p>
<blockquote>
<p>参数和返回值</p>
</blockquote>
<p>在函数调用过程中,具有非引用类型的参数要进行拷贝初始化。类似的,当一个函数具有非引用的返回类型时,返回值会被用来初始化调用方的结果。</p>
<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><blockquote>
<p>重载赋值运算符</p>
</blockquote>
<p>重载运算符本质上是函数,其名字由 operator关键字后接表示要定义的运算符的符号组成。因此,赋值运算符就是一个名为 operator=的函数。类似于任何其他函数,运算符函数也有一个返回类型和一个参数列表。</p>
<p>重载运算符的参数表示运算符的运算对象。某些运算符,包括赋值运算符,必须定义为成员函数。如果一个运算符是一个成员函数,其左侧运算对象就绑定到隐式的this参数。对于一个二元运算符,例如赋值运算符,其右侧运算对象作为显式参数传递。</p>
<p>为了与内置类型的赋值保持一致,<strong>赋值运算符通常返回一个指向其左侧运算对象的引用</strong>。另外值得注意的是,标准库通常要求保存在容器中的类型要具</p>
<blockquote>
<p>合成拷贝赋值运算符</p>
</blockquote>
<p>与处理拷贝构造函数一样,如果一个类未定义自己的拷贝赋值运算符,编译器会为它生成一个合成拷贝赋值运算符</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数执行与构造函数相反的操作:构造函数初始化对象的非 static数据成员还可能做一些其他工作;析构函数释放对象使用的资源,并销毁对象的非 static数据成员</p>
<blockquote>
<p>析构函数完成什么工作</p>
</blockquote>
<p>如同构造函数有一个初始化部分和一个函数体,析构函数也有一个函数体和一个析构部分。在一个构造函数中,成员的初始化是在函数体执行之前完成的,且按照它们在类中出现的顺序进行初始化。<strong>在一个析构函数中,首先执行函数体,然后销毁成员。成员按初始化顺序的逆序销毁</strong>。</p>
<blockquote>
<p>什么时候用到析构函数</p>
</blockquote>
<p>无论何时一个对象被销毁,就会自动调用其析构函数:</p>
<ol>
<li>变量在离开其作用域时被销毁。</li>
<li>当一个对象被销毁时,其成员被销毁。</li>
<li>容器(无论是标准库容器还是数组)被销毁时,其元素被销毁。</li>
<li>对于动态分配的对象,当对指向它的指针应用 delete运算符时被销毁</li>
<li>对于临时对象,当创建它的完整表达式结束时被销毁。</li>
</ol>
<blockquote>
<p>合成析构函数</p>
</blockquote>
<p>当一个类未定义自己的析构函数时,编译器会为它定义一个合成析构函数( synthesizeddestructor)。类似拷贝构造函数和拷贝赋值运算符,对于某些类,合成析构函数被用来阻止该类型的对象被销毁。如果不是这种情况，合成析构函数就为空</p>
<p>认识到析构函数体自身并不直接销毁成员是非常重要的。<strong>成员是在析构函数体之后隐含的析构阶段中被销毁的</strong>。在整个对象销毁过程中,析构函数体是作为成员销毁步骤之外的另一部分而进行的。</p>
<h3 id="三-五法则"><a href="#三-五法则" class="headerlink" title="三/五法则"></a>三/五法则</h3><p>如前所述,有三个基本操作可以控制类的拷贝操作:拷贝构造函数、拷贝赋值运算符和析构函数。</p>
<blockquote>
<p>需要析构函数的类也需要拷贝和赋值操作</p>
</blockquote>
<p>当我们决定一个类是否要定义它自己版本的拷贝控制成员时,一个基本原则是<strong>首先确定这个类是否需要一个析构函数。通常,对析构函数的需求要比对拷贝枃造函数或赋偵运算符的需求更为明显</strong>。如果这个类需要一个析构函数,我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。</p>
<blockquote>
<p>需要拷贝操作的类也需要赋值操作，反之亦然</p>
</blockquote>
<p>虽然很多类需要定义所有(或是不需要定义任何)拷贝控制成员,但某些类所要完成的工作,只需要拷贝或赋值操作,不需要析构函数。</p>
<p>这个例子引出了第二个基本原则:如果一个类需要一个拷贝构造函数,几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然—如果一个类需要一个拷贝赋值运篁符,几平可以肯定它也需要一个拷贝构造函数。然而,无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。</p>
<h3 id="使用-default"><a href="#使用-default" class="headerlink" title="使用=default"></a>使用=default</h3><p>我们可以通过将拷贝控制成员定义为= defau1t来显式地要求编译器生成合成的版本</p>
<p><img src="https://data2.liuin.cn/2018-03-05-15202146959452.jpg" alt=""></p>
<h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><p>虽然大多数类应该定义(而且通常也的确定义了)拷贝构造函数和拷贝赋值运算符,但对某些类来说,这些操作没有合理的意义。在此情况下,定义类时必须采用某种机制阻止拷贝或赋值。</p>
<blockquote>
<p>定义删除的函数</p>
</blockquote>
<p>在新标准下,我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数( deletedfunction)来阻止拷贝。删除的函数是这样一种函数:我们虽然声明了它们,但不能以任何方式使用它们]。在函数的参数列表后面加上=de1ete来指出我们希望将它定义为删除的:</p>
<blockquote>
<p>析构函数不能是删除的成员</p>
</blockquote>
<p>值得注意的是,我不能删除析构函数。如果析构函数被删除,就无法销毁此类型的对象了。对于一个删除了析构函数的类型,编译器将不允许定义该类型的变量或创建该类的临时对象。而且,如果一个类有某个成员的类型删除了析构函数,我们也不能定义该类</p>
<blockquote>
<p>private 拷贝控制</p>
</blockquote>
<p>在新标准发布之前,类是通过将其拷贝构造函数和拷贝赋值运算符声明为 private的来阻止拷贝:</p>
<p><img src="https://data2.liuin.cn/2018-03-05-15202148530112.jpg" alt=""></p>
<p>友元和成员函数仍旧可以拷贝对象。为了阻止友元和成员函数进行拷贝,我们将这些拷贝控制成员声明为 private的,但并不定义它们。</p>
<h2 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h2><p>通常,管理类外资源的类必须定义拷贝控制成员。某些类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数,那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。为了定义这些成员,我首先必须确定此类型对象的拷贝语义。一般来说,有两种选择:可以定义拷贝操作,<strong>使类的行为看起来像一个值或者像一个指针</strong>。</p>
<p>类的行为像一个值,意味着它应该也有自己的状态。当我们拷贝一个像值的对象时,副本和原对象是完全独立的。改变副本不会对原对象有任何影响,反之亦然。</p>
<p>行为像指针的类则共享状态。当我们拷贝一个这种类的对象时,副本和原对象使用相同的底层数据。改变副本也会改变原对象,反之亦然</p>
<h3 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h3><p>为了提供类值的行为,对于类管理的资源,每个对象都应该拥有一份自己的拷贝。这意味着对于ps指向的 string,每个 Hasptr对象都必须有自己的拷贝。</p>
<blockquote>
<p>类值拷贝赋值运算符</p>
</blockquote>
<p>赋值运算符通常组合了析构函数和构造函数的操作。类似析构函数,赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数,赋值操作会从右侧运算对象拷贝数据。</p>
<h3 id="定义行为像指针的类"><a href="#定义行为像指针的类" class="headerlink" title="定义行为像指针的类"></a>定义行为像指针的类</h3><p>对于行为类似指针的类,我们需要为其定义拷贝构造函数和拷贝赋值运算符,来拷贝指针成员本身而不是它指向的 string。我们的类仍然需要自己的析构函数来释放接受string参数的构造函数分配的内存。</p>
<p>令一个类展现类似指针的行为的最好方法是使用 share_ptr来管理类中的资源</p>
<p>但是,有时我们希望直接管理资源。在这种情况下,使用<strong>引用计数</strong>( reference count)就很有用了。</p>
<blockquote>
<p>定义一个使用引用计数的类</p>
</blockquote>
<p><img src="https://data2.liuin.cn/2018-03-05-15202156946283.jpg" alt=""></p>
<h2 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h2><p>除了定义拷贝控制成员,管理资源的类通常还定义一个名为swap的函数。对于那些与重排元素顺序的算法一起使用的类,定义swap是非常重要的。这类算法在需要交换两个元素时会调用swap。</p>
<p>为了交换两个对象，我们需要一次拷贝和两次赋值</p>
<blockquote>
<p>在赋值运算符中使用swap</p>
</blockquote>
<p>定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为拷贝并交换( copy and swap)的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换</p>
<h2 id="动态内存管理类"><a href="#动态内存管理类" class="headerlink" title="动态内存管理类"></a>动态内存管理类</h2><p>某些类需要在运行时分配可变大小的内存空间。这种类通常可以(并且如果它们确实可以的话,一般应该)使用标准库容器来保存它们的数据。</p>
<p>但是,这一策略并不是对每个类都适用:某些类需要自己进行内存分配。这些类一般来说必须定义自己的拷贝控制成员来管理所分配的内存</p>
<h2 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h2><p>新标准的一个最主要的特性是可以移动而非拷贝对象的能力。在某些情况下,移动而非拷贝对象会大幅度提升性能。</p>
<p>在旧C++标准中,没有直接的方法移动对象。因此,即使不必拷贝对象的情况下,我们也不得不拷贝。如果对象较大,或者是对象本身要求分配内存空间(如 string),进行不必要的拷贝代价非常高。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>为了支持移动操作,新标准引入了一种新的引用类型——<strong>右值引用</strong>( rvalue reference)。所谓右值引用就是必须绑定到右值的引用。我们通过&amp;&amp;而不是&amp;来获得右值引用。如我们将要看到的,右值引用有一个重要的性质——一只能绑定到一个将要销毁的对象。</p>
<p>一般而言,一个左值表达式表示的是一个对象的身份,而一个右值表达式表示的是对象的值</p>
<p>类似任何引用,一个右值引用也不过是某个对象的另一个名字而已。如我们所知,对于常规引|用(为了与右值引用区分开来,我们可以称之为左值引用( Ivalue reference),我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用有着完全相反的绑定特性:<strong>我们可以将一个右值引用绑定到这类表达式上,但不能将一个右值引用直接绑定到一个左值上</strong></p>
<p><img src="https://data2.liuin.cn/2018-03-05-15202204986268.jpg" alt=""></p>
<blockquote>
<p>左值持久，右值短暂</p>
</blockquote>
<p>考察左值和右值表达式的列表,两者相互区别之处就很明显了:左值有持久的状态而右值要么是字面常量,要么是在表达式求值过程中创建的临时对象。</p>
<p>由于右值引用只能绑定到临时对象,我们得知</p>
<ul>
<li>所引用的对象将要被销毁</li>
<li>该对象没有其他用户</li>
</ul>
<p>这两个特性意味着:使用右值引用的代码可以自由地接管所引用的对象的资源</p>
<blockquote>
<p>标准库move函数</p>
</blockquote>
<p>虽然不能将一个右值引用直接绑定到一个左值上,但我们可以显式地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用,此函数定义在头文件uti1ity中。</p>
<h3 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h3><p>类似拷贝构造函数,移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是,这个引用参数在移动构造函数中是一个右值引|用。与拷贝构造函数一样,任何额外的参数都必须有默认实参。</p>
<p>除了完成资源移动,移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。特别是,一旦资源完成移动,源对象必须不再指向被移动的资源——这些资源的所有权已经归属新创建的对象</p>
<blockquote>
<p>移动赋值运算符</p>
</blockquote>
<p>移动赋值运算符执行与析构函数和移动构造函数相同的工作。与移动构造函数一样如果我们的移动赋值运算符不抛出任何异常,我们就应该将它标记为 except。</p>
<hr>
<h1 id="操作重载和类型转换"><a href="#操作重载和类型转换" class="headerlink" title="操作重载和类型转换"></a>操作重载和类型转换</h1><p>当运算符被用于类类型的对象时,C+语言允许我们为其指定新的含义:同时,我们也能自定义类类型之间的转换规则。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>重载的运算符是具有特殊名字的函数:它们的名字由关键字 operator和其后要定义的运算符号共同组成。和其他函数一样,重载的运算符也包含返回类型、参数列表以及函数体。</p>
<p>重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有个参数,二元运算符有两个。</p>
<p>如果一个运算符函数是成员函数,则它的第一个(左侧)运算对象绑定到隐式的this指针上。</p>
<p>可以被重载的运算符：<br><img src="https://data2.liuin.cn/2018-03-06-15202996380435.jpg" alt=""></p>
<p>我们只能重载已有的运算符,而无权发明新的运算符号。对于一个重载的运算符来说,其优先级和结合律与对应的内置运算符保持一致。</p>
<blockquote>
<p>直接调用重载运算符函数</p>
</blockquote>
<p>我们也能像调用普通函数一样直接调用运算符函数,先指定函数名字,然后传入数量正确、类型适当的实参:</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15202997181932.jpg" alt=""></p>
<blockquote>
<p>某些运算符不应该被重载</p>
</blockquote>
<p>回忆之前介绍过的,某些运算符指定了运算对象求值的顺序。因为使用重载的运算符本质上是一次函数调用,所以这些<strong>关于运算对象求值顺序的规则无法应用到重载的运算符上</strong>。特别是,逻辑与运算符、逻辑或运算符和逗号运算符的运算对又象求值顺序规则无法保留下来</p>
<p>还有一个原因使得我们一般不重载逗号运算符和取地址运篁符:C+语言已经<strong>定义了这两种运算符用于类类型对象时的特殊含义</strong>,这一点与大多数运算符都不相同。因为这两种运算符已经有了内置的含义,所以一般来说它们不应该被重载,否则它们的行为将异于常态,从而导致类的用户无法适应。</p>
<blockquote>
<p>赋值和复合赋值运算符</p>
</blockquote>
<p>赋值运算符的行为与复合版本的类似:赋值之后,左侧运算对象和右侧运算对象的值相等,并且运算符应该返回它左侧运算对象的一个引用。<strong>重载的赋值运算应该继承而非违背其内置版本的含义</strong>。</p>
<h2 id="输入和输出运算符"><a href="#输入和输出运算符" class="headerlink" title="输入和输出运算符"></a>输入和输出运算符</h2><p>IO标准库分别使用&gt;&gt;和&lt;&lt;执行输入和输出操作。</p>
<h3 id="重载输出运算符-lt-lt"><a href="#重载输出运算符-lt-lt" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符&lt;&lt;</h3><p>输出运算符的<strong>第一个形参是一个非常量 ostream对象的引用</strong>。之所以ostream是非常量是因为向流写入内容会改变其状态;而该形参是引用是因为我们无法直接复制一个 ostream对象。</p>
<p><strong>第二个形参一般来说是一个常量的引用,该常量是我们想要打印的类类型</strong>。第二个形参是引用的原因是我们希望避免复制实参;而之所以该形参可以是常量是因为(通常情况下)打印对象不会改变对象的内容。</p>
<p>为了与其他输出运算符保持一致, operator&lt;&lt;一般要返回它的 ostream形参。</p>
<blockquote>
<p>输入运算符尽量减少格式化操作</p>
</blockquote>
<p>用于内置类型的输出运算符不太考虑格式化操作,尤其不会打印换行符,用户希望类的输出运算符也像如此行事。如果运算符打印了换行符,则用户就无法在对象的同一行内接着打印一些描述性的文本了。</p>
<blockquote>
<p>输入输出函数必须为非成员函数</p>
</blockquote>
<p>与 iostream标准库兼容的输入输出运算符必须是普通的非成员函数,而不能是类的成员函数。否则,它们的左侧运算对象将是我们的类的一个对象</p>
<h3 id="重载输入运算符-gt-gt"><a href="#重载输入运算符-gt-gt" class="headerlink" title="重载输入运算符&gt;&gt;"></a>重载输入运算符&gt;&gt;</h3><p>通常情况下,输入运算符的<strong>第一个形参是运算符将要读取的流的引用</strong>,<strong>第二个形参是将要读入到的(非常量)对象的引用</strong>。该运算符通常会返回某个给定流的引|用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。</p>
<blockquote>
<p>输入时的错误</p>
</blockquote>
<ul>
<li>当流含有错误类型的数据时读取操作可能失败。</li>
<li>当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败。</li>
</ul>
<h2 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h2><p>我们把<strong>算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换</strong>。因为这些运算符一般不需要改变运算对象的状态,所以形参都是常量的引用</p>
<h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><p>C++中的类通过定义相等运算符来检验两个对象是否相等。</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15203006569640.jpg" alt=""></p>
<p>设计准则：</p>
<ol>
<li>如果一个类含有判断两个对象是否相等的操作,则它显然应该把函数定义成oprator=而非一个普通的命名函数:因为用户肯定希望能使用==比较对象,所以提供了==就意味着用户无须再费时费力地学习并记忆一个全新的函数名字此外,类定义了==运算符之后也更容易使用标准库容器和算法。</li>
<li>如果类定义了 perator==,则该运算符应该能判断一组给定的对象中是否含有重复数据。</li>
<li>通常情况下,相等运算符应该具有传递性</li>
<li>如果类定义了 operator==,则这个类也应该定义 operator!=。对于用户来说当他们能使用==时肯定也希望能使用!=,反之亦然</li>
<li>相等运算符和不相等运算符中的一个应该把工作委托给另外一个</li>
</ol>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>定义了相等运算符的类也常常(但不总是)包含关系运算符。特别是,因为关联容器和一些算法要用到小于运算符,所以定义。 operator&lt;会比较有用。</p>
<ol>
<li>定义顺序关系，令其与关联容器中对关键词的要求一致</li>
<li>如果类同时含有==运算符的话，则定义一种关系令其与==保持一致</li>
</ol>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>之前已经介绍过拷贝赋值和移动赋值运算符,它们可以把类的一个对象赋值给该类的另一个对象。此外,类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象。</p>
<p>复合赋值运算符不非得是类的成员,不过我们还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部。为了与内置类型的复合赋值保持一致,类中的复合赋值运算符也要返回其左侧运算对象的引用。</p>
<h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><p>表示容器的类通常可以通过元素在容器中的位置访问元素,这些类一般会定义下标运算符 operator[]。</p>
<p><strong>下标运算符必须是成员函数</strong></p>
<p>为了与下标的原始定义兼容,<strong>下标运算符通常以所访问元素的引用作为返回值</strong>,这样做的好处是下标可以出现在赋值运算符的任意一端。进一步,我们最好同时定义下标运算符的常量版本和非常量版本,当作用于一个常量对象时,下标运算符返回常量引用以确保我们不会给返回的对象赋值</p>
<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p>在迭代器类中通常会实现递増运算符(++)和递减运算符(–),这两种运算符使得类可以在元素的序列中前后移动。</p>
<blockquote>
<p>定义前置递增/递减运算符</p>
</blockquote>
<p>递增和递减运算符的工作机理非常相似:它们首先调用 check函数检验Strblobptr是否有效,如果是,接着检查给定的索引值是否有效。如果 check函数没有抛出异常,则运算符返回对象的引用。</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15203036806102.jpg" alt=""></p>
<blockquote>
<p>区分前置和后置运算符</p>
</blockquote>
<p>要想同时定义前置和后置运算符,必须首先解决一个问题,即普通的重载形式无法区分这两种情况。前置和后置版本使用的是同一个符号,意味着其重载版本所用的名字将是相同的,并且运算对象的数量和类型也相同。</p>
<p>为了解决这个问题,<strong>后置版本接受一个额外的(不被使用)int类型的形参</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15203037487660.jpg" alt=""></p>
<h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><p>在迭代器类及智能指针类中常常用到解引用运算符(*)和箭头运算符(-&gt;)。</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15203038781378.jpg" alt=""></p>
<blockquote>
<p>对箭头运算符返回值的限定</p>
</blockquote>
<p>和大多数其他运算符一样(尽管这么做不太好),我们能令 operator*完成任何我们指定的操作。换句话说,我们可以让 operator*返回一个固定值42,或者打印对象的内容,或者其他。<strong>箭头运算符则不是这样,它永远不能丢掉成员访问这个最基本的含义</strong>。当我们重载箭头时,可以改变的是箭头从哪个对象当中获取成员,而箭头获取成员这一事实则永远不变。</p>
<h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h2><p>如果类重载了函数调用运算符,则我们可以像使用函数一样使用该类的对象</p>
<h3 id="lambda-是函数对象"><a href="#lambda-是函数对象" class="headerlink" title="lambda 是函数对象"></a>lambda 是函数对象</h3><p>当我们编写了一个 lambda后,编译器将该表达式翻译成一个未命名类的未命名对象。在 lambda表达式产生的类中含有一个重载的函数调用运算符</p>
<h2 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h2><p>我们同样能定义对于类类型的类型转换,通过定义类型转换运算符可以做到这一点。转换构造函数和类型转换运算符共同定义了<strong>类类型转换</strong>( class-type conversions),这样的转换有时也被称作用户定义的类型转换(user- defined conversions)</p>
<h3 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h3><p>类型转换运算符( conversion operator)是类的一种特殊成员函数,它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">operator type()const;</div></pre></td></tr></table></figure></p>
<p>其中type表示某种类型。类型转换运算符可以面向任意类型(除了void之外)进行定义,只要该类型能作为函数的返回类型。因此,我们不允许转换成数组或者函数类型,但允许转换成指针(包括数组指针及函数指针)或者引用类型类型</p>
<p>转换运算符既没有显式的返回类型,也没有形参,而且必须定义成类的成员函数。类型转换运算符通常不应该改变待转换对象的内容,因此,类型转换运算符一般被定义成const成员。</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15203046723464.jpg" alt=""></p>
<h3 id="避免有二义性的类型转换"><a href="#避免有二义性的类型转换" class="headerlink" title="避免有二义性的类型转换"></a>避免有二义性的类型转换</h3><p>如果类中包含一个或多个类型转换,则必须确保在类类型和目标类型之间只存在唯一一种转换方式。否则的话,我们编写的代码将很可能会具有二义性在两种情况下可能产生多重转换路径。</p>
<p>第一种情况是<strong>两个类提供相同的类型转换</strong>;例如,当A类定义了一个接受B类对象的转换构造函数,同时B类定义了一个转换目标是A类的类型转换运算符时,我们就说它们提供了相同的类型转换</p>
<p>第二种情况是<strong>类定义了多个转换规则,而这些转换涉及的类型本身可以通过其他类型转换联系在一起</strong>。最典型的例子是算术运算符,对某个给定的类来说,最好只定义最多个与算术类型有关的转换规则。</p>
<hr>
<h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="OOP：概述"><a href="#OOP：概述" class="headerlink" title="OOP：概述"></a>OOP：概述</h2><p>面向对象程序设计( object-oriented programmin)的核心思想是<strong>数据抽象、继承和动态绑定</strong>。通过使用数据抽象,我们可以将类的接口与实现分离(见第7章);使用继承,可以定义相似的类型并对其相似关系建模;使用动态绑定,可以在一定程度上忽略相似类型的区别,而以统一的方式使用它们的对象。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>通过继承( inheritance)联系在一起的类构成一种层次关系。通常在层次关系的根部有一个<strong>基类</strong>( base class),其他类则直接或间接地从基类继承而来,这些继承得到的类称为<strong>派生类</strong>( derived class)。</p>
<p>在C++语言中,基类将<strong>类型相关的函数与派生类不做改变直接继承的函数区分对待</strong>。对于某些函数,<strong>基类希望它的派生类各自定义适合自身的版本,此时基类就将这些函数声明成虚函数</strong>( virtual function)。</p>
<p>派生类必须通过使用<strong>类派生列表</strong>( class derivation list)明确指出它是从哪个(哪些)基类继承而来的。类派生列表的形式是:首先是一个冒号,后面紧跟以逗号分隔的基类列表其中每个基类前面可以有访问说明符:</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204752450638.jpg" alt=""></p>
<p>派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上 virtua1关键字,但是并不是非得这么做。</p>
<h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>通过使用动态绑定( dynamic binding),我们们能用同一段代码分别处理 Quote和Bu1k_quote的对象(Bulk_quote 继承Quote）</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204753653946.jpg" alt=""></p>
<p>因为函数 print_tota1的item形参是基类Quote的一个引用,我们既能使用基类Quote的对象调用该函数,也能使用派生类Bu1k_quote的对象调用它;</p>
<p>因为在上述过程中函数的运行版本由实参决定,即在运行时选择函数的版本,所以动态绑定有时又被称为运行时绑定(run- time binding)。</p>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><p>基类通常都应该定义一个虚析构函数,即使该函数不执行任何实际操作也是如</p>
<blockquote>
<p>成员函数与继承</p>
</blockquote>
<p>在C++语言中,基类必须将它的两种成员函数区分开来:一种是<strong>基类希望其派生类进行覆盖的函数</strong>:另一种是<strong>基类希望派生类直接继承而不要改变的函数</strong>。对于前者,基类通常将其定义为<strong>虚函数</strong>( virtual)。当我们使用指针或引用调用虚函数时,该调用将被动态绑定。根据引用或指针所绑定的对象类型不同,该调用可能执行基类的版本,也可能执行某个派生类的版本。</p>
<p>任何构造函数之外的非静态函数都可以是虚函数。关键字V1rtua1只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把个函数声明成虚函数,则该函数在派生类中隐式地也是虚函数。</p>
<p>成员函数如果没被声明为虚函数,则其解析过程发生在编译时而非运行时。</p>
<blockquote>
<p>访问控制和继承</p>
</blockquote>
<p>派生类可以继承定义在基类中的成员,但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样,派生类能访问公有成员,而不能访问私有成员。不过在某些时候基类中还有这样一种成员,基类希望它的派生类有权访问该成员,同时禁止其他用户访向。我们用受保护的( protected)访向运算符说明这样的成员。</p>
<h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><p>派生类必须通过使用类派生列表( class derivation list)明确指出它是从哪个(哪些)基类继承而来的。类派生列表的形式是:首先是一个冒号,后面紧跟以逗号分隔的基类列表,其中每个基类前面可以有以下三种访问说明符中的一个:<strong>pub1ic、 protected或者private</strong></p>
<p>派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明,因此,我们的Bulk_quote类必须包含一个 net_price成员:</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204767757091.jpg" alt=""></p>
<p>大多数类都只继承自一个类,这种形式的继承被称作“单继承”,</p>
<blockquote>
<p>派生类中的虚函数</p>
</blockquote>
<p>派生类经常(但不总是)覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数,则该虚函数的行为类似于其他的普通成员,派生类会直接继承其在基类中的版本。</p>
<p>派生类可以在它覆盖的函数前使用 virtua1关键字,但不是非得这么做。</p>
<blockquote>
<p>派生类对象及派生类向基类的类型转换</p>
</blockquote>
<p>一个派生类对象包含多个组成部分:一个含有<strong>派生类自己定义的(非静态)成员的子对象</strong>,以及一个与该派生类<strong>继承的基类对应的子对象</strong>,如果有多个基类,那么这样的子对象也有多个。</p>
<p>因为在派生类对象中含有与其基类对应的组成部分,所以我们能把派生类的对象当成基类对象来使用,而且我们也能将基类的<strong>指针或引用</strong>绑定到派生类对象中的基类部分上</p>
<p>这种转换通常称为派生类到基类的( derived-to-base)类型转换。和其他类型转换一样,编译器会隐式地执行派生类到基类的转专换</p>
<blockquote>
<p>派生类构造函数</p>
</blockquote>
<p>尽管在派生类对象中含有从基类继承而来的成员,但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样,派生类也必须使用基类的构造函数来初始化它的基类部分</p>
<p>派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段执行初始化操作的。类似于我们初始化成员的过程,派生类构造函数同样是<strong>通过构造函数初始化列表来将实参传递给基类构造函数的</strong>。</p>
<p>除非我们特别指出,否则派生类对象的基类部分会像数据成员一样执行默认初始化。如果想使用其他的基类构造函数,我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。</p>
<blockquote>
<p>派生类使用基类成员</p>
</blockquote>
<p>派生类可以访问基类的公有成员和受保护成员:</p>
<p>目前只需要了解<strong>派生类的作用域嵌套在基类的作用域之内</strong>。因此,对于派生类的一个成员来说,它使用派生类成员(例如min aty和 discount)的方式与使用基类成员(例如 price)的方式没什么不同。</p>
<blockquote>
<p>继承与静态成员</p>
</blockquote>
<p>如果基类定义了一个静态成员,则在<strong>整个继承体系中只存在该成员的唯一定义</strong>。不论从基类中派生出来多少个派生类,对于每个静态成员来说都只存在唯一的实例。</p>
<p>静态成员遵循通用的访问控制规则,如果基类中的成员是pr⊥Vate的,则派生类无权访问它。假设某静态成员是可访问的,则我们既能通过基类使用它也能通过派生类使用它</p>
<blockquote>
<p>派生类的声明</p>
</blockquote>
<p>派生类的声明与其他类差别不大(参见7.3.3节,第250页),声明中包含类名但是不包含它的派生列表:</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204772352734.jpg" alt=""></p>
<blockquote>
<p>被用作基类的类</p>
</blockquote>
<p>如果我们想将某个类用作基类,则该类必须已经定义而非仅仅声明:</p>
<p>这一规定的原因显而易见:派生类中包含并且可以使用它从基类继承而来的成员,为了使用这些成员,派生类当然要知道它们是什十么。</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204772841857.jpg" alt=""></p>
<p>在这个继承关系中,Base是D1的直接基类( direct base),同时是D2的间接基类( indirectbase)。直接基类出现在派生列表中,而间接基类由派生类通过其直接基类继承而来</p>
<p>最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。</p>
<blockquote>
<p>防止继承发生</p>
</blockquote>
<p>有时我们会定义这样一种类,我们不希望其他类继承它,或者不想考虑它是否适合作为一个基类。为了实现这一日的,C++11新标准提供了一种防止继承发生的方法,即在类名后跟一个关键字fina1:</p>
<h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>通常情况下,如果我们想把引用或指针绑定到一个对象上,则引用或指针的类型应与对象的类型一致。存在继承关系的类是一个重要的意外</p>
<p>可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义:当使用基类的引用(或指针)时,实际上我们并不清楚该引用(或指针)所绑定对象的真实类型。该对象可能是基类的对象,也可能是派生类的对象。</p>
<blockquote>
<p>静态类型与动态类型</p>
</blockquote>
<p>当我们使用存在继承关系的类型时,必须<strong>将一个变量或其他表达式的静态类型</strong>( statictype)与该表达式表示对象的动态类型( dynamic type)区分开来。表达式的静态类型在编译时总是已知的,它是变量声明时的类型或表达式生成的类型:动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。</p>
<p>如果表达式既不是引用也不是指旨针,则它的动态类型永远与静态类型一致。</p>
<blockquote>
<p>不存在从基类向派生类的隐式类型转换</p>
</blockquote>
<p>之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分,而基类的引用或指针可以绑定到该基类部分上。一个基类的对象既可以以独立的形式存在,也可以作为派生类对象的一部分存在。如果基类对象不是派生类对象的一部分,则它只含有基类定义的成员,而不含有派生类定义的成员。</p>
<blockquote>
<p>对象之间不存在转换</p>
</blockquote>
<p>派生类向基类的自动类型转换只对指针或引用类型有效,在派生类类型和基类类型之间不存在这样的转换。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><blockquote>
<p>对虚函数的调用可能在运行时才被解析</p>
</blockquote>
<p>当某个虚函数通过指针或引用调用时,编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个</p>
<p>必须要搞清楚的一点是,动态绑定只有当我们通过指针或引用调用虚函数时才会发生。当我们通过一个具有普通类型(非引用非指针)的表达式调用虚函数时,在编译时就会将调用的版本确定下来。</p>
<blockquote>
<p>派生类中的虚函数</p>
</blockquote>
<p>当我们在派生类中覆盖了某个虚函数时,可以再一次使用 virtua1关键字指出该函数的性质。然而这么做并非必须,因为<strong>一旦某个函数被声明成虚函数,则在所有派生类中它都是虚函数</strong>。</p>
<p>一个派生类的函数如果覆盖了某个继承而来的虚函数,则它的形参类型必须与被它覆盖的基类函数完全一致。</p>
<blockquote>
<p>final 和 override说明符</p>
</blockquote>
<p>派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同,这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时,派生类的函数并没有覆盖掉基类中的版本。就实际的编程习惯而言,这种声明往主往意味着发生了错误,因为我们可能原本希望派生类能覆盖掉基类中的虚函数,但是一不小心把形参列表弄错了。</p>
<p>在C++11新标准中我们可以使用override关键字来说明派生类中的虚函数。这么做的好处是在使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误,后者在编程实践中显得更加重要。</p>
<blockquote>
<p>虚函数和默认实参</p>
</blockquote>
<p>和其他函数一样,虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参,则该实参值由本次调用的静态类型决定。</p>
<p>换句话说,如果我们通过基类的引用或指针调用函数,则使用基类中定义的默认实参,即使实际运行的是派生类中的函数版本也是如此匕。此时,传入派生类函数的将是基类函数定义的默认实参。</p>
<blockquote>
<p>回避虚函数的机制</p>
</blockquote>
<p>在某些情况下,我们希望对虚函数的调用不要进行动态绑定,而是强迫其执行虚函数的某个特定版本。</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204936697970.jpg" alt=""></p>
<p>什么时候我们需要回避虚函数的默认机制呢?通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。</p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><blockquote>
<p>纯虚函数</p>
</blockquote>
<p>当我们不想让用户从一个类中创建一个对象时，我们可以使用纯虚函数。</p>
<p>和普通的虚函数不一样,一个纯虚函数无须定义。我们通过在函数体的位置(即在声明语句的分号之前)书写=0就可以将一个虚函数说明为纯虚函数。其中,=0只能出现在类内部的虚函数声明语句处</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15205130777739.jpg" alt=""></p>
<blockquote>
<p>含有纯虚函数的类是抽象基类</p>
</blockquote>
<p>含有(或者未经覆盖直接继承)纯虚函数的类是抽象基类( abstract base class)。<strong>抽象基类负责定义接口,而后续的其他类可以覆盖该接口。我们不能(直接)创建一个抽象基类的对象</strong>。</p>
<blockquote>
<p>重构</p>
</blockquote>
<p>重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。对于面向对象的应用程序来说,重构是一种很普遍的现象。</p>
<h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><blockquote>
<p>受保护成员</p>
</blockquote>
<p>一个类使用 protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。 </p>
<blockquote>
<p>公有、私有和受保护继承</p>
</blockquote>
<p>某个类对其继承而来的成员的访问权限受到两个因素影响:一是在<strong>基类中该成员的访问说明符</strong>,二是在<strong>派生类的派生列表中的访问说明符</strong>。</p>
<p>派生访问说明符对于派生类的成员(及友元)能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关。 </p>
<p>派生访问说明符的目的是<strong>控制派生类用户(包括派生类的派生类在内)对于基类成员的访问权限</strong>:</p>
<p>假设我们之前还定义了一个名为 Prot_derv的类,它采用受保护继承,则Base的所有公有成员在新定义的类中都是受保护的。 Prot_Derv的用户不能访间 pub_mem,但是 Prot_derv的成员和友元可以访问那些继承而来的成员</p>
<blockquote>
<p>友元和继承</p>
</blockquote>
<p>就像友元关系不能传递一样,友元关系同样也不能继承。<strong>基类的友元在访问派生类成员时不具有特殊性</strong></p>
<p>当一个类将另一个类声明为友元时,这种友元关系只对做出声明的类有效。对于原来那个类来说,其友元的基类或者派生类不具有特殊的访问能力</p>
<blockquote>
<p>改变个别成员的可访问性</p>
</blockquote>
<p>有时我们需要改变派生类继承的某个名字的访问级别,通过使用 using声明。</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15205140838880.jpg" alt=""></p>
<p>因为 Derived使用了私有继承,所以继承而来的成员s1ze和n(在默认情况下)是Derived的私有成员。然而,我们使用us1ng声明语句改变了这些成员的可访问性。改变之后, Derived的用户将可以使用size成员,而 Derived的派生类将能使用n</p>
<blockquote>
<p>默认的继承保护级别</p>
</blockquote>
<p>我们曾经介绍过使用 struct和c1asS关键字定义的类具有不同的默认访问说明符。类似的,默认派生运算符也由定义派生类所用的关键字来决定默认情况下,<strong>使用c1ass关键字定义的派生类是私有继承的;而使用 struct关键字定义的派生类是公有继承的:</strong></p>
<p>两者的差别只有这一个。</p>
<h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><p>每个类定义自己的作用域,在这个作用域内我们定义类的成员。当存在继承关系时,<strong>派生类的作用域嵌套在其基类的作用域之内</strong>。如果一个名字在派生类的作用域内无法正确解析,则编译器将继续在外层的基类作用域中寻找该名字的定义</p>
<blockquote>
<p>在编译时进行名字查找</p>
</blockquote>
<p>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致(当使用基类的引用或指针时会发生这种情况),但是我们能使用哪些成员仍然是由静态类型决定的。</p>
<blockquote>
<p>名字冲突和继承</p>
</blockquote>
<p>和其他作用域一样,派生类也能重用定义在其直接基类或间接基类中的名字,此时<strong>定义在内层作用域(即派生类)的名字将隐藏定义在外层作用域(即基类)的名字</strong></p>
<blockquote>
<p>通过作用域运算符来使用隐藏的成员</p>
</blockquote>
<p>我们可以通过作用域运算符来使用一个被隐藏的基类成员:</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15205150138642.jpg" alt=""></p>
<p>作用域运算符将覆盖掉原有的査找规则,并指示编译器从BaSe类的作用域开始査找mem</p>
<blockquote>
<p>一如既往，名字查找先于类型检查</p>
</blockquote>
<p>如前所述,<strong>声明在内层作用域的函数并不会重载声明在外层作用域的函数</strong>。因此,定义派生类中的函数也不会重载其基类中的成员。和其他作用域样,如果派生类(即内层作用域)的成员与基类(即外层作用域)的某个成员同名,则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致,基类成员也仍然会被隐藏掉</p>
<blockquote>
<p>虚函数与作用域</p>
</blockquote>
<p>我们现在可以理解为什么基类与派生类中的虚函数必须有相同的形参列表了。<strong>假如基类与派生类的虚函数接受的实参不同,则我们就无法通过基类的引用或指针调用派生类的虚函数了</strong>。例如:</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15205151324990.jpg" alt=""></p>
<blockquote>
<p>覆盖重载的函数</p>
</blockquote>
<p>如果派生类希望所有的重载版本对于它来说都是可见的,那么它就需要覆盖所有的版本,或者一个也不覆盖。有时一个类仅需覆盖重载集合中的一些而非全部函数</p>
<h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>继承关系对基类拷贝控制最直接的影响是<strong>基类通常应该定义一个虚析构函数</strong>,这样我们就能动态分配继承体系中的对象了。如前所述,当我们de1ete一个动态分配的对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型,则有可能出现指针的静态类型与被删除对象的动态类型不符的情况</p>
<p>我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本:</p>
<p>和其他虚函数一样,析构函数的虚属性也会被继承。</p>
<p><strong>如果一个类需要析构函数,那么它也同样需要拷贝和赋值操作。基类的析构函数并不遵循上述准则</strong>,它是个重要的例外。一个基类总是需要析构函数,而且它能将析构函数设定为虚函数。</p>
<blockquote>
<p>虚析构函数将阻止合成移动操作</p>
</blockquote>
<p>基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响:如果一个类定义了析构函数,即使它通过= defau1t的形式使用了合成的版本,编译器也不会为这个类合成移动操作</p>
<h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><p>基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似:它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外,这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。</p>
<ul>
<li>合成的Bu1k_quote默认构造函数运行 Disc_quote的默认构造函数,后者又运行 Quote的默认构造函数。</li>
</ul>
<p>无论基类成员是合成的版本(如ρuote继承体系的例子)还是自定义的版本都没有太大影响。唯一的要求是相应的成员应该可访问并且不是一个被删除的函数。</p>
<blockquote>
<p>派生类中的删除的拷贝控制与基类的关系</p>
</blockquote>
<p>基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员定义成被删除的函数</p>
<ul>
<li>·如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问,则派生类中对应的成员将是被删除的,原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作</li>
<li>·如果在基类中有一个不可访问或删除掉的析构函数,则派生类中合成的默认和拷贝构造函数将是被删除的,因为编译器无法销毁派生类对象的基类部分。</li>
</ul>
<blockquote>
<p>移动操作与继承</p>
</blockquote>
<p>大多数基类都会定义一个虚析构函数。因此在默认情况下,基类通常不含有合成的移动操作,而且在它的派生类中也没有合成的移动操作。</p>
<h3 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h3><p>派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员,还负责初始化派生类对象的基类部分。因此,派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时,也要拷贝和移动基类部分的成员。类似的,派生类赋值运算符也必须为其基类部分的成员赋值。</p>
<blockquote>
<p>定义派生类的拷贝和移动构造函数</p>
</blockquote>
<p>当为派生类定义拷贝或移动构造函数时,我们通常使用对应的基类构造函数初始化对象的基类部分</p>
<p><img src="https://data2.liuin.cn/2018-03-09-15205965427434.jpg" alt=""></p>
<blockquote>
<p>派生类赋值运算符</p>
</blockquote>
<p>与拷贝和移动构造函数一样,派生类的赋值运算符也必须显式地为其基类部分赋值:</p>
<p>值得注意的是,无论基类的构造函数或赋值运算符是自定义的版本还是合成的版本,派生类的对应操作都能使用它们。</p>
<blockquote>
<p>派生类析构函数</p>
</blockquote>
<p>在析构函数体执行完成后,对象的成员会被隐式销毁。类似的,对象的基类部分也是隐式销毁的。因此,和构造函数及赋值运算符不同的是,派生类析构函数只负责销毁由派生类自己分配的资源:</p>
<p>对象销毁的顺序正好与其创建的顺序相反:派生类析构函数首先执行,然后是基类的析构函数,以此类推,沿着继承体系的反方向直至最后。</p>
<blockquote>
<p>在构造函数和析构函数中调用虚函数</p>
</blockquote>
<p>派生类对象的基类部分将首先被构建。当执行基类的构造函数时,该对象的派生类部分是未被初始化的状态。类似的,销毁派生类对象的次序正好相反,因此当执行基类的析构函数时,派生类部分已经被销毁掉了。</p>
<p>为了能够正确地处理这种未完成状态,编译器认为对象的类型在构造或析构的过程中仿佛发生了改变一样。也就是说,<strong>当我们构建一个对象时,需要把对象的类和构造函数的类看作是同一个;对虚函数的调用绑定正好符合这种把对象的类和构造函数的类看成同一个的要求;对于析构函数也是同样的道理。</strong></p>
<h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><p>在C++11新标准中,派生类能够重用其直接基类定义的构造函数。尽管如我们所知,这些构造函数并非以常规的方式继承而来,但是为了方便,我们不妨姑且称其为“继承”的。一个类只初始化它的直接基类,出于同样的原因,一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数,则编译器将为派生类合成它们。</p>
<p>派生类继承基类构造函数的方式是提供一条注明了(直接)基类名的uS1ng声明语句。举个例子,我们可以重新定义Bu1k_quote类,令其继承Disc_quote类的构造函数:</p>
<p><img src="https://data2.liuin.cn/2018-03-09-15205968035260.jpg" alt=""></p>
<blockquote>
<p>继承的构造函数的特点</p>
</blockquote>
<p>和普通成员的 using声明不一样构造函数的 using声明不会改变该构造函数的访问级别。</p>
<h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><p>当我们使用容器存放继承体系中的对象时,通常必须采取间接存储的方式。因为不允许在容器中保存不同类型的元素,所以我们不能把具有继承关系的多种类型的对象直接在放在容器当中。</p>
<blockquote>
<p>在容器中放置（智能）指针而非对象</p>
</blockquote>
<p>当我们希望在容器中存放具有继承关系的对象时,我们实际上存放的通常是基类的指针(更好的选择是智能指针。和往常一样,这些指针所指对象的动态类型可能是基类类型,也可能是派生类类型</p>
<h3 id="编写Basket类"><a href="#编写Basket类" class="headerlink" title="编写Basket类"></a>编写Basket类</h3><p>对于C++面向对象的编程来说,一个悖论是我们无法直接使用对象进行面向对象编程。相反,我们必须使用指针和引用。因为指针会增加程序的复杂性,所以我们经常定义一些辅助的类来处理这种复杂情况。</p>
<hr>
<h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><p>面向对象编程(OOP)和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于:OOP能处理类型在程序运行之前都未知的情况;而在泛型编程中,在编译时就能获知类型了。</p>
<p>模板是C++中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。</p>
<h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>我们可以定义一个通用的函数模板( function template),而不是为每个类型都定义一个新函数。一个函数模板就是一个公式,可用来生成针对特定类型的函数版本。 compare的模板版本可能像下面这样</p>
<p><img src="https://data2.liuin.cn/2018-03-10-15206810494191.jpg" alt=""></p>
<p>模板定义以关键字 template开始,后跟一个模板参数列表( template parameter list.,这是一个逗号分隔的一个或多个模板参数( template parameter)的列表,用小于号(&lt;)和大于号(&gt;)包围起来。<strong>在模板定义中，模板参数列表不能为空</strong>。</p>
<p>模板参数表示在类或函数定义中用到的类型或值。当使用模板时,我们(隐式地或显式地)指定模板实参( template argument),将其绑定到模板参数上。</p>
<blockquote>
<p>实例化函数模板</p>
</blockquote>
<p>当我们调用一个函数模板时!,<strong>编译器(通常)用函数实参来为我们推断模板实参</strong>。</p>
<p>编译器用推断出的模板参数来为我们实例化( instantiate)一个特定版本的函数。当编译器实例化一个模板时,它使用实际的模板实参代替对应的模板参数来创建出模板的一个新“实例”。</p>
<blockquote>
<p>模板类型参数</p>
</blockquote>
<p>我们的 compare函数有一个模板<strong>类型参数</strong>( type parameter.)。一般来说,我们可以<strong>将类型参数看作类型说明符</strong>,就像内置类型或类类型说明符一样使用。特别是,类型参数可以用来指定返回类型或函数的参数类型,以及在函数体内用于变量声明或类型转换</p>
<p><img src="https://data2.liuin.cn/2018-03-10-15206812431993.jpg" alt=""></p>
<blockquote>
<p>非类型模板参数</p>
</blockquote>
<p>除了定义类型参数,还可以在模板中定义非类型参数( nontype parameter)。<strong>一个非类型参数表示一个值而非一个类型</strong>。我通过一个特定的类型名而非关键字c1ass或typename来指定非类型参数。</p>
<p>当一个模板被实例化时,非类型参数被一个用户提供的或编译器推断出的值所代替。</p>
<blockquote>
<p>inline 和constexpr 的函数模板</p>
</blockquote>
<p>函数模板可以声明为in1ine或 constexpr的,如同非模板函数一样。in1ine或constexpr说明符放在模板参数列表之后,返回类型之前:</p>
<blockquote>
<p>编写类型无关的代码</p>
</blockquote>
<p>我们最初的 compare函数虽然简单,但它说明了编写泛型代码的两个重要原则:</p>
<ul>
<li>模板中的函数参数是 const的引用</li>
<li>函数体中的条件判断仅使用&lt;比较运算</li>
</ul>
<p>通过将函数参数设定为 const的引用,我们保证了函数可以用于不能拷贝的类型。</p>
<p>如果编写代码时只使用&lt;运算符,我们就降低了 compare函数对要处理的类型的要求。这些类型必须支持&lt;,但不必同时支持&gt;。</p>
<blockquote>
<p>模板编译</p>
</blockquote>
<p>当编译器遇到一个模板定义时,它并不生成代码。<strong>只有当我们实例化出模板的一个特定版本时,编译器才会生成代码</strong>。当我们使用(而不是定义)模板时,编译器才生成代码特性影响了我们如何组织代码以及错误何时被检测到。</p>
<p>为了生成一个实例化版本,编译器需要掌握函数模板或类模板成员函数的定义。因此,与非模板代码不同,模板的头文件通常既包括声明也包括定义。</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板( class template)是用来生成类的蓝图的。与函数模板的不同之处是,<strong>编译器不能为类模板推断模板参数类型</strong>。如我们已经多次看到的,<strong>为了使用类模板,我们必须在模板名后的尖括号中提供额外信息</strong>——用来代替模板参数的模板实参列表。</p>
<blockquote>
<p>定义类模板</p>
</blockquote>
<p>类似函数模板,类模板以关键字 template开始,后跟模板参数列表。在类模板(及其成员)的定义中,我们将模板参数当作替身,代替使用模板时用户需要提供的类型或值:</p>
<p><img src="https://data2.liuin.cn/2018-03-10-15206822514896.jpg" alt=""></p>
<blockquote>
<p>实例化类模板</p>
</blockquote>
<p>当使用一个类模板时,我们必须提供额外信息。我们现在知道这些额外信息是显式模板实参( explicit template argument)列表,它们被绑定到模板参数。编译器使用这些模板实参来实例化出特定的类。</p>
<blockquote>
<p>在模板作用域中引用模板类型</p>
</blockquote>
<p>为了阅读模板类代码,应该记住类<strong>模板的名字不是一个类型名</strong>。类模板用来实例化类型,而一个实例化的类型总是包含模板参数的可能令人迷惑的是,<strong>一个类模板中的代码如果使用了另外一个模板,通常不将一个实际类型(或值)的名字用作其模板实参。相反的,我们通常将模板自己的参数当作被使用模板的实参</strong>。</p>
<p>例如,我们的data成员使用了两个模板, vector和 shared_ptr。我们知道,无论何时使用模板都必须提供模板实参。在本例中,我们提供的模板实参就是Bob的模板参数。因此,data的定义如下</p>
<p><img src="https://data2.liuin.cn/2018-03-10-15206823729019.jpg" alt=""></p>
<blockquote>
<p>类模板的成员函数</p>
</blockquote>
<p>与其他任何类相同,我们既可以在类模板内部,也可以在类模板外部为其定义成员函数,且<strong>定义在类模板内的成员函数被隐式声明为内联函数</strong>。</p>
<p>类模板的成员函数本身是一个普通函数。但是,类模板的每个实例都有其自己版本的成员函数。因此,类模板的成员函数具有和模板相同的模板参数。因而,定义在类模板之外的成员函数就必须以关键字temp1ate开始,后接类模板参数列表。</p>
<p>当我们在类外定义一个成员时,必须说明成员属于哪个类。而且,<strong>从一个模板生成的类的名字中必须包含其模板实参</strong>。</p>
<blockquote>
<p>类模板成员函数的实例化</p>
</blockquote>
<p>默认情况下,一个类模板的成员函数只有当程序用到它时才进行实例化。</p>
<p>如果一个成员函数没有被使用,则它不会被实例化。成员函数只有在被用到时才进行实例化,这一特性使得即使某种类型不能完全符合模板操作的要求。</p>
<blockquote>
<p>在类代码内简化模板类名的使用</p>
</blockquote>
<p>当我们使用一个类模板类型时必须提供模板实参,但这一规则有一个例外。<strong>在类模板自己的作用域中,我们可以直接使用模板名而不提供实参</strong></p>
<blockquote>
<p>在类模板外使用类模板名</p>
</blockquote>
<p>当我们在类模板外定义其成员时,必须记住,我们并不在类的作用域中,直到遇到类名才表示进入类的作用域(参见</p>
<blockquote>
<p>模板类和友元</p>
</blockquote>
<p>当一个类包含一个友元声明时,类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板友元,则友元被授权可以访问所有模板实例。如果友元自身是模板,类可以授权给所有友元模板实例,也可以只授权给特定实例</p>
<blockquote>
<p>一对一友好关系</p>
</blockquote>
<p><strong>类模板与另一个(类或函数)模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-03-10-15206826958070.jpg" alt=""></p>
<blockquote>
<p>通用和特定的友好关系</p>
</blockquote>
<p>一个类也可以将另一个模板的每个实例都声明为自己的友元,或者限定特定的实例为友元</p>
<p>为了让所有实例成为友元,友元声明中必须使用与类模板本身不同的模板参数</p>
<blockquote>
<p>模板类型别名</p>
</blockquote>
<p>类模板的一个实例定义了一个类类型,与任何其他类类型一样,我们可以定义一个typedef来引用实例化的类:</p>
<p><code>typedef Blob&lt;string&gt; StrBlob;</code></p>
<blockquote>
<p>类模板的static成员</p>
</blockquote>
<p>与任何其他 static数据成员相同,模板类的每个 static数据成员必须有且仅有个定义。但是,类模板的每个实例都有一个独有的 static对象。因此,与定义模板的成员函数类似,我们将 static数据成员也定义为模板</p>
<p>与非模板类的静态成员相同,我们可以通过类类型对象来访问一个类模板的 statio成员,也可以使用作用域运算符直接访问成员。当然,为了通过类来直接访问 static成员,我们必须引用一个特定的实例</p>
<h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><p>类似函数参数的名字,一个模板参数的名字也没有什么内在含义。我们通常将类型参数命名为T,但实际上我们们可以使用任何名字:</p>
<blockquote>
<p>模板参数与作用域</p>
</blockquote>
<p>模板参数遵循普通的作用域规则。<strong>一个模板参数名的可用范围是在其声明之后,至模板声明或定义结束之前</strong>。与任何其他名字一样,模板参数会隐藏外层作用域中声明的相同名字。</p>
<blockquote>
<p>模板声明</p>
</blockquote>
<p>模板声明必须包含模板参数，一个给定模板的每个声明和定义必须有相同数量和种类(即,类型或非类型)的参数。</p>
<blockquote>
<p>使用类的类型成员</p>
</blockquote>
<p>假定T是一个模板类型参数,当编译器遇到类似里T::mem这样的代码时,它不会知道mem是一个类型成员还是一个 static数据成员,直至实例化时才会知道。但是,为了处理模板,编译器必须知道名字是否表示一个类型。</p>
<p>默认情况下,<strong>C++语言假定通过作用域运算符访问的名字不是类型</strong>。因此,如果我们希望使用一个模板类型参数的类型成员,就必须显式告诉编译器该名字是一个类型。</p>
<blockquote>
<p>默认模板实参</p>
</blockquote>
<p>就像我们能为函数参数提供默认实参一样,我们也可以提供默认模板实参( default template argument)。</p>
<blockquote>
<p>模板默认实参与类模板</p>
</blockquote>
<p>无论何时使用一个类模板,我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。特别是,如果一个类模板为其所有模板参数都提供了默认实参,且我们希望使用这些默认实参,就必须在模板名之后跟一个空尖括号对:</p>
<h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><p>一个类(无论是普通类还是类模板)可以包含本身是模板的成员函数。这种成员被称为成员模板( member template)。成员模板不能是虚函数。</p>
<blockquote>
<p>普通（非模板）类的成员模板</p>
</blockquote>
<p><img src="https://data2.liuin.cn/2018-03-12-15208165159357.jpg" alt=""></p>
<blockquote>
<p>类模板的成员模板</p>
</blockquote>
<p>对于类模板,我们也可以为其定义成员模板。在此情况下,类和成员各自有自己的、独立的模板参数。</p>
<p>与类模板的普通函数成员不同,成员模板是函数模板。当我们在类模板外定义一个成员模板时,必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前,后跟成员自己的模板参数列表:</p>
<blockquote>
<p>实例化与成员模板</p>
</blockquote>
<p>为了实例化一个类模板的成员模板,我们必须同时提供类和函数模板的实参。与往常样,我们在哪个对象上调用成员模板,编译器就根据该对象的类型来推断类模板参数的实参。</p>
<h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><p>当模板被使用时才会进行实例化这一特性意味着,<strong>相同的实例可能出现在多个对象文件中</strong>。当两个或多个独立编译的源文件使用了相同的模板并提供了相同的模板参数时,每个文件中就都会有该模板的一个实例。</p>
<p>在大系统中,在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中,我们可以通过显式实例化( explicit instantiation)来避免这种开销。一个显式实例化有如下：</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208167547457.jpg" alt=""></p>
<p>当编译器遇到 extern模板声明时,它不会在本文件中生成实例化代码。将一个实例化声明为 extern就表示承诺在程序其他位置有该实例化的一个非 extern声明(定义)。</p>
<blockquote>
<p>实例化定义会实例化所有成员</p>
</blockquote>
<p><strong>一个类模板的实例化定义会实例化该模板的所有成员,包括内联的成员函数</strong>。当编译器遇到一个实例化定义时,它不了解程序使用哪些成员函数。因此,与处理类模板的普通实例化不同,编译器会实例化该类的所有成员。即使我们不使用某个成员,它也会被实例化。因此,我们用来显式实例化一个类模板的类型,必须能用于模板的所有成员</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》笔记 类设计者的工具部分&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C/C++" scheme="https://www.liuin.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 题解——Container With Most Water</title>
    <link href="https://www.liuin.cn/2018/03/09/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Container-With-Most-Water/"/>
    <id>https://www.liuin.cn/2018/03/09/LeetCode-题解——Container-With-Most-Water/</id>
    <published>2018-03-09T10:37:07.000Z</published>
    <updated>2018-03-09T10:53:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题解——Container With Most Water</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目首先给出一个数组b，数组中的每一个数可以确定平面直角坐标系上的一个点<code>(i,b[i])</code>，两个点可以确定一个容器：两个点分别向x轴引垂线形成的容器，求所有形成的容器中容积（面积）最大的那一个。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先想到的是暴力法，枚举所有的情况，这样的时间复杂度是O(n^2)，要优化这个算法的话，要么就优化成O(logn)或者O(n)，如果想要优化成O(n)的话就意味着扫描一遍即可。</p>
<p>这样可以找到一个贪心的方法：用两个指针从两边向中间进行扫描，这样我们所求的面积的底在变小，要想扫描到更大的面积的情况只有更长的高才有可能找到，所以就在扫描过程中舍弃掉较小高度的点，让指针继续向中间靠拢。</p>
<h2 id="代码（C-）"><a href="#代码（C-）" class="headerlink" title="代码（C++）"></a>代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = height.size()<span class="number">-1</span>;</div><div class="line">        <span class="keyword">int</span> res = min(height[i], height[j])*(j-i);</div><div class="line">        <span class="comment">// 从两边向中间扫描</span></div><div class="line">        <span class="keyword">while</span>(i&lt;j)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(height[i] &lt; height[j])</div><div class="line">                i++;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                j--;</div><div class="line">            res = max(res, min(height[i], height[j])*(j-i));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题解——Container With Most Water&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.liuin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://www.liuin.cn/tags/LeetCode/"/>
    
      <category term="贪心" scheme="https://www.liuin.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 题解——Regular Expression Matching</title>
    <link href="https://www.liuin.cn/2018/03/09/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Regular-Expression-Matching/"/>
    <id>https://www.liuin.cn/2018/03/09/LeetCode-题解——Regular-Expression-Matching/</id>
    <published>2018-03-09T10:06:12.000Z</published>
    <updated>2018-03-09T10:38:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题解——Regular Expression Matching</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>实现支持.和*正则匹配</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一开始的想法是从左向右进行模拟匹配，模拟的代码比较长，后面遇到这种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">aaa</div><div class="line">a*a</div></pre></td></tr></table></figure></p>
<p>就行不通了</p>
<p>事实上，上面那种情况的我们在匹配a*的时候，要分是否匹配a这个东西分两种情况进行讨论，这个时候就有一种递归的思路：<br>首先判断第一个字符是否匹配，然后判断是否是*模式，是的话可以匹配这个字符也可以不匹配，如果不是*模式的话就判断后面。</p>
<p>递归代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> plen = p.size(), slen = s.size();</div><div class="line">        <span class="keyword">if</span>(plen == <span class="number">0</span>) <span class="keyword">return</span> slen == <span class="number">0</span>;</div><div class="line">        <span class="comment">// 是否匹配第一个</span></div><div class="line">        <span class="keyword">bool</span> matchfirst = (slen != <span class="number">0</span> &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>));</div><div class="line">        <span class="comment">// 是否是*模式</span></div><div class="line">        <span class="keyword">if</span>(plen &gt;= <span class="number">2</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">'*'</span>)</div><div class="line">            <span class="keyword">return</span> (isMatch(s, p.substr(<span class="number">2</span>)) || (matchfirst &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p)));</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> (matchfirst &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>)));</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这样的递归我们会发现有大量的重复调用，这个时候可以使用动态规划进行优化。<br><code>dp[i][j]</code>表示<code>isMatch(s.strsub(i), p.strsub(j))</code>，由上面的递归方案我们可以推得</p>
<p><code>dp[i][j]</code>= </p>
<ol>
<li>dp[i][j+2],当前为*模式时不匹配的情况</li>
<li>dp[i+1][j],当前为*模式，并且第一个字符匹配成功的情况</li>
<li>dp[i+1][j],非*模式，第一个字符匹配成功的情况</li>
</ol>
<p>DP代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> plen = p.length(), slen = s.length();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; dp(slen + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; (plen + <span class="number">1</span>, <span class="literal">false</span>));</div><div class="line">        dp[slen][plen] = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=slen ;i&gt;=<span class="number">0</span>;--i)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=plen<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">// 判断第一个是否匹配</span></div><div class="line">                <span class="keyword">bool</span> match = (i&lt;slen &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">'.'</span>));</div><div class="line">                <span class="comment">// 是*模式，两种方案，匹配/不匹配</span></div><div class="line">                <span class="keyword">if</span>(j+<span class="number">1</span> &lt; plen &amp;&amp; p[j+<span class="number">1</span>] == <span class="string">'*'</span>)</div><div class="line">                    dp[i][j] = dp[i][j+<span class="number">2</span>] || (match &amp;&amp; dp[i+<span class="number">1</span>][j]);</div><div class="line">                <span class="comment">// 非*模式</span></div><div class="line">                <span class="keyword">else</span></div><div class="line">                    dp[i][j] = (match &amp;&amp; dp[i+<span class="number">1</span>][j+<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题解——Regular Expression Matching&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.liuin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="DP" scheme="https://www.liuin.cn/tags/DP/"/>
    
      <category term="LeetCode" scheme="https://www.liuin.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 题解——Median of Two Sorted Arrays</title>
    <link href="https://www.liuin.cn/2018/03/08/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Median-of-Two-Sorted-Arrays/"/>
    <id>https://www.liuin.cn/2018/03/08/LeetCode-题解——Median-of-Two-Sorted-Arrays/</id>
    <published>2018-03-08T06:42:12.000Z</published>
    <updated>2018-03-09T10:38:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题解——Median of Two Sorted Arrays</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定两个有序数组，求这两个有序数组中所有数的中位数</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先理解什么是中位数，中位数把这两个数组中的所有的数有序放到一起，排在中间的那一个数（或者两个数）就是中位数，我们也可以从另外一个角度去看，中位数作为边界把这些数分割成两半。这两边的数的个数是相等的。</p>
<p>对于这两个数组就相当于每个数组都有一个数把这个数组分割成两半：</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204918440445.jpg" alt=""></p>
<p>这里考虑使用二分法求解，对于两个数组，两边的数的个数是相等的。由此，考虑一种分割情况，我们可以假设A数组从i点分割，这样因为两边的数的个数相等很容易算得B数组的分割点<code>j=(n+m+1)/2-i</code>，对于每一种分割有三种情况：</p>
<ol>
<li><code>A[i]&gt;=B[j-1] &amp;&amp; B[j]&gt;=A[i-1]</code>这种情况下，刚好取得中位数</li>
<li><code>A[i]&lt;B[j-1]</code> 这种情况下，表示我们选取的i点过小，可以通过二分进一步缩减范围</li>
<li><code>B[j]&lt;A[i-1]</code> 这种情况下，表示我们选取的i点过大，可以通过二分进一步缩减范围</li>
</ol>
<p>除此之外另外还要注意几点：</p>
<ol>
<li>我们选取的i要从数组数量较小的那个数组中选取，因为如果从数组数量大的数组中选取的话，可能导致选取的i较小，使得计算出的j值大于B数组中的元素个数</li>
<li>存在一些特殊情况在端点分割的特殊情况，比如i=0，i=n，j=0，j=m的这些情况。在这样的情况下，我们可以只需要计算左边数的最大值，和右边数的最小值即可。</li>
<li>最后的结果要对总数是奇数还是偶数进行讨论，如果是奇数的话，表示中位数是左边那一堆中的最大值；如果是偶数的话，中位数中左边一堆数的最大值和右边一堆书的最小值的平均值。</li>
</ol>
<h2 id="代码（C-）"><a href="#代码（C-）" class="headerlink" title="代码（C++）"></a>代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = nums1.size(), m = nums2.size();</div><div class="line">        <span class="comment">// 对小的数组进行分割</span></div><div class="line">        <span class="keyword">if</span>(n &gt; m)</div><div class="line">        &#123;</div><div class="line">            swap(nums1, nums2);</div><div class="line">            swap(n,m);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 二分法确定两个界限</span></div><div class="line">        <span class="keyword">int</span> i, j, iMin = <span class="number">0</span>, iMax = n;</div><div class="line">        <span class="keyword">while</span>(iMin &lt;= iMax)</div><div class="line">        &#123;</div><div class="line">            i = (iMin + iMax)/<span class="number">2</span> ;</div><div class="line">            j = (m+n+<span class="number">1</span>)/<span class="number">2</span> - i;</div><div class="line">            <span class="comment">// i的取值过大</span></div><div class="line">            <span class="keyword">if</span>(i &gt; iMin &amp;&amp; nums1[i<span class="number">-1</span>] &gt; nums2[j])</div><div class="line">            &#123;</div><div class="line">                iMax = i - <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// i的取值过小的情况</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; iMax &amp;&amp; nums1[i] &lt; nums2[j<span class="number">-1</span>]) </div><div class="line">            &#123;</div><div class="line">                iMin = i + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 找到中位数</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) left = nums2[j<span class="number">-1</span>];</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) left = nums1[i<span class="number">-1</span>];</div><div class="line">                <span class="keyword">else</span> left = max(nums1[i<span class="number">-1</span>], nums2[j<span class="number">-1</span>]);</div><div class="line">                <span class="comment">// 总数是奇数的时候</span></div><div class="line">                <span class="keyword">if</span> ( (m + n) % <span class="number">2</span>) <span class="keyword">return</span> left;</div><div class="line">                </div><div class="line">                <span class="keyword">int</span> right = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span>(i == n) right = nums2[j];</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == m) right = nums1[i];</div><div class="line">                <span class="keyword">else</span> right = min(nums1[i], nums2[j]);</div><div class="line">                <span class="keyword">return</span> (left + right)/<span class="number">2.0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题解——Median of Two Sorted Arrays&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.liuin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://www.liuin.cn/tags/LeetCode/"/>
    
      <category term="二分" scheme="https://www.liuin.cn/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>APUE 文件I/O</title>
    <link href="https://www.liuin.cn/2018/03/06/APUE-%E6%96%87%E4%BB%B6I-O/"/>
    <id>https://www.liuin.cn/2018/03/06/APUE-文件I-O/</id>
    <published>2018-03-06T10:49:20.000Z</published>
    <updated>2018-03-07T03:29:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第2章 文件I/O 笔记</p>
<a id="more"></a>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>UNX系统中的大多数文件只需用到5个函数:open、read、 write、 lseek以及c1ose。</p>
<p>本章描述的函数经常被称为不带缓冲的I/O( unbuffered I/O,与将在第5章中说明的标准I/O函数相对照)。术语不带缓冲指的是每个read和 write都调用内核中的一个系统调用。</p>
<p>只要涉及在多个进程间共享资源,原子操作的概念就变得非常重要。我们将通过文件IO和open函数的参数来讨论此概念。</p>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>对于内核而言,<strong>所有打开的文件都通过文件描述符引用</strong>。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时,内核向进程返回一个文件描述符。</p>
<p>按照惯例,UNIX系统shell把<strong>文件描述符0与进程的标准输入关联,文件描述符1与标准输出关联,文件描述符2与标准错误关联</strong>。这是各种shel以及很多应用程序使用的惯例.</p>
<h2 id="函数open和openat"><a href="#函数open和openat" class="headerlink" title="函数open和openat"></a>函数open和openat</h2><p>用于打开或者创建一个文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oﬂag, ... <span class="comment">/* mode_t mode */</span> )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oﬂag, ... <span class="comment">/* mode_t mode */</span> )</span></span>; </div><div class="line"><span class="comment">//Both return: ﬁle descriptor if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>我们将最后一个参数写为…,ISO C用这种方法表明余下的参数的数量及其类型是可变的。对于open函数而言,仅当创建新文件时才使用最后这个参数(稍后将对此进行说明)。</p>
<p>path参数是要打开或创建文件的名字。oflag参数可用来说明此函数的多个选项。用一个或者多个常量“或”运算构成oflag参数</p>
<p>使用的常量可以参考原书</p>
<h2 id="函数create"><a href="#函数create" class="headerlink" title="函数create"></a>函数create</h2><p>可以调用create函数创建一个文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">//Returns: ﬁle descriptor opened for write-only if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>此函数等效于<code>open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);</code></p>
<p>creat的一个不足之处是它以只写方式打开所创建的文件。</p>
<h2 id="函数close"><a href="#函数close" class="headerlink" title="函数close"></a>函数close</h2><p>调用close函数关闭一个打开的文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>关闭一个文件时还会释放该进程加在该文件上的所有记录锁。</p>
<p>当一个进程终止时,内核自动关闭它所有的打开文件。很多程序都利用了这一功能而不显式地用c1ose关闭打开文件。</p>
<h2 id="函数lseek"><a href="#函数lseek" class="headerlink" title="函数lseek"></a>函数lseek</h2><p>每个打开文件都有一个与其相关联的“<strong>当前文件偏移量</strong>”( current file offset)。它通常是一个非负整数,用以度量从文件开始处计算的字节数。</p>
<p>调用1seek显式地为一个打开文件设置偏移量：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</div><div class="line"></div><div class="line"><span class="comment">//Returns: new ﬁle offset if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>对参数offet的解释与参数 whence的值有关。</p>
<ul>
<li>若 whence是 SEEK_SET,则将该文件的偏移量设置为距文件开始处 offset个字节。</li>
<li>若 whence是 SEEK_CUR,则将该文件的偏移量设置为其当前值加 offset, offset可为正或负。</li>
<li>若 whence是 SEEK_END,则将该文件的偏移量设置为文件长度加 offset, offset可正可负。</li>
</ul>
<p>通常,文件的当前偏移量应当是一个非负整数,但是,某些设备也可能允许负的偏移量。但对于普通文件,其偏移量必须是非负值。</p>
<p>1seek仅将当前的文件偏移量记录在内核中,它并不引起任何IO操作。然后,该偏移量用于下一个读或写操作。</p>
<p>文件偏移量可以大于文件的当前长度,在这种情况下,对该文件的下一次写将加长该文件,并在文件中构成一个空洞,这一点是允许的。位于文件中但没有写过的字节都被读为0</p>
<p><strong>文件中的空洞并不要求在磁盘上占用存储区</strong>。具体处理方式与文件系统的实现有关,当定位到超出文件尾端之后写时,对于新写的数据需要分配磁盘块,但是对于原文件尾端和新开始写位置之间的部分则不需要分配磁盘块。</p>
<p>创建一个具有空洞的文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">char</span>	buf1[] = <span class="string">"abcdefghij"</span>;</div><div class="line"><span class="keyword">char</span>	buf2[] = <span class="string">"ABCDEFGHIJ"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span>		fd;</div><div class="line"></div><div class="line">	<span class="comment">// 创建文件</span></div><div class="line">	<span class="keyword">if</span> ((fd = creat(<span class="string">"file.hole"</span>, FILE_MODE)) &lt; <span class="number">0</span>)</div><div class="line">		err_sys(<span class="string">"creat error"</span>);</div><div class="line"></div><div class="line">	<span class="comment">// 写入a-j，此时文件偏移量为10</span></div><div class="line">	<span class="keyword">if</span> (write(fd, buf1, <span class="number">10</span>) != <span class="number">10</span>)</div><div class="line">		err_sys(<span class="string">"buf1 write error"</span>);</div><div class="line">	<span class="comment">/* offset now = 10 */</span></div><div class="line"></div><div class="line">	<span class="comment">// 改变文件偏移量到16384</span></div><div class="line">	<span class="keyword">if</span> (lseek(fd, <span class="number">16384</span>, SEEK_SET) == <span class="number">-1</span>)</div><div class="line">		err_sys(<span class="string">"lseek error"</span>);</div><div class="line">	<span class="comment">/* offset now = 16384 */</span></div><div class="line"></div><div class="line">	<span class="comment">// 在新的文件偏移量下写入A-J</span></div><div class="line">	<span class="keyword">if</span> (write(fd, buf2, <span class="number">10</span>) != <span class="number">10</span>)</div><div class="line">		err_sys(<span class="string">"buf2 write error"</span>);</div><div class="line">	<span class="comment">/* offset now = 16394 */</span></div><div class="line"></div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为1seek使用的偏移量是用off_t类型表示的,所以允许具体实现根据各自特定的平台自行选择大小合适的数据类型。</p>
<h2 id="函数read"><a href="#函数read" class="headerlink" title="函数read"></a>函数read</h2><p>调用read函数从打开文件中读数据<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); </div><div class="line"></div><div class="line"><span class="comment">//Returns: number of bytes read, 0 if end of ﬁle, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>如read成功,则返回读到的字节数。如已到达文件的尾端,则返回0。</p>
<p>有多种情况可使实际读到的字节数少于要求读的字节数</p>
<ul>
<li>读普通文件时,在读到要求字节数之前已到达了文件尾端。</li>
<li>当从终端设备读时,通常一次最多读一行。</li>
<li>当从网络读时,网络中的缓冲机制可能造成返回值小于所要求读的字节数</li>
<li>当从管道或FIFO读时,如若管道包含的字节少于所需的数量,那么read将只返回实际可用的字节数</li>
<li>当从某些面向记录的设备(如磁带)读时,一次最多返回一个记录。</li>
<li>当一信号造成中断,而已经读了部分数据量时。</li>
</ul>
<h2 id="函数write"><a href="#函数write" class="headerlink" title="函数write"></a>函数write</h2><p>调用write函数想打开文件写数据<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); </div><div class="line"></div><div class="line"><span class="comment">//Returns: number of bytes written if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>其返回值通常与参数 nbytes的值相同,否则表示出错。 write出错的一个常见原因是磁盘已写满,或者超过了一个给定进程的文件长度限制</p>
<h2 id="I-O效率"><a href="#I-O效率" class="headerlink" title="I/O效率"></a>I/O效率</h2><p>BUFFSIZE 一般选取与磁盘块相同大小的字节数，大多数情况问4096</p>
<p>大多数文件系统为改善性能都采用某种预读( read ahead)技术。当检测到正进行顺序读取时,系统就试图读入比应用所要求的更多数据,并假想应用很快就会读这些数据。</p>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>UNIX系统支持在不同进程间共享打开文件。在介绍dup函数之前,先要说明这种共享。为此先介绍内核用于所有I/O的数据结构。</p>
<p>内核使用3种数据结构表示打开文件,它们之间的关系决定了在文件共享方面一个进程对另个进程可能产生的影响。</p>
<ol>
<li><strong>每个进程在进程表中都有一个记录项,记录项中包含一张打开文件描述符表</strong>,可将其视为一个矢量,每个描述符占用一项。与每个文件描述符相关联的是文件描述符标志和指向一个文件表项的指针。</li>
<li><strong>内核为所有打开文件维持一张文件表</strong>。每个文件表项包含文件状态标志(读、写、添写、同步和非阻塞等)、当前文件偏移量、指向该文件v节点表项的指针</li>
<li>每个打开文件(或设备)都有一个v节点( v-node)结构。v节点包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件,v节点还包含了该文件的i节点(i-node,索引节点)。</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-03-07-15203821021363.jpg" alt=""></p>
<blockquote>
<p>创建v节点结构的目的是对在一个计算机系统上的多文件系统类型提供支持。把与文件系统无关的i节点部分称为v节点。Linux没有将相关数据结构分为i节点和ⅴ节点,而是采用了一个与文件系统相关的i节点和个与文件系统无关的i节点。</p>
</blockquote>
<p>两个独立进程打开同一个文件</p>
<p><img src="https://data2.liuin.cn/2018-03-07-15203822136634.jpg" alt=""></p>
<p>文件描述符标志和文件状态标志在作用范围方面的区别,前者只用于一个进程的一个描述符,而后者则应用于指向该给定文件表项的任何进程中的所有描述符。</p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><ol>
<li>追加到一个文件</li>
</ol>
<p>多个进程同时使用这种方法将数据追加写到同一文件,则会产生问题</p>
<p>问题出在逻辑操作“先定位到文件尾端,然后写”,它使用了两个分开的函数调用。解决问题的方法是使这两个操作对于其他进程而言成为一个原子操作。</p>
<ol>
<li>函数pread和pwrite</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset); </div><div class="line"></div><div class="line"><span class="comment">//Returns: number of bytes read, 0 if end of ﬁle, −1 on error</span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> pwrite(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset); </div><div class="line"></div><div class="line"><span class="comment">//Returns: number of bytes written if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>调用 pread相当于调用1seek后调用read,但是 pread又与这种顺序调用有下列重要区别:1. 调用 pread时,无法中断其定位和读操作。2. 不更新当前文件偏移量。</p>
<p>调用pwrite相当于调用1seek后调用 write,但也与它们有类似的区别。</p>
<h2 id="函数dup和dup2"><a href="#函数dup和dup2" class="headerlink" title="函数dup和dup2"></a>函数dup和dup2</h2><p>下面两个用来复制一个文件描述符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//Both return: new ﬁle descriptor if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>由dup返回的新文件描述符一定是当前可用文件描述符中的最小数值。对于dup2,可以用fd2参数指定新描述符的值。如果fd2已经打开,则先将其关闭。如若fd等于fd2,则dup2返回fd2,而不关闭它。否则,fd2的 FD_CLOEXEO文件描述符标志就被清除,这样fd2在进程调用exec时是打开状态</p>
<p>dup(1)以后的内核数据结构：<br><img src="https://data2.liuin.cn/2018-03-07-15203828993104.jpg" alt=""></p>
<h2 id="函数sync、-fsync和-fdatasync"><a href="#函数sync、-fsync和-fdatasync" class="headerlink" title="函数sync、 fsync和 fdatasync"></a>函数sync、 fsync和 fdatasync</h2><p>传统的UNⅨ系统实现在内核中设有缓冲区高速缓存或页高速缓存,大多数磁盘I/O都通过缓冲区进行。当我们向文件写入数据时,内核通常先将数据复制到缓冲区中,然后排入队列,晚些时候再写入磁盘。这种方式被称为<strong>延迟写</strong>( delayed write)</p>
<p>通常,当内核需要重用缓冲区来存放其他磁盘块数据时,它会把所有延迟写数据块写入磁盘为了保证磁盘上实际文件系统与缓冲区中内容的一致性,UNIX系统提供了sync、 fsync和Edatasync三个函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//Returns: 0 if OK, −1 on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>sync只是将所有修改过的块缓冲区排入写队列,然后就返回,它并不等待实际写磁盘操作结束。</p>
<p>fsync函数只对由文件描述符/指定的一个文件起作用,并且等待写磁盘操作结束才返回fsync可用于数据库这样的应用程序,这种应用程序需要确保修改过的块立即写到磁盘上。</p>
<p>fdatasync函数类似于 sync,但它只影响文件的数据部分。而除数据外, fsync还会同步更新文件的属性。</p>
<h2 id="函数fcntl"><a href="#函数fcntl" class="headerlink" title="函数fcntl"></a>函数fcntl</h2><p>fcntl函数可以改变已经打开文件的属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* int arg */</span> )</span></span>; </div><div class="line"></div><div class="line"><span class="comment">//Returns: depends on cmd if OK (see following), −1 on error</span></div></pre></td></tr></table></figure>
<p>fcnt1函数有以下5种功能</p>
<ol>
<li>复制一个已有的描述符(cmd= F_DUPFD或 F_DUPFD_CLOEXEC)。</li>
<li>获取/设置文件描述符标志(cmd= E_GETED或 F_SETED)。</li>
<li>获取/设置文件状态标志(cmd= F_GETEL或 F_SETEL)</li>
<li>获取/设置异步IO所有权(cmd= F_GETOWN或F_SETOWN)。</li>
<li>获取/设置记录锁(cmd= F_GETLK、 F_SETLK或 F_SETLKW)</li>
</ol>
<p>在修改文件描述符标志或文件状态标志时必须谨慎,先要获得现在的标志值,然后按照期望修改它,最后设置新标志值。不能只是执行 F_SETED或 E_SETEL命令,这样会关闭以前设置的标志位。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">set_fl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span> <span class="comment">/* flags are file status flags to turn on */</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span>		val;</div><div class="line"></div><div class="line">	<span class="comment">// 获取现在的文件标志位</span></div><div class="line">	<span class="keyword">if</span> ((val = fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</div><div class="line">		err_sys(<span class="string">"fcntl F_GETFL error"</span>);</div><div class="line"></div><div class="line">	<span class="comment">// 计算新的标志值</span></div><div class="line">	val |= flags;		<span class="comment">/* turn on flags */</span></div><div class="line">         </div><div class="line">	<span class="comment">// 设置新的标志值</span></div><div class="line">	<span class="keyword">if</span> (fcntl(fd, F_SETFL, val) &lt; <span class="number">0</span>)</div><div class="line">		err_sys(<span class="string">"fcntl F_SETFL error"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="函数ioctl"><a href="#函数ioctl" class="headerlink" title="函数ioctl"></a>函数ioctl</h2><p>每个设备驱动程序可以定义它自己专用的一组ioct1命令,系统则为不同种类的设备提供通用的 ioctl命令。</p>
<h2 id="dev-fd"><a href="#dev-fd" class="headerlink" title="/dev/fd"></a>/dev/fd</h2><p>较新的系统都提供名为/aev/fd的目录,其目录项是名为0、1、2等的文件。打开文件/dev/fd/n等效于复制描述符n(假定描述符n是打开的)。</p>
<p>大多数系统忽略它所指定的mode,而另外一些系统则要求mode必须是所引用的文件(在这里是标准输入)初始打开时所使用的打开模式的一个子集。</p>
<p>某些系统提供路径名/dev/ stdin、/dev/stdoυt和/dev/ stderr,这些等效于dev/fd/0、/dev/fd/1和/dev/fd/2。</p>
<p>dev/fd文件主要由shell使用,它允许使用路径名作为调用参数的程序,能用处理其他路径名的相同方式处理标准输入和输出。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第2章 文件I/O 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》笔记 C++标准库部分</title>
    <link href="https://www.liuin.cn/2018/03/04/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-C-%E6%A0%87%E5%87%86%E5%BA%93%E9%83%A8%E5%88%86/"/>
    <id>https://www.liuin.cn/2018/03/04/《C-Primer》笔记-C-标准库部分/</id>
    <published>2018-03-04T02:58:33.000Z</published>
    <updated>2018-03-08T02:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》笔记 C++基础部分</p>
<a id="more"></a>
<h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><p>大部分的I/O库设施：</p>
<ul>
<li>istream(输入流)类型,提供输入操作。</li>
<li>ostream(输出流)类型,提供输出操作。</li>
<li>cin，一个 istream对象,从标准输入读取数据。</li>
<li>cout,一个 ostream对象,向标准输出写入数据。</li>
<li>cerr,一个 ostream对象,通常用于输出程序错误消息,写入到标准错误・</li>
<li>>&gt;运算符,用来从一个istream对象读取输入数据。</li>
<li>&lt;&lt;运算符,用来向一个ostream对象写入输出数据。</li>
<li>getline函数,从一个给定的 istream读取一行数据,存入一个给定的 string对象中。</li>
</ul>
<h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><p>我们已经使用过的IO类型和对象都是操纵char数据的。默认情况下,这些对象都是关联到用户的控制台窗口的。</p>
<p>为了支持这些不同种类的IO处理操作,在 istream和ostream之外,标准库还定义了其他一些IO类型:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518671687211.jpg" alt="enter description here"></p>
<p>为了支持宽字符的语言，标准库定义了一组类型和对象来操纵wchat_t类型的数据。宽字符版本的类型和函数的名字以一个w开始。</p>
<blockquote>
<p>IO类型之间的关系</p>
</blockquote>
<p>标准库使我们能忽略这些不同类型的流之间的差异,这是通过<strong>继承机制</strong>( inheritance)实现的。利用模板,我们可以使用具有继承关系的类,而不必了解继承机制如何工作的细节。简单地说,继承机制使我们可以声明一个特定的类继承自另一个类。我们通常可以将一个派生类(继承类)对象当作其基类(所继承的类)对象来使用</p>
<h3 id="IO对象无拷贝或赋值"><a href="#IO对象无拷贝或赋值" class="headerlink" title="IO对象无拷贝或赋值"></a>IO对象无拷贝或赋值</h3><p>我们不能拷贝或者对IO对象赋值，由于不能拷贝IO对象，因此我们也不能将形参或者函数返回类型设置为流类型。进行IO操作的函数通常以引用的方式传递和返回流。</p>
<p>读取或者返回一个IO对象会改变其状态，因此传递和引用不能是const的</p>
<h3 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h3><blockquote>
<p>查询流状态</p>
</blockquote>
<p>IO库定义了一个与机器无关的 iostate类型,它提供了表达流状态的完整功能。这个类型应作为一个位集合来使用</p>
<blockquote>
<p>管理条件状态</p>
</blockquote>
<p>流对象的 rdstate 成员返回一个iostate值,对应流的当前状态。 setstate操作将给定条件位置位,表示发生了对应错误。clear成员是一个重載的成员:它有一个不接受参数的版本,而另一个版本接受一个 iostate类型型的参数。</p>
<h3 id="管理输出缓存"><a href="#管理输出缓存" class="headerlink" title="管理输出缓存"></a>管理输出缓存</h3><p>每一个输出流都管理一个缓冲区，用来保存程序读写的数据。</p>
<p>文本串可能立即打印出来,但也有可能被操作系统保存在缓冲区中,随后再打印。有了缓冲机制,操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很耗时,<strong>允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升</strong>。</p>
<p>导致缓冲刷新(即,数据真正写到输出设备或文件)的原因有很多：</p>
<ul>
<li>程序正常结束,作为main函数的 return操作的一部分,缓冲冲刷新被执行。</li>
<li>缓冲区满时,需要刷新缓冲,而后新的数据才能继续写入缓冲区。</li>
<li>我们可以使用操纵符如endl来显式刷新缓冲区。</li>
<li>在每个输出操作之后,我们可以用操纵符unitbuf设置流的内部状态,来清空缓冲区。</li>
<li>一个输出流可能被关联到另一个流。在这种情况下,当读写被关联的流时,关联到的流的缓冲区会被刷新。</li>
</ul>
<blockquote>
<p>刷新输出缓冲区</p>
</blockquote>
<p>我们已经使用过操纵符endl,它完成换行并刷新缓冲区的工作。IO库中还有两个类似的操纵符:flush和ends。flush刷新缓冲区,但不输出任何额外的字符;ends向缓冲区插入一个空字符,然后刷新缓冲区</p>
<blockquote>
<p>uintbuf操作符</p>
</blockquote>
<p>如果想在每次输出操作后都刷新缓冲区,我们可以使用 unitbuf操纵符。它告诉流在接下来的每次写操作之后都进行一次=flush操作。而 nounitbuf操纵符则重置流,使其恢复使用正常的系统管理的缓冲区刷新机制:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518672433805.jpg" alt="enter description here"></p>
<h2 id="文件的输入输出"><a href="#文件的输入输出" class="headerlink" title="文件的输入输出"></a>文件的输入输出</h2><p>头文件 fstream定义了三个类型来支持文件IO: ifstream从一个给定文件读取数据,ofstream向一个给定文件写入数据,以及 fstream可以读写给定文件。</p>
<p>除了继承自 iostream类型的行为之外, fstream中定义的类型还增加了一些新的成员来管理与流关联的文件</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518672783415.jpg" alt="enter description here"></p>
<h3 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h3><p>当我们想要读写一个文件时,可以定义一个文件流对象,并将对象与文件关联起来。每个文件流类都定义了一个名为open的成员函数,它完成一些系统相关的操作,来定位给定的文件,并视情况打开为读或写模式。</p>
<blockquote>
<p>成员函数open和close</p>
</blockquote>
<p>如果我们定义一个空文件流对象，随后我们可以调用open来将它与文件关联起来。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518672886373.jpg" alt="enter description here"></p>
<p>如果调用open失败, failbit会被置位。因为调用open可能失败,进行open是否成功的检测通常是一个好习惯</p>
<h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><p>每一个流都有一个关联的<strong>文件模式</strong>（file mode），用来指出如何使用文件。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518672976516.jpg" alt="enter description here"></p>
<p>无论用哪种方式打开文件,我们都可以指定文件模式,调用open打开文件时可以,用一个文件名初始化流来隐式打开文件时也可以。</p>
<blockquote>
<p>以out模式打开文件会丢弃</p>
</blockquote>
<p>已有数据默认情况下,当我们打开一个 ofstream时,文件的内容会被丢弃。阻止一个ofstream清空给定文件内容的方法是同时指定aap模式:</p>
<h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><p>sstream头文件定义了三个类型来支持内存IO,这些类型可以向 string写入数据,从string读取数据,就像string是一个IO流一样。</p>
<p>istringstream从 string读取数据，ostringstream向 string写入数据,而头文件 stringstream既可从 string读数据也可向 string写数据。与fstream类型类似,头文件 sstream中定义的类型都继承自我们已经使用过的 iostream头文件中定义的类型。除了继承得来的操作, sstream中定义的类型还增加了一些成员来管理与流相关联的string。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518676701978.jpg" alt="enter description here"></p>
<h3 id="使用istringstream"><a href="#使用istringstream" class="headerlink" title="使用istringstream"></a>使用istringstream</h3><p>当我们的某些工作室对整行的文本进行处理，而其他的一些工作是处理行内的单个单词时，通常可以使用istringstream</p>
<h3 id="使用ostringstream"><a href="#使用ostringstream" class="headerlink" title="使用ostringstream"></a>使用ostringstream</h3><p>当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>C++使用标准库类来处理面向流的输入和输出:</p>
<ol>
<li>iostream处理控制台</li>
<li>fstream处理命名文件</li>
<li>stringstream完成内存string的IO</li>
</ol>
<hr>
<h1 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h1><p>一个容器就是一些特定类型对象的集合。<strong>顺序容器</strong>( sequential container)为程序员提供了<strong>控制元素存储和访问顺序的能力</strong>。这种顺序<strong>不依赖于元素的值,而是与元素加入容器时的位置相对应</strong>。与之相对的,我们将在第11章介绍的有序和无序关联容器,则根据关键字的值来存储元素。</p>
<h2 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_16_1518790789624.jpg" alt="enter description here"></p>
<p>以上就是标准库中的顺序容器了，所有顺序容器提供快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：</p>
<ul>
<li>向容器添加或从容器中删除元素的代价</li>
<li>非顺序访问容器中元素的代价</li>
</ul>
<p>除了固定大小的的 array外,其他容器都提供高效、灵活的内存管理。</p>
<p>list和 forward_list 两个容器的设计目的是<strong>令容器任何位置的添加和删除操作都很快速</strong>。作为代价,这两个容器不支持元素的随机访问:为了访问一个元素,我们只能遍历整个容器。而且,与 vector、 deque和 array相比,这两个容器的额外内存开销也很大。</p>
<p>deque是一个更为复杂的数据结构。与string和 vector类似, deque支持快速的随机访问。与 string和 vector一样,在 deque的中间位置添加或删除元素的代价(可能)很高。但是,<strong>在 deque的两端添加或删除元素都是很快的</strong>,与list或forward_list添加删除元素的速度相当。</p>
<p>以下是选择容器的基本原则：</p>
<ul>
<li>除非你有很好的理由选择其他容器,否则应使用 vector。</li>
<li>如果你的程序有很多小的的元素,且空间的额外开销很重要,则不要使用list或forward_list。</li>
<li>如果程序要求随机访问元素,应使用 vector或 deque如果程序要求在容器的中间插入或删除元素,应使用list或forward_list。</li>
<li>如果程序需要在头尾位置插入或删除元素,但不会在中间位置进行插入或删除操作,则使用 deque</li>
<li>如果程序只有在读取输入时才需要在容器中间位置插入元素,随后需要随机访问元素,则：首先，确定是否真的需要在容器中间添加元素；如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的额内容拷贝到一个vector 中</li>
</ul>
<h2 id="容器库概览"><a href="#容器库概览" class="headerlink" title="容器库概览"></a>容器库概览</h2><p>容器类型上形成了一种层次：</p>
<ul>
<li>某些操作是所有容器类型都提供的</li>
<li>另外一些操作仅针对顺序容器、关联容器或无序容器</li>
<li>还有一些操作只适用于一小部分容器</li>
</ul>
<p>本节我们介绍所有容器都适用的操作</p>
<p>一般来说，每个容器都定义在一个头文件中，文件名与类型名相同；顺序容器几乎可以保存任意类型的元素。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_16_1518793115931.jpg" alt="enter description here"></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>与容器一样,迭代器有着公共的接口:如果一个迭代器提供某个操作,那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。</p>
<p>一个迭代器范围( iterator range)由一对迭代器表示,两个迭代器分别指向同一个容器中的元素或者是<strong>尾元素之后的位置</strong>( one past the last element)。这两个迭代器通常被称为 begin和end,或者者是 first和laste(可能有些误导),它们标记了容器中元素的个范围</p>
<p>这种元素范围被称为<strong>左闭合区间</strong>( left-inclusive interval),其标准数学描述为<code>[begin, end)</code></p>
<h3 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h3><p>反向迭代器就是一种反向遍历容器的迭代器,与正向迭代器相比,各种操作的含义也都发生了颠倒</p>
<p>,通过类型别名,我们可以在不了解容器中元素类型的情况下使用它。如果需要元素类型,可以使用容器的value_type。如果需要元素类型的一个引用,可以使用 reference或 const_reference。这些元素相关的类型别名在泛型编程中非常有用</p>
<h3 id="begin-和-end成员"><a href="#begin-和-end成员" class="headerlink" title="begin 和 end成员"></a>begin 和 end成员</h3><p>begin和end操作生成指向容器中第一个元素和尾元素之后位置的迭代器。这两个迭代器最常见的用途是形成一个包含容器中所有元素的迭代器范围</p>
<h3 id="容器定义和初始化"><a href="#容器定义和初始化" class="headerlink" title="容器定义和初始化"></a>容器定义和初始化</h3><p>每个容器类型都定义了一个默认构造函数。除 array之外,其他容器的默认构造函数都会创建一个指定类型的空容器,且都可以接受指定容器大小和元素初始值的参数。</p>
<blockquote>
<p>将一个容器初始化为另一个容器的拷贝</p>
</blockquote>
<p>将一个新容器创建为另一个容器的拷贝的方法有两种:可以直接拷贝整个容器,或者( array除外)拷贝由一个迭代器对指定的元素范围。为了创建一个容器为另一个容器的拷贝,两个容器的类型及其元素类型必须匹配。不过,当传递迭代器参数来拷贝一个范围时,就不要求容器类型是相同的了。而且,新容器和原容器中的元素类型也可以不同,只要能将要拷贝的元素转换</p>
<blockquote>
<p>与顺序容器大小相关的构造函数</p>
</blockquote>
<p>除了与关联容器相同的构造函数外,顺序容器( array除外)还提供另一个构造函数,它接受一个容器大小和一个(可选的)元素初始值。</p>
<h3 id="赋值与swap"><a href="#赋值与swap" class="headerlink" title="赋值与swap"></a>赋值与swap</h3><p>赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝。</p>
<blockquote>
<p>使用assign</p>
</blockquote>
<p>顺序容器( array除外)还定义了一个名为 assign的成员,允许我们从一个不同但相容的类型赋值,或者从容器的一个子序列赋值。assign操作用参数所指定的元素(的拷贝)替换左边容器中的所有元素。例如,我们可以用 assign实现将一个 vector中的一段char*值赋予一个list中的 string：<br><img src="https://data2.liuin.cn/story-writer/2018_2_16_1518794438240.jpg" alt="enter description here"></p>
<blockquote>
<p>使用swap</p>
</blockquote>
<p>除 array外,交换两个容器内容的操作保证会很快——元素本身并未交换,swap只是交換了两个容器的内部数据结构。</p>
<p>元素不会被移动的事实意味着,除string外,指向容器的迭代器、引用和指针在swap操作之后都不会失效。它们仍指向swap操作之前所指向的那些元素。但是,在swap之后,这些元素已经属于不同的容器了。</p>
<p>与其他容器不同,swap两个 array会真正交换它们的元素。因此,交換两个 array所需的时间与 array中元素的数目成正比。</p>
<h3 id="容器大小操作"><a href="#容器大小操作" class="headerlink" title="容器大小操作"></a>容器大小操作</h3><p>除了一个例外,每个容器类型都有三个与大小相关的操作：</p>
<ul>
<li>成员函数size，返回容器中元素的数目; </li>
<li>empty当size为0时返回布尔值true,否则返回回false</li>
<li>max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。</li>
</ul>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符左右两边的运算对象必须是相同类型的容器,且必须保存相同类型的元素。</p>
<p>比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与string的关系运算类似:</p>
<ul>
<li>如果两个容器具有相同大小且所有元素都两两对应相等,则这两个容器相等;否则两个容器不等</li>
<li>如果两个容器大小不同,但较小容器中每个元素都等于较大容器中的对应元素,则则较小容器小于较大容器。</li>
<li>如果两个容器都不是另一个容器的前缀子序列,则它们的比较结果取決于第一个不相等的元素的比较结果。</li>
</ul>
<h2 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h2><h3 id="向顺序容器添加元素"><a href="#向顺序容器添加元素" class="headerlink" title="向顺序容器添加元素"></a>向顺序容器添加元素</h3><p>除 array外,所有标准库容器都提供灵活的内存管理。在运行时可以动态添加或刑除元素来改变容器大小。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518833554118.jpg" alt="enter description here"></p>
<p>在一个 vector或 string的尾部之外的任何位置,或是一个 deque的首尾之外的任何位置添加元素,都需要移动元素。而且,向一个 vector或 string添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存,并将元素从旧的空间移动到新的空间中。</p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>包括 array在内的每个顺序容器都有一个 front成员函数,而除 forward_list之外的所有顺序容器都有一个back成员函数。这两个操作分别返回首元素和尾元素的引用</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518833711199.jpg" alt="enter description here"></p>
<blockquote>
<p>下标操作和安全的随机访问</p>
</blockquote>
<p>提供快速随机访问的容器( string、 vector、 deque和 array)也都提供下标运算符。就像我们已经看到的那样,下标运算符接受一个下标参数,返回容器中该位置的元素的引用。<strong>给定下标必须“在范围内”</strong>(即,大于等于0,且小于容器的大小)。保证下标有效是程序员的责任,下标运算符并不检査下标是否在合法范围内。<strong>使用越界的下标是一种严重的程序设计错误</strong>,而且编译器并不检査这种错误。</p>
<p>如果我们希望确保下标是合法的,可以使用at成员函数。at成员函数类似下标运算,但如果下标越界,at会地出一个out of range异常:</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518834076074.jpg" alt="enter description here"></p>
<h3 id="特殊的forward-list操作"><a href="#特殊的forward-list操作" class="headerlink" title="特殊的forward_list操作"></a>特殊的forward_list操作</h3><p>在一个单向链表中,没有简单的方法来获取一个元素的前驱。出于这个原因,在一个 forward_list中添加或删除元素的操作是通过改变给定元素之后的元素来完成的</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518834143966.jpg" alt="enter description here"></p>
<h3 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h3><p>我们可以用rsize来增大或缩小容器・与往常一样, array不支持 resize。如果当前大小大于所要求的大小,容器后部的元素会被別除:如果当前大小小于新大小,会将新元素添加到容器后部:</p>
<h3 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h3><p>向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误,很可能引起与使用未初始化指针一样的问题</p>
<p>当你使用迭代器(或指向容器元素的引用或指针)时,最小化要求迭代器必须保持有效的程序片段是一个好的方法。</p>
<p>程序必须保证每个循环中都更新迭代器、引用或指针</p>
<blockquote>
<p>不要保存end返回的迭代器</p>
</blockquote>
<p>当我们添加删除 vector或 string的元素后,或在 deque中首元素之外任何位置添加删除元素后,原来end返回的迭代器总是会失效。因此,<strong>添加或删除元素的循环程序必须反复调用end,而不能在循环之前保存end返回的迭代器</strong>,一直当作容器末尾使用。通常C++标准库的实现中end()操作都很快,部分就是因为这个原因。</p>
<h2 id="vector对象是如何增长的"><a href="#vector对象是如何增长的" class="headerlink" title="vector对象是如何增长的"></a>vector对象是如何增长的</h2><p>为了支持快速随机访问，vector将元素连续存储——每个元素紧挨着前一个元素存储。</p>
<p>假定容器中元素是连续存储的,且容器的大小是可变的,考虑向 vector或string中添加元素会发生什么:如果没有空间容纳新元素,容器不可能简单地将它添加到内存中其他位置一一因为元素必须连续存储。容器必须分配新的内存空间来保存已有元素和新元素,将已有元素从旧位置移动到新空间中,然后添加新元素,释放旧存储空间。如如果我们每添加一个新元素, vector就执行一次这样的内存分配和释放操作,性能会慢到不可</p>
<p>为了避免这种代价,标准库实现者采用了可以减少容器空间重新分配次数的策略。当不得不获取新的内存空间时, vector和 string的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用,可用来保存更多的新元素。</p>
<p>vector 在每次重新分配内存的时候都要移动所有元素</p>
<blockquote>
<p>管理容量的成员函数</p>
</blockquote>
<p> capacity操作告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素。 reserve操作允许我们通知容器它应该准备保存多少个元素。</p>
<blockquote>
<p>capacity和size</p>
</blockquote>
<p>理解 capacity和size的区别非常重要。容器的size是指它已经保存的元素的数目;而 capacity则是在不分配新的内存空间的前提下它最多可以保存多少元素。</p>
<h2 id="额外的string操作"><a href="#额外的string操作" class="headerlink" title="额外的string操作"></a>额外的string操作</h2><h3 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861676844.jpg" alt="enter description here"></p>
<blockquote>
<p>substr操作</p>
</blockquote>
<p>substr操作返回一个str1ng,它是原始 string的一部分或全部的拷贝。可以传递给 substr一个可选的开始位置和计数值:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861736953.jpg" alt="enter description here"></p>
<h3 id="改变string的其他方法"><a href="#改变string的其他方法" class="headerlink" title="改变string的其他方法"></a>改变string的其他方法</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861803653.jpg" alt="enter description here"></p>
<h3 id="string搜索操作"><a href="#string搜索操作" class="headerlink" title="string搜索操作"></a>string搜索操作</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861836971.jpg" alt="enter description here"></p>
<h3 id="compare函数"><a href="#compare函数" class="headerlink" title="compare函数"></a>compare函数</h3><p>除了关系运算符外,标准准库str1ng类型还提供了一组compare函数,这些函数与C标准库的 strcmp函数很相似。类似 strcmp,据据s是等于、大于还是小于参数指定的字符串,s. compare返回回0、正数或负数。</p>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861942715.jpg" alt="enter description here"></p>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>除了顺序容器外,标准库还定义了三个顺序容器适配器: stack、 queue和priority_queue。<strong>适配器</strong>( adaptor)是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上,<strong>一个适配器是一种机制,能使某种事物的行为看起来像另外一种事物一样</strong>。一个容器适配器接受一种已有的容器类型,使其行为看起来像一种不同的类型。</p>
<blockquote>
<p>定义一个适配器</p>
</blockquote>
<p>每个适配器都定义两个构造函数:默认构造函数创建一个空对象,接受一个容器的构造函数拷贝该容器来初始化适配器。</p>
<p>默认情况下, stack和 queue是基于 deque实现的,priority_queue是在 vector之上实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第三个类型参数,来重载默认容器类型。</p>
<p>对于一个给定的适配器,可以使用哪些容器是有限制的。所有适配器都要求容器具有添加和删除元素的能力。因此,适配器不能构造在aray之上。类似的,我们也不能用forward_list来构造适配器,因为所有适配器都要求容器具有添加、删除以及访间尾元素的能力。 stack只要求 push_back、 pop_back和back操作,因此可以使用除 array</p>
<blockquote>
<p>栈适配器<br><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518862439794.jpg" alt="enter description here"></p>
</blockquote>
<p>每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作。我们只可以使用适配器操作,而不能使用底层容器类型的操作。</p>
<blockquote>
<p>队列适配器</p>
</blockquote>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518862492187.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518862504010.jpg" alt="enter description here"></p>
<p>标准库queue使用一种先进先出（first-in，first-out，FIFO）的存储和访问策略</p>
<p>priority_queue 允许我们为队列中的元素建立优先级，新加入的元素会排在所有优先级比它低的已有元素之前。</p>
<hr>
<h1 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h1><p>标准库容器定义的操作集合惊人得小。标准库并未给每个容器添加大量功能,而是提供了一组算法,这些算法中的大多数都独立于任何特定的容器。这些算法是通用的( generic,或称泛型的):它们可用于不同类型的容器和不同类型的元素。</p>
<p>顺序容器只定义了很少的一些操作，我们可以想象用户可能还希望做其他很多有用的操作:查找特定元素、替換或別除二个特定值、重排元素顺序等。</p>
<p>标准库并未给每个容器都定义成员函数来实现这些操作,而是定义了一组<strong>泛型算法</strong>( generic algorithm):称它们为“算法”,是因为它们实现了一些经典算法的公共接接口,如排序和搜索;称它们是“泛型的”,是因为它们可以用于不同类型的元素和多种容器类型</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一般情况下,泛型算法并不直接操作容器,而是遍历由两个迭代器指定的一个元素范围来进行操作。</p>
<p><strong>迭代器令算法不依赖于容器，但是算法依赖于容器的操作类型</strong>。虽然迭代器的使用令算法不依赖于容器类型,但大多数算法都使用了一个(或多个)元素类型上的操作。</p>
<p>泛型算法本身不会执行容器的操作，它们只会运行于迭代器上，执行迭代器的操作。</p>
<h2 id="初始泛型算法"><a href="#初始泛型算法" class="headerlink" title="初始泛型算法"></a>初始泛型算法</h2><h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p>一些算法只会读取其输入范围内的元素,而从不改变元素。find就是这样一种算法</p>
<p>另一个只读算法是 accumulate,它定义在头文件 numeric i中。 accumulate函数接受三个参数,前两个指出了需要求和的元素的范围,第三个参数是和的初值。accumulate将第三个参数作为求和起点,这蕴含着一个编程假定:将元素类型加到和的类型上的操作必须是可行的。即,序列中元素的类型必须与第三个参数匹配,或者能够转换为第三个参数的类型。</p>
<p>另一个只读算法是equal，用于确定两个序列是否保存相同的值。</p>
<h3 id="写容器元素的算法"><a href="#写容器元素的算法" class="headerlink" title="写容器元素的算法"></a>写容器元素的算法</h3><p>一些算法将新值赋予序列中的元素。当我们使用这类算法时,必须注意<strong>确保序列原大小至少不小于我们要求算法写入的元素数目</strong>。记住,<strong>算法不会执行容器操作,因此它们身不可能改变容器的大小</strong>。</p>
<p>一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素,该序列从目的位置迭代器指向的元素开始。</p>
<blockquote>
<p>介绍back_inserter</p>
</blockquote>
<p>一种保证算法有足够元素空间来容纳输出数据的方法是使用<strong>插入迭代器</strong>( InsertIterator)。插入送代器是一种向容器中添加元素的迭代器。通常情况,当我们通过一个送代器向容器元素赋值时,值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时,一个与赋值号右側值相等的元素被添加到容器中。</p>
<p>back_inserter接受一个指向容器的引用,返回一个与该容器绑定的插入迭代器当我们通过此迭代器赋值时,赋值运算符会调用 push_back将一个具有给定值的元素添加到容器中</p>
<blockquote>
<p>拷贝算法</p>
</blockquote>
<p>拷贝(copy)算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器,前两个表示一个输入范围,第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。</p>
<h3 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h3><p>某些算法会重排容器中元素的顺序,一个明显的例子是sort。调用sort会重排输入序列中的元素,使之有序,它是利用元素类型的运算符来实现排序的</p>
<blockquote>
<p>清除重复单词</p>
</blockquote>
<p>我们就可以使用另一个称为unique的标准库算法来重排ⅴector,使得不重复的元素出现在ⅴector的开始部分。由于算法不能执行容器的操作,我们将使用 vector的 erase成员来完成真正的删除操作</p>
<h2 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h2><p>很多算法都会比较输入序列中的元素。默认情况下,这类算法使用元素类型的&lt;或=运算符完成比较。标准库还为这些算法定义了额外的版本,允许<strong>我们提供自己定义的操作来代替默认运算符</strong>。</p>
<h3 id="向算法传递参数"><a href="#向算法传递参数" class="headerlink" title="向算法传递参数"></a>向算法传递参数</h3><blockquote>
<p>谓词</p>
</blockquote>
<p>谓词是一个可调用的表达式,其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类:一元谓词( unary predicate,意味着它们只接受单一参数)和二元谓词binary predicate,,意味着它们有两个参数)。接受谓词参数的算法对输入序列中的元素调用谓词。因此,元素类型必须能转换为谓词的参数类型。接受一个二元谓词参数的sOrt版本用这个谓词代替&lt;来比较元素。</p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>根据算法接受一元谓词还是二元谓词,我们传递给算法的谓词必须严格接受一个或两个参数。但是,有时我们希望进行的操作需要更多参数,超出了算法对谓词的限制。</p>
<blockquote>
<p>介绍lambda</p>
</blockquote>
<p>我们可以向一个算法传递任何类别的<strong>可调用对象</strong>( callable object)。对于一个对象或一个表达式,如果可以对其使用调用运算符,则称它为可调用的。即,如果e是一个可调用的表达式,则我们可以编写代码e(args),其中args是个逗号分隔的一个或多个参数的列表</p>
<p>到目前为止,<strong>我们使用过的仅有的两种可调用对象是函数和函数指针</strong>。还有其他两种可调用对象:重载了函数调用运算符的类,,以及 lambda表达式( lambda expression)</p>
<p>一个 lambda表达达式表示一个可调用的代码单元。我们们可以将其理解为一个未命名的内联函数。与任何函数类似似,一个 lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同, lambda可能定义在函数内部。一个 lambda表达式具有如下形式：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_18_1518953656030.jpg" alt="enter description here"></p>
<blockquote>
<p>向lambda传递参数</p>
</blockquote>
<p>与一个普通函数调用类似,调用一个 lambda时给定的实参被用来初始化 lambda的形参。通常,实参和形参的类型必须匹配。但与普通函数不同, <strong>lambda不能有默认参数</strong>。因此,一个 lambda调用的实参数目永远与形参数目相等。</p>
<blockquote>
<p>使用捕获列表</p>
</blockquote>
<p>虽然一个 lambda可以出现在一个函数中,使用其局部变量,但它只能使用那些明确指明的变量。<strong>一个 lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量</strong>。捕获列表指引 lambda在其内部包含访问局部变量所需的信息。</p>
<h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>当定义一个 lambda时,编译器生成一个与 lambda对应的新的(未命名的)类类型。目前,可以这样理解,当向个函数传递一个 lambda时,同时定义了一个新类型和该类型的一个对象:传递的参数就是此编译器生成的类类型的未命名对象。类似的,当使用auto定义一个用 lambda初始化的变量时,定义了一个从 lambda生成的类型的对象。</p>
<p>默认情況下,从 lambda生成的类都包含一个对应该 lambda 所捕获的変量的数据成员。类似任何普通类的数据成员, lambda的数据成员也在 lambda对象创建时被初始化。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_18_1518954256455.jpg" alt="enter description here"></p>
<blockquote>
<p>值捕获</p>
</blockquote>
<p>类似参数传递，变量的捕获方式也可以是值或引用。与传值参数类似,采用值捕获的前提是变量可以拷贝。与参数不同,被捕获的变量的值是在 lambda创建时拷贝,而不是调用时拷贝</p>
<blockquote>
<p>引用捕获</p>
</blockquote>
<p>一个以引用方式捕获的变量与其他任何类型的引用的行为类似。当我们在 lambda 函数体内使用此变量时,实际上使用用的是引用所绑定的对象。</p>
<blockquote>
<p>隐式捕获</p>
</blockquote>
<p>除了显式列出我们希望使用的来自所在函数的变量之外,还可以让编译器根据 lambda体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表,应在捕获列表中写一个&amp;或=。&amp;告诉编译器采用捕获引用方式,=则表示采用值捕获方式。</p>
<p>当我们混合使用隐式捕获和显式捕获时,捕获列表中的第一个元素必须是一个&amp;或=。此符号指定了默认捕获方式为引用或值。</p>
<p>当混合使用隐式捕获和显式捕获时,显式捕获的变量必须使用与隐式捕获不同的方式。即,如果隐式捕获是引用方式(使用了&amp;),则则显式捕获命名变量必须采用值方式,因此不能在其名字前使用&amp;。类似的,如如果隐式捕获采用的是值方式(使用了=),则显式捕获命名变量必须采用引用方式,即,在名字前使用&amp;。</p>
<blockquote>
<p>可变lambda</p>
</blockquote>
<p>默认情况下,对于一个值被拷贝的变量, lambda不会改变其值。如果我们希望能改变个被捕获的变量的值,就必须在参数列表首加上关键键字 mutale。</p>
<blockquote>
<p>指定的lambda返回类型</p>
</blockquote>
<p>默认情况下,如果一个 lambda体包含 return之外的任何语句,则编译器假定此 lambda返回void。与其他返回void的函数类似,被推断返回void的 lambda不能返回值。</p>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>对于那种只在一两个地方使用的简单操作, lambda表达式是最有用的。如果我们需要在很多地方使用相同的操作,通常应该定义一个函数,而不是多次编写相同的 lambda表达式。类似的,如果一个操作需要很多语句才能完成,通通常使用函数更好。</p>
<p>如果lambda的捕获列表为空，通常可以用函数来替代它。</p>
<p>但是,对于捕获局部变量的 lambda,用函数来替换它就不是那么容易了。</p>
<blockquote>
<p>标准bind函数</p>
</blockquote>
<p>我们可以解决向 check_size传递递一个长度参数的问题,方法是使用一个新的名为bind的标准库函数,它定义在头文件 functiona1中。可以将bind函数看作一个通用的函数适配记器,它接受一个可调用对象,生成一个新的可调用对象来“适应”原对象的参数列表</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_18_1518954580235.jpg" alt="enter description here"></p>
<h2 id="再探迭代器"><a href="#再探迭代器" class="headerlink" title="再探迭代器"></a>再探迭代器</h2><p>除了为每个容器定义的迭代器之外,标准库还定义了额外几种迭代器。这些迭代器包括以下几种</p>
<ul>
<li>插入迭代器( Insert iterator):这些迭代器被绑定到一个容器上,可用来向容器插入元素</li>
<li>流迭代器( stream Iterator):这些迭代器被绑定到输入或输出流上,可用来遍历所关联的IO流。</li>
<li>反向迭代器( reverse Iterator):这些迭代器向后而不是向前移动。除了forward1ist之外的标准库容器都有反向迭代器。</li>
<li>移动迭代器( move iterator):这些专用的迭代器不是拷贝其中的元素,而是移动它们。我们将在13.6.2节(第480页)介绍移动迭代器</li>
</ul>
<h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><p>插入器是一种迭代器适配器,它接受一个容器,生成一个迭代器,能实现向给定容器添加元素。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519893284405.jpg" alt="enter description here"></p>
<p>插入器有三种类型，其差异在于元素插入的位置：</p>
<ul>
<li>back_inserter创建一个使用 push_back的迭代器</li>
<li>front_inserter创建一个使用 push_front的迭代器</li>
<li>inserter创建一个使用 insert的迭代器。此函数接受第二个参数,这个参数必须是一个指向给定容器的迭代器。<strong>元素将被插入到给定迭代器所表示的元素之前</strong>。</li>
</ul>
<h3 id="iostream-迭代器"><a href="#iostream-迭代器" class="headerlink" title="iostream 迭代器"></a>iostream 迭代器</h3><p>虽然 iostream类型不是容器,但标准库定义了可以用于这些IO类型对象的迭代器。istream iterator读取输入流,ostream iterator向一个输出流写数据。<strong>这些迭代器将它们对应的流当作一个特定类型的元素序列来处理</strong>。通过使用流迭代器,我们可以用泛型算法从流对象读取数据以及向其写入数据。</p>
<blockquote>
<p>istream_iterator 允许使用懒惰求值</p>
</blockquote>
<p>当我们将一个 istream_iterator绑定到一个流时,标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据,直到我们使用迭代器时才真正读取。标准库中的实现所保证的是,<strong>在我们第一次解引用迭代器之前,从流中读取数据的操作已经完成了</strong>。对于大多数程序来说,立即读取还是推迟读取没什么差别。</p>
<h3 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h3><p>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器,递增(以及递减)操作的含义会颠倒过来。递增一个反向迭代器(++it)会移动到前一个元素;递减一个迭代器(–it)会移动到下一个元素。</p>
<p>除了 forwardlist之外,其他容器都支持反向迭代器。</p>
<h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><p>任何算法的最基本的特性是它要求其迭代器提供哪些操作。算法所要求的迭代器操作可以分为5个迭代器类别( Iterator category)。每个算法都会对它的每个迭代器参数指明须提供哪类迭代器。</p>
<p>算法还共享了一组参数传递规范和一组命名规范</p>
<h3 id="5类迭代器"><a href="#5类迭代器" class="headerlink" title="5类迭代器"></a>5类迭代器</h3><p>类似容器,迭代器也定义了一组公共操作。一些操作所有迭代器都支持,另外一些只有特定类别的迭代器才支持。例如, ostream_iterator只支持递增、解引用和赋值。vector、 string和 deque的迭代器除了这些操作外,还支持递减、关系和算术运算。</p>
<p>C++标准指明了泛型和数值算法的每个迭代器参数的最小类别。例如,find算法在一个序列上进行一遍扫描,对元素进行只读操作,因此至少需要输入迭代器。 </p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519894770101.jpg" alt="enter description here"></p>
<h3 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h3><p>在任何其他算法分类之上,还有一组参数规范。理解这些参数规范对学习新算法很有帮助—通过理解参数的含义,你可以将注意力集中在算法所做的操作上。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519894916626.jpg" alt="enter description here"></p>
<h3 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h3><p>除了参数规范,算法还遵循一套命名和重载规范。这些规范处理诸如:如何提供一个操作代替默认的&lt;或==运算符以及算法是将输出数据写入输入序列还是一个分离的目的位置等问题。</p>
<h2 id="特定容器算法"><a href="#特定容器算法" class="headerlink" title="特定容器算法"></a>特定容器算法</h2><p>与其他容器不同,链表类型list和forward_list定义了几个成员函数形式的算法。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519895023511.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519895035177.jpg" alt="enter description here"></p>
<hr>
<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>关联容器和顺序容器有着根本的不同:关联容器中的元素是按关键字来保存和访问的。与之相对,顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p>
<p>关联容器支持高效的关键字查找和访问。两个主要的<strong>关联容器</strong>( associative container)类型是map和set。map中的元素是一些关键字-值( key-value)对:关键字起到索引的作用,值则表示与索引相关联的数据。set中每个元素只包含一个关键字;set支持高效的关键字查询操作——检查一个给定关键字是否在set中。</p>
<p>标准库提供8个关联容器,。这8个容器间的不同体现在三个维度上:每个容器<br>(1)<strong>或者是一个set,或者是一个map</strong>;<br>(2)<strong>或者要求不重复的关键字,或者允许重复关键字</strong>;<br>(3)<strong>按顺序保存元素,或无序保存</strong></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519989186109.jpg" alt="enter description here"></p>
<h2 id="使用关联容器"><a href="#使用关联容器" class="headerlink" title="使用关联容器"></a>使用关联容器</h2><p>map是关键字值对的集合。例如,可以将一个人的名字作为关键字,将其电话号码作为值。我们称这样的数据结构为“将名字映射到电话号码”。map类型通常被称为关联数组( associative array)。关联数组与“正常”数组类似,不同之处在于其下标不必是整数。</p>
<p>与之相对,set就是关键字的简单集合。当只是想知道一个值是否存在时,set是最有用的。</p>
<h2 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h2><p>关联容器不支持顺序容器的位置相关的操作,例如 push_front或 push_back。原因是<strong>关联容器中元素是根据关键字存储的,这些操作对关联容器没有意义</strong>。而且,关联容器也<strong>不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作</strong>。</p>
<h3 id="定义关联容器"><a href="#定义关联容器" class="headerlink" title="定义关联容器"></a>定义关联容器</h3><p>当定义一个map时,必须既指明关键字类型又指明值类型;而定义一个set时,只需指明关键字类型,因为set中没有值。</p>
<p>map的初始化：<br><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519990637584.jpg" alt="enter description here"></p>
<h3 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h3><p>对于有序容器—map、 multimap、set以及 multiset,<strong>关键字类型必须定义元素比较的方法</strong>。默认情况下,标准库使用关键字类型的&lt;运算符来比较两个关键字。</p>
<blockquote>
<p>有序容器的关键字类型</p>
</blockquote>
<p>可以向一个算法提供我们自己定义的比较操作,与之类似也可以提供自己定义的操作来代替关键字上的&lt;运算符。所提供的操作必须在关键字类型上定义一个<strong>严格弱序</strong>( strict weak ordering)。</p>
<blockquote>
<p>使用关键字类型的比较函数</p>
</blockquote>
<p>用来组织一个容器中元素的操作的类型也是该容器类型的一部分。<strong>为了指定使用自定义的操作,必须在定义关联容器类型时提供此操作的类型</strong>。如前所述,用尖括号指出要定义哪种类型的容器,自定义的操作类型必须在尖括号中紧跟着元素类型给出</p>
<p>此处,我们使用 decltype来指出自定义操作的类型。记住,当用 decltype来获得一个函数指针类型时,必须加上一个*来指出我们要使用一个给定函数类型的指针</p>
<h3 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h3><p>在介绍关联容器操作之前,我们需要了解名为pair的标准库类型,它定义在头文件utility中。</p>
<p>一个pair保存两个数据成员。类似容器,pair是一个用来生成特定类型的模板当创建一个pair时,我们必须提供两个类型名,pa1r的数据成员将具有对应的类型。两个类型不要求一样:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519991091913.jpg" alt="enter description here"></p>
<p>与其他标准库类型不同,pair的数据成员是public的。两个成员分别命名为 first和 second。我们用普通的成员访问符号来访问它们</p>
<h2 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a>关联容器操作</h2><p>关联容器还定义了一些表示容器关键字和值的类型</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992027517.jpg" alt="enter description here"></p>
<h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><p>当解引用一个关联容器迭代器时,我们会得到一个类型为容器的value_type的值的引用。对map而言,value_type是一个pair类型,其 first成员保存 const的关键字, second成员保存值</p>
<blockquote>
<p>set 的迭代器是const的</p>
</blockquote>
<p>虽然set类型同时定义了 iterator和 const_iterator类型,但两种类型都只允许只读访问set中的元素。与不能改变一个map元素的关键字一样,一个set中的关键字也是 const的。可以用一个set迭代器来读取元素的值,但不能修改:</p>
<blockquote>
<p>遍历关联容器</p>
</blockquote>
<p>map和set类型都支持 begin和end操作。与往常一样我们可以用这些函数获取迭代器,然后用迭代器来遍历容器。</p>
<blockquote>
<p>关联容器和算法</p>
</blockquote>
<p>我们通常不对关联容器使用泛型算法。关键字是 const这一特性意味着<strong>不能将关联容器传递给修改或重排容器元素的算法</strong>,因为这类算法需要向元素写入值,而set类型中的元素是cnst的,map中的元素是pair,其第一个成员是 const的。</p>
<p>关联容器可用于只读取元素的算法。</p>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>关联容器的 insert成员向容器中添加一个元素或一个元素范围。由于map和set(以及对应的无序类型)包含不重复的关键字,因此插入一个已存在的元素对容器没有任何影响</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992536522.jpg" alt="enter description here"></p>
<blockquote>
<p>向map添加元素</p>
</blockquote>
<p>对一个map进行 insert操作时,必须记住元素类型是pair。通常,对于想要插入的数据,并没有一个现成的pair对象。可以在 insert的参数列表中创建一个pair</p>
<blockquote>
<p>检测insert的返回值</p>
</blockquote>
<p>insert(或emplace)返回的值依赖于容器类型和参数。对于不包含重复关键字的容器,添加单一元素的 insert和 emplace版本返回一个pair,告诉我们插入操作是否成功。pair的 first成员是一个迭代器,指向具有给定关键字的元素; second成员是一个bool值,指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中</p>
<h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992521248.jpg" alt="enter description here"></p>
<h3 id="map的下标操作"><a href="#map的下标操作" class="headerlink" title="map的下标操作"></a>map的下标操作</h3><p>map和 unordered_map容器提供了下标运算符和一个对应的at函数。set类型不支持下标,因为set中没有与关键字相关联的“值”。元素本身就是关键字,因此“获取与一个关键字相关联的值”的操作就没有意义了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992604789.jpg" alt="enter description here"></p>
<h3 id="访问元素-1"><a href="#访问元素-1" class="headerlink" title="访问元素"></a>访问元素</h3><p>关联容器提供多种查找一个指定元素的方法</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992681370.jpg" alt="enter description here"></p>
<blockquote>
<p>对map使用find代替下标操作</p>
</blockquote>
<p>对map和 unordered map类型,下标运算符提供了最简单的提取元素的方法。但是如我们所见,使用下标操作有一个严重的副作用:如果关键字还未在map中,下标操作会插入一个具有给定关键字的元素。这种行为是否正确完全依赖于我们的预期是什么。</p>
<h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p>新标准定义了4个<strong>无序关联容器</strong>( unordered associative container)。这些容器不是使用比较运算符来组织元素,而是使用一个哈希函数( hash function)和关键字类型==运算符。在关键字类型的元素没有明显的序关系的情况下,无序容器是非常有用的。</p>
<blockquote>
<p>使用无序容器</p>
</blockquote>
<p>除了哈希管理操作之外,无序容器还提供了与有序容器相同的操作(find、 insert）</p>
<blockquote>
<p>管理桶</p>
</blockquote>
<p>无序容器在存储上组织为一组桶,每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素,容器首先计算元素的哈希值,它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字,所有具有相同关键字的元素也都会在同一个桶中。因此,无序容器的性能依赖于哈希函数的质量和桶的数量和大小。</p>
<hr>
<h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><p>动态对象的正确释放被证明是编程中极其容易出错的地方。为了更安全地使用动态对象,标准库定义了两个智能指针类型来管理动态分配的对象。<strong>当一个对象应该被释放时,指向它的智能指针可以确保自动地释放它</strong>。</p>
<p>除了静态内存和栈内存,每个程序还拥有一个内存池。这部分内存被称作<strong>自由空间</strong>( free store)或<strong>堆</strong>(heap)。程序用堆来存储动态分配( dynamically allocate)的对象——即那些在程序运行时分配的对象。</p>
<h2 id="动态内存和智能指针"><a href="#动态内存和智能指针" class="headerlink" title="动态内存和智能指针"></a>动态内存和智能指针</h2><p>在++中,动态内存的管理是通过一对运算符来完成的:new,在动态内存中为对象分配空间并返回一个指向该对象的指针,我们可以选择对对象进行初始化; delete,接受一个动态对象的指针,销毁该对象,并释放与之关联的内存</p>
<p>为了更容易(同时也更安全)地使用动态内存,新的标准库提供了两种智能指针( smartpointer.)类型来管理动态对象。智能指针的行为类似常规指针,重要的区别是它<strong>负责自动释放所指向的对象</strong>。新标准库提供的这两种智能指针的区别在于管理底层指针的方式shared_ptr允许多个指针指向同一个对于象; unique_ptr则“独占”所指向的对象。标准库还定义了一个名为 weak_ptr的伴随类,它是一种弱引用,指向 shared_ptr所管理的对象。这三种类型都定义在 memory头文件中。</p>
<h3 id="share-ptr类"><a href="#share-ptr类" class="headerlink" title="share_ptr类"></a>share_ptr类</h3><p>类似 vector,智能指针也是模板。因此,当我们创建一个智能指针十时,必须提供额外的信息—指针可以指向的类型。智能指针的使用方式与普通指针类似。解引用一个智能指针返回它指向的对象。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520129716802.jpg" alt="enter description here"></p>
<blockquote>
<p>make_shared 函数</p>
</blockquote>
<p>最安全的分配和使用动态内存的方法是调用一个名为 make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它,返回指向此对象的 shared_ptr。</p>
<p>当要用 make_shared时,必须指定想要创建的对象的类型。定义方式与模板类相同在函数名之后跟一个尖括号,在其中给出类型</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520129795731.jpg" alt="enter description here"></p>
<blockquote>
<p>shared_ptr 的拷贝和赋值</p>
</blockquote>
<p>我们可以认为每个 shared_ptr都有一个关联的计数器,通常称其为<strong>引用计数</strong>( reference count)。无论何时我们拷贝一个 shared_ptr,计数器都会递增。一旦一个 shared_ptr的计数器变为0,它就会自动释放自己所管理的对象</p>
<blockquote>
<p>shared_ptr 自动销毁所管理的对象</p>
</blockquote>
<p>当指向一个对象的最后一个 shared_ptr被销毁时, shared_ptr类会自动销毁此对象。它是通过另一个特殊的成员函数——析构函数( destructor)完成销毁工作的。</p>
<blockquote>
<p>使用动态生存期的资源的类</p>
</blockquote>
<p>程序使用动态内存出于以下三种原因之一：</p>
<ul>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个资源之间共享数据</li>
</ul>
<h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><p>C++语言定义了两个运算符来分配和释放动态内存。运算符new分配内存, delete释放new分配的内存。</p>
<blockquote>
<p>使用new动态分配和初始化对象</p>
</blockquote>
<p>在自由空间分配的内存是无名的,因此new无法为其分配的对象命名,而是返回一个指向该对象的指针。</p>
<p>默认情况下,动态分配的对象是默认初始化的,这意味着内置类型或组合类型的对象的值将是未定义的,而类类型对象将用默认构造函数进行初始化</p>
<blockquote>
<p>内存耗尽</p>
</blockquote>
<p>一旦一个程序用光了它所有可用的内在,new表达式就会失败。默认情况下,加果new不能分配所要求的内存空间,它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常:</p>
<p>动态内存管理的时候非常容易出错：</p>
<ol>
<li>忘记delete内存</li>
<li>使用已经释放掉的对象</li>
<li>同一块内存释放两次</li>
</ol>
<blockquote>
<p>delete 之后重置指针</p>
</blockquote>
<p>当我们 delete一个指针后,指针值就变为无效了。虽然指针已经无效,但在很多机器上指针仍然保存着(已经释放了的)动态内存的地址。在 delete之后,指针就变成了人们所说的<strong>空悬指针</strong>( dangling pointer),即<strong>指向一块曾经保存数据对象但现在已经无效的内存的指针</strong>。</p>
<p>未初始化指针的所有缺点空悬指针也都有。有一种方法可以避免空悬指针的问题:在指针即将要离开其作用域之前释放掉它所关联的内存。</p>
<h3 id="share-ptr和new结合使用"><a href="#share-ptr和new结合使用" class="headerlink" title="share_ptr和new结合使用"></a>share_ptr和new结合使用</h3><p>如果我们不初始化一个智能指针，那么这个指针就会被初始化为一个空指针。</p>
<p>接受指针参数的智能指针构造函数是explicit的（禁止隐式转换）。因此,我们不能将一个内置指针隐式转换为一个智能指针,必须使用直接初始化形式</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520130371151.jpg" alt="enter description here"></p>
<h3 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h3><p>如果使用智能指针,即使程序块过早结束,智能指针类也能确保在内存不再需要时将其释放</p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>个 unique_ptr“拥有”它所指向的对象。与 shared_ptr不同,某个时刻只能有一个 unique_ptr指向一个给定对象。当 unique_ptr被销毁时,它所指向的对象也被销毁。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520130502646.jpg" alt="enter description here"></p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr是一种不控制所指向对象生存期的智能指针,它指向由一个shared_ptr管理的对象。将一个 weak_ptr绑定到一个 shared_ptr不会改变shared_ptr的引用计数。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520130696044.jpg" alt="enter description here"></p>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>new和 delete运算符一次分配释放一个对象,但某些应用需要一次为很多对象分配内存的功能。</p>
<p>为了支持这种需求,C++语言和标准库提供了两种一次分配一个对象数组的方法。C+语言定义了另一种new表达式语法,可以分配并初始化一个对象数组。标准库中包含个名为allocator的类,允许我们们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力</p>
<h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h3><p>为了让new分配一个对象数组,我们要在类型名之后跟一对方括号,在其中指明要分配的对象的数目。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span> [get_size()]; <span class="comment">// pia指向第一个int</span></div></pre></td></tr></table></figure>
<p>虽然我们]通常称newT[]分配的内存为“动态数组”,但这种叫法某种程度上有些误导。当用new分配一个数组时,我们并未得到一个数组类型的对象,而是得到一个数组元素类型的指针。不能对动态数组调用begin和end。</p>
<blockquote>
<p>释放动态数组</p>
</blockquote>
<p>为了释放动态数组,我们使用一种特殊形式的 delete—在指针前加上一个空方括号对:</p>
<blockquote>
<p>智能指针和动态数组</p>
</blockquote>
<p>标准库提供了一个可以管理new分配的数组的 unique_ptr版本。为了用一个unique_ptr管理动态数组,我们必须在对象类型后面跟一对空方括号:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520132049585.jpg" alt="enter description here"></p>
<h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>new有一些灵活性上的局限,其中一方面表现在它将内存分配和对象构造组合在了起。类似的, delete将对象析构和内存释放组合在了一起。我们分配单个对象时,通常希望将内存分配和对象初始化组合在一起。因为在这种情况下,我们几乎肯定知道对象应有什么值。</p>
<p>标准库allocator类定义在头文件 memory中,它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法,它分配的内存是原始的、未构造的。allocator是一个模板。</p>
<blockquote>
<p>allocator 分配未构造的内存</p>
</blockquote>
<p>allocator分配的内存是未构造的( unconstructed)。我们按需要在此内存中构造对象。在新标准库中, construct成员函数接受一个指针和零个或多个额外参数,在给定位置构造一个元素。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》笔记 C++基础部分&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C/C++" scheme="https://www.liuin.cn/tags/C-C/"/>
    
  </entry>
  
</feed>
