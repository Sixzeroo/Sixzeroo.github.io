<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sixzeroo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.liuin.cn/"/>
  <updated>2018-06-12T14:52:08.000Z</updated>
  <id>https://www.liuin.cn/</id>
  
  <author>
    <name>Sixzeroo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis源码剖析——AOF持久化</title>
    <link href="https://www.liuin.cn/2018/06/10/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94AOF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://www.liuin.cn/2018/06/10/Redis源码剖析——AOF持久化/</id>
    <published>2018-06-10T00:35:53.000Z</published>
    <updated>2018-06-12T14:52:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>对RDB持久化的实现过程进行剖析</p>
<a id="more"></a>
<p>前面讲了RDB持久化的实现，其主要保存的是数据库中的键值对。除了RDB持久化功能之外, Redis还提供了AOF(Append Only File)持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同,AOF持久化是通过<strong>保存Redis服务器所执行的写命令</strong>来记录数据库状态的。</p>
<p><img src="http://data3.liuin.cn/2018-06-12-15287641912469.jpg" alt=""></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="服务器中的缓冲区"><a href="#服务器中的缓冲区" class="headerlink" title="服务器中的缓冲区"></a>服务器中的缓冲区</h3><p>在Redis中服务器状态结构体<code>redisServer</code>中有一个字段是<code>aof_buf</code>的缓冲区，当服务器执行完一条命令以后会以协议格式将被执行的写命令追加到服务器状态的<code>aof_buf</code>缓冲区的末尾:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> redisServer &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// AOF 状态（开启/关闭/可写）</span></div><div class="line">    <span class="keyword">int</span> aof_state;                  <span class="comment">/* REDIS_AOF_(ON|OFF|WAIT_REWRITE) */</span></div><div class="line">    </div><div class="line">    <span class="comment">// AOF 缓冲区</span></div><div class="line">    sds aof_buf;      <span class="comment">/* AOF buffer, written before entering the event loop */</span></div><div class="line"></div><div class="line">    <span class="comment">// AOF 文件的描述符</span></div><div class="line">    <span class="keyword">int</span> aof_fd;       <span class="comment">/* File descriptor of currently selected AOF file */</span></div><div class="line"></div><div class="line">    <span class="comment">// AOF 的当前目标数据库</span></div><div class="line">    <span class="keyword">int</span> aof_selected_db; <span class="comment">/* Currently selected DB in AOF */</span></div><div class="line">    ...</div></pre></td></tr></table></figure>
<h3 id="AOF文件的写入与同步"><a href="#AOF文件的写入与同步" class="headerlink" title="AOF文件的写入与同步"></a>AOF文件的写入与同步</h3><p>Redis的服务器进程就是一个事件循环(loop),这个循环中的文件事件负责接收客户端的命令请求,以及向客户端发送命令回复,而时间事件则负责执行像server_cron函数这样需要定时运行的函数。</p>
<p>因为服务器在处理文件事件时可能会执行写命令,使得一些内容被追加到 aof_buf缓冲区里面,所以在服务器每次结束一个事件循环之前,它都会调用<code>flushAppendOnlyFile</code>函数,考虑是否需要将 aof_buf缓冲区中的内容写人和保存到AOF文件里面</p>
<p>flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值来决定,各个不同值产生的行为</p>
<p><img src="http://data3.liuin.cn/2018-06-12-15287653307562.jpg" alt=""></p>
<p>命令写入实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedAppendOnlyFile</span><span class="params">(<span class="keyword">struct</span> redisCommand *cmd, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span> </span>&#123;</div><div class="line">    sds buf = sdsempty();</div><div class="line">    robj *tmpargv[<span class="number">3</span>];</div><div class="line"></div><div class="line">    <span class="comment">/* The DB this command was targeting is not the same as the last command</span></div><div class="line">     * we appendend. To issue a SELECT command is needed. </div><div class="line">     *</div><div class="line">     * 使用 SELECT 命令，显式设置数据库，确保之后的命令被设置到正确的数据库</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (dictid != server.aof_selected_db) &#123;</div><div class="line">        <span class="keyword">char</span> seldb[<span class="number">64</span>];</div><div class="line"></div><div class="line">        <span class="built_in">snprintf</span>(seldb,<span class="keyword">sizeof</span>(seldb),<span class="string">"%d"</span>,dictid);</div><div class="line">        buf = sdscatprintf(buf,<span class="string">"*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n"</span>,</div><div class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="built_in">strlen</span>(seldb),seldb);</div><div class="line"></div><div class="line">        server.aof_selected_db = dictid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="comment">// 省略其他命令的加入buff过程</span></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">/* Append to the AOF buffer. This will be flushed on disk just before</span></div><div class="line">     * of re-entering the event loop, so before the client will get a</div><div class="line">     * positive reply about the operation performed. </div><div class="line">     *</div><div class="line">     * 将命令追加到 AOF 缓存中，</div><div class="line">     * 在重新进入事件循环之前，这些命令会被冲洗到磁盘上，</div><div class="line">     * 并向客户端返回一个回复。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (server.aof_state == REDIS_AOF_ON)</div><div class="line">        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));</div><div class="line"></div><div class="line">    <span class="comment">/* If a background append only file rewriting is in progress we want to</span></div><div class="line">     * accumulate the differences between the child DB and the current one</div><div class="line">     * in a buffer, so that when the child process will do its work we</div><div class="line">     * can append the differences to the new append only file. </div><div class="line">     *</div><div class="line">     * 如果 BGREWRITEAOF 正在进行，</div><div class="line">     * 那么我们还需要将命令追加到重写缓存中，</div><div class="line">     * 从而记录当前正在重写的 AOF 文件和数据库当前状态的差异。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>)</div><div class="line">        aofRewriteBufferAppend((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf,sdslen(buf));</div><div class="line"></div><div class="line">    <span class="comment">// 释放</span></div><div class="line">    sdsfree(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>缓冲区人间写入AOF实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushAppendOnlyFile</span><span class="params">(<span class="keyword">int</span> force)</span> </span>&#123;</div><div class="line">    <span class="keyword">ssize_t</span> nwritten;</div><div class="line">    <span class="keyword">int</span> sync_in_progress = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 缓冲区中没有任何内容，直接返回</span></div><div class="line">    <span class="keyword">if</span> (sdslen(server.aof_buf) == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 策略为每秒 FSYNC </span></div><div class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC)</div><div class="line">        <span class="comment">// 是否有 SYNC 正在后台进行？</span></div><div class="line">        sync_in_progress = bioPendingJobsOfType(REDIS_BIO_AOF_FSYNC) != <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 每秒 fsync ，并且强制写入为假</span></div><div class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp; !force) &#123;</div><div class="line"></div><div class="line">        <span class="comment">/* With this append fsync policy we do background fsyncing.</span></div><div class="line">         *</div><div class="line">         * 当 fsync 策略为每秒钟一次时， fsync 在后台执行。</div><div class="line">         *</div><div class="line">         * If the fsync is still in progress we can try to delay</div><div class="line">         * the write for a couple of seconds. </div><div class="line">         *</div><div class="line">         * 如果后台仍在执行 FSYNC ，那么我们可以延迟写操作一两秒</div><div class="line">         * （如果强制执行 write 的话，服务器主线程将阻塞在 write 上面）</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (sync_in_progress) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 有 fsync 正在后台进行 。。。</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (server.aof_flush_postponed_start == <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">/* No previous write postponinig, remember that we are</span></div><div class="line">                 * postponing the flush and return. </div><div class="line">                 *</div><div class="line">                 * 前面没有推迟过 write 操作，这里将推迟写操作的时间记录下来</div><div class="line">                 * 然后就返回，不执行 write 或者 fsync</div><div class="line">                 */</div><div class="line">                server.aof_flush_postponed_start = server.unixtime;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.unixtime - server.aof_flush_postponed_start &lt; <span class="number">2</span>) &#123;</div><div class="line">                <span class="comment">/* We were already waiting for fsync to finish, but for less</span></div><div class="line">                 * than two seconds this is still ok. Postpone again. </div><div class="line">                 *</div><div class="line">                 * 如果之前已经因为 fsync 而推迟了 write 操作</div><div class="line">                 * 但是推迟的时间不超过 2 秒，那么直接返回</div><div class="line">                 * 不执行 write 或者 fsync</div><div class="line">                 */</div><div class="line">                <span class="keyword">return</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">/* Otherwise fall trough, and go write since we can't wait</span></div><div class="line">             * over two seconds. </div><div class="line">             *</div><div class="line">             * 如果后台还有 fsync 在执行，并且 write 已经推迟 &gt;= 2 秒</div><div class="line">             * 那么执行写操作（write 将被阻塞）</div><div class="line">             */</div><div class="line">            server.aof_delayed_fsync++;</div><div class="line">            redisLog(REDIS_NOTICE,<span class="string">"Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* If you are following this code path, then we are going to write so</span></div><div class="line">     * set reset the postponed flush sentinel to zero. </div><div class="line">     *</div><div class="line">     * 执行到这里，程序会对 AOF 文件进行写入。</div><div class="line">     *</div><div class="line">     * 清零延迟 write 的时间记录</div><div class="line">     */</div><div class="line">    server.aof_flush_postponed_start = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* We want to perform a single write. This should be guaranteed atomic</span></div><div class="line">     * at least if the filesystem we are writing is a real physical one.</div><div class="line">     *</div><div class="line">     * 执行单个 write 操作，如果写入设备是物理的话，那么这个操作应该是原子的</div><div class="line">     *</div><div class="line">     * While this will save us against the server being killed I don't think</div><div class="line">     * there is much to do about the whole server stopping for power problems</div><div class="line">     * or alike </div><div class="line">     *</div><div class="line">     * 当然，如果出现像电源中断这样的不可抗现象，那么 AOF 文件也是可能会出现问题的</div><div class="line">     * 这时就要用 redis-check-aof 程序来进行修复。</div><div class="line">     */</div><div class="line">    nwritten = write(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));</div><div class="line">    <span class="keyword">if</span> (nwritten != (<span class="keyword">signed</span>)sdslen(server.aof_buf)) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">static</span> <span class="keyword">time_t</span> last_write_error_log = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> can_log = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* Limit logging rate to 1 line per AOF_WRITE_LOG_ERROR_RATE seconds. */</span></div><div class="line">        <span class="comment">// 将日志的记录频率限制在每行 AOF_WRITE_LOG_ERROR_RATE 秒</span></div><div class="line">        <span class="keyword">if</span> ((server.unixtime - last_write_error_log) &gt; AOF_WRITE_LOG_ERROR_RATE) &#123;</div><div class="line">            can_log = <span class="number">1</span>;</div><div class="line">            last_write_error_log = server.unixtime;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Lof the AOF write error and record the error code. */</span></div><div class="line">        <span class="comment">// 如果写入出错，那么尝试将该情况写入到日志里面</span></div><div class="line">        <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (can_log) &#123;</div><div class="line">                redisLog(REDIS_WARNING,<span class="string">"Error writing to the AOF file: %s"</span>,</div><div class="line">                    strerror(errno));</div><div class="line">                server.aof_last_write_errno = errno;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (can_log) &#123;</div><div class="line">                redisLog(REDIS_WARNING,<span class="string">"Short write while writing to "</span></div><div class="line">                                       <span class="string">"the AOF file: (nwritten=%lld, "</span></div><div class="line">                                       <span class="string">"expected=%lld)"</span>,</div><div class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)nwritten,</div><div class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)sdslen(server.aof_buf));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 尝试移除新追加的不完整内容</span></div><div class="line">            <span class="keyword">if</span> (ftruncate(server.aof_fd, server.aof_current_size) == <span class="number">-1</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (can_log) &#123;</div><div class="line">                    redisLog(REDIS_WARNING, <span class="string">"Could not remove short write "</span></div><div class="line">                             <span class="string">"from the append-only file.  Redis may refuse "</span></div><div class="line">                             <span class="string">"to load the AOF the next time it starts.  "</span></div><div class="line">                             <span class="string">"ftruncate: %s"</span>, strerror(errno));</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">/* If the ftrunacate() succeeded we can set nwritten to</span></div><div class="line">                 * -1 since there is no longer partial data into the AOF. */</div><div class="line">                nwritten = <span class="number">-1</span>;</div><div class="line">            &#125;</div><div class="line">            server.aof_last_write_errno = ENOSPC;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Handle the AOF write error. */</span></div><div class="line">        <span class="comment">// 处理写入 AOF 文件时出现的错误</span></div><div class="line">        <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</div><div class="line">            <span class="comment">/* We can't recover when the fsync policy is ALWAYS since the</span></div><div class="line">             * reply for the client is already in the output buffers, and we</div><div class="line">             * have the contract with the user that on acknowledged write data</div><div class="line">             * is synched on disk. */</div><div class="line">            redisLog(REDIS_WARNING,<span class="string">"Can't recover from AOF write error when the AOF fsync policy is 'always'. Exiting..."</span>);</div><div class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/* Recover from failed write leaving data into the buffer. However</span></div><div class="line">             * set an error to stop accepting writes as long as the error</div><div class="line">             * condition is not cleared. */</div><div class="line">            server.aof_last_write_status = REDIS_ERR;</div><div class="line"></div><div class="line">            <span class="comment">/* Trim the sds buffer if there was a partial write, and there</span></div><div class="line">             * was no way to undo it with ftruncate(2). */</div><div class="line">            <span class="keyword">if</span> (nwritten &gt; <span class="number">0</span>) &#123;</div><div class="line">                server.aof_current_size += nwritten;</div><div class="line">                sdsrange(server.aof_buf,nwritten,<span class="number">-1</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>; <span class="comment">/* We'll try again on the next call... */</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* Successful write(2). If AOF was in error state, restore the</span></div><div class="line">         * OK state and log the event. */</div><div class="line">        <span class="comment">// 写入成功，更新最后写入状态</span></div><div class="line">        <span class="keyword">if</span> (server.aof_last_write_status == REDIS_ERR) &#123;</div><div class="line">            redisLog(REDIS_WARNING,</div><div class="line">                <span class="string">"AOF write error looks solved, Redis can write again."</span>);</div><div class="line">            server.aof_last_write_status = REDIS_OK;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 更新写入后的 AOF 文件大小</span></div><div class="line">    server.aof_current_size += nwritten;</div><div class="line"></div><div class="line">    <span class="comment">/* Re-use AOF buffer when it is small enough. The maximum comes from the</span></div><div class="line">     * arena size of 4k minus some overhead (but is otherwise arbitrary). </div><div class="line">     *</div><div class="line">     * 如果 AOF 缓存的大小足够小的话，那么重用这个缓存，</div><div class="line">     * 否则的话，释放 AOF 缓存。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) &lt; <span class="number">4000</span>) &#123;</div><div class="line">        <span class="comment">// 清空缓存中的内容，等待重用</span></div><div class="line">        sdsclear(server.aof_buf);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 释放缓存</span></div><div class="line">        sdsfree(server.aof_buf);</div><div class="line">        server.aof_buf = sdsempty();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Don't fsync if no-appendfsync-on-rewrite is set to yes and there are</span></div><div class="line">     * children doing I/O in the background. </div><div class="line">     *</div><div class="line">     * 如果 no-appendfsync-on-rewrite 选项为开启状态，</div><div class="line">     * 并且有 BGSAVE 或者 BGREWRITEAOF 正在进行的话，</div><div class="line">     * 那么不执行 fsync </div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (server.aof_no_fsync_on_rewrite &amp;&amp;</div><div class="line">        (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Perform the fsync if needed. */</span></div><div class="line"></div><div class="line">    <span class="comment">// 总是执行 fsnyc</span></div><div class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</div><div class="line">        <span class="comment">/* aof_fsync is defined as fdatasync() for Linux in order to avoid</span></div><div class="line">         * flushing metadata. */</div><div class="line">        aof_fsync(server.aof_fd); <span class="comment">/* Let's try to get this data on the disk */</span></div><div class="line"></div><div class="line">        <span class="comment">// 更新最后一次执行 fsnyc 的时间</span></div><div class="line">        server.aof_last_fsync = server.unixtime;</div><div class="line"></div><div class="line">    <span class="comment">// 策略为每秒 fsnyc ，并且距离上次 fsync 已经超过 1 秒</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</div><div class="line">                server.unixtime &gt; server.aof_last_fsync)) &#123;</div><div class="line">        <span class="comment">// 放到后台执行</span></div><div class="line">        <span class="keyword">if</span> (!sync_in_progress) aof_background_fsync(server.aof_fd);</div><div class="line">        <span class="comment">// 更新最后一次执行 fsync 的时间</span></div><div class="line">        server.aof_last_fsync = server.unixtime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 其实上面无论执行 if 部分还是 else 部分都要更新 fsync 的时间</span></div><div class="line">    <span class="comment">// 可以将代码挪到下面来</span></div><div class="line">    <span class="comment">// server.aof_last_fsync = server.unixtime;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于三种不同的策略其效率和安全性能是不一样的：</p>
<ul>
<li><code>always</code>因为在每一个事件循环中都需要将所有的内容写入AOF文件，所以其效率是最低的，但是其安全性是最高的</li>
<li><code>everysec</code>是一个效率和安全性的折中。从效率上来讲, everysec模式足够快,并且就算出现故障停机,数据库也只丢失一秒钟的命令数据。</li>
<li><code>no</code>的同步时间需要有操作系统控制，这样其效率比较高但是安全性就比较差了</li>
</ul>
<h2 id="文件载入和数据的还原"><a href="#文件载入和数据的还原" class="headerlink" title="文件载入和数据的还原"></a>文件载入和数据的还原</h2><p>因为AOF文件里面包含了重建数据库状态所需的所有写命令,所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令,就可以还原服务器关闭之前的数据库状态。</p>
<p><img src="http://data3.liuin.cn/2018-06-12-15287660987749.jpg" alt=""></p>
<p>其底层主要通过<code>loadAppendOnlyFile</code>这个函数实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 执行 AOF 文件中的命令。</div><div class="line"> *</div><div class="line"> * 出错时返回 REDIS_OK 。</div><div class="line"> *</div><div class="line"> * 出现非执行错误（比如文件长度为 0 ）时返回 REDIS_ERR 。</div><div class="line"> *</div><div class="line"> * 出现致命错误时打印信息到日志，并且程序退出。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 为客户端</span></div><div class="line">    <span class="keyword">struct</span> redisClient *fakeClient;</div><div class="line"></div><div class="line">    <span class="comment">// 打开 AOF 文件</span></div><div class="line">    FILE *fp = fopen(filename,<span class="string">"r"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> redis_stat sb;</div><div class="line">    <span class="keyword">int</span> old_aof_state = server.aof_state;</div><div class="line">    <span class="keyword">long</span> loops = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 检查文件的正确性</span></div><div class="line">    <span class="keyword">if</span> (fp &amp;&amp; redis_fstat(fileno(fp),&amp;sb) != <span class="number">-1</span> &amp;&amp; sb.st_size == <span class="number">0</span>) &#123;</div><div class="line">        server.aof_current_size = <span class="number">0</span>;</div><div class="line">        fclose(fp);</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 检查文件是否正常打开</span></div><div class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Fatal error: can't open the append log file for reading: %s"</span>,strerror(errno));</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 暂时性地关闭 AOF ，防止在执行 MULTI 时，</div><div class="line">     * EXEC 命令被传播到正在打开的 AOF 文件中。</div><div class="line">     */</div><div class="line">    server.aof_state = REDIS_AOF_OFF;</div><div class="line"></div><div class="line">    fakeClient = createFakeClient();</div><div class="line"></div><div class="line">    <span class="comment">// 设置服务器的状态为：正在载入</span></div><div class="line">    <span class="comment">// startLoading 定义于 rdb.c</span></div><div class="line">    startLoading(fp);</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="comment">// 省略载入过程</span></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 如果能执行到这里，说明 AOF 文件的全部内容都可以正确地读取，</div><div class="line">     * 但是，还要检查 AOF 是否包含未正确结束的事务</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (fakeClient-&gt;flags &amp; REDIS_MULTI) <span class="keyword">goto</span> readerr;</div><div class="line"></div><div class="line">    <span class="comment">// 关闭 AOF 文件</span></div><div class="line">    fclose(fp);</div><div class="line">    <span class="comment">// 释放伪客户端</span></div><div class="line">    freeFakeClient(fakeClient);</div><div class="line">    <span class="comment">// 复原 AOF 状态</span></div><div class="line">    server.aof_state = old_aof_state;</div><div class="line">    <span class="comment">// 停止载入</span></div><div class="line">    stopLoading();</div><div class="line">    <span class="comment">// 更新服务器状态中， AOF 文件的当前大小</span></div><div class="line">    aofUpdateCurrentSize();</div><div class="line">    <span class="comment">// 记录前一次重写时的大小</span></div><div class="line">    server.aof_rewrite_base_size = server.aof_current_size;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div></pre></td></tr></table></figure>
<h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>因为AOF持久化是通过保存被执行的写命令来记录数据库状态的,所以随着服务器运行时间的流逝,AOF文件中的内容会越来越多,文件的体积也会越来越大,如果不加以控制的话,体积过大的AOF文件很可能对 Redis服务器、甚至整个宿主计算机造成影响,并且AOF文件的体积越大,便用AOF文件来进行数据还原所需的时间就越多。</p>
<p>为了解决AOF文件体积膨胀的问题, Redis提供了AOF文件重写( rewrite)功能。通过该功能, Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件,新旧两个AOF文件所保存的数据库状态相同,但新AOF文件不会包含任何浪费空间的冗余命令,所以新AOF文件的体积通常会比旧AOF文件的体积要小得多。</p>
<h3 id="AOF重写实现"><a href="#AOF重写实现" class="headerlink" title="AOF重写实现"></a>AOF重写实现</h3><p>AOF重写部分的主要实现（遍历所有的键，通过命令进行插入）如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">        </div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="comment">/* Iterate this DB writing every entry </span></div><div class="line">         *</div><div class="line">         * 遍历数据库所有键，并通过命令将它们的当前状态（值）记录到新 AOF 文件中</div><div class="line">         */</div><div class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</div><div class="line">            sds keystr;</div><div class="line">            robj key, *o;</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> expiretime;</div><div class="line"></div><div class="line">            <span class="comment">// 取出键</span></div><div class="line">            keystr = dictGetKey(de);</div><div class="line"></div><div class="line">            <span class="comment">// 取出值</span></div><div class="line">            o = dictGetVal(de);</div><div class="line">            initStaticStringObject(key,keystr);</div><div class="line"></div><div class="line">            <span class="comment">// 取出过期时间</span></div><div class="line">            expiretime = getExpire(db,&amp;key);</div><div class="line"></div><div class="line">            <span class="comment">/* If this key is already expired skip it </span></div><div class="line">             *</div><div class="line">             * 如果键已经过期，那么跳过它，不保存</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (expiretime != <span class="number">-1</span> &amp;&amp; expiretime &lt; now) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">            <span class="comment">/* Save the key and associated value </span></div><div class="line">             *</div><div class="line">             * 根据值的类型，选择适当的命令来保存值</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (o-&gt;type == REDIS_STRING) &#123;</div><div class="line">                <span class="comment">/* Emit a SET command */</span></div><div class="line">                <span class="keyword">char</span> cmd[]=<span class="string">"*3\r\n$3\r\nSET\r\n"</span>;</div><div class="line">                <span class="keyword">if</span> (rioWrite(&amp;aof,cmd,<span class="keyword">sizeof</span>(cmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">                <span class="comment">/* Key and value */</span></div><div class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,&amp;key) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_LIST) &#123;</div><div class="line">                <span class="keyword">if</span> (rewriteListObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_SET) &#123;</div><div class="line">                <span class="keyword">if</span> (rewriteSetObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_ZSET) &#123;</div><div class="line">                <span class="keyword">if</span> (rewriteSortedSetObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_HASH) &#123;</div><div class="line">                <span class="keyword">if</span> (rewriteHashObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                redisPanic(<span class="string">"Unknown object type"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">/* Save the expire time </span></div><div class="line">             *</div><div class="line">             * 保存键的过期时间</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) &#123;</div><div class="line">                <span class="keyword">char</span> cmd[]=<span class="string">"*3\r\n$9\r\nPEXPIREAT\r\n"</span>;</div><div class="line"></div><div class="line">                <span class="comment">// 写入 PEXPIREAT expiretime 命令</span></div><div class="line">                <span class="keyword">if</span> (rioWrite(&amp;aof,cmd,<span class="keyword">sizeof</span>(cmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,&amp;key) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">                <span class="keyword">if</span> (rioWriteBulkLongLong(&amp;aof,expiretime) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div></pre></td></tr></table></figure>
<p>因为新的AOF文件只包含还原当前数据库所必须的命令，所以新AOF文件不会浪费任何空间。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对RDB持久化的实现过程进行剖析&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="https://www.liuin.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析——RDB持久化</title>
    <link href="https://www.liuin.cn/2018/06/05/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94RDB%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://www.liuin.cn/2018/06/05/Redis源码剖析——RDB持久化/</id>
    <published>2018-06-05T02:30:43.000Z</published>
    <updated>2018-06-08T03:10:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>对RDB实现持久化的过程进行剖析</p>
<a id="more"></a>
<h2 id="持久化概述"><a href="#持久化概述" class="headerlink" title="持久化概述"></a>持久化概述</h2><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>因为Redis数据库是基于内存的Key-Value型数据库，他的所有数据库状态都存储在内存里面，如果服务器进程退出，那么存放在内存中的所有Redis数据库的状态都将消失。为了避免这种情况发生，就需要一种将数据库状态从内存转移到磁盘中的技术。</p>
<p>持久化就是这样一种将数据库的状态从内存存储到磁盘中的技术，Redis提供两种持久化：RDB持久化和AOF持久化。</p>
<h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>Redis提供了RDB持久化功能,这个功能可以将 Redis在内存中的数据库状态保存到磁盘里面,避免数据意外丢失。RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件,通过该文件可以还原生成RDB文件时的数据库状态。</p>
<p><img src="http://data3.liuin.cn/2018-06-08-15284258851033.jpg" alt=""></p>
<h2 id="RDB命令"><a href="#RDB命令" class="headerlink" title="RDB命令"></a>RDB命令</h2><p>Redis中生成RDB文件有两个命令：SAVE和BGSAVE。</p>
<p>SAVE命令会阻塞Redis服务器进程,直到RDB文件创建完毕为止,在服务器进程阻塞期间,服务器不能处理任何命令请求；BGSAVE命令会派生出一个子进程,然后由子进程负责创建RDB文件,服务器进程(父进程)继续处理命令请求</p>
<p>由此可见BGSAVE的实现是在SAVE的基础上进行的。</p>
<p>RDB文件的载入工作是在服务器启动时自动执行的,所以Redis并没有专门用于载入RDB文件的命令,只要 Redis服务器在启动时检测到RDB文件存在,它就会自动载入RDB文件。</p>
<h3 id="生成RDB文件实现"><a href="#生成RDB文件实现" class="headerlink" title="生成RDB文件实现"></a>生成RDB文件实现</h3><p>在讲生成RDB文件前首先要讲一个Redis中对I/O进行封装的一个结构体：<code>rio</code>，这个结构体在基本I/O的基础上加了一些计算校验和，获取文件指针所在偏移量等功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> _rio &#123;</div><div class="line"></div><div class="line">    <span class="comment">/* Backend functions.</span></div><div class="line">     * Since this functions do not tolerate short writes or reads the return</div><div class="line">     * value is simplified to: zero on error, non zero on complete success. */</div><div class="line">    <span class="comment">// API</span></div><div class="line">    <span class="keyword">size_t</span> (*read)(<span class="keyword">struct</span> _rio *, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len);</div><div class="line">    <span class="keyword">size_t</span> (*write)(<span class="keyword">struct</span> _rio *, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len);</div><div class="line">    <span class="keyword">off_t</span> (*tell)(<span class="keyword">struct</span> _rio *);</div><div class="line"></div><div class="line">    <span class="comment">/* The update_cksum method if not NULL is used to compute the checksum of</span></div><div class="line">     * all the data that was read or written so far. The method should be</div><div class="line">     * designed so that can be called with the current checksum, and the buf</div><div class="line">     * and len fields pointing to the new block of data to add to the checksum</div><div class="line">     * computation. */</div><div class="line">    <span class="comment">// 校验和计算函数，每次有写入/读取新数据时都要计算一次</span></div><div class="line">    <span class="keyword">void</span> (*update_cksum)(<span class="keyword">struct</span> _rio *, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len);</div><div class="line"></div><div class="line">    <span class="comment">/* The current checksum */</span></div><div class="line">    <span class="comment">// 当前校验和</span></div><div class="line">    <span class="keyword">uint64_t</span> cksum;</div><div class="line"></div><div class="line">    <span class="comment">/* number of bytes read or written */</span></div><div class="line">    <span class="keyword">size_t</span> processed_bytes;</div><div class="line"></div><div class="line">    <span class="comment">/* maximum single read or write chunk size */</span></div><div class="line">    <span class="keyword">size_t</span> max_processing_chunk;</div><div class="line"></div><div class="line">    <span class="comment">/* Backend-specific vars. */</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">struct</span> &#123;</div><div class="line">            <span class="comment">// 缓存指针</span></div><div class="line">            sds ptr;</div><div class="line">            <span class="comment">// 偏移量</span></div><div class="line">            <span class="keyword">off_t</span> pos;</div><div class="line">        &#125; buffer;</div><div class="line"></div><div class="line">        <span class="keyword">struct</span> &#123;</div><div class="line">            <span class="comment">// 被打开文件的指针</span></div><div class="line">            FILE *fp;</div><div class="line">            <span class="comment">// 最近一次 fsync() 以来，写入的字节量</span></div><div class="line">            <span class="keyword">off_t</span> buffered; <span class="comment">/* Bytes written since last fsync. */</span></div><div class="line">            <span class="comment">// 写入多少字节之后，才会自动执行一次 fsync()</span></div><div class="line">            <span class="keyword">off_t</span> autosync; <span class="comment">/* fsync after 'autosync' bytes written. */</span></div><div class="line">        &#125; file;</div><div class="line">    &#125; io;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>SAVE的实现就是依靠<code>rio</code>的，其所有的I/O都是通过<code>rio</code>进行的。SAVE实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSave</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">    dictIterator *di = <span class="literal">NULL</span>;</div><div class="line">    dictEntry *de;</div><div class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</div><div class="line">    <span class="keyword">char</span> magic[<span class="number">10</span>];</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> now = mstime();</div><div class="line">    FILE *fp;</div><div class="line">    rio rdb;</div><div class="line">    <span class="keyword">uint64_t</span> cksum;</div><div class="line"></div><div class="line">    <span class="comment">// 创建临时文件</span></div><div class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">"temp-%d.rdb"</span>, (<span class="keyword">int</span>) getpid());</div><div class="line">    fp = fopen(tmpfile,<span class="string">"w"</span>);</div><div class="line">    <span class="keyword">if</span> (!fp) &#123;</div><div class="line">        redisLog(REDIS_WARNING, <span class="string">"Failed opening .rdb for saving: %s"</span>,</div><div class="line">            strerror(errno));</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化 I/O</span></div><div class="line">    rioInitWithFile(&amp;rdb,fp);</div><div class="line"></div><div class="line">    <span class="comment">// 设置校验和函数</span></div><div class="line">    <span class="keyword">if</span> (server.rdb_checksum)</div><div class="line">        rdb.update_cksum = rioGenericUpdateChecksum;</div><div class="line"></div><div class="line">    <span class="comment">// 写入 RDB 版本号</span></div><div class="line">    <span class="built_in">snprintf</span>(magic,<span class="keyword">sizeof</span>(magic),<span class="string">"REDIS%04d"</span>,REDIS_RDB_VERSION);</div><div class="line">    <span class="keyword">if</span> (rdbWriteRaw(&amp;rdb,magic,<span class="number">9</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历所有数据库</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 指向数据库</span></div><div class="line">        redisDb *db = server.db+j;</div><div class="line"></div><div class="line">        <span class="comment">// 指向数据库键空间</span></div><div class="line">        dict *d = db-&gt;dict;</div><div class="line"></div><div class="line">        <span class="comment">// 跳过空数据库</span></div><div class="line">        <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 创建键空间迭代器</span></div><div class="line">        di = dictGetSafeIterator(d);</div><div class="line">        <span class="keyword">if</span> (!di) &#123;</div><div class="line">            fclose(fp);</div><div class="line">            <span class="keyword">return</span> REDIS_ERR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Write the SELECT DB opcode </span></div><div class="line">         *</div><div class="line">         * 写入 DB 选择器</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (rdbSaveType(&amp;rdb,REDIS_RDB_OPCODE_SELECTDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line">        <span class="keyword">if</span> (rdbSaveLen(&amp;rdb,j) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">        <span class="comment">/* Iterate this DB writing every entry </span></div><div class="line">         *</div><div class="line">         * 遍历数据库，并写入每个键值对的数据</div><div class="line">         */</div><div class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</div><div class="line">            sds keystr = dictGetKey(de);</div><div class="line">            robj key, *o = dictGetVal(de);</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> expire;</div><div class="line">            </div><div class="line">            <span class="comment">// 根据 keystr ，在栈中创建一个 key 对象</span></div><div class="line">            initStaticStringObject(key,keystr);</div><div class="line"></div><div class="line">            <span class="comment">// 获取键的过期时间</span></div><div class="line">            expire = getExpire(db,&amp;key);</div><div class="line"></div><div class="line">            <span class="comment">// 保存键值对数据</span></div><div class="line">            <span class="keyword">if</span> (rdbSaveKeyValuePair(&amp;rdb,&amp;key,o,expire,now) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line">        &#125;</div><div class="line">        dictReleaseIterator(di);</div><div class="line">    &#125;</div><div class="line">    di = <span class="literal">NULL</span>; <span class="comment">/* So that we don't release it again on error. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* EOF opcode </span></div><div class="line">     *</div><div class="line">     * 写入 EOF 代码</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (rdbSaveType(&amp;rdb,REDIS_RDB_OPCODE_EOF) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">/* CRC64 checksum. It will be zero if checksum computation is disabled, the</span></div><div class="line">     * loading code skips the check in this case. </div><div class="line">     *</div><div class="line">     * CRC64 校验和。</div><div class="line">     *</div><div class="line">     * 如果校验和功能已关闭，那么 rdb.cksum 将为 0 ，</div><div class="line">     * 在这种情况下， RDB 载入时会跳过校验和检查。</div><div class="line">     */</div><div class="line">    cksum = rdb.cksum;</div><div class="line">    memrev64ifbe(&amp;cksum);</div><div class="line">    rioWrite(&amp;rdb,&amp;cksum,<span class="number">8</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* Make sure data will not remain on the OS's output buffers */</span></div><div class="line">    <span class="comment">// 冲洗缓存，确保数据已写入磁盘</span></div><div class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</div><div class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</div><div class="line">    <span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;</div><div class="line"></div><div class="line">    <span class="comment">/* Use RENAME to make sure the DB file is changed atomically only</span></div><div class="line">     * if the generate DB file is ok. </div><div class="line">     *</div><div class="line">     * 使用 RENAME ，原子性地对临时文件进行改名，覆盖原来的 RDB 文件。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Error moving temp DB file on the final destination: %s"</span>, strerror(errno));</div><div class="line">        unlink(tmpfile);</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 写入完成，打印日志</span></div><div class="line">    redisLog(REDIS_NOTICE,<span class="string">"DB saved on disk"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 清零数据库脏状态</span></div><div class="line">    server.dirty = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 记录最后一次完成 SAVE 的时间</span></div><div class="line">    server.lastsave = time(<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 记录最后一次执行 SAVE 的状态</span></div><div class="line">    server.lastbgsave_status = REDIS_OK;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line"></div><div class="line">werr:</div><div class="line">    <span class="comment">// 关闭文件</span></div><div class="line">    fclose(fp);</div><div class="line">    <span class="comment">// 删除文件</span></div><div class="line">    unlink(tmpfile);</div><div class="line"></div><div class="line">    redisLog(REDIS_WARNING,<span class="string">"Write error saving DB on disk: %s"</span>, strerror(errno));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (di) dictReleaseIterator(di);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> REDIS_ERR;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码逻辑上看，SAVE的实现还是比较简单的，首先写入一些Redis版本信息，然后将数据库中的所有数据写入文件，最后加上一个校验和。</p>
<p>BESAVE在SAVE的基础上还要实现一些新进程创建等任务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveBackground</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">    <span class="keyword">pid_t</span> childpid;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start;</div><div class="line"></div><div class="line">    <span class="comment">// 如果 BGSAVE 已经在执行，那么出错</span></div><div class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">    <span class="comment">// 记录 BGSAVE 执行前的数据库被修改次数</span></div><div class="line">    server.dirty_before_bgsave = server.dirty;</div><div class="line"></div><div class="line">    <span class="comment">// 最近一次尝试执行 BGSAVE 的时间</span></div><div class="line">    server.lastbgsave_try = time(<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">// fork() 开始前的时间，记录 fork() 返回耗时用</span></div><div class="line">    start = ustime();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> retval;</div><div class="line"></div><div class="line">        <span class="comment">/* Child */</span></div><div class="line"></div><div class="line">        <span class="comment">// 关闭网络连接 fd</span></div><div class="line">        closeListeningSockets(<span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 设置进程的标题，方便识别</span></div><div class="line">        redisSetProcTitle(<span class="string">"redis-rdb-bgsave"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 执行保存操作</span></div><div class="line">        retval = rdbSave(filename);</div><div class="line"></div><div class="line">        <span class="comment">// 打印 copy-on-write 时使用的内存数</span></div><div class="line">        <span class="keyword">if</span> (retval == REDIS_OK) &#123;</div><div class="line">            <span class="keyword">size_t</span> private_dirty = zmalloc_get_private_dirty();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (private_dirty) &#123;</div><div class="line">                redisLog(REDIS_NOTICE,</div><div class="line">                    <span class="string">"RDB: %zu MB of memory used by copy-on-write"</span>,</div><div class="line">                    private_dirty/(<span class="number">1024</span>*<span class="number">1024</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 向父进程发送信号</span></div><div class="line">        exitFromChild((retval == REDIS_OK) ? <span class="number">0</span> : <span class="number">1</span>);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="comment">/* Parent */</span></div><div class="line"></div><div class="line">        <span class="comment">// 计算 fork() 执行的时间</span></div><div class="line">        server.stat_fork_time = ustime()-start;</div><div class="line"></div><div class="line">        <span class="comment">// 如果 fork() 出错，那么报告错误</span></div><div class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</div><div class="line">            server.lastbgsave_status = REDIS_ERR;</div><div class="line">            redisLog(REDIS_WARNING,<span class="string">"Can't save in background: fork: %s"</span>,</div><div class="line">                strerror(errno));</div><div class="line">            <span class="keyword">return</span> REDIS_ERR;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 打印 BGSAVE 开始的日志</span></div><div class="line">        redisLog(REDIS_NOTICE,<span class="string">"Background saving started by pid %d"</span>,childpid);</div><div class="line"></div><div class="line">        <span class="comment">// 记录数据库开始 BGSAVE 的时间</span></div><div class="line">        server.rdb_save_time_start = time(<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 记录负责执行 BGSAVE 的子进程 ID</span></div><div class="line">        server.rdb_child_pid = childpid;</div><div class="line"></div><div class="line">        <span class="comment">// 关闭自动 rehash</span></div><div class="line">        updateDictResizePolicy();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> REDIS_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> REDIS_OK; <span class="comment">/* unreached */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RDB文件载入实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoad</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</div><div class="line">    <span class="keyword">uint32_t</span> dbid;</div><div class="line">    <span class="keyword">int</span> type, rdbver;</div><div class="line">    redisDb *db = server.db+<span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> expiretime, now = mstime();</div><div class="line">    FILE *fp;</div><div class="line">    rio rdb;</div><div class="line"></div><div class="line">    <span class="comment">// 打开 rdb 文件</span></div><div class="line">    <span class="keyword">if</span> ((fp = fopen(filename,<span class="string">"r"</span>)) == <span class="literal">NULL</span>) <span class="keyword">return</span> REDIS_ERR;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化写入流</span></div><div class="line">    rioInitWithFile(&amp;rdb,fp);</div><div class="line">    rdb.update_cksum = rdbLoadProgressCallback;</div><div class="line">    rdb.max_processing_chunk = server.loading_process_events_interval_bytes;</div><div class="line">    <span class="keyword">if</span> (rioRead(&amp;rdb,buf,<span class="number">9</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">    buf[<span class="number">9</span>] = <span class="string">'\0'</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 检查版本号</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(buf,<span class="string">"REDIS"</span>,<span class="number">5</span>) != <span class="number">0</span>) &#123;</div><div class="line">        fclose(fp);</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Wrong signature trying to load DB from file"</span>);</div><div class="line">        errno = EINVAL;</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line">    rdbver = atoi(buf+<span class="number">5</span>);</div><div class="line">    <span class="keyword">if</span> (rdbver &lt; <span class="number">1</span> || rdbver &gt; REDIS_RDB_VERSION) &#123;</div><div class="line">        fclose(fp);</div><div class="line">        redisLog(REDIS_WARNING,<span class="string">"Can't handle RDB format version %d"</span>,rdbver);</div><div class="line">        errno = EINVAL;</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将服务器状态调整到开始载入状态</span></div><div class="line">    startLoading(fp);</div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">        robj *key, *val;</div><div class="line">        expiretime = <span class="number">-1</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* Read type. </span></div><div class="line">         *</div><div class="line">         * 读入类型指示，决定该如何读入之后跟着的数据。</div><div class="line">         *</div><div class="line">         * 这个指示可以是 rdb.h 中定义的所有以</div><div class="line">         * REDIS_RDB_TYPE_* 为前缀的常量的其中一个</div><div class="line">         * 或者所有以 REDIS_RDB_OPCODE_* 为前缀的常量的其中一个</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> ((type = rdbLoadType(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">        <span class="comment">// 读入过期时间值</span></div><div class="line">        <span class="keyword">if</span> (type == REDIS_RDB_OPCODE_EXPIRETIME) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 以秒计算的过期时间</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> ((expiretime = rdbLoadTime(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">            <span class="comment">/* We read the time so we need to read the object type again. </span></div><div class="line">             *</div><div class="line">             * 在过期时间之后会跟着一个键值对，我们要读入这个键值对的类型</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> ((type = rdbLoadType(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">            <span class="comment">/* the EXPIRETIME opcode specifies time in seconds, so convert</span></div><div class="line">             * into milliseconds. </div><div class="line">             *</div><div class="line">             * 将格式转换为毫秒*/</div><div class="line">            expiretime *= <span class="number">1000</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == REDIS_RDB_OPCODE_EXPIRETIME_MS) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 以毫秒计算的过期时间</span></div><div class="line"></div><div class="line">            <span class="comment">/* Milliseconds precision expire times introduced with RDB</span></div><div class="line">             * version 3. */</div><div class="line">            <span class="keyword">if</span> ((expiretime = rdbLoadMillisecondTime(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">            <span class="comment">/* We read the time so we need to read the object type again.</span></div><div class="line">             *</div><div class="line">             * 在过期时间之后会跟着一个键值对，我们要读入这个键值对的类型</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> ((type = rdbLoadType(&amp;rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">        &#125;</div><div class="line">            </div><div class="line">        <span class="comment">// 读入数据 EOF （不是 rdb 文件的 EOF）</span></div><div class="line">        <span class="keyword">if</span> (type == REDIS_RDB_OPCODE_EOF)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* Handle SELECT DB opcode as a special case </span></div><div class="line">         *</div><div class="line">         * 读入切换数据库指示</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (type == REDIS_RDB_OPCODE_SELECTDB) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 读入数据库号码</span></div><div class="line">            <span class="keyword">if</span> ((dbid = rdbLoadLen(&amp;rdb,<span class="literal">NULL</span>)) == REDIS_RDB_LENERR)</div><div class="line">                <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">            <span class="comment">// 检查数据库号码的正确性</span></div><div class="line">            <span class="keyword">if</span> (dbid &gt;= (<span class="keyword">unsigned</span>)server.dbnum) &#123;</div><div class="line">                redisLog(REDIS_WARNING,<span class="string">"FATAL: Data file was created with a Redis server configured to handle more than %d databases. Exiting\n"</span>, server.dbnum);</div><div class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 在程序内容切换数据库</span></div><div class="line">            db = server.db+dbid;</div><div class="line"></div><div class="line">            <span class="comment">// 跳过</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Read key </span></div><div class="line">         *</div><div class="line">         * 读入键</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> ((key = rdbLoadStringObject(&amp;rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">        <span class="comment">/* Read value </span></div><div class="line">         *</div><div class="line">         * 读入值</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> ((val = rdbLoadObject(type,&amp;rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</div><div class="line"></div><div class="line">        <span class="comment">/* Check if the key already expired. This function is used when loading</span></div><div class="line">         * an RDB file from disk, either at startup, or when an RDB was</div><div class="line">         * received from the master. In the latter case, the master is</div><div class="line">         * responsible for key expiry. If we would expire keys here, the</div><div class="line">         * snapshot taken by the master may not be reflected on the slave. </div><div class="line">         *</div><div class="line">         * 如果服务器为主节点的话，</div><div class="line">         * 那么在键已经过期的时候，不再将它们关联到数据库中去</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span> &amp;&amp; expiretime != <span class="number">-1</span> &amp;&amp; expiretime &lt; now) &#123;</div><div class="line">            decrRefCount(key);</div><div class="line">            decrRefCount(val);</div><div class="line">            <span class="comment">// 跳过</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Add the new object in the hash table </span></div><div class="line">         *</div><div class="line">         * 将键值对关联到数据库中</div><div class="line">         */</div><div class="line">        dbAdd(db,key,val);</div><div class="line"></div><div class="line">        <span class="comment">/* Set the expire time if needed </span></div><div class="line">         *</div><div class="line">         * 设置过期时间</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) setExpire(db,key,expiretime);</div><div class="line"></div><div class="line">        decrRefCount(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Verify the checksum if RDB version is &gt;= 5 </span></div><div class="line">     *</div><div class="line">     * 如果 RDB 版本 &gt;= 5 ，那么比对校验和</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (rdbver &gt;= <span class="number">5</span> &amp;&amp; server.rdb_checksum) &#123;</div><div class="line">        <span class="keyword">uint64_t</span> cksum, expected = rdb.cksum;</div><div class="line"></div><div class="line">        <span class="comment">// 读入文件的校验和</span></div><div class="line">        <span class="keyword">if</span> (rioRead(&amp;rdb,&amp;cksum,<span class="number">8</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</div><div class="line">        memrev64ifbe(&amp;cksum);</div><div class="line"></div><div class="line">        <span class="comment">// 比对校验和</span></div><div class="line">        <span class="keyword">if</span> (cksum == <span class="number">0</span>) &#123;</div><div class="line">            redisLog(REDIS_WARNING,<span class="string">"RDB file was saved with checksum disabled: no check performed."</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cksum != expected) &#123;</div><div class="line">            redisLog(REDIS_WARNING,<span class="string">"Wrong RDB checksum. Aborting now."</span>);</div><div class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 关闭 RDB </span></div><div class="line">    fclose(fp);</div><div class="line"></div><div class="line">    <span class="comment">// 服务器从载入状态中退出</span></div><div class="line">    stopLoading();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line"></div><div class="line">eoferr: <span class="comment">/* unexpected end of file is handled here with a fatal exit */</span></div><div class="line">    redisLog(REDIS_WARNING,<span class="string">"Short read or OOM loading DB. Unrecoverable error, aborting now."</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> REDIS_ERR; <span class="comment">/* Just to avoid warning */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h2><p>从SAVE命令的实现过程，我们能够知道一个RDB文件总体结构可以这样划分：</p>
<p><img src="http://data3.liuin.cn/2018-06-08-15284270187199.jpg" alt=""></p>
<p>在数据库数据部分其最基本的元素是键值对，存储在RDB的数据又可以分含有过期键的键值对和没有过期键的键值对两种</p>
<p>没有过期键的键值对组织形式：</p>
<p><img src="http://data3.liuin.cn/2018-06-08-15284272306576.jpg" alt=""></p>
<p>含有过期键的键值对组织形式：</p>
<p><img src="http://data3.liuin.cn/2018-06-08-15284272441950.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对RDB实现持久化的过程进行剖析&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="https://www.liuin.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析——数据库</title>
    <link href="https://www.liuin.cn/2018/05/30/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://www.liuin.cn/2018/05/30/Redis源码剖析——数据库/</id>
    <published>2018-05-30T01:35:46.000Z</published>
    <updated>2018-05-30T05:58:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将对Redis服务器的数据库实现进行介绍</p>
<a id="more"></a>
<h2 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h2><p>Redis服务器中一般保存了多个数据库，每个数据库用<code>redisDb</code>结构表示，结构的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisDb &#123;</div><div class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></div><div class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span></div><div class="line">    <span class="comment">// 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳</span></div><div class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span></div><div class="line">    <span class="comment">// 正处于阻塞状态的键</span></div><div class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP) */</span></div><div class="line">    <span class="comment">// 可以解除阻塞的键</span></div><div class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></div><div class="line">    <span class="comment">// 正在被 WATCH 命令监视的键</span></div><div class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></div><div class="line">    <span class="keyword">struct</span> evictionPoolEntry *eviction_pool;    <span class="comment">/* Eviction pool of keys */</span></div><div class="line">    <span class="comment">// 数据库号码</span></div><div class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID */</span></div><div class="line">    <span class="comment">// 数据库的键的平均 TTL ，统计信息</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></div><div class="line">&#125; redisDb;</div></pre></td></tr></table></figure>
<p>可以从Redis数据库中的定义中看到：数据库的所有键值对都存放在一个字典结构中，同时记录了用于键的删除所需要的过期时间。</p>
<p><img src="http://data3.liuin.cn/2018-05-30-15276449785249.jpg" alt=""></p>
<p>在Redis服务器结构中有一个数据库数组，存放各个数据库的指针；有一个记录数据库数量的变量dbnum，服务器初始化的时候根据这个变量来创建相应数量的数据库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> redisServer &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 数据库</span></div><div class="line">    redisDb *db;</div><div class="line">    <span class="comment">// 数据库数量</span></div><div class="line">    <span class="keyword">int</span> dbnum;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h2><p>每个 Redis客户端都有自己的目标数据库,每当客户端执行数据库写命令或者数据库读命令的时候,目标数据库就会成为这些命令的操作对象。默认情况下, Redis客户端的目标数据库为0号数据库,但客户端可以通过执行SELECT命令来切换目标数据库。</p>
<p>在客户端结构redisClient结构中用db属性记录客户端当前的目标数据库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisClient &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 记录客户端当前使用的数据库</span></div><div class="line">    redisDb *db;</div><div class="line">    ...</div><div class="line"></div><div class="line">&#125; redisClient</div></pre></td></tr></table></figure>
<p>redisClient.db指针指向redisServer.db数组的其中一个元素,而被指向的元素就是客户端的目标数据库。</p>
<p><img src="http://data3.liuin.cn/2018-05-30-15276464513190.jpg" alt=""></p>
<p>使用select切换数据库的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectDb</span><span class="params">(redisClient *c, <span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">    <span class="comment">// 验证db编号的合法性</span></div><div class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span> || id &gt;= server.dbnum)</div><div class="line">        <span class="keyword">return</span> REDIS_ERR;</div><div class="line">    c-&gt;db = &amp;server.db[id];</div><div class="line">    <span class="keyword">return</span> REDIS_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数据库的键空间"><a href="#数据库的键空间" class="headerlink" title="数据库的键空间"></a>数据库的键空间</h2><p>因为数据库的键空间是一个字典,所以所有针对数据库的操作,比如添加一个键值对到数据库,或者从数据库中删除一个键值对,又或者在数据库中获取某个键值对等,实际上都是通过对键空间字典进行操作来实现的</p>
<p><img src="http://data3.liuin.cn/2018-05-30-15276486205548.jpg" alt=""></p>
<h3 id="添加新键"><a href="#添加新键" class="headerlink" title="添加新键"></a>添加新键</h3><p>添加一个新键值对到数据库,实际上就是将一个新键值对添加到键空间字典里面,其中键为字符串对象,而值则为任意一种类型的 Redis对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbAdd</span><span class="params">(redisDb *db, robj *key, robj *val)</span> </span>&#123;</div><div class="line">    <span class="comment">// 拷贝字符串对象</span></div><div class="line">    sds copy = sdsdup(key-&gt;ptr);</div><div class="line">    <span class="comment">// 加入字典</span></div><div class="line">    <span class="keyword">int</span> retval = dictAdd(db-&gt;dict, copy, val);</div><div class="line"></div><div class="line">    redisAssertWithInfo(<span class="literal">NULL</span>,key,retval == REDIS_OK);</div><div class="line">    <span class="comment">// 如果值对象类型为list，需要判断该键是不是引起阻塞的键</span></div><div class="line">    <span class="keyword">if</span> (val-&gt;type == REDIS_LIST) signalListAsReady(db, key);</div><div class="line">    <span class="comment">// 如果开启的集群选项，则需要做相应的处理</span></div><div class="line">    <span class="keyword">if</span> (server.cluster_enabled) slotToKeyAdd(key);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p><img src="http://data3.liuin.cn/2018-05-30-15276578873211.jpg" alt=""></p>
<h3 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h3><p>删除数据库中的一个键,实际上就是在键空间里面删除键所对应的键值对对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></div><div class="line">     * the key, because it is shared with the main dictionary. */</div><div class="line">    <span class="comment">/* 如果有设定过期键，就去过期键字典中删除该键 */</span></div><div class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</div><div class="line">    <span class="keyword">if</span> (dictDelete(db-&gt;dict,key-&gt;ptr) == DICT_OK) &#123;</div><div class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><p>Reids中有LRU机制，能够实现对数据设置期限（过期时间），在期限到达的时候会执行删除机制。Redis中有三种不同的删除策略:</p>
<ul>
<li>定时删除:在设置键的过期时间的同时,创建一个定时器(timer),让定时器在键的过期时间来临时,立即执行对键的删除操作。</li>
<li>惰性删除:放任键过期不管,但是每次从键空间中获取键时,都检查取得的键是否过期,如果过期的话,就删除该键;如果没有过期,就返回该键。</li>
<li>定期删除:每隔一段时间,程序就对数据库进行一次检查,删除里面的过期键。至于要删除多少过期键,以及要检查多少个数据库,则由算法决定。</li>
</ul>
<p>在这三种策略中,第一种和第三种为主动删除策略,而第二种则为被动删除策略。</p>
<h3 id="过期时间的保存"><a href="#过期时间的保存" class="headerlink" title="过期时间的保存"></a>过期时间的保存</h3><p>redisDb结构的expires字典保存了数据库中所有键的过期时间,我们称这个字典为过期字典:</p>
<ul>
<li>过期字典的键是一个指针,这个指针指向键空间中的某个键对象(也即是某个数据库键)</li>
<li>过期字典的值是一个1ong 1ong类型的整数,这个整数保存了键所指向的数据库键的过期时间—个毫秒精度的UNIX时间戳。</li>
</ul>
<p><img src="http://data3.liuin.cn/2018-05-30-15276582632098.jpg" alt=""></p>
<h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>定时删除策略对内存是最友好的:通过使用定时器,定时删除策略可以保证过期键会尽可能快地被删除,并释放过期键所占用的内存。</p>
<p>另一方面,定时删除策略的缺点是,它对CPU时间是最不友好的:在过期键比较多的情况下,删除过期键这一行为可能会占用相当一部分CPU时间,在内存不紧张但是CPU时间非常紧张的情况下,将CPU时间用在删除和当前任务无关的过期键上,无疑会对服务器的响应时间和吞吐量造成影响。</p>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>惰性删除策略对CPU时间来说是最友好的:程序只会在取出键时才对键进行过期检查这可以保证删除过期键的操作只会在非做不可的情况下进行,并且删除的目标仅限于当前处理的键,这个策略<strong>不会在删除其他无关的过期键上花费任何CPU时间</strong>。</p>
<p>惰性删除策略的缺点是,它对内存是最不友好的:如果一个键已经过期,而这个键又仍然保留在数据库中,那么只要这个过期键不被删除,它所占用的内存就不会释放。</p>
<p>具体的实现是通过<code>expireIfNeeded</code>函数实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取定时时间</span></div><div class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key);</div><div class="line">    <span class="keyword">mstime_t</span> now;</div><div class="line">    <span class="comment">// 没有设置定时时间</span></div><div class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></div><div class="line">    <span class="comment">/* 服务器正在加载，不需要处理 */</span></div><div class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">/* lua相关 */</span></div><div class="line">    now = server.lua_caller ? server.lua_time_start : mstime();</div><div class="line">    <span class="comment">/* 主从复制相关 */</span></div><div class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> now &gt; when;</div><div class="line">    <span class="comment">/* 没有过期 */</span></div><div class="line">    <span class="keyword">if</span> (now &lt;= when) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">/* 删除键 */</span></div><div class="line">    server.stat_expiredkeys++;</div><div class="line">    propagateExpire(db,key);</div><div class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED,</div><div class="line">        <span class="string">"expired"</span>,key,db-&gt;id);</div><div class="line">    <span class="keyword">return</span> dbDelete(db,key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>从上面对定时删除和惰性删除的讨论来看,这两种删除方式在单一使用时都有明显的缺陷:</p>
<ul>
<li>定时删除占用太多CPU时间,影响服务器的响应时间和吞吐量。</li>
<li>惰性删除浪费太多内存,有内存泄漏的危险</li>
</ul>
<p>定期删除策略是前两种策略的一种整合和折中</p>
<ul>
<li>定期删除策略每隔一段时间执行一次删除过期键操作,并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li>
<li>除此之外,通过定期删除过期键,定期删除策略有效地减少了因为过期键而带来的内存浪费。</li>
</ul>
<p>定期删除策略的难点是确定删除操作执行的时长和频率</p>
<ul>
<li>如果删除操作执行得太频繁,或者执行的时间太长,定期删除策略就会退化成定时删除策略,以至于将CPU时间过多地消耗在删除过期键上面。</li>
<li>如果删除操作执行得太少,或者执行的时间太短,定期删除策略又会和惰性删除策略一样,出现浪费内存的情况</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将对Redis服务器的数据库实现进行介绍&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="https://www.liuin.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析——对象</title>
    <link href="https://www.liuin.cn/2018/05/29/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.liuin.cn/2018/05/29/Redis源码剖析——对象/</id>
    <published>2018-05-29T06:39:50.000Z</published>
    <updated>2018-05-30T01:09:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章将剖析Redis提供给用户的5种对象底层的数据结构和接口</p>
<a id="more"></a>
<p>前面讲了Reids底层所使用的一些数据结构：SDS、双端链表、字典、跳跃表等等，但是Redis并没有直接使用这些数据结构来构造键值对数据库。</p>
<h2 id="对象数据结构"><a href="#对象数据结构" class="headerlink" title="对象数据结构"></a>对象数据结构</h2><p>在redis.h中定义类redisObject的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Redis 对象定义</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisObject &#123;</div><div class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;       <span class="comment">// 类型</span></div><div class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;   <span class="comment">// 编码</span></div><div class="line">    <span class="comment">// 对象最后一次被访问的时间</span></div><div class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></div><div class="line">    <span class="comment">// 引用计数</span></div><div class="line">    <span class="keyword">int</span> refcount;</div><div class="line">    <span class="comment">// 实现的数据结构</span></div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line">&#125; robj;</div></pre></td></tr></table></figure>
<p>从代码中我们可以看到Redis对象所包含的信息有：类型、编码、实现指针、引用计数和访问时间</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>对于 Redis数据库保存的键值对来说,键总是一个字符串对象,而值则可以是字符串对象(string)、列表对象(list)、哈希对象(hash)、集合对象(set)或者有序集合对象(zset)的其中一种</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Object types */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_STRING 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LIST 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_SET 2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ZSET 3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_HASH 4</span></div></pre></td></tr></table></figure>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>对象的ptr指针指向对象的底层实现数据结构,而这些数据结构由对象的encoding属性决定encoding属性记录了对象所使用的编码,也即是说这个对象使用了什么数据结构作为对象的底层实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_RAW 0     <span class="comment">/* 编码为 简单动态字符串 */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INT 1     <span class="comment">/* 编码为 long类型的整数 */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_HT 2      <span class="comment">/* 编码为 字典 */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPMAP 3   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_LINKEDLIST 4 <span class="comment">/* 编码为 双端链表 */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPLIST 5 <span class="comment">/* 编码为 压缩列表 */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INTSET 6  <span class="comment">/* 编码为 整数集合 */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_SKIPLIST 7  <span class="comment">/* 编码为 跳跃表和字典 */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_EMBSTR 8  <span class="comment">/* 编码为 embstr编码的简单动态字符串 */</span></span></div></pre></td></tr></table></figure>
<p>每种类型的对象都至少对应两种不同的编码</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275795005914.jpg" alt=""></p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>Redis的对象系统实现了<strong>基于引用计数技术的内存回收机制</strong>,当程序不再使用某个对象的时候,这个对象所占用的内存就会被自动释放;另外, Redis还<strong>通过引用计数技术实现了对象共享机制</strong>,这一机制可以在适当的条件下,通过让多个数据库键共享同个对象来节约内存。</p>
<p>上面这些功能都是通过<code>refcount</code>这个属性来实现的：</p>
<ul>
<li>在创建一个新对象时,引用计数的值会被初始化为1</li>
<li>当对象被一个新程序使用时,它的引用计数值会被增一</li>
<li>当对象不再被一个程序使用时,它的引用计数值会被减一</li>
<li>当对象的引用计数值变为0时,对象所占用的内存会被释放</li>
</ul>
<p>修改引用计数的api如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrRefCount</span><span class="params">(robj *o)</span></span>;</div><div class="line"><span class="function">robj *<span class="title">resetRefCount</span><span class="params">(robj *obj)</span></span>;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>内存回收</p>
</blockquote>
<p>我们可以通过decrRefCount的实现看到当引用计数到达0的时候会自动释放对象所占有的资源</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) redisPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);</div><div class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// 释放对象占有的资源</span></div><div class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</div><div class="line">        <span class="keyword">case</span> REDIS_STRING: freeStringObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> REDIS_LIST: freeListObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> REDIS_SET: freeSetObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> REDIS_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> REDIS_HASH: freeHashObject(o); <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>: redisPanic(<span class="string">"Unknown object type"</span>); <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        zfree(o);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        o-&gt;refcount--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>对象共享</p>
</blockquote>
<p>如果想创建一个与另外一个对象含有相同值的对象，这个时候可以启动对象的共享机制。</p>
<p>在Redis中,让多个键共享同一个值对象需要执行以下两个步骤</p>
<ul>
<li>将数据库键的值指针指向一个现有的值对象</li>
<li>将被共享的值对象的引用计数增一</li>
</ul>
<p>比如在从LongLong创建一个字符串对象的时候，首先要判断在不在共享对象的范围内，如果在的话就对引用计数加1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function">robj *<span class="title">createStringObjectFromLongLong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</div><div class="line"></div><div class="line">    robj *o;</div><div class="line"></div><div class="line">    <span class="comment">// value 的大小符合 REDIS 共享整数的范围</span></div><div class="line">    <span class="comment">// 那么返回一个共享对象</span></div><div class="line">    <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt; REDIS_SHARED_INTEGERS) &#123;</div><div class="line">        incrRefCount(shared.integers[value]);</div><div class="line">        o = shared.integers[value];</div><div class="line"></div><div class="line">    <span class="comment">// 不符合共享范围，创建一个新的整数对象</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 值可以用 long 类型保存，</span></div><div class="line">        <span class="comment">// 创建一个 REDIS_ENCODING_INT 编码的字符串对象</span></div><div class="line">        <span class="keyword">if</span> (value &gt;= LONG_MIN &amp;&amp; value &lt;= LONG_MAX) &#123;</div><div class="line">            o = createObject(REDIS_STRING, <span class="literal">NULL</span>);</div><div class="line">            o-&gt;encoding = REDIS_ENCODING_INT;</div><div class="line">            o-&gt;ptr = (<span class="keyword">void</span>*)((<span class="keyword">long</span>)value);</div><div class="line"></div><div class="line">        <span class="comment">// 值不能用 long 类型保存（long long 类型），将值转换为字符串，</span></div><div class="line">        <span class="comment">// 并创建一个 REDIS_ENCODING_RAW 的字符串对象来保存值</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            o = createObject(REDIS_STRING,sdsfromlonglong(value));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="对象的基本操作"><a href="#对象的基本操作" class="headerlink" title="对象的基本操作"></a>对象的基本操作</h2><p>Redis对象的基本操作包含了创建对象、销毁对象、编码转换等等</p>
<p>大部分操作的实现都在object.c文件中</p>
<h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>各种对象创建的API如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span></span>;  <span class="comment">// 创建对象，设定参数</span></div><div class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>;  <span class="comment">// 创建字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createRawStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>;   <span class="comment">// 创建raw编码的字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createEmbeddedStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span>;  <span class="comment">// 创建embstr编码的字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createStringObjectFromLongLong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;  <span class="comment">// 根据传入LongLong创建字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createStringObjectFromLongDouble</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> value)</span></span>;  <span class="comment">// 根据传入的LongDouble创建字符串对象</span></div><div class="line"><span class="function">robj *<span class="title">createListObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建双端链表链表编码的列表对象</span></div><div class="line"><span class="function">robj *<span class="title">createZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建压缩列表编码的列表对象</span></div><div class="line"><span class="function">robj *<span class="title">createSetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建集合对象</span></div><div class="line"><span class="function">robj *<span class="title">createIntsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建整型集合编码的集合对象</span></div><div class="line"><span class="function">robj *<span class="title">createHashObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建hash对象</span></div><div class="line"><span class="function">robj *<span class="title">createZsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 创建zset对象</span></div><div class="line"><span class="function">robj *<span class="title">createZsetZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//创建压缩列表编码的zset对象</span></div></pre></td></tr></table></figure></p>
<p>具体我们以列表对象为例，看看创建对象的过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 创建一个 LINKEDLIST 编码的列表对象</div><div class="line"> */</div><div class="line"><span class="function">robj *<span class="title">createListObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="built_in">list</span> *l = listCreate();</div><div class="line">    robj *o = createObject(REDIS_LIST,l);</div><div class="line">    listSetFreeMethod(l,decrRefCountVoid);</div><div class="line">    o-&gt;encoding = REDIS_ENCODING_LINKEDLIST;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 创建一个 ZIPLIST 编码的列表对象</div><div class="line"> */</div><div class="line"><span class="function">robj *<span class="title">createZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</div><div class="line">    robj *o = createObject(REDIS_LIST,zl);</div><div class="line">    o-&gt;encoding = REDIS_ENCODING_ZIPLIST;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对象销毁"><a href="#对象销毁" class="headerlink" title="对象销毁"></a>对象销毁</h3><p>各种对象销毁的API如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeStringObject</span><span class="params">(robj *o)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeListObject</span><span class="params">(robj *o)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeSetObject</span><span class="params">(robj *o)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeZsetObject</span><span class="params">(robj *o)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeHashObject</span><span class="params">(robj *o)</span></span>;</div></pre></td></tr></table></figure></p>
<p>以List为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 释放列表对象</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeListObject</span><span class="params">(robj *o)</span> </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (o-&gt;encoding) &#123;</div><div class="line">    <span class="keyword">case</span> REDIS_ENCODING_LINKEDLIST:</div><div class="line">        listRelease((<span class="built_in">list</span>*) o-&gt;ptr);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> REDIS_ENCODING_ZIPLIST:</div><div class="line">        zfree(o-&gt;ptr);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        redisPanic(<span class="string">"Unknown list encoding type"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</div><div class="line">    listNode *current, *next;</div><div class="line"></div><div class="line">    <span class="comment">// 指向头指针</span></div><div class="line">    current = <span class="built_in">list</span>-&gt;head;</div><div class="line">    <span class="comment">// 遍历整个链表</span></div><div class="line">    len = <span class="built_in">list</span>-&gt;len;</div><div class="line">    <span class="keyword">while</span>(len--) &#123;</div><div class="line">        next = current-&gt;next;</div><div class="line">        <span class="comment">// 如果有设置值释放函数，那么调用它</span></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</div><div class="line">        <span class="comment">// 释放节点结构</span></div><div class="line">        zfree(current);</div><div class="line">        current = next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 释放链表结构</span></div><div class="line">    zfree(<span class="built_in">list</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和创建对象分多钟编码格式相对应，释放对象的时候也要根据编码具体执行释放</p>
<h2 id="对象交互指令"><a href="#对象交互指令" class="headerlink" title="对象交互指令"></a>对象交互指令</h2><p>Redis提供三个命令用户获取对象的一些参数：</p>
<ul>
<li>object refcount <key> 返回key所指的对象的引用计数</key></li>
<li>object encoding <key> 返回key所指的对象中存放的数据的编码方式</key></li>
<li>object idletime <key> 返回key所指的对象的空转时长</key></li>
</ul>
<p>具体的实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">objectCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line">    robj *o;</div><div class="line"></div><div class="line">    <span class="comment">// 返回对戏哪个的引用计数</span></div><div class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"refcount"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((o = objectCommandLookupOrReply(c,c-&gt;argv[<span class="number">2</span>],shared.nullbulk))</div><div class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line">        addReplyLongLong(c,o-&gt;refcount);</div><div class="line"></div><div class="line">    <span class="comment">// 返回对象的编码</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"encoding"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((o = objectCommandLookupOrReply(c,c-&gt;argv[<span class="number">2</span>],shared.nullbulk))</div><div class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line">        addReplyBulkCString(c,strEncoding(o-&gt;encoding));</div><div class="line">    </div><div class="line">    <span class="comment">// 返回对象的空闲时间</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">"idletime"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((o = objectCommandLookupOrReply(c,c-&gt;argv[<span class="number">2</span>],shared.nullbulk))</div><div class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line">        addReplyLongLong(c,estimateObjectIdleTime(o)/<span class="number">1000</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        addReplyError(c,<span class="string">"Syntax error. Try OBJECT (refcount|encoding|idletime)"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章将剖析Redis提供给用户的5种对象底层的数据结构和接口&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="https://www.liuin.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>《UNIX网络编程卷1》笔记 基本套接字编程部分</title>
    <link href="https://www.liuin.cn/2018/05/23/%E3%80%8AUNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B71%E3%80%8B%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%E9%83%A8%E5%88%86/"/>
    <id>https://www.liuin.cn/2018/05/23/《UNIX网络编程卷1》笔记-基本套接字编程部分/</id>
    <published>2018-05-23T13:36:29.000Z</published>
    <updated>2018-05-29T06:29:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>UNIX网络编程必读书籍——《UNIX网络编程卷1》  基本套接字编程 笔记</p>
<a id="more"></a>
<h1 id="套接字编程简介"><a href="#套接字编程简介" class="headerlink" title="套接字编程简介"></a>套接字编程简介</h1><h2 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h2><p>大多数套接字函数都需要一个指向套接字地址结构的指针作为参数。每个协议族都定义它自己的套接字地址结构。这些结构的名字均以 sockaddr_开头,并以对应每个协议族的唯一后缀结尾。</p>
<h3 id="IPv4套接字地址结构"><a href="#IPv4套接字地址结构" class="headerlink" title="IPv4套接字地址结构"></a>IPv4套接字地址结构</h3><p>IPv4套接字地址结构通常也称为“网际套接字地址结构”,它以 sockaddr_in命名,定义在<netinet in.h="">头文件中。POSIX定义：</netinet></p>
<p><img src="https://data2.liuin.cn/2018-05-22-15269964950047.jpg" alt=""></p>
<p>下面给出几点说明：</p>
<ul>
<li>并不是所有厂商都支持sin_len，即使有长度字段,我们也无须设置和检查它,除非涉及路由套接字，处理来自不同协议族的套接字地址结构的例程(例如路由表处理代码)在内核中使用的。</li>
<li>POSX规范只需要这个结构中的3个字段:sin_fari1y、 sin_addr和sin_port,</li>
</ul>
<h3 id="通用套接字地址结构"><a href="#通用套接字地址结构" class="headerlink" title="通用套接字地址结构"></a>通用套接字地址结构</h3><p>当作为一个参数传递进任何套接字函数时,套接字地址结构总是以引用形式(也就是以指向该结构的指针)来传递。然而以这样的指针作为参数之一的任何套接字函数必须处理来自所支持的任何协议族的套接字地址结构。</p>
<p>现在所采用的方法是在<sys socket.h="">头文件中定义一个通用的套接字地址结构：</sys></p>
<p><img src="https://data2.liuin.cn/2018-05-22-15269968296764.jpg" alt=""></p>
<p>于是套接字函数被定义为以指向某个通用套接字地址结构的一个指针作为其参数之一。这就要求对这些函数的任何调用都必须要将<strong>指向特定于协议的套接字地址结构的指针进行强制转换(casting),变成指向某个通用套接字地址结构的指针</strong></p>
<p>从应用程序开发人员的观点看,这些通用套接字地址结构的唯一用途就是<strong>对指向特定于协议的套接字地址结构的指针执行类型强制转换</strong>。</p>
<h3 id="套接字地址结构比较"><a href="#套接字地址结构比较" class="headerlink" title="套接字地址结构比较"></a>套接字地址结构比较</h3><p><img src="https://data2.liuin.cn/2018-05-22-15269969711360.jpg" alt=""></p>
<h2 id="值-结果参数"><a href="#值-结果参数" class="headerlink" title="值-结果参数"></a>值-结果参数</h2><p>当往一个套接字函数传递一个套接字地址结构时,该<strong>结构总是以引用形式来传递</strong>,也就是说传递的是指向该结构的一个指针。该结构的长度也作为一个参数来传递,不过其传递方式取决于该结构的传递方向:是从进程到内核,还是从内核到进程。</p>
<p>(1)从进程到内核传递套接字地址结构的函数有3个:bind、connect和 sendto。这些函数的一个参数是指向某个套接字地址结构的指针,另一个参数是该结构的整数大小。既然指针和指针所指内容的大小都传递给了内核,于是内核知道到底需从进程复制多少数据进来。</p>
<p><img src="https://data2.liuin.cn/2018-05-22-15269972347844.jpg" alt=""></p>
<p>(2)从内核到进程传递套接字地址结构的函数有4个: accept、 recvfrom、 getsockname和 getpeername。这4个函数的其中两个参数是<strong>指向某个套接字地址结构的指针</strong>和<strong>指向表示该结构大小的整数变量的指针</strong>。把套接字地址结构大小这个参数从一个整数改为指向某个整数变量的指针,其原因在于:当函数被调用时,结构大小是一个值(value),它告诉内核该结构的大小,这样内核在写该结构时不至于越界;当函数返回时,结构大小又是一个结果(result.),它告诉进程内核在该结构中究竟存储了多少信息。这种类型的参数称为值-结果(value-result)参数。</p>
<p><img src="https://data2.liuin.cn/2018-05-22-15269973186591.jpg" alt=""></p>
<p>在网络编程中,值-结果参数最常见的例子是所返回套接字地址结构的长度</p>
<h2 id="字节排序函数"><a href="#字节排序函数" class="headerlink" title="字节排序函数"></a>字节排序函数</h2><p>内存中有两种存储多字节数的方法：一种是将低序字节存储在起始地址,这称为小端(little-endian)字节序;另一种方法是将高序字节存储在起始地址,这称为大端(big-endian)字节序</p>
<p><img src="https://data2.liuin.cn/2018-05-22-15269974255787.jpg" alt=""></p>
<p>不同的主机中使用的字节序是不一样的。</p>
<p>套接字地址结构中的某些字段必须按照网络字节序进行维护。因此我们要关注如何在主机字节序和网络字节序之间相互转换。这两种字节序之间的转换使用以下4个函数：</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270558826021.jpg" alt=""></p>
<p>在这些函数的名字中,h代表host,n代表network,s代表short,l代表long。</p>
<h2 id="字节操作函数"><a href="#字节操作函数" class="headerlink" title="字节操作函数"></a>字节操作函数</h2><p>操纵多字节字段的函数有两组,它们<strong>既不对数据作解释,也不假设数据是以空字符结束的C字符串</strong>。当处理套接字地址结构时,我们需要这些类型的函数,因为我们需要操纵诸如IP地址这样的字段,这些字段可能包含值为0的字节,却并不是C字符串。以空字符结尾的C字符串是由在<string.h>头文件中定义、名字以str(表示字符串)开头的函数处理的。</string.h></p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270567699154.jpg" alt=""></p>
<p>bzero把目标字节串中指定数目的字节置为0。我们经常使用该函数来把一个套接字地址结构初始化为0。 bcopy将指定数目的字节从源字节串移到目标字节串。bcmp比较两个任意的字节串,若相同则返回值为0,否则返回值为非0。</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270568142560.jpg" alt=""></p>
<p>memset把目标字节串指定数目的字节置为值c。 memcpy类似bcopy,不过两个指针参数的顺序是相反的。当源字节串与目标字节串重叠时,bco能够正确处理,但是 memcpy的操作结果却不可知。这种情形下必须改用 ANSI C的 mernmove函数。</p>
<h2 id="inet-aton、inet-addr和inet-ntoa函数"><a href="#inet-aton、inet-addr和inet-ntoa函数" class="headerlink" title="inet_aton、inet_addr和inet_ntoa函数"></a>inet_aton、inet_addr和inet_ntoa函数</h2><p>在ASCII字符串(这是人们偏爱使用的格式)与网络字节序的二进制值(这是存放在套接字地址结构中的值)之间转换网际地址需要一些函数进行实现。</p>
<p>inet_aton、inet_addr和 inet_ntoa在点分十进制数串(例如“206,168,112.96”)与它长度为32位的网络字节序二进制值间转换IP4地址:</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270571324262.jpg" alt=""></p>
<h2 id="inet-pton和inet-ntop函数"><a href="#inet-pton和inet-ntop函数" class="headerlink" title="inet_pton和inet_ntop函数"></a>inet_pton和inet_ntop函数</h2><p>这两个函数是随Iv6出现的新函数,对于IPv4地址和Pv6地址都适用。本书通篇都在使用这两个函数。函数名中和n分别代表表达( presentation)和数值( numeric)。地址的表达格式通常是ASCⅡ字符串,数值格式则是存放到套接字地址结构中的二进制值</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270571987014.jpg" alt=""></p>
<h2 id="sock-ntop和相关函数"><a href="#sock-ntop和相关函数" class="headerlink" title="sock_ntop和相关函数"></a>sock_ntop和相关函数</h2><p>inet_ntop的一个基本问题是:它要求调用者传递一个指向某个二进制地址的指针,而该地址通常包含在一个套接字地址结构中,这就要求调用者必须知道这个结构的格式和地址族。</p>
<p>为了解决这个问题,我们将自行编写一个名为sock_ntop的函数,它以指向某个套接字地址结构的指针为参数,查看该结构的内部,然后调用适当的函数返回该地址的表达格式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sock_ntop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *sockaddr, <span class="keyword">sockelen_t</span> addrlen)</span></span>;</div></pre></td></tr></table></figure>
<p>仅为AF_INET下的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sock_ntop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *sockaddr, <span class="keyword">sockelen_t</span> addrlen)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> portstr[<span class="number">8</span>];</div><div class="line">	<span class="keyword">static</span> <span class="keyword">char</span> str[<span class="number">128</span>];</div><div class="line"></div><div class="line">	<span class="keyword">switch</span>(sockaddr-&gt;sa_family)&#123;</div><div class="line">		<span class="keyword">case</span> AF_INET:</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">struct</span> sockaddr_in *<span class="built_in">sin</span> = (<span class="keyword">struct</span> sockaddr_in *) sockeaddr;</div><div class="line">				<span class="keyword">if</span>(inet_ntop(AF_INET, &amp;<span class="built_in">sin</span>-&gt;sin_addr, str, <span class="keyword">sizeof</span>(str)) == <span class="literal">NULL</span>)</div><div class="line">					<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">				<span class="keyword">if</span>(ntohs(<span class="built_in">sin</span>-&gt;sin_port) != <span class="number">0</span>)</div><div class="line">				&#123;</div><div class="line">					<span class="built_in">snprintf</span>(portstr, <span class="keyword">sizeof</span>(portstr), <span class="string">":%d"</span>, ntohs(<span class="built_in">sin</span>-&gt;sin_port));</div><div class="line">					<span class="built_in">strcat</span>(str, portstr);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> str;</div><div class="line">			&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="readn、writen和readline函数"><a href="#readn、writen和readline函数" class="headerlink" title="readn、writen和readline函数"></a>readn、writen和readline函数</h2><p>字节流套接字(例如TCP套接字)上的read和 write函数所表现的行为不同于通常的文件IO。字节流套接字上调用read或 write输入或输出的字节数可能比请求的数量少,然而这不是出错的状态。这个现象的原因在于<strong>内核中用于套接字的缓冲区可能已达到了极限</strong>。</p>
<p>因为这个原因，我们可以在原始的读写函数的基础上，为了使得I/O传输所有的字符，我们不断调用read、write直到对所需要的数据完成所有的传输</p>
<h1 id="基本TCP套接字编程"><a href="#基本TCP套接字编程" class="headerlink" title="基本TCP套接字编程"></a>基本TCP套接字编程</h1><p>下图给出了TCP客户与服务器进程之间发生的一些典型事件的时间表：</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270592134854.jpg" alt=""></p>
<h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><p>为了执行网络O,一个进程必须做的第一件事情就是调用 socket函数,指定期望的通信协议类型(使用IPv4的TCP、使用IPv6的UDP、Unix域字节流协议等)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span> <span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: non-negative descriptor if OK, -1 on error</span></div></pre></td></tr></table></figure>
<p>其中family参数指明协议族。该参数也往往被称为协议域。type参数指明套接字类型。protocol参数应设为某个协议类型常值,或者设为0,以选择所给定mi和nye组合的系统默认值。</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270603977151.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270604018451.jpg" alt=""></p>
<p>socket函数在成功时返回一个小的非负整数值,它与文件描述符类似,我们把它称为套接字描述符(socket descriptor),简称sockfd</p>
<blockquote>
<p>对比AF_XXX和PF_XXX</p>
</blockquote>
<p>AF前缀表示地址族,PF前缀表示协议族。历史上曾有这样的想法:单个协议族可以支持多个地址族,<strong>PF值用来创建套接字,而AF值用于套接字地址结构</strong>。但实际上,支持多个地址族的协议族从来就未实现过,而且头文件<sys socket.h="">中为一给定协议定义的PF值总是与此协议的AF值相等。</sys></p>
<h2 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h2><p>TCP客户用 connect函数来建立与TCP服务器的连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *servaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>; </div><div class="line"><span class="comment">// Returns: 0 if OK, -1 on error</span></div></pre></td></tr></table></figure>
<p>sockfd是由socket函数返回的套接字描述符,第二个、第三个参数分别是一个指向套接字地址结构的指针和该结构的大小。客户在调用函数 connect前不必非得调用bind函数,因为如果需要的话,内核会确定源IP地址,并选择一个临时端口作为源端口。</p>
<p>建立连接是通过TCP三次握手建立的，建立连接中产生的具体错误可以通过返回值进行判断</p>
<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><p>bind函数把一个本地协议地址赋予一个套接字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span> <span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK,-1 on error</span></div></pre></td></tr></table></figure>
<p>第二个参数是一个指向特定于协议的地址结构的指针,第三个参数是该地址结构的长度。对于TCP,调用bind函数可以指定一个端口号,或指定一个IP地址,也可以两者都指定,还可以都不指定。</p>
<ul>
<li>服务器在启动时捆绑它们的众所周知端口</li>
<li>进程可以把一个特定的IP地址捆绑到它的套接字上,不过这个IP地址必须属于其所在主机的网络接口之一。对于TCP客户,这就为在该套接字上发送的IP数据报指派了源IP地址。对于TCP服务器,这就限定该套接字只接收那些目的地为这个P地址的客户连接。</li>
</ul>
<p>如果指定端口号为0,那么内核就在bind被调用时选择一个临时端口。然而如果指定IP地址为通配地址,那么内核将等到套接字已连接(TCP)或已在套接字上发出数据报(UDP)时才选择一个本地IP地址</p>
<h2 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h2><p>listen函数仅由TCP服务器调用,它做两件事情</p>
<ol>
<li>当 socket函数创建一个套接字时,它被假设为一个<strong>主动套接字</strong>,也就是说,它是一个将调用connect发起连接的客户套接字。listen函数把一个未连接的套接字转换成一个被动套接字,指示内核应接受指向该套接字的连接请求。</li>
<li>本函数的第二个参数规定了内核应该为相应套接字排队的最大连接个数。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span> <span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, -1 on error</span></div></pre></td></tr></table></figure>
<p>为了理解其中的backlog参数,我们必须认识到内核为任何一个给定的监听套接字维护两个队列:</p>
<ol>
<li>未完成连接队列(incomplete connection queue),每个这样的SYN分节对应其中一项:已由某个客户发出并到达服务器,而服务器正在等待完成相应的TCP三路握手过程。这些套接字处于SYN RCVD状态。</li>
<li>已完成连接队列(completed connection queue),每个已完成TCP三路握手过程的客户对应其中一项。这些套接字处于 ESTABLISHED状态</li>
</ol>
<h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><p>accept函数由TCP服务器调用,用于从已完成连接队列队头返回下一个已完成连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span> <span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *cliaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: non-negative descriptor if OK, -1 on error</span></div></pre></td></tr></table></figure>
<p>参数cliaddr和addrlen用来返回已连接的对端进程(客户)的协议地址。 addrlen是值-结果参数:调用前,我们将由*addrlen所引用的整数值置为由cliaddr所指的套接字地址结构的长度,返回时,该整数值即为由内核存放在该套接字地址结构内的确切字节数。</p>
<p>如果accept成功,那么其返回值是由内核自动生成的一个全新描述符,代表与所返回客户的TCP连接。在讨论 accept函数时,我们称它的第一个参数为<strong>监听套接字</strong>(listening socket)描述符(由socke创建,随后用作bind和listen的第一个参数的描述符),称它的返回值为<strong>已连接套接字</strong>( connected socket)描述符。</p>
<p>区分这两个套接字非常重要。一个服务器通常仅仅创建个监听套接字,它在该服务器的生命期内一直存在。内核为每个由服务器进程接受的客户连接创建一个已连接套接字(也就是说对于它的TCP三路握手过程已经完成)。当服务器完成对某个给定客户的服务时,相应的已连接套接字就被关闭。</p>
<h2 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h2><p>然而当服务一个客户请求可能花费较长时间时,我们并不希望整个服务器被单个客户长期占用,而是希望同时服务多个客户。Unix中编写并发服务器程序最简单的办法就是foxk一个子进程来服务每个客户。</p>
<p>当一个连接建立时, accept返回,服务器接着调用fork,然后由子进程服务客户(通过已连接套接字clientfd),父进程则等待另一个连接(通过监听套接字listened)。既然新的客户由子进程提供服务,父进程就关闭已连接套接。</p>
<h2 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h2><p>close一个TCP套接字的默认行为是把该套接字标记成已关闭,然后立即返回到调用进程。该套接字描述符不能再由调用进程使用,也就是说它不能再作为read或wrie的第一个参数。然而TCP将尝试发送已排队等待发送到对端的任何数据,发送完毕后发生的是正常的TCP连接终止序列。</p>
<p>并发服务器中父进程关闭已连接套接字只是导致相应描述符的引用计数值减1。既然引用计数值仍大于0,这个<strong>c1ose调用并不引发TCP的四分组连接终止序列</strong>。对于父进程与子进程共享已连接套接字的并发服务器来说,这正是所期望的。如果我们确实想在某个TCP连接上发送一个FⅠN,那么可以改用shutdow函数以代替c1ose。</p>
<h1 id="I-O复用：select和poll函数"><a href="#I-O复用：select和poll函数" class="headerlink" title="I/O复用：select和poll函数"></a>I/O复用：select和poll函数</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>有的时候，进程需要一种预先告知内核的能力,使得内核一旦发现进程指定的一个或多个I/O条件就绪(也就是说输入已准备好被读取,或者描述符已能承接更多的输出),它就通知进程。这个能力称为I/O复用(I/O multiplexing),是由se1ect和po11这两个函数支持的。</p>
<p>IO复用典型使用在下列网络应用场合:</p>
<ul>
<li>当客户处理多个描述符(通常是交互式输入和网络套接字)时,必须使用I/O复用。</li>
<li>一个客户同时处理多个套接字是可能的,不过比较少见。</li>
<li>如果一个TCP服务器既要处理监听套接字,又要处理已连接套接字,一般就要使用I/O复用</li>
<li>如果一个服务器即要处理TCP,又要处理UDP,一般就要使用I/O复用</li>
<li>如果一个服务器要处理多个服务或者多个协议,一般就要使用IO复用。</li>
</ul>
<p>IO复用并非只限于网络编程,许多重要的应用程序也需要使用这项技术。</p>
<h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h2><p>在介绍 select和poll这两个函数之前,我们需要回顾整体,查看Uniⅸ下可用的5种I/O模型的基本区别:</p>
<ul>
<li>阻塞式I/O;</li>
<li>非阻塞式I/O;</li>
<li>IO复用(se1ect和po11);</li>
<li>信号驱动式IO(SIGIO);</li>
<li>异步I/O(POSIX的aio_系列函数)。</li>
</ul>
<h3 id="阻塞式I-O模型"><a href="#阻塞式I-O模型" class="headerlink" title="阻塞式I/O模型"></a>阻塞式I/O模型</h3><p>默认情形下,所有套接字都是阻塞的</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274240586717.jpg" alt=""></p>
<p>在图中,进程调用 recvfrom,其系统调用直到数据报到达且被复制到应用进程的缓冲区中或者发生错误才返回。最常见的错误是系统调用被信号中断</p>
<h3 id="非阻塞式I-O模型"><a href="#非阻塞式I-O模型" class="headerlink" title="非阻塞式I/O模型"></a>非阻塞式I/O模型</h3><p>进程把一个套接字设置成非阻塞是在通知内核：当所请求的I/O操作非得把本进程投入睡眠才能完成时,不要把本进程投入睡眠,而是返回一个错误。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274241782814.jpg" alt=""></p>
<p>当一个应用进程像这样对一个非阻塞描述符循环调用 recvfrom时,我们称之为轮询</p>
<h3 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h3><p>有了I/O复用(I/O multiplexing),我们就可以调用select或po11,<strong>阻塞在这两个系统调用中的某一个之上,而不是阻塞在真正的I/O系统调用上</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274242724836.jpg" alt=""></p>
<p>我们阻塞于se]ect调用,等待数据报套接字变为可读。当se1ect返回套接字可读这一条件时,我们调用 recvfrom把所读数据报复制到应用进程缓冲区。</p>
<h3 id="信号驱动式IO模型"><a href="#信号驱动式IO模型" class="headerlink" title="信号驱动式IO模型"></a>信号驱动式IO模型</h3><p>我们也可以用信号,让内核在描述符就绪时发送SIGIO信号通知我们。我们称这种模型为信号驱动式I/O( signal-driven I/O)</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274243322666.jpg" alt=""></p>
<h3 id="异步I-O模型"><a href="#异步I-O模型" class="headerlink" title="异步I/O模型"></a>异步I/O模型</h3><p>这些函数的工作机制是:告知内核启动某个操作,并让内核在整个操作(包括将数据从内核复制到我们自己的缓冲区)完成后通知我们。这种模型与前一节介绍的信号驱动模型的主要区别在于:<strong>信号驱动式IO是由内核通知我们何时可以启动一个O操作,而异步LO模型是由内核通知我们IO操作何时完成</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274244101255.jpg" alt=""></p>
<h3 id="各种I-O模型的比较"><a href="#各种I-O模型的比较" class="headerlink" title="各种I/O模型的比较"></a>各种I/O模型的比较</h3><p><img src="https://data2.liuin.cn/2018-05-27-15274244780614.jpg" alt=""></p>
<p>上图对比了上述5种不同的I/O模型。可以看出,前4种模型的主要区别在于第一阶段,因为它们的第二阶段是一样的:在数据从内核复制到调用者的缓冲区期间,进程阻塞于recvfrom调用。相反,异步I/O模型在这两个阶段都要处理,从而不同于其他4种模型。</p>
<h2 id="select-函数"><a href="#select-函数" class="headerlink" title="select 函数"></a>select 函数</h2><p>该函数允许进程指示内核等待多个事件中的任何一个发生,并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。也就是说,我们调用 select告知内核对哪些描述符(就读、写或异常条件)感兴趣以及等待多长时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> <span class="keyword">struct</span> timeval *timeout)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: positive count of ready descriptors, 0 on timeout, –1 on error</span></div></pre></td></tr></table></figure>
<p>最后一个参数它告知内核等待所指定描述符中的任何一个就绪可花多少时间。</p>
<p>中间的三个参数 readset、 writeset和 excepts指定我们要让内核测试读、写和异常条件的描述符。目前支持的异常条件只有两个:<br>(1)某个套接字的带外数据的到达<br>(2)某个已置为分组模式的伪终端存在可从其主端读取的控制状态信息</p>
<p>如何给这3个参数中的每一个参数指定一个或多个描述符值是一个设计上的问题。se1ect使用描述符集,通常是一个整数数组,其中每个整数中的每一位对应一个描述符</p>
<p>select函数的中间三个参数 readset、 writeset和 excepts中,如果我们对某一个的条件不感兴趣,就可以把它设为空指针。事实上,如果这三个指针}均为空,我们就有了一个比UNIX的s1eep函数更为精确的定时器( sleep睡眠以秒为最小单位)。</p>
<p>头文件<sys select.h="">中定义的 FD_SETSIZE常值是数据类型 fd_set中的描述符总数,其值通常是1024,不过很少有程序用到那么多的描述符。<strong>maxfdpl参数迫使我们计算出所关心的最大描述符并告知内核该值</strong>。</sys></p>
<p>se1ect函数修改由指针 readset、 writeset和 excepts所指向的的描述符集,因而这三个参数都是值结果参数。调用该函数时,我们指定所关心的描述符的值,该函数返回时,结果将指示哪些描述符已就绪。该函数返回后,我们使用 FD_ISSET宏来测试 fa_set数据类型中的描述符描述符集内任何与未就绪描述符对应的位返回时均清成0。为此,每次重新调用se1ect函数时,我们都得再次把所有描述符集内所关心的位均置为1。</p>
<p>该函数的<strong>返回值表示跨所有描述符集的已就绪的总位数</strong>。如果在任何描述符就绪之前定时器到时,那么返回0。返回-1表示出错(这是可能发生的,譬如本函数被一个所捕获的信号中断)。</p>
<h3 id="描述符就绪条件"><a href="#描述符就绪条件" class="headerlink" title="描述符就绪条件"></a>描述符就绪条件</h3><p>我们一直在讨论等待某个描述符准备好I/O(读或写)或是等待其上发生一个待处理的异常条件(带外数据)。尽管可读性和可写性对于普通文件这样的描述符显而易见,然而对于引起select返回套接字“就绪”的条件我们必须讨论得更明确些</p>
<p>满足下列四个条件中的任何一个时,一个套接字准备好读</p>
<ol>
<li>该套接字接收缓冲区中的数据字节数大于等于套接字接收缓冲区低水位标记的当前大小。对这样的套接字执行读操作不会阻塞并将返回一个大于0的值(也就是返回准备好读入的数据)。</li>
<li>该连接的读半部关闭(也就是接收了FIN的TCP连接)。对这样的套接字的读操作将不阻塞并返回0(也就是返回EOF)。</li>
<li>该套接字是一个监听套接字且已完成的连接数不为0。对这样的套接字的accept通常不会阻塞</li>
<li>其上有一个套接字错误待处理。</li>
</ol>
<p>下列四个条件中的任何一个满足时,一个套接字准备好写</p>
<ol>
<li>该套接字发送缓冲区中的可用空间字节数大于等于套接字发送缓冲区低水位标记的当前大小,并且或者该套接字已连接,或者该套接字不需要连接(如UDP套接字)。这意味着如果我们把这样的套接字设置成非阻塞，写操作将不阻塞并返回一个正值(例如由传输层接受的字节数)。</li>
<li>该连接的写半部关闭。对这样的套接字的写操作将产生SIGPIP信号</li>
<li>使用非阻塞式connect的套接字已建立连接,或者connect已经以失败告终</li>
<li>其上有一个套接字错误待处理。</li>
</ol>
<p>如果一个套接字存在带外数据或者仍处于带外标记,那么它有异常条件待处理。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274255486025.jpg" alt=""></p>
<h2 id="shutdown函数"><a href="#shutdown函数" class="headerlink" title="shutdown函数"></a>shutdown函数</h2><p>终止网络连接的通常方法是调用c1ose函数。不过cose有两个限制,却可以使用shutdown来避免：</p>
<ol>
<li>close把描述符的引用计数减1,仅在该计数变为0时才关闭套接字。使用 shutdown可以不管引用计数就激发TCP的正常连接终止序列</li>
<li>close终止读和写两个方向的数据传送。既然TCP连接是全双工的,有时候我们需要告知对端我们已经完成了数据发送,即使对端仍有数据要发送给我们。</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-05-27-15274259894144.jpg" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, –1 on error</span></div></pre></td></tr></table></figure>
<p>该函数的行为依赖于howo参数的值:</p>
<ul>
<li>SHUT_RD——关闭连接的读这一半——套接字中不再有数据可接收,而且套接字接收缓冲区中的现有数据都被丢弃。进程不能再对这样的套接字调用任何读函数。对一个TCP套接字这样调用 shutdown函数后,由该套接字接收的来自对端的任何数据都被确认,然后悄然丢弃。</li>
<li>SHUT_WR——关闭连接的写这一半——对于TCP套接字,这称为半关闭。当前留在套接字发送缓冲区中的数据将被发送掉,后跟TCP的正常连接终止序列。我们已经说过,不管套接字描述符的引用计数是否等于0,这样的写半部关闭照样执行。进程不能再对这样的套接字调用任何写函数。</li>
<li>SHUT_RDWR——连接的读半部和写半部都关闭——这与调用shutdown两次等效:第一次调用指定 SHUT_RD,第二次调用指定 SHUT_WR</li>
</ul>
<h2 id="pselect-函数"><a href="#pselect-函数" class="headerlink" title="pselect 函数"></a>pselect 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span> <span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *timeout, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, –1 on error</span></div></pre></td></tr></table></figure>
<p>pselect相对于通常的select有两个变化。</p>
<ul>
<li>pselect使用timespec结构,而不使用timeval结构。前者指定纳秒数，后者指定微秒数</li>
<li>pselect函数增加了第六个参数:一个指向信号掩码的指针。该参数允许程序先禁止递交某些信号,再测试由这些当前被禁止信号的信号处理函数设置的全局变量,然后调用select,告诉它重新设置信号掩码。</li>
</ul>
<h2 id="poll-函数"><a href="#poll-函数" class="headerlink" title="poll 函数"></a>poll 函数</h2><p>po11提供的功能与se1ect类似,不过在处理流设备时,它能够提供额外的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(<span class="keyword">struct</span> pollfd *fdarray, <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, –1 on error</span></div></pre></td></tr></table></figure>
<p>第一个参数是指向一个结构数组第一个元素的指针。每个数组元素都是一个pollfd结构,用于指定测试某个给定描述符fd的条件。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274265737476.jpg" alt=""></p>
<p>要测试的条件由 events成员指定,函数在相应的 revents成员中返回该描述符的状态。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274266342975.jpg" alt=""></p>
<h1 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h1><h2 id="getsockopt和setsockopt函数"><a href="#getsockopt和setsockopt函数" class="headerlink" title="getsockopt和setsockopt函数"></a>getsockopt和setsockopt函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval <span class="keyword">socklen_t</span> optlen)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK,–1 on error</span></div></pre></td></tr></table></figure>
<p>其中sockfd必须指向一个打开的套接字描述符,level(级别)指定系统中解释选项的代码或为通用套接字代码,或为某个特定于协议的代码(例如IPv4、IPv6、TCP或SCTP)。optval是一个指向某个变量(*optval)的指针, setsockopt从*optval中取得选项待设置的新值, getsockopt则把已获取的选项当前值存放到*optval冲中。*optval的大小由最后一个参数指定,它对于setsockopt是一个值参数,对于 getsockopt是一个值-结果参数</p>
<p>套接字选项粗分为两大基本类型:一是<strong>启用或禁止某个特性的二元选项(称为标志选项)</strong>二是<strong>取得并返回我们可以设置或检查的特定值的选项</strong>(称为值选项)。</p>
<h2 id="通用套接字选项"><a href="#通用套接字选项" class="headerlink" title="通用套接字选项"></a>通用套接字选项</h2><p>通用套接字选项是与协议无关的，不过其中有些选项只能应用到某些特定类型的套接字中。</p>
<h3 id="SO-BROADCAST套接字选项"><a href="#SO-BROADCAST套接字选项" class="headerlink" title="SO_BROADCAST套接字选项"></a>SO_BROADCAST套接字选项</h3><p>本选项开启或禁止进程发送广播消息的能力。只有数据报套接字支持广播,并且还必须是在支持广播消息的网络上(例如以太网、令牌环网等)。我们不可能在点对点链路上进行广播,也不可能在基于连接的传输协议(例如TCP和SCTP)之上进行广播。</p>
<p>由于应用进程在发送广播数据报之前必须设置本套接字选项,因此它能够有效地防止一个进程在其应用程序根本没有设计成可广播时就发送广播数据报。</p>
<h3 id="SO-DEBUG套接字选项"><a href="#SO-DEBUG套接字选项" class="headerlink" title="SO_DEBUG套接字选项"></a>SO_DEBUG套接字选项</h3><p>本选项仅由TCP支持。当给一个TCP套接字开启本选项时,内核将为TCP在该套接字发送和接收的所有分组保留详细跟踪信息。这些信息保存在内核的某个环形缓冲区中,并可使用trpt程序进行检查。</p>
<h3 id="SO-DONTROUTE套接字选项"><a href="#SO-DONTROUTE套接字选项" class="headerlink" title="SO_DONTROUTE套接字选项"></a>SO_DONTROUTE套接字选项</h3><p>本选项规定外出的分组将绕过底层协议的正常路由机制</p>
<h3 id="SO-ERROR套接字选项"><a href="#SO-ERROR套接字选项" class="headerlink" title="SO_ERROR套接字选项"></a>SO_ERROR套接字选项</h3><p>当一个套接字上发生错误时,源自 Berkeley的内核中的协议模块将该套接字的名为so_error的变量设为标准的Unix Exxx值中的一个,我们称它为该套接字的待处理错误( pendingeror)。内核能够以下面两种方式之一立即通知进程这个错误。</p>
<ol>
<li>如果进程阻塞在对该套接字的 select调用上,那么无论是检查可读条件还是可写条件, select均返回并设置其中一个或所有两个条件。</li>
<li>如果进程使用信号驱动式I/O模型,那就给进程或进程组产生一个SIGTO信号。</li>
</ol>
<h3 id="SO-KEEPALIVE套接字选项"><a href="#SO-KEEPALIVE套接字选项" class="headerlink" title="SO_KEEPALIVE套接字选项"></a>SO_KEEPALIVE套接字选项</h3><p>给一个TCP套接字设置保持存活( keep-alive)选项后,如果2小时内在该套接字的任一方向上都没有数据交换,TCP就自动给对端发送一个保持存活探测分节( keep-alive probe)。这是一个对端必须响应的TCP分节,它会导致以下三种情况之一</p>
<ul>
<li>对端以期望的ACK响应。应用进程得不到通知(因为一切正常)。在又经过仍无动静的时后,TCP将发出另一个探测分节。</li>
<li>对端以RST响应,它告知本端TCP:对端已崩溃且己重新启动。该套接字的待处理错误被置为 ECONNRESET,套接字本身则被关闭。</li>
<li>对端对保持存活探测分节没有任何响应。</li>
</ul>
<p>本选项的功用是检测对端主机是否崩溃或变得不可达(譬如拨号调制解调器连接掉线,电源发生故障,等等)。如果对端进程崩溃,它的TCP将跨连接发送一个FIN,这可以通过调用select很容易地检测到。同时也要认识到,即使对任何保持存活探测分节均无响应(第三种情况),我们也不能肯定对端主机已经崩溃,因而TCP可能会终止一个有效连接。</p>
<p>本选项一般由服务器使用,不过客户也可以使用。服务器使用本选项是因为它们花大部分时间阻塞在等待穿越TCP连接的输入上,也就是说在等待客户的请求。然而如果客户主机连接掉线、电源掉电或系统崩溃,服务器进程将永远不会知道,并将继续等待永远不会到达的输入我们称这种情况为半开连接( half-open connection)。保持存活选项将检测出这些半开连接并终止它们。</p>
<h3 id="SO-LINGER套接字选项"><a href="#SO-LINGER套接字选项" class="headerlink" title="SO_LINGER套接字选项"></a>SO_LINGER套接字选项</h3><p>本选项指定close函数对面向连接的协议(例如TCP和SCTP,但不是UDP)如何操作。默认操作是c1ose立即返回,但是如果有数据残留在套接字发送缓冲区中,系统将试着把这些数据发送给对端。</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275638162436.jpg" alt=""></p>
<p>客户可以设置so_LINGER套接字选项,指定一个正的延滞时间。这种情况下客户的c1ose要到它的数据和FIN已被服务器主机的TCP确认后才返回</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275638674270.jpg" alt=""></p>
<p>然而我们会面临一个问题:在服务器应用进程读剩余数据之前,服务器主机可能崩溃,并且客户应用进程永远不会知道。更糟糕的是，下图展示了当给 SO_LINGER选项设置偏低的延滞时间值时可能发生的现象。</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275640017253.jpg" alt=""></p>
<p>让客户知道服务器已读取其数据的一个方法是改为调用shutdown(并设置它的第二个参数为 SHUT_WR)而不是调用c1ose,并等待对端c1ose连接的当地端(服务器端)。</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275641013574.jpg" alt=""></p>
<h2 id="IPv4套接字选项"><a href="#IPv4套接字选项" class="headerlink" title="IPv4套接字选项"></a>IPv4套接字选项</h2><p>这些套接字选项由IPv4处理,它们的级别(即 getsockopt和 setsockopt函数的第二个参数)为IPPROTO_IP。</p>
<h3 id="IP-HDRINCL套接字选项"><a href="#IP-HDRINCL套接字选项" class="headerlink" title="IP_HDRINCL套接字选项"></a>IP_HDRINCL套接字选项</h3><p>如果本选项是给一个原始IP套接字设置的,那么我们必须为所有在该原始套接字上发送的数据报构造自己的IP首部。一般情况下,在原始套接字上发送的数据报其IP首部是由内核构造的,不过有些应用程序(特别是路由跟踪程序 traceroute)需要构造自己的IP首部以取代IP置于该首部中的某些字段。</p>
<h3 id="IP-OPTIONS套接字选项"><a href="#IP-OPTIONS套接字选项" class="headerlink" title="IP_OPTIONS套接字选项"></a>IP_OPTIONS套接字选项</h3><p>本选项的设置允许我们在IPv4首部中设置IP选项</p>
<h3 id="IP-RECVDSTADDR套接字选项"><a href="#IP-RECVDSTADDR套接字选项" class="headerlink" title="IP_RECVDSTADDR套接字选项"></a>IP_RECVDSTADDR套接字选项</h3><p>本套接字选项导致所收到UDP数据报的且的IP地址由 recvmsg函数作为辅助数据返回</p>
<h3 id="IP-TOS套接字选项"><a href="#IP-TOS套接字选项" class="headerlink" title="IP_TOS套接字选项"></a>IP_TOS套接字选项</h3><p>本套接字选项允许我们为TCP、UDP或SCTP套接字设置IP首部中的服务类型字段</p>
<h2 id="TCP套接字选项"><a href="#TCP套接字选项" class="headerlink" title="TCP套接字选项"></a>TCP套接字选项</h2><p>TCP有两个套接字选项,它们的级别(即 get_sockopt和 set_sockopt函数的第二个参数)为IPPROTO_TCP。</p>
<h3 id="TCP-MAXSEG套接字选项"><a href="#TCP-MAXSEG套接字选项" class="headerlink" title="TCP_MAXSEG套接字选项"></a>TCP_MAXSEG套接字选项</h3><p>本选项允许我们获取或设置TCP连接的最大分节大小(MSS)。返回值是我们的TCP可以发送给对端的最大数据量,它通常是由对端使用SYN分节通告的MSS,除非我们的TCP选择使用个比对端通告的MSS小些的值。如果该值在相应套接字的连接建立之前取得,那么返回值是未从对端收到MSS选项的情况下所用的默认值。</p>
<h3 id="TCP-NODELAY套接字选项"><a href="#TCP-NODELAY套接字选项" class="headerlink" title="TCP_NODELAY套接字选项"></a>TCP_NODELAY套接字选项</h3><p>开启本选项将禁止TCP的 Nagle算法。默认情况下该算法是启动的。</p>
<p>Nagle算法的目的在于减少广域网(wAN)上小分组的数目。该算法指出:如果某个给定连接上有待确认数据( outstanding data),那么原本应该作为用戶写操作之响应的在该连接上立即发送相应小分组的行为就不会发生,直到现有数据被确认为止。这里“小”分组的定义就是小于MSS的任何分组。TCP总是尽可能地发送最大大小的分组, Nagle算法的目的在于防止一个连接在任何时刻有多个小分组待确认。</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275651499834.jpg" alt=""></p>
<h2 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h2><p>与代表“file control”(文件控制)的名字相符,fcntl函数可执行各种描述符控制操作。</p>
<p>fcntl函数提供了与网络编程相关的如下特性:</p>
<ul>
<li>非阻塞式I/O。通过使用F_SETFL命令设置O_NONBLOCK文件状态标志,我们可以把一个套接字设置为非阻塞型。</li>
<li>信号驱动式I/O。通过使用F_SEFL命令设置o_ASYNC文件状态标志,我们可以把一个套接字设置成一旦其状态发生变化,内核就产生一个SIGIO信号。</li>
<li>F_SETOWN命令允许我们指定用于接收SIGIO和SIGURG信号的套接字属主(进程ID或进程组IO)。其中 SIGIO信号是套接字被设置为信号驱动式I/O型后产生的,SIGURG信号是在新的带外数据到达套接字时产生的。F_GETOWN命令返回套接字的当前属主。</li>
</ul>
<h1 id="基本UDP套接字编程"><a href="#基本UDP套接字编程" class="headerlink" title="基本UDP套接字编程"></a>基本UDP套接字编程</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>在使用TCP编写的应用程序和使用UDP编写的应用程序之间存在一些本质差异,其原因在于这两个传输层之间的差别:UDP是无连接不可靠的数据报协议,非常不同于TCP提供的面向连接的可靠字节流。然而相比TCP,有些场合确实更适合使用UDP</p>
<p>下图给出了典型的UDP客户服务器程序的函数调用。客户不与服务器建立连接,而是只管使用sendto函数给服务器发送数据报,其中必须指定目的地(即服务器)的地址作为参数。类似地,服务器不接受来自客户的连接,而是只管调用 recvfrom函数,等待来自客户的某个数据到达</p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275736670682.jpg" alt=""></p>
<h2 id="recvfrom和sendto函数"><a href="#recvfrom和sendto函数" class="headerlink" title="recvfrom和sendto函数"></a>recvfrom和sendto函数</h2><p>这两个函数类似于标准的read和write函数,不过需要三个额外的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags, <span class="keyword">struct</span> sockaddr *from, <span class="keyword">socklen_t</span> *addrlen);</div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *to, <span class="keyword">socklen_t</span> addrlen);</div><div class="line"></div><div class="line"><span class="comment">// Both return: number of bytes read or written if OK, –1 on error</span></div></pre></td></tr></table></figure>
<p>前三个参数<code>sockfd</code>、<code>buff</code>和<code>nbytes</code>等同于read和write函数的三个参数:描述符、指向读入或写出缓冲区的指针和读写字节数</p>
<p>sendto的to参数指向一个含有数据报接收者的协议地址(例如IP地址及端口号)的套接字地址结构,其大小由 addrlen参数指定。 recvfrom的fom参数指向一个将由该函数在返回时填写数据报发送者的协议地址的套接字地址结构,而在该套接字地址结构中填写的字节数则放在addrlen参数所指的整数中返回给调用者。注意, sendto的最后一个参数是一个整数值,而recvfrom的最后一个参数是一个指向整数值的指针(即值-结果参数)。</p>
<h2 id="数据报的丢失"><a href="#数据报的丢失" class="headerlink" title="数据报的丢失"></a>数据报的丢失</h2><p>我们的UDP客户服务器例子是不可靠的。如果一个客户数据报丢失(譬如说,被客户主机与服务器主机之间的某个路由器丢弃),客户将永远阻塞于dg_cli函数中的recvfrom调用,等待一个永远不会到达的服务器应答。类似地,如果客户数据报到达服务器,但是服务器的应答丢失了,客户也将永远阻塞于recvfrom调用。防止这样永久阻塞的一般方法是给客户的recvfrom调用设置一个超时。</p>
<p>但是仅仅给recvfrom调用设置超时并不是完整的解决办法。</p>
<h2 id="UDP的connect函数"><a href="#UDP的connect函数" class="headerlink" title="UDP的connect函数"></a>UDP的connect函数</h2><p>除非套接字已连接,否则异步错误是不会返回到UDP套接字的。我们确实可以给UDP套接字调用 connect(4,3节),然而这样做的结果却与TCP连接大相径庭:没有三路握手过程。内核只是检查是否存在立即可知的错误(例如一个显然不可达的目的地),记录对端的P地址和端口号(取自传递给 connect的套接字地址结构),然后立即返回到调用进程。</p>
<p>对于已连接UDP套接字,与默认的未连接UDP套接字相比,发生了三个变化</p>
<ol>
<li>我们再也不能给输出操作指定目的IP地址和端口号。也就是说,我们不使用sendto,而改用write或send写到已连接UDP套接字上的任何内容都自动发送到由connect指定的协议地址（例如IP地址和端口号）</li>
<li>我们不必使用recvfrom以获悉数据报的发送者,而改用read、recv或recvmsg</li>
<li>由已连接UDP套接字引发的异步错误会返回给它们所在的进程,而未连接UDP套接字不接收任何异步错误。</li>
</ol>
<p><img src="http://data3.liuin.cn/2018-05-29-15275750978867.jpg" alt=""></p>
<p><img src="http://data3.liuin.cn/2018-05-29-15275751182016.jpg" alt=""></p>
<h3 id="给一个UDP套接字多次调用connect"><a href="#给一个UDP套接字多次调用connect" class="headerlink" title="给一个UDP套接字多次调用connect"></a>给一个UDP套接字多次调用connect</h3><p>拥有一个已连接UDP套接字的进程可出于下列两个目的之一再次调用 connect:</p>
<ol>
<li>指定新的IP地址和端口号</li>
<li>断开套接字。</li>
</ol>
<p>第一个目的(即给一个已连接UDP套接字指定新的对端)不同于TCP套接字中 connect的使用:对于TCP套接字, connect只能调用一次。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>当应用进程在一个未连接的UDP套接字上调用sendto时,源自Berkeley的内核暂时连接该套接字,发送数据报,然后断开该连接。在一个未连接的UDP套接字上给两个数据报调用sendto函数于是涉及内核执行下列6个步骤:</p>
<ul>
<li>连接套接字;</li>
<li>输出第一个数据报;</li>
<li>断开套接字连接;</li>
<li>连接套接字;</li>
<li>输出第二个数据报;</li>
<li>断开套接字连接。</li>
</ul>
<p>当应用进程知道自己要给同一目的地址发送多个数据报时,显式连接套接字效率更高。调用 connect后调用两次 write涉及内核执行如下步骤:</p>
<ul>
<li>连接套接字</li>
<li>输出第一个数据报</li>
<li>输出第二个数据报</li>
</ul>
<p>在这种情况下,内核只复制一次含有目的IP地址和端口号的套接字地址结构,相反当调用两次 sendto时,需复制两次。临时连接未连接的UDP套接字大约会耗费每个UDP传输三分之一的开销。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UNIX网络编程必读书籍——《UNIX网络编程卷1》  基本套接字编程 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://www.liuin.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>《STL源码剖析》 笔记</title>
    <link href="https://www.liuin.cn/2018/05/20/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B-%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.liuin.cn/2018/05/20/《STL源码剖析》-笔记/</id>
    <published>2018-05-20T00:52:59.000Z</published>
    <updated>2018-05-29T06:35:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>侯捷老师的《STL源码剖析》可谓是学习STL的经典。在书籍的自序中侯捷老师提到的”我的确认为99.99%的程序员所写的程序，在SGI STL面前都是三流水平“，这让我等菜鸟根本把持不住呀。</p>
<a id="more"></a>
<h1 id="空间配置其（allocator）"><a href="#空间配置其（allocator）" class="headerlink" title="空间配置其（allocator）"></a>空间配置其（allocator）</h1><p>以STL的运用角度而言，空间配置器是最不需要介绍的东西，它总是隐藏在切组件(更具体地说是指容器， container)的背后，默默工作，默默付出。但若以STL的实现角度而言，第一个需要介绍的就是空间配置器，因为整个<strong>STL的操作对象(所有的数值)都存放在容器之内</strong>，而容器一定需要配置空间以置放资料不先掌握空间配置器的原理，难免在阅读其它STL组件的实现时处处遇到挡路石。</p>
<h2 id="空间配置器的标准接口"><a href="#空间配置器的标准接口" class="headerlink" title="空间配置器的标准接口"></a>空间配置器的标准接口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">allocator::value_type</div><div class="line">allocator::pointer</div><div class="line">allocator::const_pointer</div><div class="line">allocator::reference</div><div class="line">allocator::const_reference</div><div class="line">allocator::sieze_type</div><div class="line">allocator::defference_type</div><div class="line"><span class="comment">// 一个嵌套的(nested) class template。 class rebind&lt;U&gt;拥有唯一成员other，那是一个 typedef，代表allocator&lt;U&gt;</span></div><div class="line">allocator::rebind</div><div class="line"><span class="comment">// default constructor</span></div><div class="line">allocator::allocator()</div><div class="line"><span class="comment">// copy constructor</span></div><div class="line">allocator::allocator(<span class="keyword">const</span> allocator&amp;)</div><div class="line"><span class="comment">// 泛化的 copy constructor</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt;allocator::allocator(<span class="keyword">const</span> allocator&lt;U&gt;&amp;)</div><div class="line"><span class="comment">// 默认析构</span></div><div class="line">allocator::~allocator()</div><div class="line"><span class="comment">// 返回某个对象的地址</span></div><div class="line">pointer allocator::address(reference x) <span class="keyword">const</span></div><div class="line"><span class="comment">// 返回某个const对象的地址</span></div><div class="line">const_pointer allocator::address(const_reference x) <span class="keyword">const</span></div><div class="line"><span class="comment">// 配置空间，足以存储n个T对象</span></div><div class="line">pointer allocator::allocate(size_type n， <span class="keyword">const</span> <span class="keyword">void</span>* = <span class="number">0</span>)</div><div class="line"><span class="comment">// 归还先前配置的空间</span></div><div class="line"><span class="keyword">void</span> allocator::deallocate(pointer p， size_type n)</div><div class="line"><span class="comment">// 返回可成功配置的最大量</span></div><div class="line">size_type allocator::max_size() <span class="keyword">const</span></div><div class="line"><span class="comment">// 等同于 new(const void*) p) T(x)</span></div><div class="line"><span class="keyword">void</span> allocator::construct(pointer p， <span class="keyword">const</span> T&amp; x)</div><div class="line"><span class="comment">// 等同于 p-&gt;~T()</span></div><div class="line"><span class="keyword">void</span> allocator::destory(pointer p)</div></pre></td></tr></table></figure>
<h2 id="具备次配置力-sub-allocation-的SGI空间配置器"><a href="#具备次配置力-sub-allocation-的SGI空间配置器" class="headerlink" title="具备次配置力(sub-allocation)的SGI空间配置器"></a>具备次配置力(sub-allocation)的SGI空间配置器</h2><p>SGI STI的配置器与众不同，也与标准规范不同，其名称是a1loc而非allocator，而且不接受任何参数。</p>
<h3 id="SGI的标准空间配置器，std-allocator"><a href="#SGI的标准空间配置器，std-allocator" class="headerlink" title="SGI的标准空间配置器，std::allocator"></a>SGI的标准空间配置器，std::allocator</h3><p>虽然SGI也定义有一个符合部分标准、名为allocator的配置器，但SGI自己从未用过它，也不建议我们使用。主要原因是效率不佳，只把C++的<code>::operator new</code>和<code>::operator delete</code>做一层薄薄的包装而已。</p>
<h3 id="SGI特殊的空间配置器，std-alloc"><a href="#SGI特殊的空间配置器，std-alloc" class="headerlink" title="SGI特殊的空间配置器，std::alloc"></a>SGI特殊的空间配置器，std::alloc</h3><p>一般而言，我们所习惯的C++内存配置操作和释放操作是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Foo &#123; ... &#125;;</div><div class="line"></div><div class="line">Foo* pf = <span class="keyword">new</span> Foo;</div><div class="line"><span class="keyword">delete</span> pf;</div></pre></td></tr></table></figure>
<p>这其中的new算式内含两阶段操作(1)调用:: operator new配置内存;(2)调用Foo::Foo()构造对象内容。<br>delete算式也内含两阶段操作:(1)调用Foo::~FOO()将对象析构:(2)调用::operator delete释放内存</p>
<p>为了精密分工， STL allocator决定将这两阶段操作区分开来。内存配置操作由a11c:allocate()负责，内存释放操作由alloc::deallocate()负责对象构造操作由::construct()负责，对象析构操作由::destroy()负责。</p>
<p>配置器定义在<memory>中，SGI<memory>的主要组成如下：</memory></memory></p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270395375460.jpg" alt=""></p>
<h3 id="构造和析构基本工具-construct-和-destroy"><a href="#构造和析构基本工具-construct-和-destroy" class="headerlink" title="构造和析构基本工具: construct()和 destroy()"></a>构造和析构基本工具: construct()和 destroy()</h3><p><img src="https://data2.liuin.cn/2018-05-23-15270396596949.jpg" alt=""></p>
<h3 id="空间的配置与释放"><a href="#空间的配置与释放" class="headerlink" title="空间的配置与释放"></a>空间的配置与释放</h3><p>对象构造前的空间配置和对象析构后的空间释放，由<stla1loc.h>负责，SGI对此的设计哲学如下:</stla1loc.h></p>
<ul>
<li>向 system heap要求空间</li>
<li>考虑多线程( multi-threads)状态</li>
<li>考虑内存不足时的应变措施</li>
<li>考虑过多“小型区块”可能造成的内存碎片( fragment)问题</li>
</ul>
<p>考虑到小型区块所可能造成的内存破碎问题，SGI设计了<strong>双层级配置器</strong>：</p>
<p>第一级配置器直接使用malloc()和free()，第二级配置器则视情况采用不同的策略:当配置区块超过128 bytes时，视之为“足够大”，便调用第一级配置器;<strong>当配置区块小于128 bytes时，视之为“过小”，为了降低额外负担，便采用复杂的memory pool整理方式，而不再求助于第一级配置器</strong>。整个设计究竟只开放第一级配置器，或是同时开放第二级配置器</p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270402949330.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-23-15270403004835.jpg" alt=""></p>
<h3 id="第一级配置器"><a href="#第一级配置器" class="headerlink" title="第一级配置器"></a>第一级配置器</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">template &lt;int inst&gt;</div><div class="line">class __malloc_alloc_template &#123;</div><div class="line">private:</div><div class="line">//malloc调用内存不足时调用函数</div><div class="line">static void *oom_malloc(size_t);</div><div class="line">//realloc调用内存不足时调用函数</div><div class="line">static void *oom_realloc(void *, size_t);</div><div class="line">//错误处理函数，类似C++的set_new_handler，默认值为０，如果不设置，则内存分配失败时，返回THROW_BAD_ALLOC</div><div class="line">#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG</div><div class="line">    static void (* __malloc_alloc_oom_handler)();</div><div class="line">#endif</div><div class="line">public:</div><div class="line">static void * allocate(size_t n)</div><div class="line">&#123;</div><div class="line">    void *result = malloc(n);	第一级配置器直接使用malloc分配内存</div><div class="line">    if (0 == result) result = oom_malloc(n);//如果分配失败，则调用oom_malloc()</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line">static void deallocate(void *p, size_t /* n */)</div><div class="line">&#123;</div><div class="line">    free(p);	//第一级配置器用free回收内存</div><div class="line">&#125;</div><div class="line">static void * reallocate(void *p, size_t /* old_sz */, size_t new_sz)</div><div class="line">&#123;</div><div class="line">    void * result = realloc(p, new_sz);	//第一级配置器用reallocate重分配内存</div><div class="line">    if (0 == result) result = oom_realloc(p, new_sz);／／分配失败，调用oom_realloc分配</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line">// 设置分配错误处理函数，用于在oom_malloc和oom_realloc中使用</div><div class="line">static void (* set_malloc_handler(void (*f)()))()</div><div class="line">&#123;</div><div class="line">    void (* old)() = __malloc_alloc_oom_handler;</div><div class="line">    __malloc_alloc_oom_handler = f;</div><div class="line">    return(old);</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">template &lt;int inst&gt;</div><div class="line">void * __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n)</div><div class="line">&#123;</div><div class="line">    void (* my_malloc_handler)();//声明一个函数指针，用于赋值 __malloc_alloc_oom_handler</div><div class="line">    void *result;//返回的内存指针</div><div class="line">    for (;;) &#123;	// 不断尝试释放内存，分配，再释放，再分配...</div><div class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</div><div class="line">        if (0 == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;//为设置处理函数时，抛出错误</div><div class="line">        (*my_malloc_handler)();		// 调用处理函数，尝试释放内存</div><div class="line">        result = malloc(n);			// 再重新分配内存。</div><div class="line">        if (result) return(result);//如果分配成功，返回指针</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">template &lt;int inst&gt;</div><div class="line">void * __malloc_alloc_template&lt;inst&gt;::oom_realloc(void *p, size_t n)</div><div class="line">&#123;</div><div class="line">    void (* my_malloc_handler)();</div><div class="line">    void *result;</div><div class="line">    for (;;) &#123;	// 不断尝试释放内存，分配，再释放，再分配...</div><div class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</div><div class="line">        if (0 == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;////为设置处理函数时，抛出错误</div><div class="line">        (*my_malloc_handler)();	//  调用处理函数，尝试释放内存</div><div class="line">        result = realloc(p, n);	// 再重新分配内存。</div><div class="line">        if (result) return(result);////如果分配成功，返回指针</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一级配置器以malloc(),free(), realloc()等C函数执行实际的内存配置、释放、重配置操作,并实现出类似C++ new-handler 的机制。所谓C++ new handler机制是,你可以要求系统在内存配置需求无法被满足时,调用一个你所指定的函数。</p>
<p>SGI第一级配置器的allocate()和 realloc()都是在调用ma11oc()和rea11oc()不成功后,改调用 oom_ma11oc()和oom_realloc()。后两者都有内循环,不断调用“内存不足处理例程”,期望在某次调用之后,获得足够的内存而圆满完成任务。</p>
<h3 id="第二级配置器"><a href="#第二级配置器" class="headerlink" title="第二级配置器"></a>第二级配置器</h3><p>第二级配置器多了一些机制,避免太多小额区块造成内存的碎片。小额区块带来的其实不仅是内存碎片,配置时的额外负担(overhead)也是一个大问题。额外负担永远无法避免,毕竟系统要靠这多出来的空间来管理内存。但是区块愈小,额外负担所占的比例就愈大,愈显得浪费</p>
<p>SGI第二级配置器的做法是,如果区块够大,超过128 bytes时,就移交第级配置器处理。当区块小于128 bytes时,则以内存池( memory pool)管理,此法又称为次层配置(sub-allocation):每次配置一大块内存,并维护对应之自由链表(free-list)。下次若再有相同大小的内存需求,就直接从free-lists中拨出。如果客端释还小额区块,就由配置器回收到free-lists中——是的,别忘了,配置器除了负责配置,也负责回收。</p>
<p>为了方便管理,SGl第二级配置器会主动将任何小额区块的内存<strong>需求量上调至8的倍数</strong>(例如客端要求30 bytes,就自动调整为32 bytes)并维护16个free-lists,各自管理大小分别为8,16,24,32,40,48,56,64,72,80,88,96,104,l12,120,128 bytes的小额区块。 </p>
<p>free-lists的节点结构如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> obj &#123;</div><div class="line">      <span class="keyword">union</span> obj * free_list_link;<span class="comment">//指向下一个内存的地址</span></div><div class="line">      <span class="keyword">char</span> client_data[<span class="number">1</span>];    <span class="comment">//内存的首地址</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><img src="https://data2.liuin.cn/2018-05-23-15270421196298.jpg" alt=""></p>
<h1 id="迭代器概念与traits编程技法"><a href="#迭代器概念与traits编程技法" class="headerlink" title="迭代器概念与traits编程技法"></a>迭代器概念与traits编程技法</h1><p>在设计模式中有一种迭代器模式，其定义如下：提供一种方法，使之能够依序巡访某个聚合物(容器)所含的各个元素，而又无需暴露该聚合物的内部表述方式</p>
<h2 id="迭代器设计思维——STL关键所在"><a href="#迭代器设计思维——STL关键所在" class="headerlink" title="迭代器设计思维——STL关键所在"></a>迭代器设计思维——STL关键所在</h2><p>STL的中心思想在于:将数据容器( containers)和算法 algorithms)分开，彼此独立设计，最后再以一帖胶着剂将它们撮合在一起。容器和算法的泛型化，从技术角度来看并不困难，C++的class templates和 function templates可分别达成目标。如何设计出两者之间的良好胶着剂，才是大难题</p>
<h2 id="迭代器是一种smart-pointer"><a href="#迭代器是一种smart-pointer" class="headerlink" title="迭代器是一种smart pointer"></a>迭代器是一种smart pointer</h2><p>迭代器是一种行为类似指针的对象，而指针的各种行为中最常见也最重要的便是内容提领(dereference)和成员访问( member access)，因此，迭代器最重要的编程工作就是对 operator*和 operator-&gt;进行重载( overloading)工作。</p>
<p>在设计实现每一个容器的迭代器的时候都会暴露许多这些容器的一些实现细节的东西，要设计出 LIstitem，首先必须对List的实现细节有非常丰富的了解。既然这无可避免，干脆就把迭代器的开发工作交给List的设计者好了，如此一来，所有实现细节反而得以封装起来不被使用者看到。<strong>这正是为什么每一种STL容器都提供有专属迭代器的缘故</strong></p>
<h2 id="迭代器相应的型别"><a href="#迭代器相应的型别" class="headerlink" title="迭代器相应的型别"></a>迭代器相应的型别</h2><p>迭代器中相应的型别之一是迭代器所指之物的型别</p>
<p>迭代器相应型别(associated types)不只是“迭代器所指对象的型别”一种而已。根据经验，最常用的相应型别有五种，然而并非任何情况下任何一种都可利用上述的 template参数推导机制来取得.我们需要更全面的解法</p>
<h1 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h1><h2 id="容器的概观与分类"><a href="#容器的概观与分类" class="headerlink" title="容器的概观与分类"></a>容器的概观与分类</h2><p>研究数据的特定排列方式，以利于搜寻或排序或其它特殊目的，这一专门学科我们称为数据结构( Data Structures)。大学信息类相关教育里面，与编程最有直接关系的科目，首推数据结构与算法( Algorithms)。几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。STL容器即是将运用最广的一些数据结构实现出来</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267795512022.jpg" alt=""></p>
<blockquote>
<p>序列式容器</p>
</blockquote>
<p>所谓序列式容器，其中的<strong>元素都可序( ordered)，但未必有序( sorted)</strong>。C++语言本身提供了一个序列式容器 array，STL另外再提供 vector， list， deque， stack， queue， priority-queue等等序列式容器。其中 stack和 queue由于只是将 deque改头换面而成，技术上被归类为一种配接器( adapter)</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="vector-概述"><a href="#vector-概述" class="headerlink" title="vector 概述"></a>vector 概述</h3><p>vector的数据安排以及操作方式，与 array非常相似。两者的唯一差别在于空间的运用的灵活性。 array是静态空间，一旦配置了就不能改变，如果需要更多的空间需要用户自己解决。vector是动态空间，随着元素的加人，它的内部机制会自行扩充空间以容纳新元素。因此， vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必因为害怕空间不足而开始就要求一个大块头 array了，我们可以安心使用 vector，吃多少用多少</p>
<h3 id="vector-迭代器"><a href="#vector-迭代器" class="headerlink" title="vector 迭代器"></a>vector 迭代器</h3><p>vector维护的是一个连续线性空间，所以不论其元素型别为何，<strong>普通指针都可以作为 vector的迭代器而满足所有必要条件</strong>，因为 vector迭代器所需要的操作行为普通指针天生就具备。 vector支持随机存取，而普通指针正有着这样的能力。所以， vector提供的是 Random Access Iterators。</p>
<h3 id="vector-的数据结构"><a href="#vector-的数据结构" class="headerlink" title="vector 的数据结构"></a>vector 的数据结构</h3><p>vector所采用的数据结构非常简单:线性连续空间。它以两个迭代器 start和 finish分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器end_of_storage指向整块连续空间(含备用空间)的尾端</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T， <span class="keyword">class</span> Alloc = alloc&gt;</div><div class="line"><span class="keyword">class</span> <span class="built_in">vector</span>&#123;</div><div class="line">...</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    iterator start;</div><div class="line">    iterator finish;</div><div class="line">    iterator end_of_storage;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了降低空间配置时的速度成本， vector实际配置的大小可能比客户端需求量更大一些，以备将来可能的扩充。这便是容量( capacity)的观念。换句话说个 vector的容量永远大于或等于其大小。一旦容量等于大小，便是满载，下次再有新增元素，整个 vector就得另觅居所</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267802557974.jpg" alt=""></p>
<h3 id="vector-的构造和内存管理"><a href="#vector-的构造和内存管理" class="headerlink" title="vector 的构造和内存管理"></a>vector 的构造和内存管理</h3><p>当我们以 push_back()将新元素插入于 vector尾端时，该函数首先检查是否还有备用空间，如果有就直接在备用空间上构造元素，并调整迭代器 finish，使vector变大。如果没有备用空间了，就扩充空间(重新配置、移动数据、释放原空间)</p>
<p>注意，所谓动态增加大小，并不是在原空间之后接续新空间(因为无法保证原空间之后尚有可供配置的空间)，而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此对 vector的任何操作，<strong>一旦引起空间重新配置，指向原 vector的所有迭代器就都失效了</strong>。这是程序员易犯的一个错误，务需小心</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="list-概述"><a href="#list-概述" class="headerlink" title="list 概述"></a>list 概述</h3><p>相较于vector的连续线性空间，list就显得复杂许多，它的好处是每次插人或删除一个元素，就配置或释放一个元素空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素移除，list永远是常数时间。</p>
<p>list和 vector是两个最常被使用的容器。什么时机下最适合使用哪一种容器，必须视元素的多寡、元素的构造复杂度、元素存取行为的特性而定。</p>
<h3 id="list的节点-node"><a href="#list的节点-node" class="headerlink" title="list的节点(node)"></a>list的节点(node)</h3><p>list的节点是一个典型的双向链表的结构</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267809077014.jpg" alt=""></p>
<h3 id="list的迭代器"><a href="#list的迭代器" class="headerlink" title="list的迭代器"></a>list的迭代器</h3><p>list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在储存空间中连续存在。list迭代器必须有能力指向list的节点，并有能力进行正确的递增、递减、取值、成员存取等操作。</p>
<p>由于STL list是一个双向链表(double linked-ist)，迭代器必须具备前移后移的能力，所以list提供的是 Bidirectional iteratorslist</p>
<p>有一个重要性质:插入操作( insert)和接合操作( splice)都不会造成原有的list迭代器失效。这在 vector是不成立的，因为 vector的插人操作可能造成内存的重新配置，导致原有的迭代器全部失效。甚至list的元素删除操作( erase)，也只有“指向被删除元素”的那个迭代器失效，其它迭代器不受任何影响</p>
<h3 id="list的数据结构"><a href="#list的数据结构" class="headerlink" title="list的数据结构"></a>list的数据结构</h3><p>SGL list不仅是一个双向链表，而且还是一个环状双向链表。所以它只需要个指针，便可以完整表现整个链表</p>
<p>如果让指针node指向刻意置于尾端的一个空白节点，node便能符合STL对于“前闭后开”区间的要求，成为1ast迭代器，如图所示</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267812961833.jpg" alt=""></p>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><h3 id="deque概述"><a href="#deque概述" class="headerlink" title="deque概述"></a>deque概述</h3><p>vector是单向开口的连续线性空间， deque则是一种双向开口的连续线性空间。所谓双向开口，意思是<strong>可以在头尾两端分别做元素的插入和删除操作</strong>。 vector当然也可以在头尾两端进行操作(从技术观点)，但是其头部操作效率奇差，无法被接受</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267815267741.jpg" alt=""></p>
<p>deque和 vector的最大差异，一在于deque允许于常数时间内对起头端进行元素的插入或移除操作，二在于 deque没有所谓容量( capacity)观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。换句话说，像 vector那样“因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在 deque是不会发生的。也因此， deque没有必要提供所谓的空间保留( reserve)功能</p>
<p>虽然 deque也提供 Ramdon Access iterator，但<strong>它的迭代器并不是普通指针，其复杂度和 vector不可以道里计</strong>(稍后看到源代码，你便知道)，这当然影响了各个运算层面。因此，除非必要，我们应尽可能选择使用 vector而非 deque</p>
<h3 id="deque的中控器"><a href="#deque的中控器" class="headerlink" title="deque的中控器"></a>deque的中控器</h3><p>deque是连续空间(至少逻辑上看来如此)，连续线性空间总令我们联想到array或 vector。 array无法成长， vector虽可成长，却只能向尾端成长，而且其所谓成长原是个假象，事实上是(1)另觅更大空间;(2)将原数据复制过去;(3)释放原空间三部曲。如果不是 <strong>vector每次配置新空间时都有留下一些余裕，其成长”假象所带来的代价将是相当高昂</strong></p>
<p>deque系由一段一段的定量连续空间构成。一旦有必要在 deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个 deque的头端或尾端deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象并提供随机存取的接口·避开了“重新配置、复制、释放”的轮回，<strong>代价则是复杂的迭代器架构</strong></p>
<p>受到分段连续线性空间的字面影响，我们可能以为 deque的实现复杂度和vector相比虽不中亦不远矣，其实不然。主要因为，既日<strong>分段连续线性空间，就必须有中央控制，而为了维持整体连续的假象，数据结构的设计及迭代器前进后退等操作都颇为繁琐</strong>。 deque的实现代码分量远比 vector或list都多得多</p>
<p>deque采用一块所谓的mqp(注意，不是STL的map容器)作为主控。这里所谓map是一小块连续空间，其中每个元素(此处称为一个节点，node)都是指针，指向另一段(较大的)连续线性空间，称为缓冲区。缓冲区才是 deque的储存空间主体。 </p>
<p>把令人头皮发麻的各种型别定义(为了型别安全，那其实是有必要的)整理下，我们便可发现，map其实是一个T**，也就是说它是一个指针，所指之物又是个指针，指向型别为T的一块空间，如图所示</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267828260370.jpg" alt=""></p>
<h3 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h3><p>deque是分段连续空间。维持其“整体连续”假象的任务，落在了迭代器的operator++和operator–两个运算子身上</p>
<p>让我们思考一下， deque迭代器应该具备什么结构。首先，它必须能够<strong>指出分段连续空间(亦即缓冲区)在哪里，其次它必须能够判断自己是否已经处于其所在缓冲区的边缘</strong>，如果是，一旦前进或后退时就必须跳跃至下一个或上一个缓冲区为了能够正确跳跃， deque必须<strong>随时掌握管控中心</strong>(map)。</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267830496256.jpg" alt=""></p>
<h3 id="deque的数据结构"><a href="#deque的数据结构" class="headerlink" title="deque的数据结构"></a>deque的数据结构</h3><p>deque除了维护一个先前说过的指向map的指针外，也维护 start，fini两个迭代器，分别指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素(的下一位置)。此外，它当然也必须记住目前的mqp大小。因为一旦mqp所提供的节点不足，就必须重新配置更大的一块map</p>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><h3 id="stack-概述"><a href="#stack-概述" class="headerlink" title="stack 概述"></a>stack 概述</h3><p>stack是一种先进后出( First In last out，FILO)的数据结构。它只有一个出口，形式如图4-18所示。 stack允许新增元素、移除元素、取得最顶端元素。但除了最顶端外，没有任何其它方法可以存取 stack的其它元素。换言之， stack不允许有遍历行为</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267835939355.jpg" alt=""></p>
<h3 id="stack-定义完整列表"><a href="#stack-定义完整列表" class="headerlink" title="stack 定义完整列表"></a>stack 定义完整列表</h3><p>以某种既有容器作为底部结构，将其接口改变，使之符合“先进后出”的特性，形成一个 stack，是很容易做到的， deque是双向开口的数据结构，若以dequ为底部结构并封闭其头端开口，便轻而易举地形成了一个 stack。因此， SGI STI便以 deque作为缺省情况下的 stack底部结构， stack的实现因而非常简单，源代码十分简短，本处完整列出</p>
<p>由于 stack系以底部容器完成其所有工作，而具有这种“修改某物接口，形成另一种风貌”之性质者，称为 adapter(配接器)，因此STL stack往往不被归类为 container(容器)，而被归类为 container adapter</p>
<h3 id="stack-没有迭代器"><a href="#stack-没有迭代器" class="headerlink" title="stack 没有迭代器"></a>stack 没有迭代器</h3><p>stack所有元素的进出都必须符合“先进后出”的条件，只有 stack顶端的元素，才有机会被外界取用。 stack不提供走访功能，也不提供迭代器</p>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h3 id="queue概述"><a href="#queue概述" class="headerlink" title="queue概述"></a>queue概述</h3><p>queue是一种先进先出( First In First Out，FIFO)的数据结构。它有两个出口。 queue允许新增元素、移除元素、从最底端加入元素、取得最顶端元素。但除了最底端可以加入、最顶端可以取出外，没有任何其它方法可以存取 queue的其它元素。换言之， queue不允许有遍历行为。</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267838406632.jpg" alt=""></p>
<h3 id="queue定义完整列表"><a href="#queue定义完整列表" class="headerlink" title="queue定义完整列表"></a>queue定义完整列表</h3><p>以某种既有容器为底部结构，将其接口改变，使其符合“先进先出”的特性形成一个 queue，是很容易做到的. deque是双向开口的数据结构，若以 deque为底部结构并封闭其底端的出口和前端的入口，便轻而易举地形成了一个 queue。因此， SGI STL便以 deque作为缺省情况下的 queue底部结构。</p>
<h3 id="queue没有迭代器"><a href="#queue没有迭代器" class="headerlink" title="queue没有迭代器"></a>queue没有迭代器</h3><p>queue所有元素的进出都必须符合“先进先出”的条件，只有 queue顶端的元素，才有机会被外界取用。 queue不提供遍历功能，也不提供迭代器</p>
<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><h3 id="heap概述"><a href="#heap概述" class="headerlink" title="heap概述"></a>heap概述</h3><p>heap并不归属于STL容器组件，它是个幕后英雄，扮演 priority queue的助手。顾名思义， priority queue允许用户以任何次序将任何元素推入容器内，但取出时一定是从优先权最高(也就是数值最高)的元素开始取。 binary max heap正是具有这样的特性，适合作为 priority queue的底层机制</p>
<p>如果使用list作为 priority queue的底层机制，元素插入操作可享常数时间。但是要找到list中的极值，却需要对整个list进行线性扫描。我们也可以改变做法，让元素插入前先经过排序这一关，使得list的元素值总是由小到大(或由大到小)，但这么一来，收之东隅却失之桑榆:虽然取得极值以及元素删除操作达到最高效率，可元素的插人却只有线性表现</p>
<p>比较麻辣的做法是以 binary search tree作为 prlorltyqueue的底层机制。这么一来，元素的插入和极值的取得就有O(logN)的表现但杀鸡用牛刀，未免小题大做，一来 binary search tree的输人需要足够的随机性，二来 binary search tree并不容易实现。 </p>
<p>比较适合的是binary heap的方案，所谓 binary heap就是一种 complete binary tree(完全二叉树)，也就是说，整棵 binary tree除了最底层的叶节点之外，是填满的，而最底层的叶节点(s)由左至右又不得有空隙。</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267842482184.jpg" alt=""></p>
<p>这么一来，我们需要的工具就很简单了:一个 array和一组heap算法(用来插入元素、删除元素、取极值，将某一整组数据排列成一个heap)</p>
<h3 id="heap算法"><a href="#heap算法" class="headerlink" title="heap算法"></a>heap算法</h3><h4 id="push-heap-算法"><a href="#push-heap-算法" class="headerlink" title="push_heap 算法"></a>push_heap 算法</h4><p><img src="https://data2.liuin.cn/2018-05-20-15267844079830.jpg" alt=""></p>
<h4 id="pop-heap-算法"><a href="#pop-heap-算法" class="headerlink" title="pop_heap 算法"></a>pop_heap 算法</h4><p><img src="https://data2.liuin.cn/2018-05-20-15267844125899.jpg" alt=""></p>
<h4 id="sort-heap-算法"><a href="#sort-heap-算法" class="headerlink" title="sort_heap 算法"></a>sort_heap 算法</h4><p>堆排序思想，不断对heap进行pop操作，达到排序效果</p>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><h3 id="priority-queue概述"><a href="#priority-queue概述" class="headerlink" title="priority_queue概述"></a>priority_queue概述</h3><p>顾名思义， priority_queue是一个拥有权值观念的 queue，它允许加人新元素、移除旧元素、审视元素值等功能。由于这是一个 queue，所以只允许在底端加入元素，并从顶端取出元素，除此之外别无其它存取元素的途径</p>
<p>priority_queue带有权值观念，其内的元素并非依照被推入的次序排列，而是自动依照元素的权值排列(通常权值以实值表示)。权值最高者，排在最前面</p>
<p>缺省情况下 priority_queue系利用一个max-heap完成，后者是一个以vector表现的 complete binary tree。max-heap可以满足priority_queue所需要的“依权值高低自动递增排序”的特性。</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267846191674.jpg" alt=""></p>
<h3 id="priority-queue定义完整列表"><a href="#priority-queue定义完整列表" class="headerlink" title="priority_queue定义完整列表"></a>priority_queue定义完整列表</h3><p>由于 priority-queue完全以底部容器为根据，再加上heap处理规则，所以其实现非常简单。缺省情况下是以 vector为底部容器。</p>
<p>queue以底部容器完成其所有工作。具有这种“修改某物接口，形成另一种风貌”之性质者，称为 adapter(配接器)，因此， STL prior1ty_ queue往往不被归类为 container(容器)，而被归类为 container adapter</p>
<h3 id="priority-queue没有迭代器"><a href="#priority-queue没有迭代器" class="headerlink" title="priority_queue没有迭代器"></a>priority_queue没有迭代器</h3><p>priority-queue的所有元素，进出都有一定的规则，只有 queue顶端的元素(权值最高者)，才有机会被外界取用。 priority_queue不提供遍历功能，也不提供迭代器。</p>
<h1 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h1><p>标准的STL关联式容器分为set(集合)和map(映射表)两大类，以及这两大类的衍生体 multiset(多键集合)和multimap(多键映射表)。这些容器的底层机制均以RB-tree(红黑树)完成。RB-tree也是一个独立容器，但并不开放给外界使用</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15268607936529.jpg" alt=""></p>
<p>所谓关联式容器，观念上类似关联式数据库(实际上则简单许多):每笔数据(每个元素)都有一个键值(key)和一个实值( value)。当元素被插人到关联式容器中时，容器内部结构(可能是RB-tree，也可能是hash-tab1e)便依照其键值大小，以某种特定规则将这个元素放置于适当位置.关联式容器没有所谓头尾(只有最大元素和最小元素)</p>
<h2 id="RB-tree（红黑树）"><a href="#RB-tree（红黑树）" class="headerlink" title="RB-tree（红黑树）"></a>RB-tree（红黑树）</h2><p>AVL-tree之外，另一个颇具历史并被广泛运用的平衡二又搜索树是RB-tree(红黑树)。所谓RB-tree，不仅是一个二叉搜索树，而且必须满足以下规则</p>
<ol>
<li>每个节点不是红色就是黑色</li>
<li>根节点为黑色</li>
<li>如果节点为红，其子节点必须为黑</li>
<li>任一节点至NULL(树尾端)的任何路径，所含之黑节点数必须相同</li>
</ol>
<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p>当插入一个新节点的时候，就会导致红黑树上面的规则被破坏。这个时候就要进行调整，其中包括了四种情况：</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15268627862296.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-21-15268628337631.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-21-15268628547016.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-21-15268628574449.jpg" alt=""></p>
<h3 id="RB-tree的元素操作"><a href="#RB-tree的元素操作" class="headerlink" title="RB-tree的元素操作"></a>RB-tree的元素操作</h3><p>RB-tree提供两种插入操作:insert_unique()和 insert_equal()，前者表示被插入节点的键值(key)在整棵树中必须独一无二(因此，如果树中已存在相同的键值，插入操作就不会真正进行)，后者表示被插入节点的键值在整棵树中可以重复，因此，无论如何插入都会成功(除非空间不足导致配置失败)。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set的特性是，所有元素都会根据元素的键值自动被排序。set的元素不像map那样可以同时拥有实值( value)和键值(key)，set元素的键值就是实值实值就是键值。<strong>set不允许两个元素有相同的键值</strong></p>
<p>我们可以通过set的迭代器改变set的元素值吗?不行，因为set元素值就是其键值，关系到set元素的排列规则。如果任意改变set元素值，会严重破坏set组织。set iterators是一种constant iterators(相对于 mutable iterators)</p>
<p>set拥有与1ist相同的某些性质:当<strong>客户端对它进行元素新增操作( insert)或删除操作( erase)时，操作之前的所有迭代器，在操作完成之后都依然有效</strong>。当然，被删除的那个元素的迭代器必然是个例外</p>
<p>由于RB-tree是一种平衡二叉搜索树，自动排序的效果很不错，所以标准的STL set即以RB-tree为底层机制。又由于set所开放的各种操作接口，RB-tree也都提供了，所以几乎所有的set操作行为，都只是转调用RB→tree的操作行为而已</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map的特性是，所有元素都会根据元素的键值自动被排序。map的所有元素都是pair，同时拥有实值( value)和键值(key)。pair的第一元素被视为键值第二元素被视为实值.map不允许两个元素拥有相同的键值。</p>
<p>可以通过map的迭代器修改value的值，但是不能更改key的值，因为修改key会破坏map的组织结构。因此， map iterators既不是一种constant iterators，也不是一种 mutable iterators</p>
<p>map拥有和1ist相同的某些性质:当客户端对它进行元素新增操作或删除操作时，操作之前的所有迭代器，在操作完成之后都依然有效。当然，被删除的那个元素的迭代器必然是个例外</p>
<p>map底层以RB-tree为实现机制，主要调用的是底层RB-tree的各种接口</p>
<h2 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h2><p>multiset的特性以及用法和set完全相同，唯一的差别在于它允许键值重复，因此它的插入操作采用的是底层机制RB-tree的 insert_equa1()而非insert unique()。</p>
<h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h2><p>multimap的特性以及用法与map完全相同，唯一的差别在于它允许键值重复，因此它的插入操作采用的是底层机制RB-tree的 insert_equal()而非insert_unique()。</p>
<h2 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h2><p>二叉搜索树具有对数平均时间(logarithmic average time)的表现，但这样的表现构造在一个假设上:输入数据有足够的随机性。这一节要介绍一种名为hashtable(散列表)的数据结构，这种结构在插人、删除、搜寻等操作上也具有“常数平均时间”的表现，而且这种表现是以统计为基础，不需仰赖输入元素的随机性</p>
<h3 id="hashtable-概述"><a href="#hashtable-概述" class="headerlink" title="hashtable 概述"></a>hashtable 概述</h3><p>hash table可提供对任何有名项( named item)的存取操作和删除操作。由于操作对象是有名项，所以 hash table也可被视为一种字典结构( dictionary)这种结构的用意在于提供常数时间之基本操作，就像 stack或 queue那样。乍听之下这几乎是不可能的任务，因为约束制条件如此之少，而元素个数增加，搜寻操作必定耗费更多时间</p>
<p>通过hash function来进行key和index之间的转换。但是使用hash function会产生冲突的问题</p>
<p>解决冲突的方法主要有以下几种：</p>
<ol>
<li>线性探测法，产生冲突的时候向下一个地址进行存储</li>
<li>二次探测法，产生冲突的时候以H+1^2，H+2^2…的形式进行存储</li>
<li>开链法，在表格中维护一个list</li>
</ol>
<h3 id="hashtable-的buckets与nodes"><a href="#hashtable-的buckets与nodes" class="headerlink" title="hashtable 的buckets与nodes"></a>hashtable 的buckets与nodes</h3><p>下图是以开链法( separate chaining)完成 hash table的图形表述。为了解说 SGI STL源代码，我遵循SGI的命名，称 hash table表格内的元素为桶子( bucket)，此名称的大约意义是，表格内的每个单元，涵盖的不只是个节点(元素)，甚且可能是一“桶”节点</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15268653336402.jpg" alt=""></p>
<h2 id="hash-set"><a href="#hash-set" class="headerlink" title="hash_set"></a>hash_set</h2><p>STL set多半以RB-tree为底层机制。SGI则是在STL标准规格之外另又提供了一个所谓的hash_set，以 hash table为底层机制。由于hash_set所供应的操作接口hashtable都提供了，所以几乎所有的hash_set操作行为，都只是转调用hashtab1e的操作行为而已</p>
<p>运用set，为的是能够快速搜寻元素。这一点，不论其底层是RB-tree或是hash table，都可以达成任务。但是请注意，<strong>RB-tree有自动排序功能而 hashtable没有，反应出来的结果就是，set的元素有自动排序功能而hash_set没有</strong>。</p>
<h2 id="hash-map"><a href="#hash-map" class="headerlink" title="hash_map"></a>hash_map</h2><p>SGI在STL标准规格之外，另提供了一个所谓的 hash_map，以 hash table为底层机制。由于 hash_map所供应的操作接口， hash table都提供了，所以几乎所有的hash_map操作行为，都只是转调用 hashtable的操作行为而已。</p>
<p>运用map，为的是能够根据键值快速搜寻元素。这一点，不论其底层是RB-tree或是 hash table，都可以达成任务。但是请注意，RB-tree有自动排序功能而hashtable没有，反应出来的结果就是，<strong>map的元素有自动排序功能而hash_map没有</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;侯捷老师的《STL源码剖析》可谓是学习STL的经典。在书籍的自序中侯捷老师提到的”我的确认为99.99%的程序员所写的程序，在SGI STL面前都是三流水平“，这让我等菜鸟根本把持不住呀。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="STL" scheme="https://www.liuin.cn/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>《UNIX网络编程卷1》笔记 简介部分</title>
    <link href="https://www.liuin.cn/2018/05/15/%E3%80%8AUNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B71%E3%80%8B%E7%AC%94%E8%AE%B0%20%E7%AE%80%E4%BB%8B%E9%83%A8%E5%88%86/"/>
    <id>https://www.liuin.cn/2018/05/15/《UNIX网络编程卷1》笔记 简介部分/</id>
    <published>2018-05-15T12:37:20.000Z</published>
    <updated>2018-05-21T13:35:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>UNIX网络编程必读书籍——《UNIX网络编程卷1》  简介部分 笔记</p>
<a id="more"></a>
<h1 id="传输层：TCP、UDP和SCTP"><a href="#传输层：TCP、UDP和SCTP" class="headerlink" title="传输层：TCP、UDP和SCTP"></a>传输层：TCP、UDP和SCTP</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>UDP是一个<strong>简单的、不可靠的数据报协议</strong>,而TCP是一个<strong>复杂、可靠的字节流协议</strong>。SCTP与TCP类似之处在于它<strong>也是一个可靠的传输协议,但它还提供消息边界、传输级别多宿</strong>（multihoming)支持以及将头端阻塞( head-of-line blockin)减少到最小的一种方法。我们必须了解由这些传输层协议提供给应用进程的服务,这样才能弄清这些协议处理什么,应用进程中又需要处理什么。</p>
<h2 id="总图"><a href="#总图" class="headerlink" title="总图"></a>总图</h2><p>TCP/IP协议族除了TCP和IP这两个协议以外，还有许多其他的成员：</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15269068803801.jpg" alt=""></p>
<h2 id="用户数据报协议（UDP）"><a href="#用户数据报协议（UDP）" class="headerlink" title="用户数据报协议（UDP）"></a>用户数据报协议（UDP）</h2><p>应用进程往一个UDP套接字写入一个消息,该消息随后被封装( encapsulating)到一个UDP数据报,该UDP数据报进而又被封装到一个IP数据报,然后发送到目的地。UDP不保证UDP数据报会到达其最终目的地,不保证各个数据报的先后顺序跨网络后保持不变,也不保证每个数据报只到达一次</p>
<p>使用UDP进行网络编程所遇到的问题是它缺乏可靠性。如果一个数据报到达了其最终目的地,但是校验和检测发现有错误,或者该数据报在网络传输途中被丢弃了,它就无法被投递给UDP套接字,也不会被源端自动重传。</p>
<p>每个UDP数据报都有一个长度。如果一个数据报正确地到达其目的地,那么该数据报的长度将随数据一道传递给接收端应用进程。同时TCP是一个字节流(byte-stream)协议,没有任何记录边界,这一点不同于UDP</p>
<h2 id="传输控制协议（TCP）"><a href="#传输控制协议（TCP）" class="headerlink" title="传输控制协议（TCP）"></a>传输控制协议（TCP）</h2><p>首先，TCP客户先与某个给定服务器<strong>建立一个连接</strong>,再跨该连接与那个服务器交换数据,然后终止这个连接。</p>
<p>其次,TCP还提供了<strong>可靠性</strong>( reliability)。当TCP向另一端发送数据时,它要求对端返回个确认。如果没有收到确认,TCP就自动重传数据并等待更长时间。在数次重传失败后,TCP才放弃。TCP通过给其中每个字节关联一个序列号对所发送的数据进行排序，从而达到确认重传的目的。</p>
<p>再次,TCP提供<strong>流量控制</strong>( flow control)。TCP总是告知对端在任何时刻它一次能够从对端接收多少字节的数据,这称为通告窗口( advertised window)。在任何时刻,该窗口指出接收缓冲区中当前可用的空间量,从而确保发送端发送的数据不会使接收缓冲区溢出。该窗口时刻动态变化。</p>
<p>最后,TCP连接是全双工的( full-duplex)。这意味着在一个给定的连接上应用可以在任何时刻在进出两个方向上既发送数据又接收数据。因此,TCP必须为每个数据流方向跟踪诸如序列号和通告窗口大小等状态信息。当然UDP也是全双工的。</p>
<h2 id="流控制传输协议（SCTP）"><a href="#流控制传输协议（SCTP）" class="headerlink" title="流控制传输协议（SCTP）"></a>流控制传输协议（SCTP）</h2><p>SCTP提供的服务与UDP和TCP提供的类似。SCTP在客户和服务器之间提供关联( association),并像TCP那样给应用提供可靠性、排序、流量控制以及全双工的数据传送。SCTP中使用“关联”一词取代“连接”是为了避免这样的内涵:一个连接只涉及两个IP地址之间的通信。一个关联指代两个系统之间的一次通信,它可能因为SCTP支持多宿而涉及不止两个地址</p>
<p>与TCP不同的是,SCTP是面向消息的(message-oriented)。它提供各个记录的按序递送服务。与UDP一样,由发送端写入的每条记录的长度随数据一道传递给接收端应用SCTP能够在所连接的端点之间提供多个流,每个流各自可靠地按序递送消息。</p>
<h2 id="TCP连接的建立和终止"><a href="#TCP连接的建立和终止" class="headerlink" title="TCP连接的建立和终止"></a>TCP连接的建立和终止</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://data2.liuin.cn/2018-05-21-15269078619660.jpg" alt=""></p>
<h3 id="TCP选项"><a href="#TCP选项" class="headerlink" title="TCP选项"></a>TCP选项</h3><p>每一个SYN可以含有多个TCP选项，下面是一些常用的：</p>
<ul>
<li>MSS选项。发送SYN的TCP一端使用本选项通告对端它的最大分节大小( maximunsegment size)即MSS,也就是它在本连接的每个TCP分节中愿意接受的最大数据量。</li>
<li>窗口规模选项。TCP连接任何一端能够通告对端的最大窗口大小是65535,因为在TCP首部中相应的字段占16位。</li>
<li>时间戳选项。这个选项对于高速网络连接是必要的,它可以防止由失而复现的分组°可能造成的数据损坏。</li>
</ul>
<h3 id="TCP-连接终止"><a href="#TCP-连接终止" class="headerlink" title="TCP 连接终止"></a>TCP 连接终止</h3><p><img src="https://data2.liuin.cn/2018-05-21-15269079942940.jpg" alt=""></p>
<h3 id="TCP-状态转换图"><a href="#TCP-状态转换图" class="headerlink" title="TCP 状态转换图"></a>TCP 状态转换图</h3><p>TCP建立连接和连接终止的操作可以用状态转换图来进行表示，其中一共有11种状态</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15269080313206.jpg" alt=""></p>
<h3 id="观察分组"><a href="#观察分组" class="headerlink" title="观察分组"></a>观察分组</h3><p>下图展示了一个完整的TCP连接所发生的实际分组交换情况，包括建立连接、数据传送和连接终止3个阶段</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15269082100424.jpg" alt=""></p>
<h2 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h2><p>TIME WAIT状态有两个存在的理由:</p>
<ol>
<li>可靠地实现TCP全双工连接的终止，当最终的ACK丢失的时候，客户端必须重新发出这个ACK，在这之前客户端必须维护之前的状态，以允许重新发送那个ACK</li>
<li>允许老的重复分节在网络中消逝，防止影响后面的TCP连接</li>
</ol>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>任何时候,多个进程可能同时使用TCP、UDP和SCTP这3种传输层协议中的任何一种。这3种协议都使用16位整数的端口号(port number)来区分这些进程</p>
<p>当一个客户想要跟一个服务器联系时,它必须标识想要与之通信的这个服务器。TCP、UDP和SCTP定义了一组众所周知的端口(well- known port),用于标识众所周知的服务。</p>
<p>另一方面,客户通常使用短期存活的临时端口( ephemeral port)。这些端口号通常<strong>由传输层协议自动赋予客户</strong>。客户通常不关心其临时端口的具体值,而只需确信该端口在所在主机中是唯一的就行。传输协议的代码确保这种唯一性</p>
<p>端口号被划分成以下3段：</p>
<ol>
<li>众所周知的端口为0~1023。这些端口由IANA分配和控制。可能的话,相同端口号就分配给TCP、UDP和SCTP的同一给定服务。</li>
<li>已登记的端口( registered port)为1024~49151。这些端口不受IANA控制,不过由LANA登记并提供它们的使用情况清单,以方便整个群体。</li>
<li>49152~65535是动态的( dynamic)或私用的( private)端口。IANA不管这些端口。它们就是我们所称的临时端口。(49152这个魔数是65536的四分之三。）</li>
</ol>
<blockquote>
<p>套接字对</p>
</blockquote>
<p>一个TCP连接的套接字对( socket pair)是一个定义该连接的两个端点的四元组:本地P地址、本地TCP端口号、外地IP地址、外地TCP端口号。套接字对唯一标识一个网络上的每个TCP连接。</p>
<h2 id="TCP端口号与并发服务器"><a href="#TCP端口号与并发服务器" class="headerlink" title="TCP端口号与并发服务器"></a>TCP端口号与并发服务器</h2><p>并发服务器中主服务器循环通过派生一个子进程来处理每个新的连接</p>
<p>我们必须在服务器主机上区分监听套接字和已连接套接字( connected socket)。注意已连接套接字使用与监听套接字相同的本地端口(21)。</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15269091556898.jpg" alt=""></p>
<p>从上面我们可以看到：TCP无法仅仅通过查看目的端口号来分离外来的分节到不同的端点。它必须查看套接字对的所有4个元素才能确定由哪个端点接收某个到达的分节。</p>
<h2 id="缓冲区大小和限制"><a href="#缓冲区大小和限制" class="headerlink" title="缓冲区大小和限制"></a>缓冲区大小和限制</h2><h3 id="TCP输出"><a href="#TCP输出" class="headerlink" title="TCP输出"></a>TCP输出</h3><p>每一个TCP套接字有一个发送缓冲区,我们可以使用 SO_SNDBUF套接字选项来更改该缓冲区的大小。当某个应用进程调用 write时,内核从该应用进程的缓冲区中复制所有数据到所写套接字的发送缓冲区。如果该套接字的发送缓冲区容不下该应用进程的所有数据(或是应用进程的缓冲区大于套接字的发送缓冲区,或是套接字的发送缓冲区中已有其他数据),该应用进程将被投入睡眠。这里假设该套接字是阻塞的,它是通常的默认设置。内核将不从wite系统调用返回,<strong>直到应用进程缓冲区中的所有数据都复制到套接字发送缓冲区</strong>。因此,从写一个TCP套接字的 write调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区,<strong>并不表明对端的TCP或应用进程已接收到数据</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15269096002757.jpg" alt=""></p>
<h3 id="UDP输出"><a href="#UDP输出" class="headerlink" title="UDP输出"></a>UDP输出</h3><p>任何UDP套接字都有发送缓冲区大小(我们可以使用 SO SNDBUE套接字选项更改它,见75节),不过它仅仅是可写到该套接字的UDP数据报的大小上限。如果一个应用进程写一个大于套接字发送缓冲区大小的数据报,内核将返回该进程一个 EMSGSIZE错误。既然UDP是不可靠的,它不必保存应用进程数据的一个副本,因此无需一个真正的发送缓冲区。</p>
<p><img src="https://data2.liuin.cn/2018-05-21-15269096922589.jpg" alt=""></p>
<h2 id="常见因特网应用的协议使用"><a href="#常见因特网应用的协议使用" class="headerlink" title="常见因特网应用的协议使用"></a>常见因特网应用的协议使用</h2><p><img src="https://data2.liuin.cn/2018-05-21-15269097511476.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UNIX网络编程必读书籍——《UNIX网络编程卷1》  简介部分 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="https://www.liuin.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>APUE 伪终端</title>
    <link href="https://www.liuin.cn/2018/05/05/APUE-%E4%BC%AA%E7%BB%88%E7%AB%AF/"/>
    <id>https://www.liuin.cn/2018/05/05/APUE-伪终端/</id>
    <published>2018-05-05T08:09:34.000Z</published>
    <updated>2018-05-05T11:14:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第19章 伪终端 笔记</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>伪终端这个术语是指,对于一个应用程序而言,它看上去像一个终端,但事实上它并不是个真正的终端。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255087230010.jpg" alt=""></p>
<p>图中的关键点是：</p>
<ol>
<li>通常,一个进程打开伪终端主设备,然后调用fork。子进程建立一个新的会话,打开一个相应的伪终端从设备,将其文件描述符复制到标准输入、标准输出和标准错误,然后调用exec。伪终端从设备成为子进程的控制终端。</li>
<li>对于伪终端从设备上的用户进程来说,其标准输入、标准输出和标准错误都是终端设备。通过这些描述符,用户进程能够处理所有终端I/O函数。但是因为仍终端从设备不是真正的终端设备,所以无意义的函数调用(例如,改变波特率、发送中断符、设置奇偶校验)将被忽略</li>
<li>任何写到伪终端主设备的都会作为从设备的输入,反之亦然。事实上,所有从设备端的输入都来自于伪终端主设备上的用户进程。这看起来就像一个双向管道,但是从设备上的中断行规程使我们拥有管道没有的处理奇谈问题的能力</li>
</ol>
<p>伪终端的某些经典用途：</p>
<blockquote>
<p>网络登录服务器</p>
</blockquote>
<p>伪终端可用于构造提供网络登录的服务器。典型的例子是 telnetd和rlogind服务器</p>
<p>在rlogind服务器和登录shell之间有两个exec调用,这是因为login程序通常是在两个exec之间检验用户是否合法</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255090645150.jpg" alt=""></p>
<blockquote>
<p>窗口系统终端模拟</p>
</blockquote>
<p>窗口系统通常提供一个终端模拟器,这样我们就能在熟悉的命令行环境中通过shell来运行程序。终端模拟器作为shell和窗口管理器之间的媒介。每个shell在自己的窗口中执行。</p>
<p>shell将自己的标准输入、标准输出、标准错误连接到PTY的从设备端。终端模拟器程序打开PTY的主设备。终端模拟器除了作为窗口子系统的接口,还要负责模拟一种特殊的终端,这意味着它需要根据它所模拟的设备类型来响应返回码。这些码列在 termcap和 terminfo数据库中。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255091975517.jpg" alt=""></p>
<blockquote>
<p>script 程序</p>
</blockquote>
<p>script(1)程序是随大多数UNIX系统提供的,它将终端会话期间的所有输入和输出信息复制到一个文件中。为完成此工作,该程序将自己置于终端和一个新调用的登录 shell之间。这里要特别指出, script程序通常是从登录shell启动的,该 shell还要等待 script程序的终止。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255092890944.jpg" alt=""></p>
<blockquote>
<p>expect 程序</p>
</blockquote>
<p>伪终端可以用来在非交互模式中驱动交互式程序的运行。许多硬连线程序需要一个终端才能行, passwd(1)命令就是一个例子,它要求用户在系统提示后输入口令</p>
<blockquote>
<p>运行协同进程</p>
</blockquote>
<p>如果协同进程是一个已经编译的程序而我们又没有源程序,则无法在源程序中加入ff1ush语句来解决这个问题。我们需要做的是将一个伪终端放到两个进程之间,诱使协同进程认为它是由终端驱动的,而非另一个进程</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255094556754.jpg" alt=""></p>
<blockquote>
<p>观看长时间运行程序的输出</p>
</blockquote>
<p>使用任何一个标准 shell,可以将一个需要长时间运行的程序放到后台运行。但是,如果将该程序的标准输出重定向到一个文件,并且它产生的输出又不多,那么我们就不能方便地监控程序的进展,因为标准I/O库将完全缓冲它的标准输出。</p>
<p>如果有源程序,则可以加入fflush调用强制标准I/O缓冲区在某些节点冲洗或者把缓冲模式改使用 setybuf的行缓冲。然而,如果没有源程序,可以在pty程序下运行该程序,让标准I/O库认为标准输出是终端。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255095797010.jpg" alt=""></p>
<h2 id="打开伪终端设备"><a href="#打开伪终端设备" class="headerlink" title="打开伪终端设备"></a>打开伪终端设备</h2><p>PTY表现得就像物理终端设备一样,因此应用程序就无须在意它们在使用的是何种设备。各种平台打开伪终端设备的方法有所不同。posix_openpt函数提供了一种可移植的方法来打开下一个可用<strong>伪终端主设备</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; #include &lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">posix_openpt</span><span class="params">(<span class="keyword">int</span> oﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: ﬁle descriptor of next available PTY master if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>在伪终端从设备可用之前,它的权限必须设置,以便应用程序可以访问它。 grantpt函数提供这样的功能:它把从设备节点的用户ID设置为调用者的实际用户ID,设置其组ID为一非指定值,通常是可以访问该终端设备的组。权限被设置为:对个体所有者是读写,对组所有者是写(0620)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">grantpt</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlockpt</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 on success, −1 on error</span></div></pre></td></tr></table></figure>
<p>unlockpt函数用于准予对伪终端从设备的访问,从而允许应用程序打开该设备。阻止其他进程打开从设备后,建立该设备的应用程序有机会在使用主、从设备之前正确地初始化这些设备</p>
<p>注意,在 grantpt和unlockpt这两个函数中,文件描述符参数是与伪终端主设备关联的文件描述符。</p>
<p>如果给定了伪终端主设备的文件描述符,那么可以用 ptsname函数找到伪终端从设备的路径名。这使应用程序可以独立于给定平台的某种特定约定而标识从设备。注意,该函数返回的名字可能存储在静态存储中,因此后续的调用可能会覆盖它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ptsname</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to name of PTY slave if OK, NULL on error</span></div></pre></td></tr></table></figure>
<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><p>伪终端还有其他特性：</p>
<ol>
<li>打包模式</li>
</ol>
<p>打包模式(packet mode)能够使PTY主设备了解到PTY从设备的状态变化</p>
<ol>
<li>远程模式</li>
</ol>
<p>PTY主设备可以用 TIOCREMOTE ioct1命令将PTY从设备设置成远程模式</p>
<ol>
<li>窗口大小变化</li>
</ol>
<p>PTY主设备上的进程可以用 TIOCSWINSZ ioct1命令来设置从设备的窗口大小。如果新的大小和当前的大小不同, SIGWINCH信号将被发送到PTY从设备的前台进程组。</p>
<ol>
<li>信号发生</li>
</ol>
<p>读、写PTY主设备的进程可以向PTY从设备的进程组发送信号</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第19章 伪终端 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 终端I/O</title>
    <link href="https://www.liuin.cn/2018/05/05/APUE-%E7%BB%88%E7%AB%AFI-O/"/>
    <id>https://www.liuin.cn/2018/05/05/APUE-终端I-O/</id>
    <published>2018-05-05T02:53:52.000Z</published>
    <updated>2018-05-05T08:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第18章 终端I/O 笔记</p>
<a id="more"></a>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>终端I/O有两种不同的工作模式:</p>
<ol>
<li>规范模式输入处理。在这种模式中,对终端输入以行为单位进行处理。对于每个读请求终端驱动程序最多返回一行</li>
<li>非规范模式输入处理。输入字符不装配成行</li>
</ol>
<p>如果不做特殊处理,则默认模式是规范模式</p>
<p>可以认为终端设备是由通常位于内核中的终端驱动程序控制的。每个终端设备都有一个输入列和一个输出队列,如图所示：</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255055612367.jpg" alt=""></p>
<p>有以下几点说明：</p>
<ul>
<li>如果打开了回显功能,则在输入队列和输出队列之间有一个隐含的连接</li>
<li>输入队列的长度MAX_INPUT是有限值。当一个特定设备的输入队列已经填满时,系统的行为将依赖于实现。这种情况发生时大多数UNIX系统回显响铃字符。</li>
<li>图中没有显示另一个输入限制MAX_CANON。这个限制是一个规范输入行的最大字节数</li>
<li>虽然输出队列的长度通常也是有限的,但是程序并不能获得这个定义其长度的常量为当输出队列将要填满时,内核便直接使写进程休眠,直至写队列中有可用的空间。</li>
</ul>
<p>大多数UNIX系统在一个称为终端行规程(terminal linediscipline)的模块中进行全部的规范处理。可以将这个模块设想成一个盒子,<strong>位于内核通用读、写函数和实际设备驱动程序之间</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255057246778.jpg" alt=""></p>
<p>由于将规范处理分离为单独的模块,所有的终端驱动程序都能够一致地支持规范处理。</p>
<p>所有可以检测和更改的终端设备特性都包含在termios结构中。该结构定义在头文件<termios.h>中,本章使用这一头文件。</termios.h></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255057581968.jpg" alt=""></p>
<p>各个标志位的作用：</p>
<ul>
<li>输入标志通过终端设备驱动程序控制字符的输入(例如,剥除输入字节的第8位,允许输入奇偶校验)</li>
<li>输出标志则控制驱动程序输出(例如,执行输出处理、将换行符转换为CRLF)</li>
<li>控制标志影响RS232串行线(例如,忽略调制解调器的状态线、每个字符的一个或两个停止位)</li>
<li>本地标志影响驱动程序和用户之间的接口(例如,回显打开或关闭、可视地擦除字符、允许终端产生的信号以及对后台输出的作业控制停止信号</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-05-05-15255058794969.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255058823469.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255058855001.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255058879538.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255058906529.jpg" alt=""></p>
<p>与终端有关的各个函数之间的关系</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255059407734.jpg" alt=""></p>
<h2 id="特殊输入字符"><a href="#特殊输入字符" class="headerlink" title="特殊输入字符"></a>特殊输入字符</h2><p>POSIX.1定义了11个在输入时要特殊处理的字符。实现定义了另外一些特殊字符</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255061027706.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255061066356.jpg" alt=""></p>
<p>在POSIX的11个特殊字符中,其中有9个字符的值可以任意更改。不能更改的两个特殊字符是换行符和回车符(分别是\n和\r),也可能是STOP和START字符(依赖于实现)。为了更改,只需要修改termios结构中c_cc数组的相应项。该数组中的元素都用名字作为下标进行引用,每个名字都以字母V开头。</p>
<p>对各个字符的详细解释可见原书内容</p>
<h2 id="获得和设置终端属性"><a href="#获得和设置终端属性" class="headerlink" title="获得和设置终端属性"></a>获得和设置终端属性</h2><p>为了获得和设置 termios结构,可以调用 tcgetattr和 tcsetattr函数。这样就可以检测和修改各种终端选项标志和特殊字符,使终端按我们所希望的方式进行操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcgetattr</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">struct</span> termios *termptr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsetattr</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> opt, <span class="keyword">const</span> <span class="keyword">struct</span> termios *termptr)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>tcsetattr的参数opt使我们可以指定在什么时候新的终端属性才起作用。opt可以指定为下列常量中的一个:</p>
<ul>
<li>TCSANOW   更改立即发生。</li>
<li>TCSADRAIN 发送了所有输出后更改才发生。若更改输出参数则应使用此选项。</li>
<li>TCSAFLUSH 发送了所有输出后更改才发生。更进一步,在更改发生时未读的所有输入数据都被丢弃(冲洗)。</li>
</ul>
<h2 id="终端选项标志"><a href="#终端选项标志" class="headerlink" title="终端选项标志"></a>终端选项标志</h2><p>包含终端选项标志的所有的解释，具体可查看原书</p>
<h2 id="stty命令"><a href="#stty命令" class="headerlink" title="stty命令"></a>stty命令</h2><p>上节说明的所有选项都可以被检查和更改:在程序中用tcgetattr和tcsetattr函数进行检查和更改;在命令行(或shell脚本)中用stty(1)命令进行检查和更改。简单地说,stty(1)命令就是终端I/O所列的前6个函数的接口。</p>
<h2 id="波特率函数"><a href="#波特率函数" class="headerlink" title="波特率函数"></a>波特率函数</h2><p>术语波特率(baud rate)是一个历史沿用的术语,现在它指的是“位/秒”(bit per second)。虽然大多数终端设备对输入和输出使用同一波特率,但是只要硬件许可,可以将它们设置为两个不同值。</p>
<p>设置波特率函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">speed_t</span> cfgetispeed(<span class="keyword">const</span> <span class="keyword">struct</span> termios *termptr); </div><div class="line"><span class="keyword">speed_t</span> cfgetospeed(<span class="keyword">const</span> <span class="keyword">struct</span> termios *termptr); </div><div class="line"></div><div class="line"><span class="comment">// Both return: baud rate value </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cfsetispeed</span><span class="params">(<span class="keyword">struct</span> termios *termptr, <span class="keyword">speed_t</span> speed)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cfsetospeed</span><span class="params">(<span class="keyword">struct</span> termios *termptr, <span class="keyword">speed_t</span> speed)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="行控制函数"><a href="#行控制函数" class="headerlink" title="行控制函数"></a>行控制函数</h2><p>下列4个函数提供了终端设备的行控制能力：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcdrain</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcflow</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> action)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcflush</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> <span class="built_in">queue</span>)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsendbreak</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> duration)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All four return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>tcdrain函数等待所有输出都被传递。<br>tcflow函数用于对输入和输出流控制进行控制。<br>tcflush函数冲洗(抛弃)输入缓冲区(其中的数据是终端驱动程序已接收到,但用户程序尚未读取的)或输出缓冲区(其中的数据是用户程序已经写入,但尚未被传递的)。<br>tcsendbreak函数在一个指定的时间区间内发送连续的0值位流。</p>
<h2 id="终端标识"><a href="#终端标识" class="headerlink" title="终端标识"></a>终端标识</h2><p>历史上,在大多数UNIX系统版本中,控制终端的名字一直是/dev/tty。POSIX.1提供了个运行时函数,可用来确定控制终端的名字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctermid</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to name of controlling terminal on success, pointer to empty string on error</span></div></pre></td></tr></table></figure>
<p>另外还有两个UNIX系统比较感兴趣的函数: isatty和 ttyname。如果文件描述符引用个终端设备,则 isatty返回真。 ttyname返回的是在该文件描述符上打开的终端设备的路径名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">isatty</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 1 (true) if terminal device, 0 (false) otherwise</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ttyname</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to pathname of terminal, NULL on error</span></div></pre></td></tr></table></figure>
<h2 id="规范模式"><a href="#规范模式" class="headerlink" title="规范模式"></a>规范模式</h2><p>规范模式很简单:发一个读请求,<strong>当一行已经输入后,终端驱动程序即返回</strong>。以下几个条件造成读返回。</p>
<ol>
<li>所请求的字节数已读到时,读返回。无需读一个完整的行。如果读了部分行,那么也不会丢失任何信息,下一次读从前一次读的停止处开始。</li>
<li>当读到一个行定界符时,读返回。</li>
<li>如果捕捉到信号,并且该函数不再自动重启,则读也返回</li>
</ol>
<h2 id="非规范模式"><a href="#非规范模式" class="headerlink" title="非规范模式"></a>非规范模式</h2><p>可以通过关闭termios结构中c_lf1ag字段的ICANON标志来指定非规范模式。在非规范模式中,输入数据不装配成行,不处理下列特殊字符: ERASE、KILL、EOF、NLEOL、EOL2、CR、REPRINT、STATUS和 WERASE。</p>
<p>如前所述,规范模式很容易理解:系统每次至多返回一行。但在非规范模式下,系统如何知道在什么时候将数据返回给我们呢?如果它一次返回一个字节,那么系统开销就会过大。在启动读数据之前,往往不知道要读多少数据,所以系统不能总是一次返回多个字节解决方法是,当已读了指定量的数据后,或者已经超过了给定量的时间后,即通知系统返回。</p>
<p>这种技术使用了 termios结构中c_cc数组的两个变量:MIN和TIME。c_cc数组中的这两个元素的下标名为VMIN和VTIM。</p>
<p>MIN指定一个read返回前的最小字节数。TIME指定等待数据到达的分秒数(分秒为秒的1/10)。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255076147395.jpg" alt=""></p>
<h2 id="终端窗口大小"><a href="#终端窗口大小" class="headerlink" title="终端窗口大小"></a>终端窗口大小</h2><p>大多数UNⅨX系统都提供了一种跟踪当前终端窗口大小的方法,在窗口大小发生变化时,使内核通知前台进程组。内核为每个终端和伪终端都维护了一个wins1ze结构</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255076954042.jpg" alt=""></p>
<p>提供这种功能的目的是,当窗口大小发生变化时应用程序能够得到通知(如v1编辑器)。应用程序接收此信号后,可以获取窗口大小的新值,然后重绘屏幕。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第18章 终端I/O 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 高级进程间通信</title>
    <link href="https://www.liuin.cn/2018/05/05/APUE-%E9%AB%98%E7%BA%A7%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://www.liuin.cn/2018/05/05/APUE-高级进程间通信/</id>
    <published>2018-05-05T01:37:33.000Z</published>
    <updated>2018-05-05T02:55:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第17章 高级进程间通信 笔记</p>
<a id="more"></a>
<h2 id="UNIX-域套接字"><a href="#UNIX-域套接字" class="headerlink" title="UNIX 域套接字"></a>UNIX 域套接字</h2><p>UNIX域套接字用于在同一台计算机上运行的进程之间的通信。虽然因特网域套接字可用于同一目的,但<strong>UNIX域套接字的效率更高</strong>。UNIX域套接字仅仅复制数据,它们并不执行协议处理,不需要添加或删除网络报头,无需计算校验和,不要产生顺序号,无需发送确认报文。</p>
<p>UNIX域套接字<strong>提供流和数据报两种接口</strong>。UNIX域数据报服务是可靠的,既不会丢失报文也不会传递出错。UNIX域套接字就像是套接字和管道的混合。</p>
<p>可以使用它们面向网络的域套接字接口或者使用socketpair函数来创建一对无命名的、相互连接的UNIX域套接字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> sockfd[<span class="number">2</span>])</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>虽然接口足够通用,允许socketpair用于其他域,但一般来说操作系统仅对UNIX域提供支持</p>
<p>对相互连接的UNIX域套接字可以起到<strong>全双工管道的作用</strong>:两端对读和写开放。我们将其称为fd管道( fd-pipe),以便与普通的半双工管道区分开来。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254872539788.jpg" alt=""></p>
<p>曾经提到XSI消息队列的使用存在一个问题,即不能将它们和po11或者se1ect起使用,这是因为它们不能关联到文件描述符。然而,套接字是和文件描述符相关联的,消息到达时,可以用套接字来通知。对每个消息队列使用一个线程。每个线程都会在mmsgrcv调用中阻塞。当消息到达时,线程会把它写入一个UNIX域套接字的一端。当poll指示套接字可以读取数据时,应用程序会使用这个套接字的另外一端来接收这个消息。</p>
<blockquote>
<p>命名UNIX域套接字</p>
</blockquote>
<p>虽然socketpair函数能创建一对相互连接的套接字,但是每一个套接字都没有名字。这意味着无关进程不能使用它们。恰如因特网域套接字一样,可以命名UNIX域套接字,并可将其用于告示服务。但是要注意,UNX域套接字使用的地址格式不同于因特网域套接字，套接字地址格式会随实现而变。</p>
<p>UNIX域套接字的地址由 sockaddr_un结构表示。在 Linux3.20和 Solaris10中, sockaddr_un结构在头文件<sys un.h="">中的定义</sys></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254875673064.jpg" alt=""></p>
<p>sockaddr_un结构的sun_path成员包含一个路径名。当我们将一个地址绑定到一个UNIX域套接字时,系统会用该路径名创建一个S_IFSOCK类型的文件该文件仅用于向客户进程告示套接字名字。该文件无法打开,也不能由应用程序用于通信。</p>
<p>如果我们试图绑定同一地址时,该文件已经存在,那么bind请求会失败。当关闭套接字时,并不自动删除该文件,所以必须确保在应用程序退出前,对该文件执行解除链接操作。</p>
<h2 id="唯一连接"><a href="#唯一连接" class="headerlink" title="唯一连接"></a>唯一连接</h2><p>服务器进程可以使用标准bind、listen和 accept函数,为客户进程安排一个唯一UNIX域连接。客户进程使用 connect与服务器进程联系。在服务器进程接受了connect请求后,在服务器进程和客户进程之间就存在了唯一连接。</p>
<p>下图展示了客户进程和服务器进程存在连接之前二者的情形。服务器端把它的套接字绑定到sockaddr_un的地址并监听新的连接请求。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254879207178.jpg" alt=""></p>
<p>现在，开发3个函数,使用这些函数可以在运行于同一台计算机上的两个无关进程之间创建唯一连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span> </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">serv_listen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </div><div class="line"><span class="comment">// Returns: ﬁle descriptor to listen on if OK, negative value on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">serv_accept</span><span class="params">(<span class="keyword">int</span> listenfd, <span class="keyword">uid_t</span> *uidptr)</span></span>; </div><div class="line"><span class="comment">// Returns: new ﬁle descriptor if OK, negative value on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cli_conn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </div><div class="line"><span class="comment">// Returns: ﬁle descriptor if OK, negative value on error</span></div></pre></td></tr></table></figure>
<p>服务器进程可以调用serv_listen函数声明它要在一个众所周知的名字(文件系统中的某个路径名)上监听客户进程的连接请求。当客户进程想要连接至服务器进程时,它们将使用该名字。serv_listen函数的返回值是用于接收客户进程连接请求的服务器UNIX域套接字</p>
<p>服务器进程可以使用serv_accept函数等待客户进程连接请求的到达。当个请求到达时,系统自动创建一个新的UNIX域套接字,并将它与客户端套接字连接,最后将这个新套接字返回给服务器。此外,客户进程的有效用户ID存放在 uidptr指向的存储区中客户</p>
<p>进程调用cli_conn函数连接至服务器进程。客户进程指定的name参数必须与服务器进程调用serv_listen函数时所用的名字相同</p>
<p>这三个函数的具体实现可以查看书本</p>
<h2 id="传送文件描述符"><a href="#传送文件描述符" class="headerlink" title="传送文件描述符"></a>传送文件描述符</h2><p>在两个进程之间传送打开文件描述符的技术是非常有用的。因此可以对客户进程服务器进程应用进行不同的设计。它使一个进程(通常是服务器进程)能够处理打开一个文件所要做的一切操作(包括将网络名翻译为网络地址、拨号调制解调器、协商文件锁等)以及<strong>向调用进程送回个描述符</strong>,该描述符可被用于以后的所有I/O函数。涉及打开文件或设备的所有细节对客户进程而言都是透明的。</p>
<p>一般情况下，两个进程,它们打开了同一文件。虽然它们共享同一个v节点,但每个进程都有它自己的文件表项。当一个进程向另一个进程传送一个打开文件描述符时,我们想让发送进程和接收进程共享同文件表项。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254885933315.jpg" alt=""></p>
<p>在技术上,我们是<strong>将指向一个打开文件表项的指针从一个进程发送到另外一个进程</strong>。该指针被分配存放在接收进程的第一个可用描述符项中。(注意,不要造成错觉,以为发送进程和接收进程中的描述符编号是相同的,它们通常是不同的。)两个进程共享同一个打开文件表,这与foxk之后的父进程和子进程共享打开文件表的情况完全相同。</p>
<p>当发送进程将描述符传送给接收进程后,通常会关闭该描述符。发送进程关闭该描述符并不会真的关闭该文件或设备,其原因是该描述符仍被视为由接收进程打开(即使接收进程尚未接收到该描述符)</p>
<p>下面定义用以发送和接收文件描述符的3个函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include "apue.h" </div><div class="line"></div><div class="line">int send_fd(int fd, int fd_to_send); </div><div class="line">int send_err(int fd, int status, const char *errmsg); </div><div class="line">// Both return: 0 if OK, −1 on error </div><div class="line"></div><div class="line">int recv_fd(int fd, ssize_t (*userfunc)(int, const void *, size_t)); </div><div class="line">// Returns: ﬁle descriptor if OK, negative value on error</div></pre></td></tr></table></figure>
<p>具体的实现原书代码</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第17章 高级进程间通信 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 网络IPC：套接字</title>
    <link href="https://www.liuin.cn/2018/05/05/APUE-%E7%BD%91%E7%BB%9CIPC%EF%BC%9A%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    <id>https://www.liuin.cn/2018/05/05/APUE-网络IPC：套接字/</id>
    <published>2018-05-05T00:38:42.000Z</published>
    <updated>2018-05-05T01:37:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第16章 网络IPC：套接字 笔记</p>
<a id="more"></a>
<h2 id="套接字描述"><a href="#套接字描述" class="headerlink" title="套接字描述"></a>套接字描述</h2><p>套接字是通信端点的抽象。正如使用文件描述符访问文件,应用程序用套接字描述符访问套接字。<strong>套接字描述符在UNIX系统中被当作是一种文件描述符</strong>。事实上,许多处理文件描述符的函数(如read和 write)可以用于处理套接字描述符。</p>
<p>为创建一个套接字,调用socket函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: ﬁle (socket) descriptor if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>参数 domain(域)确定通信的特性,包括地址格式</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254808968863.jpg" alt=""></p>
<p>参数type确定套接字的类型,进一步确定通信特征。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254809237060.jpg" alt=""></p>
<p>参数protocol通常是0,表示为给定的域和套接字类型选择默认协议。当对同一域和套接字类型支持多个协议时,可以使用 protocol选择一个特定协议</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254809947426.jpg" alt=""></p>
<p>对于数据报(SOCK_DGRAM)接口,两个对等进程之间通信时不需要逻辑连接。只需要向对等进程所使用的套接字送出一个报文。字节流(SOCK_STREAM)要求在交换数据之前,在本地套接字和通信的对等进程的套接字之间建立一个逻辑连接。</p>
<p>调用socket与调用open相类似。在两种情况下,均可获得用于I/O的文件描述符。当不再需要该文件描述符时,调用c1ose来关闭对文件或套接字的访问,并且释放该描述符以便重新使用虽然套接字描述符本质上是一个文件描述符,但不是所有参数为文件描述符的函数都可以接受套接字描述符。</p>
<h2 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h2><p>在学习用套接字做一些有意义的事情之前,需要知道如何标识一个目标通信进程。进程标识由两部分组成。一部分是<strong>计算机的网络地址</strong>,它可以帮助标识网络上我们想与之通信的计算机;另一部分是该<strong>计算机上用端口号</strong>表示的服务,它可以帮助标识特定的进程。</p>
<h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>字节序是一个处理器架构特性用于指示像整数这样的大数据类型内部的字节如何排序。</p>
<p>如果处理器架构支持大端(big-endian)字节序,那么<strong>最大字节地址出现在最低有效字节</strong>( Least Significant Byte,LSB)上，小端(little-endian)字节序则相反:<strong>最低有效字节包含最小字节地址</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254815015116.jpg" alt=""></p>
<p>网络协议指定了字节序,因此异构计算机系统能够交换协议信息而不会被字节序所混淆。TCPP协议栈使用大端字节序。应用程序交换格式化数据时,字节序问题就会出现</p>
<p>对于TCPP应用程序,有4个用来在处理器字节序和网络字节序之间实施转换的函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostint32);</div><div class="line"><span class="comment">// Returns: 32-bit integer in network byte order</span></div><div class="line"></div><div class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostint16);</div><div class="line"><span class="comment">// Returns: 16-bit integer in network byte order</span></div><div class="line"></div><div class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netint32);</div><div class="line"></div><div class="line"><span class="comment">// Returns: 32-bit integer in host byte order</span></div><div class="line"></div><div class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> netint16);</div><div class="line"></div><div class="line"><span class="comment">// Returns: 16-bit integer in host byte order</span></div></pre></td></tr></table></figure>
<p>h表示“主机”字节序,n表示“网络”字节序。1表示“长”(即4字节)整数,s表示“短”</p>
<h3 id="地址格式"><a href="#地址格式" class="headerlink" title="地址格式"></a>地址格式</h3><p>一个地址标识一个特定通信域的套接字端点,地址格式与这个特定的通信域相关。为使不同格式地址能够传入到套接字函数,地址会被<strong>强制转换</strong>成一个通用的地址结构sockaddr</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254817776056.jpg" alt=""></p>
<p>不同的系统实现可能会不一样</p>
<p>因特网地址定义在<netinet in.h="">头文件中。在IPv4因特网域(AF_INET)中,套接字地址用结构 sockaddr_in表示</netinet></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254818310427.jpg" alt=""></p>
<p>有时,需要打印出能被人理解而不是计算机所理解的地址格式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> addr, <span class="keyword">char</span> *<span class="keyword">restrict</span> str, <span class="keyword">socklen_t</span> size)</span></span>;</div><div class="line"><span class="comment">// Returns: pointer to address string on success, NULL on error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> str, <span class="keyword">void</span> *<span class="keyword">restrict</span> addr)</span></span>;</div><div class="line"><span class="comment">// Returns: 1 on success, 0 if the format is invalid, or −1 on error</span></div></pre></td></tr></table></figure>
<p>函数inet_ntop将网络字节序的二进制地址转换成文本字符串格式。inet_pton将文本字符串格式转换成网络字节序的二进制地址。</p>
<h3 id="将套接字和地址关联"><a href="#将套接字和地址关联" class="headerlink" title="将套接字和地址关联"></a>将套接字和地址关联</h3><p>将一个客户端的套接字关联上一个地址没有多少新意,可以让系统选一个默认的地址。然而,<strong>对于服务器,需要给一个接收客户端请求的服务器套接字关联上一个众所周知的地址</strong>。客户端应有一种方法来发现连接服务器所需要的地址,最简单的方法就是服务器保留一个地址并且注册在/etc/services或者某个名字服务中。</p>
<p>使用bind函数来关联地址和套接字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>对于使用的地址有以下一些限制:</p>
<ul>
<li>在进程正在运行的计算机上,指定的地址必须有效，不能指定一个其他机器的地址。</li>
<li>地址必须和创建套接字时的地址族所支持的格式相匹配。</li>
<li>地址中的端口号必须不小于1024,除非该进程具有相应的特权(即超级用户)</li>
<li>一般只能将一个套接字端点绑定到一个给定地址上,尽管有些协议允许多重绑定</li>
</ul>
<p>可以调用 getsockname函数来发现绑定到套接字上的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> alenp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>调用 getsockname之前,将 alenp设置为一个指向整数的指针,该整数指定缓冲区sockaddr的长度。返回时,该整数会被设置成返回地址的大小。如果地址和提供的缓冲区长</p>
<p>如果套接字已经和对等方连接,可以调用 getpeername函数来找到对方的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> alenp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>如果要处理一个面向连接的网络服务(SOCK_STREAM或SOCK_SEQPACKET),那么在开始交换数据以前,需要在请求服务的进程套接字(客户端)和提供服务的进程套接字(服务器)之间建立一个连接。使用connect函数来建立连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>在connect中指定的地址是我们想与之通信的服务器地址。如果 sockfd没有绑定到一个地址, connect会给调用者绑定一个默认地址。</p>
<p>服务器调用listen函数来宣告它愿意接受连接请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>一旦服务器调用了listen,所用的套接字就能接收连接请求。使用accept函数获得连接请求并建立连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> len)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: ﬁle (socket) descriptor if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>函数accept所返回的文件描述符是套接字描述符,该描述符连接到调用connect的客户端。这个新的套接字描述符和原始套接字(sockfd)具有相同的套接字类型和地址族。传给accept原始套接字没有关联到这个连接,而是继续保持可用状态并接收其他连接请求。</p>
<p>如果服务器调用accept,并且当前没有连接请求,服务器会阻塞直到一个请求到来。另外服务器可以使用poll或se1ect来等待一个请求的到来。在这种情况下,一个带有等待连接请求的套接字会以可读的方式出现</p>
<h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>既然一个套接字端点表示为一个文件描述符,那么只要建立连接,就可以使用read和 write来通过套接字通信。</p>
<p>尽管可以通过read和write交换数据,但这就是这两个函数所能做的一切。如果想指定选项,从多个客户端接收数据包,或者发送带外数据,就需要使用6个为数据传递而设计的套接字函数中的一个</p>
<p>3个函数用来发送数据,3个用于接收数据。首先,考查用于发送数据的函数。最简单的是send,它和 write很像,但是可以指定标志来改变处理传输数据的方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> send(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> ﬂags);</div><div class="line"></div><div class="line"><span class="comment">// Returns: number of bytes sent if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>前面3个参数和write参数一样，不同的是第4个参数flags：</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254833405785.jpg" alt=""></p>
<p>即使send成功返回,也并不表示连接的另一端的进程就一定接收了数据。我们所能保证的只是当send成功返回时,数据已经被无错误地发送到网络驱动程序上</p>
<p>函数 sendto和send很类似。区别在于sendto可以在无连接的套接字上指定一个目标地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> ﬂags, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *destaddr, <span class="keyword">socklen_t</span> destlen); </div><div class="line"></div><div class="line"><span class="comment">// Returns: number of bytes sent if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>对于面向连接的套接字,目标地址是被忽略的,因为连接中隐含了目标地址。对于无连接的套接字,除非先调用 connect设置了目标地址,否则不能使用send。 sendto提供了发送报文的另一种方式</p>
<p>通过套接字发送数据时,还有一个选择。可以调用带有msghdr结构的sendmsg来指定多重缓冲区传输数据,这和 writev函数很相似</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> sendmsg(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="keyword">int</span> ﬂags);</div><div class="line"></div><div class="line"><span class="comment">// Returns: number of bytes sent if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>与发送数据相对应的，接受数据也有三个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> recv(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> ﬂags);</div><div class="line"></div><div class="line"><span class="comment">// Returns: length of message in bytes, 0 if no messages are available and peer has done an orderly shutdown, or −1 on error</span></div></pre></td></tr></table></figure>
<p><img src="https://data2.liuin.cn/2018-05-05-15254835445782.jpg" alt=""></p>
<p>如果有兴趣定位发送者,可以使用 recvfrom来得到数据发送者的源地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> ﬂags, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> addrlen); </div><div class="line"></div><div class="line"><span class="comment">// Returns: length of message in bytes, 0 if no messages are available and peer has done an orderly shutdown, or −1 on error</span></div></pre></td></tr></table></figure>
<p>为了将接收到的数据送入多个缓冲区,类似于 readv,或者想接收辅助数据,可以使用 recvmso</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> recvmsg(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="keyword">int</span> ﬂags);</div><div class="line"></div><div class="line"><span class="comment">// Returns: length of message in bytes, 0 if no messages are available and peer has done an orderly shutdown, or −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h2><p>套接字机制提供了两个套接字选项接口来控制套接字行为。一个接口用来设置选项,另一个接口可以查询选项的状态。可以获取或设置以下3种选项</p>
<ol>
<li>通用选项,工作在所有套接字类型上</li>
<li>在套接字层次管理的选项,但是依赖于下层协议的支持</li>
<li>特定于某协议的选项,每个协议独有的</li>
</ol>
<p>可以使用 setsockopt函数来设置套接字选项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option, <span class="keyword">const</span> <span class="keyword">void</span> *val, <span class="keyword">socklen_t</span> len)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>参数 level标识了选项应用的协议。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254838324441.jpg" alt=""></p>
<p>参数val根据选项的不同指向一个数据结构或者一个整数。一些选项是on/off开关。如果整数非0,则启用选项。如果整数为0,则禁止选项。参数len指定了val指向的对象的大小</p>
<p>可以使用getsockopt来查看选项的当前值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option, <span class="keyword">void</span> *<span class="keyword">restrict</span> val, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> lenp)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="带外数据"><a href="#带外数据" class="headerlink" title="带外数据"></a>带外数据</h2><p>带外数据( out-of-band data)是一些通信协议所支持的可选功能,与普通数据相比,它允许更高优先级的数据传输。带外数据先行传输,即使传输队列已经有数据。TCP支持带外数据,但是UDP不支持。套接字接口对带外数据的支持很大程度上受TCP带外数据具体实现的影响。TCP将带外数据称为紧急数据( urgent data)。</p>
<p>TCP仅支持一个字节的紧急数据,但是允许紧急数据在普通数据传递机制数据流之外传输。</p>
<h2 id="非阻塞和异步I-O"><a href="#非阻塞和异步I-O" class="headerlink" title="非阻塞和异步I/O"></a>非阻塞和异步I/O</h2><p>在基于套接字的异步LO中,当从套接字中读取数据时,或者当套接字写队列中空间变得可用时,可以安排要发送的信号 SIGIO。</p>
<p>启用异步IO是一个两步骤的过程</p>
<ol>
<li>建立套接字所有权,这样信号可以被传递到合适的进程</li>
<li>通知套接字当IO操作不会阻塞时发信号</li>
</ol>
<p>可以使用3种方式来完成第一个步骤</p>
<ul>
<li>在fcnt1中使用 F_SETOWN命令</li>
<li>在ioct1中使用 FIOSETOWN命令</li>
<li>在ioctl中使用 SIOCSPGRP命令</li>
</ul>
<p>要完成第二个步骤,有两个选择</p>
<ul>
<li>在fcnt1中使用F_SETFL命令并且启用文件标志O_ASYNO</li>
<li>在ioctl中使用FI命令</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第16章 网络IPC：套接字 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 进程间通信</title>
    <link href="https://www.liuin.cn/2018/05/04/APUE-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://www.liuin.cn/2018/05/04/APUE-进程间通信/</id>
    <published>2018-05-04T06:00:08.000Z</published>
    <updated>2018-05-27T12:01:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第15章 进程间通信 笔记</p>
<a id="more"></a>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道是UNX系统IPC的最古老形式,所有UNX系统都提供此种通信机制。</p>
<p>管道有以下两种局限性：</p>
<ol>
<li>历史上,它们是半双工的(即数据只能在一个方向上流动)。现在,某些系统提供全双工管道,但是为了最佳的可移植性,我们决不应预先假定系统支持全双工管道</li>
<li>管道只能在具有公共祖先的两个进程之间使用。通常,一个管道由一个进程创建,在进程调用fork之后,这个管道就能在父进程和子进程之间使用了。</li>
</ol>
<p>每当在管道中键入一个命令序列,让shell执行时,shell都会为每一条命令单独创建一个进程,然后用管道将前一条命令进程的标准输出与后一条命令的标准输入相连接。</p>
<p>管道是通过调用pipe函数创建的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</div><div class="line"></div><div class="line">Returns: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</div></pre></td></tr></table></figure>
<p>经由参数fd返回两个文件描述符:fd[0]为读而打开,fd[1]为写而打开。fd[1]的输出是fd[0]的输入。</p>
<p>单个进程中的管道几乎没有任何用处。通常,进程会先调用pipe,接着调用fork,从而创建从父进程到子进程的IPC通道,反之亦然</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254214499352.jpg" alt=""></p>
<p>对于一个从子进程到父进程的管道,父进程关闭fd[1],子进程关闭fd[0]当管道的一端被关闭后,下列两条规则起作用。<br>(1)当读(read)一个写端已被关闭的管道时,在所有数据都被读取后,read返回0,表示文件结束。(从技术上来讲,如果管道的写端还有进程,就不会产生文件的结束。可以复制一个管道的描述符,使得有多个进程对它具有写打开文件描述符。但是,通常一个管道只有一个读进程和一个写进程。）<br>(2)如果写(write)一个读端已被关闭的管道,则产生信号 SIGPIPE。如果忽略该信号或者捕捉该信号并从其处理程序返回,则 write返回-1, errno设置为 EPIPE。</p>
<h2 id="函数popen和pclose"><a href="#函数popen和pclose" class="headerlink" title="函数popen和pclose"></a>函数popen和pclose</h2><p>常见的操作是创建一个连接到另一个进程的管道,然后读其输出或向其输入端发送数据,为此,标准I/O库提供了两个函数 popen和 pclose。这两个函数实现的操作是:创建一个管道,fork一个子进程,关闭未使用的管道端,执行一个shell运行命令,然后等待命令终止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">`<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function">FILE *<span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</div><div class="line"><span class="comment">// Returns: ﬁle pointer if OK, NULL on error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *fp)</span></span>; </div><div class="line"><span class="comment">// Returns: termination status of cmdstring, or −1 on error</span></div></pre></td></tr></table></figure>
<p>函数 popen先执行fork,然后调用exec执行cstring,并且返回一个标准I/O文件指针。如果type是”r”,则文件指针连接到cstring的标准输出。如果type是”w”,则文件指针连接到 cmdstring的标准输入，表示写FILE中的东西</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254216672075.jpg" alt=""></p>
<p>可以将最后一个参数的使用方法和fopen类比，如果type是”r”,则返回的文件指针是可读的,如果type是”w”,则是可写的</p>
<h2 id="协同进程"><a href="#协同进程" class="headerlink" title="协同进程"></a>协同进程</h2><p>UNIX系统过滤程序从标准输入读取数据,向标准输出写数据。几个过滤程序通常在shell管道中线性连接。当一个过滤程序既产生某个过滤程序的输入,又读取该过滤程序的输出时,它就变成了协同进程(coprocess)。</p>
<p>协同进程通常在shell的后台运行,其标准输入和标准输出通过管道连接到另一个程序。</p>
<p>popen只提供连接到另一个进程的标准输入或标准输出的一个单向管道,而协同进程则有连接到另一个进程的两个单向管道:一个接到其标准输入,另一个则来自其标准输出。</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254220325027.jpg" alt=""></p>
<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>FIFO有时被称为命名管道。未命名的管道只能在两个相关的进程之间使用,而且这两个相关的进程还要有一个共同的创建了它们的祖先进程。但是,通过FIFO,不相关的进程也能交换数据。</p>
<p>FIFO是一种文件类型。通过<code>stat</code>结构的<code>st_mode</code>成员的编码可以知道文件是否是FIFO类型。可以用S_ ISFTEO宏对此进行测试。</p>
<p><strong>创建FIFO类似于创建文件</strong>。确实,FIFO的路径名存在于文件系统中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>当我们用 mkfifo或者 mkfifoat创建FIFO时,要用open来打开它。设置非阻塞以及对错误的处理和普通文件的处理是一样的。</p>
<p>类似于管道,若 write一个尚无进程为读而打开的FIFO,则产生信号SIGPIPE。若某个FIFO的最后一个写进程关闭了该FIFO,则将为该FIFO的读进程产生一个文件结束标志。</p>
<p>FIFO有以下两种用途</p>
<ul>
<li>shell命令使用FIFO将数据从一条管道传送到另一条时,无需创建中间临时文件</li>
<li>客户进程服务器进程应用程序中,FIFO用作汇聚点,在客户进程和服务器进程二者之间传递数据</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-05-04-15254224287657.jpg" alt=""></p>
<h2 id="XSI-IPC"><a href="#XSI-IPC" class="headerlink" title="XSI IPC"></a>XSI IPC</h2><p>有3种称作XSI IPC的IPC:消息队列、信号量以及共享存储器。它们之间有很多相似之处</p>
<h3 id="标识符与键"><a href="#标识符与键" class="headerlink" title="标识符与键"></a>标识符与键</h3><p>每个内核中的IPC结构(消息队列、信号量或共享存储段)都用一个非负整数的标识符(identifier)加以引用。</p>
<p>标识符是IPC对象的内部名。为使多个合作进程能够在同一IPC对象上汇聚,需要提供一个外部命名方案。为此,每个IPC对象都与一个键(key)相关联,将这个键作为该对象的外部名。键的数据结构是<code>key_t</code></p>
<p>有多种方法使客户进程和服务器进程在同一IPC结构上汇聚：</p>
<ol>
<li>服务器进程可以指定键IPC_PRIVATE创建一个新IPC结构,将返回的标识符存放在某处(如一个文件)以便客户进程取用。</li>
<li>可以在一个公用头文件中定义一个客户进程和服务器进程都认可的键。</li>
<li>客户进程和服务器进程认同一个路径名和项目ID，接着调用函数ftok将这两个值变成一个键</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">key_t</span> ftok(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> id);</div><div class="line"></div><div class="line"><span class="comment">// Returns: key if OK, (key_t)−1 on error</span></div></pre></td></tr></table></figure>
<p>ftok创建的键通常是用下列方式构成的:按给定的路径名取得其stat结构中的部分 st_dev和 st_ino字段,然后再将它们与项目ID组合起来。如果两个路径名引用的是两个不同的文件,那么ftok通常会为这两个路径名返回不同的键。但是,因为i节点编号和键通常都存放在长整型中,所以创建键时可能会丢失信息。这意味着,对于不同文件的两个路径名,如果使用同一项目ID,那么可能产生相同的键。</p>
<p>3个get函数( msgget、 semget和 shmget)都有两个类似的参数:一个key和一个整型flag。在创建新的IPC结构(通常由服务器进程创建)时,如果key是 IPC_PRIVATE或者和当前某种类型的IPC结构无关,则需要指明fag的 IPC_CREAT标志位。为了引用一个现有队列(通常由客户进程创建),key必须等于队列创建时指明的key的值,并且 IPC_CREAT必须不被指明。</p>
<p>注意,决不能指定 IPC_PRIVATE作为键来引用一个现有队列,因为这个特殊的键值总是用于创建一个新队列。为了引用一个用 IPC_PRIVATE键创建的现有队列,一定要知道这个相关的标识符,然后在其他IPC调用中(如 msgsnd、 nserc)使用该标识符,这样可以绕过get函数</p>
<p>如果希望创建一个新的IPC结构,而且要确保没有引用具有同一标识符的一个现有IPC结构,那么必须在flag中同时指定 IPC_CREAT和IPC_EXCL位。这样做了以后,如果IPC结构已经存在就会造成出错,返回 EEXIST(这与指定了O_CREAT和O_EXCL标志的open相类似)</p>
<h3 id="权限结构"><a href="#权限结构" class="headerlink" title="权限结构"></a>权限结构</h3><p>XSI IPC为每一个IPC结构关联了一个ipc_perm结构。该结构规定了权限和所有者,它至少包括下列成员:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct ipc_perm &#123; </div><div class="line">    uid_t uid; /* owner’s effective user ID */ </div><div class="line">    gid_t gid; /* owner’s effective group ID */ </div><div class="line">    uid_t cuid; /* creator’s effective user ID */ </div><div class="line">    gid_t cgid; /* creator’s effective group ID */ </div><div class="line">    mode_t mode; /* access modes */ </div><div class="line">    .</div><div class="line">    .</div><div class="line">    .</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>每个实现会包括另外一些成员。在创建IPC结构时,对所有字段都赋初值。</p>
<p>mode字段的值如下图所示，<strong>对于任何IPC结构都不存在执行权限</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274218221632.jpg" alt=""></p>
<h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><p>XSI IPC的一个基本问题是:<strong>IPC结构是在系统范围内起作用的,没有引用计数</strong>。例如,如果进程创建了一个消息队列,并且在该队列中放入了几则消息,然后终止,那么该消息队列及其内容不会被删除。它们会一直留在系统中直至发生下列动作为止:由某个进程调用 msgrcv或msct1读消息或删除消息队列;或某个进程执行 ipcri(1)命令删除消息队列;或正在自举的系统删除消息队列。</p>
<p>将此与管道相比,当最后一个引用管道的进程终止时,管道就被完全地删除了。对于FIFO而言,在最后一个引用FIFO的进程终止时,虽然FIFO的名字仍保留在系统中,直至被显式地删除,但是留在FIFO中的数据已被删除了</p>
<p>XSI IPC的另一个问题是:这些IPC结构在文件系统中没有名字，为了支持这些IPC对象，系统增加了许多的系统调用</p>
<p>因为这些形式的IPC不使用文件描述符,所以<strong>不能对它们使用多路转接I/O函数</strong></p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是消息的链接表,<strong>存储在内核中</strong>,由消息队列标识符标识。</p>
<p><code>msgget</code>用于创建一个新队列或打开一个现有队列。<code>msgsnd</code>将新消息添加到队列尾端。每个消息包含一个正的长整型类型的字段、一个非负的长度以及实际数据字节数(对应于长度),所有这些都在将消息添加到队列时,传送给<code>msgsnd</code>。 <code>msgrcv</code>用于从队列中取消息。我们并不定要以先进先出次序取消息,也可以按消息的类型字段取消息。</p>
<p>每个队列有一个msqid_ds结构与其相关联</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254293881565.jpg" alt=""></p>
<p>创建一个队列或者打开一个现有队列函数<code>msgget</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: message queue ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>msgctl函数对队列执行多种操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf )</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>cmd参数指定对msqid队列要执行的命令：</p>
<ul>
<li>IPC_STAT  获取此队列的msqid_ds结构</li>
<li>IPC_SET  设置队列结构</li>
<li>IPC_RMID  从系统中删除该消息队列以及仍在该消息队列中的所有数据</li>
</ul>
<p>调用msgsnd将数据放到消息队列中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>消息类型结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> mymesg &#123; </div><div class="line">    <span class="keyword">long</span> mtype; <span class="comment">/* positive message type */</span> </div><div class="line">    <span class="keyword">char</span> mtext[<span class="number">512</span>]; <span class="comment">/* message data, of length nbytes */</span> </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>msgrcv从队列中取用消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> msgrcv(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes, <span class="keyword">long</span> type, <span class="keyword">int</span> ﬂag); </div><div class="line"></div><div class="line"><span class="comment">// Returns: size of data portion of message if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量与已经介绍过的IPC机构(管道、FIFO以及消息列队)不同。它是一个计数器,用于为多个进程提供对共享数据对象的访问</p>
<p>为了正确地实现信号量,信号量值的测试及减1操作应当是原子操作。为此,信号量通常是在内核中实现的</p>
<p>常用的信号量形式被称为二元信号量(binary semaphore)。它控制单个资源,其初始值为1。但是,一般而言,信号量的初值可以是任意一个正值,该值表明有多少个共享资源单位可供共享应用。</p>
<p>下面3个特性造成了XSI信号量比较复杂：</p>
<ol>
<li>信号量并非是单个非负值,而必需定义为含有一个或多个信号量值的集合。</li>
<li>信号量的创建(semget)是独立于它的初始化(sectl)的。这是一个致命的缺点,因为不能原子地创建一个信号量集合,并且对该集合中的各个信号量值赋初值。</li>
<li>即使没有进程正在使用各种形式的XSI IPO,它们仍然是存在的。有的程序在终止时并没有释放已经分配给它的信号量,所以我们不得不为这种程序担心。</li>
</ol>
<p>当我们想使用XSI信号量时,首先需要通过调用函数 semget来获得一个信号量ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: semaphore ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>semctl函数包含对信号量的各种操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ... <span class="comment">/* union semun arg */</span> )</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: (see following)</span></div></pre></td></tr></table></figure></p>
<p>函数semop自动执行信号集合上面的操作数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">struct</span> sembuf semoparray[], <span class="keyword">size_t</span> nops)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>参数 semoparray是一个指针,它指向一个由 sembuf结构表示的信号量操作数组:</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254305267397.jpg" alt=""></p>
<h2 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h2><p>共享存储允许两个或多个进程共享一个给定的存储区。因为数据不需要在客户进程和服务器进程之间复制,所以这是最快的一种IPC。使用共享存储时要掌握的唯一窍门是,在多个进程之间同步访问一个给定的存储区。若服务器进程正在将数据放入共享存储区,则在它做完这一操作之前,客户进程不应当去取这些数据。通常,信号量用于同步共享存储访问。下面可以看到共享内存为什么是最快的一种IPC方式：</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274224200311.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-27-15274224241716.jpg" alt=""></p>
<p>我们已经看到了共享存储的一种形式,就是在多个进程将同一个文件映射到它们的地址空间的时候。XSI共享存储和内存映射的文件的不同之处在于,前者没有相关的文件。XSI共享存储段是内存的匿名段</p>
<p>内核为每一个共享存储段维护一个结构，包含以下成员：</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254405323155.jpg" alt=""></p>
<p>使用函数shmgget获取一个共享存储标识符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: shared memory ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>函数shmctl对共享存储段执行多种操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf )</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>一旦创建了一个共享存储段,进程就可调用 shmat将其连接到它的地址空间中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to shared memory segment if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>共享存储段连接到调用进程的哪个地址上与addr参数以及flag中是否指定SHM_RND位有关</p>
<ul>
<li>如果addr为0,则此段连接到由内核选择的第一个可用地址上。这是推荐的使用方式。</li>
<li>如果add非0,并且没有指定 SHM_RND,则此段连接到addr所指定的地址上。</li>
<li>如果add非0,并且指定了 SHM_RND,则此段连接到(addr-( addr mod SHMLBA))所表示的地址上。 SHM_RND命令的意思是“取整”。 SHMLBA的意思是“低边界地址倍数”,它总是2的乘方。该算式是将地址向下取最近1个 SHMLBA的倍数。</li>
</ul>
<p>当对共享存储段的操作已经结束时,则调用 shmdt与该段分离。注意,这<strong>并不从系统中删除其标识符以及其相关的数据结构</strong>。该标识符仍然存在,直至某个进程(一般是服务器进程)带IPC_RMID命令的调用shmctl特地删除它为止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *addr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>回忆一下mmap函数,它可将一个文件的若干部分映射至进程地址空间。这在概念上类似于用 shmat XSI IPC函数连接一个共享存储段。两者之间的主要区别是,用mmap映射的存储段是与文件相关联的,而XSI共享存储段则并无这种关联。</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254410116645.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第15章 进程间通信 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 高级I/O</title>
    <link href="https://www.liuin.cn/2018/05/04/APUE-%E9%AB%98%E7%BA%A7I-O/"/>
    <id>https://www.liuin.cn/2018/05/04/APUE-高级I-O/</id>
    <published>2018-05-04T02:25:32.000Z</published>
    <updated>2018-05-04T05:45:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第14章 高级I/O 笔记</p>
<a id="more"></a>
<h2 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h2><p>将系统调用分成两类:“低速”系统调用和其他。低速系统调用是可能会<strong>使进程永远阻塞的一类系统调用</strong>,包括:</p>
<ul>
<li>如果某些文件类型(如读管道、终端设备和网络设备)的数据并不存在,读操作可能会使调用者永远阻塞;</li>
<li>如果数据不能被相同的文件类型立即接受(如管道中无空间、网络流控制),写操作可能会使调用者永远阻塞</li>
<li>在某种条件发生之前打开某些文件类型可能会发生阻塞(如要打开一个终端设备,需要先等待与之连接的调制解调器应答,又如若以只写模式打开FIFO,那么在没有其他进程已用读模式打开该FIFO时也要等待)</li>
<li>对已经加上强制性记录锁的文件进行读写</li>
<li>某些ioctl操作;</li>
<li>某些进程间通信函数</li>
</ul>
<p>虽然读写磁盘文件会暂时阻塞调用者,但并不能将与磁盘I/O有关的系统调用视为“低速”。</p>
<p>非阻塞IO使我们可以发出open、read和 write这样的IO操作,并使这些操作不会永远阻塞。如果这种操作不能完成,则调用立即出错返回,表示该操作如继续执行将阻塞。</p>
<p>对于一个给定的描述符,有两种为其指定非阻塞I/O的方法。</p>
<ol>
<li>如果调用open获得描述符,则可指定<code>O_NONBLOCK</code>标志</li>
<li>对于已经打开的一个描述符,则可调用<code>fcntl</code>,由该函数打开<code>O_NONBLOCK</code>文件状态标志</li>
</ol>
<h2 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h2><p>记录锁(record locking)的功能是：当第一个进程正在读或修改文件的某个部分时,使用记录锁可以阻止其他进程修改同一文件区。对于UNIX系统而言,“记录”这个词是一种误用,因为UNIX系统内核根本没有使用文件记录这种概念。一个更适合的术语可能是字节范围锁(byte-range locking),因为它锁定的只是文件中的一个区域(也可能是整个文件)</p>
<p>设置记录锁的方法是使用fcntl函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* struct flock *ﬂockptr */</span> )</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: depends on cmd if OK (see following), −1 on error</span></div></pre></td></tr></table></figure></p>
<p>对于记录锁,cmd是<code>F_GETLK</code>、<code>F_SELK</code>或<code>F_SETLKW</code>。第三个参数(我们将调用<code>flockptr</code>)是一个指向flock结构的指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct flock &#123; </div><div class="line">    short l_type; /* F_RDLCK, F_WRLCK, or F_UNLCK */ </div><div class="line">    short l_whence; /* SEEK_SET, SEEK_CUR, or SEEK_END */ </div><div class="line">    off_t l_start; /* offset in bytes, relative to l_whence */ </div><div class="line">    off_t l_len; /* length, in bytes; 0 means lock to EOF */ </div><div class="line">    pid_t l_pid; /* returned with F_GETLK */ </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>flock结构说明如下：</p>
<ul>
<li>所希望的锁类型:<code>F_RDLCK</code>(共享读锁)、<code>F_WRLCK</code>(独占性写锁)或<code>F_UNLCK</code>(解锁个区域)。</li>
<li>要加锁或解锁区域的起始字节偏移量(<code>l_start</code>和<code>l_whence</code>)。</li>
<li>区域的字节长度(1_1en)。</li>
<li>进程的ID(l_pid)持有的锁能阻塞当前进程(仅由F_GETLK返回)</li>
</ul>
<p>上面提到了两种类型的锁:共享读锁和独占性写锁。基本规则是:任意多个进程在一个给定的字节上可以有一把共享的读锁,但是在一个给定字节上只能有一个进程有把独占写锁。</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254024702844.jpg" alt=""></p>
<p>在设置或释放文件上的一把锁时,系统按要求组合或分裂相邻区。其中一个部分解锁的时候进程分裂，再次将这个区域加锁的时候进行合并。</p>
<blockquote>
<p>锁的隐含继承和释放</p>
</blockquote>
<p>关于记录锁的自动继承和释放有3条规则：</p>
<ol>
<li>锁与进程和文件两者相关联。这有两重含义:第一重很明显,当一个进程终止时,它所建立的锁全部释放;第二重则不太明显,无论一个描述符何时关闭,<strong>该进程通过这一描述符引用的文件上的任何一把锁都会释放</strong>(这些锁都是该进程设置的)。</li>
<li>由fork产生的子进程不继承父进程所设置的锁</li>
<li>在执行exec后,新程序可以继承原执行程序的锁。但是注意,如果对一个文件描述符设置了执行时关闭标志,那么当作为exec的一部分关闭该文件描述符时,将释放相应文件的所有锁。</li>
</ol>
<blockquote>
<p>FreeBSD实现</p>
</blockquote>
<p><img src="https://data2.liuin.cn/2018-05-04-15254027539830.jpg" alt=""></p>
<h2 id="I-O多路转接"><a href="#I-O多路转接" class="headerlink" title="I/O多路转接"></a>I/O多路转接</h2><p>有的时候我们需要从多个文件描述符读的时候，我们不能在任一个描述符上进行阻塞读(read),否则可能会因为被阻塞在一个描述符的读操作上而导致另一个描述符即使有数据也无法处理。</p>
<p>一种比较好的技术是使用I/O多路转接(I/O multiplexing)。为了使用这种技术,先构造一张我们感兴趣的描述符(通常都不止一个)的列表,然后调用一个函数,直到这些描述符中的一个已准备好进行I/O时,该函数才返回。</p>
<h3 id="函数select和pselect"><a href="#函数select和pselect" class="headerlink" title="函数select和pselect"></a>函数select和pselect</h3><p>在所有POSIX兼容的平台上, select函数使我们可以执行I/O多路转接。传给se1ect的参数告诉内核:</p>
<ul>
<li>我们所关心的描述符:</li>
<li>对于每个描述符我们所关心的条件(是否想从一个给定的描述符读,是否想写一个给定的描述符,是否关心一个给定描述符的异常条件)</li>
<li>愿意等待多长时间(可以永远等待、等待一个固定的时间或者根本不等待)</li>
<li>从se1ect返回时,内核告诉我们已准备好的描述符的总数量</li>
<li>对于读、写或异常这3个条件中的每一个,哪些描述符已准备好</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *<span class="keyword">restrict</span> readfds, fd_set *<span class="keyword">restrict</span> writefds, fd_set *<span class="keyword">restrict</span> exceptfds, <span class="keyword">struct</span> timeval *<span class="keyword">restrict</span> tvptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, −1 on error</span></div></pre></td></tr></table></figure>
<p>中间3个参数 readfds、 writefds和exceptfds是指向描述符集的指针。这3个描述符集说明了我们关心的可读、可写或处于异常条件的描述符集合。每个描述符集存储在一个<code>fd_set</code>数据类型中。这个数据类型是由实现选择的,它可以为每一个可能的描述符保持一位。</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254037628736.jpg" alt=""></p>
<p>对于<code>fd_set</code>数据类型,唯一可以进行的处理是:分配一个这种类型的变量,将这种类型的一个变量值赋给同类型的另一个变量,或对这种类型的变量使用下列4个函数中的一个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</div><div class="line"><span class="comment">// Returns: nonzero if fd is in set, 0 otherwise</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;</div></pre></td></tr></table></figure>
<p>另外一个select函数的变体pselect：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *<span class="keyword">restrict</span> readfds, fd_set *<span class="keyword">restrict</span> writefds, fd_set *<span class="keyword">restrict</span> exceptfds, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> sigmask)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, −1 on error</span></div></pre></td></tr></table></figure>
<p>和select的不同点在于：</p>
<ul>
<li>超时使用的数据结构不一样，能够提供更加精准的超时时间</li>
<li>超时值被声明为const，保证了pselect不会改变这一个值</li>
<li>可使用可选信号屏蔽字</li>
</ul>
<h3 id="函数poll"><a href="#函数poll" class="headerlink" title="函数poll"></a>函数poll</h3><p>poll函数和select差不多，就是函数的接口不一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd fdarray[], <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, −1 on error</span></div></pre></td></tr></table></figure>
<p>与 select不同,pol1不是为每个条件(可读性、可写性和异常条件)构造一个描述符集,而是构造一个po11fd结构的数组,每个数组元素指定一个描述符编号以及我们对该描述符感兴趣的条件。</p>
<h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h2><p>在用异步I/O的时候,要通过选择来灵活处理多个并发操作,这会使应用程序的设计复杂化。更简单的做法可能是使用多线程,使用同步模型来编写程序,并让这些线程以异步的方式运行。</p>
<p>使用POSIX异步I/O接口，会带来这些麻烦：</p>
<ul>
<li>每个异步操作有3处可能产生错误的地方:一处在操作提交的部分,一处在操作本身的结果,还有一处在用于决定异步操作状态的函数中。</li>
<li>设计大量额外的设置和处理规则</li>
<li>从错误中恢复会比较困难</li>
</ul>
<h2 id="函数readv和writev"><a href="#函数readv和writev" class="headerlink" title="函数readv和writev"></a>函数readv和writev</h2><p>readv和 writev函数用于在一次函数调用中读、写多个非连续缓冲区。有时也将这两个函数称为散布读(scatter read)和聚集写(gather write)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> readv(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">struct</span> iovec *iov, <span class="keyword">int</span> iovcnt);</div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> writev(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">struct</span> iovec *iov, <span class="keyword">int</span> iovcnt);</div><div class="line"></div><div class="line"><span class="comment">// Both return: number of bytes read or written, −1 on error</span></div></pre></td></tr></table></figure>
<p>其中中间参数的数据结构iov如下：</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254044988663.jpg" alt=""></p>
<h2 id="函数readn和writen"><a href="#函数readn和writen" class="headerlink" title="函数readn和writen"></a>函数readn和writen</h2><p>管道、FIFO以及某些设备(特别是终端和网络)有下列两种性质</p>
<ol>
<li>一次read操作所返回的数据可能少于所要求的数据,即使还没达到文件尾端也可能是这样。这不是一个错误,应当继续读该设备。</li>
<li>一次 write操作的返回值也可能少于指定输出的字节数。</li>
</ol>
<p>下面两个函数 readn和 writen的功能分别是读、写指定的N字节数据,并处理返回值可能小于要求值的情况。这两个函数只是按需多次调用xead和 write直至读、写了N字节数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span> </span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); </div><div class="line"><span class="keyword">ssize_t</span> writen(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); </div><div class="line"></div><div class="line"><span class="comment">// Both return: number of bytes read or written, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="存储映射I-O"><a href="#存储映射I-O" class="headerlink" title="存储映射I/O"></a>存储映射I/O</h2><p>存储映射I/O(memory-mapped I/O)能<strong>将一个磁盘文件映射到存储空间中的一个缓冲区上</strong>。于是,当从缓冲区中取数据时,就相当于读文件中的相应字节。与此类似,将数据存入缓冲区时相应字节就自动写入文件。这样,就可以在不使用read和 write的情况下执行I/O。</p>
<p>为了使用这种功能,应首先告诉内核将一个给定的文件映射到一个存储区域中。这是由mmap函数实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> ﬂag, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> off )</span></span>; </div><div class="line"><span class="comment">// Returns: starting address of mapped region if OK, MAP_FAILED on error</span></div></pre></td></tr></table></figure>
<p>addr参数用于指定映射存储区的起始地址。通常将其设置为0,这表示由系统选择该映射区的起始地址。此函数的返回值是该映射区的起始地址。</p>
<p>fd参数是指定要被映射文件的描述符。在文件映射到地址空间之前,必须先打开该文件。len参数是映射的字节数,off是要映射字节在文件中的起始偏移量</p>
<p>prot参数指定了映射存储区的保护要求</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254123464536.jpg" alt=""></p>
<p>存储映射文件的基本情况</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254124013724.jpg" alt=""></p>
<p>flag参数可以使用的属性：</p>
<ul>
<li>MAP_FIXED  返回值必须等于addr。因为这不利于可移植性,所以不鼓励使用此标志。</li>
<li>MAP_SHARED  这一标志描述了本进程对映射区所进行的存储操作的配置。此标志指定存储操作修改映射文件,也就是,存储操作相当于对该文件的 write</li>
<li>MAP_PRIVATE  本标志说明,对映射区的存储操作导致创建该映射文件的一个私有副本</li>
</ul>
<p>off的值和addr的值(如果指定了 MAP_FIXED)通常被要求是系统虚拟存储页长度的倍数</p>
<p>与映射区相关的信号有 SIGSEGV和 SIGBUS:</p>
<ul>
<li>信号 SIGSEGV通常用于指示进程试图访问对它不可用的存储区。如果映射存储区被map指定成了只读的,那么进程试图将数据存入这个映射存储区的时候,也会产生此信号。</li>
<li>如果映射区的某个部分在访问时已不存在,则产生 SIGBUS信号。例如,假设用文件长度映射了一个文件,但在引用该映射区之前,另一个进程已将该文件截断。此时,如果进程试图访问对应于该文件已截去部分的映射区,将会接收到 SIGBUS信号</li>
</ul>
<p><strong>子进程能通过fork继承存储映射区</strong>(因为子进程复制父进程地址空间,而存储映射区是该地址空间的一个部分），新程序则不能通过exec继承存储映射区</p>
<p>调用mprotect可以更改一个现有映射的权限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>如果共享映射中的页已修改,那么可以调用 msync将该页冲洗到被映射的文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> ﬂags)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>如果映射是私有的,那么不修改被映射的文件。与其他存储映射函数一样,地址必须与页边界对齐。</p>
<p>当进程终止时,会自动解除存储映射区的映射,或者直接调用 munmap函数也可以解除映射区。关闭映射存储区时使用的文件描述符并不解除映射区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第14章 高级I/O 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 守护进程</title>
    <link href="https://www.liuin.cn/2018/05/04/APUE-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
    <id>https://www.liuin.cn/2018/05/04/APUE-守护进程/</id>
    <published>2018-05-04T01:06:24.000Z</published>
    <updated>2018-05-04T01:35:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第13章 守护进程 笔记</p>
<a id="more"></a>
<p>守护进程(daemon)是生存期长的一种进程。它们常常在系统引导装入时启动,仅在系统关闭时才终止。因为它们没有控制终端,所以说它们是在后台运行的。UNIX系统有很多守护进程,它们执行日常事务活动。</p>
<h2 id="守护进程的特征"><a href="#守护进程的特征" class="headerlink" title="守护进程的特征"></a>守护进程的特征</h2><p>系统进程依赖于操作系统实现。父进程ID为0的各进程通常是内核进程,它们作为系统引导装入过程的一部分而启动。(init是个例外,它是一个由内核在引导装入时启动的用户层次的命令。)内核进程是特殊的,通常存在于系统的整个生命期中。它们以超级用户特权运行,无控制终端,无命令行。</p>
<p>对于需要在进程上下文执行工作但却不被用户层进程上下文调用的每一个内核组件,通常有它自己的内核守护进程。例如,在Linux中</p>
<ul>
<li><code>kswapd</code>守护进程也称为内存换页守护进程。它支持虚拟内存子系统在经过一段时间后将脏页面慢慢地写回磁盘来回收这些页面</li>
<li><code>f1ush</code>守护进程在可用内存达到设置的最小阅值时将脏页面冲洗至磁盘。它也定期地将脏页面冲洗回磁盘来减少在系统出现故障时发生的数据丢失。多个冲洗守护进程可以同时存在,每个写回的设备都有一个冲洗守护进程。</li>
<li><code>sync_supers</code>守护进程定期将文件系统元数据冲洗至磁盘。</li>
<li><code>jbd</code>守护进程帮助实现了ext4文件系统中的日志功能。</li>
<li><code>cron</code>守护进程在定期安排的日期和时间执行命令。许多系统管理任务是通过<code>cron</code>每隔一段固定的时间就运行相关程序而得以实现的。</li>
<li><code>atd</code>守护进程与cron类似,它允许用户在指定的时间执行任务,但是每个任务它只执行一次,而非在定期安排的时间反复执行。</li>
<li><code>cupsa</code>守护进程是个打印假脱机进程,它处理对系统提出的各个打印请求。</li>
<li><code>sshd</code>守护进程提供了安全的远程登录和执行设施注意,大多数守护进程都以超级用户(root)特权运行。所有的守护进程都没有控制终端其终端名设置为问号。</li>
</ul>
<p>内核守护进程以无控制终端方式启动。用户层守护进程缺少控制终端可能是守护进程调用了 setid的结果。</p>
<h2 id="编程规则"><a href="#编程规则" class="headerlink" title="编程规则"></a>编程规则</h2><p>在编写守护进程程序时需遵循一些基本规则,以防止产生不必要的交互作用。下面先说明这些规则,</p>
<ol>
<li>首先要做的是调用<code>umask</code>将文件模式创建屏蔽字设置为一个已知值(通常是0)。由继承得来的文件模式创建屏蔽字可能会被设置为拒绝某些权限。如果守护进程要创建文件,那么它可能要设置特定的权限。</li>
<li>调用fork,然后使父进程exit。这样做实现了下面几点。第一,如果该守护进程是作为一条简单的shell命令启动的,那么父进程终止会让shell认为这条命令已经执行完毕。第二,虽然子进程继承了父进程的进程组ID,但获得了一个新的进程ID,这就保证了子进程不是一个进程组的组长进程。这是下面将要进行的setid调用的先决条件。</li>
<li>调用setid创建一个新会话，执行3步：成为新会话的首进程、成为新进程组的组长进程、没有控制终端</li>
<li>将当前工作目录更改为根目录</li>
<li>关闭不再需要的文件描述符</li>
<li>某些守护进程打开<code>/dev/null</code>使其具有文件描述符0、1和2,这样,任何一个试图读标准输入、写标准输出或标准错误的库例程都不会产生任何效果。因为守护进程并不与终端设备相关联所以其输出无处显示,也无处从交互式用户那里接收输入。</li>
</ol>
<h2 id="出错记录"><a href="#出错记录" class="headerlink" title="出错记录"></a>出错记录</h2><p>守护进程存在的一个问题是如何处理出错消息。因为它本就不应该有控制终端,所以不能只是简单地写到标准错误上。我们不希望所有守护进程都写到控制台设备上,因为在很多工作站上控制台设备都运行着一个窗口系统。我们也不希望每个守护进程将它自己的出错消息写到一个单独的文件中。对任何一个系统管理人员而言,如果要关心哪一个守护进程写到哪一个记录文件中并定期地检查这些文件,那么一定会使他感到头痛。所以,需要有一个集中的守护进程出错记录设施。</p>
<p>BSD的<code>sys1og</code>设施得到了广泛的应用。大多数守护进程都使用这一设施</p>
<p>有下面3种产生日志消息的方法：</p>
<ol>
<li>内核例程可以调用log函数</li>
<li>大多数用户进程(守护进程)调用sys1og(3)函数来产生日志消息</li>
<li>无论一个用户进程是在此主机上,还是在通过TCP/IP网络连接到此主机的其他主机上,都可将日志消息发向UDP端口514。</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-05-04-15253968653919.jpg" alt=""></p>
<p>通常, syslogd守护进程读取所有3种格式的日志消息。此守护进程在启动时读一个配置文件,其文件名一般为<code>/etc/sys1og.conf</code>,该文件决定了不同种类的消息应送向何处。例如,紧急消息可发送至系统管理员(若已登录),并在控制台上打印,而警告消息则可记录到一个文件中。</p>
<p>该设施的接口是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">openlog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ident, <span class="keyword">int</span> option, <span class="keyword">int</span> facility)</span></span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">(<span class="keyword">void</span>)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setlogmask</span><span class="params">(<span class="keyword">int</span> maskpri)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: previous log priority mask value</span></div></pre></td></tr></table></figure></p>
<h2 id="单实例守护进程"><a href="#单实例守护进程" class="headerlink" title="单实例守护进程"></a>单实例守护进程</h2><p>为了正常运作,某些守护进程会实现为,在任一时刻只运行该守护进程的一个副本。例如,这种守护进程可能需要排它地访问一个设备。对cron守护进程而言,如果同时有多个实例运行,那么每个副本都可能试图开始某个预定的操作,于是造成该操作的重复执行,这很可能导致出错。</p>
<p>文件和记录锁机制为一种方法提供了基础,该方法保证一个守护进程只有一个副本在运行。</p>
<h2 id="守护进程的惯例"><a href="#守护进程的惯例" class="headerlink" title="守护进程的惯例"></a>守护进程的惯例</h2><p>在UNIX系统中,守护进程遵循下列通用惯例：</p>
<ol>
<li>若守护进程使用锁文件,那么该文件通常存储在<code>/var/run</code>目录中</li>
<li>若守护进程支持配置选项,那么配置文件通常存放在<code>/etc</code>目录中</li>
<li>守护进程可用命令行启动,但通常它们是由系统初始化脚本之一(<code>/etc/rc*</code>或<code>etc/init.d/*</code>)启动的。如果在守护进程终止时,应当自动地重新启动它,则我们可在<code>/etc/inittab</code>中为该守护进程包括 respawn记录项,这样,init就将重新启动该守护进程。</li>
<li>若一个守护进程有一个配置文件,那么当该守护进程启动时会读该文件,但在此之后般就不会再查看它。若某个管理员更改了配置文件,那么该守护进程可能需要被停止,然后再启动,以使配置文件的更改生效。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第13章 守护进程 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 线程控制</title>
    <link href="https://www.liuin.cn/2018/05/02/APUE-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://www.liuin.cn/2018/05/02/APUE-线程控制/</id>
    <published>2018-05-02T09:15:42.000Z</published>
    <updated>2018-05-25T10:18:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第12章 线程控制 笔记</p>
<a id="more"></a>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>pthread接口允许我们通过设置每个对象关联的不同属性来细调线程和同步对象的行为。通常,管理这些属性的函数都遵循相同的模式</p>
<ul>
<li>每个对象与它自己类型的属性对象进行关联</li>
<li>有一个初始化函数,把属性设置为默认值。</li>
<li>还有一个销毁属性对象的函数。</li>
<li>每个属性都有一个从属性对象中获取属性值的函数</li>
<li>每一个属性都有一个设置属性值的函数</li>
</ul>
<p>可以使用<code>pthread_attr_t</code>结构修改线程默认属性,并把这些属性与创建的线程联系起来。可以使用 <code>pthread_attr_init</code>函数初始化<code>pthread_attr_t</code>结构。在调用<code>pthread_attr_init</code>以后, <code>pthread_attr_t</code>结构所包含的就是操作系统实现支持的所有线程属性的默认值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>POSIX.1定义的线程属性：</p>
<p><img src="https://data2.liuin.cn/2018-05-02-15252530369029.jpg" alt=""></p>
<blockquote>
<p>detachstate 属性</p>
</blockquote>
<p>如果在创建线程时就知道不需要了解线程的终止状态,就可以修改<code>pthread_attr_t</code>结构中的<code>detachstate</code>线程属性,让线程一开始就处于分离状态。可以使用 pthread_attr_setdetachstate函数把线程属性 detachstate设置成以下两个合法值之一: PTHREAD_CREATE_DETACHED,以分离状态启动线程:或者 PTHREAD_CREATE_JOINABLE,正常启动线程,应用程序可以获取线程的终止状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *detachstate)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> detachstate)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<blockquote>
<p>stackaddr 属性</p>
</blockquote>
<p>对线程栈属性进行管理的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstack</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">void</span> **<span class="keyword">restrict</span> stackaddr, <span class="keyword">size_t</span> *<span class="keyword">restrict</span> stacksize)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstack</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *stackaddr, <span class="keyword">size_t</span> stacksize)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>对于进程来说,虚地址空间的大小是固定的。因为进程中只有一个栈,所以它的大小通常不是问题。但对于线程来说,同样大小的虚地址空间必须被所有的线程栈共享。如果应用程序使用了许多线程,以致这些线程栈的累计大小超过了可用的虚地址空间,就需要减少默认的线程栈大小。</p>
<p>另一方面,如果线程调用的函数分配了大量的自动变量,或者调用的函数涉及许多很深的栈帧(stack frame),那么需要的栈大小可能要比默认的大。</p>
<p>如果线程栈的虚地址空间都用完了,那可以使用ma1loc或者mnap来为可替代的栈分配空间,并用<code>pthread _attr_setstack</code>函数来改变新建线程的栈位置。由 tackaddr参数指定的地址可以用作线程栈的内存范围中的<strong>最低可寻址地址</strong>,该地址与处理器结构相应的边界应对齐。当然,这要假设ma11oc和mmap所用的虚地址范围与线程栈当前使用的虚地址范围不同。</p>
<blockquote>
<p>stacksize 属性</p>
</blockquote>
<p>stackaddr线程属性被定义为栈的最低内存地址,但这并不一定是栈的开始位置。对于一个给定的处理器结构来说,如果栈是从高地址向低地址方向增长的,那么 stackaddi线程属性将是栈的结尾位置,而不是开始位置</p>
<p>管理线程属性<code>stacksize</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstacksize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">size_t</span> *<span class="keyword">restrict</span> stacksize)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstacksize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> stacksize)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>如果希望<strong>改变默认的栈大小,但又不想自己处理线程栈的分配问题</strong>,这时使用 <code>pthread_attr_setstacksize</code>函数就非常有用。</p>
<blockquote>
<p>guardsize 属性</p>
</blockquote>
<p>线程属性guardsize控制着线程栈末尾之后用以避免栈溢出的扩展内存的大小这个属性默认值是由具体实现来定义的,但常用值是系统页大小。可以把 guardsize线程属性设置为0,不允许属性的这种特征行为发生:在这种情况下,不会提供警戒缓冲区。同样,如果修改了线程属性stackadar,系统就认为我们将自己管理栈,进而使栈警戒缓冲区机制无效,这等同于把 guardsize线程属性设置为0。</p>
<p>管理线程属性<code>guardsize</code>属性的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getguardsize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">size_t</span> *<span class="keyword">restrict</span> guardsize)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setguardsize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> guardsize)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>如果 guardsize线程属性被修改了,操作系统可能会把它取为页大小的整数倍。如果线程的栈指针溢出到警戒区域,应用程序就可能通过信号接收到出错信息。</p>
<h2 id="同步属性"><a href="#同步属性" class="headerlink" title="同步属性"></a>同步属性</h2><h3 id="互斥量属性"><a href="#互斥量属性" class="headerlink" title="互斥量属性"></a>互斥量属性</h3><p>互斥量属性是用<code>pthread_mutexattr_t</code>结构表示的，其初始化和销毁函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>值得注意的3个属性是:进程共享属性、健壮属性以及类型属性</p>
<p>存在这样的机制:允许相互独立的多个进程把同一个内存数据块映射到它们各自独立的地址空间中。就像多个线程访问共享数据一样,多个进程访问共享数据通常也需要同步。如果进程共享互斥量属性设置为<code>PTHREAD_PROCESS_SHARED</code>,从多个进程彼此之间共享的内存数据块中分配的互斥量就可以用于这些进程的同步</p>
<p>获得和修改进程共享属性的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>进程共享互斥量属性设置为<code>PTHREAD_PROCESS_PRIVATE</code>时,允许pthread线程库提供更有效的互斥量实现,这在多线程应用程序中是默认的情况。在多个进程共享多个互斥量的情况下,pthread线程库可以限制开销较大的互斥量实现。</p>
<p>互斥量健壮属性与在多个进程间共享的互斥量有关。这意味着,当持有互斥量的进程终止时需要解决互斥量状态恢复的问题。这种情况发生时,互斥量处于锁定状态,恢复起来很困难。</p>
<p>获取和设置互斥量健壮属性的函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getrobust</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> robust)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setrobust</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> robust)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure></p>
<h3 id="读写锁属性"><a href="#读写锁属性" class="headerlink" title="读写锁属性"></a>读写锁属性</h3><p>读写锁和互斥量类似，都有属性，用数据结构<code>pthread_rwlockattr_t</code>表示，初始化和反初始化函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_init</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_destroy</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>读写锁支持的唯一属性是进程共享属性。它与互斥量的进程共享属性是相同的。有一对函数用于读取和设置读写锁的进程共享属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_setpshared</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="条件变量属性"><a href="#条件变量属性" class="headerlink" title="条件变量属性"></a>条件变量属性</h3><p>目前定义了条件变量的两个属性:<strong>进程共享属性和时钟属性</strong>，用数据结构<code>pthread_condattr_t</code>表示，初始化和反初始化函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_init</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_destroy</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>获取和设置进程共享属性的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_setpshared</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>时钟属性控制计算<code>pthread_cond_timedwait</code>函数的超时参数(sp)时采用的是哪个时钟，相关函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_getclock</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">clockid_t</span> *<span class="keyword">restrict</span> clock_id)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_setclock</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr, <span class="keyword">clockid_t</span> clock_id)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="屏障属性"><a href="#屏障属性" class="headerlink" title="屏障属性"></a>屏障属性</h3><p>初始化和反初始化函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_init</span><span class="params">(<span class="keyword">pthread_barrierattr_t</span> *attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_destroy</span><span class="params">(<span class="keyword">pthread_barrierattr_t</span> *attr)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>目前定义的屏障属性只有进程共享属性,它控制着屏障是可以被多进程的线程使用,还是只能被初始化屏障的进程内的多线程使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_barrierattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_setpshared</span><span class="params">(<span class="keyword">pthread_barrierattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h2 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h2><p>多个控制线程在相同的时间有可能调用相同的函数。如果一个函数在相同的时间点可以被多个线程安全地调用,就称该函数是线程安全的。</p>
<p>如果一个函数对多个线程来说是可重入的,就说这个函数就是线程安全的。但这并不能说明对信号处理程序来说该函数也是可重入的。如果函数对异步信号处理程序的重入是安全的,那么就可以说函数是异步信号安全的。</p>
<h2 id="线程特定数据"><a href="#线程特定数据" class="headerlink" title="线程特定数据"></a>线程特定数据</h2><p>线程特定数据( thread-specific data),也称为<strong>线程私有数据</strong>( thread-private data.),是存储和查询某个特定线程相关数据的一种机制。我们把这种数据称为线程特定数据或线程私有数据的原因是,我们希望每个线程可以访问它自己单独的数据副本,而不需要担心与其他线程的同步访问问题</p>
<p>设置线程私有数据的原因：</p>
<ol>
<li>有时候需要维护基于每线程(per-thread)的数据，即使线程ID确实是小而连续的整数,我们可能还希望有一些额外的保护,防止某个线程的数据与其他线程的数据相混淆。</li>
<li>它提供了让基于进程的接口适应多线程环境的机制。一个很明显的例子就是errno，以前的接口(线程出现以前)把errno定义为进程上下文中全局可访问的整数。系统调用和库例程在调用或执行失败时设置把它作为操作失败时的附属结果。为了让线程也能够使用那些原本基于进程的系统调用和库例程, errno被重新定义为线程私有数据。这样,一个线程做了重置 errno的操作也不会影响进程中其他线程的 errno值。</li>
</ol>
<p>我们知道一个进程中的所有线程都可以访问这个进程的整个地址空间。除了使用寄存器以外,一个线程没有办法阻止另一个线程访问它的数据。线程特定数据也不例外。虽然底层的实现部分并不能阻止这种访问能力,但管理线程特定数据的函数可以提高线程间的数据独立性,使得线程不太容易访问到其他线程的线程特定数据</p>
<p>在分配线程特定数据之前,需要创建与该数据关联的键。这个键将用于获取对线程特定数据的访问。使用 <code>pthread_key_create</code>创建一个键</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt; </div><div class="line"></div><div class="line">int pthread_key_create(pthread_key_t *keyp, void (*destructor)(void *)); </div><div class="line"></div><div class="line">// Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
<p>创建的键存储在keyp指向的内存单元中,这个键可以被进程中的所有线程使用,但<strong>每个线程把这个键与不同的线程特定数据地址进行关联</strong>。创建新键时,每个线程的数据地址设为空值。</p>
<p>除了创建键以外, pthread<em>key</em> create可以为该键关联一个可选择的析构函数。当这个线程退出时,如果数据地址已经被置为非空值,那么析构函数就会被调用,它唯一的参数就是该数据地址。如果传入的析构函数为空,就表明没有析构函数与这个键关联。</p>
<p>线程<strong>通常使用malloc为线程特定数据分配内存</strong>。析构函数通常释放已分配的内存。如果线程在没有释放内存之前就退出了,那么这块内存就会丢失,即线程所属进程就出现了内存泄漏。</p>
<p>线程退出时,线程特定数据的析构函数将按照操作系统实现中定义的顺序被调用。析构函数可能会调用另一个函数,该函数可能会创建新的线程特定数据,并且把这个数据与当前的键关联起来。当所有的析构函数都调用完成以后,系统会检查是否还有非空的线程特定数据值与键关联,如果有的话,再次调用析构函数。</p>
<p>对所有的线程,我们都可以通过调用<code>pthread_key_de1ete</code>来取消键与线程特定数据值之间的关联关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_delete</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>上述函数不会激活与键关联的析构函数</p>
<p>需要确保分配的键并不会由于在初始化阶段的竞争而发生变动。解决这种竞争的方法是使用<code>pthread_once</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line"></div><div class="line">pthread_once_t initﬂag = PTHREAD_ONCE_INIT;</div><div class="line"></div><div class="line">int pthread_once(pthread_once_t *initﬂag, void (*initfn)(void));</div><div class="line"></div><div class="line">// Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
<p>initflag必须是一个非本地变量(如全局变量或静态变量),而且必须初始化为<code>PTHREAD_ONCE_INIT</code>。如果每个线程都调用 pthread_once,系统就能保证初始化例程initfn只被调用一次,即系统首次调用 pthread_once时。</p>
<p>键一旦创建以后,就可以通过调用<code>pthread_setspecific</code>函数把键和线程特定数据关联起来。可以通过 <code>pthread_ getspecific</code>函数获得线程特定数据的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: thread-speciﬁc data value or NULL if no value has been associated with the key</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key, <span class="keyword">const</span> <span class="keyword">void</span> *value)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h2 id="取消选项"><a href="#取消选项" class="headerlink" title="取消选项"></a>取消选项</h2><p>有两个线程属性并没有包含在<code>pthread_attr_t</code>结构中,它们是可取消状态和可取消类型。这两个属性影响着线程在响应<code>pthread_cancel</code>函数调用时所呈现的行为</p>
<p>可取消状态属性可以是<code>PTHREAD_CANCEL_ENABLE</code>,也可以是<code>PTHREAD_CANCEL_DISABLE</code>，线程可以通过调用`pthread_setcancel_state修改它的可取消状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcancelstate</span><span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span> *oldstate)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p><code>pthread_setcancel_state</code>把当前的可取消状态设置为state,把原来的可取消状态存储在由oldstate指向的内存单元,<strong>这两步是一个原子操作</strong>。</p>
<p><code>pthread_cancel</code>调用并不等待线程终止。在默认情况下,线程在取消请求发出以后还是继续运行,直到线程到达某个取消点。取消点是线程检查它是否被取消的一个位置,如果取消了,则按照请求行事。</p>
<p>线程启动时默认的可取消状态是<code>PTHREAD_CANCEL_ENABLE</code>。当状态设为<code>PTHREAD_CANCEL_DISABLE</code>时,对<code>pthread_cancel</code>的调用并不会杀死线程。相反,取消请求对这个线程来说还处于挂起状态,当取消状态变为<code>PTHREAD_CANCEL_ENABLE</code>时,线程将在下一个取消点上对所有挂起的取消请求进行处理</p>
<p>可以调用<code>pthread_testcancel</code>函数在程序中添加自己的取消点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_testcancel</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>默认的取消类型也称为推迟取消。调用<code>pthread_cancel</code>以后,在线程到达取消点之前,并不会出现真正的取消。可以通过调用<code>pthread_setcanceltype</code>来修改取消类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> *oldtype)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>有两种取消类型：推迟取消和异步取消，异步取消与推迟取消不同,因为使用异步取消时,线程可以在任意时间撤消,不是非得遇到取消点才能被取消</p>
<h2 id="线程和信号"><a href="#线程和信号" class="headerlink" title="线程和信号"></a>线程和信号</h2><p>每个<strong>线程都有自己的信号屏蔽字,但是信号的处理是进程中所有线程共享的</strong>。这意味着单个线程可以阻止某些信号,但当某个线程修改了与某个给定信号相关的处理行为以后,所有的线程都必须共享这个处理行为的改变。这样,如果一个线程选择忽略某个给定信号,那么另一个线程就可以通过以下两种方式撤消上述线程的信号选择:恢复信号的默认处理行为,或者为信号设置个新的信号处理程序</p>
<p>进程使用<code>sigprocmask</code>函数来阻止信号发送。线程使用的函数是<code>pthread_sigmask</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_sigmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> oset)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>pthread_sigmask函数与sigprocmask函数基本相同,不过pthread_sigmask工作在线程中,而且失败时返回错误码,不再像sigprocmask中那样设置errno并返回-1。set参数包含线程用于修改信号屏蔽字的信号集。how参数可以取下列3个值之一: SIG_BLOCK,把信号集添加到线程信号屏蔽字中, SIG_SETMASK,用信号集替换线程的信号屏蔽字;SIG_UNBLOCK,从线程信号屏蔽字中移除信号集。如果oset参数不为空,线程之前的信号屏蔽字就存储在它指向的siget_t结构中。线程可以通过把set参数设置为NULL,并把oser参数设置为si gset_t结构的地址,来获取当前的信号屏蔽字。这种情况中的how参数会被忽略</p>
<p>线程可以通过调用sigwait等待一个或多个信号的出现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigwait</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">int</span> *<span class="keyword">restrict</span> signop)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>set参数指定了线程等待的信号集。返回时, signop指向的整数将包含发送信号的数量</p>
<p>为了避免错误行为发生,线程在调用sigwait之前,必须阻塞那些它正在等待的信号</p>
<p>sigwait函数会原子地取消信号集的阻塞状态,直到有新的信号被递送</p>
<p>要把信号发送给进程,可以调用ki11。要把信号发送给线程,可以调用 pthread_kill<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_kill</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">int</span> signo)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure></p>
<h2 id="线程和fork"><a href="#线程和fork" class="headerlink" title="线程和fork"></a>线程和fork</h2><p>当线程调用fork时，就为子进程创建整个进程地址空间的副本</p>
<p>子进程通过继承整个地址空间的副本,还从父进程那儿继承了每个互斥量、读写锁和条件变量的状态。如果父进程包含一个以上的线程,子进程在fork返回以后,如果紧接着不是马上调用exec的话,就需要清理锁状态</p>
<p>在子进程内部,只存在一个线程,它是由父进程中调用fork的线程的副本构成的。</p>
<p>在多线程的进程中,为了避免不一致状态的问题, POSIX.1声明,在fork返回和子进程调用其中一个exec函数之间,子进程只能调用异步信号安全的函数。这就限制了在调用exec之前子进程能做什么,但不涉及子进程中锁状态的问题。</p>
<p>要清除锁状态，可以通过调用pthread_atfork函数建立fork处理程序</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt; </div><div class="line"></div><div class="line">int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void)); </div><div class="line"></div><div class="line">// Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
<p>用pthread_atfork函数最多可以安装3个帮助清理锁的函数。 <code>prepare_fork</code>处理程序由父进程在fork创建子进程前调用。这个fork处理程序的任务是<strong>获取父进程定义的所有锁</strong>。 <code>parent_fork</code>处理程序是在fork创建子进程以后、返回之前在父进程上下文中调用的。这个fok处理程序的任务是对<code>prepare_fork</code>处理程序获取的所有锁进行解锁。<code>child_fork</code>处理程序在fork返回之前在子进程上下文中调用。与 <code>parent_fork</code>处理程序一样, <code>child_fork</code>处理程序也必须释放<code>prepare_fork</code>处理程序获取的所有锁</p>
<h2 id="线程和I-O"><a href="#线程和I-O" class="headerlink" title="线程和I/O"></a>线程和I/O</h2><p>在多线程环境下，使用的都是pread和pwrite函数，这些函数都是源自操作，使得多线程下所有线程可以共享相同的文件描述符。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第12章 线程控制 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 线程</title>
    <link href="https://www.liuin.cn/2018/05/02/APUE-%E7%BA%BF%E7%A8%8B/"/>
    <id>https://www.liuin.cn/2018/05/02/APUE-线程/</id>
    <published>2018-05-02T06:34:59.000Z</published>
    <updated>2018-05-27T01:00:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第11章 线程 笔记</p>
<a id="more"></a>
<h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p>在程序设计时就可以把进程设计成在某一时刻能够做不止一件事,每个线程处理各自独立的任务。这种方法有很多好处。</p>
<ul>
<li>通过为每种事件类型分配单独的处理线程,可以简化处理异步事件的代码。每个线程在进行事件处理时可以采用同步编程模式,同步编程模式要比异步编程模式简单得多。</li>
<li>多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享，而多个线程自动地可以访问相同的存储地址空间和文件描述符</li>
<li>有些问题可以分解从而提高整个程序的吞吐量。在只有一个控制线程的情况下,一个单线程进程要完成多个任务,只需要把这些任务串行化。但有多个控制线程时,相互独立的任务的处理就可以交叉进行,此时只需要为每个任务分配一个单独的线程。</li>
<li>交互的程序同样可以通过使用多线程来改善响应时间,多线程可以把程序中处理用户输入输出的部分与其他部分分开。</li>
</ul>
<p>处理器的数量并不影响程序结构,所以不管处理器的个数多少,程序都可以通过使用线程得以简化。</p>
<p>每个线程都包含有表示执行环境所必需的信息,其中包括<strong>进程中标识线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、 errno变量以及线程私有数据</strong></p>
<p>一个进程的所有信息对该进程的所有线程都是共享的,包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符</p>
<h2 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h2><p>就像每个进程有一个进程ID一样,每个线程也有一个线程ID。进程ID在整个系统中是唯一的,但线程ID不同,线程ID只有在它所属的进程上下文中才有意义。</p>
<p>线程ID是用pthread_t数据类型来表示的,实现的时候可以用一个结构来代表pthread_t数据类型,所以可移植的操作系统实现不能把它作为整数处理。因此必须使用一个函数来对两个线程ID进行比较:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> tid1, <span class="keyword">pthread_t</span> tid2)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: nonzero if equal, 0 otherwise</span></div></pre></td></tr></table></figure>
<p>线程可以通过调用 pthread_self函数获得自身的线程ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: the thread ID of the calling thread</span></div></pre></td></tr></table></figure>
<p>当线程需要识别以线程ID作为标识的数据结构时, pthread_self函数可以与pthread_equal函数一起使用。例如,主线程可能把工作任务放在一个队列中,用线程ID来控制每个工作线程处理哪些作业。如图所示,主线程把新的作业放到一个工作队列中,由3个工作线程组成的线程池从队列中移出作业。主线程不允许每个线程任意处理从队列顶端取出的作业,而是由主线程控制作业的分配,主线程会在每个待处理作业的结构中放置处理该作业的线程ID,每个工作线程只能移出标有自己线程ID的作业。</p>
<p><img src="https://data2.liuin.cn/2018-05-25-15272376666056.jpg" alt=""></p>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>新增的线程可以通过调用 pthread_create函数创建。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt; </div><div class="line"></div><div class="line">int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(*start_rtn)(void *), void *restrict arg); </div><div class="line"></div><div class="line">// Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
<p>当pthread_create成功返回时,新创建线程的线程ID会被设置成<code>tidp</code>指向的内存单元，<code>attr</code>参数用于定制各种不同的线程属性。新创建的线程从<code>start_rtn</code>函数的地址开始运行,该函数只有一个无类型指针参数<code>arg</code>。如果需要向<code>start_run</code>函数传递的参数有一个以上,那么需要把这些参数放到一个结构中,然后把这个结构的地址作为<code>arg</code>参数传入</p>
<p>线程创建时并不能保证哪个线程会先运行:是新创建的线程,还是调用线程。新创建的线程可以访问进程的地址空间,并且继承调用线程的浮点环境和信号屏蔽字,但是该线程的挂起信号集会被清除。</p>
<p>注意, pthread函数在调用失败时通常会返回错误码,它们并不像其他的POSIX函数一样设置 errno。每个线程都提供 errno的副本,这只是为了与使用 errno的现有函数兼容。</p>
<p>在使用pthread_create函数的时候有一些问题是需要注意的：</p>
<ul>
<li>在创建多线程程序的时候，有的时候主线程需要休眠,如果主线程不休眠,它就可能会退出,这样新线程还没有机会运行,整个进程可能就已经终止了。这种行为特征依赖于操作系统中的线程实现和调度算法</li>
<li>第二个特别之处在于新线程是通过调用 pthread_se1f函数获取自己的线程ID的,而不是从共享内存中读出的,或者从线程的启动例程中以参数的形式接收到。我们知道pthread_create会通过第一个参数(tidp)返回新建线程的线程ID。但是新建的线程并不能安全地使用它,如果新线程在主线程调用pthread_create返回之前就运行了,那么新线程看到的是未经初始化的ntid的内容,这个内容并不是正确的线程</li>
</ul>
<h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>如果进程中的任意线程调用了exit、_Exit或者_exit,那么整个进程就会终止</p>
<p>单个线程可以通过3种方式退出,因此可以在不终止整个进程的情况下,停止它的控制流。</p>
<ol>
<li>线程可以简单地从启动例程中返回,返回值是线程的退出码。</li>
<li>线程可以被同一进程中的其他线程取消。</li>
<li>线程调用 pthread_ex1t</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *rval_ptr)</span></span>;</div></pre></td></tr></table></figure>
<p><code>rval_ptr</code>参数是一个无类型指针,与传给启动例程的单个参数类似。进程中的其他线程也可以通过调用 <code>pthread_join</code>函数访问到这个指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **rval_ptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>调用线程将一直阻塞,直到指定的线程调用<code>pthread_exit</code>，从启动例程中返回或者被取消。如果线程简单地从它的启动例程返回, <code>rval_ptr</code>就包含返回码。如果线程被取消,由<code>rval_pir</code>指定的内存单元就设置为<code>PTHREAD_CANCELED</code></p>
<p>可以通过调用<code>pthread_join</code>自动把线程置于分离状态(马上就会讨论到),这样资源就可以恢复。如果线程已经处于分离状态, <code>pthread_join</code>调用就会失败,返回<code>EINVAL</code>,尽管这种行为是与具体实现相关的。</p>
<p>如果对线程的返回值并不感兴趣,那么可以把 rval_ptr设置为NULL。在这种情况下,调用pthread_join函数可以等待指定的线程终止,但并不获取线程的终止状态。</p>
<p>pthread_create和 pthread_exit函数的无类型指针参数可以传递的值不止一个,这个指针可以传递包含复杂信息的结构的地址,但是注意,<strong>这个结构所使用的内存在调用者完成调用以后必须仍然是有效的</strong>。</p>
<p>为了解决这个问题,可以使用全局结构,或者用mal1oc函数分配结构</p>
<p>线程可以通过调用<code>pthread_cancel</code>函数来请求取消同一进程中的其他线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>在默认情况下, pthread_cancel函数会使得由tid标识的线程的行为表现为如同调用了参数为 PTHREAD_CANCELED的 pthread_exit函数,但是,线程可以选择忽略取消或者控制如何被取消。注意 pthread_cancel<strong>并不等待线程终止,它仅仅提出请求</strong></p>
<p>线程可以安排它退出时需要调用的函数,这与进程在退出时可以用<code>atexit</code>函数安排退出是类似的。这样的函数称为线程清理处理程序( thread cleanup handler)。一个线程可以建立多个清理处理程序。处理程序记录在栈中,也就是说,它们的<strong>执行顺序与它们注册时相反</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line"></div><div class="line">void pthread_cleanup_push(void (*rtn)(void *), void *arg);</div><div class="line"></div><div class="line">void pthread_cleanup_pop(int execute);</div></pre></td></tr></table></figure>
<p>需要注意的是：如果线程是通过从它的启动例程中返回而终止的话,它的清理处理程序就不会被调用。还要注意,清理处理程序是按照与它们安装时相反的顺序被调用的</p>
<p>进程原语和线程原语的比较：</p>
<p><img src="https://data2.liuin.cn/2018-05-27-15273825684274.jpg" alt=""></p>
<blockquote>
<p>线程的分离和结合</p>
</blockquote>
<p>在任何一个时间点上，线程是可结合的（joinable），或者是分离的（detached）。一个可结合的线程能够被其他线程收回其资源和杀死；在被其他线程回收之前，它的存储器资源（如栈）是不释放的。相反，一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放</p>
<p>在默认情况下,线程的终止状态会保存直到对该线程调用 pthread_join。如果线程已经被分离,线程的底层存储资源可以在线程终止时立即被收回。在线程被分离后,我们不能用pthread_join函数等待它的终止状态,因为对分离状态的线程调用 pthread_join会产生未定义行为。可以调用 pthread_detach分离线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当一个线程可以修改的变量,其他线程也可以读取或者修改的时候,我们就需要对这些线程进行同步,确保它们在访问变量的存储内容时不会访问到无效的值。</p>
<p>当一个线程修改变量时,其他线程在读取这个变量时可能会看到一个不一致的值。在变量修改时间多于一个存储器访问周期的处理器结构中,当存储器读与存储器写这两个周期交叉时,这种不一致就会出现。</p>
<p>为了解决这个问题,线程不得不使用锁,同一时间只允许一个线程访问该变量</p>
<p><img src="https://data2.liuin.cn/2018-05-02-15252443887056.jpg" alt=""></p>
<p>两个或多个线程试图在同一时间修改同一变量时,也需要进行同步</p>
<p>如果修改操作是原子操作,那么就不存在竞争。当多个线程观察不到数据的不一致时,那么操作就是顺序一致的。在现代计算机系统中,存储访问需要多个总线周期,多处理器的总线周期通常在多个处理器上是交叉的,所以我们并不能保证数据是顺序一致的。</p>
<p><img src="https://data2.liuin.cn/2018-05-25-15272391697777.jpg" alt=""></p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>可以使用 pthread的互斥接口来保护数据,确保同一时间只有一个线程访问数据。<strong>互斥量(mutex)</strong>从本质上说是一把锁,在访问共享资源前对互斥量进行设置(加锁),在访问完成后释放(解锁)互斥量。</p>
<p>互斥变量是用<code>pthread_mutex_t</code>数据类型表示的，使用互斥量之前必须要初始化，动态分配的互斥量在释放内存之前要调用<code>pthread_mutex_destory</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>要用默认的属性初始化互斥量,只需把attr设为NULL。</p>
<p>对互斥量进行加锁,需要调用<code>pthread_mutex_lock</code>。如果互斥量已经上锁,调用线程将阻塞直到互斥量被解锁。对互斥量解锁,需要调用<code>pthread_mutex_un1ock</code>。</p>
<p>如果线程不希望被阻塞,它可以使用<code>pthread_mutex_try1ock</code>尝试对互斥量进行加锁。如果调用 <code>pthread_mutex_try1ock</code>时互斥量处于未锁住状态,那么<code>pthread_mutex_try1ock</code>将锁住互斥量,不会出现阻塞直接返回0,否则<code>pthread_mutex_try1ock</code>就会失败,不能锁住互斥量,返回 EBUSY。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>如果线程试图对同一个互斥量加锁两次,那么它自身就会陷入死锁状态,可以通过仔细控制互斥量加锁的顺序来避免死锁的发生。例如,假设需要对两个互斥量A和B同时加锁。如果所有线程总是在对互斥量B加锁之前锁住互斥量A,那么使用这两个互斥量就不会产生死锁(当然在其他的资源上仍可能出现死锁)。</p>
<p>上面讲的是采用顺序加锁的形式避免死锁的方式。</p>
<p>有时候,应用程序的结构使得对互斥量进行排序是很困难的。如果涉及了太多的锁和数据结构,可用的函数并不能把它转换成简单的层次,那么就需要采用另外的方法。在这种情况下,可以先释放占有的锁,然后过一段时间再试。这种情况可以使用 pthread_mutex_trylock接口避免死锁。如果已经占有某些锁而且 pthread_mutex_try1ock接口返回成功,那么就可以前进。但是,如果不能获取锁,可以先释放已经占有的锁,做好清理工作,然后过一段时间再重新试。</p>
<h3 id="函数pthread-mutex-timelock"><a href="#函数pthread-mutex-timelock" class="headerlink" title="函数pthread_mutex_timelock"></a>函数pthread_mutex_timelock</h3><p>当线程试图获取一个已加锁的互斥量时,<code>pthread_mutex_timedlock</code>互斥量原语允许绑定线程阻塞时间。 <code>pthread_mutex_timedlock</code>函数与<code>pthread_mutex_timedlock</code>是基本等价的,但是在达到超时时间值时,<code>pthread_mutex_timedlock</code>不会对互斥量进行加锁,而是返回错误码 ETIME_DOUT。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; #include &lt;time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_timedlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁( reader-writer lock)与互斥量类似,不过读写锁允许更高的并行性。互斥量要么是锁住状态,要么就是不加锁状态,而且一次只有一个线程可以对其加锁。读写锁可以有3种状态:读模式下加锁状态,写模式下加锁状态,不加锁状态。一次只有一个线程可以占有写模式的读写锁,但是多个线程可以同时占有读模式的读写锁</p>
<p>读写锁非常适合于对数据结构读的次数远大于写的情况。读写锁也叫做共享互斥锁( shared-exclusive lock)。</p>
<p>初始化和销毁读写锁的函数和互斥量类似<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure></p>
<p>要在读模式下锁定读写锁,需要调用<code>pthread_rwlock_rdlock</code>。要在写模式下锁定读写锁,需要调用 <code>pthread_rwlock_wrlock</code>。不管以何种方式锁住读写锁,都可以调用<code>pthread_rw1ock_unlock</code>进行解锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>读写锁原语的条件版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="带有超时的读写锁"><a href="#带有超时的读写锁" class="headerlink" title="带有超时的读写锁"></a>带有超时的读写锁</h3><p>与互斥量一样，读写锁也有带有超时条件的加锁函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; #include &lt;time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedwrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量是线程可用的另一种同步机制。条件变量给多个线程提供了一个会合的场所。条件变量与互斥量一起使用时,允许线程以无竞争的方式等待特定的条件发生。</p>
<p>条件本身是由互斥量保护的。<strong>线程在改变条件状态之前必须首先锁住互斥量</strong>。其他线程在获得互斥量之前不会察觉到这种改变,因为互斥量必须在锁定以后才能计算条件。</p>
<p>条件变量使用的数据结构<code>pthread_cond_t</code>，同理也有初始化和销毁的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>我们使用<code>pthread_cond_wait</code>等待条件变量变为真。如果在给定的时间内条件不能满足那么会生成一个返回错误码的变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>传递给pthread_cond_wait的互斥量对条件进行保护。调用者<strong>把锁住的互斥量传给函数,函数然后自动把调用线程放到等待条件的线程列表上,对互斥量解锁</strong>。这就<strong>关闭了条件检查和线程进入休眠状态等待条件改变这两个操作之间的时间通道,这样线程就不会错过条件的任何变化</strong>。 pthread_cond_wait返回时,互斥量再次被锁住。</p>
<p>有两个函数可以用于通知线程条件已经满足。<code>pthread_cond_signal</code>函数<strong>至少能唤醒一个等待该条件的线程</strong>,而<code>pthread_cond_broadcast</code>函数则能<strong>唤醒等待该条件的所有线程</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁与互斥量类似,但它不是通过休眠使进程阻塞,而是在获取锁之前一直处于忙等(自旋)阻塞状态。自旋锁可用于以下情况:锁被持有的时间短,而且线程并不希望在重新调度上花费太多的成本</p>
<p>自旋锁通常作为底层原语用于实现其他类型的锁。</p>
<p>当自旋锁用在非抢占式内核中时是非常有用的:除了提供互斥机制以外,它们会阻塞中断这样中断处理程序就不会让系统陷入死锁状态,因为它需要获取已被加锁的自旋锁(把中断想成是另一种抢占)。在这种类型的内核中,中断处理程序不能休眠,因此它们能用的同步原语只能是自旋锁。</p>
<p>初始化和销毁函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_init</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock, <span class="keyword">int</span> pshared)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_destroy</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>加锁解锁函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_lock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_trylock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_unlock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>屏障(barrier)是用户<strong>协调多个线程并行工作的同步机制</strong>。屏障允许每个线程等待,直到所有的合作线程都到达某一点,然后从该点继续执行。我们已经看到一种屏障,<code>pthread_jo1n</code>函数就是一种屏障,允许一个线程等待,直到另一个线程退出。</p>
<p>但是屏障对象的概念更广,它们允许任意数量的线程等待,直到所有的线程完成处理工作而线程不需要退出。所有线程达到屏障后可以接着工作。</p>
<p>初始化和销毁函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_init</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *<span class="keyword">restrict</span> barrier, <span class="keyword">const</span> <span class="keyword">pthread_barrierattr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_destroy</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>初始化屏障时,可以使用<code>count</code>参数指定在允许所有线程继续运行之前,必须到达屏障的线程数目。使用<code>attr</code>参数指定屏障对象的属性,设置atmr为NULL,用默认属性初始化屏障。</p>
<p>可以使用<code>pthread_barrier_wait</code>函数来表明,线程已完成工作,准备等所有其他线程赶上来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_wait</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 or PTHREAD_BARRIER_SERIAL_THREAD if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>一旦达到屏障计数值,而且线程处于非阻塞状态,屏障就可以被重用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第11章 线程 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 进程关系</title>
    <link href="https://www.liuin.cn/2018/05/01/APUE-%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/"/>
    <id>https://www.liuin.cn/2018/05/01/APUE-进程关系/</id>
    <published>2018-05-01T02:55:38.000Z</published>
    <updated>2018-05-24T11:32:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第9章 进程关系 笔记</p>
<a id="more"></a>
<h2 id="终端登录"><a href="#终端登录" class="headerlink" title="终端登录"></a>终端登录</h2><p>我们现在描述的过程用于经由终端登录至UNIX系统。该过程几乎与所使用的终端类型无关,所使用的终端可以是基于字符的终端、仿真基于字符终端的图形终端,或者运行窗口系统的图形终端。</p>
<ol>
<li>BSD终端登录</li>
</ol>
<p>系统管理者创建通常名为/etc/ttys的文件,其中,每个终端设备都有一行,每一行说明设备名和传到 getty程序的参数。</p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251450557245.jpg" alt=""></p>
<p>1ogin能处理多项工作。因为它得到了用户名,所以能调用<code>getpwnam</code>取得相应用户的口令文件登录项。然后调用<code>getpass</code>以显示提示“ Password:”,接着读用户键入的口令(自然,禁止回显用户键入的口令)。它调用 <code>crypt</code>将用户键入的口令加密,并与该用户在阴影口令文件中登录项的<code>pw_passwd</code>字段相比较。如果用户几次键入的口令都无效,则<code>1ogin</code>以参数1调用<code>exit</code>表示登录过程失败。父进程(init)了解到子进程的终止情况后,将再次调用<code>fork</code>,其后又执行了<code>getty</code>,对此终端重复上述过程。</p>
<p>如果用户正确登录，login就将完成如下工作：</p>
<ol>
<li>将当前工作目录更改为该用户的起始目录(chdir)。</li>
<li>调用chown更改该终端的所有权,使登录用户成为它的所有者。将对该终端设备的访问权限改变成“用户读和写”。</li>
<li>调用setgid及initgroups设置进程的组ID</li>
<li>用login得到的所有信息初始化环境:起始目录(HOME)、shell(SHEL)用户名(USER和 LOGNAME)以及一个系统默认路径(PATH)。</li>
<li>1ogin进程更改为登录用户的用户ID( setuid)并调用该用户的登录 shell</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-05-01-15251453247541.jpg" alt=""></p>
<h2 id="网络登录"><a href="#网络登录" class="headerlink" title="网络登录"></a>网络登录</h2><p>通过串行终端登录至系统和经由网络登录至系统两者之间的主要(物理上的)区别是:网络登录时,在终端和计算机之间的连接不再是点到点的。在网络登录情况下,1ogin仅仅是一种可用的服务,这与其他网络服务(如FIP或SMIP)的性质相同</p>
<p>为使同一个软件既能处理终端登录,又能处理网络登录,系统使用了一种称为伪终端(pseudo terminal)的软件驱动程序,它仿真串行终端的运行行为,并将终端操作映射为网络操作,反之亦然。</p>
<ol>
<li>BSD网络登录</li>
</ol>
<p>作为系统启动的一部分,init调用一个shell,,使其执行shell脚本/etc/rc。由此shell脚本启动一个守护进程 inetd。一旦此shell脚本终止, inetd的父进程就变成init。 inetd等待TCP/IP连接请求到达主机,而当一个连接请求到达时,它执行一次fork,然后生成的子进程exec适当的程序。</p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251533208482.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251534277316.jpg" alt=""></p>
<p>当通过终端或网络登录时,我们得到一个登录shell,其标准输入、标准输出和标准错误要么连接到一个终端设备,要么连接到一个伪终端设备上。</p>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><p>进程组是一个或多个进程的集合。通常,它们是在同一作业中结合起来的,<strong>同一进程组中的各进程接收来自同一终端的各种信号</strong>。每个进程组有一个唯一的进程组ID。进程组ID类似于进程ID——它是一个正整数,并可存放在pid_t数据类型中。函数 getpgrp返回调用进程的进程组ID。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getpgrp(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: process group ID of calling process</span></div></pre></td></tr></table></figure>
<p>getpgid函数返回指定进程所在的进程组ID：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getpgid(<span class="keyword">pid_t</span> pid);</div><div class="line"></div><div class="line"><span class="comment">// Returns: process group ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>每个进程组有一个组长进程。组长进程的进程组ID等于其进程ID。</p>
<p>进程组组长可以创建一个进程组、创建该组中的进程,然后终止。<strong>只要在某个进程组中有个进程存在,则该进程组就存在,这与其组长进程是否终止无关</strong>。从进程组创建开始到其中最后一个进程离开为止的时间区间称为进程组的生命期。某个进程组中的最后一个进程可以终止,也可以转移到另一个进程组</p>
<p>进程调用setpgid可以加入一个现有的进程组或者创建一个新进程组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>一个进程只能为它自己或它的子进程设置进程组ID。在它的子进程调用了exec后,它就不再更改该子进程的进程组ID</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话( session)是一个或多个进程组的集合</p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251538207763.jpg" alt=""></p>
<p>通常是由shell管道将几个进程编成一组的。</p>
<p>进程调用setsid函数建立一个新会话</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> setsid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: process group ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>如果调用此函数的进程不是一个进程组的组长,则此函数创建个新会话。具体会发生以下3件事。</p>
<ol>
<li>进程变成新会话的会话首进程( session leader,会话首进程是创建该会话的进程)。此时,该进程是新会话中的唯一进程</li>
<li>该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID。</li>
<li>该进程没有控制终端(下一节讨论控制终端)。如果在调用 setid之前该进程有一个控制终端,那么这种联系也被切断。</li>
</ol>
<p>如果该调用进程已经是一个进程组的组长,则此函数返回出错。为了保证不处于这种情况,通常先调用fork,然后使其父进程终止,而子进程则继续。因为子进程继承了父进程的进程组ID,而其进程ID则是新分配的,两者不可能相等,这就保证了子进程不是一个进程组的组长</p>
<p>会话首进程是具有唯一进程ID的单个进程,所以<strong>可以将会话首进程的进程ID视为会话ID</strong></p>
<p><code>getsid</code>函数返回会话首进程的进程组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getsid(<span class="keyword">pid_t</span> pid); </div><div class="line"></div><div class="line"><span class="comment">// Returns: session leader’s process group ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>如若pid是0, getsid返回调用进程的会话首进程的进程组ID。出于安全方面的考虑些实现有如下限制:如若pid并不属于调用者所在的会话,那么调用进程就不能得到该会话首进程的进程组ID</p>
<h2 id="控制终端"><a href="#控制终端" class="headerlink" title="控制终端"></a>控制终端</h2><p>会话和进程组还有一些其他特性</p>
<ul>
<li>一个会话可以有一个控制终端(controlling terminal)。这通常是终端设备(在终端登录情况下)或伪终端设备(在网络登录情况下)。</li>
<li>建立与控制终端连接的会话首进程被称为控制进程(controlling process)</li>
<li>一个会话中的几个进程组可被分成一个前台进程组(foreground process group)以及一个或多个后台进程组(background process group)</li>
<li>如果一个会话有一个控制终端,则它有一个前台进程组,其他进程组为后台进程组</li>
<li>无论何时键入终端的中断键(常常是Delete或Ctrl+C),都会将中断信号发送至前台进程组的所有进程。</li>
<li>无论何时键入终端的退出键(常常是Ctrl+),都会将退出信号发送至前台进程组的所有进程。</li>
<li>如果终端接口检测到调制解调器(或网络)已经断开连接,则将挂断信号发送至控制进程〔会话首进程)</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-05-01-15251544917844.jpg" alt=""></p>
<p>有时不管标准输入、标准输出是否重定向,程序都要与控制终端交互作用。保证程序能与控制终端对话的方法是open文件/dev/tty。在内核中,此特殊文件是控制终端的同义语。自然地,如果程序没有控制终端,则对于此设备的open将失败。</p>
<h2 id="函数tcgetpgrp、tcsetpgrp和tcgetsid"><a href="#函数tcgetpgrp、tcsetpgrp和tcgetsid" class="headerlink" title="函数tcgetpgrp、tcsetpgrp和tcgetsid"></a>函数tcgetpgrp、tcsetpgrp和tcgetsid</h2><p>需要有一种方法来通知内核哪一个进程组是前台进程组,这样,终端设备驱动程序就能知道将终端输入和终端产生的信号发送到何处</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> tcgetpgrp(<span class="keyword">int</span> fd); </div><div class="line"></div><div class="line"><span class="comment">// Returns: process group ID of foreground process group if OK, −1 on error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsetpgrp</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">pid_t</span> pgrpid)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>函数tcgetpgrp返回前台进程组ID,它与在fd上打开的终端相关联</p>
<p>如果进程有一个控制终端,则该进程可以调用 tcsetpgrp将前台进程组ID设置为pergid值应当是在同一会话中的一个进程组的ID。fd必须引用该会话的控制终端。</p>
<p>给出控制TTY的文件描述符,通过 tcgetsid函数,应用程序就能获得会话首进程的进程组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> tcgetsid(<span class="keyword">int</span> fd); </div><div class="line"></div><div class="line"><span class="comment">// Returns: session leader’s process group ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h2><p>作业控制允许<strong>在一个终端上启动多个作业(进程组)</strong>，它控制哪一个作业可以访问该终端以及哪些作业在后台运行。作业控制要求以下3种形式的支持。</p>
<ol>
<li>支持作业控制的 shell</li>
<li>内核中的终端驱动程序必须支持作业控制。</li>
<li>内核必须提供对某些作业控制信号的支持。</li>
</ol>
<p>从 shell使用作业控制功能的角度观察,用户可以在前台或后台启动一个作业。一个作业只是几个进程的集合,通常是一个进程管道。</p>
<p>当启动一个后台作业时，shell赋予其一个作业标识符，并打印一个或者多个进程ID，如下图所示：</p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251551733307.jpg" alt=""></p>
<p>我们可以键入一个影响前台作业的特殊字符—挂起键(通常采用Ctrl+z),与终端驱动程序进行交互作用。键入此字符使终端驱动程序将信号SIGTSTP发送至前台进程组中的所有进程,后台进程组作业则不受影响。实际上有3个特殊字符可使终端驱动程序产生信号,并将它们发送至前台进程组，他们是：</p>
<ul>
<li>中断字符(一般采用Delete或Ctrl+C)产生 SIGINT</li>
<li>退出字符(一般采用Ctrl+)产生 SIGQUIT</li>
<li>挂起字符(一般采用Ctrl+Z)产生 SIGTSTE。</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-05-01-15251552824446.jpg" alt=""></p>
<p>是否需要作业控制是一个有争议的问题。作业控制是在窗口终端广泛得到应用之前设计和实现的。很多人认为设计得好的窗口系统已经免除了对作业控制的需要。某些人抱怨作业控制的实现要求得到内核、终端驱动程序、 shell以及某些应用程序的支持,是吃力不讨好的事情。</p>
<h2 id="shell-执行程序"><a href="#shell-执行程序" class="headerlink" title="shell 执行程序"></a>shell 执行程序</h2><p><img src="https://data2.liuin.cn/2018-05-01-15251555962605.jpg" alt=""></p>
<h2 id="孤儿进程组"><a href="#孤儿进程组" class="headerlink" title="孤儿进程组"></a>孤儿进程组</h2><p>我们曾提及,一个其父进程己终止的进程称为孤儿进程( orphan process),这种进程由init进程“收养”。现在我们要说明整个进程组也可成为“孤儿”,以及POSIX.1如何处理它。</p>
<p>POSIX.1将孤儿进程组( orphaned process group)定义为:该组中每个成员的父进程要么是该组的一个成员,要么不是该组所属会话的成员。对孤儿进程组的另一种描述可以是:一个进程组不是孤儿进程组的条件是——该组中有一个进程,其父进程在属于同一会话的另一个组中。如果进程组不是孤儿进程组那么在属于同一会话的另一个组中的父进程就有机会重新启动该组中停止的进程。在这里,进程组中每一个进程的父进程(例如,进程6100的父进程是进程1)都属于另一个会话。所以此进程组是孤儿进程组</p>
<p>父进程终止后,进程组包含一个停止的进程,进程组成为孤儿进程组,POSIX.1要求向新孤儿进程组中处于停止状态的每一个进程发送挂断信号( SIGHUP),接着又向其发送继续信号( SIGCONT)。</p>
<p>在处理了挂断信号后,子进程继续。对挂断信号的系统默认动作是终止该进程,为此必须提供一个信号处理程序以捕捉该信号。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第9章 进程关系 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 进程控制</title>
    <link href="https://www.liuin.cn/2018/04/30/APUE-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://www.liuin.cn/2018/04/30/APUE-进程控制/</id>
    <published>2018-04-30T08:07:20.000Z</published>
    <updated>2018-05-24T09:07:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第8章 进程控制 笔记</p>
<a id="more"></a>
<h2 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h2><p>每个进程都有一个非负整型表示的唯一进程ID。因为进程ID标识符总是唯一的,常将其用作其他标识符的一部分以保证其唯一性。</p>
<p>虽然是唯一的,但是<strong>进程ID是可复用的</strong>。当一个进程终止后,其进程ID就成为复用的候选者。大多数UNIX系统实现延迟复用算法,使得赋予新建进程的DD不同于最近终止进程所使用的ID。这防止了将新进程误认为是使用同一ID的某个已终止的先前进程。</p>
<p>系统中有一些专用进程,但具体细节随实现而不同。<strong>ID为0的进程通常是调度进程,常常被称为交换进程</strong>(swapper)。该进程是内核的一部分,它并不执行任何磁盘上的程序,因此也被称为系统进程。</p>
<p>进程ID为1通常是init进程,在自举过程结束时由内核调用。该进程的程序文件在UNIX的早期版本中是/etc/init,在较新版本中是/sbin/init。此进程负责在自举内核后启动一个UNIX系统。init通常读取与系统有关的初始化文件(/etc/rc*文件或/etc/inittab文件,以及在/etc/init.d中的文件),并将系统引导到一个状态(如多用户)。init进程决不会终止。它是一个普通的用户进程(与交换进程不同,它不是内核中的系统进程),但是它以超级用户特权运行。</p>
<p>每个UNIX系统实现都有它自己的一套提供操作系统服务的内核进程,例如,在某些UNIX的虚拟存储器实现中,进程ID2是页守护进程( page daemon),此进程负责支持虚拟存储器系统的分页操作。</p>
<p>返回进程标识符的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: process ID of calling process</span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getppid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: parent process ID of calling process</span></div><div class="line"></div><div class="line"><span class="keyword">uid_t</span> getuid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: real user ID of calling process</span></div><div class="line"></div><div class="line"><span class="keyword">uid_t</span> geteuid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: effective user ID of calling process</span></div><div class="line"></div><div class="line"><span class="keyword">gid_t</span> getgid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: real group ID of calling process</span></div><div class="line"></div><div class="line"><span class="keyword">gid_t</span> getegid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: effective group ID of calling process</span></div></pre></td></tr></table></figure>
<h2 id="函数fork"><a href="#函数fork" class="headerlink" title="函数fork"></a>函数fork</h2><p>一个现有进程调用fork函数创建一个新的进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 in child, process ID of child in parent, −1 on error</span></div></pre></td></tr></table></figure>
<p>由fork创建的新进程被称为子进程(child process) fork函数被调用一次,但返回两次。两次返回的区别是子进程的返回值是0,而父进程的返回值则是新建子进程的进程ID。</p>
<p>将子进程ID返回给父进程的理由是:因为一个进程的子进程可以有多个,<strong>并且没有一个函数使一个进程可以获得其所有子进程的进程ID</strong>。fork使子进程得到返回值0的理由是:一个进程只会有一个父进程,所以子进程总是可以调用 getppid以获得其父进程的进程ID(进程ID0总是由内核交换进程使用,所以一个子进程的进程ID不可能为0)</p>
<p>子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。</p>
<p>由于在fork之后经常跟随着exec,所以现在的很多实现并不执行一个父进程数据段栈和堆的完全副本。作为替代,使用了<strong>写时复制</strong>( copy-on-write,COW)技术。这些区域由父进程和子进程共享,而且内核将它们的访问权限改变为只读。如果父进程和子进程中的任一个试图修改这些区域,则内核只为修改区域的那块内存制作一个副本,通常是虚拟存储系统中的一“页”。</p>
<p>一般来说,在fork之后是父进程先执行还是子进程先执行是不确定的,这取决于内核所使用的调度算法。如果要求父进程和子进程之间相互同步,则要求某种形式的进程间通信。</p>
<blockquote>
<p>strlen 和 sizeof 的区别</p>
</blockquote>
<p>str1en计算不包含终止nul字节的字符串长度,而sizeof则计算包括终止nul字节的缓冲区长度。两者之间的另一个差别是,使用strlen需进行一次函数调用,而对于sizeof而言,因为缓冲区已用已知字符串进行初始化,其长度是固定的,所以 sizeof是在编译时计算缓冲区长度。</p>
<blockquote>
<p>文件共享</p>
</blockquote>
<p>fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中。我们说“复制”是因为对每个文件描述符来说,就好像执行了dup函数。<strong>父进程和子进程每个相同的打开描述符共享一个文件表项</strong>，因此他们共享的是一个文件偏移量。</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250766871953.jpg" alt=""></p>
<p>如果父进程和子进程写同一描述符指向的文件,但又没有任何形式的同步(如使父进程等待子进程),那么它们的输出就会相互混合(假定所用的描述符是在foxk之前打开的)。</p>
<p>在fork之后处理文件描述符有以下两种情况：</p>
<ol>
<li>父进程等待子进程完成</li>
<li>父进程和子进程各自执行不同的程序段</li>
</ol>
<p>除了打开文件之外,<strong>子进程继承父进程的属性</strong>有：</p>
<ul>
<li>实际用户ID、实际组ID、有效用户ID、有效组ID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>会话ID</li>
<li>控制终端</li>
<li>设置用户ID标志和设置组ID标志</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字</li>
<li>信号屏蔽和安排</li>
<li>对任一打开文件描述符的执行时关闭( close-on-exec)标志</li>
<li>环境</li>
<li>连接的共享存储段</li>
<li>存储映像</li>
<li>资源限制</li>
</ul>
<p>父进程和子进程的区别如下：</p>
<ul>
<li>fork的返回值不同</li>
<li>进程ID不同</li>
<li>这两个进程的父进程ID不同:子进程的父进程ID是创建它的进程的ID,而父进程的父进程ID则不变。</li>
<li>进程的 tms_utime、 tms_stime、 tms_cutime和tms_ultime的值设置为0</li>
<li>子进程不继承父进程设置的文件锁</li>
<li>子进程的未处理闹钟被清除</li>
<li>子进程的未处理信号集设置为空集</li>
</ul>
<p>使fork失败的原因主要有以下几个：</p>
<ol>
<li>系统中已经有了太多的进程</li>
<li>该实际用户ID的进程总数超过了系统限制</li>
</ol>
<p>fork有如下两种用法：</p>
<ol>
<li>一个父进程希望复制自己,使父进程和子进程同时执行不同的代码段</li>
<li>一个进程要执行一个不同的程序</li>
</ol>
<h2 id="函数vfork"><a href="#函数vfork" class="headerlink" title="函数vfork"></a>函数vfork</h2><p>vfork函数的调用序列和返回值与fork相同,但两者的语义不同</p>
<p>vfork函数用于创建一个新进程,而该新进程的目的是exec一个新程序。但是它并不将父进程的地址空间完全复制到子进程中,因为子进程会立即调用exec(或exit),于是也就<strong>不会引用该地址空间</strong>。不过在子进程调用exec或exit之前,它在父进程的空间中运行。这种优化工作方式在某些UNIX系统的实现中提高了效率,但如果子进程修改数据(除了用于存放 vfork返回值的变量)、进行函数调用、或者没有调用exec或exit就返回都可能会带来未知的结果。(就像上一节中提及的,实现采用写时复制技术以提高fork之后跟随exec操作的效率,但是不复制比部分复制还是要快一些)</p>
<p>vfork和fork之间的另一个区别是: <strong>vfork保证子进程先运行,在它调用exec或exit之后父进程才可能被调度运行,当子进程调用这两个函数中的任意一个时,父进程会恢复运行</strong>。</p>
<h2 id="函数exit"><a href="#函数exit" class="headerlink" title="函数exit"></a>函数exit</h2><p>进程有5种正常终止和3种异常终止的方式，5种正常终止的方式如下：</p>
<ol>
<li>从main返回</li>
<li>调用exit</li>
<li>调用_exit或_Exit</li>
<li>最后一个线程从其启动例程返回</li>
<li>从最后一个线程调用 pthread_exit</li>
</ol>
<p>3种异常终止方式：</p>
<ol>
<li>调用 abort</li>
<li>接到一个信号</li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<p>不管进程如何终止,最后都会执行内核中的同一段代码。这段代码为相应进程<strong>关闭所有打开描述符,释放它所使用的存储器等</strong>。</p>
<p>对上述任意一种终止情形,我们都希望终止进程能够通知其父进程它是如何终止的。对于3个终止函数(exit、_exit和_Exit),实现这一点的方法是,将其退出状态( exit status)作为参数传送给函数。在异常终止情况,内核(不是进程本身)<strong>产生一个指示其异常终止原因的终止状态</strong>( termination status)。在任意一种情况下,该终止进程的父进程都能用wait或wa1tpid函数(将在下一节说明)取得其终止状态。</p>
<p>上面说明了子进程将其终止状态返回给其父进程，但是如果父进程在子进程之前终止,又将如何呢?其回答是:<strong>对于父进程已经终止的所有进程,它们的父进程都改变为init进程</strong>。我们称这些进程由init进程收养。其操作过程大致是:在一个进程终止时,内核逐个检查所有活动进程,以判断它是否是正要终止进程的子进程,如果是,则该进程的父进程ID就更改为1(init进程的ID)。这种处理方法保证了每个进程有一个父进程。</p>
<p>如果子进程在父进程之前终止,那么父进程又如何能在做相应检查时得到子进程的终止状态呢?如果子进程完全消失了,父进程在最终准备好检查子进程是否终止时是无法获取它的终止状态的。内核为每个终止子进程保存了一定量的信息,所以当终止进程的父进程调用wait或 waitpid时,可以得到这些信息。</p>
<p>在UNIX术语中,一个已经终止、但是其父进程尚未对其进行善后处理(获取终止子进程的有关信息、释放它仍占用的资源)的进程被称为<strong>僵死进程</strong>(zombie)。ps(1)命令将僵死进程的状态打印为Z。如果编写一个长期运行的程序,它fork了很多子进程,那么除非父进程等待取得子进程的终止状态,不然这些子进程终止后就会变成僵死进程</p>
<p>最后一个要考虑的问题是:一个由init进程收养的进程终止时会发生什么?它会不会变成一个僵死进程?对此问题的回答是“否”,因为init被编写成无论何时只要有一个子进程终止,init就会调用一个wait函数取得其终止状态。这样也就防止了在系统中塞满僵死进程。</p>
<h2 id="函数wait-和-waitpid"><a href="#函数wait-和-waitpid" class="headerlink" title="函数wait 和 waitpid"></a>函数wait 和 waitpid</h2><p>当一个进程正常或异常终止时,内核就向其父进程发送 SIGCHLD信号。因为子进程终止是个异步事件(这可以在父进程运行的任何时候发生),所以这种信号也是内核向父进程发的异步通知。父进程可以选择忽略该信号,或者提供一个该信号发生时即被调用执行的函数(信号处理程序)。对于这种信号的系统默认动作是忽略它。</p>
<p>现在我们要知道的是调用wait和waitpid时进程都发生什么：</p>
<ul>
<li>如果其所有子进程都还在运行,则阻塞。</li>
<li>如果一个子进程已终止,正等待父进程获取其终止状态,则取得该子进程的终止状态立即返回</li>
<li>如果它没有任何子进程,则立即出错返回。</li>
</ul>
<p>如果进程由于接收到 SIGCHLD信号而调用wait,我们期望wait会立即返回。但是如果在间点调用wait,则进程可能会阻塞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *statloc); </div><div class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options); </div><div class="line"></div><div class="line"><span class="comment">// Both return: process ID if OK, 0 (see later), or −1 on error</span></div></pre></td></tr></table></figure>
<p>两个函数的区别如下：</p>
<ul>
<li>在一个子进程终止前,wait使其调用者阻塞,而 waitpid有一选项,可使调用者不阻塞</li>
<li>waitpid并不等待在其调用之后的第一个终止子进程,它有若千个选项,可以控制它所等待的进程</li>
</ul>
<p>这两个函数的参数statloc是一个整型指针。如果statloc不是一个空指针,则终止进程的终止状态就存放在它所指向的单元内。如果不关心终止状态,则可将该参数指定为空指针</p>
<p>对于waitpid函数中pid参数的作用解释如下。</p>
<ul>
<li>pid == -1  等待任一子进程。此种情况下, waitpid与wait等效</li>
<li>pid &gt; 0  等待进程ID与pid相等的子进程</li>
<li>pid == 0  等待组ID等于调用进程组ID的任一子进程。</li>
<li>pid &lt; -1  等待组ID等于pid绝对值的任一子进程</li>
</ul>
<p>waitpid函数返回终止子进程的进程ID,并将该子进程的终止状态存放在由saoc指向的存储单元中。</p>
<p>options参数可以使我们能够进一步控制waitpid函数的操作</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250876888707.jpg" alt=""></p>
<h2 id="函数waitid"><a href="#函数waitid" class="headerlink" title="函数waitid"></a>函数waitid</h2><p>另一个取得进程终止状态的函数waited,此函数类似于 waitpid,但提供了更多的灵活性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">waitid</span><span class="params">(<span class="keyword">idtype_t</span> idtype, <span class="keyword">id_t</span> id, <span class="keyword">siginfo_t</span> *infop, <span class="keyword">int</span> options)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>与 waitpid相似, waitid允许一个进程指定要等待的子进程。但它使用两个单独的参数表示要等待的子进程所属的类型,而不是将此与进程DD或进程组ID组合成一个参数。</p>
<p>idtype参数：</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250878149783.jpg" alt=""></p>
<p>options参数：</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250878305949.jpg" alt=""></p>
<h2 id="函数wait3和wait4"><a href="#函数wait3和wait4" class="headerlink" title="函数wait3和wait4"></a>函数wait3和wait4</h2><p>wait3和wait4提供的功能比上面的函数多一个，该参数允许内核返回由终止进程及其所有子进程使用的资源概况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> wait3(<span class="keyword">int</span> *statloc, <span class="keyword">int</span> options, <span class="keyword">struct</span> rusage *rusage);</div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> wait4(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options, <span class="keyword">struct</span> rusage *rusage);</div><div class="line"></div><div class="line"><span class="comment">// Both return: process ID if OK, 0, or −1 on error</span></div></pre></td></tr></table></figure>
<p>资源统计信息包括用户CPU时间总量、系统CPU时间总量、缺页次数、接收到信号的次数等。</p>
<h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><p>当多个进程都企图对共享数据进行某种处理,而最后的结果又取决于进程运行的顺序时,我们认为发生了竞争条件(race condition)。如果在fork之后的某种逻辑显式或隐式地依赖于在fork之后是父进程先运行还是子进程先运行,那么fork函数就会是竞争条件活跃的滋生地</p>
<p>如果一个进程希望等待一个子进程终止,则它必须调用wait函数中的一个。如果一个进程要等待其父进程终止,则可使用下列形式的循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">while</span>(getppid() != <span class="number">1</span>)</div><div class="line">    sleep(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>这种形式的循环称为轮询( polling),它的问题是浪费了CPU时间,因为调用者每隔1s都被唤醒,然后进行条件测试</p>
<p>为了避免竞争条件和轮询,在多个进程之间需要有某种形式的信号发送和接收的方法。在UNIX中可以使用信号机制。各种形式的进程间通信(IPC)也可使用。</p>
<h2 id="函数exec"><a href="#函数exec" class="headerlink" title="函数exec"></a>函数exec</h2><p>用fork函数创建新的子进程后,子进程往往要调用一种exec函数以执行另个程序。当进程调用一种exec函数时,该进程执行的程序完全替换为新程序,而新程序则从其main函数开始执行。因为调用exec并不创建新进程,所以前后的进程ID并未改变。<strong>exec只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段</strong>。</p>
<p>有7中不同的exec函数可以使用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span> )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ...<span class="comment">/* (char *)0, char *const envp[] */</span> )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ﬁlename, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span> )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ﬁlename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fexecve</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All seven return: −1 on error, no return on success</span></div></pre></td></tr></table></figure></p>
<p>这些函数之间的第一个区别是前4个函数取路径名作为参数,后两个函数则取文件名作为参数,最后一个取文件描述符作为参数。</p>
<p>第二个区别与参数表的传递有关(1表示列表list,v表示矢量vector)。函数exec1、exec1p和 execle要求将新程序的每个命令行参数都说明为一个单独的参数。这种参数表以空指针结尾。对于另外4个函数( execv、 execvp、execve和 fexecve),则应先构造一个指向各参数的指针数组,然后将该数组地址作为这4个函数的参数。</p>
<p>最后一个区别与向新程序传递环境表相关。以e结尾的3个函数(eXec1e、 execve和 fexecve)可以传递一个指向环境字符串指针数组的指针。其他4个函数则使用调用进程中的 environ变量为新程序复制现有的环境</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15251006856272.jpg" alt=""></p>
<p>前面曾提及,在执行exec后,进程ID没有改变。但新程序从调用进程继承了的下列属性:</p>
<ul>
<li>进程ID和父进程ID</li>
<li>实际用户ID和实际组ID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>会话ID</li>
<li>控制终端</li>
<li>闹钟尚余留的时间</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字</li>
<li>文件锁</li>
<li>进程信号屏蔽</li>
<li>未处理信号</li>
<li>资源限制</li>
<li>nice值</li>
<li>tms_utime、tms_stime、tms_cutime以及tms_ctime值</li>
</ul>
<p>在很多UNIX实现中,这7个函数中只有<code>execve</code>是内核的系统调用。另外6个只是库函数它们最终都要调用该系统调用。</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15251008959267.jpg" alt=""></p>
<h2 id="更改用户ID和更改组ID"><a href="#更改用户ID和更改组ID" class="headerlink" title="更改用户ID和更改组ID"></a>更改用户ID和更改组ID</h2><p>在UNIX系统中,特权(如能改变当前日期的表示法)以及访问控制(如熊否读、写一个特定文件),是基于用户ID和组ID的。当程序需要增加特权,或需要访问当前并不允许访问的资源时,我们需要更换自己的用户ID或组ID,使得新ID具有合适的特权或访问权限。与此类似当程序需要降低其特权或阻止对某些资源的访问时,也需要更换用户ID或组ID,新ID不具有相应特权或访问这些资源的能力</p>
<p>在设计应用时,我们总是试图使用<strong>最小特权( least privilege)模型</strong>。依照此模型我们的程序应当只具有为完成给定任务所需的最小特权。这降低了由恶意用户试图哄骗我们的程序以未预料的方式使用特权造成的安全性风险</p>
<p>设置用户ID和组ID的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>使用时注意如下：</p>
<ul>
<li>若进程具有超级用户特权,则 setuid函数将实际用户ID、有效用户ID以及保存的设置用户ID设置为uid</li>
<li>若进程没有超级用户特权,但是uid等于实际用户ID或保存的设置用户ID,则 setid只将有效用户ID设置为uid。不更改实际用户ID和保存的设置用户ID</li>
<li>如果上面两个条件都不满足,则 errno设置为 EPERM,并返回-1</li>
</ul>
<p>关于内核所维护的3个ID，需要注意的事项如下：</p>
<ul>
<li>只有超级用户才可以更改实际用户ID，通常,实际用户ID是在用户登录时,由1ogin(1)程序设置的,而且决不会改变它。</li>
<li>仅当对程序文件设置了设置用户ID位时,exec函数才设置有效用户ID</li>
<li>保存的设置用户ID是由exec复制有效用户ID而得到的</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-04-30-15251013810789.jpg" alt=""></p>
<ol>
<li>函数setreuid和setregid</li>
</ol>
<p>其功能是交换实际用户ID和有效用户ID的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setreuid</span><span class="params">(<span class="keyword">uid_t</span> ruid, <span class="keyword">uid_t</span> euid)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setregid</span><span class="params">(<span class="keyword">gid_t</span> rgid, <span class="keyword">gid_t</span> egid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<ol>
<li>函数seteuid和setegid</li>
</ol>
<p>它们类似于 setuid和 setgid,但只更改有效用户ID和有效组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>各个函数之间的区别</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15251015827722.jpg" alt=""></p>
<h2 id="解释器文件"><a href="#解释器文件" class="headerlink" title="解释器文件"></a>解释器文件</h2><p>所有现今的UNIX系统都支持解释器文件(interpreter file)。这种文件是文本文件,其起始行的形式是：</p>
<p><code>#! pathname [optional-argument]</code></p>
<p>最常见的如下：</p>
<p><code>#! /bin/sh</code></p>
<p>对这种文件的识别是由内核作为exec系统调用处理的一部分来完成的。内核使调用exec函数的进程<strong>实际执行的并不是该解释器文件,而是在该解释器文件第一行中 pathname所指定的文件</strong>。一定要将解释器文件(文本文件,它以#!开头)和解释器(由该解释器文件第一行中的 pathname指定)区分开来</p>
<p>当内核exec解释器(/home/sar/bin/echoarg)时,argv[0]是该解释器的 pathname,argv[1]是解释器文件中的可选参数</p>
<h2 id="函数system"><a href="#函数system" class="headerlink" title="函数system"></a>函数system</h2><p>ISO C定义了system函数,但是其操作对系统的依赖性很强</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: (see below)</span></div></pre></td></tr></table></figure>
<p>如果 cmdstring是一个空指针,则仅当命令处理程序可用时, system返回非0值,这一特征可以确定在一个给定的操作系统上是否支持 system函数。在UNIX中, system总是可用的。</p>
<p>因为 system在其实现中调用了fork、exec和 waitpid,因此有3种返回值<br>(1)fork失败或者 waitpid返回除 EINTR之外的出错,则 system返回-1,并且设置errno以指示错误类型。<br>(2)如果 exec失败(表示不能执行shel1),则其返回值如同 shell执行了exit(127)一样<br>(3)否则所有3个函数(fork、exec和 waitpid)都成功,那么 system的返回值是 shell的终止状态,其格式已在 waitpid中说明。</p>
<p>使用 system而不是直接使用fork和exec的优点是: system进行了所需的各种出错处理以及各种信号处理</p>
<h2 id="进程会计"><a href="#进程会计" class="headerlink" title="进程会计"></a>进程会计</h2><p>大多数UNIX系统提供了一个选项以进行进程会计( process accounting)处理。启用该选项后,每当进程结束时内核就写一个会计记录。典型的会计记录包含总量较小的二进制数据,一般包括<strong>命令名、所使用的CPU时间总量、用户ID和组ID、启动时间</strong>等。</p>
<p>一个至今没有说明的函数(acct)启用和禁用进程会计。唯一使用这一函数的是<code>accton(8)</code>命令(这是在几种平台上都类似的少数几条命令中的一条)。超级用户执行一个带路径名参数的accton命令启用会计处理。会计记录写到指定的文件中</p>
<p>会计记录结构定义在头文件<sys acct.h="">中，每个系统都有不同，但是基本样式如下：</sys></p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251417041152.jpg" alt=""></p>
<p>会计记录所需的各个数据(各CPU时间、传输的字符数等)都由内核保存在进程表中,并在个新进程被创建时初始化(如fork之后在子进程中)。进程终止时写一个会计记录。</p>
<p>这产生两个后果:</p>
<p>第一,我们不能获取永远不终止的进程的会计记录。像init这样的进程在系统生命周期中直在运行,并不产生会计记录。这也同样适合于内核守护进程,它们通常不会终止<br>第二,在会计文件中记录的顺序对应于进程终止的顺序,而不是它们启动的顺序。</p>
<h2 id="用户标识"><a href="#用户标识" class="headerlink" title="用户标识"></a>用户标识</h2><p>任一进程都可以得到其实际用户ID和有效用户ID及组ID。但是,我们有时希望找到运行该程序用户的登录名。</p>
<p>系统通常记录用户登录时使用的名字(见68节),用get1ogin函数可以获取此登录名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getlogin</span><span class="params">(<span class="keyword">void</span>)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to string giving login name if OK, NULL on error</span></div></pre></td></tr></table></figure>
<p>如果调用此函数的进程没有连接到用户登录时所用的终端,则函数会失败。通常称这些进程为守护进程(daemon)</p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>UNIX系统历史上对进程提供的只是基于调度优先级的粗粒度的控制。调度策略和调度优先级是由内核确定的。<strong>进程可以通过调整nice值选择以更低优先级运行</strong>(通过调整nice值降低它对CPU的占有,因此该进程是“友好的”)。只有特权进程允许提高调度权限</p>
<p>Single UNIX Specification中nice值的范围在0~(2*NZERO)-1之间,有些实现支持0~2*NERO。nice值越小,优先级越高。虽然这看起来有点倒退,但实际上是有道理的:你越友好,你的调度优先级就越低。 NERO是系统默认的nice值。</p>
<p>进程可以通过nice函数获取或更改它的nice值。使用这个函数,进程只能影响自己的nce值,不能影响任何其他进程的nice值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">nice</span><span class="params">(<span class="keyword">int</span> incr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: new nice value − NZERO if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>getpriority函数可以像nice函数那样用于获取进程的nice值,但是 getpriority还可以获取一组相关进程的nice值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: nice value between −NZERO and NZERO−1 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>setpriority函数可用于为进程、进程组和属于特定用户ID的所有进程设置优先级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who, <span class="keyword">int</span> value)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h2><p>我们可以度量的3个时间:墙上时钟时间、用户CPU时间和系统CPU时间。任一进程都可调用 times函数获得它自己以及已终止子进程的土述值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">clock_t</span> times(<span class="keyword">struct</span> tms *buf );</div><div class="line"></div><div class="line"><span class="comment">// Returns: elapsed wall clock time in clock ticks if OK, −1 on error</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第8章 进程控制 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 进程环境</title>
    <link href="https://www.liuin.cn/2018/04/29/APUE-%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/"/>
    <id>https://www.liuin.cn/2018/04/29/APUE-进程环境/</id>
    <published>2018-04-29T10:30:25.000Z</published>
    <updated>2018-05-24T06:39:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第7章 进程环境 笔记</p>
<a id="more"></a>
<h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>C程序总是从main函数开始执行，main函数的原型是：</p>
<p><code>int main(int argc, char *argv);</code></p>
<p>其中，argc是命令行参数的数目，argv是指向参数的各个指针所构成的数组</p>
<p>当内核执行C程序时(使用一个exec函数),在调用main前先调用一个特殊的启动例程。可执行程序文件将此启动例程指定为程序的起始地址—这是由连接编辑器设置的,而连接编辑器则由C编译器调用。启动例程从内核取得命令行参数和环境变量值,然后为按上述方式调用main函数做好安排。</p>
<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>有8种方法使得进程终止(termination)，其中5种为正常终止：</p>
<ol>
<li>从main返回</li>
<li>调用exit</li>
<li>调用_exit或_Exit</li>
<li>最后一个线程从其启动例程返回</li>
<li>从最后一个线程调用 pthread_exit</li>
</ol>
<p>异常终止有3种方式,它们是:</p>
<ol>
<li>调用 abort</li>
<li>接到一个信号</li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<blockquote>
<p>退出函数</p>
</blockquote>
<p>3个函数用于正常终止一个程序:_exit和_Exit立即进入内核,exit则先执行一些清理处理,然后返回内核。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>; </div><div class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</div></pre></td></tr></table></figure>
<p><code>exit</code>函数总是执行一个标准I/O库的清理关闭操作:对于所有打开流调用fc1ose函数。这造成输出缓冲中的所有数据都被冲洗(写到文件上)</p>
<p>3个退出函数都带一个整型参数,称为终止状态(或退出状态, exit status)。大多数UNIX系统 shell都提供检查进程终止状态的方法。</p>
<blockquote>
<p>函数atexit</p>
</blockquote>
<p>按照ISO C的规定,一个进程可以登记多至32个函数,这些函数将由exit自动调用。我们称这些函数为终止处理程序( exit handler),并调用 atexit函数来登记这些函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">int atexit(void (*func)(void));</div><div class="line"></div><div class="line">// Returns: 0 if OK, nonzero on error</div></pre></td></tr></table></figure>
<p>其中, <code>atexit</code>的参数是一个函数地址,当调用此函数时无需向它传递任何参数,也不期望它返回一个值。exit调用这些函数的顺序与它们登记时候的顺序相反。同一函数如若登记多次也会被调用多次。</p>
<p>exit首先调用各终止程序，然后关闭（通过fclose）所有打开的流</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250569958373.jpg" alt=""></p>
<p>注意,<strong>内核使程序执行的唯一方法是调用一个exec函数。进程自愿终止的唯一方法是显式或隐式地(通过调用exit)调用exit或Exit</strong>。进程也可非自愿地由一个信号使其终止</p>
<p>atexit函数有点像析构函数的意思</p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>当执行一个程序时,调用exec的进程可将命令行参数传递给该新程序。</p>
<p>ISO C和POSIX.1都要求argv[argc]是一个空指针。这就使我们可以将参数处理循环改写为</p>
<p><code>for(i = 0; argv[i] != NULL; i++)</code></p>
<h2 id="环境表"><a href="#环境表" class="headerlink" title="环境表"></a>环境表</h2><p>每个程序都接收到一张环境表。与参数表一样,<strong>环境表也是一个字符指针数组</strong>,其中每个指针包含一个以null结束的C字符串的地址。全局变量 environ则包含了该指针数组的地址</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250572321583.jpg" alt=""></p>
<h2 id="C程序的存储空间布局"><a href="#C程序的存储空间布局" class="headerlink" title="C程序的存储空间布局"></a>C程序的存储空间布局</h2><p>C程序一直由以下几个部分组成：</p>
<ul>
<li>正文段。这是由CPU执行的机器指令部分。通常,正文段是可共享的</li>
<li>初始化数据段。通常将此段称为数据段,它包含了程序中需明确地赋初值的变量</li>
<li>未初始化数据段。通常将此段称为bss段,这一名称来源于早期汇编程序一个操作符,意思是“由符号开始的块”( block started by symbol),在程序开始执行之前,<strong>内核将此段中的数据初始化为0或空指针</strong>。</li>
<li>栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。</li>
<li>堆。通常在堆中进行动态存储分配。</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-04-30-15250574049036.jpg" alt=""></p>
<p>栈顶和堆顶的虚拟地址空间很大。</p>
<p>未初始化数据段的内容并不存放在磁盘程序文件中。其原因是,内核在程序开始运行前将它们都设置为0。需要存放在磁盘程序文件中的段只有正文段和初始化数据段</p>
<h2 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h2><p>共享库使得<strong>可执行文件中不再需要包含公用的库函数</strong>,而只需在所有进程都可引用的存储区中保存这种库例程的一个副本。程序第一次执行或者第一次调用某个库函数时,<strong>用动态链接方法将程序与共享库函数相链接</strong>。这减少了每个可执行文件的长度,但增加了一些运行时间开销。这种时间开销发生在该程序第一次被执行时,或者每个共享库函数第一次被调用时。共享库的另一个优点是<strong>可以用库函数的新版本代替老版本而无需对使用该库的程序重新连接编辑</strong>(假定参数的数目和类型都没有发生改变)</p>
<h2 id="存储空间分配"><a href="#存储空间分配" class="headerlink" title="存储空间分配"></a>存储空间分配</h2><p>ISO C说明了3个用于存储空间动态分配的函数</p>
<ol>
<li>ma11oc,分配指定字节数的存储区。此存储区中的初始值不确定。</li>
<li>cal1oc,为指定数量指定长度的对象分配存储空间。该空间中的每一位(bit)都初始化为0</li>
<li>rea11oc,增加或减少以前分配区的长度。当增加长度时,可能需将以前分配区的内容移到另一个足够大的区域,以便在尾端提供增加的存储区,而新增区域内的初始值则不确定。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nobj, <span class="keyword">size_t</span> size)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> newsize)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All three return: non-null pointer if OK, NULL on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</div></pre></td></tr></table></figure>
<p>这3个分配函数所返回的指针一定是适当对齐的,使其可用于任何数据对象。</p>
<p>函数free释放ptr指向的存储空间。被释放的空间通常被送入可用存储区池,以后,可在用上述3个分配函数时再分配。</p>
<p>这些分配例程通常用sbrk(2)系统调用实现。该系统调用扩充(或缩小)进程的堆。</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境字符串的形式是 <code>name=value</code></p>
<p>UNIX内核并不查看这些字符串,它们的解释完全取决于各个应用程序。</p>
<p>可以使用getenv函数获得环境变量的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to value associated with name, NULL if not found</span></div></pre></td></tr></table></figure>
<p>此函数返回一个指针,它指向<code>name=value</code>字符串中的 value。</p>
<p>设置环境变量的三个函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, nonzero on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> rewrite)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>用法：</p>
<ul>
<li>putenv取形式为<code>name=value</code>的字符串,将其放到环境表中。如果name已经存在,则先删除其原来的定义。</li>
<li>setenv将name设置为value。</li>
<li>unsetenv删除name的定义</li>
</ul>
<p>环境表(指向实际<code>name=value</code>字符串的指针数组)和环境字符串通常存放在进程存储空间的顶部(栈之上)。删除一个字符串很简单——只要先在环境表中找到该指针,然后将所有后续指针都向环境表首部顺次移动一个位置。但是增加一个字符串或修改一个现有的字符串就困难得多。环境表和环境字符串通常占用的是进程地址空间的顶部,所以它不能再向高地址方向(向上)扩展:同时也不能移动在它之下的各栈帧,所以它也不能向低地址方向(向下)扩展。两者组合使得该空间的长度不能再增加。</p>
<h2 id="函数setjmp和longjmp"><a href="#函数setjmp和longjmp" class="headerlink" title="函数setjmp和longjmp"></a>函数setjmp和longjmp</h2><p>在C中,goto语句是不能跨越函数的,而执行这种类型跳转功能的是函数 setjmp和1ongjmp两个函数对于处理发生在很深层嵌套函数调用中的出错情况是非常有用的</p>
<p>setjmp和1ongjmp函数可以看成一个非局部goto函数。非局部指的是这不是由普通的C语言goto语句在一个函数内实施的跳转,而是在栈上跳过若于调用帧,返回到当前函数调用路径上的某一个函数中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if called directly, nonzero if returning from a call to longjmp</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="函数getrlimit和setrlimit"><a href="#函数getrlimit和setrlimit" class="headerlink" title="函数getrlimit和setrlimit"></a>函数getrlimit和setrlimit</h2><p>每个进程都有一组资源限制,其中一些可以用getrlimit和 setrlimit函数查询和更改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">struct</span> rlimit *rlptr)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> <span class="keyword">struct</span> rlimit *rlptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第7章 进程环境 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 系统数据文件和信息</title>
    <link href="https://www.liuin.cn/2018/04/28/APUE-%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E4%BF%A1%E6%81%AF/"/>
    <id>https://www.liuin.cn/2018/04/28/APUE-系统数据文件和信息/</id>
    <published>2018-04-28T11:26:36.000Z</published>
    <updated>2018-04-30T08:06:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第6章 系统数据文件和信息 笔记</p>
<a id="more"></a>
<h2 id="口令文件"><a href="#口令文件" class="headerlink" title="口令文件"></a>口令文件</h2><p>UNX系统口令文件(POSX1则将其称为用户数据库)包含了如下图所示的各字段,这些字段包含在<pwd.h>中定义的 passwd结构中。</pwd.h></p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250520434469.jpg" alt=""></p>
<p>由于历史原因,口令文件是<code>/etc/passwd</code>,而且是一个ASCII文件。字段之间用冒号分隔。</p>
<p>关于这些信息有以下这些注意事项：</p>
<ul>
<li>通常有一个用户名为root的登录项,其用户ID是0(超级用户）</li>
<li>加密口令包含一个字段，现在出于安全的考虑把加密口令存放在另一个文件中</li>
<li>口令文件项中的某些字段可能是空。如果加密口令字段为空,这通常就意味着该用户没有口令(不推荐这样做)。 </li>
<li>shel字段包含了一个可执行程序名,它被用作该用户的登录 shell.若该字段为空,则取系统默认值,通常是<code>/bin/sh</code>。</li>
<li>为了阻止一个特定用户登录系统,除使用/dev/nu11外,还有若干种替代方法。</li>
</ul>
<p>有两个获取口令文件项的函数。在给出用户登录名或数值用户ID后,这两个函数就能查看相关项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> passwd *<span class="title">getpwuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> passwd *<span class="title">getpwnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
<p>如果想要查看整个口令文件，下面3个函数可以用于此目的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> passwd *<span class="title">getpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer if OK, NULL on error or end of ﬁle</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">endpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>调用<code>getpwent</code>时,它返回口令文件中的下一个记录项。函数<code>setpwent</code>反绕它所使用的文件（倒回到所有口令文件的开始）, <code>endpwent</code>则关闭这些文件</p>
<h2 id="阴影口令"><a href="#阴影口令" class="headerlink" title="阴影口令"></a>阴影口令</h2><p>加密口令是经单向加密算法处理过的用户口令副本。因为此算法是单向的,所以不能从加密口令猜测到原来的口令。</p>
<p>现在,某些系统将加密口令存放在另个通常称为阴影口令( shadow password)的文件中。该文件至少要包含用户名和加密囗令。</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250527613967.jpg" alt=""></p>
<p>阴影口令文件不应是一般用户可以读取的。仅有少数几个程序需要访问加密口令,如1ogin(1)和 passwd(1),这些程序常常是设置用户ID为root的程序。</p>
<h2 id="组文件"><a href="#组文件" class="headerlink" title="组文件"></a>组文件</h2><p>UNIX组文件中包含如下的字段，这些字段在<grp.h>所定义的group的数据结构中</grp.h></p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250528423155.jpg" alt=""></p>
<p>查看组名或数值组ID：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> group *<span class="title">getgrgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>; </div><div class="line"><span class="function"><span class="keyword">struct</span> group *<span class="title">getgrnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
<p>和用户信息一样查看所有组文件函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> group *<span class="title">getgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>; </div><div class="line"><span class="comment">// Returns: pointer if OK, NULL on error or end of ﬁle</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">endgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="附属组ID"><a href="#附属组ID" class="headerlink" title="附属组ID"></a>附属组ID</h2><p>我们不仅可以属于口令文件记录项中组ID所对应的组,也可属于多至16个另外的组。文件访问权限检查相应被修改为:不仅将进程的有效组ID与文件的组ID相比较,而且也将所有附属组ID与文件的组ID进行比较</p>
<p>使用附属组ID的优点是不必再显式地经常更改组。一个用户会参与多个项目,因此也就要同时属于多个组,此类情况是常有的。</p>
<p>以下3个函数用于获取和设置附属组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getgroups</span><span class="params">(<span class="keyword">int</span> gidsetsize, <span class="keyword">gid_t</span> grouplist[])</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: number of supplementary group IDs if OK, −1 on error</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt; /* on Linux */ </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; /* on FreeBSD, Mac OS X, and Solaris */ </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgroups</span><span class="params">(<span class="keyword">int</span> ngroups, <span class="keyword">const</span> <span class="keyword">gid_t</span> grouplist[])</span></span>; </div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt; /* on Linux and Solaris */ </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; /* on FreeBSD and Mac OS X */ </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">initgroups</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *username, <span class="keyword">gid_t</span> basegid)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p><code>getgroups</code>将进程所属用户的各附属组ID填写到数组<code>grouplist</code>中,填写入该数组的附属组ID数最多为 <code>gidsetsize</code>个。实际填写到数组中的附属组ID数由函数返回。</p>
<p><code>setgroups</code>可由超级用户调用以便为调用进程设置附属组ID表。<code>grouplist</code>是组ID数组,而 <code>ngroups</code>说明了数组中的元素数。 <code>ngroups</code>的值不能大于 NGROUPS_MAX.</p>
<h2 id="登录账户记录"><a href="#登录账户记录" class="headerlink" title="登录账户记录"></a>登录账户记录</h2><p>大多数UNIX系统都提供下列两个数据文件:utmp文件记录当前登录到系统的各个用户;wtmp文件跟踪各个登录和注销事件。</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250533552178.jpg" alt=""></p>
<h2 id="系统标识"><a href="#系统标识" class="headerlink" title="系统标识"></a>系统标识</h2><p>有一个uname函数,它返回与主机和操作系统有关的信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/utsname.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">uname</span><span class="params">(<span class="keyword">struct</span> utsname *name)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: non-negative value if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="时间和日期例程"><a href="#时间和日期例程" class="headerlink" title="时间和日期例程"></a>时间和日期例程</h2><p>由UNIX内核提供的基本时间服务是计算自协调世界时公元1970年1月1日00：00：00这一特定时间以来经过的秒数。</p>
<p>用数据结构<code>time_t</code>表示，据类型 time_t表示的,我们称它们为日历时间。日历时间包括时间和日期。UNIX在这方面与其他操作系统的区别是:(a)以协调统一时间而非本地时间计时;(b)可自动进行转换,如变换到夏令时;(c)将时间和日期作为一个量值保存。</p>
<p><code>time</code>函数返回当前时间和日期</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">time_t</span> time(<span class="keyword">time_t</span> *calptr);</div><div class="line"></div><div class="line"><span class="comment">// Returns: value of time if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>时间值作为函数值返回。如果参数非空,则时间值也存放在由calptr指向的单元内</p>
<p>关于日期和时间，有许多相关的函数，以下列出其中一些函数的关系：</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250538112744.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第6章 系统数据文件和信息 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
</feed>
