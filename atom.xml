<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sixzeroo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.liuin.cn/"/>
  <updated>2018-04-26T08:17:53.000Z</updated>
  <id>https://www.liuin.cn/</id>
  
  <author>
    <name>Sixzeroo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>APUE 文件和目录</title>
    <link href="https://www.liuin.cn/2018/04/26/APUE-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
    <id>https://www.liuin.cn/2018/04/26/APUE-文件和目录/</id>
    <published>2018-04-26T06:08:38.000Z</published>
    <updated>2018-04-26T08:17:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第4章 文件和目录 笔记</p>
<a id="more"></a>
<h2 id="函数stat、fstat、fstatat和lstat"><a href="#函数stat、fstat、fstatat和lstat" class="headerlink" title="函数stat、fstat、fstatat和lstat"></a>函数stat、fstat、fstatat和lstat</h2><p>返回文件信息的主要有4个函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">struct</span> stat *buf )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname,<span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All four return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>一旦给出pathname：</p>
<ul>
<li>stat将返回与此命名文件有关的信息结构：</li>
<li>fstat函数获得已在描述符fd上打开文件的有关信息</li>
<li>1stat函数类似于stat,但是当命名的文件是一个符号链接时,1stat返回该符号链接的有关信息,而不是由该符号链接引用的文件的信息。</li>
<li>fstatat函数为一个相对于当前打开目录(由fd参数指向)的路径名返回文件统计信息。</li>
</ul>
<p>第二个参数buf是一个指针，其指向一个我们必须提供的结构。函数来填充由buf指向的结构。其基本格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> stat &#123; </div><div class="line">    <span class="keyword">mode_t</span> st_mode; <span class="comment">/* file type &amp; mode (permissions) */</span> </div><div class="line">    <span class="keyword">ino_t</span> st_ino; <span class="comment">/* i-node number (serial number) */</span> </div><div class="line">    <span class="keyword">dev_t</span> st_dev; <span class="comment">/* device number (file system) */</span> </div><div class="line">    <span class="keyword">dev_t</span> st_rdev; <span class="comment">/* device number for special files */</span> </div><div class="line">    <span class="keyword">nlink_t</span> st_nlink; <span class="comment">/* number of links */</span> </div><div class="line">    <span class="keyword">uid_t</span> st_uid; <span class="comment">/* user ID of owner */</span> </div><div class="line">    <span class="keyword">gid_t</span> st_gid; <span class="comment">/* group ID of owner */</span> </div><div class="line">    <span class="keyword">off_t</span> st_size; <span class="comment">/* size in bytes, for regular files */</span> </div><div class="line">    <span class="keyword">struct</span> timespec st_atim; <span class="comment">/* time of last access */</span> </div><div class="line">    <span class="keyword">struct</span> timespec st_mtim; <span class="comment">/* time of last modification */</span> </div><div class="line">    <span class="keyword">struct</span> timespec st_ctim; <span class="comment">/* time of last file status change */</span> </div><div class="line">    <span class="keyword">blksize_t</span> st_blksize; <span class="comment">/* best I/O block size */</span> </div><div class="line">    <span class="keyword">blkcnt_t</span> st_blocks; <span class="comment">/* number of disk blocks allocated */</span> </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>UNIX系统的大多数文件是普通文件或目录,但是也有另外一些文件类型。文件类型包括如下几种：</p>
<ol>
<li>普通文件（regular file）文本文件或者二进制文件</li>
<li>目录文件（directory file），对一个目录文件具有读权限的任一进程都可以读该目录的内容,但只有内核可以直接写目录文件。</li>
<li>块特殊文件（block special file），这种类型的文件提供对设备(如磁盘)带缓冲的访问,</li>
<li>字符特殊文件(character special file)。这种类型的文件提供对设备不带缓冲的访问</li>
<li>FIFO，用于进程间通信的命名管道</li>
<li>套接字（socket），用于网络间进程通信</li>
<li>符号链接（symbol link），这种类型的文件指向另一个文件</li>
</ol>
<p>文件类型信息包含在stat结构的 st_mode成员中。也可以使用自带的宏确定的文件类型</p>
<h2 id="设置用户ID和设置组ID"><a href="#设置用户ID和设置组ID" class="headerlink" title="设置用户ID和设置组ID"></a>设置用户ID和设置组ID</h2><p>和一个进程相关联的ID有6个：</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247249639065.jpg" alt=""></p>
<ul>
<li>实际用户ID和实际组ID标识我们究竟是谁。这两个字段在登录时取自口令文件中的登录项。通常,在一个登录会话期间这些值并不改变,但是超级用户进程有办法改变</li>
<li>有效用户ID、有效组IDD以及附属组ID决定了我们的文件访问权限</li>
<li>保存的设置用户ID和保存的设置组ID在执行一个程序时包含了有效用户ID和有效组ID的副本</li>
</ul>
<p>通常,有效用户ID等于实际用户ID,有效组ID等于实际组ID</p>
<p>每个文件有一个所有者和组所有者,所有者由stat结构中的<code>st_uid</code>指定,组所有者则由<code>st_gid</code>指定</p>
<h2 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a>文件访问权限</h2><p>st_mode值也包含了对文件的访问权限位。当提及文件时,指的是前面所提到的任何类型的文件。所有文件类型(目录、字符特别文件等)都有访问权限( access permission)。</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247252761376.jpg" alt=""></p>
<p>3类访问权限的使用方式如下：</p>
<ul>
<li>我们用名字打开任一类型的文件时,对该名字中包含的每一个目录,包括它可能隐含的当前工作目录都应具有执行权限。这就是为什么对于目录其执行权限位常被称为搜索位的原因</li>
<li>对于一个文件的读权限决定了我们是否能够打开现有文件进行读操作</li>
<li>对于一个文件的写权限决定了我们是否能够打开现有文件进行写操作</li>
<li>为了在open函数中对一个文件指定O_TRUNC标志,必须对该文件具有写权限</li>
<li>为了在一个目录中创建一个新文件,必须对该目录具有写权限和执行权限</li>
<li>为了删除一个现有文件,必须对包含该文件的目录具有写权限和执行权限。</li>
</ul>
<p>进程每次打开、创建或者删除一个文件的时候，内核就对文件进行访问权限测试。</p>
<p>内核测试的具体内容：</p>
<ol>
<li>若进程的有效用户ID是0(超级用户),则允许访问。这给予了超级用户对整个文件系统进行处理的最充分的自由</li>
<li>若进程的有效用户ID等于文件的所有者ID(也就是进程拥有此文件),那么如果所有者适当的访问权限位被设置,则允许访问;否则拒绝访问。</li>
<li>若进程的有效组ID或进程的附属组ID之一等于文件的组ID,那么如果组适当的访问权限位被设置,则允许访问;否则拒绝访问。</li>
<li>若其他用户适当的访问权限位被设置,则允许访问;否则拒绝访问</li>
</ol>
<h2 id="新文件和目录的所有权"><a href="#新文件和目录的所有权" class="headerlink" title="新文件和目录的所有权"></a>新文件和目录的所有权</h2><p>新文件的用户ID设置为进程的有效用户ID。</p>
<p>关于组ID，POSIX实现有两种方案：</p>
<ul>
<li>进程有效组ID</li>
<li>所在目录的组ID</li>
</ul>
<h2 id="函数access和faccessat"><a href="#函数access和faccessat" class="headerlink" title="函数access和faccessat"></a>函数access和faccessat</h2><p>正如前面所说,当用open函数打开一个文件时,内核以进程的有效用户ID和有效组ID为基础执行其访问权限测试。有时,进程也希望按其实际用户ID和实际组ID来测试其访问能力。</p>
<p><code>access</code>和 <code>faccessat</code>函数是按实际用户ID和实际组ID进行访问权限测试的。(该测试也分成4步）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccessat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p><code>flag</code>参数可以用于改变<code>faccessat</code>的行为,如果<code>fag</code>设置为<code>AT_EACCESS</code>,访问检查用的是调用进程的有效用户ID和有效组D,而不是实际用户ID和实际组ID</p>
<h2 id="函数umask"><a href="#函数umask" class="headerlink" title="函数umask"></a>函数umask</h2><p><code>umask</code>函数为进程设置文件模式创建屏蔽字,并返回之前的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">mode_t</span> umask(<span class="keyword">mode_t</span> cmask);</div><div class="line"></div><div class="line"><span class="comment">// Returns: previous ﬁle mode creation mask</span></div></pre></td></tr></table></figure>
<p><code>cmask</code>是9个权限访问为常量（S_IRUSR、S_IWUSR）的若干个或组成的</p>
<p>在进程创建一个新文件或新目录时,就一定会使用文件模式创建屏蔽字</p>
<p>UNX系统的大多数用户从不处理他们的 umask值。通常在登录时,由 shell的启动文件设置一次,然后,再不改变。</p>
<p>用户可以设置 umask值以控制他们所创建文件的默认权限。该值表示成八进制数,一位代表一种要屏蔽的权限,这示于图4-10中。设置了相应位后,它所对应的权限就会被拒绝常用的几种 umask值是002、022和027。002阻止其他用户写入你的文件,022阻止同组成员和其他用户写入你的文件,027阻止同组成员写你的文件以及其他用户读、写或执行你的文件。</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247265122569.jpg" alt=""></p>
<h2 id="函数chmod、fchmod和fchmodat"><a href="#函数chmod、fchmod和fchmodat" class="headerlink" title="函数chmod、fchmod和fchmodat"></a>函数chmod、fchmod和fchmodat</h2><p>chmod、fchmod和fchmodat这3个函数使我们可以更改现有文件的访问权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmodat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All three return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>chmod函数在指定的文件上进行操作,而fchmod函数则对已打开的文件进行操作。fchmodat函数与chmod函数在下面两种情况下是相同的:一种是 pathname参数为绝对路径另一种是/参数取值为 AT_FDCWD而 pathname参数为相对路径。</p>
<p>为了改变一个文件的权限位,进程的有效用户ID必须等于文件的所有者ID,或者该进程必须具有超级用户权限。</p>
<h2 id="粘着位"><a href="#粘着位" class="headerlink" title="粘着位"></a>粘着位</h2><p>在UNIX尚未使用请求分页式技术的早期版本中, S_ISVTX位被称为粘着位( sticky bit)。如果一个可执行程序文件的这一位被设置了,那么当该程序第一次被执行,在其终止时,程序正文部分的一个副本仍被保存在交换区(程序的正文部分是机器指令)。这使得下次执行该程序时能较快地将其装载入内存。</p>
<p>后来的UNIX版本称它为保存正文位( saved-text bit),因此也就有了常量S_ISVTX。现今较新的UNX系统大多数都配置了虚拟存储系统以及快速文件系统,所以不再需要使用这种技术</p>
<p>现在粘着位的使用方法是：<br>如果对一个目录设置了粘着位,只有对该目录具有写权限的用户并且满足下列条件之一,才能删除或重命名该目录下的文件</p>
<ul>
<li>拥有此文件</li>
<li>拥有此目录</li>
<li>是超级用户</li>
</ul>
<h2 id="函数chown、fchown、fchownat和lchown"><a href="#函数chown、fchown、fchownat和lchown" class="headerlink" title="函数chown、fchown、fchownat和lchown"></a>函数chown、fchown、fchownat和lchown</h2><p>下面几个chown函数可用于更改文件的用户ID和组ID。如果两个参数 owner或 group中的任意一个是-1,则对应的ID不变</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchownat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>; All four <span class="keyword">return</span>: </div><div class="line"></div><div class="line"><span class="comment">// 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>基于BSD的系统一直规定只有超级用户才能更改一个文件的所有者这样做的原因是防止用户改变其文件的所有者从而摆脱磁盘空间限额对他们的限制。 System V则允许任一用户更改他们所拥有的文件的所有者。</p>
<h2 id="文件长度"><a href="#文件长度" class="headerlink" title="文件长度"></a>文件长度</h2><p><code>stat</code>结构成员<code>st_size</code>表示以字节为单位的文件的长度。此字段只对普通文件、目录文件和符号链接有意义。</p>
<p>对于普通文件,其文件长度可以是0；对于目录,文件长度通常是一个数(如16或512)的整倍数；对于符号链接,文件长度是在文件名中的实际字节数。</p>
<p>现今,大多数现代的UNIⅨ系统提供字段stb1ks1ze和st_b1ocks。其中,第一个是对文件I/O较合适的块长度,第二个是所分配的实际512字节块块数。</p>
<blockquote>
<p>文件空洞</p>
</blockquote>
<p>空洞是由所设置的文件偏移量超过文件尾端，并写入了某些数据造成的。</p>
<h2 id="文件截断"><a href="#文件截断" class="headerlink" title="文件截断"></a>文件截断</h2><p>有时我们需要在文件尾端处截去一些数据以缩短文件。将一个文件的长度截断为0是一个特例,在打开文件时使用 O_TRUNC标志可以做到这一点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">off_t</span> length)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>这两个函数将一个现有文件长度截断为 length。如果该文件以前的长度大于 length,则超过length以外的数据就不再能访问。如果以前的长度小于 length,文件长度将增加,在以前的文件尾端和新的文件尾端之间的数据将读作0(也就是可能在文件中创建了一个空洞)</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>目前,正在使用的UNIX文件系统有多种实现。例如, Solaris支持多种不同类型的磁盘文件系统:传统的基于BSD的UNIX文件系统(称为UFS),读、写DOS格式软盘的文件系统(称为PCFS),以及读CD的文件系统(称为HSFS)。</p>
<p>我们可以把一个磁盘分成一个或多个分区。每个分区可以包含一个文件系统，i节点是固定长度的记录项,它包含有关文件的大部分信息。</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247278022212.jpg" alt=""></p>
<p>更仔细地观察一个柱面组的i节点和数据块部分：</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247278729393.jpg" alt=""></p>
<p>在图中有两个目录项指向同一个i节点。每个i节点中都有一个链接计数,其值是指向该i节点的目录项数。只有当链接计数减少至0时,才可删除该文件(也就是可以释放该文件占用的数据块)。这就是为什么“解除对一个文件的链接”操作并不总是意味着“释放该文件占用的磁盘块”的原因。这也是为什么删除一个目录项的函数被称之为<code>un1ink</code></p>
<p>另外一种链接类型称为符号链接( symbolic link)。符号链接文件的实际内容(在数据块中)包含了该符号链接所指向的文件的名字。</p>
<p>节点包含了文件有关的所有信息:文件类型、文件访问权限位、文件长度和指向文件数据块的指针等。stat结构中的大多数信息都取自i节点。只有两项重要数据存放在目录项中:文件名和节点编号。</p>
<p>因为目录项中的i节点编号指向同一文件系统中的相应i节点,<strong>一个目录项不能指向另个文件系统的i节点</strong>。这就是为什么1n(1)命令不能跨越文件系统的原因</p>
<p>当在不更换文件系统的情况下为一个文件重命名时,该文件的实际内容并未移动,只需构造一个指向现有i节点的新目录项,并删除老的目录项。链接计数不会改变。</p>
<p>我们说明了普通文件链接计数的概念，对于目录的链接计数相关方法如下：</p>
<p>任何一个叶目录(不包含任何其他目录的目录)的链接计数总是2,数值2来自于命名该目录( testdir)的目录项以及在该目录中的.项。在父目录中的每一个子目录都使该父目录的链接计数增加1</p>
<h2 id="函数link、linkat、unlink、unlinkat和remove"><a href="#函数link、linkat、unlink、unlinkat和remove" class="headerlink" title="函数link、linkat、unlink、unlinkat和remove"></a>函数link、linkat、unlink、unlinkat和remove</h2><p>创建一个指向现有文件的链接的方法是使用linke或者linkat函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">linkat</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">int</span> nfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>这两个函数创建一个新目录项<code>newpath</code>,它引用现有文件 <code>existingpath</code></p>
<p>为了删除一个现有的目录项、可以调用unlink函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlinkat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>这两个函数删除目录项,并将由pathname所引用文件的链接计数减1。如果对该文件还有其他链接,则仍可通过其他链接访问该文件的数据。如果出错,则不对该文件做任何更改。</p>
<p>我们在前面已经提及,为了解除对文件的链接,必须对包含该目录项的目录具有写和执行权限。如果对该目录设置了粘着位,则对该目录必须具有写权限,并且具备下面三个条件之一:拥有该文件、拥有该目录或者具有超级用户权限</p>
<p>只有当链接计数达到0时,该文件的内容才可被删除。另一个条件也会阻止删除文件的内容——<strong>只要有进程打开了该文件,其内容也不能删除</strong>。关闭一个文件时,内核首先检查打开该文件的进程个数;如果这个计数达到0,内核再去检查其链接计数;如果计数也是0,那么就删除该文件的内容。</p>
<p>ulink的这种特性经常被程序用来确保即使是在程序崩溃时,它所创建的临时文件也不会遗留下来。进程用open或 creat创建一个文件,然后立即调用 unlink,因为该文件仍旧是打开的,所以不会将其内容删除。只有当进程关闭该文件或终止时，该文件的内容才被删除。</p>
<p>我们也可以用<code>remove</code>函数解除对一个文件或目录的链接。对于文件,<code>remove</code>的功能与<code>unlink</code>相同。对于目录,<code>remove</code>的功能与<code>rmdir</code>相同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="函数rename和renameat"><a href="#函数rename和renameat" class="headerlink" title="函数rename和renameat"></a>函数rename和renameat</h2><p>文件或目录可以用 rename函数或者 renameat函数进行重命名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">renameat</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">int</span> newfd,<span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2><p>符号链接是对一个文件的间接指针,它与上一节所述的硬链接有所不同,硬链接直接指向文件的i节点。引入符号链接的原因是为了避开硬链接的一些限制：</p>
<ul>
<li>硬链接通常要求链接和文件位于同一文件系统中。</li>
<li>只有超级用户才能创建指向目录的硬链接(在底层文件系统支持的情况下)。</li>
</ul>
<p>对符号链接以及它指向何种对象并无任何文件系统限制,任何用户都可以创建指向目录的符号链接。符号链接一般用于将一个文件或整个目录结构移到系统中另一个位置</p>
<h2 id="创建和读取符号链接"><a href="#创建和读取符号链接" class="headerlink" title="创建和读取符号链接"></a>创建和读取符号链接</h2><p>可以用symlink或symlikat函数创建一个符号链接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlinkat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>因为open函数跟随符号链接,所以需要有一种方法打开该链接本身,并读该链接中的名字read1ink和 readlinkat函数提供了这种功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> readlink(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize); </div><div class="line"><span class="keyword">ssize_t</span> readlinkat(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize); </div><div class="line"></div><div class="line"><span class="comment">// Both return: number of bytes read if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="文件的时间"><a href="#文件的时间" class="headerlink" title="文件的时间"></a>文件的时间</h2><p>每个文件属性所保存的实际精度依赖于文件系统的实现。对于把时间戳记录在秒级的文件系统来说,纳秒这个字段就会被填充为0。对于时间戳的记录精度高于秒级的文件系统来说,不足秒的值被转换成纳秒并记录在纳秒这个字段中。</p>
<p>每个文件维护3个时间字段：<br><img src="https://data2.liuin.cn/2018-04-26-15247296049968.jpg" alt=""></p>
<p>注意修改时间( st_mtim)和状态更改时间( st_ctim)之间的区别。修改时间是文件内容最后一次被修改的时间。状态更改时间是该文件的i节点最后一次被修改的时间。系统并不维护对一个i节点的最后一次访问时间,所以 access和stat函数并不更改这3个时间中的任一个。</p>
<h2 id="函数futimens、utimensat和utimes"><a href="#函数futimens、utimensat和utimes" class="headerlink" title="函数futimens、utimensat和utimes"></a>函数futimens、utimensat和utimes</h2><p>一个文件的访问和修改时间可以用以下几个函数更改。<code>futimens</code>和<code>utimensat</code>函数可以指定纳秒级精度的时间戳。用到的数据结构是与stat函数族相同的timespec结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimens</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>])</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimensat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>], <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="函数mkdir、mkdirat和rmdir"><a href="#函数mkdir、mkdirat和rmdir" class="headerlink" title="函数mkdir、mkdirat和rmdir"></a>函数mkdir、mkdirat和rmdir</h2><p>用 mkdir和 mkdirat函数创建目录,用rmdir函数删除目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdirat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>这两个函数创建一个新的空目录。其中,.和..目录项是自动创建的。所指定的文件访问权限mode由进程的文件模式创建屏蔽字修改。</p>
<p>用 <code>rmdir</code>函数可以删除一个空目录。空目录是只包含.和..这两项的目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="读目录"><a href="#读目录" class="headerlink" title="读目录"></a>读目录</h2><p>对某个目录具有访问权限的任一用户都可以读该目录,但是,为了防止文件系统产生混乱只有内核才能写目录。</p>
<p>读目录相关的系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>; </div><div class="line"><span class="function">DIR *<span class="title">fdopendir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: pointer if OK, NULL on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> dirent *<span class="title">readdir</span><span class="params">(DIR *dp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer if OK, NULL at end of directory or error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">telldir</span><span class="params">(DIR *dp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: current location in directory associated with dp </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekdir</span><span class="params">(DIR *dp, <span class="keyword">long</span> loc)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="函数chdir、fchdir和getcwd"><a href="#函数chdir、fchdir和getcwd" class="headerlink" title="函数chdir、fchdir和getcwd"></a>函数chdir、fchdir和getcwd</h2><p>每个进程都有一个当前工作目录,此目录是搜索所有相对路径名的起点(不以斜线开始的路径名为相对路径名)。当用户登录到UNIX系统时,其当前工作目录通常是口令文件(/etc/ passwd)中该用户登录项的第6个字段——用户的起始目录( home directory)。当前工作目录是进程的一个属性,起始目录则是登录名的一个属性</p>
<p>进程调用chdir和fchdir函数可以改变当前工作目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchdir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>我们需要一个函数,它从当前工作目录(.)开始,用.找到其上一级目录,然后读其目录项,直到该目录项中的i节点编号与工作目录i节点编号相同,这样地就找到了其对应的文件名按照这种方法,逐层上移,直到遇到根,这样就得到了当前工作目录完整的绝对路径名。很幸运,函数 getcwd就提供了这种功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: buf if OK, NULL on error</span></div></pre></td></tr></table></figure>
<h2 id="文件访问权限位小结"><a href="#文件访问权限位小结" class="headerlink" title="文件访问权限位小结"></a>文件访问权限位小结</h2><p><img src="https://data2.liuin.cn/2018-04-26-15247306715849.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第4章 文件和目录 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>I/O多路复用之Select、Poll和Epoll</title>
    <link href="https://www.liuin.cn/2018/04/20/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8BSelect%E3%80%81Poll%E5%92%8CEpoll/"/>
    <id>https://www.liuin.cn/2018/04/20/I-O多路复用之Select、Poll和Epoll/</id>
    <published>2018-04-20T12:45:23.000Z</published>
    <updated>2018-04-21T08:10:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期写一个在线聊天室的时候接触到epoll，加上之前腾讯面试的时候面试官有问到这一题。这里就对select、poll和epoll做一个总结，目的是让自己更加深入地理解，大部分内容来自网上，可能存在错误，欢迎大家指正。</p>
<a id="more"></a>
<h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p>之前在讲阻塞/非阻塞和同步/异步的理解的时候讲到，在Unix网络I/O中，有三种同步I/O方式：阻塞式I/O、非阻塞式I/O和I/O复用。</p>
<p>I/O多路复用简单来说就是对多个文件进行操作，<strong>通过一种机制一个进程能同时等待多个文件描述符</strong>，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回</p>
<p>select，poll，epoll都是I/O多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>
<h2 id="Linux内核的wakeup-callback机制"><a href="#Linux内核的wakeup-callback机制" class="headerlink" title="Linux内核的wakeup callback机制"></a>Linux内核的wakeup callback机制</h2><p>Linux内核的wakeup callback机制是I/O多路复用存在的本质。Linux内核通过睡眠队列来组织所有等待某个事件的task，而wakeup机制则可以异步唤醒整个睡眠队列上的task，每一个睡眠队列上的节点都拥有一个callback，wakeup逻辑在唤醒睡眠队列时，会遍历该队列链表上的每一个节点，调用每一个节点的callback，如果遍历过程中遇到某个节点是排他节点，则终止遍历，不再继续遍历后面的节点。</p>
<p>总体有两个逻辑：（1）睡眠等待逻辑；（2）唤醒逻辑。</p>
<blockquote>
<p>睡眠等待逻辑</p>
</blockquote>
<ul>
<li>select、poll、epoll_wait陷入内核，判断监控的fd是否有关心的事件发生了，如果没，则为当前task构建一个wait_entry节点，然后插入到监控fd的sleep_list</li>
<li>进入循环的schedule直到关心的事件发生了</li>
<li>关心的事件发生后，将当前task的wait_entry节点从socket的sleep_list中删除</li>
</ul>
<blockquote>
<p>唤醒逻辑</p>
</blockquote>
<ul>
<li>fd监听的事件发生了，然后fd顺序遍历其睡眠队列，依次调用每个wait_entry节点的callback函数</li>
<li>直到完成队列的遍历或遇到某个wait_entry节点是排他的才停止</li>
<li>一般情况下callback包含两个逻辑：1.wait_entry自定义的私有逻辑；2.唤醒的公共逻辑，主要用于将该wait_entry的task放入CPU的就绪队列，让CPU随后可以调度其执行。</li>
</ul>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</div></pre></td></tr></table></figure>
<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。nfds表示所有监视的文件描述符中最高的数+1，同时可以定义时间timeout，超过时间将返回0。</p>
<p>调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>当用户进程调用select的时候，select会将需要监控的readfds集合拷贝到内核空间（假设监控的仅仅是fd可读），然后遍历自己监控的fd_sk，挨个调用sk的poll逻辑以便检查该sk是否有可读事件，遍历完所有的sk后，如果没有任何一个sk可读，那么select会调用schedule_timeout进入schedule循环，使得process进入睡眠。如果在timeout时间内某个sk上有数据可读了，或者等待timeout了，则调用select的process会被唤醒，接下来select就是遍历监控的sk集合，挨个收集可读事件并返回给用户了</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。</p>
<p>但是通过上面实现的分析，select还存在的问题是：</p>
<ul>
<li>被监控的fds需要从用户空间拷贝到内核空间。为了减少数据拷贝带来的性能损坏，内核对被监控的fds集合大小做了限制，并且这个是通过宏控制的，大小不可改变(限制为1024)。</li>
<li>被监控的fds集合中，只要有一个有数据可读，整个socket集合就会被遍历一次调用sk的poll函数收集可读事件。由于当初的需求是朴素，仅仅关心是否有数据可读这样一个事件，当事件通知来的时候，由于数据的到来是异步的，我们不知道事件来的时候，有多少个被监控的socket有数据可读了，于是，只能挨个遍历每个socket来收集可读事件，但是我们希望的是能够从通知中得到有可读事件的fds列表，而不是需要遍历整个fds来收集</li>
</ul>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div></pre></td></tr></table></figure>
<p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的数组实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> pollfd &#123;</div><div class="line">   <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></div><div class="line">   <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span></div><div class="line">   <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>fd表示检测的文件描述符，要测试的条件由 events成员指定,函数在相应的 revents成员中返回该描述符的状态。和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>
<p>poll虽然解决了fds集合大小1024的限制问题，但是，它并没改变大量描述符数组被整体复制于用户态和内核态的地址空间之间，以及个别描述符就绪触发整体描述符集合的遍历的低效问题。poll随着监控的socket集合的增加性能线性下降，poll不适合用于大并发场景。</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>epoll含有的接口有三个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;   </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span></span></div><div class="line">                      <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout);</div></pre></td></tr></table></figure>
<blockquote>
<p>epoll_create</p>
</blockquote>
<p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</p>
<p>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽</p>
<blockquote>
<p>epoll_ctl</p>
</blockquote>
<p>对由<code>epfd</code>所引用的epoll实例进行操作，其中<code>op</code>表示操作类型(包含增删改)，<code>fd</code>表示操作的目标文件描述符，<code>event</code>和文件描述符相关联表示具体监听什么事件，以下是<code>event</code>的具体数据结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</div><div class="line">   <span class="keyword">void</span>        *ptr;</div><div class="line">   <span class="keyword">int</span>          fd;</div><div class="line">   <span class="keyword">uint32_t</span>     u32;</div><div class="line">   <span class="keyword">uint64_t</span>     u64;</div><div class="line">&#125; <span class="keyword">epoll_data_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> epoll_event &#123;</div><div class="line">   <span class="keyword">uint32_t</span>     events;      <span class="comment">/* 监听的事件属性，通常包含：读、写、出错、挂断等等 */</span></div><div class="line">   <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* 事件信息 */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>epoll_wait</p>
</blockquote>
<p>等待<code>epfd</code>所引用的epoll实例上的I/O就绪，同时用<code>events</code>来获得从内核得到的事件集合、<code>maxevents</code>表示传入的events有多少</p>
<p>函数返回以后可以遍历event数组，对已经就绪的I/O进行处理。</p>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>在每个事件的属性中可以设置对文件描述符的工作模式，有两种模式：水平触发LT（level trigger）和边沿出发ET（edge trigger）。LT模式是默认模式。两种模式的区别如下：</p>
<p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序可以不立即处理该事件</strong>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p>
<p>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序必须立即处理该事件</strong>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<p>对于可读事件而言，在ET模式下，如果某个socket有新的数据到达，那么该sk就会被排入epoll的ready_list，从而epoll_wait就一定能收到可读事件的通知(调用sk的poll逻辑一定能收集到可读事件)。于是，我们通常理解的缓冲区状态变化(从无到有)的理解是不准确的，准确的理解应该是是否有新的数据达到缓冲区。</p>
<p>而在LT模式下，某个sk被探测到有数据可读，那么该sk会被重新加入到read_list，那么在该sk的数据被全部取走前，下次调用epoll_wait就一定能够收到该sk的可读事件(调用sk的poll逻辑一定能收集到可读事件)，从而epoll_wait就能返回。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><blockquote>
<p>fds集合拷贝问题的解决</p>
</blockquote>
<p>细看select或poll的函数原型，我们会发现，每次调用select或poll都在重复地准备(集中处理)整个需要监控的fds集合。然而对于频繁调用的select或poll而言，fds集合的变化频率要低得多，我们没必要每次都重新准备(集中处理)整个fds集合。</p>
<p>于是，epoll引入了epoll_ctl系统调用，将高频调用的epoll_wait和低频的epoll_ctl隔离开。同时，epoll_ctl通过(EPOLL_CTL_ADD、EPOLL_CTL_MOD、EPOLL_CTL_DEL)三个操作来分散对需要监控的fds集合的修改，做到了有变化才变更，将select或poll高频、大块内存拷贝(集中处理)变成epoll_ctl的低频、小块内存的拷贝(分散处理)，避免了大量的内存拷贝。同时，对于高频epoll_wait的可读就绪的fd集合返回的拷贝问题，epoll通过内核与用户空间mmap(内存映射)同一块内存来解决。mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址（不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理地址），使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。</p>
<p>另外，epoll通过epoll_ctl来对监控的fds集合来进行增、删、改，那么必须涉及到fd的快速查找问题，于是，一个低时间复杂度的增、删、改、查的数据结构来组织被监控的fds集合是必不可少的了。在linux 2.6.8之前的内核，epoll使用hash来组织fds集合，于是在创建epoll fd的时候，epoll需要初始化hash的大小。于是epoll_create(int size)有一个参数size，以便内核根据size的大小来分配hash的大小。在linux 2.6.8以后的内核中，epoll使用红黑树来组织监控的fds集合，于是epoll_create(int size)的参数size实际上已经没有意义了。</p>
<blockquote>
<p>按需遍历就绪的fds集合</p>
</blockquote>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)</p>
<p>其优点主要有如下几点：</p>
<ul>
<li>监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于1024</li>
<li>IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>监视事件数量</p>
</blockquote>
<p>select受限于1024（依据系统而定），poll虽然数量上没有收到限制，但是因为需要轮询数量非常大的时候性能会下降，epoll在数量和性能上面都没有限制</p>
<blockquote>
<p>实现方式</p>
</blockquote>
<p>select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用 epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在 epoll_wait中进入睡眠的进程<br>虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的 时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间，这就是回调机制带来的性能提升。</p>
<blockquote>
<p>开销</p>
</blockquote>
<p>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内 部定义的等待队列），这也能节省不少的开销</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Unix网络编程》</li>
<li><a href="https://segmentfault.com/a/1190000003063859#articleHeader9" target="_blank" rel="external">https://segmentfault.com/a/1190000003063859#articleHeader9</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1005481" target="_blank" rel="external">https://cloud.tencent.com/developer/article/1005481</a></li>
<li><a href="http://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="external">http://www.cnblogs.com/Anker/p/3265058.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期写一个在线聊天室的时候接触到epoll，加上之前腾讯面试的时候面试官有问到这一题。这里就对select、poll和epoll做一个总结，目的是让自己更加深入地理解，大部分内容来自网上，可能存在错误，欢迎大家指正。&lt;/p&gt;
    
    </summary>
    
      <category term="开发随笔" scheme="https://www.liuin.cn/categories/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Unix" scheme="https://www.liuin.cn/tags/Unix/"/>
    
  </entry>
  
  <entry>
    <title>《Effective C++》 笔记</title>
    <link href="https://www.liuin.cn/2018/04/19/%E3%80%8AEffective-C-%E3%80%8B-%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.liuin.cn/2018/04/19/《Effective-C-》-笔记/</id>
    <published>2018-04-19T08:18:10.000Z</published>
    <updated>2018-04-25T15:03:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>《Effective C++》的副标题是改善程序与设计的55个具体做法。这本书用比较多的示例展示了很多改善C++程序的方法，值得一读。</p>
<a id="more"></a>
<h2 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h2><h3 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款01：视C++为一个语言联邦</h3><p>C++高效编程守则视状况而变化,取决于你使用C++的哪一部分。</p>
<h3 id="条款02：尽量以const，enum，inline替换-define"><a href="#条款02：尽量以const，enum，inline替换-define" class="headerlink" title="条款02：尽量以const，enum，inline替换#define"></a>条款02：尽量以const，enum，inline替换#define</h3><p>“宁可以编译器替换预处理器”</p>
<p>当我们以常量替换<code>#defines</code>,有两种特殊情况值得说说。第一是定义常量指针( constant pointers)。由于常量定义式通常被放在头文件内(以便被不同的源码含入),因此有必要将指针(而不只是指针所指之物)声明为<code>const</code></p>
<p>第二个值得注意的是<code>class</code>专属常量。为了将常量的作用域(scope)限制于<code>class</code>内,你必须让它成为 class一个成员(member);而为确保此常量至多只有一份实体,你必须让它成为一个<code>static</code>成员:</p>
<blockquote>
<p>重点</p>
<ul>
<li>对于单纯常量,最好以 const对象或 enums替换#defines</li>
<li>对于形似函数的宏( macros),最好改用 inline函数替换#defines</li>
</ul>
</blockquote>
<h3 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h3><p>const的一件奇妙的事情是，它允许你指定一个语义约束，而编译器会强制执行这项约束。</p>
<p>const语法虽然变化多端,但并不莫测高深。如果关键字const出现在星号左边,表示被指物是常量(底层const)；如果出现在星号右边,表示指针自身是常量(顶层const);如果出现在星号两边,表示被指物和指针两者都是常量。</p>
<p>const最具威力的用法是面对函数声明时的应用。在一个函数声明式内, const可以和函数返回值、各参数、函数自身(如果是成员函数)产生关联。</p>
<blockquote>
<p>const 成员函数</p>
</blockquote>
<p>将 const实施于成员函数的目的,是为了确认该成员函数可作用于 const对象身上。这一类成员函数之所以重要,基于两个理由。第一,它们使 class接口比较容易被理解。这是因为,得知哪个函数可以改动对象内容而哪个函数不行,很是重要。第二,它们使“操作 const对象”成为可能。</p>
<blockquote>
<p>重点</p>
<ul>
<li>将某些东西声明为 const可帮助编译器侦测出错误用法。 const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体</li>
<li>当 const和non- const成员函数有着实质等价的实现时,令non- const版本调用 const版本可避免代码重复。</li>
</ul>
</blockquote>
<h3 id="条款04：确认确认对象使用前已被初始化"><a href="#条款04：确认确认对象使用前已被初始化" class="headerlink" title="条款04：确认确认对象使用前已被初始化"></a>条款04：确认确认对象使用前已被初始化</h3><p>在某些语境下x保证被初始化(为0),但在其他语境中却不保证。<strong>读取未初始化的值会导致不明确行为</strong></p>
<p>对于内置类型之外的东西，初始化的任务落在了构造函数的身上。我们要确保每一个构造函数都将对象的每一个成员初始化。但是我们很容易混淆复制和初始化的而例子，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; b);</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> thea;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> theb;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">A::A(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; b)</div><div class="line">&#123;</div><div class="line">    thea = a;   <span class="comment">// 这些都是赋值，而非初始化</span></div><div class="line">    theb = b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>C++规定,对象的成员变量的初始化动作发生在进入构造函数本体之前。所以构造函数最好使用成员初值列进行初始化。</p>
<blockquote>
<p>重点</p>
<ul>
<li>为内置型对象进行手工初始化,因为C++不保证初始化它们。</li>
<li>构造函数最好使用成员初值列( member initialization list),而不要在构造函数本体内使用赋值操作( assignment)。初值列列出的成员变量,其排列次序应该和它们在 class中的声明次序相同。</li>
</ul>
</blockquote>
<h2 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h2><h3 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款05：了解C++默默编写并调用哪些函数</h3><p>如果你自己没声明,编译器就会为它声明(编译器版本的)一个copy构造函数、一个 copy assignment操作符和一个析构函数。此外如果你没有声明任何构造函数,编译器也会为你声明一个 default构造函数。所有这些函数都是 public且in1ine。</p>
<p>default构造函数和析构函数主要是给编译器一个地方用来放置“藏身幕后”的代码,像是调用 base classes和non-static成员变量的构造函数和析构函数。</p>
<p>至于copy构造函数和 copy assignment操作符,编译器创建的版本只是单纯地将来源对象的每一个non- static成员变量拷贝到目标对象。</p>
<blockquote>
<p>重点</p>
<ul>
<li>编译器可以暗自为 class创建default构造函数、copy构造函数、 copy assignment操作符,以及析构函数。</li>
</ul>
</blockquote>
<h3 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>如果你不希望 class支持某一特定机能,只要不声明对应函数就是了。但这个策略对copy构造函数和copy assignment操作符却不起作用</p>
<p>所有编译器产出的函数都是 public.为阻止这些函数被创建出来,你得自行声明它们,但这里并没有什么需求使你必须将它们声明为 public。因此你可以将cory构造函数或 copy assignment操作符声明为 private。藉由明确声明一个成员函数,你阻止了编译器暗自创建其专属版本;而令这些函数为 private,使你得以成功组织别人调用他</p>
<blockquote>
<p>重点</p>
<ul>
<li>为驳回编译器自动(暗自)提供的机能,可将相应的成员函数声明为 private并且不予实现。</li>
</ul>
</blockquote>
<h3 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h3><p>C++明白指出,当 derived class对象经由一个base class指针被删除,而该 base class带着一个non- virtual析构函数,其结果未有定义实际执行时通常发生的是对象的 derived成分没被销毁。</p>
<p>消除这个问题的做法很简单:给 base class一个 virtua析构函数</p>
<blockquote>
<p>重点</p>
<ul>
<li>polymorphic(带多态性质的) base classes应该声明一个 virtual析构函数。如果class带有任何 virtual函数,它就应该拥有一个 virtual析构函数。</li>
</ul>
</blockquote>
<h3 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h3><p>C++并不禁止析构函数吐出异常,但它不鼓励你这样做。理由是当有多个（比如在vector中）对象需要销毁的时候，第一个对象和第二个对象析构是都抛出异常，这种情况下程序不是结束执行就是导致未定义行为。</p>
<blockquote>
<p>重点</p>
<ul>
<li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常,析构函数应该捕捉任何异常,然后吞下它们(不传播)或结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应,那么 class应该提供一个普通函数(而非在析构函数中)执行该操作。</li>
</ul>
</blockquote>
<h3 id="条款09：绝不要在构造函数和析构函数中调用virtual函数"><a href="#条款09：绝不要在构造函数和析构函数中调用virtual函数" class="headerlink" title="条款09：绝不要在构造函数和析构函数中调用virtual函数"></a>条款09：绝不要在构造函数和析构函数中调用virtual函数</h3><p>在base class构造期间，virtual函数不是virtual函数。</p>
<blockquote>
<p>重点</p>
<ul>
<li>在构造和析构期间不要调用 virtual函数,因为这类调用从不下降至 derived class(比起当前执行构造函数和析构函数的那层)</li>
</ul>
</blockquote>
<h3 id="条款10：令operator-返回一个-reference-to-this"><a href="#条款10：令operator-返回一个-reference-to-this" class="headerlink" title="条款10：令operator= 返回一个 reference to *this"></a>条款10：令operator= 返回一个 reference to *this</h3><p>复制可以写成连锁形式：</p>
<p><code>x = y = z = 15;</code></p>
<p>同时赋值采用右结合律,所以上述连锁赋值被解析为:</p>
<p><code>x = (y = (z = 15));</code></p>
<p>为了实现“连锁赋值”,赋值操作符必须返回一个 reference指向操作符的左侧实参。</p>
<blockquote>
<p>重点</p>
<ul>
<li>令赋值( assignment)操作符返回一个 reference to *this。</li>
</ul>
</blockquote>
<h3 id="条款11：在operator-中处理“自我赋值”"><a href="#条款11：在operator-中处理“自我赋值”" class="headerlink" title="条款11：在operator= 中处理“自我赋值”"></a>条款11：在operator= 中处理“自我赋值”</h3><p>“自我赋值“发生在对象赋值给自己时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Widget &#123; ... &#125; ;</div><div class="line">Widget w;</div><div class="line">...</div><div class="line">w = w;</div></pre></td></tr></table></figure>
<p>这看起来有点愚蠢,但它合法,所以不要认定客户绝不会那么做。</p>
<p>自我赋值可能出现的一个问题是, operator=函数内的*this(赋值的目的端)和rhs有可能是同一个对象。果真如此 delete就不只是销毁当前对象的 bitmap,它也销毁rhs的 bitmap。</p>
<p>欲阻止这种错误,传统做法是藉由 operator=最前面的一个“证同测试( identitytest)”达到“自我赋值”的检验目的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>重点</p>
<ul>
<li>确保当对象自我赋值时 operator=有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及 copy-and-swap。</li>
<li>确定任何函数如果操作一个以上的对象,而其中多个对象是同一个对象时,其行为仍然正确。</li>
</ul>
</blockquote>
<h3 id="条款12：复制对象时勿忘其每一个成分"><a href="#条款12：复制对象时勿忘其每一个成分" class="headerlink" title="条款12：复制对象时勿忘其每一个成分"></a>条款12：复制对象时勿忘其每一个成分</h3><blockquote>
<p>重点</p>
<ul>
<li>Copying函数应该确保复制“对象内的所有成员变量”及“所有 base class成分”。</li>
<li>不要尝试以某个 copying函数实现另一个 copying函数。应该将共同机能放进第三个函数中,并由两个 coping函数共同调用。</li>
</ul>
</blockquote>
<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h3 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h3><p>有的时候我们我们使用工厂函数获得某个特定的对象的指针的时候，在使用完毕时候需要将其占用的空间释放，尽管我们有这个意识，但是在实际开发中，如果中间出现异常或者return可能会造成内存泄漏的现象。</p>
<p>为了确保使用工厂函数返回的资源总是被释放,我们需要将资源放进对象内,当控制流离开f,<strong>该对象的析构函数会自动释放那些资源</strong>。实际上这正是隐身于本条款背后的半边想法:把资源放进对象内,我们便可倚赖C++的“析构函数自动调用机制”确保资源被释放。(稍后讨论另半边想法。)</p>
<blockquote>
<p>重点</p>
<ul>
<li>为防止资源泄漏,请使用RAII对象,它们在构造函数中获得资源并在析构函数中释放资源</li>
<li>两个常被使用的 RAII classes分别是trl::shared_ptr和 auto_ptr。前者通常是较佳选择,因为其copy行为比较直观。若选择 auto_ptr,复制动作会使它(被复制物)指向null</li>
</ul>
</blockquote>
<h3 id="条款14：在资源管理类中小心coping行为"><a href="#条款14：在资源管理类中小心coping行为" class="headerlink" title="条款14：在资源管理类中小心coping行为"></a>条款14：在资源管理类中小心coping行为</h3><p>我们使用C API管理一个互斥对象的时候，有lock和unlock两个函数可以用；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(Mutex* pm)</span></span>;     <span class="comment">// 锁定</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(Mutex* pm)</span></span>;   <span class="comment">// 解锁</span></div></pre></td></tr></table></figure>
<p>为了确保不会忘记解锁一个互斥量，我们可以使用上一个条款的建议，创建一个对象来管理这个互斥量，使得“资源在构造期间获得，在析构期间释放”</p>
<p>但是如果这个对象发生复制的时候怎么办？大多时候有以下两种可行的方案：</p>
<ul>
<li>禁止复制</li>
<li>对底层资源祭出“引用计数法”（reference-count）</li>
</ul>
<blockquote>
<p>重点</p>
<ul>
<li>复制RAII对象必须一并复制它所管理的资源,所以资源的copying行为决定RAII对象的copying行为。</li>
<li>普遍而常见的 Rail class copying行为是:抑制 copying、施行引用计数法( reference counting)。不过其他行为也都可能被实现</li>
</ul>
</blockquote>
<h3 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h3><p>资源管理类( resource-managing classes)很棒。它们是你对抗资源泄漏的堡垒。排除此等泄漏是良好设计系统的根本性质。在一个完美世界中你将倚赖这样的classes来处理和资源之间的所有互动,而不是玷污双手直接处理原始资源(rawresources)。但这个世界并不完美。许多APIs直接指涉资源,所以除非你发誓(这其实是一种少有实际价值的举动)永不录用这样的APls,否则只得绕过资源管理对象( resource-managing objects)直接访问原始资源( raw resources)。</p>
<p>由于有时候还是必须取得RAI对象内的原始资源,某些 RAII class设计者于是联想到“将油脂涂在滑轨上”,做法是提供一个显示转换函数或者隐式转换函数。</p>
<blockquote>
<p>重点</p>
<ul>
<li>APIs往往要求访问原始资源( raw resources),所以每一个 RAII class应该提供一个“取得其所管理之资源”的办法。</li>
<li>对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全,但隐式转换对客户比较方便。</li>
</ul>
</blockquote>
<h3 id="条款16：成对使用new和delete时要采取相同格式"><a href="#条款16：成对使用new和delete时要采取相同格式" class="headerlink" title="条款16：成对使用new和delete时要采取相同格式"></a>条款16：成对使用new和delete时要采取相同格式</h3><p>当你使用new(也就是通过new动态生成一个对象),有两件事发生。第内存被分配出来(通过名为 operator new的函数)。第二,针对此内存会有一个(或更多)构造函数被调用。</p>
<p>当你使用 delete,也有两件事发生:针对此内存会有一个(或更多)析构函数被调用,然后内存才被释放(通过名为 operator delete的函数)。</p>
<p>delete的最大问题在于:即将被删除的内存之内究竟存有多少对象?这个问题的答案决定了有多少个析构函数必须被调用起来。实际上这个问题可以更简单些:即将被删除的那个指针,所指的是单一对象或对象数组?这是个必不可缺的问题,因为单一对象的内存布局一般而言不同于数组的内存布局。</p>
<p>所以在成对使用new和delete的时候要采取相同的形式</p>
<blockquote>
<p>重点</p>
<ul>
<li>如果你在new表达式中使用[],必须在相应的de1ete表达式中也使用[]。如果你在new表达式中不使用[],一定不要在相应的 delete表达式中使用[]</li>
</ul>
</blockquote>
<h3 id="条款17：以独立语句将newed对象置入智能指针"><a href="#条款17：以独立语句将newed对象置入智能指针" class="headerlink" title="条款17：以独立语句将newed对象置入智能指针"></a>条款17：以独立语句将newed对象置入智能指针</h3><blockquote>
<p>重点</p>
<ul>
<li>以独立语句将 newed对象存储于(置入)智能指针内。如果不这样做,一旦异常被抛出,有可能导致难以察觉的资源泄漏。</li>
</ul>
</blockquote>
<h2 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h2><h3 id="条款18：让接口容易被正确使用，不容易被误用"><a href="#条款18：让接口容易被正确使用，不容易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不容易被误用"></a>条款18：让接口容易被正确使用，不容易被误用</h3><blockquote>
<p>重点</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Effective C++》的副标题是改善程序与设计的55个具体做法。这本书用比较多的示例展示了很多改善C++程序的方法，值得一读。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C/C++" scheme="https://www.liuin.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>APUE 信号</title>
    <link href="https://www.liuin.cn/2018/04/18/APUE-%E4%BF%A1%E5%8F%B7/"/>
    <id>https://www.liuin.cn/2018/04/18/APUE-信号/</id>
    <published>2018-04-18T13:37:51.000Z</published>
    <updated>2018-04-19T01:28:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第10章 信号 笔记</p>
<a id="more"></a>
<p>信号是软件中断。很多比较重要的应用程序都需处理信号。信号提供了一种<strong>处理异步事件</strong>的方法,例如,终端用户键入中断键,会通过信号机制停止一个程序,或及早终止管道中的下一个程序。</p>
<h2 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h2><p>每个信号都有一个名字，这些名字都以3个字符SIG开头，比如：SIGINT中断信号、SIGABRT夭折信号、SIGALRM闹钟信号。</p>
<p>产生信号的条件：</p>
<ul>
<li>当用户按某些终端键时,引发终端产生的信号。</li>
<li>硬件异常产生信号:除数为0、无效的内存引用等。</li>
<li>进程调用ki11(2)函数可将任意信号发送给另一个进程或进程组。</li>
<li>用户可用ki11(1)命令将信号发送给其他进程</li>
<li>当检测到某种软件条件已经发生,并应将其通知有关进程时也产生信号</li>
</ul>
<p>信号是异步事件的经典实例。产生信号的事件对进程而言是随机出现的。进程不能简单地测试一个变量(如 errno)来判断是否发生了一个信号,而是必须告诉内核“在此信号发生时,请执行下列操作”。</p>
<p>在某个信号出现时,可以告诉内核按下列3种方式之一进行处理,我们称之为信号的处理或与信号相关的动作：</p>
<ul>
<li>忽略此信号，有两种信号不能被忽略，它们是 SIGKILL和 SIGSTOP。这两种信号不能被忽略的原因是:它们向内核和超级用户提供了使进程终止或停止的可靠方法。</li>
<li>捕捉信号，通知内核在某种信号发生时,调用一个用户函数。在用户函数中,可执行用户希望对这种事件进行的处理。</li>
<li>执行系统默认操作</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-04-18-15240592901538.jpg" alt=""></p>
<h2 id="函数signal"><a href="#函数signal" class="headerlink" title="函数signal"></a>函数signal</h2><p>UNX系统信号机制最简单的接口是 signa1函数，其用于捕获信号，并捕获以后发生什么事情。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> signo, <span class="keyword">void</span> (*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>); </div><div class="line"></div><div class="line"><span class="comment">//Returns: previous disposition of signal (see following) if OK, SIG_ERR on error</span></div></pre></td></tr></table></figure>
<p><code>signo</code>参数是信号名。<code>func</code>的值是常量SIG_IGN、常量SIG_DEL或当接到此信号后要调用的函数的地址。<code>SIG_IGN</code>表示向内核表示忽略此信号(记住有两个信号 SIGKILI和 SIGSTOP不能忽略)。SIG_DEL表示接到此信号后的动作是系统默认动作。</p>
<p>当指定函数地址时，则在信号发生时，调用该函数，我们称这种处理为捕获该信号，称此函数为信号处理程序( signal handler)或信号捕捉函数 (signal-catching function)</p>
<blockquote>
<p>程序启动</p>
</blockquote>
<p>当执行一个程序时,所有信号的状态都是系统默认或忽略。通常所有信号都被设置为它们的默认动作,除非调用exec的进程忽略该信号。确切地讲,<strong>exec函数将原先设置为要捕捉的信号都更改为默认动作</strong>,其他信号的状态则不变(一个进程原先要捕捉的信号,当其执行一个新程序后,就不能再捕捉了,因为信号捕捉函数的地址很可能在所执行的新程序文件中已无意义)。</p>
<blockquote>
<p>进程创建</p>
</blockquote>
<p>当一个进程调用fork时,其子进程继承父进程的信号处理方式。因为子进程在开始时复制了父进程内存映像,所以信号捕捉函数的地址在子进程中是有意义的</p>
<h2 id="不可靠信号"><a href="#不可靠信号" class="headerlink" title="不可靠信号"></a>不可靠信号</h2><p>在早期的UNX版本中(如V7),信号是不可靠的。不可靠在这里指的是,信号可能会丢失。一个信号发生了,但进程却可能一直不知道这一点。同时,进程对信号的控制能力也很差,它能捕捉信号或忽略它。有时用户希望通知内核阻塞某个信号:不要忽略该信号,在其发生时记住它然后在进程做好了准备时再通知它。这种阻塞信号的能力当时并不具备</p>
<p>这些早期版本的另一个问题是:在进程不希望某种信号发生时,它不能关闭该信号。进程能做的一切就是忽略该信号。</p>
<h2 id="中断的系统调用"><a href="#中断的系统调用" class="headerlink" title="中断的系统调用"></a>中断的系统调用</h2><p>早期UNX系统的一个特性是:如果进程在执行一个低速系统调用而阻塞期间捕捉到一个信号,则该系统调用就被中断不再继续执行。该系统调用返回出错,其erno设置为EINTR。</p>
<p>为了支持这种特性,将系统调用分成两类:低速系统调用和其他系统调用。低速系统调用是可能会使进程永远阻塞的类系统调用。</p>
<p>可以用中断系统调用这种方法来处理的一个例子是:一个进程启动了读终端操作,而使用该终端设备的用户却离开该终端很长时间。在这种情况下,进程可能处于阻塞状态几个小时甚至数天,除非系统停机,否则一直如此</p>
<h2 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h2><p>进程捕捉到信号并对其进行处理时,进程正在执行的正常指令序列就被信号处理程序临时中断,它首先执行该信号处理程序中的指令。如果从信号处理程序返回,则继续执行在捕捉到信号时进程正在执行的正常指令序列(这类似于发生硬件中断时所做的)。但在信号处理程序中,<strong>不能判断捕捉到信号时进程执行到何处</strong>。</p>
<p>在信号处理函数中保证调用安全的函数（可以被安全中断的函数），这些函数是<strong>可重入的</strong>并被称之为<strong>异步信号安全的</strong></p>
<p>大多数函数是不可重入的,因为<br>(a)已知它们使用静态数据结构;<br>(b)它们调用mal1oc或free;<br>(c)它们是标准I/O函数。标准IO库的很多实现都以不可重入方式使用全局数据结构</p>
<h2 id="可靠信号术语与语义"><a href="#可靠信号术语与语义" class="headerlink" title="可靠信号术语与语义"></a>可靠信号术语与语义</h2><p>我们需要先定义一些在讨论信号时会用到的术语。首先,当造成信号的事件发生时,为进程产生一个信号(或向一个进程发送一个信号)。事件可以是硬件异常(如除以0)、软件条件(如a1arm定时器超时)、终端产生的信号或调用ki11函数。当一个信号产生时,<strong>内核通常在进程表中以某种形式设置一个标志</strong>。</p>
<p>当对信号采取了这种动作时,我们说向进程递送了一个信号。在信号产生(generation)和递送(delivery)之间的时间间隔内,称信号是<strong>未决的</strong>(pending)</p>
<p>进程可以选用“阻塞信号递送”。如果为进程产生了一个阻塞的信号,而且对该信号的动作是系统默认动作或捕捉该信号,则为该进程将此信号保持为未决状态,直到该进程对此信号解除了阻塞,或者将对此信号的动作更改为忽略。内核在递送一个原来被阻塞的信号给进程时(而不是在产生该信号时),才决定对它的处理方式。于是进程在信号递送给它之前仍可改变对该信号的动作。进程调用<code>sigpending</code>函数来判定哪些信号是设置为阻塞并处于未决状态的。</p>
<p>每个进程都有一个信号屏蔽字( signal mask.),它规定了当前要阻塞递送到该进程的信号集。对于每种可能的信号,该屏蔽字中都有一位与之对应。对于某种信号,若其对应位已设置,则它当前是被阻塞的。进程可以调用 <code>sigprocmask</code>来检测和更改其当前信号屏蔽字。</p>
<h2 id="函数kill和raise"><a href="#函数kill和raise" class="headerlink" title="函数kill和raise"></a>函数kill和raise</h2><p>ki11函数将信号发送给进程或进程组。 ralse函数则允许进程向自身发送信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signo)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>进程将信号发送给其他进程需要权限。超级用户可将信号发送给任一进程。对于非超级用户,其基本规则是发送者的实际用户DD或有效用户ID必须等于接收者的实际用户ID或有效用户ID。</p>
<h2 id="函数alarm和pause"><a href="#函数alarm和pause" class="headerlink" title="函数alarm和pause"></a>函数alarm和pause</h2><p>使用alarm函数可以设置一个定时器(闹钟时间),在将来的某个时刻该定时器会超时。当定时器超时时,产生 SIGALRM信号。如果忽略或不捕捉此信号,则其默认动作是终止调用该a1arm函数的进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 or number of seconds until previously set alarm</span></div></pre></td></tr></table></figure>
<p>每个进程只能有一个闹钟时间。如果在调用a1arm时,之前已为该进程注册的闹钟时间还没有超时,则该闹钟时间的余留值作为本次a1arm函数调用的值返回。以前注册的闹钟时间则被新值代替。</p>
<p>如果有以前注册的尚未超过的闹钟时间,而且本次调用的 seconds值是0,则取消以前的闹钟时间,其余留值仍作为a1arm函数的返回值</p>
<p>pause函数使调用进程挂起直至捕捉到一个信号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: −1 with errno set to EINTR</span></div></pre></td></tr></table></figure>
<p>只有执行了一个信号处理程序并返回时，pause才返回</p>
<h2 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h2><p>我们需要有一个能表示多个信号—信号集(signal set)的数据类型。我们将在sigprocmask类函数中使用这种数据类型,以便告诉内核不允许发生该信号集中的信号。不同的信号的编号可能超过一个整型量所包含的位数,所以一般而言,不能用整型量中的一位代表一种信号,也就是不能用一个整型量表示信号集。POSIX 定义数据类型sigset_t以包含一个信号集,并且定义了下列5个处理信号集的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All four return: 0 if OK, −1 on error int sigismember(const sigset_t *set, int signo); Returns: 1 if true, 0 if false, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="函数sigprocmask"><a href="#函数sigprocmask" class="headerlink" title="函数sigprocmask"></a>函数sigprocmask</h2><p>调用函数<code>sigprocmask</code>可以检测或更改,或同时进行检测和更改进程的信号屏蔽字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> oset)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>如果oset为是非空指针，则进程当前的信号屏蔽字通过oset返回<br>其次,若ser是一个非空指针,则参数how指示如何修改当前信号屏蔽字。主要的操作有并集、交集、替代</p>
<p>在调用<code>sigprocmask</code>后如果有任何未决的、不再阻塞的信号,则在<code>sigprocmask</code>返回前至少将其中之一递送给该进程</p>
<h2 id="函数sigpending"><a href="#函数sigpending" class="headerlink" title="函数sigpending"></a>函数sigpending</h2><p><code>sigpending</code>函数返回一信号集,对于调用进程而言,其中的各信号是阻塞不能递送的,因而也一定是当前未决的。该信号集通过set参数返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="函数sigaction"><a href="#函数sigaction" class="headerlink" title="函数sigaction"></a>函数sigaction</h2><p><code>sigaction</code>函数的功能是检查或修改(或检查并修改)与指定信号相关联的处理动作。此函数取代了UNX早期版本使用的 signa1函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> <span class="keyword">struct</span> sigaction *<span class="keyword">restrict</span> act, <span class="keyword">struct</span> sigaction *<span class="keyword">restrict</span> oact)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>参数signo是要检测或修改其具体动作的信号编号。若act指针非空,则要修改其动作。如果oact指针非空,则系统经由oact指针返回该信号的上一个动作。</p>
<h2 id="函数abort"><a href="#函数abort" class="headerlink" title="函数abort"></a>函数abort</h2><p>abort函数的功能是使程序异常终止，此函数将 SIGABRT信号发送给调用进程(进程不应忽略此信号)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// This function never returns</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第10章 信号 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>Unix 进程间通信</title>
    <link href="https://www.liuin.cn/2018/04/13/Unix-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://www.liuin.cn/2018/04/13/Unix-进程间通信/</id>
    <published>2018-04-13T14:52:23.000Z</published>
    <updated>2018-04-18T13:34:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结Unix下进程间通信的几种方式及其特点</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="进程同步和进程通信的区别"><a href="#进程同步和进程通信的区别" class="headerlink" title="进程同步和进程通信的区别"></a>进程同步和进程通信的区别</h3><p>关于这个问题，网络和很多书籍上把这两者混为一谈，对于这两者的区别，说法也有很多种。</p>
<p>其中一种说法是：</p>
<blockquote>
<p>进程互斥、同步与通信的关系：进程竞争资源时要实施互斥，互斥是一种特殊的同步，实质上需要解决好进程同步问题，进程同步是一种进程通信，由此看来，进程互斥、同步都可以看做进程的通信</p>
</blockquote>
<p>个人比较认同是以下这种说法：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行</li>
<li>进程通信：进程间传输信息</li>
</ul>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<p>在进程同步中介绍的信号量也属于进程通信的一种方式，但是属于低级别的进程通信，因为它传输的信息非常小。</p>
<h3 id="消息传递与共享内存"><a href="#消息传递与共享内存" class="headerlink" title="消息传递与共享内存"></a>消息传递与共享内存</h3><p>消息传递提供一种机制以允许进程不必通过共享地址空间来实现通信和同步，消息传递工具提供至少两种操作:发送(消息)和接收(消息)。由进程发送的消息可以是定长的或变长的。</p>
<p>操作系统提供用于通信的通道，进程通过读写这个通道进行通信。</p>
<p>Unix中基于消息传递实现的IPC有：管道、FIFO、消息队列以及网络间的Socket通信</p>
<p>共享内存的进程间通信需要通信进程建立共享内存区域。通常,一块共享内存区域驻留在生成共享内存段进程的地址空间。其他希望使用这个共享内存段进行通信的进程必须将此放到它们自己的地址空间上。</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道用于有亲缘关系的两个进程（父子进程）进行通信，写进程在管道的尾端写入数据，读进程在管道的首端读出数据。管道提供了简单的流控制机制，进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。</p>
<p>通常,一个管道由一个进程创建,在进程调用fork之后,这个管道就能在父进程和子进程之间使用了。</p>
<p>管道存在以下这些局限性：</p>
<ol>
<li>历史上,它们是半双工的(即数据只能在一个方向上流动)。现在,某些系统提供全双工管道,但是为了最佳的可移植性,我们决不应预先假定系统支持全双工管道</li>
<li>管道只能在具有公共祖先的两个进程之间使用。</li>
</ol>
<p>在Unix中管道是通过调用<code>pipe</code>函数创建的。对于一个从子进程到父进程的管道,父进程关闭fd[1],子进程关闭fd[0]。</p>
<p><img src="https://data2.liuin.cn/2018-04-18-15240546357016.jpg" alt=""></p>
<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>FIFO有时被称为命名管道。未命名的管道只能在两个相关的进程之间使用,而且这两个相关的进程还要有一个共同的创建了它们的祖先进程。但是,通过FIFO,不相关的进程也能交换数据。</p>
<p>在Unix中使用<code>mkfifo</code>或者<code>mkfifoat</code>创建FIFO，使用<code>open</code>打开，使用正常文件的I/O函数对FIFO进行读写操作实现进程间通信的目的。</p>
<p>使用FIFO实现两进程间通信的例子：</p>
<p><img src="https://data2.liuin.cn/2018-04-18-15240551859039.jpg" alt=""></p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是消息的链接表,存储在内核中,由消息队列标识符标识。</p>
<p>在Unix中使用<code>msgget</code>用于创建一个新队列或打开一个现有队列、<code>msgsnd</code>将新消息添加到队列尾端。<code>mmsgrcv</code>用于从队列中取消息。我们并不定要以先进先出次序取消息,也可以按消息的类型字段取消息。<br>每个消息包含一个正的长整型类型的字段、一个非负的长度以及实际数据字节数(对应于长度),所有这些都在将消息添加到队列时,传送给 msgsna。</p>
<p>消息队列相比于其他方式有很多优点：它提供有格式的字节流，减少了开发人员的工作量；消息具有类型（system V）或优先级（posix）</p>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>Socket 是网络进程间通信的一种，我们将描述套接字网络进程间通信接口,进程用该接口能够和其他进程通信,无论它们是在同一台计算机上还是在不同的计算机上。实际上,这正是套接字接口的设计目标之一。</p>
<p>Socket自身携带同步机制，不需要额外的方式来辅助实现同步。</p>
<p>在Unix中使用<code>socket</code>、<code>bind</code>、<code>connect</code>、<code>listen</code>、<code>accept</code>等一系列系统调用建立连接并进行通信。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量是一个计数器，用于多进程提供对共享数据对象的访问。</p>
<p>为了获得共享资源,进程需要执行下列操作。</p>
<ol>
<li>测试控制该资源的信号量</li>
<li>若此信号量的值为正,则进程可以使用该资源。在这种情况下,进程会将信号量值减1,表示它使用了一个资源单位。</li>
<li>否则,若此信号量的值为0,则进程进入休眠状态,直至信号量值大于0。进程被唤醒后,它返回至步骤(1)。</li>
</ol>
<p>当进程不再使用由一个信号量控制的共享资源时,该信号量值增1。如果有进程正在休眠等待此信号量,则唤醒它们。</p>
<p>为了正确地实现信号量,信号量值的测试及减1操作应当是原子操作。为此,信号量通常是在内核中实现的。</p>
<p>因为只能传递简单的数据，所以信号量常常只是用来进行进程间的同步。</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享存储允许两个或多个进程共享一个给定的存储区。因为数据不需要在客户进程和服务器进程之间复制,所以这是最快的一种IPC。</p>
<p>不过使用共享内存的时候要注意保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>管道</td>
<td>创建简单</td>
<td>容量有限、速度慢、只能用于父子进程通讯、半双工通信方式</td>
</tr>
<tr>
<td>FIFO</td>
<td>克服了管道没有名字的限制、允许无亲缘关系进程间的通信</td>
<td>速度慢</td>
</tr>
<tr>
<td>消息队列</td>
<td>承载信息量比较多、能够承载有格式的字节流</td>
<td>容量受到系统限制</td>
</tr>
<tr>
<td>Socket</td>
<td>能够实现网络间进程的通信</td>
<td>实现比较复杂</td>
</tr>
<tr>
<td>信号量</td>
<td>能够比较好地解决同步问题</td>
<td>传递的信息较少，只能用于同步</td>
</tr>
<tr>
<td>共享内存</td>
<td>速度快</td>
<td>要解决线程安全的问题</td>
</tr>
</tbody>
</table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Unix环境高级编程》</li>
<li>《Unix-Linux编程实践教程》</li>
<li>《操作系统概念》</li>
<li><a href="http://www.cnblogs.com/youngforever/p/3250270.html" target="_blank" rel="external">http://www.cnblogs.com/youngforever/p/3250270.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结Unix下进程间通信的几种方式及其特点&lt;/p&gt;
    
    </summary>
    
      <category term="开发随笔" scheme="https://www.liuin.cn/categories/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>同步/异步与阻塞/非阻塞的理解</title>
    <link href="https://www.liuin.cn/2018/04/09/%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E4%B8%8E%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://www.liuin.cn/2018/04/09/同步-异步与阻塞-非阻塞的理解/</id>
    <published>2018-04-09T02:57:32.000Z</published>
    <updated>2018-04-09T03:02:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期在了解网络编程的时候对同步/异步和阻塞/非阻塞这些概念有一些混淆，所查了一些资料总结了这篇文章。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于同步/异步与阻塞/非阻塞的理解可能各个领域的人的回答是不一样的，在网络上也有各种各样的说法。这其实是因为不同的人的知识背景不同，并且在讨论这个问题的时候上下文(context)也不相同。本文主要结合网络上的观点以及一些书籍谈谈对同步/异步与阻塞/非阻塞大致概念上的理解，以及在Linux Network IO上的这四个概念的情况。</p>
<h2 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h2><p>同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)</p>
<p>所谓同步，就是在发出一个<strong>调用</strong>时，在没有得到结果之前，该<strong>调用</strong>就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由<strong>调用者</strong>主动等待这个<strong>调用</strong>的结果。</p>
<p>而异步则是相反，<strong>调用</strong>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<strong>调用</strong>发出后，<strong>被调用者</strong>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
<p>打一个不恰当的比方：</p>
<blockquote>
<p>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p>
</blockquote>
<h2 id="阻塞-非阻塞"><a href="#阻塞-非阻塞" class="headerlink" title="阻塞/非阻塞"></a>阻塞/非阻塞</h2><p>阻塞和非阻塞关注的是程序在<strong>等待调用结果（消息，返回值）时的状态</strong>.</p>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<p>例子：</p>
<blockquote>
<p>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。</p>
</blockquote>
<p>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>
<p>把自己挂起可以是在电话里面一直等着老板回信（同步阻塞），也可以是挂掉电话以后一直等着老板回电过来（异步阻塞）。先玩一会儿可以是电话接通着你去玩一会儿（同步非阻塞），也可以是电话挂了你去玩老板回电给你的时候你回来接（异步非阻塞）。</p>
<p>阻塞和非阻塞描述的是一种状态，同步与非同步描述的是行为方式。</p>
<h2 id="Unix-网络IO"><a href="#Unix-网络IO" class="headerlink" title="Unix 网络IO"></a>Unix 网络IO</h2><p>POSIX对同步I/O和异步I/O的定义如下：</p>
<ul>
<li>同步I/O操作( synchronous I/O opetation) 导致请求进程阻塞,直到I/O操作完成</li>
<li>异步IO操作( asynchronous I/O opetation) 不导致请求进程阻塞。</li>
</ul>
<p>在Unix中有四种常用的网络IO模型：</p>
<ul>
<li>阻塞式I/O</li>
<li>非阻塞式I/O</li>
<li>I/O复用</li>
<li>异步I/O</li>
</ul>
<p>其中前者都是同步I/O</p>
<h3 id="阻塞式I-O"><a href="#阻塞式I-O" class="headerlink" title="阻塞式I/O"></a>阻塞式I/O</h3><p>默认情况下，所有套接字都是阻塞的。在下面展示recvfrom系统调用中把数据接收过程分成两个阶段：1. 等待数据 2. 数据复制到用户空间。</p>
<p><img src="https://data2.liuin.cn/2018-04-09-15232418188483.jpg" alt=""></p>
<p>在等待过程中，进程不能做其他事情，所以是阻塞式的。什么时候调用结束：有结果或者报错的时候，调用才结束，所以是同步的。</p>
<h3 id="非阻塞式I-O"><a href="#非阻塞式I-O" class="headerlink" title="非阻塞式I/O"></a>非阻塞式I/O</h3><p><img src="https://data2.liuin.cn/2018-04-09-15232420864225.jpg" alt=""></p>
<p>在非阻塞式I/O中进程在进行系统调用recvfrom的时候，如果数据没有准备好线程不会等待，而是不断询问，直到数据准备好，复制数据到用户空间以后，接受数据这个动作才算完成。</p>
<p>因为线程不是一直在等待数据返回，其中也可以做其他的事情，所以是非阻塞式的，对于接受数据这个动作，进程会不断询问，知道最后有结果才算结束，所以是同步式的。</p>
<h3 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h3><p><img src="https://data2.liuin.cn/2018-04-09-15232424437721.jpg" alt=""></p>
<p>我们阻塞于 select调用,等待数据报套接字变为可读。当se1ect返回套接字可读这一条件时,我们调用 recvfrom把所读数据报复制到应用进程缓冲区。</p>
<h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><p><img src="https://data2.liuin.cn/2018-04-09-15232425049293.jpg" alt=""></p>
<p>异步I/O的工作模式时:告知内核启动某个操作,并让内核在整个操作(包括将数据从内核复制到我们自己的缓冲区)完成后通知我们。所以进程不需要一直询问其数据是否准备好</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><img src="https://data2.liuin.cn/2018-04-09-15232425884264.jpg" alt=""></p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://www.zhihu.com/question/19732473/answer/20851256" target="_blank" rel="external">https://www.zhihu.com/question/19732473/answer/20851256</a></li>
<li>《Unix 网络编程》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期在了解网络编程的时候对同步/异步和阻塞/非阻塞这些概念有一些混淆，所查了一些资料总结了这篇文章。&lt;/p&gt;
    
    </summary>
    
      <category term="开发随笔" scheme="https://www.liuin.cn/categories/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Unix" scheme="https://www.liuin.cn/tags/Unix/"/>
    
  </entry>
  
  <entry>
    <title>Github分布式爬虫——数据分析</title>
    <link href="https://www.liuin.cn/2018/04/07/Github%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <id>https://www.liuin.cn/2018/04/07/Github分布式爬虫——数据分析/</id>
    <published>2018-04-07T01:54:54.000Z</published>
    <updated>2018-04-07T02:00:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>对Github分布式爬虫爬取的20w用户信息和40w仓库信息进行简单的分析和统计</p>
<a id="more"></a>
<p>这里爬取的数据主要有两大类：用户数据和仓库数据，此次分析的数据量：256171用户数据，434994仓库数据</p>
<h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><h3 id="全球用户榜单"><a href="#全球用户榜单" class="headerlink" title="全球用户榜单"></a>全球用户榜单</h3><h4 id="Followers人数榜"><a href="#Followers人数榜" class="headerlink" title="Followers人数榜"></a>Followers人数榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/1024025" alt=""></td>
<td><a href="https://github.com/torvalds" target="_blank" rel="external">https://github.com/torvalds</a></td>
<td>6</td>
<td>2</td>
<td>70400</td>
<td>0</td>
<td>8</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/66577" alt=""></td>
<td><a href="https://github.com/JakeWharton" target="_blank" rel="external">https://github.com/JakeWharton</a></td>
<td>95</td>
<td>228</td>
<td>45000</td>
<td>12</td>
<td>3541</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/905434" alt=""></td>
<td><a href="https://github.com/ruanyf" target="_blank" rel="external">https://github.com/ruanyf</a></td>
<td>48</td>
<td>206</td>
<td>38200</td>
<td>0</td>
<td>1645</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/25254" alt=""></td>
<td><a href="https://github.com/tj" target="_blank" rel="external">https://github.com/tj</a></td>
<td>273</td>
<td>2000</td>
<td>34400</td>
<td>46</td>
<td>3310</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/499550" alt=""></td>
<td><a href="https://github.com/yyx990803" target="_blank" rel="external">https://github.com/yyx990803</a></td>
<td>141</td>
<td>779</td>
<td>29200</td>
<td>90</td>
<td>2553</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/110953" alt=""></td>
<td><a href="https://github.com/addyosmani" target="_blank" rel="external">https://github.com/addyosmani</a></td>
<td>295</td>
<td>807</td>
<td>29000</td>
<td>254</td>
<td>928</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/810438" alt=""></td>
<td><a href="https://github.com/gaearon" target="_blank" rel="external">https://github.com/gaearon</a></td>
<td>227</td>
<td>1300</td>
<td>27200</td>
<td>171</td>
<td>3019</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/39191" alt=""></td>
<td><a href="https://github.com/paulirish" target="_blank" rel="external">https://github.com/paulirish</a></td>
<td>266</td>
<td>723</td>
<td>25600</td>
<td>245</td>
<td>2375</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/170270" alt=""></td>
<td><a href="https://github.com/sindresorhus" target="_blank" rel="external">https://github.com/sindresorhus</a></td>
<td>975</td>
<td>2500</td>
<td>23600</td>
<td>50</td>
<td>4753</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/119893" alt=""></td>
<td><a href="https://github.com/kennethreitz" target="_blank" rel="external">https://github.com/kennethreitz</a></td>
<td>141</td>
<td>1900</td>
<td>21200</td>
<td>197</td>
<td>5626</td>
</tr>
</tbody>
</table>
<h4 id="Following人数榜"><a href="#Following人数榜" class="headerlink" title="Following人数榜"></a>Following人数榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/3076393" alt=""></td>
<td><a href="https://github.com/KevinHock" target="_blank" rel="external">https://github.com/KevinHock</a></td>
<td>19</td>
<td>198</td>
<td>1300</td>
<td>284000</td>
<td>639</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/5877145" alt=""></td>
<td><a href="https://github.com/angusshire" target="_blank" rel="external">https://github.com/angusshire</a></td>
<td>8</td>
<td>217000</td>
<td>10300</td>
<td>230000</td>
<td>30</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/6508763" alt=""></td>
<td><a href="https://github.com/dalinhuang99" target="_blank" rel="external">https://github.com/dalinhuang99</a></td>
<td>20</td>
<td>75</td>
<td>3200</td>
<td>162000</td>
<td>1293</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/3604053" alt=""></td>
<td><a href="https://github.com/cusspvz" target="_blank" rel="external">https://github.com/cusspvz</a></td>
<td>109</td>
<td>1200</td>
<td>6600</td>
<td>130000</td>
<td>90</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/6673982" alt=""></td>
<td><a href="https://github.com/MichalPaszkiewicz" target="_blank" rel="external">https://github.com/MichalPaszkiewicz</a></td>
<td>60</td>
<td>558</td>
<td>4600</td>
<td>72700</td>
<td>172</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/418638" alt=""></td>
<td><a href="https://github.com/nfultz" target="_blank" rel="external">https://github.com/nfultz</a></td>
<td>70</td>
<td>2500</td>
<td>2600</td>
<td>61600</td>
<td>2141</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/14251570" alt=""></td>
<td><a href="https://github.com/mstraughan86" target="_blank" rel="external">https://github.com/mstraughan86</a></td>
<td>15</td>
<td>454</td>
<td>3400</td>
<td>60500</td>
<td>299</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/32831059" alt=""></td>
<td><a href="https://github.com/opengiineer" target="_blank" rel="external">https://github.com/opengiineer</a></td>
<td>19</td>
<td>90</td>
<td>1600</td>
<td>55700</td>
<td>46</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/778015" alt=""></td>
<td><a href="https://github.com/ahmetabdi" target="_blank" rel="external">https://github.com/ahmetabdi</a></td>
<td>130</td>
<td>4100</td>
<td>448</td>
<td>53300</td>
<td>1954</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/4107768" alt=""></td>
<td><a href="https://github.com/brunocasanova" target="_blank" rel="external">https://github.com/brunocasanova</a></td>
<td>46</td>
<td>152</td>
<td>2400</td>
<td>48300</td>
<td>13</td>
</tr>
</tbody>
</table>
<h4 id="Stars榜"><a href="#Stars榜" class="headerlink" title="Stars榜"></a>Stars榜</h4><p>看看谁收藏的仓库最多</p>
<table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/5877145" alt=""></td>
<td><a href="https://github.com/angusshire" target="_blank" rel="external">https://github.com/angusshire</a></td>
<td>8</td>
<td>217000</td>
<td>10300</td>
<td>230000</td>
<td>30</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1610158" alt=""></td>
<td><a href="https://github.com/mcanthony" target="_blank" rel="external">https://github.com/mcanthony</a></td>
<td>4300</td>
<td>42500</td>
<td>375</td>
<td>12700</td>
<td>21</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/3947125" alt=""></td>
<td><a href="https://github.com/maoabc1818" target="_blank" rel="external">https://github.com/maoabc1818</a></td>
<td>9</td>
<td>32200</td>
<td>121</td>
<td>95</td>
<td>2</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/391299" alt=""></td>
<td><a href="https://github.com/JT5D" target="_blank" rel="external">https://github.com/JT5D</a></td>
<td>210</td>
<td>29300</td>
<td>276</td>
<td>6200</td>
<td>0</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/500775" alt=""></td>
<td><a href="https://github.com/reduxionist" target="_blank" rel="external">https://github.com/reduxionist</a></td>
<td>15</td>
<td>25800</td>
<td>174</td>
<td>429</td>
<td>62</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/6948067" alt=""></td>
<td><a href="https://github.com/pranavlathigara" target="_blank" rel="external">https://github.com/pranavlathigara</a></td>
<td>1200</td>
<td>24600</td>
<td>793</td>
<td>14900</td>
<td>130</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/2882" alt=""></td>
<td><a href="https://github.com/nikolay" target="_blank" rel="external">https://github.com/nikolay</a></td>
<td>12</td>
<td>23100</td>
<td>243</td>
<td>349</td>
<td>469</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/3759759" alt=""></td>
<td><a href="https://github.com/denji" target="_blank" rel="external">https://github.com/denji</a></td>
<td>1300</td>
<td>22500</td>
<td>181</td>
<td>397</td>
<td>305</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/24416962" alt=""></td>
<td><a href="https://github.com/roscopecoltran" target="_blank" rel="external">https://github.com/roscopecoltran</a></td>
<td>156</td>
<td>21000</td>
<td>121</td>
<td>4400</td>
<td>599</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/6257454" alt=""></td>
<td><a href="https://github.com/Jerzerak" target="_blank" rel="external">https://github.com/Jerzerak</a></td>
<td>1</td>
<td>18900</td>
<td>54</td>
<td>0</td>
<td>3</td>
</tr>
</tbody>
</table>
<h4 id="Reps榜"><a href="#Reps榜" class="headerlink" title="Reps榜"></a>Reps榜</h4><p>Github上创建仓库最多的人在这里</p>
<table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/675997" alt=""></td>
<td><a href="https://github.com/pombredanne" target="_blank" rel="external">https://github.com/pombredanne</a></td>
<td>40600</td>
<td>6500</td>
<td>149</td>
<td>87</td>
<td>2558</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/1732196" alt=""></td>
<td><a href="https://github.com/carriercomm" target="_blank" rel="external">https://github.com/carriercomm</a></td>
<td>20400</td>
<td>12900</td>
<td>72</td>
<td>176</td>
<td>151</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/14135456" alt=""></td>
<td><a href="https://github.com/digideskio" target="_blank" rel="external">https://github.com/digideskio</a></td>
<td>18000</td>
<td>88</td>
<td>120</td>
<td>3900</td>
<td>113</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/431924" alt=""></td>
<td><a href="https://github.com/guoyu07" target="_blank" rel="external">https://github.com/guoyu07</a></td>
<td>11600</td>
<td>91</td>
<td>20</td>
<td>1000</td>
<td>112</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/12729391" alt=""></td>
<td><a href="https://github.com/modulexcite" target="_blank" rel="external">https://github.com/modulexcite</a></td>
<td>10700</td>
<td>4200</td>
<td>30</td>
<td>192</td>
<td>15</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/1218365" alt=""></td>
<td><a href="https://github.com/PlumpMath" target="_blank" rel="external">https://github.com/PlumpMath</a></td>
<td>10100</td>
<td>508</td>
<td>31</td>
<td>147</td>
<td>103</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/3380677" alt=""></td>
<td><a href="https://github.com/carabina" target="_blank" rel="external">https://github.com/carabina</a></td>
<td>9300</td>
<td>8700</td>
<td>83</td>
<td>5</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/4687038" alt=""></td>
<td><a href="https://github.com/jorik041" target="_blank" rel="external">https://github.com/jorik041</a></td>
<td>9200</td>
<td>53</td>
<td>20</td>
<td>129</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1332574" alt=""></td>
<td><a href="https://github.com/treejames" target="_blank" rel="external">https://github.com/treejames</a></td>
<td>8000</td>
<td>6900</td>
<td>93</td>
<td>897</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/498130" alt=""></td>
<td><a href="https://github.com/mehulsbhatt" target="_blank" rel="external">https://github.com/mehulsbhatt</a></td>
<td>7400</td>
<td>364</td>
<td>23</td>
<td>9</td>
<td>104</td>
</tr>
</tbody>
</table>
<h4 id="Contribution榜"><a href="#Contribution榜" class="headerlink" title="Contribution榜"></a>Contribution榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/3244" alt=""></td>
<td><a href="https://github.com/robertbrook" target="_blank" rel="external">https://github.com/robertbrook</a></td>
<td>67</td>
<td>32</td>
<td>63</td>
<td>114</td>
<td>539804</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/20975616" alt=""></td>
<td><a href="https://github.com/SimiCode" target="_blank" rel="external">https://github.com/SimiCode</a></td>
<td>24</td>
<td>11</td>
<td>5</td>
<td>15</td>
<td>377077</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/751143" alt=""></td>
<td><a href="https://github.com/jasoncalabrese" target="_blank" rel="external">https://github.com/jasoncalabrese</a></td>
<td>75</td>
<td>50</td>
<td>64</td>
<td>19</td>
<td>357587</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/56100" alt=""></td>
<td><a href="https://github.com/kinlane" target="_blank" rel="external">https://github.com/kinlane</a></td>
<td>222</td>
<td>242</td>
<td>346</td>
<td>588</td>
<td>199240</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/415831" alt=""></td>
<td><a href="https://github.com/talos" target="_blank" rel="external">https://github.com/talos</a></td>
<td>113</td>
<td>95</td>
<td>143</td>
<td>7</td>
<td>115891</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/283441" alt=""></td>
<td><a href="https://github.com/honzajavorek" target="_blank" rel="external">https://github.com/honzajavorek</a></td>
<td>87</td>
<td>167</td>
<td>128</td>
<td>93</td>
<td>80301</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1006477" alt=""></td>
<td><a href="https://github.com/felixonmars" target="_blank" rel="external">https://github.com/felixonmars</a></td>
<td>420</td>
<td>369</td>
<td>806</td>
<td>149</td>
<td>70179</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/1317792" alt=""></td>
<td><a href="https://github.com/xndcn" target="_blank" rel="external">https://github.com/xndcn</a></td>
<td>33</td>
<td>86</td>
<td>67</td>
<td>8</td>
<td>67634</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/3935007" alt=""></td>
<td><a href="https://github.com/ojengwa" target="_blank" rel="external">https://github.com/ojengwa</a></td>
<td>293</td>
<td>469</td>
<td>67</td>
<td>8</td>
<td>49621</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/10103766" alt=""></td>
<td><a href="https://github.com/SergioChan" target="_blank" rel="external">https://github.com/SergioChan</a></td>
<td>47</td>
<td>372</td>
<td>982</td>
<td>598</td>
<td>42202</td>
</tr>
</tbody>
</table>
<p>365天，天天绿是种怎样的体验？</p>
<h3 id="中国用户榜单"><a href="#中国用户榜单" class="headerlink" title="中国用户榜单"></a>中国用户榜单</h3><p>这里只是通过location中”China”、”Shanghai”类似的关键词对中国用户进行区分，所以可能有遗漏的地方，还请谅解。此次统计的中国用户数据有18011</p>
<h4 id="Followers人数榜-1"><a href="#Followers人数榜-1" class="headerlink" title="Followers人数榜"></a>Followers人数榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/905434" alt=""></td>
<td><a href="https://github.com/ruanyf" target="_blank" rel="external">https://github.com/ruanyf</a></td>
<td>48</td>
<td>206</td>
<td>38200</td>
<td>0</td>
<td>1645</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/499550" alt=""></td>
<td><a href="https://github.com/yyx990803" target="_blank" rel="external">https://github.com/yyx990803</a></td>
<td>141</td>
<td>779</td>
<td>29200</td>
<td>90</td>
<td>2553</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/2503423" alt=""></td>
<td><a href="https://github.com/daimajia" target="_blank" rel="external">https://github.com/daimajia</a></td>
<td>63</td>
<td>2900</td>
<td>20000</td>
<td>241</td>
<td>21</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/470058" alt=""></td>
<td><a href="https://github.com/michaelliao" target="_blank" rel="external">https://github.com/michaelliao</a></td>
<td>61</td>
<td>81</td>
<td>19700</td>
<td>0</td>
<td>297</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/327019" alt=""></td>
<td><a href="https://github.com/JacksonTian" target="_blank" rel="external">https://github.com/JacksonTian</a></td>
<td>229</td>
<td>583</td>
<td>15500</td>
<td>151</td>
<td>805</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/1169522" alt=""></td>
<td><a href="https://github.com/Trinea" target="_blank" rel="external">https://github.com/Trinea</a></td>
<td>24</td>
<td>1500</td>
<td>14100</td>
<td>38</td>
<td>80</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/2267900" alt=""></td>
<td><a href="https://github.com/stormzhang" target="_blank" rel="external">https://github.com/stormzhang</a></td>
<td>5</td>
<td>1500</td>
<td>12800</td>
<td>91</td>
<td>9</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/97227" alt=""></td>
<td><a href="https://github.com/lifesinger" target="_blank" rel="external">https://github.com/lifesinger</a></td>
<td>2</td>
<td>278</td>
<td>12000</td>
<td>13</td>
<td>1</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/729648" alt=""></td>
<td><a href="https://github.com/cloudwu" target="_blank" rel="external">https://github.com/cloudwu</a></td>
<td>102</td>
<td>63</td>
<td>11700</td>
<td>1</td>
<td>690</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/472311" alt=""></td>
<td><a href="https://github.com/phodal" target="_blank" rel="external">https://github.com/phodal</a></td>
<td>254</td>
<td>1700</td>
<td>11100</td>
<td>15</td>
<td>5924</td>
</tr>
</tbody>
</table>
<h4 id="Following人数榜-1"><a href="#Following人数榜-1" class="headerlink" title="Following人数榜"></a>Following人数榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/3693121" alt=""></td>
<td><a href="https://github.com/fordream" target="_blank" rel="external">https://github.com/fordream</a></td>
<td>724</td>
<td>21</td>
<td>919</td>
<td>19800</td>
<td>1</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/17972943" alt=""></td>
<td><a href="https://github.com/Vermisse" target="_blank" rel="external">https://github.com/Vermisse</a></td>
<td>15</td>
<td>25</td>
<td>2300</td>
<td>10400</td>
<td>102</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/93859" alt=""></td>
<td><a href="https://github.com/technologiclee" target="_blank" rel="external">https://github.com/technologiclee</a></td>
<td>149</td>
<td>844</td>
<td>374</td>
<td>9500</td>
<td>6</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/15626022" alt=""></td>
<td><a href="https://github.com/shenzhoudance" target="_blank" rel="external">https://github.com/shenzhoudance</a></td>
<td>599</td>
<td>6</td>
<td>108</td>
<td>7700</td>
<td>2373</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/10573715" alt=""></td>
<td><a href="https://github.com/kotobukki" target="_blank" rel="external">https://github.com/kotobukki</a></td>
<td>15</td>
<td>68</td>
<td>111</td>
<td>7500</td>
<td>889</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/29220207" alt=""></td>
<td><a href="https://github.com/vincentpanqi" target="_blank" rel="external">https://github.com/vincentpanqi</a></td>
<td>1800</td>
<td>714</td>
<td>47</td>
<td>5600</td>
<td>102</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/1727724" alt=""></td>
<td><a href="https://github.com/ovwane" target="_blank" rel="external">https://github.com/ovwane</a></td>
<td>220</td>
<td>1100</td>
<td>120</td>
<td>5500</td>
<td>329</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/9153294" alt=""></td>
<td><a href="https://github.com/pisual" target="_blank" rel="external">https://github.com/pisual</a></td>
<td>39</td>
<td>62</td>
<td>917</td>
<td>4900</td>
<td>122</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/23236638" alt=""></td>
<td><a href="https://github.com/youkaichao" target="_blank" rel="external">https://github.com/youkaichao</a></td>
<td>39</td>
<td>0</td>
<td>58</td>
<td>4800</td>
<td>113</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/7576876" alt=""></td>
<td><a href="https://github.com/bloodycoder" target="_blank" rel="external">https://github.com/bloodycoder</a></td>
<td>73</td>
<td>34</td>
<td>162</td>
<td>4200</td>
<td>390</td>
</tr>
</tbody>
</table>
<h4 id="Stars榜-1"><a href="#Stars榜-1" class="headerlink" title="Stars榜"></a>Stars榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1041542" alt=""></td>
<td><a href="https://github.com/weimingtom" target="_blank" rel="external">https://github.com/weimingtom</a></td>
<td>2100</td>
<td>9100</td>
<td>172</td>
<td>1800</td>
<td>1724</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/2041398" alt=""></td>
<td><a href="https://github.com/jiangplus" target="_blank" rel="external">https://github.com/jiangplus</a></td>
<td>28</td>
<td>8800</td>
<td>85</td>
<td>115</td>
<td>13</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1024948" alt=""></td>
<td><a href="https://github.com/DavidAlphaFox" target="_blank" rel="external">https://github.com/DavidAlphaFox</a></td>
<td>346</td>
<td>7800</td>
<td>167</td>
<td>83</td>
<td>1122</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/480859" alt=""></td>
<td><a href="https://github.com/mayulu" target="_blank" rel="external">https://github.com/mayulu</a></td>
<td>12</td>
<td>7700</td>
<td>133</td>
<td>616</td>
<td>14</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/4370703" alt=""></td>
<td><a href="https://github.com/hzy87email" target="_blank" rel="external">https://github.com/hzy87email</a></td>
<td>73</td>
<td>7700</td>
<td>77</td>
<td>167</td>
<td>3</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1468284" alt=""></td>
<td><a href="https://github.com/se77en" target="_blank" rel="external">https://github.com/se77en</a></td>
<td>197</td>
<td>7600</td>
<td>119</td>
<td>455</td>
<td>0</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/12030169" alt=""></td>
<td><a href="https://github.com/JaredYeDH" target="_blank" rel="external">https://github.com/JaredYeDH</a></td>
<td>166</td>
<td>7400</td>
<td>45</td>
<td>636</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/10380759" alt=""></td>
<td><a href="https://github.com/xhs" target="_blank" rel="external">https://github.com/xhs</a></td>
<td>20</td>
<td>7200</td>
<td>43</td>
<td>119</td>
<td>10</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/1881113" alt=""></td>
<td><a href="https://github.com/paladin74" target="_blank" rel="external">https://github.com/paladin74</a></td>
<td>618</td>
<td>7100</td>
<td>52</td>
<td>901</td>
<td>1</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/3856" alt=""></td>
<td><a href="https://github.com/mrluanma" target="_blank" rel="external">https://github.com/mrluanma</a></td>
<td>12</td>
<td>7000</td>
<td>126</td>
<td>541</td>
<td>36</td>
</tr>
</tbody>
</table>
<h4 id="Reps榜-1"><a href="#Reps榜-1" class="headerlink" title="Reps榜"></a>Reps榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/10938976" alt=""></td>
<td><a href="https://github.com/skyformat99" target="_blank" rel="external">https://github.com/skyformat99</a></td>
<td>6000</td>
<td>143</td>
<td>98</td>
<td>3200</td>
<td>134</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/1203820" alt=""></td>
<td><a href="https://github.com/tempbottle" target="_blank" rel="external">https://github.com/tempbottle</a></td>
<td>4200</td>
<td>59</td>
<td>21</td>
<td>18</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/8662447" alt=""></td>
<td><a href="https://github.com/JamesLinus" target="_blank" rel="external">https://github.com/JamesLinus</a></td>
<td>4100</td>
<td>1600</td>
<td>89</td>
<td>3300</td>
<td>181</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/12955801" alt=""></td>
<td><a href="https://github.com/hu19891110" target="_blank" rel="external">https://github.com/hu19891110</a></td>
<td>3600</td>
<td>90</td>
<td>11</td>
<td>112</td>
<td>107</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/452743" alt=""></td>
<td><a href="https://github.com/WilliamRen" target="_blank" rel="external">https://github.com/WilliamRen</a></td>
<td>2900</td>
<td>3200</td>
<td>32</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/3414057" alt=""></td>
<td><a href="https://github.com/chagge" target="_blank" rel="external">https://github.com/chagge</a></td>
<td>2300</td>
<td>8</td>
<td>16</td>
<td>669</td>
<td>101</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/6813552" alt=""></td>
<td><a href="https://github.com/forging2012" target="_blank" rel="external">https://github.com/forging2012</a></td>
<td>2200</td>
<td>789</td>
<td>8</td>
<td>71</td>
<td>151</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1041542" alt=""></td>
<td><a href="https://github.com/weimingtom" target="_blank" rel="external">https://github.com/weimingtom</a></td>
<td>2100</td>
<td>9100</td>
<td>172</td>
<td>1800</td>
<td>1724</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/23429527" alt=""></td>
<td><a href="https://github.com/isuhao" target="_blank" rel="external">https://github.com/isuhao</a></td>
<td>2000</td>
<td>153</td>
<td>62</td>
<td>2700</td>
<td>282</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/5791117" alt=""></td>
<td><a href="https://github.com/ycaihua" target="_blank" rel="external">https://github.com/ycaihua</a></td>
<td>1900</td>
<td>109</td>
<td>38</td>
<td>589</td>
<td>133</td>
</tr>
</tbody>
</table>
<h4 id="Contribution榜-1"><a href="#Contribution榜-1" class="headerlink" title="Contribution榜"></a>Contribution榜</h4><table>
<thead>
<tr>
<th>Avatar</th>
<th>User</th>
<th>Repos</th>
<th>Stars</th>
<th>Followers</th>
<th>Following</th>
<th>Contributions</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/1006477" alt=""></td>
<td><a href="https://github.com/felixonmars" target="_blank" rel="external">https://github.com/felixonmars</a></td>
<td>420</td>
<td>369</td>
<td>806</td>
<td>149</td>
<td>70179</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/10103766" alt=""></td>
<td><a href="https://github.com/SergioChan" target="_blank" rel="external">https://github.com/SergioChan</a></td>
<td>47</td>
<td>372</td>
<td>982</td>
<td>598</td>
<td>42202</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/12693644" alt=""></td>
<td><a href="https://github.com/dragon-yuan" target="_blank" rel="external">https://github.com/dragon-yuan</a></td>
<td>16</td>
<td>109</td>
<td>35</td>
<td>50</td>
<td>18591</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/8347202" alt=""></td>
<td><a href="https://github.com/fengss" target="_blank" rel="external">https://github.com/fengss</a></td>
<td>30</td>
<td>67</td>
<td>15</td>
<td>1</td>
<td>12560</td>
</tr>
<tr>
<td><img src="https://avatars0.githubusercontent.com/u/9410171" alt=""></td>
<td><a href="https://github.com/xieguigang" target="_blank" rel="external">https://github.com/xieguigang</a></td>
<td>41</td>
<td>115</td>
<td>136</td>
<td>143</td>
<td>10999</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/9280577" alt=""></td>
<td><a href="https://github.com/csjunxu" target="_blank" rel="external">https://github.com/csjunxu</a></td>
<td>194</td>
<td>81</td>
<td>35</td>
<td>51</td>
<td>9935</td>
</tr>
<tr>
<td><img src="https://avatars3.githubusercontent.com/u/559179" alt=""></td>
<td><a href="https://github.com/airyland" target="_blank" rel="external">https://github.com/airyland</a></td>
<td>183</td>
<td>1400</td>
<td>996</td>
<td>175</td>
<td>8852</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/11537812" alt=""></td>
<td><a href="https://github.com/yutiansut" target="_blank" rel="external">https://github.com/yutiansut</a></td>
<td>216</td>
<td>1100</td>
<td>298</td>
<td>8</td>
<td>7311</td>
</tr>
<tr>
<td><img src="https://avatars2.githubusercontent.com/u/1826685" alt=""></td>
<td><a href="https://github.com/lloydzhou" target="_blank" rel="external">https://github.com/lloydzhou</a></td>
<td>92</td>
<td>556</td>
<td>52</td>
<td>69</td>
<td>6729</td>
</tr>
<tr>
<td><img src="https://avatars1.githubusercontent.com/u/8784712" alt=""></td>
<td><a href="https://github.com/egoist" target="_blank" rel="external">https://github.com/egoist</a></td>
<td>647</td>
<td>2700</td>
<td>3600</td>
<td>40</td>
<td>6236</td>
</tr>
</tbody>
</table>
<h3 id="个人网站中顶级域名分布情况"><a href="#个人网站中顶级域名分布情况" class="headerlink" title="个人网站中顶级域名分布情况"></a>个人网站中顶级域名分布情况</h3><p><img src="https://data2.liuin.cn/2018-04-01-15225621477939.jpg" alt=""></p>
<h3 id="用户公布邮箱情况"><a href="#用户公布邮箱情况" class="headerlink" title="用户公布邮箱情况"></a>用户公布邮箱情况</h3><p><img src="https://data2.liuin.cn/2018-04-01-15225624252077.jpg" alt=""></p>
<h3 id="用户所在公司情况"><a href="#用户所在公司情况" class="headerlink" title="用户所在公司情况"></a>用户所在公司情况</h3><p>公布公司的前8</p>
<p><img src="https://data2.liuin.cn/2018-04-01-15225631364406.jpg" alt=""></p>
<p>云图</p>
<p><img src="https://data2.liuin.cn/2018-04-01-15225635127953.jpg" alt=""></p>
<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><h3 id="Stars榜-2"><a href="#Stars榜-2" class="headerlink" title="Stars榜"></a>Stars榜</h3><table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/freeCodeCamp/freeCodeCamp" target="_blank" rel="external">freeCodeCamp/freeCodeCamp</a></td>
<td><a href="https://github.com/freeCodeCamp" target="_blank" rel="external">freeCodeCamp</a></td>
<td>JavaScript</td>
<td>291895</td>
<td>13667</td>
<td>11334</td>
</tr>
<tr>
<td><a href="https://github.com/twbs/bootstrap" target="_blank" rel="external">twbs/bootstrap</a></td>
<td><a href="https://github.com/twbs" target="_blank" rel="external">twbs</a></td>
<td>CSS</td>
<td>123341</td>
<td>58717</td>
<td>17645</td>
</tr>
<tr>
<td><a href="https://github.com/EbookFoundation/free-programming-books" target="_blank" rel="external">EbookFoundation/free-programming-books</a></td>
<td><a href="https://github.com/EbookFoundation" target="_blank" rel="external">EbookFoundation</a></td>
<td></td>
<td>103480</td>
<td>26331</td>
<td>4634</td>
</tr>
<tr>
<td><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">tensorflow/tensorflow</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>C++</td>
<td>95028</td>
<td>60694</td>
<td>30887</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/react" target="_blank" rel="external">facebook/react</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>92602</td>
<td>17473</td>
<td>9773</td>
</tr>
<tr>
<td><a href="https://github.com/vuejs/vue" target="_blank" rel="external">vuejs/vue</a></td>
<td><a href="https://github.com/vuejs" target="_blank" rel="external">vuejs</a></td>
<td>JavaScript</td>
<td>89447</td>
<td>13129</td>
<td>2581</td>
</tr>
<tr>
<td><a href="https://github.com/sindresorhus/awesome" target="_blank" rel="external">sindresorhus/awesome</a></td>
<td><a href="https://github.com/sindresorhus" target="_blank" rel="external">sindresorhus</a></td>
<td></td>
<td>82141</td>
<td>10785</td>
<td>725</td>
</tr>
<tr>
<td><a href="https://github.com/getify/You-Dont-Know-JS" target="_blank" rel="external">getify/You-Dont-Know-JS</a></td>
<td><a href="https://github.com/getify" target="_blank" rel="external">getify</a></td>
<td></td>
<td>78848</td>
<td>14404</td>
<td>1465</td>
</tr>
<tr>
<td><a href="https://github.com/d3/d3" target="_blank" rel="external">d3/d3</a></td>
<td><a href="https://github.com/d3" target="_blank" rel="external">d3</a></td>
<td>JavaScript</td>
<td>74472</td>
<td>19024</td>
<td>4132</td>
</tr>
<tr>
<td><a href="https://github.com/airbnb/javascript" target="_blank" rel="external">airbnb/javascript</a></td>
<td><a href="https://github.com/airbnb" target="_blank" rel="external">airbnb</a></td>
<td>JavaScript</td>
<td>68833</td>
<td>13127</td>
<td>1607</td>
</tr>
</tbody>
</table>
<h3 id="Forks榜"><a href="#Forks榜" class="headerlink" title="Forks榜"></a>Forks榜</h3><table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/jtleek/datasharing" target="_blank" rel="external">jtleek/datasharing</a></td>
<td><a href="https://github.com/jtleek" target="_blank" rel="external">jtleek</a></td>
<td></td>
<td>4332</td>
<td>184409</td>
<td>29</td>
</tr>
<tr>
<td><a href="https://github.com/rdpeng/ProgrammingAssignment2" target="_blank" rel="external">rdpeng/ProgrammingAssignment2</a></td>
<td><a href="https://github.com/rdpeng" target="_blank" rel="external">rdpeng</a></td>
<td>R</td>
<td>528</td>
<td>110145</td>
<td>7</td>
</tr>
<tr>
<td><a href="https://github.com/octocat/Spoon-Knife" target="_blank" rel="external">octocat/Spoon-Knife</a></td>
<td><a href="https://github.com/octocat" target="_blank" rel="external">octocat</a></td>
<td>HTML</td>
<td>10043</td>
<td>97471</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">tensorflow/tensorflow</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>C++</td>
<td>95028</td>
<td>60694</td>
<td>30887</td>
</tr>
<tr>
<td><a href="https://github.com/twbs/bootstrap" target="_blank" rel="external">twbs/bootstrap</a></td>
<td><a href="https://github.com/twbs" target="_blank" rel="external">twbs</a></td>
<td>CSS</td>
<td>123341</td>
<td>58717</td>
<td>17645</td>
</tr>
<tr>
<td><a href="https://github.com/SmartThingsCommunity/SmartThingsPublic" target="_blank" rel="external">SmartThingsCommunity/SmartThingsPublic</a></td>
<td><a href="https://github.com/SmartThingsCommunity" target="_blank" rel="external">SmartThingsCommunity</a></td>
<td>Groovy</td>
<td>853</td>
<td>38018</td>
<td>2448</td>
</tr>
<tr>
<td><a href="https://github.com/rdpeng/RepData_PeerAssessment1" target="_blank" rel="external">rdpeng/RepData_PeerAssessment1</a></td>
<td><a href="https://github.com/rdpeng" target="_blank" rel="external">rdpeng</a></td>
<td></td>
<td>69</td>
<td>29883</td>
<td>13</td>
</tr>
<tr>
<td><a href="https://github.com/github/gitignore" target="_blank" rel="external">github/gitignore</a></td>
<td><a href="https://github.com/github" target="_blank" rel="external">github</a></td>
<td></td>
<td>63853</td>
<td>29259</td>
<td>2738</td>
</tr>
<tr>
<td><a href="https://github.com/angular/angular.js" target="_blank" rel="external">angular/angular.js</a></td>
<td><a href="https://github.com/angular" target="_blank" rel="external">angular</a></td>
<td>JavaScript</td>
<td>58232</td>
<td>28872</td>
<td>8755</td>
</tr>
<tr>
<td><a href="https://github.com/EbookFoundation/free-programming-books" target="_blank" rel="external">EbookFoundation/free-programming-books</a></td>
<td><a href="https://github.com/EbookFoundation" target="_blank" rel="external">EbookFoundation</a></td>
<td></td>
<td>103480</td>
<td>26331</td>
<td>4634</td>
</tr>
</tbody>
</table>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>stars排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/torvalds/linux" target="_blank" rel="external">torvalds/linux</a></td>
<td><a href="https://github.com/torvalds" target="_blank" rel="external">torvalds</a></td>
<td>C</td>
<td>57191</td>
<td>21032</td>
<td>744803</td>
</tr>
<tr>
<td><a href="https://github.com/firehol/netdata" target="_blank" rel="external">firehol/netdata</a></td>
<td><a href="https://github.com/firehol" target="_blank" rel="external">firehol</a></td>
<td>C</td>
<td>28607</td>
<td>2389</td>
<td>6690</td>
</tr>
<tr>
<td><a href="https://github.com/antirez/redis" target="_blank" rel="external">antirez/redis</a></td>
<td><a href="https://github.com/antirez" target="_blank" rel="external">antirez</a></td>
<td>C</td>
<td>28340</td>
<td>10916</td>
<td>6679</td>
</tr>
<tr>
<td><a href="https://github.com/git/git" target="_blank" rel="external">git/git</a></td>
<td><a href="https://github.com/git" target="_blank" rel="external">git</a></td>
<td>C</td>
<td>21665</td>
<td>12634</td>
<td>50674</td>
</tr>
<tr>
<td><a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="external">Bilibili/ijkplayer</a></td>
<td><a href="https://github.com/Bilibili" target="_blank" rel="external">Bilibili</a></td>
<td>C</td>
<td>18374</td>
<td>5191</td>
<td>2584</td>
</tr>
<tr>
<td><a href="https://github.com/php/php-src" target="_blank" rel="external">php/php-src</a></td>
<td><a href="https://github.com/php" target="_blank" rel="external">php</a></td>
<td>C</td>
<td>16996</td>
<td>4745</td>
<td>107206</td>
</tr>
<tr>
<td><a href="https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System" target="_blank" rel="external">SamyPesse/How-to-Make-a-Computer-Operating-System</a></td>
<td><a href="https://github.com/SamyPesse" target="_blank" rel="external">SamyPesse</a></td>
<td>C</td>
<td>16957</td>
<td>3015</td>
<td>243</td>
</tr>
<tr>
<td><a href="https://github.com/wg/wrk" target="_blank" rel="external">wg/wrk</a></td>
<td><a href="https://github.com/wg" target="_blank" rel="external">wg</a></td>
<td>C</td>
<td>15386</td>
<td>1245</td>
<td>72</td>
</tr>
<tr>
<td><a href="https://github.com/ggreer/the_silver_searcher" target="_blank" rel="external">ggreer/the_silver_searcher</a></td>
<td><a href="https://github.com/ggreer" target="_blank" rel="external">ggreer</a></td>
<td>C</td>
<td>14854</td>
<td>954</td>
<td>1974</td>
</tr>
<tr>
<td><a href="https://github.com/kripken/emscripten" target="_blank" rel="external">kripken/emscripten</a></td>
<td><a href="https://github.com/kripken" target="_blank" rel="external">kripken</a></td>
<td>C</td>
<td>14373</td>
<td>1704</td>
<td>18154</td>
</tr>
</tbody>
</table>
<p>forks排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/torvalds/linux" target="_blank" rel="external">torvalds/linux</a></td>
<td><a href="https://github.com/torvalds" target="_blank" rel="external">torvalds</a></td>
<td>C</td>
<td>57191</td>
<td>21032</td>
<td>744803</td>
</tr>
<tr>
<td><a href="https://github.com/git/git" target="_blank" rel="external">git/git</a></td>
<td><a href="https://github.com/git" target="_blank" rel="external">git</a></td>
<td>C</td>
<td>21665</td>
<td>12634</td>
<td>50674</td>
</tr>
<tr>
<td><a href="https://github.com/antirez/redis" target="_blank" rel="external">antirez/redis</a></td>
<td><a href="https://github.com/antirez" target="_blank" rel="external">antirez</a></td>
<td>C</td>
<td>28340</td>
<td>10916</td>
<td>6679</td>
</tr>
<tr>
<td><a href="https://github.com/arduino/Arduino" target="_blank" rel="external">arduino/Arduino</a></td>
<td><a href="https://github.com/arduino" target="_blank" rel="external">arduino</a></td>
<td>C</td>
<td>7936</td>
<td>6184</td>
<td>6649</td>
</tr>
<tr>
<td><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July" target="_blank" rel="external">julycoding/The-Art-Of-Programming-By-July</a></td>
<td><a href="https://github.com/julycoding" target="_blank" rel="external">julycoding</a></td>
<td>C</td>
<td>13544</td>
<td>5666</td>
<td>3630</td>
</tr>
<tr>
<td><a href="https://github.com/MarlinFirmware/Marlin" target="_blank" rel="external">MarlinFirmware/Marlin</a></td>
<td><a href="https://github.com/MarlinFirmware" target="_blank" rel="external">MarlinFirmware</a></td>
<td>C</td>
<td>3615</td>
<td>5340</td>
<td>9015</td>
</tr>
<tr>
<td><a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="external">Bilibili/ijkplayer</a></td>
<td><a href="https://github.com/Bilibili" target="_blank" rel="external">Bilibili</a></td>
<td>C</td>
<td>18374</td>
<td>5191</td>
<td>2584</td>
</tr>
<tr>
<td><a href="https://github.com/php/php-src" target="_blank" rel="external">php/php-src</a></td>
<td><a href="https://github.com/php" target="_blank" rel="external">php</a></td>
<td>C</td>
<td>16996</td>
<td>4745</td>
<td>107206</td>
</tr>
<tr>
<td><a href="https://github.com/esp8266/Arduino" target="_blank" rel="external">esp8266/Arduino</a></td>
<td><a href="https://github.com/esp8266" target="_blank" rel="external">esp8266</a></td>
<td>C</td>
<td>7063</td>
<td>4378</td>
<td>2697</td>
</tr>
<tr>
<td><a href="https://github.com/FFmpeg/FFmpeg" target="_blank" rel="external">FFmpeg/FFmpeg</a></td>
<td><a href="https://github.com/FFmpeg" target="_blank" rel="external">FFmpeg</a></td>
<td>C</td>
<td>10314</td>
<td>4377</td>
<td>90611</td>
</tr>
</tbody>
</table>
<h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><p>stars排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">tensorflow/tensorflow</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>C++</td>
<td>95028</td>
<td>60694</td>
<td>30887</td>
</tr>
<tr>
<td><a href="https://github.com/electron/electron" target="_blank" rel="external">electron/electron</a></td>
<td><a href="https://github.com/electron" target="_blank" rel="external">electron</a></td>
<td>C++</td>
<td>58531</td>
<td>7642</td>
<td>18669</td>
</tr>
<tr>
<td><a href="https://github.com/apple/swift" target="_blank" rel="external">apple/swift</a></td>
<td><a href="https://github.com/apple" target="_blank" rel="external">apple</a></td>
<td>C++</td>
<td>43250</td>
<td>6795</td>
<td>68510</td>
</tr>
<tr>
<td><a href="https://github.com/nwjs/nw.js" target="_blank" rel="external">nwjs/nw.js</a></td>
<td><a href="https://github.com/nwjs" target="_blank" rel="external">nwjs</a></td>
<td>C++</td>
<td>33478</td>
<td>3731</td>
<td>3188</td>
</tr>
<tr>
<td><a href="https://github.com/x64dbg/x64dbg" target="_blank" rel="external">x64dbg/x64dbg</a></td>
<td><a href="https://github.com/x64dbg" target="_blank" rel="external">x64dbg</a></td>
<td>C++</td>
<td>33242</td>
<td>684</td>
<td>3923</td>
</tr>
<tr>
<td><a href="https://github.com/bitcoin/bitcoin" target="_blank" rel="external">bitcoin/bitcoin</a></td>
<td><a href="https://github.com/bitcoin" target="_blank" rel="external">bitcoin</a></td>
<td>C++</td>
<td>30209</td>
<td>18101</td>
<td>16629</td>
</tr>
<tr>
<td><a href="https://github.com/google/protobuf" target="_blank" rel="external">google/protobuf</a></td>
<td><a href="https://github.com/google" target="_blank" rel="external">google</a></td>
<td>C++</td>
<td>24950</td>
<td>7150</td>
<td>5557</td>
</tr>
<tr>
<td><a href="https://github.com/BVLC/caffe" target="_blank" rel="external">BVLC/caffe</a></td>
<td><a href="https://github.com/BVLC" target="_blank" rel="external">BVLC</a></td>
<td>C++</td>
<td>23550</td>
<td>14390</td>
<td>4118</td>
</tr>
<tr>
<td><a href="https://github.com/opencv/opencv" target="_blank" rel="external">opencv/opencv</a></td>
<td><a href="https://github.com/opencv" target="_blank" rel="external">opencv</a></td>
<td>C++</td>
<td>23493</td>
<td>16901</td>
<td>23654</td>
</tr>
<tr>
<td><a href="https://github.com/rethinkdb/rethinkdb" target="_blank" rel="external">rethinkdb/rethinkdb</a></td>
<td><a href="https://github.com/rethinkdb" target="_blank" rel="external">rethinkdb</a></td>
<td>C++</td>
<td>20993</td>
<td>1665</td>
<td>33382</td>
</tr>
</tbody>
</table>
<p>forks排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">tensorflow/tensorflow</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>C++</td>
<td>95028</td>
<td>60694</td>
<td>30887</td>
</tr>
<tr>
<td><a href="https://github.com/bitcoin/bitcoin" target="_blank" rel="external">bitcoin/bitcoin</a></td>
<td><a href="https://github.com/bitcoin" target="_blank" rel="external">bitcoin</a></td>
<td>C++</td>
<td>30209</td>
<td>18101</td>
<td>16629</td>
</tr>
<tr>
<td><a href="https://github.com/opencv/opencv" target="_blank" rel="external">opencv/opencv</a></td>
<td><a href="https://github.com/opencv" target="_blank" rel="external">opencv</a></td>
<td>C++</td>
<td>23493</td>
<td>16901</td>
<td>23654</td>
</tr>
<tr>
<td><a href="https://github.com/BVLC/caffe" target="_blank" rel="external">BVLC/caffe</a></td>
<td><a href="https://github.com/BVLC" target="_blank" rel="external">BVLC</a></td>
<td>C++</td>
<td>23550</td>
<td>14390</td>
<td>4118</td>
</tr>
<tr>
<td><a href="https://github.com/electron/electron" target="_blank" rel="external">electron/electron</a></td>
<td><a href="https://github.com/electron" target="_blank" rel="external">electron</a></td>
<td>C++</td>
<td>58531</td>
<td>7642</td>
<td>18669</td>
</tr>
<tr>
<td><a href="https://github.com/google/protobuf" target="_blank" rel="external">google/protobuf</a></td>
<td><a href="https://github.com/google" target="_blank" rel="external">google</a></td>
<td>C++</td>
<td>24950</td>
<td>7150</td>
<td>5557</td>
</tr>
<tr>
<td><a href="https://github.com/apple/swift" target="_blank" rel="external">apple/swift</a></td>
<td><a href="https://github.com/apple" target="_blank" rel="external">apple</a></td>
<td>C++</td>
<td>43250</td>
<td>6795</td>
<td>68510</td>
</tr>
<tr>
<td><a href="https://github.com/cocos2d/cocos2d-x" target="_blank" rel="external">cocos2d/cocos2d-x</a></td>
<td><a href="https://github.com/cocos2d" target="_blank" rel="external">cocos2d</a></td>
<td>C++</td>
<td>11759</td>
<td>6496</td>
<td>36641</td>
</tr>
<tr>
<td><a href="https://github.com/ArduPilot/ardupilot" target="_blank" rel="external">ArduPilot/ardupilot</a></td>
<td><a href="https://github.com/ArduPilot" target="_blank" rel="external">ArduPilot</a></td>
<td>C++</td>
<td>3110</td>
<td>6153</td>
<td>31379</td>
</tr>
<tr>
<td><a href="https://github.com/dmlc/xgboost" target="_blank" rel="external">dmlc/xgboost</a></td>
<td><a href="https://github.com/dmlc" target="_blank" rel="external">dmlc</a></td>
<td>C++</td>
<td>11406</td>
<td>5192</td>
<td>3254</td>
</tr>
</tbody>
</table>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>stars排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">ReactiveX/RxJava</a></td>
<td><a href="https://github.com/ReactiveX" target="_blank" rel="external">ReactiveX</a></td>
<td>Java</td>
<td>32001</td>
<td>5594</td>
<td>5328</td>
</tr>
<tr>
<td><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="external">iluwatar/java-design-patterns</a></td>
<td><a href="https://github.com/iluwatar" target="_blank" rel="external">iluwatar</a></td>
<td>Java</td>
<td>31422</td>
<td>10072</td>
<td>2022</td>
</tr>
<tr>
<td><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="external">elastic/elasticsearch</a></td>
<td><a href="https://github.com/elastic" target="_blank" rel="external">elastic</a></td>
<td>Java</td>
<td>29931</td>
<td>10408</td>
<td>30528</td>
</tr>
<tr>
<td><a href="https://github.com/square/retrofit" target="_blank" rel="external">square/retrofit</a></td>
<td><a href="https://github.com/square" target="_blank" rel="external">square</a></td>
<td>Java</td>
<td>27182</td>
<td>5311</td>
<td>1569</td>
</tr>
<tr>
<td><a href="https://github.com/square/okhttp" target="_blank" rel="external">square/okhttp</a></td>
<td><a href="https://github.com/square" target="_blank" rel="external">square</a></td>
<td>Java</td>
<td>25870</td>
<td>6054</td>
<td>3147</td>
</tr>
<tr>
<td><a href="https://github.com/google/guava" target="_blank" rel="external">google/guava</a></td>
<td><a href="https://github.com/google" target="_blank" rel="external">google</a></td>
<td>Java</td>
<td>23154</td>
<td>5323</td>
<td>4676</td>
</tr>
<tr>
<td><a href="https://github.com/spring-projects/spring-boot" target="_blank" rel="external">spring-projects/spring-boot</a></td>
<td><a href="https://github.com/spring-projects" target="_blank" rel="external">spring-projects</a></td>
<td>Java</td>
<td>22927</td>
<td>17555</td>
<td>16129</td>
</tr>
<tr>
<td><a href="https://github.com/PhilJay/MPAndroidChart" target="_blank" rel="external">PhilJay/MPAndroidChart</a></td>
<td><a href="https://github.com/PhilJay" target="_blank" rel="external">PhilJay</a></td>
<td>Java</td>
<td>21393</td>
<td>5939</td>
<td>1938</td>
</tr>
<tr>
<td><a href="https://github.com/kdn251/interviews" target="_blank" rel="external">kdn251/interviews</a></td>
<td><a href="https://github.com/kdn251" target="_blank" rel="external">kdn251</a></td>
<td>Java</td>
<td>21348</td>
<td>3503</td>
<td>370</td>
</tr>
<tr>
<td><a href="https://github.com/bumptech/glide" target="_blank" rel="external">bumptech/glide</a></td>
<td><a href="https://github.com/bumptech" target="_blank" rel="external">bumptech</a></td>
<td>Java</td>
<td>21032</td>
<td>4132</td>
<td>2190</td>
</tr>
</tbody>
</table>
<p>forks排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/spring-projects/spring-boot" target="_blank" rel="external">spring-projects/spring-boot</a></td>
<td><a href="https://github.com/spring-projects" target="_blank" rel="external">spring-projects</a></td>
<td>Java</td>
<td>22927</td>
<td>17555</td>
<td>16129</td>
</tr>
<tr>
<td><a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="external">spring-projects/spring-framework</a></td>
<td><a href="https://github.com/spring-projects" target="_blank" rel="external">spring-projects</a></td>
<td>Java</td>
<td>20126</td>
<td>13328</td>
<td>16384</td>
</tr>
<tr>
<td><a href="https://github.com/apache/incubator-dubbo" target="_blank" rel="external">apache/incubator-dubbo</a></td>
<td><a href="https://github.com/apache" target="_blank" rel="external">apache</a></td>
<td>Java</td>
<td>17706</td>
<td>12714</td>
<td>2201</td>
</tr>
<tr>
<td><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="external">elastic/elasticsearch</a></td>
<td><a href="https://github.com/elastic" target="_blank" rel="external">elastic</a></td>
<td>Java</td>
<td>29931</td>
<td>10408</td>
<td>30528</td>
</tr>
<tr>
<td><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="external">iluwatar/java-design-patterns</a></td>
<td><a href="https://github.com/iluwatar" target="_blank" rel="external">iluwatar</a></td>
<td>Java</td>
<td>31422</td>
<td>10072</td>
<td>2022</td>
</tr>
<tr>
<td><a href="https://github.com/eugenp/tutorials" target="_blank" rel="external">eugenp/tutorials</a></td>
<td><a href="https://github.com/eugenp" target="_blank" rel="external">eugenp</a></td>
<td>Java</td>
<td>4950</td>
<td>8411</td>
<td>7809</td>
</tr>
<tr>
<td><a href="https://github.com/zxing/zxing" target="_blank" rel="external">zxing/zxing</a></td>
<td><a href="https://github.com/zxing" target="_blank" rel="external">zxing</a></td>
<td>Java</td>
<td>18000</td>
<td>7345</td>
<td>3425</td>
</tr>
<tr>
<td><a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="external">nostra13/Android-Universal-Image-Loader</a></td>
<td><a href="https://github.com/nostra13" target="_blank" rel="external">nostra13</a></td>
<td>Java</td>
<td>16040</td>
<td>6476</td>
<td>1025</td>
</tr>
<tr>
<td><a href="https://github.com/checkstyle/checkstyle" target="_blank" rel="external">checkstyle/checkstyle</a></td>
<td><a href="https://github.com/checkstyle" target="_blank" rel="external">checkstyle</a></td>
<td>Java</td>
<td>3597</td>
<td>6402</td>
<td>7658</td>
</tr>
<tr>
<td><a href="https://github.com/netty/netty" target="_blank" rel="external">netty/netty</a></td>
<td><a href="https://github.com/netty" target="_blank" rel="external">netty</a></td>
<td>Java</td>
<td>13422</td>
<td>6122</td>
<td>8723</td>
</tr>
</tbody>
</table>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>stars排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/vinta/awesome-python" target="_blank" rel="external">vinta/awesome-python</a></td>
<td><a href="https://github.com/vinta" target="_blank" rel="external">vinta</a></td>
<td>Python</td>
<td>47930</td>
<td>9270</td>
<td>1222</td>
</tr>
<tr>
<td><a href="https://github.com/rg3/youtube-dl" target="_blank" rel="external">rg3/youtube-dl</a></td>
<td><a href="https://github.com/rg3" target="_blank" rel="external">rg3</a></td>
<td>Python</td>
<td>35575</td>
<td>6532</td>
<td>16048</td>
</tr>
<tr>
<td><a href="https://github.com/toddmotto/public-apis" target="_blank" rel="external">toddmotto/public-apis</a></td>
<td><a href="https://github.com/toddmotto" target="_blank" rel="external">toddmotto</a></td>
<td>Python</td>
<td>35115</td>
<td>3319</td>
<td>1760</td>
</tr>
<tr>
<td><a href="https://github.com/jakubroztocil/httpie" target="_blank" rel="external">jakubroztocil/httpie</a></td>
<td><a href="https://github.com/jakubroztocil" target="_blank" rel="external">jakubroztocil</a></td>
<td>Python</td>
<td>34746</td>
<td>2362</td>
<td>965</td>
</tr>
<tr>
<td><a href="https://github.com/nvbn/thefuck" target="_blank" rel="external">nvbn/thefuck</a></td>
<td><a href="https://github.com/nvbn" target="_blank" rel="external">nvbn</a></td>
<td>Python</td>
<td>34601</td>
<td>1723</td>
<td>1463</td>
</tr>
<tr>
<td><a href="https://github.com/pallets/flask" target="_blank" rel="external">pallets/flask</a></td>
<td><a href="https://github.com/pallets" target="_blank" rel="external">pallets</a></td>
<td>Python</td>
<td>34411</td>
<td>10562</td>
<td>3205</td>
</tr>
<tr>
<td><a href="https://github.com/django/django" target="_blank" rel="external">django/django</a></td>
<td><a href="https://github.com/django" target="_blank" rel="external">django</a></td>
<td>Python</td>
<td>32956</td>
<td>13953</td>
<td>25601</td>
</tr>
<tr>
<td><a href="https://github.com/tensorflow/models" target="_blank" rel="external">tensorflow/models</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>Python</td>
<td>32262</td>
<td>17985</td>
<td>2109</td>
</tr>
<tr>
<td><a href="https://github.com/josephmisiti/awesome-machine-learning" target="_blank" rel="external">josephmisiti/awesome-machine-learning</a></td>
<td><a href="https://github.com/josephmisiti" target="_blank" rel="external">josephmisiti</a></td>
<td>Python</td>
<td>31793</td>
<td>7780</td>
<td>1033</td>
</tr>
<tr>
<td><a href="https://github.com/requests/requests" target="_blank" rel="external">requests/requests</a></td>
<td><a href="https://github.com/requests" target="_blank" rel="external">requests</a></td>
<td>Python</td>
<td>31508</td>
<td>5824</td>
<td>5416</td>
</tr>
</tbody>
</table>
<p>forks排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/tensorflow/models" target="_blank" rel="external">tensorflow/models</a></td>
<td><a href="https://github.com/tensorflow" target="_blank" rel="external">tensorflow</a></td>
<td>Python</td>
<td>32262</td>
<td>17985</td>
<td>2109</td>
</tr>
<tr>
<td><a href="https://github.com/shadowsocks/shadowsocks" target="_blank" rel="external">shadowsocks/shadowsocks</a></td>
<td><a href="https://github.com/shadowsocks" target="_blank" rel="external">shadowsocks</a></td>
<td>Python</td>
<td>24278</td>
<td>15499</td>
<td>1</td>
</tr>
<tr>
<td><a href="https://github.com/django/django" target="_blank" rel="external">django/django</a></td>
<td><a href="https://github.com/django" target="_blank" rel="external">django</a></td>
<td>Python</td>
<td>32956</td>
<td>13953</td>
<td>25601</td>
</tr>
<tr>
<td><a href="https://github.com/scikit-learn/scikit-learn" target="_blank" rel="external">scikit-learn/scikit-learn</a></td>
<td><a href="https://github.com/scikit-learn" target="_blank" rel="external">scikit-learn</a></td>
<td>Python</td>
<td>27088</td>
<td>13623</td>
<td>22684</td>
</tr>
<tr>
<td><a href="https://github.com/ansible/ansible" target="_blank" rel="external">ansible/ansible</a></td>
<td><a href="https://github.com/ansible" target="_blank" rel="external">ansible</a></td>
<td>Python</td>
<td>29373</td>
<td>10728</td>
<td>36562</td>
</tr>
<tr>
<td><a href="https://github.com/pallets/flask" target="_blank" rel="external">pallets/flask</a></td>
<td><a href="https://github.com/pallets" target="_blank" rel="external">pallets</a></td>
<td>Python</td>
<td>34411</td>
<td>10562</td>
<td>3205</td>
</tr>
<tr>
<td><a href="https://github.com/keras-team/keras" target="_blank" rel="external">keras-team/keras</a></td>
<td><a href="https://github.com/keras-team" target="_blank" rel="external">keras-team</a></td>
<td>Python</td>
<td>27833</td>
<td>10213</td>
<td>4442</td>
</tr>
<tr>
<td><a href="https://github.com/udacity/fullstack-nanodegree-vm" target="_blank" rel="external">udacity/fullstack-nanodegree-vm</a></td>
<td><a href="https://github.com/udacity" target="_blank" rel="external">udacity</a></td>
<td>Python</td>
<td>202</td>
<td>9370</td>
<td>53</td>
</tr>
<tr>
<td><a href="https://github.com/vinta/awesome-python" target="_blank" rel="external">vinta/awesome-python</a></td>
<td><a href="https://github.com/vinta" target="_blank" rel="external">vinta</a></td>
<td>Python</td>
<td>47930</td>
<td>9270</td>
<td>1222</td>
</tr>
<tr>
<td><a href="https://github.com/odoo/odoo" target="_blank" rel="external">odoo/odoo</a></td>
<td><a href="https://github.com/odoo" target="_blank" rel="external">odoo</a></td>
<td>Python</td>
<td>9200</td>
<td>7889</td>
<td>115520</td>
</tr>
</tbody>
</table>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>stars排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/freeCodeCamp/freeCodeCamp" target="_blank" rel="external">freeCodeCamp/freeCodeCamp</a></td>
<td><a href="https://github.com/freeCodeCamp" target="_blank" rel="external">freeCodeCamp</a></td>
<td>JavaScript</td>
<td>291895</td>
<td>13667</td>
<td>11334</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/react" target="_blank" rel="external">facebook/react</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>92602</td>
<td>17473</td>
<td>9773</td>
</tr>
<tr>
<td><a href="https://github.com/vuejs/vue" target="_blank" rel="external">vuejs/vue</a></td>
<td><a href="https://github.com/vuejs" target="_blank" rel="external">vuejs</a></td>
<td>JavaScript</td>
<td>89447</td>
<td>13129</td>
<td>2581</td>
</tr>
<tr>
<td><a href="https://github.com/d3/d3" target="_blank" rel="external">d3/d3</a></td>
<td><a href="https://github.com/d3" target="_blank" rel="external">d3</a></td>
<td>JavaScript</td>
<td>74472</td>
<td>19024</td>
<td>4132</td>
</tr>
<tr>
<td><a href="https://github.com/airbnb/javascript" target="_blank" rel="external">airbnb/javascript</a></td>
<td><a href="https://github.com/airbnb" target="_blank" rel="external">airbnb</a></td>
<td>JavaScript</td>
<td>68833</td>
<td>13127</td>
<td>1607</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/react-native" target="_blank" rel="external">facebook/react-native</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>62128</td>
<td>14129</td>
<td>13166</td>
</tr>
<tr>
<td><a href="https://github.com/angular/angular.js" target="_blank" rel="external">angular/angular.js</a></td>
<td><a href="https://github.com/angular" target="_blank" rel="external">angular</a></td>
<td>JavaScript</td>
<td>58232</td>
<td>28872</td>
<td>8755</td>
</tr>
<tr>
<td><a href="https://github.com/jquery/jquery" target="_blank" rel="external">jquery/jquery</a></td>
<td><a href="https://github.com/jquery" target="_blank" rel="external">jquery</a></td>
<td>JavaScript</td>
<td>48560</td>
<td>15318</td>
<td>6316</td>
</tr>
<tr>
<td><a href="https://github.com/nodejs/node" target="_blank" rel="external">nodejs/node</a></td>
<td><a href="https://github.com/nodejs" target="_blank" rel="external">nodejs</a></td>
<td>JavaScript</td>
<td>47212</td>
<td>9904</td>
<td>21744</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/create-react-app" target="_blank" rel="external">facebook/create-react-app</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>46391</td>
<td>9259</td>
<td>1484</td>
</tr>
</tbody>
</table>
<p>forks排行</p>
<table>
<thead>
<tr>
<th>Rep</th>
<th>User</th>
<th>Language</th>
<th>Stars</th>
<th>Fork</th>
<th>Commit</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/angular/angular.js" target="_blank" rel="external">angular/angular.js</a></td>
<td><a href="https://github.com/angular" target="_blank" rel="external">angular</a></td>
<td>JavaScript</td>
<td>58232</td>
<td>28872</td>
<td>8755</td>
</tr>
<tr>
<td><a href="https://github.com/udacity/frontend-nanodegree-resume" target="_blank" rel="external">udacity/frontend-nanodegree-resume</a></td>
<td><a href="https://github.com/udacity" target="_blank" rel="external">udacity</a></td>
<td>JavaScript</td>
<td>915</td>
<td>25814</td>
<td>84</td>
</tr>
<tr>
<td><a href="https://github.com/d3/d3" target="_blank" rel="external">d3/d3</a></td>
<td><a href="https://github.com/d3" target="_blank" rel="external">d3</a></td>
<td>JavaScript</td>
<td>74472</td>
<td>19024</td>
<td>4132</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/react" target="_blank" rel="external">facebook/react</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>92602</td>
<td>17473</td>
<td>9773</td>
</tr>
<tr>
<td><a href="https://github.com/jquery/jquery" target="_blank" rel="external">jquery/jquery</a></td>
<td><a href="https://github.com/jquery" target="_blank" rel="external">jquery</a></td>
<td>JavaScript</td>
<td>48560</td>
<td>15318</td>
<td>6316</td>
</tr>
<tr>
<td><a href="https://github.com/nightscout/cgm-remote-monitor" target="_blank" rel="external">nightscout/cgm-remote-monitor</a></td>
<td><a href="https://github.com/nightscout" target="_blank" rel="external">nightscout</a></td>
<td>JavaScript</td>
<td>439</td>
<td>15228</td>
<td>4505</td>
</tr>
<tr>
<td><a href="https://github.com/mrdoob/three.js" target="_blank" rel="external">mrdoob/three.js</a></td>
<td><a href="https://github.com/mrdoob" target="_blank" rel="external">mrdoob</a></td>
<td>JavaScript</td>
<td>40668</td>
<td>15152</td>
<td>22927</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/react-native" target="_blank" rel="external">facebook/react-native</a></td>
<td><a href="https://github.com/facebook" target="_blank" rel="external">facebook</a></td>
<td>JavaScript</td>
<td>62128</td>
<td>14129</td>
<td>13166</td>
</tr>
<tr>
<td><a href="https://github.com/freeCodeCamp/freeCodeCamp" target="_blank" rel="external">freeCodeCamp/freeCodeCamp</a></td>
<td><a href="https://github.com/freeCodeCamp" target="_blank" rel="external">freeCodeCamp</a></td>
<td>JavaScript</td>
<td>291895</td>
<td>13667</td>
<td>11334</td>
</tr>
<tr>
<td><a href="https://github.com/vuejs/vue" target="_blank" rel="external">vuejs/vue</a></td>
<td><a href="https://github.com/vuejs" target="_blank" rel="external">vuejs</a></td>
<td>JavaScript</td>
<td>89447</td>
<td>13129</td>
<td>2581</td>
</tr>
</tbody>
</table>
<h3 id="语言使用比例"><a href="#语言使用比例" class="headerlink" title="语言使用比例"></a>语言使用比例</h3><p>stars 超过100的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229847469176.jpg" alt=""></p>
<p>stars 超过1000的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229848318605.jpg" alt=""></p>
<p>stars 超过10000的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229848710272.jpg" alt=""></p>
<p>forks 超过100的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229849187089.jpg" alt=""></p>
<p>forks 超过1000的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229849529776.jpg" alt=""></p>
<p>forks 超过10000的</p>
<p><img src="https://data2.liuin.cn/2018-04-06-15229849860861.jpg" alt=""></p>
<p>欢迎大家Star我的<a href="https://github.com/Sixzeroo/GithubCrawler" target="_blank" rel="external">Github项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对Github分布式爬虫爬取的20w用户信息和40w仓库信息进行简单的分析和统计&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.liuin.cn/categories/python/"/>
    
    
      <category term="python" scheme="https://www.liuin.cn/tags/python/"/>
    
      <category term="爬虫" scheme="https://www.liuin.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Github分布式爬虫——实现</title>
    <link href="https://www.liuin.cn/2018/04/05/Github%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.liuin.cn/2018/04/05/Github分布式爬虫——实现/</id>
    <published>2018-04-05T11:40:54.000Z</published>
    <updated>2018-04-07T01:54:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用Redis实现分布式爬虫</p>
<a id="more"></a>
<p>主要使用Scrapy、Redis、MongoDB实现，Scrapy作为异步爬虫框架、Redis实现分布式以及Cookies池的存储，MongoDB实现底层数据存储</p>
<h2 id="分布式示意图"><a href="#分布式示意图" class="headerlink" title="分布式示意图"></a>分布式示意图</h2><p><img src="https://data2.liuin.cn/2018-03-25-15219437958574.jpg" alt=""></p>
<p>主机中安装Redis和MongoDB</p>
<p>Redis中存储：</p>
<ul>
<li>所有Scrapy爬虫的待爬取队列</li>
<li>去重用的已发出Request指纹</li>
</ul>
<p>MongoDB负责最终数据的存储</p>
<p>可创建多个Scrapy从机进行爬取，实现分布式。</p>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul>
<li>共享爬取队列实现分布式</li>
<li>生成Request的指纹实现分布式的去重</li>
<li>随机指定User-Agent</li>
<li>通过Redis实现Cookies池并进行更新</li>
</ul>
<h2 id="分布式实现"><a href="#分布式实现" class="headerlink" title="分布式实现"></a>分布式实现</h2><h3 id="请求队列"><a href="#请求队列" class="headerlink" title="请求队列"></a>请求队列</h3><p>各个分布式爬虫共同维护一个Request请求队列，使用的是Redis的list。队列可以实现FIFO，LIFO或者优先级队列。</p>
<p>爬取的时候一开始使用的是优先级队列，但是后来因为不好设置优先级，导致最后都是User的item，导致Rep的饥饿现象，所以到后面换成FIFO队列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FifoQueue</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="string">"""Per-spider FIFO queue"""</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""Return the length of the queue"""</span></div><div class="line">        <span class="keyword">return</span> self.server.llen(self.key)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, request)</span>:</span></div><div class="line">        <span class="string">"""Push a request"""</span></div><div class="line">        self.server.lpush(self.key, self._encode_request(request))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self, timeout=<span class="number">0</span>)</span>:</span></div><div class="line">        <span class="string">"""Pop a request"""</span></div><div class="line">        <span class="keyword">if</span> timeout &gt; <span class="number">0</span>:</div><div class="line">            data = self.server.brpop(self.key, timeout)</div><div class="line">            <span class="keyword">if</span> isinstance(data, tuple):</div><div class="line">                data = data[<span class="number">1</span>]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            data = self.server.rpop(self.key)</div><div class="line">        <span class="keyword">if</span> data:</div><div class="line">            <span class="keyword">return</span> self._decode_request(data)</div></pre></td></tr></table></figure>
<p>同时需要设置request队列的大小限制，因为爬取Github页面的时候可能爬取一个star列表以后就会产生几十个Request，这样很容易把Redis的队列挤爆：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">enqueue_request</span><span class="params">(self, request)</span>:</span></div><div class="line">    <span class="comment"># set upper limit of request num</span></div><div class="line">    <span class="keyword">if</span> len(self.queue) &gt; REQUEST_NUM:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.dont_filter <span class="keyword">and</span> self.df.request_seen(request):</div><div class="line">        self.df.log(request, self.spider)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">if</span> self.stats:</div><div class="line">        self.stats.inc_value(<span class="string">'scheduler/enqueued/redis'</span>, spider=self.spider)</div><div class="line">    self.queue.push(request)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>没有设置数量大小的时候，1G内存的主机跑一个多小时之后就挂掉了：</p>
<p><img src="https://data2.liuin.cn/2018-03-21-15215617499559.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-20-15215615819339.jpg" alt=""></p>
<h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><p>为了使用共同的请求队列，所以需要重写Scheduler，重写的Scheduler负责把要爬取的request放入队列以及从队列中找出request进行爬取</p>
<h3 id="去重集合"><a href="#去重集合" class="headerlink" title="去重集合"></a>去重集合</h3><p>本地爬虫通常需要解决一个去重问题，通常使用的是数据库查询，爬取之前判断url是否请求过。分布式爬虫就是在这个的基础上共用一个去重集合，使用的是Redis的set。</p>
<p>判断一个Request是否已经爬取过，这里不是使用url，因为不同的url可能代表的是同一种资源，比如：<code>http://www.example.com/query?cat=222&amp;id=111</code>和<code>http://www.example.com/query?cat=222&amp;id=111</code> 事实表示的是一个东西。此外，发出的Request还可能与当时的Cookie有关，因为里面还会有用户信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 计算Request指纹判断有没有重复</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_seen</span><span class="params">(self, request)</span>:</span></div><div class="line">    fp = self.request_fingerprint(request)</div><div class="line">    <span class="keyword">if</span> USEBLOOMFILTER == <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">if</span> self.bf.isContains(fp):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.bf.insert(fp)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="comment"># This returns the number of values added, zero if already exists.</span></div><div class="line">        added = self.server.sadd(self.key, fp)</div><div class="line">        <span class="keyword">return</span> added == <span class="number">0</span></div></pre></td></tr></table></figure>
<p>这里采用的方案是生成一个Request的指纹，实际上是把request的url，method和指定的header使用sha1算法得到一个hash值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Request 指纹计算方法</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_fingerprint</span><span class="params">(request, include_headers=None)</span>:</span></div><div class="line">    <span class="keyword">if</span> include_headers:</div><div class="line">        include_headers = tuple(to_bytes(h.lower())</div><div class="line">                                 <span class="keyword">for</span> h <span class="keyword">in</span> sorted(include_headers))</div><div class="line">    cache = _fingerprint_cache.setdefault(request, &#123;&#125;)</div><div class="line">    <span class="keyword">if</span> include_headers <span class="keyword">not</span> <span class="keyword">in</span> cache:</div><div class="line">        fp = hashlib.sha1()</div><div class="line">        fp.update(to_bytes(request.method))</div><div class="line">        fp.update(to_bytes(canonicalize_url(request.url)))</div><div class="line">        fp.update(request.body <span class="keyword">or</span> <span class="string">b''</span>)</div><div class="line">        <span class="keyword">if</span> include_headers:</div><div class="line">            <span class="keyword">for</span> hdr <span class="keyword">in</span> include_headers:</div><div class="line">                <span class="keyword">if</span> hdr <span class="keyword">in</span> request.headers:</div><div class="line">                    fp.update(hdr)</div><div class="line">                    <span class="keyword">for</span> v <span class="keyword">in</span> request.headers.getlist(hdr):</div><div class="line">                        fp.update(v)</div><div class="line">        cache[include_headers] = fp.hexdigest()</div><div class="line">    <span class="keyword">return</span> cache[include_headers]</div></pre></td></tr></table></figure>
<h2 id="反反爬虫策略"><a href="#反反爬虫策略" class="headerlink" title="反反爬虫策略"></a>反反爬虫策略</h2><h3 id="随机User-Agent"><a href="#随机User-Agent" class="headerlink" title="随机User-Agent"></a>随机User-Agent</h3><p>使用中间件实现随机User-Agent，随机替换掉request的header的User-Agent参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitHubUserAgentMiddleware</span><span class="params">(UserAgentMiddleware)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></div><div class="line">        agent = random.choice(agents)</div><div class="line">        request.headers[<span class="string">'User-Agent'</span>] = agent</div></pre></td></tr></table></figure>
<h3 id="Cookies池"><a href="#Cookies池" class="headerlink" title="Cookies池"></a>Cookies池</h3><p>首先使用多账号模拟登录，获取到很多已登录账号的cookies，放入到Redis的hashset中，各个爬虫共用这一个Cookies池。爬虫同样实现一个中间件，替换Request的Cookies。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Cookie 中间件</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitHubCookieMiddleware</span><span class="params">(RetryMiddleware)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,settings)</span>:</span></div><div class="line">        RetryMiddleware.__init__(self,settings)</div><div class="line">        self.rconn = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, db=<span class="number">3</span>)</div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></div><div class="line">        <span class="keyword">return</span> cls(crawler.settings)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></div><div class="line">        keys = self.rconn.hkeys(REDIS_COOKIE)</div><div class="line">        <span class="keyword">if</span>(len(keys) == <span class="number">0</span>):</div><div class="line">            print(<span class="string">"cookies don't work!"</span>)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        key = random.choice(keys)</div><div class="line">        <span class="comment"># 获取最新cookie</span></div><div class="line">        value = self.rconn.hget(REDIS_COOKIE, key)</div><div class="line">        <span class="keyword">if</span>( isinstance(value, bytes) ):</div><div class="line">            value = value.decode(<span class="string">'utf-8'</span>)</div><div class="line">        cookies = json.loads(value)</div><div class="line">        request.cookies = cookies</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一个为了了解分布式工作原理而做的一个小的项目，其中很多地方存在缺陷，欢迎大家在Github上留建议：</p>
<p><a href="https://github.com/Sixzeroo/GithubCrawler" target="_blank" rel="external">https://github.com/Sixzeroo/GithubCrawler</a></p>
<p>同时也可以查看下一篇关于Github用户和仓库数据分析的文章</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Redis实现分布式爬虫&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.liuin.cn/categories/python/"/>
    
    
      <category term="python" scheme="https://www.liuin.cn/tags/python/"/>
    
      <category term="爬虫" scheme="https://www.liuin.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 题解——Redundant Connection II</title>
    <link href="https://www.liuin.cn/2018/03/28/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Redundant-Connection-II/"/>
    <id>https://www.liuin.cn/2018/03/28/LeetCode-题解——Redundant-Connection-II/</id>
    <published>2018-03-28T07:09:37.000Z</published>
    <updated>2018-03-28T07:12:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题解——Redundant Connection II</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个有向图，求其有向的最小生成树（除了根节点之外所有的节点都有一条入边指向它），同时给出的有向图刚好只多出一条边</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>前一道题是求只多出一条边的无向图的最小生成树，使用并查集很容易就能够求解。</p>
<p>这一道有向图的题就比较复杂一点了，有向图的最小生成树又叫最小树形图，常规算法是使用<a href="https://www.liuin.cn/2017/03/25/%E5%88%9D%E8%AF%86-%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95/">朱刘算法</a>。这里因为只多出一条边，所以不用这么麻烦。</p>
<p>总共有三种情况：</p>
<ol>
<li>有环，但是没有入度为2的节点</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-03-28-15222211302563.jpg" alt=""></p>
<ol>
<li>有环，同时有入度为2的节点</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-03-28-15222211412345.jpg" alt=""></p>
<ol>
<li>无环，有入度为2的节点</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-03-28-15222211561578.jpg" alt=""></p>
<p>第一种情况，按照无向图的处理方式进行就行了，使用并查集返回最后一条形成环的边。</p>
<p>后面两种情况，首先要找到入度为2的节点，选出指向这个节点的两条边，处理完其他的边以后处理这两条边，使用并查集找出最后一个连接的两个节点已经在同一集合中的边</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> par[<span class="number">3000</span>];</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">            par[i] = i;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(par[x] == x) <span class="keyword">return</span> x;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> par[x] = find(par[x]);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></div><div class="line">    &#123;</div><div class="line">        x = find(x);</div><div class="line">        y = find(y);</div><div class="line">        <span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</div><div class="line">        par[y] = x;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 并查集</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findRedundantDirectedConnection(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</div><div class="line">        <span class="keyword">int</span> len = edges.size();</div><div class="line">        init(len);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegre(len, <span class="number">0</span>), outdegre(len, <span class="number">0</span>);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; problem_edge;</div><div class="line">        <span class="keyword">int</span> node = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 统计入度，找到入度为2的点</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:edges)</div><div class="line">        &#123;</div><div class="line">            indegre[i[<span class="number">1</span>]]++;</div><div class="line">            <span class="keyword">if</span>(indegre[i[<span class="number">1</span>]] == <span class="number">2</span>) node = i[<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:edges)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i[<span class="number">1</span>] == node)</div><div class="line">            &#123;</div><div class="line">                problem_edge.push_back(i);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 有环的情况</span></div><div class="line">            <span class="keyword">int</span> a = find(i[<span class="number">0</span>]), b= find(i[<span class="number">1</span>]);</div><div class="line">            <span class="keyword">if</span>(a == b) </div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">            unite(i[<span class="number">0</span>], i[<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 无环的情况，从入度为2的节点入手</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:problem_edge)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> a = find(i[<span class="number">0</span>]), b= find(i[<span class="number">1</span>]);</div><div class="line">            <span class="keyword">if</span>(a == b) <span class="keyword">return</span> i;</div><div class="line">            <span class="keyword">else</span> unite(a,b);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题解——Redundant Connection II&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.liuin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="图论" scheme="https://www.liuin.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="LeetCode" scheme="https://www.liuin.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析——内存分配</title>
    <link href="https://www.liuin.cn/2018/03/23/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>https://www.liuin.cn/2018/03/23/Redis源码剖析——内存分配/</id>
    <published>2018-03-23T10:43:53.000Z</published>
    <updated>2018-03-23T11:12:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>内存分配是程序需要解决的一个大问题，也应该是剖析一个程序的源码最基础最关键的部分之一。</p>
<a id="more"></a>
<p>Redis的内存分配主要是在C语言中对内存处理的函数：malloc、realloc、free的基础加了一些封装和异常的处理。</p>
<p>其特点主要有以下三点：</p>
<ol>
<li>添加对使用内存的统计，在分配和释放内存的时候都会更新记录使用内存的量</li>
<li>支持线程安全模式，通过锁的机制对use_memory进行控制，避免其出现脏数据的可能</li>
<li>增添对内存溢出的处理</li>
</ol>
<p>首先Redis源码中与内存分配相关的以下全局变量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>;    <span class="comment">// 使用的内存大小</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> zmalloc_thread_safe = <span class="number">0</span>;   <span class="comment">// 线程安全模式状态</span></div><div class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;   <span class="comment">// 为此服务器</span></div></pre></td></tr></table></figure></p>
<h2 id="内存分配相关功能函数"><a href="#内存分配相关功能函数" class="headerlink" title="内存分配相关功能函数"></a>内存分配相关功能函数</h2><p>Redis中和内存分配相关的功能函数主要有以下这些：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void *zmalloc(size_t size);   </div><div class="line">void *zcalloc(size_t size);</div><div class="line">void *zrealloc(void *ptr, size_t size);</div><div class="line">void zfree(void *ptr);</div><div class="line">char *zstrdup(const char *s);  // 封装的字符复制函数</div><div class="line">size_t zmalloc_used_memory(void);   // 获取使用的内存大小</div><div class="line">void zmalloc_enable_thread_safeness(void);    // 开启线程安全模式</div><div class="line">void zmalloc_set_oom_handler(void (*oom_handler)(size_t));   // 自定义的内存溢出处理方法</div><div class="line">float zmalloc_get_fragmentation_ratio(size_t rss);  // 使用内存和所给内存之比</div><div class="line">size_t zmalloc_get_rss(void);  // 获取rss信息</div><div class="line">size_t zmalloc_get_private_dirty(void);   // 获取实际物理分配的内存</div></pre></td></tr></table></figure></p>
<h2 id="内存申请与调整"><a href="#内存申请与调整" class="headerlink" title="内存申请与调整"></a>内存申请与调整</h2><p>Redis中和内存申请相关的函数主要是zmalloc、zcalloc和zrealloc，分别是对C语言中的malloc、calloc和realloc的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对malloc进行封装，加上异常处理和内存统计</span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="comment">// 多申请的内存用于存储次块空间大小</span></div><div class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</div><div class="line"></div><div class="line">    <span class="comment">// 内存溢出</span></div><div class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</div><div class="line">    <span class="comment">// 进行内存统计</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</div><div class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size+PREFIX_SIZE);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</div><div class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 封装重新分配内存函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="keyword">void</span> *realptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">size_t</span> oldsize;</div><div class="line">    <span class="keyword">void</span> *newptr;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zmalloc(size);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="comment">// 原来所使用空间的大小</span></div><div class="line">    oldsize = zmalloc_size(ptr);</div><div class="line">    <span class="comment">// 重新分配新的空间</span></div><div class="line">    newptr = <span class="built_in">realloc</span>(ptr,size);</div><div class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</div><div class="line"></div><div class="line">    <span class="comment">// 更新保存的使用内存值</span></div><div class="line">    update_zmalloc_stat_free(oldsize);</div><div class="line">    update_zmalloc_stat_alloc(zmalloc_size(newptr));</div><div class="line">    <span class="keyword">return</span> newptr;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</div><div class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</div><div class="line">    newptr = <span class="built_in">realloc</span>(realptr,size+PREFIX_SIZE);</div><div class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</div><div class="line"></div><div class="line">    *((<span class="keyword">size_t</span>*)newptr) = size;</div><div class="line">    update_zmalloc_stat_free(oldsize);</div><div class="line">    update_zmalloc_stat_alloc(size);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newptr+PREFIX_SIZE;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先要注意的是对内存溢出的处理，可以自定义处理函数，其默认的处理方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 默认溢出处理方法</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zmalloc_default_oom</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"zmalloc: Out of memory trying to allocate %zu bytes\n"</span>,</div><div class="line">        size);</div><div class="line">    fflush(<span class="built_in">stderr</span>);</div><div class="line">    <span class="built_in">abort</span>();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 内存溢出处理方法</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*zmalloc_oom_handler)</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= zmalloc_default_oom;</div></pre></td></tr></table></figure>
<p>然后我们可以看到每次在调整内存的时候，都会对全局变量use_memory进行改变，调整是以<code>sizeof(long)</code>的整数倍进行调整的。在改变use_memory的时候会判断是否在线程安全模式下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 更新使用的内存数量值</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) do &#123; \</span></div><div class="line">    size_t _n = (__n); \</div><div class="line">    <span class="comment">// _n调整为size(long)的整数倍</span></div><div class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</div><div class="line">    <span class="comment">// 线程安全模式，原子性增加使用内存大小 （加锁）</span></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \</div><div class="line">        update_zmalloc_stat_add(_n); \</div><div class="line">    <span class="comment">// 不使用线程安全模式，直接增加</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123; \</div><div class="line">        used_memory += _n; \</div><div class="line">    &#125; \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_add(__n) do &#123; \</span></div><div class="line">    pthread_mutex_lock(&amp;used_memory_mutex); \</div><div class="line">    used_memory += (__n); \</div><div class="line">    pthread_mutex_unlock(&amp;used_memory_mutex); \</div><div class="line">&#125; while(0)</div></pre></td></tr></table></figure>
<h2 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h2><p>内存释放部分和申请部分类似，主要是对free函数的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取内存占用空间大小</span></div><div class="line"><span class="keyword">size_t</span> zmalloc_size(<span class="keyword">void</span> *ptr) &#123;</div><div class="line">    <span class="comment">// 减去统计内存大小的部分</span></div><div class="line">    <span class="keyword">void</span> *realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</div><div class="line">    <span class="keyword">size_t</span> size = *((<span class="keyword">size_t</span>*)realptr);</div><div class="line">    <span class="comment">/* Assume at least that all the allocations are padded at sizeof(long) by</span></div><div class="line">     * the underlying allocator. */</div><div class="line">    <span class="comment">// 调整为sizeof(long)的整数倍，方便对齐</span></div><div class="line">    <span class="keyword">if</span> (size&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) size += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(size&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>));</div><div class="line">    <span class="keyword">return</span> size+PREFIX_SIZE;</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">// 封装对系统的free调用</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="keyword">void</span> *realptr;</div><div class="line">    <span class="keyword">size_t</span> oldsize;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></div><div class="line">    <span class="comment">// 减少对内存的计数</span></div><div class="line">    update_zmalloc_stat_free(zmalloc_size(ptr));</div><div class="line">    <span class="built_in">free</span>(ptr);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</div><div class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</div><div class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</div><div class="line">    <span class="built_in">free</span>(realptr);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对use_memory的操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 释放内存以后对内存空间统计变量的改变</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_free(__n) do &#123; \</span></div><div class="line">    size_t _n = (__n); \</div><div class="line">    <span class="comment">// 以sizeof(long)的整数倍进行调整</span></div><div class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</div><div class="line">    <span class="comment">// 线程安全模式</span></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \</div><div class="line">        update_zmalloc_stat_sub(_n); \</div><div class="line">    &#125; <span class="keyword">else</span> &#123; \</div><div class="line">        used_memory -= _n; \</div><div class="line">    &#125; \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><p>除了最基本的一些内存分配的函数以外，还实现了一些辅助函数(如复制字符串、获取已经使用内存的大小）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 复制字符串操作</span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</div><div class="line">    <span class="keyword">size_t</span> l = <span class="built_in">strlen</span>(s)+<span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> *p = zmalloc(l);</div><div class="line"></div><div class="line">    <span class="comment">// 调用字符复制函数</span></div><div class="line">    <span class="built_in">memcpy</span>(p,s,l);</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取已经使用的内存大小</span></div><div class="line"><span class="keyword">size_t</span> zmalloc_used_memory(<span class="keyword">void</span>) &#123;</div><div class="line">    <span class="keyword">size_t</span> um;</div><div class="line"></div><div class="line">    <span class="comment">// 线程安全模式</span></div><div class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__ATOMIC_RELAXED) || defined(HAVE_ATOMIC)</span></div><div class="line">        um = update_zmalloc_stat_add(<span class="number">0</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        pthread_mutex_lock(&amp;used_memory_mutex);</div><div class="line">        um = used_memory;</div><div class="line">        pthread_mutex_unlock(&amp;used_memory_mutex);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 非线程安全情况下，直接赋值</span></div><div class="line">        um = used_memory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> um;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存分配是程序需要解决的一个大问题，也应该是剖析一个程序的源码最基础最关键的部分之一。&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="https://www.liuin.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析——跳跃表</title>
    <link href="https://www.liuin.cn/2018/03/22/Redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    <id>https://www.liuin.cn/2018/03/22/Redis源码解析——跳跃表/</id>
    <published>2018-03-22T07:47:17.000Z</published>
    <updated>2018-03-23T10:40:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis使用跳跃表作为有序集合键的底层实现之一，跳跃表(skiplist)是一种有序数据结构,它通过在每个节点中维持多个指向其他节点的指针,从而达到快速访问节点的目的。</p>
<a id="more"></a>
<p>跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找,还可以通过顺序性操作来批量处理节点。在大部分情况下,跳跃表的效率可以和平衡树相媲美,并且因为跳跃表的实现比平衡树要来得更为简单,所以有不少程序都使用跳跃表来代替平衡树。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>一个跳跃表的整体结构如下：<br><img src="https://data2.liuin.cn/2018-03-22-15217053998776.jpg" alt=""></p>
<h3 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h3><p>跳跃表节点的数据结构定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 跳跃表节点</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplistNode &#123;</div><div class="line">    robj *obj;   <span class="comment">// 保存的值</span></div><div class="line">    <span class="keyword">double</span> score;  <span class="comment">// 节点分值</span></div><div class="line">    <span class="keyword">struct</span> zskiplistNode *backward;  <span class="comment">// 后退指针</span></div><div class="line">    <span class="comment">// 层</span></div><div class="line">    <span class="keyword">struct</span> zskiplistLevel &#123;    </div><div class="line">        <span class="keyword">struct</span> zskiplistNode *forward;   <span class="comment">// 前进指针</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;   <span class="comment">// 跨度</span></div><div class="line">    &#125; level[];</div><div class="line">&#125; zskiplistNode;</div></pre></td></tr></table></figure></p>
<ul>
<li>层：level数组包含多个元素,每个元素都包含一个指向其他节点的指针,程序可以通过这些层来加快访问其他节点的速度,一般来说,层的数量越多,访问其他节点的速度就越快</li>
<li>前进指针：每个层都有一个指向表尾方向的前进指针,用于从表头向表尾方向访问节点</li>
<li>跨度：表示两个节点之间的距离（前进指针指向节点和当前节点的距离）</li>
<li>后退指针：用于从表尾向表头访问节点</li>
<li>score分值：跳跃表中所有的节点按照分值进行排序</li>
<li>obj：保存的成员，一般为sds数据结构</li>
</ul>
<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 跳跃表</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> zskiplist &#123;</div><div class="line">    <span class="keyword">struct</span> zskiplistNode *header, *tail; <span class="comment">// 头结点、尾节点</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;  <span class="comment">// 长度</span></div><div class="line">    <span class="keyword">int</span> level; <span class="comment">// 最高层节点的层数</span></div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure>
<p>跳跃表记录了头结点和尾结点的指针、长度（即跳跃表中节点数目）和层数最大的节点的层数，注意表头节点的层高并不计算在内。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="创建跳跃表"><a href="#创建跳跃表" class="headerlink" title="创建跳跃表"></a>创建跳跃表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建跳跃表节点</span></div><div class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</div><div class="line">    <span class="comment">// 分配内存空间</span></div><div class="line">    zskiplistNode *zn = zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> zskiplistLevel));</div><div class="line">    <span class="comment">// 初始化</span></div><div class="line">    zn-&gt;score = score;</div><div class="line">    zn-&gt;obj = obj;</div><div class="line">    <span class="keyword">return</span> zn;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建跳跃表</span></div><div class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    zskiplist *zsl;</div><div class="line"></div><div class="line">    <span class="comment">// 分配内存空间</span></div><div class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</div><div class="line">    zsl-&gt;level = <span class="number">1</span>;</div><div class="line">    zsl-&gt;length = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 表头为32层的空节点，每一层都指向NULL</span></div><div class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</div><div class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</div><div class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</div><div class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">return</span> zsl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见：</p>
<ul>
<li>创建的跳跃表的初识level层数值为1</li>
<li>刚创建的跳跃表的头结点是一个有32层的空节点，其中每一层的forward都是NULL</li>
</ul>
<h3 id="跳跃表插入节点"><a href="#跳跃表插入节点" class="headerlink" title="跳跃表插入节点"></a>跳跃表插入节点</h3><p>跳跃表插入节点的部分有些复杂，需要改变节点前后节点的forward、backward指针以及长度等信息。其基本思想是：使用update表记录新节点在各层中forward指针指向它的节点，然后插入，同时改变这些复杂的指向关系。</p>
<p>其中rank数组是用来记录每一个节点再整个节点表中的排位信息，其是通过每层中的跨度计算得来的。</p>
<p>新插入的节点的层数是通过幂次定律决定的一个1-32的数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回一个1-32的层数值，使用幂次定律，越大的数出现的概率越小</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</div><div class="line">    <span class="comment">// 使用幂次定律，1/4概率</span></div><div class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</div><div class="line">        level += <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 跳跃表插入节点</span></div><div class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    <span class="comment">// 记录每一个节点的排位信息</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</div><div class="line">    <span class="keyword">int</span> i, level;</div><div class="line"></div><div class="line">    redisAssert(!isnan(score));</div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="comment">// 查找插入位置，从最高的层开始</span></div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></div><div class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</div><div class="line">        <span class="comment">// 遍历跳跃表</span></div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            <span class="comment">// 对比分值</span></div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                    <span class="comment">// 对比成员</span></div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>))) &#123;</div><div class="line">            <span class="comment">// 计算排位</span></div><div class="line">            rank[i] += x-&gt;level[i].span;</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 第i层将要和新节点连接的节点</span></div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* we assume the key is not already inside, since we allow duplicated</span></div><div class="line">     * scores, and the re-insertion of score and redis object should never</div><div class="line">     * happen since the caller of zslInsert() should test in the hash table</div><div class="line">     * if the element is already inside or not. */</div><div class="line">    <span class="comment">// 获取层数</span></div><div class="line">    level = zslRandomLevel();</div><div class="line">    <span class="comment">// 新的层数比原来所以节点的层数都大</span></div><div class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 初始化未使用的层</span></div><div class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</div><div class="line">            rank[i] = <span class="number">0</span>;</div><div class="line">            update[i] = zsl-&gt;header;</div><div class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</div><div class="line">        &#125;</div><div class="line">        zsl-&gt;level = level;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 创建指定层数的新节点</span></div><div class="line">    x = zslCreateNode(level,score,obj);</div><div class="line">    <span class="comment">// 使用update中的信息将为新的节点建立连接</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</div><div class="line">        <span class="comment">// 设置新节点的forward</span></div><div class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</div><div class="line">        <span class="comment">// 前面的节点的forward指向新节点</span></div><div class="line">        update[i]-&gt;level[i].forward = x;</div><div class="line"></div><div class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></div><div class="line">        <span class="comment">// 更新跨节点数量</span></div><div class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</div><div class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* increment span for untouched levels */</span></div><div class="line">    <span class="comment">// 没有和新节点接触的节点的跨度也要加一</span></div><div class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        update[i]-&gt;level[i].span++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 更新后退指针（新节点的后退指针+前面一个节点的后退指针）</span></div><div class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</div><div class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</div><div class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        zsl-&gt;tail = x;</div><div class="line">    <span class="comment">// 更新长度</span></div><div class="line">    zsl-&gt;length++;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="跳跃表删除节点"><a href="#跳跃表删除节点" class="headerlink" title="跳跃表删除节点"></a>跳跃表删除节点</h3><p>删除节点的方法差不多就是插入节点方法的反向操作，首先找到目标节点（通过update数组记录沿途节点），接触forward指针关系，更新跳跃表的层数和长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank */</span></div><div class="line"><span class="comment">// 跳跃表内部删除节点，update数组为forward指向本节点的数组</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslDeleteNode</span><span class="params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="comment">// 解除forward关系</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123;</div><div class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="number">1</span>;</div><div class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            update[i]-&gt;level[i].span -= <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 更新backward指针</span></div><div class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward) &#123;</div><div class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x-&gt;backward;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        zsl-&gt;tail = x-&gt;backward;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果删除的节点是层数最大的节点，则更新跳跃表的最大层数</span></div><div class="line">    <span class="keyword">while</span>(zsl-&gt;level &gt; <span class="number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level<span class="number">-1</span>].forward == <span class="literal">NULL</span>)</div><div class="line">        zsl-&gt;level--;</div><div class="line">    <span class="comment">// 跳跃表长度减一</span></div><div class="line">    zsl-&gt;length--;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Delete an element with matching score/object from the skiplist. */</span></div><div class="line"><span class="comment">// 跳跃表删除节点</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslDelete</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历跳跃表，找到目标节点，并记录沿途节点</span></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>)))</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* We may have multiple elements with the same score, what we need</span></div><div class="line">     * is to find the element with both the right score and object. */</div><div class="line">    <span class="comment">// 只有在分值和对象都相同的时候才删除</span></div><div class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</div><div class="line">    <span class="keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; equalStringObjects(x-&gt;obj,obj)) &#123;</div><div class="line">        zslDeleteNode(zsl, x, update);</div><div class="line">        zslFreeNode(x);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="跳跃表查找节点"><a href="#跳跃表查找节点" class="headerlink" title="跳跃表查找节点"></a>跳跃表查找节点</h3><p>跳跃表中查找节点相关的操作主要有获取排名、依据排名获取信息。其基本思想和插入节点找到插入位置一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通过分值和对象值获取排位信息，以1为起始值</span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *o)</span> </span>&#123;</div><div class="line">    zskiplistNode *x;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rank = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="comment">// 从最高层依次往下</span></div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</div><div class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,o) &lt;= <span class="number">0</span>))) &#123;</div><div class="line">            <span class="comment">// 排位增加</span></div><div class="line">            rank += x-&gt;level[i].span;</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* x might be equal to zsl-&gt;header, so test if obj is non-NULL */</span></div><div class="line">        <span class="comment">// 对象和分数值都相等</span></div><div class="line">        <span class="keyword">if</span> (x-&gt;obj &amp;&amp; equalStringObjects(x-&gt;obj,o)) &#123;</div><div class="line">            <span class="keyword">return</span> rank;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Finds an element by its rank. The rank argument needs to be 1-based. */</span></div><div class="line"><span class="comment">// 通过排位获取节点</span></div><div class="line"><span class="function">zskiplistNode* <span class="title">zslGetElementByRank</span><span class="params">(zskiplist *zsl, <span class="keyword">unsigned</span> <span class="keyword">long</span> rank)</span> </span>&#123;</div><div class="line">    zskiplistNode *x;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> traversed = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    <span class="comment">// 从最高层依次往下找</span></div><div class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt;= rank)</div><div class="line">        &#123;</div><div class="line">            traversed += x-&gt;level[i].span;</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 找到相应的节点</span></div><div class="line">        <span class="keyword">if</span> (traversed == rank) &#123;</div><div class="line">            <span class="keyword">return</span> x;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用一张图能够简单表示这种查找行为，例如找到5这个节点：</p>
<p><img src="https://data2.liuin.cn/2018-03-22-56782.png" alt="56782"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis使用跳跃表作为有序集合键的底层实现之一，跳跃表(skiplist)是一种有序数据结构,它通过在每个节点中维持多个指向其他节点的指针,从而达到快速访问节点的目的。&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="https://www.liuin.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析——链表和字典</title>
    <link href="https://www.liuin.cn/2018/03/20/Redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.liuin.cn/2018/03/20/Redis源码解析——链表/</id>
    <published>2018-03-20T05:17:06.000Z</published>
    <updated>2018-03-26T05:01:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>链表和字典（dict）是比较常用的数据结构，但是C语言在底层并没有内置这种数据结构，这里通过源码查看这两个数据结构在Redis底层的实现</p>
<a id="more"></a>
<h2 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h2><p>Redis底层使用的是一个双端链表</p>
<p>链表节点结构定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 双端链表节点</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> listNode &#123;</div><div class="line">    <span class="keyword">struct</span> listNode *prev;  <span class="comment">// 前置节点</span></div><div class="line">    <span class="keyword">struct</span> listNode *next;  <span class="comment">// 后置节点</span></div><div class="line">    <span class="keyword">void</span> *value;   <span class="comment">// 节点值</span></div><div class="line">&#125; listNode;</div></pre></td></tr></table></figure></p>
<p>链表迭代器结构定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 双端链表迭代器</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> listIter &#123;</div><div class="line">    listNode *next; <span class="comment">// 迭代的指针</span></div><div class="line">    <span class="keyword">int</span> direction;  <span class="comment">// 迭代的方向</span></div><div class="line">&#125; listIter;</div></pre></td></tr></table></figure></p>
<p>通过迭代器可以比较容易对整个链表进行遍历，从而轻松实现查找等功能。</p>
<p>链表结构定义<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 双端链表</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">list</span> &#123;</div><div class="line">    listNode *head;  <span class="comment">// 头结点</span></div><div class="line">    listNode *tail;  <span class="comment">// 尾节点</span></div><div class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);  <span class="comment">// 节点值复制函数，可指定复制的方法</span></div><div class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);  <span class="comment">// 节点值释放函数</span></div><div class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);  <span class="comment">// 节点值对比函数</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;   <span class="comment">// 链表中所包含的节点数量</span></div><div class="line">&#125; <span class="built_in">list</span>;</div></pre></td></tr></table></figure></p>
<p>Redis底层中所包含的链表API都是对链表常用功能的实现，比如说插入、删除、搜索等，这里不在解释。</p>
<p>Redis的链表实现的特点有如下几个：</p>
<ul>
<li>双端，方便向前和向后便利</li>
<li>多态，链表节点使用void*指针来保存节点值,并且可以通过1ist结构的dup、free、 match三个属性为节点值设置类型特定函数,所以链表可以用于保存各种不同类型的值。</li>
</ul>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典,又称为符号表( symbol table)、关联数组( associative array)或映射(map),是种用于<strong>保存键值对(key- value pair)的抽象数据结构</strong>。</p>
<p>字典在Reds中的应用相当广泛,比如 Redis的数据库就是使用字典来作为底层实现的,对数据库的增、删、查、改操作也是构建在对字典的操作之上的。</p>
<h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><p>Redis的字典用哈希表作为底层实现，哈希表中含有哈希表节点，而每一个哈希表节点就保存了字典中的一个键值对。</p>
<blockquote>
<p>哈希表</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictht &#123;</div><div class="line">    dictEntry **table;  <span class="comment">// 哈希表的节点数组</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size; <span class="comment">// 哈希表大小</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;  <span class="comment">// 哈希表的大小掩码，用于计算索引值，总等于size-1</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used; <span class="comment">// 哈希表中含有的节点数</span></div><div class="line">&#125; dictht;</div></pre></td></tr></table></figure>
<p>sizemask属性的值总是等于size-1,这个属性和哈希值一起决定一个键应该被放到tab1e数组的哪个索引上面。</p>
<blockquote>
<p>哈希表节点</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 哈希表节点</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dictEntry &#123;</div><div class="line">    <span class="keyword">void</span> *key;  <span class="comment">// 键  </span></div><div class="line">    <span class="keyword">union</span> &#123;  </div><div class="line">        <span class="keyword">void</span> *val;</div><div class="line">        <span class="keyword">uint64_t</span> u64;</div><div class="line">        <span class="keyword">int64_t</span> s64;</div><div class="line">        <span class="keyword">double</span> d;</div><div class="line">    &#125; v;   <span class="comment">// 值</span></div><div class="line">    <span class="keyword">struct</span> dictEntry *next;  <span class="comment">// 下一个哈希表结点，形成链表</span></div><div class="line">&#125; dictEntry;</div></pre></td></tr></table></figure>
<p>Redis中哈希表解决冲突的方法是拉链法，所以其中有next属性指向另一个哈希表节点的指针,这个指针可以将多个哈希值相同的键值对连接在一次,以此来解决键冲突( collision)的问题。</p>
<blockquote>
<p>字典</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> dict &#123;</div><div class="line">    dictType *type;  <span class="comment">// 类型特定函数</span></div><div class="line">    <span class="keyword">void</span> *privdata;  <span class="comment">// 私有数据</span></div><div class="line">    dictht ht[<span class="number">2</span>];   <span class="comment">// 含有两个哈希表</span></div><div class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">// rehash 索引，当rehash不再运行的时候，值为-1</span></div><div class="line">    <span class="keyword">int</span> iterators;  <span class="comment">// 现在正在运行的迭代器数量</span></div><div class="line">&#125; dict;</div></pre></td></tr></table></figure>
<p>type属性和 privata属性是针对不同类型的键值对,为创建多态字典而设置的；ht属性是一个包含两个项的数组,数组中的每个项都是一个 dictht哈希表,一般情况下,字典只使用ht[0]哈希表,ht[1]哈希表只会在对ht[0]哈希表进行 rehash时使用。</p>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>把一个新的键值对加入到字典中，首先要根据key计算出哈希值和索引值，然后把新的哈希节点加到哈希表数组的指定索引上面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 计算哈希值</span></div><div class="line">    h = dictHashKey(d, key);</div><div class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</div><div class="line">        <span class="comment">// 计算索引值</span></div><div class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</div><div class="line">        <span class="comment">/* Search if this slot does not already contain the given key */</span></div><div class="line">        <span class="comment">// 查找key是否存在</span></div><div class="line">        he = d-&gt;ht[table].table[idx];</div><div class="line">        <span class="keyword">while</span>(he) &#123;</div><div class="line">            <span class="keyword">if</span> (dictCompareKeys(d, key, he-&gt;key))</div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">            he = he-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>Redis使用的是Murmur算法计算哈希值的，这种算法的优点在于,即使输人的键是有规律的,算法仍能给出一个很好的随机分布性,并且算法的计算速度也非常快。</p>
<h3 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h3><p>Redis采用的是链地址法( separate chaining)解决键冲突的，每个哈希表节点都有个next指针,多个哈希表节点可以用next指针构成一个单向链表,被分配到同一个索引上的多个节点可以用这个单向链表连接起来,这就解决了键冲突的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Allocate the memory and store the new entry */</span></div><div class="line">ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</div><div class="line">entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</div><div class="line">entry-&gt;next = ht-&gt;table[index];  <span class="comment">// 把新的哈希节点加入到哈希数组索引处，并放在链表的头结点处</span></div><div class="line">ht-&gt;table[index] = entry;</div><div class="line">ht-&gt;used++;</div></pre></td></tr></table></figure>
<p><img src="https://data2.liuin.cn/2018-03-20-15215263654971.jpg" alt=""></p>
<h3 id="重新散列（rehash）"><a href="#重新散列（rehash）" class="headerlink" title="重新散列（rehash）"></a>重新散列（rehash）</h3><p>当dict不断进行添加或删除等操作的时候，所保存的键值对也会不断的增加或者减少。为了使哈希表的负载因子（load factor）维持在合理的范围内，此时就需要对哈希表的大小进行相应的扩展或者收缩。</p>
<p>这个工作通过重新散列（rehash）来进行，执行的主要步骤如下：</p>
<ul>
<li>为dict的ht[1]哈希表分配合适的空间，空间的大小取决于要执行的操作和ht[0]哈希表中键值对的数量</li>
<li>对所有在ht[0]中的键值对重新计算哈希索引值，将他们转移到ht[1]中</li>
<li>释放ht[0]，将ht[1]设置为ht[0]</li>
</ul>
<p>其中负载因子的计算公式为：<code>load_factor = ht[0].used / ht[0].size</code></p>
<blockquote>
<p>渐进式rehash</p>
</blockquote>
<p>在进行rehash的过程中需要将所有的键值对从ht[0]迁移到ht[1]中，如果键值对的数量比较大的话，就会导致Redis需要停止一段时间的服务才能够完成这些操作，所以为了避免对服务性能造成影响，rehash并不是一次性的、集中式地完成的，而是分多次、渐进式完成的。</p>
<p>具体的步骤如下：</p>
<ul>
<li>为ht[1]分配空间，同时保留ht[0]和ht[1]两个哈希表</li>
<li>在dict中维持一个索引计数变量rehashldx，将其值设为0，表示开始rehash（不工作是为-1）</li>
<li>在rehash是，每对dict进行一次操作的时候，除了进行制定操作外还要ht[0]哈希表中rehashldx索引上的索引键值对转移的ht[1]上，完成以后将rehashldx加一</li>
<li>当完成了所有ht[0]到ht[1]键值对的转移工作时，表示完成了rehash，此时将rehashldx的值设为-1</li>
</ul>
<p>在渐进式rehash的过程中，dict同时拥有两个hash表，所以dict的删除、查找、更新等操作会在两个哈希表上同时进行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在rehash期间每进行一次操作，迁移一个索引中所有的键值对</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></div><div class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</div><div class="line">        dictEntry *de, *nextde;</div><div class="line"></div><div class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></div><div class="line">         * elements because ht[0].used != 0 */</div><div class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</div><div class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</div><div class="line">            d-&gt;rehashidx++;</div><div class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</div><div class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></div><div class="line">        <span class="comment">// 对每一个键值对重新计算hash值、index值，进行迁移</span></div><div class="line">        <span class="keyword">while</span>(de) &#123;</div><div class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</div><div class="line"></div><div class="line">            nextde = de-&gt;next;</div><div class="line">            <span class="comment">/* Get the index in the new hash table */</span></div><div class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</div><div class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</div><div class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</div><div class="line">            d-&gt;ht[<span class="number">0</span>].used--;</div><div class="line">            d-&gt;ht[<span class="number">1</span>].used++;</div><div class="line">            de = nextde;</div><div class="line">        &#125;</div><div class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</div><div class="line">        d-&gt;rehashidx++; <span class="comment">// 将rehashldx的值加一</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></div><div class="line">    <span class="comment">// 完成渐进式rehash工作</span></div><div class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</div><div class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</div><div class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</div><div class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</div><div class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* More to rehash... */</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链表和字典（dict）是比较常用的数据结构，但是C语言在底层并没有内置这种数据结构，这里通过源码查看这两个数据结构在Redis底层的实现&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="https://www.liuin.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码剖析——简单动态字符串(SDS)</title>
    <link href="https://www.liuin.cn/2018/03/19/Redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2-SDS/"/>
    <id>https://www.liuin.cn/2018/03/19/Redis源码解析——简单动态字符串-SDS/</id>
    <published>2018-03-19T10:45:00.000Z</published>
    <updated>2018-03-23T10:41:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>解析Redis的一个底层数据结构——简单动态数组，讨论起优点和不足</p>
<a id="more"></a>
<p>Redis没有直接使用C语言传统的字符串表示(以空字符结尾的字符数组),而是自己构建了一种名为<strong>简单动态字符串</strong>( simple dynamic string,SDS)的抽象类型,并将SDS用作 Redis的默认字符串表示。现在作者把这一个部分抽出来，单独做了一个项目，地址在<a href="https://github.com/antirez/sds" target="_blank" rel="external">这里</a></p>
<h2 id="数据结构定义定义"><a href="#数据结构定义定义" class="headerlink" title="数据结构定义定义"></a>数据结构定义定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sdshdr &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;   <span class="comment">// buf数组中已经使用的字节数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>;  <span class="comment">// buf数组中未使用的字节数量</span></div><div class="line">    <span class="keyword">char</span> buf[];         <span class="comment">// 字节数组，保存字符</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>SDS遵循C字符串以空字符结尾的惯例,保存空字符的1字节空间不计算在SDS的1en属性里面,并且为空字符分配额外的1字节空间,以及添加空字符到字符串末尾等操作</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><h3 id="获取字符串长度是常数级复杂度"><a href="#获取字符串长度是常数级复杂度" class="headerlink" title="获取字符串长度是常数级复杂度"></a>获取字符串长度是常数级复杂度</h3><p>C语言中获取字符串的长度需要把整个字符串都遍历一遍，而对于SDS来说，只需要访问len属性，将时间复杂度从O（N）降低到了O（1）</p>
<h3 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h3><p>除了获取字符串长度的复杂度高之外,C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出( buffer overflow)。C语言字符串进行拼接的时候如果不对原来的字符串分配足够的空间，容易造成溢出。</p>
<p>与C字符串不同,SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性:当SDS API需要对SDS进行修改时,API会先检查SDS的空间是否满足修改所需的要求,如果不满足的话,API会自动将SDS的空间扩展至执行修改所需的大小,然后才执行实际的修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 追加长度为len的字符串到buf的末尾</span></div><div class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh;</div><div class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</div><div class="line"></div><div class="line">    <span class="comment">// 扩展sds空间，确保其至少含有len+1个空间可以放置字符串</span></div><div class="line">    s = sdsMakeRoomFor(s,len);</div><div class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    <span class="comment">// 复制字符串</span></div><div class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</div><div class="line">    <span class="comment">// 更新长度</span></div><div class="line">    sh-&gt;len = curlen+len;</div><div class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>-len;</div><div class="line">    s[curlen+len] = <span class="string">'\0'</span>;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h3><p>C语言中，每次对字符串进行修改都要进行内存的重新分配，在SDS中使用<strong>空间预分配和惰性空间释放</strong>来减少内存重新分配的次数</p>
<blockquote>
<p>空间预分配</p>
</blockquote>
<p>SDS在执行空间扩展的时候将执行以下策略：</p>
<ul>
<li>如果对SDS进行修改之后,SDS的长度(也即是1en属性的值)将小于1MB,那么程序分配和1en属性同样大小的未使用空间,这时SDs1en属性的值将和free属性的值相同。</li>
<li>如果对SDs进行修改之后,SDS的长度将大于等于1MB,那么程序会分配1MB的未使用空间。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对sds中buf的长度进行扩展，至少有addlen+1长度的剩余空间</span></div><div class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh, *newsh;</div><div class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</div><div class="line">    <span class="keyword">size_t</span> len, newlen;</div><div class="line"></div><div class="line">    <span class="comment">// 目前剩余空间足够</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</div><div class="line">    len = sdslen(s);</div><div class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    newlen = (len+addlen);</div><div class="line">    <span class="comment">// 分配两倍空间</span></div><div class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</div><div class="line">        newlen *= <span class="number">2</span>;</div><div class="line">    <span class="comment">// 分配1M空间</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        newlen += SDS_MAX_PREALLOC;</div><div class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+newlen+<span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 更新剩余空间</span></div><div class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</div><div class="line">    <span class="keyword">return</span> newsh-&gt;buf;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>惰性空间释放</p>
</blockquote>
<p>惰性空间释放用于优化SDS的字符串缩短操作:当SDS的API需要缩短SDS保存的字符串时,程序并不立即使用内存重分配来回收缩短后多出来的字节,而是使用free属性将这些字节的数量记录起来,并等待将来使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 移除所有在s中出现过的cset字符</span></div><div class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span> </span>&#123;</div><div class="line">    <span class="keyword">struct</span> sdshdr *sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line">    <span class="keyword">char</span> *start, *end, *sp, *ep;</div><div class="line">    <span class="keyword">size_t</span> len;</div><div class="line"></div><div class="line">    sp = start = s;</div><div class="line">    ep = end = s+sdslen(s)<span class="number">-1</span>;</div><div class="line">    <span class="keyword">while</span>(sp &lt;= end &amp;&amp; <span class="built_in">strchr</span>(cset, *sp)) sp++;</div><div class="line">    <span class="keyword">while</span>(ep &gt; start &amp;&amp; <span class="built_in">strchr</span>(cset, *ep)) ep--;</div><div class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep-sp)+<span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (sh-&gt;buf != sp) memmove(sh-&gt;buf, sp, len);</div><div class="line">    sh-&gt;buf[len] = <span class="string">'\0'</span>;</div><div class="line">    <span class="comment">// 并没有释放buf空间，而是增加free数量</span></div><div class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>+(sh-&gt;len-len);</div><div class="line">    sh-&gt;len = len;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>C字符串中的字符必须符合某种编码方式，并且除了字符串的末尾处，字符串里面不能包含空字符。使得C字符串只能保存文本数据,而不能保存像图片、音频、视频、压缩文件这样的二进制数据。</p>
<p>Redis可以适用于各种不同的使用场景,SDS的API都是二进制安全的(binary-safe),所有 SDS API都会以处理二进制的方式来处理SDs存放在buf数组里的数据</p>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><h3 id="API返回后不能确定内部是否重新分配了空间"><a href="#API返回后不能确定内部是否重新分配了空间" class="headerlink" title="API返回后不能确定内部是否重新分配了空间"></a>API返回后不能确定内部是否重新分配了空间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s = sdscat(s, <span class="string">"Hello world"</span>);</div></pre></td></tr></table></figure>
<p>s既是参数，又作为了返回值，原因是我们在调用sdscat函数之前不确定s的剩余空间是否足够分配出data长度的字节，如果不够的话，内部会重新malloc空间，然后把目前的sds包括头部全部挪过去，这样的话如果我们没有把返回的地址重新赋值给s,那么s实际上是失效的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解析Redis的一个底层数据结构——简单动态数组，讨论起优点和不足&lt;/p&gt;
    
    </summary>
    
      <category term="源码剖析" scheme="https://www.liuin.cn/categories/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>初识Redis</title>
    <link href="https://www.liuin.cn/2018/03/19/%E5%88%9D%E8%AF%86Redis/"/>
    <id>https://www.liuin.cn/2018/03/19/初识Redis/</id>
    <published>2018-03-19T10:41:15.000Z</published>
    <updated>2018-03-19T11:16:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是我在认识Redis过程中的一些笔记</p>
<a id="more"></a>
<h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>官网的介绍：</p>
<blockquote>
<p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.</p>
</blockquote>
<p>简单来说就是一个数据存储在内存中的一个key-value存储系统。</p>
<p>通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。而键（key）只能是字符串类型（String）</p>
<h2 id="Redis有什么优势"><a href="#Redis有什么优势" class="headerlink" title="Redis有什么优势"></a>Redis有什么优势</h2><h3 id="支持多种数据结构k"><a href="#支持多种数据结构k" class="headerlink" title="支持多种数据结构k"></a>支持多种数据结构k</h3><p>key-value系统中的值支持多种数据结构：字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)。使得我们使用的时候更加方便，更容易和已有的代码进行整合</p>
<h3 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h3><p>redis使用rdb和aof做数据的持久化存储。主从数据同时，生成rdb文件，并利用缓冲区添加新的数据更新操作做对应的同步。将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</p>
<h3 id="性能好"><a href="#性能好" class="headerlink" title="性能好"></a>性能好</h3><p>因为数据是存储在内存中，所以读写速度非常高。Redis能读的速度是110000次/s,写的速度是81000次/s 。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>Redis的所有操作都是原子的，同时支持几个操作合并以后的原子性</p>
<h3 id="丰富的特性"><a href="#丰富的特性" class="headerlink" title="丰富的特性"></a>丰富的特性</h3><p>支持pulish/subscribe、key过期等特性</p>
<h2 id="Redis有什么缺点"><a href="#Redis有什么缺点" class="headerlink" title="Redis有什么缺点"></a>Redis有什么缺点</h2><h3 id="使用内存，资源有限"><a href="#使用内存，资源有限" class="headerlink" title="使用内存，资源有限"></a>使用内存，资源有限</h3><p>因为数据存储在内存中，单台机器的存储数据量跟机器本身的内存大小有很大的关系。虽然redis本身有key过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。</p>
<h2 id="Redis-适用场景"><a href="#Redis-适用场景" class="headerlink" title="Redis 适用场景"></a>Redis 适用场景</h2><p>Redis因为其性能非常，所以很多在普通数据上运行不够理想的功能使用Redis都能够得到比较好的效果</p>
<h3 id="需要快速排序的相关应用"><a href="#需要快速排序的相关应用" class="headerlink" title="需要快速排序的相关应用"></a>需要快速排序的相关应用</h3><p>像排行榜、过期项目这些功能需要我们快速排序并进行更新，我们就可以使用到Redis</p>
<h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p>在很多普通数据库中实现一个计数器的功能往往会遇到写入敏感等一些问题。这个在Redis中能够有很好的解决：Redis支持原子递增（atomic increment）</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Redis能够替代memcached，让你的缓存从只能存储数据变得能够更新数据，因此你不再需要每次都重新生成数据了。</p>
<h2 id="安装及使用"><a href="#安装及使用" class="headerlink" title="安装及使用"></a>安装及使用</h2><p>这里可以参考官方文档或者<a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="external">菜鸟教程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是我在认识Redis过程中的一些笔记&lt;/p&gt;
    
    </summary>
    
      <category term="开发随笔" scheme="https://www.liuin.cn/categories/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Redis" scheme="https://www.liuin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》笔记 高级主题部分</title>
    <link href="https://www.liuin.cn/2018/03/18/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98%E9%83%A8%E5%88%86/"/>
    <id>https://www.liuin.cn/2018/03/18/《C-Primer》笔记-高级主题部分/</id>
    <published>2018-03-18T11:17:21.000Z</published>
    <updated>2018-04-03T01:05:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》笔记 高级主题部分，时间关系只看了其中一部分</p>
<a id="more"></a>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>大型程序往往会使用多个独立开发的库,这些库又会定义大量的全局名字,如类、函数和模板等。当应用程序用到多个供应商提供的库时,不可避免地会发生某些名字相互冲突的情况。多个库将名字放置在全局命名空间中将引发命名空间污染( namespace pollution)。</p>
<p><strong>命名空间</strong>( namespace)为防止名字冲突提供了更加可控的机制。<strong>命名空间分割了全局命名空间,其中每个命名空间是一个作用域</strong>。通过在某个命名空间中定义库的名字,库的作者(以及用户1)可以避免全局名字固有的限制。</p>
<h3 id="命名空间定义"><a href="#命名空间定义" class="headerlink" title="命名空间定义"></a>命名空间定义</h3><p>一个命名空间的定义包含两部分:首先是关键字 name space,随后是命名空间的名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内,主要包括:类、变量(及其初始化操作)、函数(及其定义)、模板和其他命名空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> cplusplus_primer &#123; </div><div class="line">    <span class="keyword">class</span> Sales_data &#123; / * ... * /&#125;; </div><div class="line">    Sales_data <span class="keyword">operator</span>+(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;); </div><div class="line">    <span class="keyword">class</span> Query &#123; <span class="comment">/* ... */</span> &#125;; </div><div class="line">    <span class="keyword">class</span> Query_base &#123; <span class="comment">/* ... */</span>&#125;; </div><div class="line">&#125; <span class="comment">// like blocks, namespaces do not end with a semicolon</span></div></pre></td></tr></table></figure>
<blockquote>
<p>每一个命名空间都是一个作用域</p>
</blockquote>
<p>和其他作用域类似,命名空间中的每个名字都必须表示该空间内的唯一实体。因为不同命名空间的作用域不同,所以在不同命名空间内可以有相同名字的成员。</p>
<blockquote>
<p>命名空间可以不连续</p>
</blockquote>
<p>命名空间可以定义在几个不同的部分,这点与其他作用域不太一样。命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件组成一个命名空间。此时,命名空间的组织方式类似于我们管理自定义类及函数的方式</p>
<ul>
<li>命名空间的一部分成员的作用是定义类,以及声明作为类接口的函数及对象,则这些成员应该置于头文件中,这些头文件将被包含在使用了这些成员的文件中。</li>
<li>命名空间成员的定义部分则置于另外的源文件中</li>
</ul>
<blockquote>
<p>定义命名空间成员</p>
</blockquote>
<p>假定作用域中存在合适的声明语句,则命名空间中的代码可以使用同一命名空间定义的名字的简写形式:</p>
<blockquote>
<p>全局命名空间</p>
</blockquote>
<p>全局作用域中定义的名字(即在所有类、函数及命名空间之外定义的名字)也就是定义在<strong>全局命名空间</strong>( global namespace)中。全局命名空间以隐式的方式声明,并且在所有程序中都存在。全局作用域中定义的名字被隐式地添加到全局命名空间中。</p>
<h3 id="使用命名空间成员"><a href="#使用命名空间成员" class="headerlink" title="使用命名空间成员"></a>使用命名空间成员</h3><p>像 namespace_name:: member_name 这样使用命名空间的成员显然非常烦琐,特别是当命名空间的名字很长时尤其如此。幸运的是,我们可以通过一些其他更简便的方法使用命名空间的成员。</p>
<blockquote>
<p>命名空间的别名</p>
</blockquote>
<p>命名空间的别名( namespace alias)使得我们可以为命名空间的名字设定一个短得多的同义词。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> primer = cplusplus_primer;</div></pre></td></tr></table></figure>
<blockquote>
<p>using声明：扼要概述</p>
</blockquote>
<p>一条using声明( using declaration)语句一次只引入命名空间的一个成员。它使得我们可以清楚地知道程序中所用的到底是哪个名字。</p>
<p>using声明引入的名字遵守与过去一样的作用域规则:它的有效范围从uS1ng声明的地方开始,一直到 using声明所在的作用域结束为止。在此过程中,外层作用域的同名实体将被隐藏。未加限定的名字只能在 using声明所在的作用域以及其内层作用域中使用。</p>
<blockquote>
<p>using 指示</p>
</blockquote>
<p>using指示( using directive)和 using声明类似的地方是,我们可以使用命名空间名字的简写形式:和 using声明不同的地方是,我们无法控制哪些名字是可见的,因为所有名字都是可见的</p>
<p>using指示以关键字using开始,后面是关键字 namespace以及命名空间的名字。</p>
<blockquote>
<p>using 指示与作用域</p>
</blockquote>
<p>using指示引入的名字的作用域远比 using声明引入的名字的作用域复杂。如我们所知,uS1ng声明的名字的作用域与uS1ng声明语句本身的作用域一致,从效果上看就好像 using声明语句为命名空间的成员在当前作用域内创建了一个别名一样。</p>
<p>using指示所做的绝非声明别名这么简单。相反,<strong>它具有将命名空间成员提升到包含命名空间本身和using指示的最近作用域的能力</strong>。    </p>
<blockquote>
<p>类、命名空间与作用域</p>
</blockquote>
<p>对命名空间内部名字的查找遵循常规的查找规则:即由内向外依次查找每个外层作用域。外层作用域也可能是一个或多个嵌套的命名空间,直到最外层的全局命名空间查找过程终止。只有位于开放的块中且在使用点之前声明的名字才被考虑</p>
<h2 id="tuple类型"><a href="#tuple类型" class="headerlink" title="tuple类型"></a>tuple类型</h2><p>tuple是类似pair的模板。每个pair的成员类型都不相同,但每个pair都恰好有两个成员。不同 tuple类型的成员类型也不相同,但<strong>一个tup1e可以有任意数量的成员</strong>。每个确定的 tuple类型的成员数目是固定的,但一个tuple类型的成员数目可以与另一个 tuple类型不同。</p>
<p>当我们希望将一些数据组合成单一对象,但又不想麻烦地定义一个新数据结构来表示这些数据时,tup1e是非常有用的。</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209268356387.jpg" alt=""></p>
<p>我们可以将 tuple看作一个“快速而随意”的数据结构。</p>
<h3 id="定义和初始化tuple"><a href="#定义和初始化tuple" class="headerlink" title="定义和初始化tuple"></a>定义和初始化tuple</h3><p>当我们定义一个 tuple时,需要指出每个成员的类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD; <span class="comment">// all three members set to 0 tuple&lt;string,</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;, <span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; someVal(<span class="string">"constants"</span>, &#123;<span class="number">3.14</span>, <span class="number">2.718</span>&#125;, <span class="number">42</span>, &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);</div></pre></td></tr></table></figure>
<p>当我们创建一个tup1e对象时,可以使用 tuple的默认构造函数,它会对每个成员进行值初始化;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">// error</span></div><div class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;   <span class="comment">// OK</span></div></pre></td></tr></table></figure>
<p>类似 make_pair函数,标准库定义了 make_tuple函,我们还可以用它来生成 tuple对象。</p>
<blockquote>
<p>访问tuple的成员</p>
</blockquote>
<p>tuple的成员都是未命名的。要访问一个 tuple的成员,就要使用一个名为get的标准库函数模板。为了使用get,我们必须指定一个显式模板实参,它指出我们想要访问第几个成员。我们传递给qet一个tup1e对象,它返回指定成员的引用:</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209364781943.jpg" alt=""></p>
<p>尖括号中的值必须是一个整型常量表达式。</p>
<p>如果不知道一个tup1e准确的类型细节信息,可以用两个辅助类模板来查询tuple成员的数量和类型:</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209366456481.jpg" alt=""></p>
<blockquote>
<p>关系和相等运算符</p>
</blockquote>
<p>tuple 的关系和相等运算符的行为类似容器的对应操作。</p>
<h3 id="使用tuple返回多个值"><a href="#使用tuple返回多个值" class="headerlink" title="使用tuple返回多个值"></a>使用tuple返回多个值</h3><p>tuple的一个常见用途是从一个函数返回多个值。</p>
<blockquote>
<p>返回tuple的函数</p>
</blockquote>
<p><img src="https://data2.liuin.cn/2018-03-13-15209367806251.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》笔记 高级主题部分，时间关系只看了其中一部分&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C/C++" scheme="https://www.liuin.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 题解——Longest Valid Parentheses</title>
    <link href="https://www.liuin.cn/2018/03/18/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Longest-Valid-Parentheses/"/>
    <id>https://www.liuin.cn/2018/03/18/LeetCode-题解——Longest-Valid-Parentheses/</id>
    <published>2018-03-18T01:52:16.000Z</published>
    <updated>2018-03-18T02:18:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题解——Longest Valid Parentheses</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个括号字符串，求出其中匹配的子字符串的最大长度</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>一个思路是用动态规划思想：用数组dp[i]表示以s[i]结尾的匹配子字符串的长度，这样我们可以得到状态转移方程：</p>
<p><img src="https://data2.liuin.cn/2018-03-18-15213386227746.jpg" alt=""></p>
<p>其中后面一个分支表示的情况是，最后以后<code>)</code>跳过前面的已经能够匹配的子字符串能和其前面的<code>(</code>匹配</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = s.length(), res = <span class="number">0</span>;</div><div class="line">        <span class="comment">// len+1 数组，最前面一个当做0</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(len+<span class="number">1</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i&gt;<span class="number">1</span> &amp;&amp; s[i<span class="number">-1</span>] == <span class="string">')'</span> &amp;&amp; s[i<span class="number">-2</span>] == <span class="string">'('</span>) dp[i]=dp[i<span class="number">-2</span>] + <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(i&gt;<span class="number">1</span> &amp;&amp; s[i<span class="number">-1</span>] == <span class="string">')'</span> &amp;&amp; s[i<span class="number">-2</span>] == <span class="string">')'</span> &amp;&amp; s[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>] == <span class="string">'('</span>) dp[i] = dp[i<span class="number">-1</span>] + dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>] + <span class="number">2</span>;</div><div class="line">            res = max(res, dp[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="利用栈"><a href="#利用栈" class="headerlink" title="利用栈"></a>利用栈</h3><p>这种括号字符串的题目，大部分都能够用栈来解决，按照以往的思路：遇到左括号入栈、遇到右括号出栈，这样输入匹配的括号之后，栈里面的东西不多不少，如果此时我们记录，第一个入栈时的位置，那么最后一个出栈的时候就可以通过位置（index）计算其长度了。</p>
<p>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</div><div class="line">        <span class="keyword">int</span> len = s.length();</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        st.push(<span class="number">-1</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</div><div class="line">                st.push(i);</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                st.pop();</div><div class="line">                <span class="comment">// 栈为空的时候表示新的串匹配开始</span></div><div class="line">                <span class="keyword">if</span>(st.empty())</div><div class="line">                    st.push(i);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                &#123;</div><div class="line">                    res = max(res, i-st.top());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题解——Longest Valid Parentheses&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.liuin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="DP" scheme="https://www.liuin.cn/tags/DP/"/>
    
      <category term="LeetCode" scheme="https://www.liuin.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX 数学公式</title>
    <link href="https://www.liuin.cn/2018/03/16/LaTeX-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <id>https://www.liuin.cn/2018/03/16/LaTeX-数学公式/</id>
    <published>2018-03-16T09:16:44.000Z</published>
    <updated>2018-03-16T11:03:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>平时写Markdown的时候难免会遇到一些用数学公式的情况，这里总结一些常用数学公式的写法。</p>
<a id="more"></a>
<h2 id="数学结构"><a href="#数学结构" class="headerlink" title="数学结构"></a>数学结构</h2><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p>常用的上下标结构</p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211921156811.jpg" alt=""></p>
<table>
<thead>
<tr>
<th>公式</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$A_{ij} = 2^{i+j}$</code></td>
<td>$A_{ij} = 2^{i+j}$</td>
</tr>
<tr>
<td><code>$A = 90^\circ$</code></td>
<td>$A = 90^\circ$</td>
</tr>
<tr>
<td><code>$\int_0^1 f(t) \dif t = \iint_D g(x, y) \dif x \dif y$</code></td>
<td>$\int_0^1 f(t) \cos t = \iint_D g(x, y) \cos x \sin y$</td>
</tr>
</tbody>
</table>
<h3 id="上下画线与花括号"><a href="#上下画线与花括号" class="headerlink" title="上下画线与花括号"></a>上下画线与花括号</h3><ul>
<li>\overline和\underline命令可用来在公式的上方和下方划横线</li>
<li>\overbrace和\underbrace带上花括号</li>
</ul>
<table>
<thead>
<tr>
<th>公式</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\overline{a+b} = \overline a \overline b$</code></td>
<td>$\overline{a+b} = \overline a \overline b$</td>
</tr>
<tr>
<td><code>$\overbrace {a+b+c} = \underbrace{1+2+3}$</code></td>
<td>$\overbrace {a+b+c} = \underbrace{1+2+3}$</td>
</tr>
</tbody>
</table>
<h3 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h3><p>分式使用<code>\face{分子}{分母}</code>得到</p>
<table>
<thead>
<tr>
<th>公式</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\frac{1}{\frac 12 (a+b)} = \frac{2}{a+b}$</code></td>
<td>$\frac{1}{\frac 12 (a+b)} = \frac{2}{a+b}$</td>
</tr>
</tbody>
</table>
<h3 id="根式"><a href="#根式" class="headerlink" title="根式"></a>根式</h3><p>根式是又一种常见的数学结构,用单参数的命令<code>\sqrt</code>得到,同时可以带一个可选参数,表示开方的次数</p>
<table>
<thead>
<tr>
<th>公式</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\sqrt[n] {\frac{x^2 + \sqrt 2}{x+y}}$</code></td>
<td>$\sqrt[n] {\frac{x^2 + \sqrt 2}{x+y}}$</td>
</tr>
</tbody>
</table>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>各种外括号不同的矩阵：</p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211932205959.jpg" alt=""></p>
<p>在矩阵环境中,不同的列用符号&amp;分隔,行用\分隔,矩阵每列中元素居中对齐</p>
<table>
<thead>
<tr>
<th>公式</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$ A = \begin{pmatrix} a &amp; b &amp; c \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; a \end{pmatrix}$</code></td>
<td>$ A = \begin {pmatrix} a &amp; b &amp; c \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; a \end {pmatrix}$</td>
</tr>
<tr>
<td><code>$ A = \begin{bmatrix} a_{11} &amp; \dots &amp; a_{1n} \\  &amp; \ddots &amp; \vdots \\ 0 &amp; &amp; a_{nn} \end{bmatrix} $</code></td>
<td>$ A = \begin{bmatrix} a_{11} &amp; \dots &amp; a_{1n} \\  &amp; \ddots &amp; \vdots \\ 0 &amp; &amp; a_{nn} \end{bmatrix} $</td>
</tr>
</tbody>
</table>
<h2 id="符号与类型"><a href="#符号与类型" class="headerlink" title="符号与类型"></a>符号与类型</h2><h3 id="字母表和普通符号"><a href="#字母表和普通符号" class="headerlink" title="字母表和普通符号"></a>字母表和普通符号</h3><p><img src="https://data2.liuin.cn/2018-03-16-15211956280206.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211956379753.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211956477483.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211956663623.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211956803907.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211956929506.jpg" alt=""></p>
<h3 id="数学算子"><a href="#数学算子" class="headerlink" title="数学算子"></a>数学算子</h3><p><img src="https://data2.liuin.cn/2018-03-16-15211957120206.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211957244734.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211957348221.jpg" alt=""></p>
<h3 id="二元运算符与关系符"><a href="#二元运算符与关系符" class="headerlink" title="二元运算符与关系符"></a>二元运算符与关系符</h3><p><img src="https://data2.liuin.cn/2018-03-16-15211957624199.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211957708521.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211957833150.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211957967157.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211958049898.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211958460225.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211958550071.jpg" alt=""></p>
<h3 id="括号与定界符"><a href="#括号与定界符" class="headerlink" title="括号与定界符"></a>括号与定界符</h3><p><img src="https://data2.liuin.cn/2018-03-16-15211959051369.jpg" alt=""></p>
<h3 id="标点"><a href="#标点" class="headerlink" title="标点"></a>标点</h3><p><img src="https://data2.liuin.cn/2018-03-16-15211959300033.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-03-16-15211959403756.jpg" alt=""></p>
<h2 id="在Hexo中使用LaTeX编辑数学公式"><a href="#在Hexo中使用LaTeX编辑数学公式" class="headerlink" title="在Hexo中使用LaTeX编辑数学公式"></a>在Hexo中使用LaTeX编辑数学公式</h2><p>在Hexo中编辑数学公式一般用的是<a href="https://github.com/hexojs/hexo-math" target="_blank" rel="external">这个</a>插件</p>
<p>其中有一个比较坑的点就是，不能够识别<code>\</code>和<code>_</code>这些符号，因为其在Markdown语法中也有一些意义，所以在某些情况下使用的时候还要在前面加一个<code>\</code>进行转义：</p>
<ul>
<li>后面接<code>,</code> 各种括号的时候，前面<code>_</code>所表示符号前面要加<code>\</code>转义</li>
</ul>
<p>另外可以更换markdown的渲染引擎，参考<a href="https://jdhao.github.io/2017/10/06/hexo-markdown-latex-equation/" target="_blank" rel="external">这里</a></p>
<p>主要参考：《LaTeX 入门》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时写Markdown的时候难免会遇到一些用数学公式的情况，这里总结一些常用数学公式的写法。&lt;/p&gt;
    
    </summary>
    
      <category term="开发随笔" scheme="https://www.liuin.cn/categories/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="LaTeX" scheme="https://www.liuin.cn/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 题解——Substring with Concatenation of All Words</title>
    <link href="https://www.liuin.cn/2018/03/15/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Substring-with-Concatenation-of-All-Words/"/>
    <id>https://www.liuin.cn/2018/03/15/LeetCode-题解——Substring-with-Concatenation-of-All-Words/</id>
    <published>2018-03-15T03:21:04.000Z</published>
    <updated>2018-03-15T03:22:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题解——Substring with Concatenation of All Words</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个字符串，和一组匹配字符串（vector），其中每一个字符串的长度是相同的，后面的这一组字符串可以形成一个组合，比如[“ab”,”cd”]可以组合成的字符串有：”abcd” “cdab”。题目要求我们在给定的这个字符串中查找出现后面这些组合的子串的位置（给出首字母位置）</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目中给出的匹配字符串组中每一个字符串的长度是相同的这个条件降低了题目的难度，如果从普通的字符串匹配的思路下手的话，就是每次从原串截取对比的长度是一样的，然后截取的字符串可以分割成几个长度相同的子字符串，我们只要判断这几个字符子串是否都在给出的这组匹配字符串中就行了。</p>
<p>这里使用两个unordered_map(Hash实现，性能更优)来判断是否都在这组字符串中，第一个map存储匹配字符串组中的字符串和出现的次数（都是1），第二个map存储截取的字符串分割以后的子串（并且在匹配字符串组中）以及其出现的次数，如果其次数大于1，表示截取的这段不符合条件，进行下一次匹配。</p>
<p>map有两个作用：查找字符串；记录出现次数</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">        <span class="comment">// 用来进行对比的map</span></div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; contrast;</div><div class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> s : words)</div><div class="line">        &#123;</div><div class="line">            contrast[s]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> slen = s.length(), wlen = words[<span class="number">0</span>].length(), wsize = words.size();</div><div class="line">        <span class="comment">// 依次截取一定长度的字符串进行匹配</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;slen-wsize*wlen+<span class="number">1</span>; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; tem;</div><div class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(; j&lt;wsize; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">// 分割以后的每一个字符串</span></div><div class="line">                <span class="built_in">string</span> stem = s.substr(i+j*wlen, wlen);</div><div class="line">                <span class="comment">// 判断是否在匹配字符串组中</span></div><div class="line">                <span class="keyword">if</span>(contrast.find(stem) != contrast.end())</div><div class="line">                &#123;</div><div class="line">                    tem[stem]++;</div><div class="line">                    <span class="comment">// 出现次数超过1，放弃</span></div><div class="line">                    <span class="keyword">if</span>(tem[stem] &gt; contrast[stem])</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(j == wsize)</div><div class="line">                res.push_back(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题解——Substring with Concatenation of All Words&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.liuin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://www.liuin.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Coursera 吴恩达机器学习 课程笔记</title>
    <link href="https://www.liuin.cn/2018/03/13/Coursera-%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.liuin.cn/2018/03/13/Coursera-吴恩达机器学习-课程笔记/</id>
    <published>2018-03-13T06:27:40.000Z</published>
    <updated>2018-03-16T11:01:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Coursera 吴恩达机器学习 课程笔记</p>
<a id="more"></a>
<h1 id="监督学习和无监督学习"><a href="#监督学习和无监督学习" class="headerlink" title="监督学习和无监督学习"></a>监督学习和无监督学习</h1><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>维基百科中的定义：</p>
<blockquote>
<p>监督式学习（英语：Supervised learning），是一个机器学习中的方法，可以由训练资料中学到或建立一个模式（函数 / learning model），并依此模式推测新的实例。训练资料是由输入物件（通常是向量）和预期输出所组成。函数的输出可以是一个连续的值（称为回归分析），或是预测一个分类标签（称作分类）</p>
</blockquote>
<p>在监督学习中, 我们的预测结果可以是连续值, 也可以是离散值. 我们根据这样的属性将监督学习氛围回归问题和分类问题.</p>
<h3 id="监督学习举例"><a href="#监督学习举例" class="headerlink" title="监督学习举例"></a>监督学习举例</h3><blockquote>
<p>回归问题</p>
</blockquote>
<p>通过给定的一个房子的面积来预测这个房子在市场中的价格. 这里的房子的面积就是特征, 房子的价格就是一个输出值. 为了解决这个问题, 我们获取了大量的房地产数据, 每一条数据都包含房子的面积及其对应价格. 第一, 我们的数据不仅包含房屋的面积, 还包含其对应的价格, 而我们的目标就是通过面积预测房价. 所以这应该是一个监督学习; 其次, 我们的输出数据房价可以看做是连续的值, 所以这个问题是一个回归问题.</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208368350754.jpg" alt=""></p>
<blockquote>
<p>分类问题</p>
</blockquote>
<p>我们的目标应该是要对数据进行分类. 现在我们的数据是有关乳腺癌的医学数据, 它包含了肿瘤的大小以及该肿瘤是良性的还是恶性的. 我们的目标是给定一个肿瘤的大小来预测它是良性还是恶性. 我们可以用0代表良性，1代表恶性. 这就是一个分类问题, 因为我们要预测的是一个离散值. </p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208368814648.jpg" alt=""></p>
<p>在这个例子中特征只有一个即瘤的大小。 对于大多数机器学习的问题, 特征往往有多个(上面的房价问题也是, 实际中特征不止是房子的面积). 例如下图， 有“年龄”和“肿瘤大小”两个特征。</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208369551948.jpg" alt=""></p>
<h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>在无监督学习中, 我们的数据并没有给出特定的标签, 例如上面例子中的房价或者是良性还是恶性. 我们目标也从预测某个值或者某个分类变成了寻找数据集中特殊的或者对我们来说有价值结构. </p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208370522571.jpg" alt=""></p>
<h3 id="无监督学习举例"><a href="#无监督学习举例" class="headerlink" title="无监督学习举例"></a>无监督学习举例</h3><blockquote>
<p>新闻分类</p>
</blockquote>
<p>Google News搜集网上的新闻，并且根据新闻的主题将新闻分成许多簇, 然后将在同一个簇的新闻放在一起。如图中红圈部分都是关于BP Oil Well各种新闻的链接，当打开各个新闻链接的时候，展现的都是关于BP Oil Well的新闻。</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208370968972.jpg" alt=""></p>
<blockquote>
<p>根据给定基因将人群分类</p>
</blockquote>
<p><img src="https://data2.liuin.cn/2018-03-12-15208371698906.jpg" alt=""></p>
<h1 id="单变量线性回归"><a href="#单变量线性回归" class="headerlink" title="单变量线性回归"></a>单变量线性回归</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="训练集"><a href="#训练集" class="headerlink" title="训练集"></a>训练集</h3><p>由训练样例(training example)组成的集合就是训练集(training set)</p>
<h3 id="假设函数"><a href="#假设函数" class="headerlink" title="假设函数"></a>假设函数</h3><p>使用某种学习算法对训练集的数据进行训练, 我们可以得到假设函数(Hypothesis Function)</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208382454378.jpg" alt=""></p>
<p>我们使用如下方法表示假设函数，</p>
<p>$$ {h_\theta(x)=\theta_0+\theta_1x} $$</p>
<p>以上这个模型就叫做单变量的线性回归(Linear Regression with One Variable).</p>
<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><h3 id="什么是代价函数"><a href="#什么是代价函数" class="headerlink" title="什么是代价函数"></a>什么是代价函数</h3><p>只要我们知道了假设函数, 我们就可以进行预测了. 关键是, 假设函数中有两个未知的量$\theta_0$,$\theta_1$. 当选择不同的$\theta_0$和$\theta_1$时, 我们模型的效果肯定是不一样的. 我们的想法是选择某个$\theta_0$和$\theta_1$，使得对于训练样例$(x,y)$，$h_\theta(x)$最“接近”$y$。越是接近, 代表这个假设函数越是准确, 这里我们选择均方误差来作为衡量标准, 即我们想要每个样例的估计值与真实值之间差的平方的均值最小:（其中$1/2$只是为了我们后面计算方便）</p>
<p>$$<br>{\mathop{min}\limits_{\theta_0,\theta_1}\frac{1}{2m}\sum_{i=0}^m\left(h_\theta(x^{(i)})-y^{(i)}\right)^2}<br>$$</p>
<p>记作：</p>
<p>$${J(\theta_0,\theta_1) = \frac{1}{2m}\sum_{i=0}^m\left(h_\theta(x^{(i)})-y^{(i)}\right)^2 }$$</p>
<p>这样就得到了我们的代价函数(cost function), 也就是我们的优化目标, 我们想要代价函数最小:</p>
<p>$$ \mathop{min}\limits_{\theta_0,\theta_1}J(\theta_0,\theta_1)$$</p>
<h3 id="代价函数和假设函数"><a href="#代价函数和假设函数" class="headerlink" title="代价函数和假设函数"></a>代价函数和假设函数</h3><p>对于不同的$\theta_1$，对应着不同的假设函数$h_\theta(x)$，于是就有了不同的代价函数$J (\theta_1)$的值。将这些点连接起来就可以得到$J(\theta_1)$和$\theta_1$关系的图像：</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208395529904.jpg" alt=""></p>
<p>我们的目标是找到一个$\theta$使得$J(\theta_1)$最小</p>
<p>如果我们考虑两个变量，能够绘制$J(\theta_0,\theta_1)$的图形如下</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208397051963.jpg" alt=""></p>
<p>由于3D图形不太方便我们研究，我们就使用二维的等高线(上图右上角教授写的contour plots/figures)，这样看上去比较清楚一些。越靠近中心表示$J(\theta_0,\theta_1)$值越小</p>
<h2 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h2><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>梯度下降算法是一种优化算法, 它可以帮助我们找到一个函数的局部极小值点. 它不仅仅可以用在线性回归模型中, 在机器学习许多其他的模型中也可以使用它. 对于我们现在研究的单变量线性回归来说, 我们想要使用梯度下降来找到最优的$\theta_0$,$\theta_1$。</p>
<p>它的思想是，首先随机选择两个$\theta_0$,$\theta_1$，不断改变他们的值使得$J(\theta)$最小，最终找到$J(\theta)$的最小点</p>
<p>可以把梯度下降的过程想象成下山坡, 如果想要尽可能快的下坡, 应该每次都往坡度最大的方向下山.</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208400482188.jpg" alt=""></p>
<p>算法过程：（要注意的是，算法是每次同时改变$\theta_0$和$\theta_1$的值）</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208401837391.jpg" alt=""></p>
<h3 id="梯度和学习率"><a href="#梯度和学习率" class="headerlink" title="梯度和学习率"></a>梯度和学习率</h3><p>学习率$\alpha$会影响梯度下降的幅度。如果$\alpha$的值太小，$\theta$的值每次会变化很小，那么梯度下降就会比较慢；相反，如果$\alpha$过大，$\theta$的值每次就会变化很大，有可能超过最低点，可能导致永远没法到达最低点。</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208404559020.jpg" alt=""></p>
<p>由于随着越来越接近最低点, 相应的梯度(绝对值)也会逐渐减小，所以每次下降程度就会越来越小, 我们并不需要减小$\alpha$的值来减小下降程度。</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208404858375.jpg" alt=""></p>
<h3 id="计算梯度"><a href="#计算梯度" class="headerlink" title="计算梯度"></a>计算梯度</h3><p>将偏导计算出来就得到了完整梯度下降算法：</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208405675961.jpg" alt=""></p>
<p>事实上，用于线性回归的代价函数总是一个凸函数(Convex Function)。这样的函数没有局部最优解，只有一个全局最优解。所以我们在使用梯度下降的时候，总会得到一个全局最优解。</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208406207656.jpg" alt=""></p>
<h1 id="多变量线性回归"><a href="#多变量线性回归" class="headerlink" title="多变量线性回归"></a>多变量线性回归</h1><h2 id="假设函数-1"><a href="#假设函数-1" class="headerlink" title="假设函数"></a>假设函数</h2><p>在之前的单变量线性回归中, 我们的问题只涉及到了房子面积这一个特征。在实际问题中, 会有很多特征. 例如, 除了房子面积, 还有房子的卧室数量, 房子的楼层数, 房子建筑年龄.</p>
<p>在单变量线性回归中假设函数为：</p>
<p>$${h_\theta(x)=\theta_0+\theta_1x}$$</p>
<p>现在对于多变量，可以设其假设函数为：</p>
<p>$${h_\theta(x)=\theta_0+\theta_1x_1+\theta_2x_2+…+\theta_nx_n}$$</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208613808836.jpg" alt=""></p>
<p>得到其向量表示：</p>
<p>$${h_\theta(x)=\theta_0x_0+\theta_1x_1+\theta_2x_2+…+\theta_nx_n= \theta^Tx}$$</p>
<h2 id="梯度下降-1"><a href="#梯度下降-1" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>多变量情况下的梯度下降其实没有区别, 只需要把对应的偏导数项换掉即可</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208618844580.jpg" alt=""></p>
<h2 id="特征处理"><a href="#特征处理" class="headerlink" title="特征处理"></a>特征处理</h2><h3 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h3><p>如果每个特征的范围相差的很大, 梯度下降会很慢. 为了解决这个问题, 我们在梯度下降之前应该对数据做特征归缩放(Feature Scaling)处理, 从而将所有的特征的数量级都在一个差不多的范围之内, 以加快梯度下降的速度.</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208619474872.jpg" alt=""></p>
<p>通常我们需要把特征都缩放到$[-1,1]$(附近)这个范围</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208619856026.jpg" alt=""></p>
<h3 id="均值均一化"><a href="#均值均一化" class="headerlink" title="均值均一化"></a>均值均一化</h3><p>还有一个特征处理的方法就是均值归一化(Mean normalization)</p>
<p>$${x_i=\frac{x_i-\mu_i}{max-min}}$$</p>
<h2 id="代价函数与学习率"><a href="#代价函数与学习率" class="headerlink" title="代价函数与学习率"></a>代价函数与学习率</h2><p>我们可以通过画出$\mathop{min}\limits_{\theta}J(\theta)$与迭代次数的关系来观察梯度下降的运行情况，</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209095236343.jpg" alt=""></p>
<p>出现下面两种情况，应该选择更小的学习率$\alpha$，</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209096625766.jpg" alt=""></p>
<p>注意：</p>
<ul>
<li>如果$\alpha$足够小，，那么$J(\theta)$在每次迭代之后都会减小</li>
<li>如果$\alpha$太小， 梯度下降会进行的非常缓慢.</li>
</ul>
<p>进行尝试的值：<br><img src="https://data2.liuin.cn/2018-03-13-15209097782077.jpg" alt=""></p>
<h2 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h2><p>多项式回归(Polynomial Regression)是研究一个因变量与一个或多个自变量间多项式的回归分析方法。如果自变量只有一个时，称为一元多项式回归；如果自变量有多个时，称为多元多项式回归。</p>
<p>我们可以将房屋的面积作为第一个特征, 面积的平方作为第二个特征, 面积的立方作为第三个特征:</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209102744925.jpg" alt=""></p>
<p>除了三次函数模型, 这里也可以选择平方根函数模型, 如下图所示</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209107024350.jpg" alt=""></p>
<h2 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h2><h3 id="正规方程介绍"><a href="#正规方程介绍" class="headerlink" title="正规方程介绍"></a>正规方程介绍</h3><p>之前我们一直是用的梯度下降求解最优值. 它的缺点就是需要进行很多次迭代才能得到全局最优解. 有没有更好的方法呢? 我们先来看一个最简单的例子, 假设现在的代价函数为$J(\theta)=a\theta^2+b\theta+c$，在导数等于0的时候取到最优解。</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209111273173.jpg" alt=""></p>
<p>下面我们介绍一种向量化的求解方法。首先, 在数据集前加上一列$X_0$，值都为1，然后将所有的变量都放入矩阵$X$中（包括加上的$x_0$）；再将输出值放入向量$y$中. 最后通过公式$$\theta=(X^TX)^{-1}X^Ty$$就可以算出最优解</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209221924071.jpg" alt=""></p>
<p>更通用的表达方式</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209222169590.jpg" alt=""></p>
<h3 id="梯度下降和正规方程的比较"><a href="#梯度下降和正规方程的比较" class="headerlink" title="梯度下降和正规方程的比较"></a>梯度下降和正规方程的比较</h3><p><img src="https://data2.liuin.cn/2018-03-13-15209222993254.jpg" alt=""></p>
<h3 id="正规方程不可逆的情况"><a href="#正规方程不可逆的情况" class="headerlink" title="正规方程不可逆的情况"></a>正规方程不可逆的情况</h3><p>使用正规方程还有一个问题就是$X^TX$可能存在不可逆的情况. 这个时候, 可能是因为我们使用了冗余的特征, 还有一个原因是我们使用了太多的特征(特征的数量超过了样本的数量). 对于这种情况我们可以删掉一些特征或者使用正则化(正则化在后面的课中讲).</p>
<p><img src="https://data2.liuin.cn/2018-03-13-15209223711085.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Coursera 吴恩达机器学习 课程笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="https://www.liuin.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》笔记 类设计者的工具部分</title>
    <link href="https://www.liuin.cn/2018/03/11/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7%E9%83%A8%E5%88%86/"/>
    <id>https://www.liuin.cn/2018/03/11/《C-Primer》笔记-类设计者的工具部分/</id>
    <published>2018-03-11T11:58:50.000Z</published>
    <updated>2018-04-18T08:32:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》笔记 类设计者的工具部分</p>
<a id="more"></a>
<h1 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h1><p>当定义一个类时,我们显式地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作,包括:拷贝构造函数( copy constructor)、拷贝赋值运算符( copy-assignment operator)、移动构造函数(moveconstructor)、移动赋值运算符(move-assignment operator)和析构函数( destructor)。</p>
<h2 id="拷贝、赋值与销毁"><a href="#拷贝、赋值与销毁" class="headerlink" title="拷贝、赋值与销毁"></a>拷贝、赋值与销毁</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>如果一个构造函数的第一个参数是自身类类型的引用,且任何额外参数都有默认值,则此构造函数是拷贝构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Foo&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Foo();      <span class="comment">// 默认构造函数</span></div><div class="line">    Foo(<span class="keyword">const</span> Foo&amp;);  <span class="comment">// 拷贝构造函数</span></div></pre></td></tr></table></figure>
<p>拷贝构造函数的第一个参数必须是一个引用类型,原因我们稍后解释。虽然我们可以定义个接受非 const引用的拷贝构造函数,但此参数几乎总是一个 const的引用。拷贝构造函数在几种情况下都会被隐式地使用。因此,拷贝构造函数通常不应该是 explicit（抑制构造函数定义的隐式转换）的</p>
<blockquote>
<p>合成拷贝构造函数</p>
</blockquote>
<p>对某些类来说,合成拷贝构造函数( synthesized copy constructor)用来阻止我们拷贝该类类型的对象。而一般情况,<strong>合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中</strong>。</p>
<blockquote>
<p>拷贝初始化</p>
</blockquote>
<p>当使用直接初始化时,我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。当我们使用拷贝初始化(copy initialization)时,我们要求<strong>编译器将右侧运算对象拷贝到正在创建的对象中,如果需要的话还要进行类型转换</strong>。</p>
<blockquote>
<p>拷贝初始化使用场景</p>
</blockquote>
<p>拷贝初始化不仅在我们用=定义变量时会发生,在下列情况下也会发生</p>
<ul>
<li>将一个对象作为实参传递给一个非引用类型的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li>
</ul>
<blockquote>
<p>参数和返回值</p>
</blockquote>
<p>在函数调用过程中,具有非引用类型的参数要进行拷贝初始化。类似的,当一个函数具有非引用的返回类型时,返回值会被用来初始化调用方的结果。</p>
<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><blockquote>
<p>重载赋值运算符</p>
</blockquote>
<p>重载运算符本质上是函数,其名字由 operator关键字后接表示要定义的运算符的符号组成。因此,赋值运算符就是一个名为 operator=的函数。类似于任何其他函数,运算符函数也有一个返回类型和一个参数列表。</p>
<p>重载运算符的参数表示运算符的运算对象。某些运算符,包括赋值运算符,必须定义为成员函数。如果一个运算符是一个成员函数,其左侧运算对象就绑定到隐式的this参数。对于一个二元运算符,例如赋值运算符,其右侧运算对象作为显式参数传递。</p>
<p>为了与内置类型的赋值保持一致,<strong>赋值运算符通常返回一个指向其左侧运算对象的引用</strong>。另外值得注意的是,标准库通常要求保存在容器中的类型要具</p>
<blockquote>
<p>合成拷贝赋值运算符</p>
</blockquote>
<p>与处理拷贝构造函数一样,如果一个类未定义自己的拷贝赋值运算符,编译器会为它生成一个合成拷贝赋值运算符</p>
<p>等价合成拷贝赋值运算符：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data &amp;rhs)</div><div class="line">&#123;</div><div class="line">    bookNo = rhs.bookNo;</div><div class="line">    revenue = rhs.revenur;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数执行与构造函数相反的操作:构造函数初始化对象的非 static数据成员还可能做一些其他工作;析构函数释放对象使用的资源,并销毁对象的非 static数据成员</p>
<blockquote>
<p>析构函数完成什么工作</p>
</blockquote>
<p>如同构造函数有一个初始化部分和一个函数体,析构函数也有一个函数体和一个析构部分。在一个构造函数中,成员的初始化是在函数体执行之前完成的,且按照它们在类中出现的顺序进行初始化。<strong>在一个析构函数中,首先执行函数体,然后销毁成员。成员按初始化顺序的逆序销毁</strong>。</p>
<blockquote>
<p>什么时候用到析构函数</p>
</blockquote>
<p>无论何时一个对象被销毁,就会自动调用其析构函数:</p>
<ol>
<li>变量在离开其作用域时被销毁。</li>
<li>当一个对象被销毁时,其成员被销毁。</li>
<li>容器(无论是标准库容器还是数组)被销毁时,其元素被销毁。</li>
<li>对于动态分配的对象,当对指向它的指针应用 delete运算符时被销毁</li>
<li>对于临时对象,当创建它的完整表达式结束时被销毁。</li>
</ol>
<blockquote>
<p>合成析构函数</p>
</blockquote>
<p>当一个类未定义自己的析构函数时,编译器会为它定义一个合成析构函数( synthesizeddestructor)。类似拷贝构造函数和拷贝赋值运算符,对于某些类,合成析构函数被用来阻止该类型的对象被销毁。如果不是这种情况，合成析构函数就为空</p>
<p>认识到析构函数体自身并不直接销毁成员是非常重要的。<strong>成员是在析构函数体之后隐含的析构阶段中被销毁的</strong>。在整个对象销毁过程中,析构函数体是作为成员销毁步骤之外的另一部分而进行的。</p>
<h3 id="三-五法则"><a href="#三-五法则" class="headerlink" title="三/五法则"></a>三/五法则</h3><p>如前所述,有三个基本操作可以控制类的拷贝操作:拷贝构造函数、拷贝赋值运算符和析构函数。</p>
<blockquote>
<p>需要析构函数的类也需要拷贝和赋值操作</p>
</blockquote>
<p>当我们决定一个类是否要定义它自己版本的拷贝控制成员时,一个基本原则是<strong>首先确定这个类是否需要一个析构函数。通常,对析构函数的需求要比对拷贝枃造函数或赋偵运算符的需求更为明显</strong>。如果这个类需要一个析构函数,我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。</p>
<blockquote>
<p>需要拷贝操作的类也需要赋值操作，反之亦然</p>
</blockquote>
<p>虽然很多类需要定义所有(或是不需要定义任何)拷贝控制成员,但某些类所要完成的工作,只需要拷贝或赋值操作,不需要析构函数。</p>
<p>这个例子引出了第二个基本原则:如果一个类需要一个拷贝构造函数,几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然—如果一个类需要一个拷贝赋值运篁符,几平可以肯定它也需要一个拷贝构造函数。然而,无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。</p>
<h3 id="使用-default"><a href="#使用-default" class="headerlink" title="使用=default"></a>使用=default</h3><p>我们可以通过将拷贝控制成员定义为= defau1t来显式地要求编译器生成合成的版本</p>
<p><img src="https://data2.liuin.cn/2018-03-05-15202146959452.jpg" alt=""></p>
<h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><p>虽然大多数类应该定义(而且通常也的确定义了)拷贝构造函数和拷贝赋值运算符,但对某些类来说,这些操作没有合理的意义。在此情况下,定义类时必须采用某种机制阻止拷贝或赋值。</p>
<blockquote>
<p>定义删除的函数</p>
</blockquote>
<p>在新标准下,我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数( deletedfunction)来阻止拷贝。删除的函数是这样一种函数:我们虽然声明了它们,但不能以任何方式使用它们]。在函数的参数列表后面加上=de1ete来指出我们希望将它定义为删除的:</p>
<blockquote>
<p>析构函数不能是删除的成员</p>
</blockquote>
<p>值得注意的是,我不能删除析构函数。如果析构函数被删除,就无法销毁此类型的对象了。对于一个删除了析构函数的类型,编译器将不允许定义该类型的变量或创建该类的临时对象。而且,如果一个类有某个成员的类型删除了析构函数,我们也不能定义该类</p>
<blockquote>
<p>private 拷贝控制</p>
</blockquote>
<p>在新标准发布之前,类是通过将其拷贝构造函数和拷贝赋值运算符声明为 private的来阻止拷贝:</p>
<p><img src="https://data2.liuin.cn/2018-03-05-15202148530112.jpg" alt=""></p>
<p>友元和成员函数仍旧可以拷贝对象。为了阻止友元和成员函数进行拷贝,我们将这些拷贝控制成员声明为 private的,但并不定义它们。</p>
<h2 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h2><p>通常,管理类外资源的类必须定义拷贝控制成员。某些类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数,那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。为了定义这些成员,我首先必须确定此类型对象的拷贝语义。一般来说,有两种选择:可以定义拷贝操作,<strong>使类的行为看起来像一个值或者像一个指针</strong>。</p>
<p>类的行为像一个值,意味着它应该也有自己的状态。当我们拷贝一个像值的对象时,副本和原对象是完全独立的。改变副本不会对原对象有任何影响,反之亦然。</p>
<p>行为像指针的类则共享状态。当我们拷贝一个这种类的对象时,副本和原对象使用相同的底层数据。改变副本也会改变原对象,反之亦然</p>
<h3 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h3><p>为了提供类值的行为,对于类管理的资源,每个对象都应该拥有一份自己的拷贝。这意味着对于ps指向的 string,每个 Hasptr对象都必须有自己的拷贝。</p>
<blockquote>
<p>类值拷贝赋值运算符</p>
</blockquote>
<p>赋值运算符通常组合了析构函数和构造函数的操作。类似析构函数,赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数,赋值操作会从右侧运算对象拷贝数据。</p>
<h3 id="定义行为像指针的类"><a href="#定义行为像指针的类" class="headerlink" title="定义行为像指针的类"></a>定义行为像指针的类</h3><p>对于行为类似指针的类,我们需要为其定义拷贝构造函数和拷贝赋值运算符,来拷贝指针成员本身而不是它指向的 string。我们的类仍然需要自己的析构函数来释放接受string参数的构造函数分配的内存。</p>
<p>令一个类展现类似指针的行为的最好方法是使用 share_ptr来管理类中的资源</p>
<p>但是,有时我们希望直接管理资源。在这种情况下,使用<strong>引用计数</strong>( reference count)就很有用了。</p>
<blockquote>
<p>定义一个使用引用计数的类</p>
</blockquote>
<p><img src="https://data2.liuin.cn/2018-03-05-15202156946283.jpg" alt=""></p>
<h2 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h2><p>除了定义拷贝控制成员,管理资源的类通常还定义一个名为swap的函数。对于那些与重排元素顺序的算法一起使用的类,定义swap是非常重要的。这类算法在需要交换两个元素时会调用swap。</p>
<p>为了交换两个对象，我们需要一次拷贝和两次赋值</p>
<blockquote>
<p>在赋值运算符中使用swap</p>
</blockquote>
<p>定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为拷贝并交换( copy and swap)的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// rhs按值传递，使用HasPtr的拷贝构造函数</span></div><div class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(HasPtr rhs)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 交换左侧运算对象和局部变量rhs的内容</span></div><div class="line">    swap(*<span class="keyword">this</span>, rhs);</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="动态内存管理类"><a href="#动态内存管理类" class="headerlink" title="动态内存管理类"></a>动态内存管理类</h2><p>某些类需要在运行时分配可变大小的内存空间。这种类通常可以(并且如果它们确实可以的话,一般应该)使用标准库容器来保存它们的数据。</p>
<p>但是,这一策略并不是对每个类都适用:某些类需要自己进行内存分配。这些类一般来说必须定义自己的拷贝控制成员来管理所分配的内存</p>
<h2 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h2><p>新标准的一个最主要的特性是可以移动而非拷贝对象的能力。在某些情况下,移动而非拷贝对象会大幅度提升性能。</p>
<p>在旧C++标准中,没有直接的方法移动对象。因此,即使不必拷贝对象的情况下,我们也不得不拷贝。如果对象较大,或者是对象本身要求分配内存空间(如 string),进行不必要的拷贝代价非常高。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>为了支持移动操作,新标准引入了一种新的引用类型——<strong>右值引用</strong>( rvalue reference)。所谓右值引用就是必须绑定到右值的引用。我们通过&amp;&amp;而不是&amp;来获得右值引用。如我们将要看到的,右值引用有一个重要的性质——一只能绑定到一个将要销毁的对象。</p>
<p>一般而言,一个左值表达式表示的是一个对象的身份,而一个右值表达式表示的是对象的值</p>
<p>类似任何引用,一个右值引用也不过是某个对象的另一个名字而已。如我们所知,对于常规引|用(为了与右值引用区分开来,我们可以称之为左值引用( Ivalue reference),我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用有着完全相反的绑定特性:<strong>我们可以将一个右值引用绑定到这类表达式上,但不能将一个右值引用直接绑定到一个左值上</strong></p>
<p><img src="https://data2.liuin.cn/2018-03-05-15202204986268.jpg" alt=""></p>
<blockquote>
<p>左值持久，右值短暂</p>
</blockquote>
<p>考察左值和右值表达式的列表,两者相互区别之处就很明显了:左值有持久的状态而右值要么是字面常量,要么是在表达式求值过程中创建的临时对象。</p>
<p>由于右值引用只能绑定到临时对象,我们得知</p>
<ul>
<li>所引用的对象将要被销毁</li>
<li>该对象没有其他用户</li>
</ul>
<p>这两个特性意味着:使用右值引用的代码可以自由地接管所引用的对象的资源</p>
<blockquote>
<p>标准库move函数</p>
</blockquote>
<p>虽然不能将一个右值引用直接绑定到一个左值上,但我们可以显式地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用,此函数定义在头文件uti1ity中。</p>
<h3 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h3><p>类似拷贝构造函数,移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是,这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样,任何额外的参数都必须有默认实参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">StrVec::StrVec(StrVec &amp;&amp;s) <span class="keyword">noexcept</span>   <span class="comment">// 移动操作不应抛出异常</span></div><div class="line">: elements(s.elements), first_free(s.first_free), cap(s.cap)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// s这种状态对于运行析构函数式安全的</span></div><div class="line">    s.elements = s.first_fiee = s.cap = <span class="literal">nullptr</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了完成资源移动,移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。特别是,一旦资源完成移动,源对象必须不再指向被移动的资源——这些资源的所有权已经归属新创建的对象</p>
<blockquote>
<p>移动赋值运算符</p>
</blockquote>
<p>移动赋值运算符执行与析构函数和移动构造函数相同的工作。与移动构造函数一样如果我们的移动赋值运算符不抛出任何异常,我们就应该将它标记为 except。</p>
<hr>
<h1 id="操作重载和类型转换"><a href="#操作重载和类型转换" class="headerlink" title="操作重载和类型转换"></a>操作重载和类型转换</h1><p>当运算符被用于类类型的对象时,C+语言允许我们为其指定新的含义:同时,我们也能自定义类类型之间的转换规则。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>重载的运算符是具有特殊名字的函数:它们的名字由关键字 operator和其后要定义的运算符号共同组成。和其他函数一样,重载的运算符也包含返回类型、参数列表以及函数体。</p>
<p>重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有个参数,二元运算符有两个。</p>
<p>如果一个运算符函数是成员函数,则它的第一个(左侧)运算对象绑定到隐式的this指针上。</p>
<p>可以被重载的运算符：<br><img src="https://data2.liuin.cn/2018-03-06-15202996380435.jpg" alt=""></p>
<p>我们只能重载已有的运算符,而无权发明新的运算符号。对于一个重载的运算符来说,其优先级和结合律与对应的内置运算符保持一致。</p>
<blockquote>
<p>直接调用重载运算符函数</p>
</blockquote>
<p>我们也能像调用普通函数一样直接调用运算符函数,先指定函数名字,然后传入数量正确、类型适当的实参:</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15202997181932.jpg" alt=""></p>
<blockquote>
<p>某些运算符不应该被重载</p>
</blockquote>
<p>回忆之前介绍过的,某些运算符指定了运算对象求值的顺序。因为使用重载的运算符本质上是一次函数调用,所以这些<strong>关于运算对象求值顺序的规则无法应用到重载的运算符上</strong>。特别是,逻辑与运算符、逻辑或运算符和逗号运算符的运算对又象求值顺序规则无法保留下来。除此之外,&amp;&amp;和||运算符的重载版本也无法保留内置运算符的短路求值属性,两个运算对象总是会被求值。</p>
<p>还有一个原因使得我们一般不重载逗号运算符和取地址运篁符:C+语言已经<strong>定义了这两种运算符用于类类型对象时的特殊含义</strong>,这一点与大多数运算符都不相同。因为这两种运算符已经有了内置的含义,所以一般来说它们不应该被重载,否则它们的行为将异于常态,从而导致类的用户无法适应。</p>
<blockquote>
<p>赋值和复合赋值运算符</p>
</blockquote>
<p>赋值运算符的行为与复合版本的类似:赋值之后,左侧运算对象和右侧运算对象的值相等,并且运算符应该返回它左侧运算对象的一个引用。<strong>重载的赋值运算应该继承而非违背其内置版本的含义</strong>。</p>
<blockquote>
<p>选择作为成员还是非成员</p>
</blockquote>
<p>当我们定义重载的运算符时,必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。</p>
<p>下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择：</p>
<ul>
<li>赋值(=)、下标([])、调用(())和成员访问箭头(-&gt;)运算符必须是成员。</li>
<li>复合赋值运算符一般来说应该是成员,但并非必须,这一点与赋值运算符略有不同。</li>
<li>改变对象状态的运算符或者与给定类型密切相关的运算符,如递增、递减和解引用运算符,通常应该是成员。</li>
<li>具有对称性的运算符可能转换任意一端的运算对象,例如算术、相等性、关系和位运算符等,因此它们通常应该是普通的非成员函数。</li>
</ul>
<h2 id="输入和输出运算符"><a href="#输入和输出运算符" class="headerlink" title="输入和输出运算符"></a>输入和输出运算符</h2><p>IO标准库分别使用&gt;&gt;和&lt;&lt;执行输入和输出操作。</p>
<h3 id="重载输出运算符-lt-lt"><a href="#重载输出运算符-lt-lt" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符&lt;&lt;</h3><p>输出运算符的<strong>第一个形参是一个非常量 ostream对象的引用</strong>。之所以ostream是非常量是因为向流写入内容会改变其状态;而该形参是引用是因为我们无法直接复制一个 ostream对象。</p>
<p><strong>第二个形参一般来说是一个常量的引用,该常量是我们想要打印的类类型</strong>。第二个形参是引用的原因是我们希望避免复制实参;而之所以该形参可以是常量是因为(通常情况下)打印对象不会改变对象的内容。</p>
<p>为了与其他输出运算符保持一致, operator&lt;&lt;一般要返回它的 ostream形参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Sale_data &amp;item)</div><div class="line">&#123;</div><div class="line">    os &lt;&lt; item.isbon() &lt;&lt; <span class="string">" "</span> &lt;&lt; item.units_old ;</div><div class="line">    <span class="keyword">return</span> os;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>输入运算符尽量减少格式化操作</p>
</blockquote>
<p>用于内置类型的输出运算符不太考虑格式化操作,尤其不会打印换行符,用户希望类的输出运算符也像如此行事。如果运算符打印了换行符,则用户就无法在对象的同一行内接着打印一些描述性的文本了。</p>
<blockquote>
<p>输入输出函数必须为非成员函数</p>
</blockquote>
<p>与 iostream标准库兼容的输入输出运算符必须是普通的非成员函数,而不能是类的成员函数。否则,它们的左侧运算对象将是我们的类的一个对象</p>
<p>因此,<strong>如果我们希望为类自定义IO运算符,则必须将其定义成非成员函数</strong>。当然,IO运算符通常需要读写类的非公有数据成员,所以IO运算符一般被声明为友元</p>
<h3 id="重载输入运算符-gt-gt"><a href="#重载输入运算符-gt-gt" class="headerlink" title="重载输入运算符&gt;&gt;"></a>重载输入运算符&gt;&gt;</h3><p>通常情况下,输入运算符的<strong>第一个形参是运算符将要读取的流的引用</strong>,<strong>第二个形参是将要读入到的(非常量)对象的引用</strong>。该运算符通常会返回某个给定流的引|用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Sales_data &amp;item)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">double</span> price;</div><div class="line">    is &gt;&gt; item.bokNo &gt;&gt; item.units_sold &gt;&gt; price;</div><div class="line">    item.revence = item.units_sold * price;</div><div class="line">    <span class="keyword">return</span> is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>输入时的错误</p>
</blockquote>
<ul>
<li>当流含有错误类型的数据时读取操作可能失败。</li>
<li>当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败。</li>
</ul>
<h2 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h2><p>我们把<strong>算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换</strong>。因为这些运算符一般不需要改变运算对象的状态,所以形参都是常量的引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Sales_data <span class="keyword">operator</span>+(Sales_data &amp;lhs, Sales_data &amp;rhs)</div><div class="line">&#123;</div><div class="line">    Sale_data sum = lhs;</div><div class="line">    sum += rhs;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><p>C++中的类通过定义相等运算符来检验两个对象是否相等。</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15203006569640.jpg" alt=""></p>
<p>设计准则：</p>
<ol>
<li>如果一个类含有判断两个对象是否相等的操作,则它显然应该把函数定义成oprator=而非一个普通的命名函数:因为用户肯定希望能使用==比较对象,所以提供了==就意味着用户无须再费时费力地学习并记忆一个全新的函数名字此外,类定义了==运算符之后也更容易使用标准库容器和算法。</li>
<li>如果类定义了 perator==,则该运算符应该能判断一组给定的对象中是否含有重复数据。</li>
<li>通常情况下,相等运算符应该具有传递性</li>
<li>如果类定义了 operator==,则这个类也应该定义 operator!=。对于用户来说当他们能使用==时肯定也希望能使用!=,反之亦然</li>
<li>相等运算符和不相等运算符中的一个应该把工作委托给另外一个</li>
</ol>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>定义了相等运算符的类也常常(但不总是)包含关系运算符。特别是,因为关联容器和一些算法要用到小于运算符,所以定义。 operator&lt;会比较有用。</p>
<ol>
<li>定义顺序关系，令其与关联容器中对关键词的要求一致</li>
<li>如果类同时含有==运算符的话，则定义一种关系令其与==保持一致</li>
</ol>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>之前已经介绍过拷贝赋值和移动赋值运算符,它们可以把<strong>类的一个对象赋值给该类的另一个对象</strong>。此外,类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象。</p>
<p>复合赋值运算符不非得是类的成员,不过我们还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部。为了与内置类型的复合赋值保持一致,类中的复合赋值运算符也要返回其左侧运算对象的引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Sale_data &amp;Sale_data::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Sale_data &amp;rhs)</div><div class="line">&#123;</div><div class="line">    units_sold += rhs.units_sold;</div><div class="line">    revenue += rhs.revenus;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><p>表示容器的类通常可以通过元素在容器中的位置访问元素,这些类一般会定义下标运算符 operator[]。</p>
<p><strong>下标运算符必须是成员函数</strong></p>
<p>为了与下标的原始定义兼容,<strong>下标运算符通常以所访问元素的引用作为返回值</strong>,这样做的好处是下标可以出现在赋值运算符的任意一端。进一步,我们最好<strong>同时定义下标运算符的常量版本和非常量版本</strong>,当作用于一个常量对象时,下标运算符返回常量引用以确保我们不会给返回的对象赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">class</span> StrVec &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</div><div class="line">    &#123; <span class="keyword">return</span> element[n]; &#125;</div><div class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) <span class="keyword">const</span></div><div class="line">    &#123; <span class="keyword">return</span> element[n]; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p>在迭代器类中通常会实现递増运算符(++)和递减运算符(–),这两种运算符使得类可以在元素的序列中前后移动。</p>
<blockquote>
<p>定义前置递增/递减运算符</p>
</blockquote>
<p>递增和递减运算符的工作机理非常相似:它们首先调用 check函数检验Strblobptr是否有效,如果是,接着检查给定的索引值是否有效。如果 check函数没有抛出异常,则运算符返回对象的引用。</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15203036806102.jpg" alt=""></p>
<blockquote>
<p>区分前置和后置运算符</p>
</blockquote>
<p>要想同时定义前置和后置运算符,必须首先解决一个问题,即普通的重载形式无法区分这两种情况。前置和后置版本使用的是同一个符号,意味着其重载版本所用的名字将是相同的,并且运算对象的数量和类型也相同。</p>
<p>为了解决这个问题,<strong>后置版本接受一个额外的(不被使用)int类型的形参</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15203037487660.jpg" alt=""></p>
<h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><p>在迭代器类及智能指针类中常常用到解引用运算符(*)和箭头运算符(-&gt;)。</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15203038781378.jpg" alt=""></p>
<blockquote>
<p>对箭头运算符返回值的限定</p>
</blockquote>
<p>和大多数其他运算符一样(尽管这么做不太好),我们能令 operator*完成任何我们指定的操作。换句话说,我们可以让 operator*返回一个固定值42,或者打印对象的内容,或者其他。<strong>箭头运算符则不是这样,它永远不能丢掉成员访问这个最基本的含义</strong>。当我们重载箭头时,可以改变的是箭头从哪个对象当中获取成员,而箭头获取成员这一事实则永远不变。</p>
<h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h2><p>如果类重载了函数调用运算符,则我们可以像使用函数一样使用该类的对象</p>
<h3 id="lambda-是函数对象"><a href="#lambda-是函数对象" class="headerlink" title="lambda 是函数对象"></a>lambda 是函数对象</h3><p>当我们编写了一个 lambda后,编译器将该表达式翻译成一个未命名类的未命名对象。在 lambda表达式产生的类中含有一个重载的函数调用运算符</p>
<h2 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h2><p>我们同样能定义对于类类型的类型转换,通过定义类型转换运算符可以做到这一点。转换构造函数和类型转换运算符共同定义了<strong>类类型转换</strong>( class-type conversions),这样的转换有时也被称作用户定义的类型转换(user- defined conversions)</p>
<h3 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h3><p>类型转换运算符( conversion operator)是类的一种特殊成员函数,它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">operator type()const;</div></pre></td></tr></table></figure></p>
<p>其中type表示某种类型。类型转换运算符可以面向任意类型(除了void之外)进行定义,只要该类型能作为函数的返回类型。因此,我们不允许转换成数组或者函数类型,但允许转换成指针(包括数组指针及函数指针)或者引用类型类型</p>
<p>转换运算符既没有显式的返回类型,也没有形参,而且必须定义成类的成员函数。类型转换运算符通常不应该改变待转换对象的内容,因此,类型转换运算符一般被定义成const成员。</p>
<p><img src="https://data2.liuin.cn/2018-03-06-15203046723464.jpg" alt=""></p>
<h3 id="避免有二义性的类型转换"><a href="#避免有二义性的类型转换" class="headerlink" title="避免有二义性的类型转换"></a>避免有二义性的类型转换</h3><p>如果类中包含一个或多个类型转换,则必须确保在类类型和目标类型之间只存在唯一一种转换方式。否则的话,我们编写的代码将很可能会具有二义性在两种情况下可能产生多重转换路径。</p>
<p>第一种情况是<strong>两个类提供相同的类型转换</strong>;例如,当A类定义了一个接受B类对象的转换构造函数,同时B类定义了一个转换目标是A类的类型转换运算符时,我们就说它们提供了相同的类型转换</p>
<p>第二种情况是<strong>类定义了多个转换规则,而这些转换涉及的类型本身可以通过其他类型转换联系在一起</strong>。最典型的例子是算术运算符,对某个给定的类来说,最好只定义最多个与算术类型有关的转换规则。</p>
<hr>
<h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="OOP：概述"><a href="#OOP：概述" class="headerlink" title="OOP：概述"></a>OOP：概述</h2><p>面向对象程序设计( object-oriented programmin)的核心思想是<strong>数据抽象、继承和动态绑定</strong>。通过使用数据抽象,我们可以将类的接口与实现分离(见第7章);使用继承,可以定义相似的类型并对其相似关系建模;使用动态绑定,可以在一定程度上忽略相似类型的区别,而以统一的方式使用它们的对象。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>通过继承( inheritance)联系在一起的类构成一种层次关系。通常在层次关系的根部有一个<strong>基类</strong>( base class),其他类则直接或间接地从基类继承而来,这些继承得到的类称为<strong>派生类</strong>( derived class)。</p>
<p>在C++语言中,基类将<strong>类型相关的函数与派生类不做改变直接继承的函数区分对待</strong>。对于某些函数,<strong>基类希望它的派生类各自定义适合自身的版本,此时基类就将这些函数声明成虚函数</strong>( virtual function)。</p>
<p>派生类必须通过使用<strong>类派生列表</strong>( class derivation list)明确指出它是从哪个(哪些)基类继承而来的。类派生列表的形式是:首先是一个冒号,后面紧跟以逗号分隔的基类列表其中每个基类前面可以有访问说明符:</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204752450638.jpg" alt=""></p>
<p>派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上 virtua1关键字,但是并不是非得这么做。</p>
<h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>通过使用动态绑定( dynamic binding),我们们能用同一段代码分别处理 Quote和Bu1k_quote的对象(Bulk_quote 继承Quote）</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204753653946.jpg" alt=""></p>
<p>因为函数 print_tota1的item形参是基类Quote的一个引用,我们既能使用基类Quote的对象调用该函数,也能使用派生类Bu1k_quote的对象调用它;</p>
<p>因为在上述过程中函数的运行版本由实参决定,即在运行时选择函数的版本,所以动态绑定有时又被称为运行时绑定(run-time binding)。</p>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><p>基类通常都应该定义一个虚析构函数,即使该函数不执行任何实际操作也是如</p>
<blockquote>
<p>成员函数与继承</p>
</blockquote>
<p>在C++语言中,基类必须将它的两种成员函数区分开来:一种是<strong>基类希望其派生类进行覆盖的函数</strong>:另一种是<strong>基类希望派生类直接继承而不要改变的函数</strong>。对于前者,基类通常将其定义为<strong>虚函数</strong>( virtual)。当我们使用指针或引用调用虚函数时,该调用将被动态绑定。根据引用或指针所绑定的对象类型不同,该调用可能执行基类的版本,也可能执行某个派生类的版本。</p>
<p>任何构造函数之外的非静态函数都可以是虚函数。关键字V1rtua1只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把个函数声明成虚函数,则该函数在派生类中隐式地也是虚函数。</p>
<p>成员函数如果没被声明为虚函数,则其解析过程发生在编译时而非运行时。</p>
<blockquote>
<p>访问控制和继承</p>
</blockquote>
<p>派生类可以继承定义在基类中的成员,但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样,派生类能访问公有成员,而不能访问私有成员。不过在某些时候基类中还有这样一种成员,基类希望它的派生类有权访问该成员,同时禁止其他用户访向。我们用受保护的( protected)访向运算符说明这样的成员。</p>
<h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><p>派生类必须通过使用类派生列表( class derivation list)明确指出它是从哪个(哪些)基类继承而来的。类派生列表的形式是:首先是一个冒号,后面紧跟以逗号分隔的基类列表,其中每个基类前面可以有以下三种访问说明符中的一个:<strong>pub1ic、 protected或者private</strong></p>
<p>派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明,因此,我们的Bulk_quote类必须包含一个 net_price成员:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Bulk_quote : <span class="keyword">public</span> Quote &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Bulk_quote() = <span class="keyword">default</span>;</div><div class="line">    Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;, <span class="keyword">double</span>, <span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">double</span>);</div><div class="line">    <span class="comment">// 覆盖基类函数</span></div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> override</span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> min_qty = <span class="number">0</span>;</div><div class="line">    <span class="keyword">double</span> discount = <span class="number">0.0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大多数类都只继承自一个类,这种形式的继承被称作“单继承”,</p>
<blockquote>
<p>派生类中的虚函数</p>
</blockquote>
<p>派生类经常(但不总是)覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数,则该虚函数的行为类似于其他的普通成员,派生类会直接继承其在基类中的版本。</p>
<p>派生类可以在它覆盖的函数前使用 virtua1关键字,但不是非得这么做。</p>
<blockquote>
<p>派生类对象及派生类向基类的类型转换</p>
</blockquote>
<p>一个派生类对象包含多个组成部分:一个含有<strong>派生类自己定义的(非静态)成员的子对象</strong>,以及一个与该派生类<strong>继承的基类对应的子对象</strong>,如果有多个基类,那么这样的子对象也有多个。</p>
<p>因为在派生类对象中含有与其基类对应的组成部分,所以我们<strong>能把派生类的对象当成基类对象来使用</strong>,而且我们也能将基类的<strong>指针或引用</strong>绑定到派生类对象中的基类部分上</p>
<p>这种转换通常称为派生类到基类的( derived-to-base)类型转换。和其他类型转换一样,编译器会隐式地执行派生类到基类的转专换</p>
<blockquote>
<p>派生类构造函数</p>
</blockquote>
<p>尽管在派生类对象中含有从基类继承而来的成员,但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样,派生类也必须使用基类的构造函数来初始化它的基类部分</p>
<p>派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段执行初始化操作的。类似于我们初始化成员的过程,派生类构造函数同样是<strong>通过构造函数初始化列表来将实参传递给基类构造函数的</strong>。</p>
<p>除非我们特别指出,否则派生类对象的基类部分会像数据成员一样执行默认初始化。如果想使用其他的基类构造函数,我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。</p>
<blockquote>
<p>派生类使用基类成员</p>
</blockquote>
<p>派生类可以访问基类的公有成员和受保护成员:</p>
<p>目前只需要了解<strong>派生类的作用域嵌套在基类的作用域之内</strong>。因此,对于派生类的一个成员来说,它使用派生类成员(例如min aty和 discount)的方式与使用基类成员(例如 price)的方式没什么不同。</p>
<blockquote>
<p>继承与静态成员</p>
</blockquote>
<p>如果基类定义了一个静态成员,则在<strong>整个继承体系中只存在该成员的唯一定义</strong>。不论从基类中派生出来多少个派生类,对于每个静态成员来说都只存在唯一的实例。</p>
<p>静态成员遵循通用的访问控制规则,如果基类中的成员是pr⊥Vate的,则派生类无权访问它。假设某静态成员是可访问的,则我们既能通过基类使用它也能通过派生类使用它</p>
<blockquote>
<p>派生类的声明</p>
</blockquote>
<p>派生类的声明与其他类差别不大(参见7.3.3节,第250页),声明中包含类名但是不包含它的派生列表:</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204772352734.jpg" alt=""></p>
<blockquote>
<p>被用作基类的类</p>
</blockquote>
<p>如果我们想将某个类用作基类,则该类必须已经定义而非仅仅声明:</p>
<p>这一规定的原因显而易见:派生类中包含并且可以使用它从基类继承而来的成员,为了使用这些成员,派生类当然要知道它们是什十么。</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204772841857.jpg" alt=""></p>
<p>在这个继承关系中,Base是D1的直接基类( direct base),同时是D2的间接基类( indirectbase)。直接基类出现在派生列表中,而间接基类由派生类通过其直接基类继承而来</p>
<p>最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。</p>
<blockquote>
<p>防止继承发生</p>
</blockquote>
<p>有时我们会定义这样一种类,我们不希望其他类继承它,或者不想考虑它是否适合作为一个基类。为了实现这一日的,C++11新标准提供了一种防止继承发生的方法,即在类名后跟一个关键字fina1:</p>
<h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>通常情况下,如果我们想把引用或指针绑定到一个对象上,则引用或指针的类型应与对象的类型一致。存在继承关系的类是一个重要的意外：<strong>我们可以把基类的指针或者应用绑定到派生类对象上</strong>。</p>
<p>可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义:当使用基类的引用(或指针)时,实际上我们并不清楚该引用(或指针)所绑定对象的真实类型。该对象可能是基类的对象,也可能是派生类的对象。</p>
<blockquote>
<p>静态类型与动态类型</p>
</blockquote>
<p>当我们使用存在继承关系的类型时,必须<strong>将一个变量或其他表达式的静态类型</strong>( statictype)与该表达式表示对象的动态类型( dynamic type)区分开来。表达式的静态类型在编译时总是已知的,它是变量声明时的类型或表达式生成的类型:动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。</p>
<p><strong>如果表达式既不是引用也不是指针,则它的动态类型永远与静态类型一致</strong>。</p>
<blockquote>
<p>不存在从基类向派生类的隐式类型转换</p>
</blockquote>
<p>之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分,而基类的引用或指针可以绑定到该基类部分上。一个基类的对象既可以以独立的形式存在,也可以作为派生类对象的一部分存在。如果基类对象不是派生类对象的一部分,则它只含有基类定义的成员,而不含有派生类定义的成员。</p>
<blockquote>
<p>对象之间不存在转换</p>
</blockquote>
<p>派生类向基类的自动类型转换只对指针或引用类型有效,在派生类类型和基类类型之间不存在这样的转换。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><blockquote>
<p>对虚函数的调用可能在运行时才被解析</p>
</blockquote>
<p>当某个虚函数通过指针或引用调用时,编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个</p>
<p>必须要搞清楚的一点是,动态绑定只有当我们通过指针或引用调用虚函数时才会发生。当我们通过一个具有普通类型(非引用非指针)的表达式调用虚函数时,在编译时就会将调用的版本确定下来。</p>
<blockquote>
<p>派生类中的虚函数</p>
</blockquote>
<p>当我们在派生类中覆盖了某个虚函数时,可以再一次使用 virtua1关键字指出该函数的性质。然而这么做并非必须,因为<strong>一旦某个函数被声明成虚函数,则在所有派生类中它都是虚函数</strong>。</p>
<p>一个派生类的函数如果覆盖了某个继承而来的虚函数,则它的形参类型必须与被它覆盖的基类函数完全一致。</p>
<blockquote>
<p>final 和 override说明符</p>
</blockquote>
<p>派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同,这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时,派生类的函数并没有覆盖掉基类中的版本。就实际的编程习惯而言,这种声明往主往意味着发生了错误,因为我们可能原本希望派生类能覆盖掉基类中的虚函数,但是一不小心把形参列表弄错了。</p>
<p>在C++11新标准中我们可以使用override关键字来说明派生类中的虚函数。这么做的好处是在使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误,后者在编程实践中显得更加重要。</p>
<p>我们还能把某个函数指定为fina1,如果我们已经把函数定义成fina1了,则之后任何尝试覆盖该函数的操作都将引发错误</p>
<p>同一个函数可以同时添加final和override说明符；</p>
<blockquote>
<p>虚函数和默认实参</p>
</blockquote>
<p>和其他函数一样,虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参,则该实参值由本次调用的静态类型决定。</p>
<p>换句话说,如果我们通过基类的引用或指针调用函数,则使用基类中定义的默认实参,即使实际运行的是派生类中的函数版本也是如此匕。此时,传入派生类函数的将是基类函数定义的默认实参。</p>
<blockquote>
<p>回避虚函数的机制</p>
</blockquote>
<p>在某些情况下,我们希望对虚函数的调用不要进行动态绑定,而是强迫其执行虚函数的某个特定版本。</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204936697970.jpg" alt=""></p>
<p>什么时候我们需要回避虚函数的默认机制呢?通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。</p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><blockquote>
<p>纯虚函数</p>
</blockquote>
<p>当我们不想让用户从一个类中创建一个对象时，我们可以使用纯虚函数。</p>
<p>和普通的虚函数不一样,一个纯虚函数无须定义。我们通过在函数体的位置(即在声明语句的分号之前)书写=0就可以将一个虚函数说明为纯虚函数。其中,=0只能出现在类内部的虚函数声明语句处</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 用于保存折扣值和购买量的类</span></div><div class="line"><span class="keyword">class</span> Disc_quote</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Disc_quote() = <span class="keyword">default</span>;</div><div class="line">	Disc_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price, </div><div class="line">		<span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> dsc) :</div><div class="line">			Quote(book, price), quantity(qty), discount(disc) &#123; &#125;;</div><div class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> quantity = <span class="number">0</span>;</div><div class="line">	<span class="keyword">double</span> discount = <span class="number">0.0</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>含有纯虚函数的类是抽象基类</p>
</blockquote>
<p>含有(或者未经覆盖直接继承)纯虚函数的类是抽象基类( abstract base class)。<strong>抽象基类负责定义接口,而后续的其他类可以覆盖该接口。我们不能(直接)创建一个抽象基类的对象</strong>。</p>
<blockquote>
<p>重构</p>
</blockquote>
<p>重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。对于面向对象的应用程序来说,重构是一种很普遍的现象。</p>
<h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><blockquote>
<p>受保护成员</p>
</blockquote>
<p>一个类使用 protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。 </p>
<blockquote>
<p>公有、私有和受保护继承</p>
</blockquote>
<p>某个类对其继承而来的成员的访问权限受到两个因素影响:一是在<strong>基类中该成员的访问说明符</strong>,二是在<strong>派生类的派生列表中的访问说明符</strong>。</p>
<p>派生访问说明符对于派生类的成员(及友元)能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关。 </p>
<p>派生访问说明符的目的是<strong>控制派生类用户(包括派生类的派生类在内)对于基类成员的访问权限</strong>:</p>
<p>假设我们之前还定义了一个名为 Prot_derv的类,它采用受保护继承,则Base的所有公有成员在新定义的类中都是受保护的。 Prot_Derv的用户不能访间 pub_mem,但是 Prot_derv的成员和友元可以访问那些继承而来的成员</p>
<blockquote>
<p>友元和继承</p>
</blockquote>
<p>就像友元关系不能传递一样,友元关系同样也不能继承。<strong>基类的友元在访问派生类成员时不具有特殊性</strong></p>
<p>当一个类将另一个类声明为友元时,这种友元关系只对做出声明的类有效。对于原来那个类来说,其友元的基类或者派生类不具有特殊的访问能力</p>
<blockquote>
<p>改变个别成员的可访问性</p>
</blockquote>
<p>有时我们需要改变派生类继承的某个名字的访问级别,通过使用 using声明。</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15205140838880.jpg" alt=""></p>
<p>因为 Derived使用了私有继承,所以继承而来的成员s1ze和n(在默认情况下)是Derived的私有成员。然而,我们使用us1ng声明语句改变了这些成员的可访问性。改变之后, Derived的用户将可以使用size成员,而 Derived的派生类将能使用n</p>
<blockquote>
<p>默认的继承保护级别</p>
</blockquote>
<p>我们曾经介绍过使用 struct和c1asS关键字定义的类具有不同的默认访问说明符。类似的,默认派生运算符也由定义派生类所用的关键字来决定默认情况下,<strong>使用c1ass关键字定义的派生类是私有继承的;而使用 struct关键字定义的派生类是公有继承的:</strong></p>
<p>两者的差别只有这一个。</p>
<h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><p>每个类定义自己的作用域,在这个作用域内我们定义类的成员。当存在继承关系时,<strong>派生类的作用域嵌套在其基类的作用域之内</strong>。如果一个名字在派生类的作用域内无法正确解析,则编译器将继续在外层的基类作用域中寻找该名字的定义</p>
<blockquote>
<p>在编译时进行名字查找</p>
</blockquote>
<p>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致(当使用基类的引用或指针时会发生这种情况),但是我们能使用哪些成员仍然是由静态类型决定的。</p>
<blockquote>
<p>名字冲突和继承</p>
</blockquote>
<p>和其他作用域一样,派生类也能重用定义在其直接基类或间接基类中的名字,此时<strong>定义在内层作用域(即派生类)的名字将隐藏定义在外层作用域(即基类)的名字</strong></p>
<blockquote>
<p>通过作用域运算符来使用隐藏的成员</p>
</blockquote>
<p>我们可以通过作用域运算符来使用一个被隐藏的基类成员:</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15205150138642.jpg" alt=""></p>
<p>作用域运算符将覆盖掉原有的査找规则,并指示编译器从BaSe类的作用域开始査找mem</p>
<blockquote>
<p>一如既往，名字查找先于类型检查</p>
</blockquote>
<p>如前所述,<strong>声明在内层作用域的函数并不会重载声明在外层作用域的函数</strong>。因此,定义派生类中的函数也不会重载其基类中的成员。和其他作用域样,如果派生类(即内层作用域)的成员与基类(即外层作用域)的某个成员同名,则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致,基类成员也仍然会被隐藏掉</p>
<blockquote>
<p>虚函数与作用域</p>
</blockquote>
<p>我们现在可以理解为什么基类与派生类中的虚函数必须有相同的形参列表了。<strong>假如基类与派生类的虚函数接受的实参不同,则我们就无法通过基类的引用或指针调用派生类的虚函数了</strong>。例如:</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15205151324990.jpg" alt=""></p>
<blockquote>
<p>覆盖重载的函数</p>
</blockquote>
<p>如果派生类希望所有的重载版本对于它来说都是可见的,那么它就需要覆盖所有的版本,或者一个也不覆盖。有时一个类仅需覆盖重载集合中的一些而非全部函数</p>
<h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>继承关系对基类拷贝控制最直接的影响是<strong>基类通常应该定义一个虚析构函数</strong>,这样我们就能动态分配继承体系中的对象了。如前所述,当我们de1ete一个动态分配的对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型,则有可能出现指针的静态类型与被删除对象的动态类型不符的情况</p>
<p>我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本:</p>
<p>和其他虚函数一样,析构函数的虚属性也会被继承。</p>
<p><strong>如果一个类需要析构函数,那么它也同样需要拷贝和赋值操作。基类的析构函数并不遵循上述准则</strong>,它是个重要的例外。一个基类总是需要析构函数,而且它能将析构函数设定为虚函数。</p>
<blockquote>
<p>虚析构函数将阻止合成移动操作</p>
</blockquote>
<p>基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响:如果一个类定义了析构函数,即使它通过= defau1t的形式使用了合成的版本,编译器也不会为这个类合成移动操作</p>
<h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><p>基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似:它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外,这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。</p>
<ul>
<li>合成的Bu1k_quote默认构造函数运行 Disc_quote的默认构造函数,后者又运行 Quote的默认构造函数。</li>
</ul>
<p>无论基类成员是合成的版本(如ρuote继承体系的例子)还是自定义的版本都没有太大影响。唯一的要求是相应的成员应该可访问并且不是一个被删除的函数。</p>
<blockquote>
<p>派生类中的删除的拷贝控制与基类的关系</p>
</blockquote>
<p>基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员定义成被删除的函数</p>
<ul>
<li>·如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问,则派生类中对应的成员将是被删除的,原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作</li>
<li>·如果在基类中有一个不可访问或删除掉的析构函数,则派生类中合成的默认和拷贝构造函数将是被删除的,因为编译器无法销毁派生类对象的基类部分。</li>
</ul>
<blockquote>
<p>移动操作与继承</p>
</blockquote>
<p>大多数基类都会定义一个虚析构函数。因此在默认情况下,基类通常不含有合成的移动操作,而且在它的派生类中也没有合成的移动操作。</p>
<h3 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h3><p>派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员,还负责初始化派生类对象的基类部分。因此,派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时,也要拷贝和移动基类部分的成员。类似的,派生类赋值运算符也必须为其基类部分的成员赋值。</p>
<blockquote>
<p>定义派生类的拷贝和移动构造函数</p>
</blockquote>
<p>当为派生类定义拷贝或移动构造函数时,我们通常使用对应的基类构造函数初始化对象的基类部分</p>
<p><img src="https://data2.liuin.cn/2018-03-09-15205965427434.jpg" alt=""></p>
<blockquote>
<p>派生类赋值运算符</p>
</blockquote>
<p>与拷贝和移动构造函数一样,派生类的赋值运算符也必须显式地为其基类部分赋值:</p>
<p>值得注意的是,无论基类的构造函数或赋值运算符是自定义的版本还是合成的版本,派生类的对应操作都能使用它们。</p>
<blockquote>
<p>派生类析构函数</p>
</blockquote>
<p>在析构函数体执行完成后,对象的成员会被隐式销毁。类似的,对象的基类部分也是隐式销毁的。因此,和构造函数及赋值运算符不同的是,派生类析构函数只负责销毁由派生类自己分配的资源:</p>
<p>对象销毁的顺序正好与其创建的顺序相反:派生类析构函数首先执行,然后是基类的析构函数,以此类推,沿着继承体系的反方向直至最后。</p>
<blockquote>
<p>在构造函数和析构函数中调用虚函数</p>
</blockquote>
<p>派生类对象的基类部分将首先被构建。当执行基类的构造函数时,该对象的派生类部分是未被初始化的状态。类似的,销毁派生类对象的次序正好相反,因此当执行基类的析构函数时,派生类部分已经被销毁掉了。</p>
<p>为了能够正确地处理这种未完成状态,编译器认为对象的类型在构造或析构的过程中仿佛发生了改变一样。也就是说,<strong>当我们构建一个对象时,需要把对象的类和构造函数的类看作是同一个;对虚函数的调用绑定正好符合这种把对象的类和构造函数的类看成同一个的要求;对于析构函数也是同样的道理。</strong></p>
<h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><p>在C++11新标准中,派生类能够重用其直接基类定义的构造函数。尽管如我们所知,这些构造函数并非以常规的方式继承而来,但是为了方便,我们不妨姑且称其为“继承”的。一个类只初始化它的直接基类,出于同样的原因,一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数,则编译器将为派生类合成它们。</p>
<p>派生类继承基类构造函数的方式是提供一条注明了(直接)基类名的uS1ng声明语句。举个例子,我们可以重新定义Bu1k_quote类,令其继承Disc_quote类的构造函数:</p>
<p><img src="https://data2.liuin.cn/2018-03-09-15205968035260.jpg" alt=""></p>
<blockquote>
<p>继承的构造函数的特点</p>
</blockquote>
<p>和普通成员的 using声明不一样构造函数的 using声明不会改变该构造函数的访问级别。</p>
<h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><p>当我们使用容器存放继承体系中的对象时,通常必须采取间接存储的方式。因为不允许在容器中保存不同类型的元素,所以我们不能把具有继承关系的多种类型的对象直接在放在容器当中。</p>
<blockquote>
<p>在容器中放置（智能）指针而非对象</p>
</blockquote>
<p>当我们希望在容器中存放具有继承关系的对象时,我们实际上存放的通常是基类的指针(更好的选择是智能指针。和往常一样,这些指针所指对象的动态类型可能是基类类型,也可能是派生类类型</p>
<h3 id="编写Basket类"><a href="#编写Basket类" class="headerlink" title="编写Basket类"></a>编写Basket类</h3><p>对于C++面向对象的编程来说,一个悖论是我们无法直接使用对象进行面向对象编程。相反,我们必须使用指针和引用。因为指针会增加程序的复杂性,所以我们经常定义一些辅助的类来处理这种复杂情况。</p>
<hr>
<h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><p>面向对象编程(OOP)和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于:OOP能处理类型在程序运行之前都未知的情况;而在泛型编程中,在编译时就能获知类型了。</p>
<p>模板是C++中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。</p>
<h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>我们可以定义一个通用的函数模板( function template),而不是为每个类型都定义一个新函数。一个函数模板就是一个公式,可用来生成针对特定类型的函数版本。 compare的模板版本可能像下面这样</p>
<p><img src="https://data2.liuin.cn/2018-03-10-15206810494191.jpg" alt=""></p>
<p>模板定义以关键字 template开始,后跟一个模板参数列表( template parameter list.,这是一个逗号分隔的一个或多个模板参数( template parameter)的列表,用小于号(&lt;)和大于号(&gt;)包围起来。<strong>在模板定义中，模板参数列表不能为空</strong>。</p>
<p>模板参数表示在类或函数定义中用到的类型或值。当使用模板时,我们(隐式地或显式地)指定模板实参( template argument),将其绑定到模板参数上。</p>
<blockquote>
<p>实例化函数模板</p>
</blockquote>
<p>当我们调用一个函数模板时!,<strong>编译器(通常)用函数实参来为我们推断模板实参</strong>。</p>
<p>编译器用推断出的模板参数来为我们实例化( instantiate)一个特定版本的函数。当编译器实例化一个模板时,它使用实际的模板实参代替对应的模板参数来创建出模板的一个新“实例”。</p>
<blockquote>
<p>模板类型参数</p>
</blockquote>
<p>我们的 compare函数有一个模板<strong>类型参数</strong>( type parameter.)。一般来说,我们可以<strong>将类型参数看作类型说明符</strong>,就像内置类型或类类型说明符一样使用。特别是,类型参数可以用来指定返回类型或函数的参数类型,以及在函数体内用于变量声明或类型转换</p>
<p><img src="https://data2.liuin.cn/2018-03-10-15206812431993.jpg" alt=""></p>
<blockquote>
<p>非类型模板参数</p>
</blockquote>
<p>除了定义类型参数,还可以在模板中定义非类型参数( nontype parameter)。<strong>一个非类型参数表示一个值而非一个类型</strong>。我通过一个特定的类型名而非关键字c1ass或typename来指定非类型参数。</p>
<p>当一个模板被实例化时,非类型参数被一个用户提供的或编译器推断出的值所代替。</p>
<blockquote>
<p>inline 和constexpr 的函数模板</p>
</blockquote>
<p>函数模板可以声明为in1ine或 constexpr的,如同非模板函数一样。in1ine或constexpr说明符放在模板参数列表之后,返回类型之前:</p>
<blockquote>
<p>编写类型无关的代码</p>
</blockquote>
<p>我们最初的 compare函数虽然简单,但它说明了编写泛型代码的两个重要原则:</p>
<ul>
<li>模板中的函数参数是 const的引用</li>
<li>函数体中的条件判断仅使用&lt;比较运算</li>
</ul>
<p>通过将函数参数设定为 const的引用,我们保证了函数可以用于不能拷贝的类型。</p>
<p>如果编写代码时只使用&lt;运算符,我们就降低了 compare函数对要处理的类型的要求。这些类型必须支持&lt;,但不必同时支持&gt;。</p>
<blockquote>
<p>模板编译</p>
</blockquote>
<p>当编译器遇到一个模板定义时,它并不生成代码。<strong>只有当我们实例化出模板的一个特定版本时,编译器才会生成代码</strong>。当我们使用(而不是定义)模板时,编译器才生成代码特性影响了我们如何组织代码以及错误何时被检测到。</p>
<p>为了生成一个实例化版本,编译器需要掌握函数模板或类模板成员函数的定义。因此,与非模板代码不同,模板的头文件通常既包括声明也包括定义。</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板( class template)是用来生成类的蓝图的。与函数模板的不同之处是,<strong>编译器不能为类模板推断模板参数类型</strong>。如我们已经多次看到的,<strong>为了使用类模板,我们必须在模板名后的尖括号中提供额外信息</strong>——用来代替模板参数的模板实参列表。</p>
<blockquote>
<p>定义类模板</p>
</blockquote>
<p>类似函数模板,类模板以关键字 template开始,后跟模板参数列表。在类模板(及其成员)的定义中,我们将模板参数当作替身,代替使用模板时用户需要提供的类型或值:</p>
<p><img src="https://data2.liuin.cn/2018-03-10-15206822514896.jpg" alt=""></p>
<blockquote>
<p>实例化类模板</p>
</blockquote>
<p>当使用一个类模板时,我们必须提供额外信息。我们现在知道这些额外信息是显式模板实参( explicit template argument)列表,它们被绑定到模板参数。编译器使用这些模板实参来实例化出特定的类。</p>
<blockquote>
<p>在模板作用域中引用模板类型</p>
</blockquote>
<p>为了阅读模板类代码,应该记住类<strong>模板的名字不是一个类型名</strong>。类模板用来实例化类型,而一个实例化的类型总是包含模板参数的可能令人迷惑的是,<strong>一个类模板中的代码如果使用了另外一个模板,通常不将一个实际类型(或值)的名字用作其模板实参。相反的,我们通常将模板自己的参数当作被使用模板的实参</strong>。</p>
<p>例如,我们的data成员使用了两个模板, vector和 shared_ptr。我们知道,无论何时使用模板都必须提供模板实参。在本例中,我们提供的模板实参就是Bob的模板参数。因此,data的定义如下</p>
<p><img src="https://data2.liuin.cn/2018-03-10-15206823729019.jpg" alt=""></p>
<blockquote>
<p>类模板的成员函数</p>
</blockquote>
<p>与其他任何类相同,我们既可以在类模板内部,也可以在类模板外部为其定义成员函数,且<strong>定义在类模板内的成员函数被隐式声明为内联函数</strong>。</p>
<p>类模板的成员函数本身是一个普通函数。但是,类模板的每个实例都有其自己版本的成员函数。因此,类模板的成员函数具有和模板相同的模板参数。因而,定义在类模板之外的成员函数就必须以关键字temp1ate开始,后接类模板参数列表。</p>
<p>当我们在类外定义一个成员时,必须说明成员属于哪个类。而且,<strong>从一个模板生成的类的名字中必须包含其模板实参</strong>。</p>
<blockquote>
<p>类模板成员函数的实例化</p>
</blockquote>
<p>默认情况下,一个类模板的成员函数只有当程序用到它时才进行实例化。</p>
<p>如果一个成员函数没有被使用,则它不会被实例化。成员函数只有在被用到时才进行实例化,这一特性使得即使某种类型不能完全符合模板操作的要求。</p>
<blockquote>
<p>在类代码内简化模板类名的使用</p>
</blockquote>
<p>当我们使用一个类模板类型时必须提供模板实参,但这一规则有一个例外。<strong>在类模板自己的作用域中,我们可以直接使用模板名而不提供实参</strong></p>
<blockquote>
<p>在类模板外使用类模板名</p>
</blockquote>
<p>当我们在类模板外定义其成员时,必须记住,我们并不在类的作用域中,直到遇到类名才表示进入类的作用域(参见</p>
<blockquote>
<p>模板类和友元</p>
</blockquote>
<p>当一个类包含一个友元声明时,类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板友元,则友元被授权可以访问所有模板实例。如果友元自身是模板,类可以授权给所有友元模板实例,也可以只授权给特定实例</p>
<blockquote>
<p>一对一友好关系</p>
</blockquote>
<p><strong>类模板与另一个(类或函数)模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-03-10-15206826958070.jpg" alt=""></p>
<blockquote>
<p>通用和特定的友好关系</p>
</blockquote>
<p>一个类也可以将另一个模板的每个实例都声明为自己的友元,或者限定特定的实例为友元</p>
<p>为了让所有实例成为友元,友元声明中必须使用与类模板本身不同的模板参数</p>
<blockquote>
<p>模板类型别名</p>
</blockquote>
<p>类模板的一个实例定义了一个类类型,与任何其他类类型一样,我们可以定义一个typedef来引用实例化的类:</p>
<p><code>typedef Blob&lt;string&gt; StrBlob;</code></p>
<blockquote>
<p>类模板的static成员</p>
</blockquote>
<p>与任何其他 static数据成员相同,模板类的每个 static数据成员必须有且仅有个定义。但是,类模板的每个实例都有一个独有的 static对象。因此,与定义模板的成员函数类似,我们将 static数据成员也定义为模板</p>
<p>与非模板类的静态成员相同,我们可以通过类类型对象来访问一个类模板的 statio成员,也可以使用作用域运算符直接访问成员。当然,为了通过类来直接访问 static成员,我们必须引用一个特定的实例</p>
<h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><p>类似函数参数的名字,一个模板参数的名字也没有什么内在含义。我们通常将类型参数命名为T,但实际上我们们可以使用任何名字:</p>
<blockquote>
<p>模板参数与作用域</p>
</blockquote>
<p>模板参数遵循普通的作用域规则。<strong>一个模板参数名的可用范围是在其声明之后,至模板声明或定义结束之前</strong>。与任何其他名字一样,模板参数会隐藏外层作用域中声明的相同名字。</p>
<blockquote>
<p>模板声明</p>
</blockquote>
<p>模板声明必须包含模板参数，一个给定模板的每个声明和定义必须有相同数量和种类(即,类型或非类型)的参数。</p>
<blockquote>
<p>使用类的类型成员</p>
</blockquote>
<p>假定T是一个模板类型参数,当编译器遇到类似里T::mem这样的代码时,它不会知道mem是一个类型成员还是一个 static数据成员,直至实例化时才会知道。但是,为了处理模板,编译器必须知道名字是否表示一个类型。</p>
<p>默认情况下,<strong>C++语言假定通过作用域运算符访问的名字不是类型</strong>。因此,如果我们希望使用一个模板类型参数的类型成员,就必须显式告诉编译器该名字是一个类型。</p>
<blockquote>
<p>默认模板实参</p>
</blockquote>
<p>就像我们能为函数参数提供默认实参一样,我们也可以提供默认模板实参( default template argument)。</p>
<blockquote>
<p>模板默认实参与类模板</p>
</blockquote>
<p>无论何时使用一个类模板,我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。特别是,如果一个类模板为其所有模板参数都提供了默认实参,且我们希望使用这些默认实参,就必须在模板名之后跟一个空尖括号对:</p>
<h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><p>一个类(无论是普通类还是类模板)可以包含本身是模板的成员函数。这种成员被称为成员模板( member template)。成员模板不能是虚函数。</p>
<blockquote>
<p>普通（非模板）类的成员模板</p>
</blockquote>
<p><img src="https://data2.liuin.cn/2018-03-12-15208165159357.jpg" alt=""></p>
<blockquote>
<p>类模板的成员模板</p>
</blockquote>
<p>对于类模板,我们也可以为其定义成员模板。在此情况下,类和成员各自有自己的、独立的模板参数。</p>
<p>与类模板的普通函数成员不同,成员模板是函数模板。当我们在类模板外定义一个成员模板时,必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前,后跟成员自己的模板参数列表:</p>
<blockquote>
<p>实例化与成员模板</p>
</blockquote>
<p>为了实例化一个类模板的成员模板,我们必须同时提供类和函数模板的实参。与往常样,我们在哪个对象上调用成员模板,编译器就根据该对象的类型来推断类模板参数的实参。</p>
<h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><p>当模板被使用时才会进行实例化这一特性意味着,<strong>相同的实例可能出现在多个对象文件中</strong>。当两个或多个独立编译的源文件使用了相同的模板并提供了相同的模板参数时,每个文件中就都会有该模板的一个实例。</p>
<p>在大系统中,在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中,我们可以通过显式实例化( explicit instantiation)来避免这种开销。一个显式实例化有如下：</p>
<p><img src="https://data2.liuin.cn/2018-03-12-15208167547457.jpg" alt=""></p>
<p>当编译器遇到 extern模板声明时,它不会在本文件中生成实例化代码。将一个实例化声明为 extern就表示承诺在程序其他位置有该实例化的一个非 extern声明(定义)。</p>
<blockquote>
<p>实例化定义会实例化所有成员</p>
</blockquote>
<p><strong>一个类模板的实例化定义会实例化该模板的所有成员,包括内联的成员函数</strong>。当编译器遇到一个实例化定义时,它不了解程序使用哪些成员函数。因此,与处理类模板的普通实例化不同,编译器会实例化该类的所有成员。即使我们不使用某个成员,它也会被实例化。因此,我们用来显式实例化一个类模板的类型,必须能用于模板的所有成员</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》笔记 类设计者的工具部分&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C/C++" scheme="https://www.liuin.cn/tags/C-C/"/>
    
  </entry>
  
</feed>
