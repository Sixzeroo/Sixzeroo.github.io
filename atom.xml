<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sixzeroo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.liuin.cn/"/>
  <updated>2018-05-20T02:52:44.000Z</updated>
  <id>https://www.liuin.cn/</id>
  
  <author>
    <name>Sixzeroo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《STL源码剖析》 笔记</title>
    <link href="https://www.liuin.cn/2018/05/20/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B-%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.liuin.cn/2018/05/20/《STL源码剖析》-笔记/</id>
    <published>2018-05-20T00:52:59.000Z</published>
    <updated>2018-05-20T02:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>侯捷老师的《STL源码剖析》可谓是学习STL的经典。在书籍的自序中侯捷老师提到的”我的确认为99.99%的程序员所写的程序，在SGI STL面前都是三流水平“，这让我等菜鸟更本把持不住呀。</p>
<a id="more"></a>
<h1 id="迭代器概念与traits编程技法"><a href="#迭代器概念与traits编程技法" class="headerlink" title="迭代器概念与traits编程技法"></a>迭代器概念与traits编程技法</h1><p>在设计模式中有一种迭代器模式，其定义如下：提供一种方法,使之能够依序巡访某个聚合物(容器)所含的各个元素,而又无需暴露该聚合物的内部表述方式</p>
<h2 id="迭代器设计思维——STL关键所在"><a href="#迭代器设计思维——STL关键所在" class="headerlink" title="迭代器设计思维——STL关键所在"></a>迭代器设计思维——STL关键所在</h2><p>STL的中心思想在于:将数据容器( containers)和算法 algorithms)分开,彼此独立设计,最后再以一帖胶着剂将它们撮合在一起。容器和算法的泛型化,从技术角度来看并不困难,C++的class templates和 function templates可分别达成目标。如何设计出两者之间的良好胶着剂,才是大难题</p>
<h2 id="迭代器是一种smart-pointer"><a href="#迭代器是一种smart-pointer" class="headerlink" title="迭代器是一种smart pointer"></a>迭代器是一种smart pointer</h2><p>迭代器是一种行为类似指针的对象,而指针的各种行为中最常见也最重要的便是内容提领(dereference)和成员访问( member access),因此,迭代器最重要的编程工作就是对 operator*和 operator-&gt;进行重载( overloading)工作。</p>
<p>在设计实现每一个容器的迭代器的时候都会暴露许多这些容器的一些实现细节的东西，要设计出 LIstitem,首先必须对List的实现细节有非常丰富的了解。既然这无可避免,干脆就把迭代器的开发工作交给List的设计者好了,如此一来,所有实现细节反而得以封装起来不被使用者看到。<strong>这正是为什么每一种STL容器都提供有专属迭代器的缘故</strong></p>
<h2 id="迭代器相应的型别"><a href="#迭代器相应的型别" class="headerlink" title="迭代器相应的型别"></a>迭代器相应的型别</h2><p>迭代器中相应的型别之一是迭代器所指之物的型别</p>
<p>迭代器相应型别(associated types)不只是“迭代器所指对象的型别”一种而已。根据经验,最常用的相应型别有五种,然而并非任何情况下任何一种都可利用上述的 template参数推导机制来取得.我们需要更全面的解法</p>
<h1 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h1><h2 id="容器的概观与分类"><a href="#容器的概观与分类" class="headerlink" title="容器的概观与分类"></a>容器的概观与分类</h2><p>研究数据的特定排列方式,以利于搜寻或排序或其它特殊目的,这一专门学科我们称为数据结构( Data Structures)。大学信息类相关教育里面,与编程最有直接关系的科目,首推数据结构与算法( Algorithms)。几乎可以说,任何特定的数据结构都是为了实现某种特定的算法。STL容器即是将运用最广的一些数据结构实现出来</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267795512022.jpg" alt=""></p>
<blockquote>
<p>序列式容器</p>
</blockquote>
<p>所谓序列式容器,其中的<strong>元素都可序( ordered),但未必有序( sorted)</strong>。C++语言本身提供了一个序列式容器 array,STL另外再提供 vector, list, deque, stack, queue, priority-queue等等序列式容器。其中 stack和 queue由于只是将 deque改头换面而成,技术上被归类为一种配接器( adapter)</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="vector-概述"><a href="#vector-概述" class="headerlink" title="vector 概述"></a>vector 概述</h3><p>vector的数据安排以及操作方式,与 array非常相似。两者的唯一差别在于空间的运用的灵活性。 array是静态空间,一旦配置了就不能改变，如果需要更多的空间需要用户自己解决。vector是动态空间,随着元素的加人,它的内部机制会自行扩充空间以容纳新元素。因此, vector的运用对于内存的合理利用与运用的灵活性有很大的帮助,我们再也不必因为害怕空间不足而开始就要求一个大块头 array了,我们可以安心使用 vector,吃多少用多少</p>
<h3 id="vector-迭代器"><a href="#vector-迭代器" class="headerlink" title="vector 迭代器"></a>vector 迭代器</h3><p>vector维护的是一个连续线性空间,所以不论其元素型别为何,<strong>普通指针都可以作为 vector的迭代器而满足所有必要条件</strong>,因为 vector迭代器所需要的操作行为普通指针天生就具备。 vector支持随机存取,而普通指针正有着这样的能力。所以, vector提供的是 Random Access Iterators。</p>
<h3 id="vector-的数据结构"><a href="#vector-的数据结构" class="headerlink" title="vector 的数据结构"></a>vector 的数据结构</h3><p>vector所采用的数据结构非常简单:线性连续空间。它以两个迭代器 start和 finish分别指向配置得来的连续空间中目前已被使用的范围,并以迭代器end_of_storage指向整块连续空间(含备用空间)的尾端</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc = alloc&gt;</div><div class="line"><span class="keyword">class</span> <span class="built_in">vector</span>&#123;</div><div class="line">...</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    iterator start;</div><div class="line">    iterator finish;</div><div class="line">    iterator end_of_storage;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了降低空间配置时的速度成本, vector实际配置的大小可能比客户端需求量更大一些,以备将来可能的扩充。这便是容量( capacity)的观念。换句话说个 vector的容量永远大于或等于其大小。一旦容量等于大小,便是满载,下次再有新增元素,整个 vector就得另觅居所</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267802557974.jpg" alt=""></p>
<h3 id="vector-的构造和内存管理"><a href="#vector-的构造和内存管理" class="headerlink" title="vector 的构造和内存管理"></a>vector 的构造和内存管理</h3><p>当我们以 push_back()将新元素插入于 vector尾端时,该函数首先检查是否还有备用空间,如果有就直接在备用空间上构造元素,并调整迭代器 finish,使vector变大。如果没有备用空间了,就扩充空间(重新配置、移动数据、释放原空间)</p>
<p>注意,所谓动态增加大小,并不是在原空间之后接续新空间(因为无法保证原空间之后尚有可供配置的空间),而是以原大小的两倍另外配置一块较大空间,然后将原内容拷贝过来,然后才开始在原内容之后构造新元素,并释放原空间。因此对 vector的任何操作,<strong>一旦引起空间重新配置,指向原 vector的所有迭代器就都失效了</strong>。这是程序员易犯的一个错误,务需小心</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="list-概述"><a href="#list-概述" class="headerlink" title="list 概述"></a>list 概述</h3><p>相较于vector的连续线性空间,list就显得复杂许多,它的好处是每次插人或删除一个元素,就配置或释放一个元素空间。因此,list对于空间的运用有绝对的精准,一点也不浪费。而且,对于任何位置的元素插入或元素移除,list永远是常数时间。</p>
<p>list和 vector是两个最常被使用的容器。什么时机下最适合使用哪一种容器,必须视元素的多寡、元素的构造复杂度、元素存取行为的特性而定。</p>
<h3 id="list的节点-node"><a href="#list的节点-node" class="headerlink" title="list的节点(node)"></a>list的节点(node)</h3><p>list的节点是一个典型的双向链表的结构</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267809077014.jpg" alt=""></p>
<h3 id="list的迭代器"><a href="#list的迭代器" class="headerlink" title="list的迭代器"></a>list的迭代器</h3><p>list不再能够像vector一样以普通指针作为迭代器,因为其节点不保证在储存空间中连续存在。list迭代器必须有能力指向list的节点,并有能力进行正确的递增、递减、取值、成员存取等操作。</p>
<p>由于STL list是一个双向链表(double linked-ist),迭代器必须具备前移后移的能力,所以list提供的是 Bidirectional iteratorslist</p>
<p>有一个重要性质:插入操作( insert)和接合操作( splice)都不会造成原有的list迭代器失效。这在 vector是不成立的,因为 vector的插人操作可能造成内存的重新配置,导致原有的迭代器全部失效。甚至list的元素删除操作( erase),也只有“指向被删除元素”的那个迭代器失效,其它迭代器不受任何影响</p>
<h3 id="list的数据结构"><a href="#list的数据结构" class="headerlink" title="list的数据结构"></a>list的数据结构</h3><p>SGL list不仅是一个双向链表,而且还是一个环状双向链表。所以它只需要个指针,便可以完整表现整个链表</p>
<p>如果让指针node指向刻意置于尾端的一个空白节点,node便能符合STL对于“前闭后开”区间的要求,成为1ast迭代器,如图所示</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267812961833.jpg" alt=""></p>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><h3 id="deque概述"><a href="#deque概述" class="headerlink" title="deque概述"></a>deque概述</h3><p>vector是单向开口的连续线性空间, deque则是一种双向开口的连续线性空间。所谓双向开口,意思是<strong>可以在头尾两端分别做元素的插入和删除操作</strong>。 vector当然也可以在头尾两端进行操作(从技术观点),但是其头部操作效率奇差,无法被接受</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267815267741.jpg" alt=""></p>
<p>deque和 vector的最大差异,一在于deque允许于常数时间内对起头端进行元素的插入或移除操作,二在于 deque没有所谓容量( capacity)观念,因为它是动态地以分段连续空间组合而成,随时可以增加一段新的空间并链接起来。换句话说,像 vector那样“因旧空间不足而重新配置一块更大空间,然后复制元素,再释放旧空间”这样的事情在 deque是不会发生的。也因此, deque没有必要提供所谓的空间保留( reserve)功能</p>
<p>虽然 deque也提供 Ramdon Access iterator,但<strong>它的迭代器并不是普通指针,其复杂度和 vector不可以道里计</strong>(稍后看到源代码,你便知道),这当然影响了各个运算层面。因此,除非必要,我们应尽可能选择使用 vector而非 deque</p>
<h3 id="deque的中控器"><a href="#deque的中控器" class="headerlink" title="deque的中控器"></a>deque的中控器</h3><p>deque是连续空间(至少逻辑上看来如此),连续线性空间总令我们联想到array或 vector。 array无法成长, vector虽可成长,却只能向尾端成长,而且其所谓成长原是个假象,事实上是(1)另觅更大空间;(2)将原数据复制过去;(3)释放原空间三部曲。如果不是 <strong>vector每次配置新空间时都有留下一些余裕,其成长”假象所带来的代价将是相当高昂</strong></p>
<p>deque系由一段一段的定量连续空间构成。一旦有必要在 deque的前端或尾端增加新空间,便配置一段定量连续空间,串接在整个 deque的头端或尾端deque的最大任务,便是在这些分段的定量连续空间上,维护其整体连续的假象并提供随机存取的接口·避开了“重新配置、复制、释放”的轮回,<strong>代价则是复杂的迭代器架构</strong></p>
<p>受到分段连续线性空间的字面影响,我们可能以为 deque的实现复杂度和vector相比虽不中亦不远矣,其实不然。主要因为,既日<strong>分段连续线性空间,就必须有中央控制,而为了维持整体连续的假象,数据结构的设计及迭代器前进后退等操作都颇为繁琐</strong>。 deque的实现代码分量远比 vector或list都多得多</p>
<p>deque采用一块所谓的mqp(注意,不是STL的map容器)作为主控。这里所谓map是一小块连续空间,其中每个元素(此处称为一个节点,node)都是指针,指向另一段(较大的)连续线性空间,称为缓冲区。缓冲区才是 deque的储存空间主体。 </p>
<p>把令人头皮发麻的各种型别定义(为了型别安全,那其实是有必要的)整理下,我们便可发现,map其实是一个T**,也就是说它是一个指针,所指之物又是个指针,指向型别为T的一块空间,如图所示</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267828260370.jpg" alt=""></p>
<h3 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h3><p>deque是分段连续空间。维持其“整体连续”假象的任务,落在了迭代器的operator++和operator–两个运算子身上</p>
<p>让我们思考一下, deque迭代器应该具备什么结构。首先,它必须能够<strong>指出分段连续空间(亦即缓冲区)在哪里,其次它必须能够判断自己是否已经处于其所在缓冲区的边缘</strong>,如果是,一旦前进或后退时就必须跳跃至下一个或上一个缓冲区为了能够正确跳跃, deque必须<strong>随时掌握管控中心</strong>(map)。</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267830496256.jpg" alt=""></p>
<h3 id="deque的数据结构"><a href="#deque的数据结构" class="headerlink" title="deque的数据结构"></a>deque的数据结构</h3><p>deque除了维护一个先前说过的指向map的指针外,也维护 start,fini两个迭代器,分别指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素(的下一位置)。此外,它当然也必须记住目前的mqp大小。因为一旦mqp所提供的节点不足,就必须重新配置更大的一块map</p>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><h3 id="stack-概述"><a href="#stack-概述" class="headerlink" title="stack 概述"></a>stack 概述</h3><p>stack是一种先进后出( First In last out,FILO)的数据结构。它只有一个出口,形式如图4-18所示。 stack允许新增元素、移除元素、取得最顶端元素。但除了最顶端外,没有任何其它方法可以存取 stack的其它元素。换言之, stack不允许有遍历行为</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267835939355.jpg" alt=""></p>
<h3 id="stack-定义完整列表"><a href="#stack-定义完整列表" class="headerlink" title="stack 定义完整列表"></a>stack 定义完整列表</h3><p>以某种既有容器作为底部结构,将其接口改变,使之符合“先进后出”的特性,形成一个 stack,是很容易做到的, deque是双向开口的数据结构,若以dequ为底部结构并封闭其头端开口,便轻而易举地形成了一个 stack。因此, SGI STI便以 deque作为缺省情况下的 stack底部结构, stack的实现因而非常简单,源代码十分简短,本处完整列出</p>
<p>由于 stack系以底部容器完成其所有工作,而具有这种“修改某物接口,形成另一种风貌”之性质者,称为 adapter(配接器),因此STL stack往往不被归类为 container(容器),而被归类为 container adapter</p>
<h3 id="stack-没有迭代器"><a href="#stack-没有迭代器" class="headerlink" title="stack 没有迭代器"></a>stack 没有迭代器</h3><p>stack所有元素的进出都必须符合“先进后出”的条件,只有 stack顶端的元素,才有机会被外界取用。 stack不提供走访功能,也不提供迭代器</p>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h3 id="queue概述"><a href="#queue概述" class="headerlink" title="queue概述"></a>queue概述</h3><p>queue是一种先进先出( First In First Out,FIFO)的数据结构。它有两个出口。 queue允许新增元素、移除元素、从最底端加入元素、取得最顶端元素。但除了最底端可以加入、最顶端可以取出外,没有任何其它方法可以存取 queue的其它元素。换言之, queue不允许有遍历行为。</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267838406632.jpg" alt=""></p>
<h3 id="queue定义完整列表"><a href="#queue定义完整列表" class="headerlink" title="queue定义完整列表"></a>queue定义完整列表</h3><p>以某种既有容器为底部结构,将其接口改变,使其符合“先进先出”的特性形成一个 queue,是很容易做到的. deque是双向开口的数据结构,若以 deque为底部结构并封闭其底端的出口和前端的入口,便轻而易举地形成了一个 queue。因此, SGI STL便以 deque作为缺省情况下的 queue底部结构。</p>
<h3 id="queue没有迭代器"><a href="#queue没有迭代器" class="headerlink" title="queue没有迭代器"></a>queue没有迭代器</h3><p>queue所有元素的进出都必须符合“先进先出”的条件,只有 queue顶端的元素,才有机会被外界取用。 queue不提供遍历功能,也不提供迭代器</p>
<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><h3 id="heap概述"><a href="#heap概述" class="headerlink" title="heap概述"></a>heap概述</h3><p>heap并不归属于STL容器组件,它是个幕后英雄,扮演 priority queue的助手。顾名思义, priority queue允许用户以任何次序将任何元素推入容器内,但取出时一定是从优先权最高(也就是数值最高)的元素开始取。 binary max heap正是具有这样的特性,适合作为 priority queue的底层机制</p>
<p>如果使用list作为 priority queue的底层机制,元素插入操作可享常数时间。但是要找到list中的极值,却需要对整个list进行线性扫描。我们也可以改变做法,让元素插入前先经过排序这一关,使得list的元素值总是由小到大(或由大到小),但这么一来,收之东隅却失之桑榆:虽然取得极值以及元素删除操作达到最高效率,可元素的插人却只有线性表现</p>
<p>比较麻辣的做法是以 binary search tree作为 prlorltyqueue的底层机制。这么一来,元素的插入和极值的取得就有O(logN)的表现但杀鸡用牛刀,未免小题大做,一来 binary search tree的输人需要足够的随机性,二来 binary search tree并不容易实现。 </p>
<p>比较适合的是binary heap的方案，所谓 binary heap就是一种 complete binary tree(完全二叉树),也就是说,整棵 binary tree除了最底层的叶节点之外,是填满的,而最底层的叶节点(s)由左至右又不得有空隙。</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267842482184.jpg" alt=""></p>
<p>这么一来,我们需要的工具就很简单了:一个 array和一组heap算法(用来插入元素、删除元素、取极值,将某一整组数据排列成一个heap)</p>
<h3 id="heap算法"><a href="#heap算法" class="headerlink" title="heap算法"></a>heap算法</h3><h4 id="push-heap-算法"><a href="#push-heap-算法" class="headerlink" title="push_heap 算法"></a>push_heap 算法</h4><p><img src="https://data2.liuin.cn/2018-05-20-15267844079830.jpg" alt=""></p>
<h4 id="pop-heap-算法"><a href="#pop-heap-算法" class="headerlink" title="pop_heap 算法"></a>pop_heap 算法</h4><p><img src="https://data2.liuin.cn/2018-05-20-15267844125899.jpg" alt=""></p>
<h4 id="sort-heap-算法"><a href="#sort-heap-算法" class="headerlink" title="sort_heap 算法"></a>sort_heap 算法</h4><p>堆排序思想，不断对heap进行pop操作，达到排序效果</p>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><h3 id="priority-queue概述"><a href="#priority-queue概述" class="headerlink" title="priority_queue概述"></a>priority_queue概述</h3><p>顾名思义, priority_queue是一个拥有权值观念的 queue,它允许加人新元素、移除旧元素、审视元素值等功能。由于这是一个 queue,所以只允许在底端加入元素,并从顶端取出元素,除此之外别无其它存取元素的途径</p>
<p>priority_queue带有权值观念,其内的元素并非依照被推入的次序排列,而是自动依照元素的权值排列(通常权值以实值表示)。权值最高者,排在最前面</p>
<p>缺省情况下 priority_queue系利用一个max-heap完成,后者是一个以vector表现的 complete binary tree。max-heap可以满足priority_queue所需要的“依权值高低自动递增排序”的特性。</p>
<p><img src="https://data2.liuin.cn/2018-05-20-15267846191674.jpg" alt=""></p>
<h3 id="priority-queue定义完整列表"><a href="#priority-queue定义完整列表" class="headerlink" title="priority_queue定义完整列表"></a>priority_queue定义完整列表</h3><p>由于 priority-queue完全以底部容器为根据,再加上heap处理规则,所以其实现非常简单。缺省情况下是以 vector为底部容器。</p>
<p>queue以底部容器完成其所有工作。具有这种“修改某物接口,形成另一种风貌”之性质者,称为 adapter(配接器),因此, STL prior1ty_ queue往往不被归类为 container(容器),而被归类为 container adapter</p>
<h3 id="priority-queue没有迭代器"><a href="#priority-queue没有迭代器" class="headerlink" title="priority_queue没有迭代器"></a>priority_queue没有迭代器</h3><p>priority-queue的所有元素,进出都有一定的规则,只有 queue顶端的元素(权值最高者),才有机会被外界取用。 priority_queue不提供遍历功能,也不提供迭代器。</p>
<h1 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;侯捷老师的《STL源码剖析》可谓是学习STL的经典。在书籍的自序中侯捷老师提到的”我的确认为99.99%的程序员所写的程序，在SGI STL面前都是三流水平“，这让我等菜鸟更本把持不住呀。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="STL" scheme="https://www.liuin.cn/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>APUE 伪终端</title>
    <link href="https://www.liuin.cn/2018/05/05/APUE-%E4%BC%AA%E7%BB%88%E7%AB%AF/"/>
    <id>https://www.liuin.cn/2018/05/05/APUE-伪终端/</id>
    <published>2018-05-05T08:09:34.000Z</published>
    <updated>2018-05-05T11:14:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第19章 伪终端 笔记</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>伪终端这个术语是指,对于一个应用程序而言,它看上去像一个终端,但事实上它并不是个真正的终端。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255087230010.jpg" alt=""></p>
<p>图中的关键点是：</p>
<ol>
<li>通常,一个进程打开伪终端主设备,然后调用fork。子进程建立一个新的会话,打开一个相应的伪终端从设备,将其文件描述符复制到标准输入、标准输出和标准错误,然后调用exec。伪终端从设备成为子进程的控制终端。</li>
<li>对于伪终端从设备上的用户进程来说,其标准输入、标准输出和标准错误都是终端设备。通过这些描述符,用户进程能够处理所有终端I/O函数。但是因为仍终端从设备不是真正的终端设备,所以无意义的函数调用(例如,改变波特率、发送中断符、设置奇偶校验)将被忽略</li>
<li>任何写到伪终端主设备的都会作为从设备的输入,反之亦然。事实上,所有从设备端的输入都来自于伪终端主设备上的用户进程。这看起来就像一个双向管道,但是从设备上的中断行规程使我们拥有管道没有的处理奇谈问题的能力</li>
</ol>
<p>伪终端的某些经典用途：</p>
<blockquote>
<p>网络登录服务器</p>
</blockquote>
<p>伪终端可用于构造提供网络登录的服务器。典型的例子是 telnetd和rlogind服务器</p>
<p>在rlogind服务器和登录shell之间有两个exec调用,这是因为login程序通常是在两个exec之间检验用户是否合法</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255090645150.jpg" alt=""></p>
<blockquote>
<p>窗口系统终端模拟</p>
</blockquote>
<p>窗口系统通常提供一个终端模拟器,这样我们就能在熟悉的命令行环境中通过shell来运行程序。终端模拟器作为shell和窗口管理器之间的媒介。每个shell在自己的窗口中执行。</p>
<p>shell将自己的标准输入、标准输出、标准错误连接到PTY的从设备端。终端模拟器程序打开PTY的主设备。终端模拟器除了作为窗口子系统的接口,还要负责模拟一种特殊的终端,这意味着它需要根据它所模拟的设备类型来响应返回码。这些码列在 termcap和 terminfo数据库中。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255091975517.jpg" alt=""></p>
<blockquote>
<p>script 程序</p>
</blockquote>
<p>script(1)程序是随大多数UNIX系统提供的,它将终端会话期间的所有输入和输出信息复制到一个文件中。为完成此工作,该程序将自己置于终端和一个新调用的登录 shell之间。这里要特别指出, script程序通常是从登录shell启动的,该 shell还要等待 script程序的终止。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255092890944.jpg" alt=""></p>
<blockquote>
<p>expect 程序</p>
</blockquote>
<p>伪终端可以用来在非交互模式中驱动交互式程序的运行。许多硬连线程序需要一个终端才能行, passwd(1)命令就是一个例子,它要求用户在系统提示后输入口令</p>
<blockquote>
<p>运行协同进程</p>
</blockquote>
<p>如果协同进程是一个已经编译的程序而我们又没有源程序,则无法在源程序中加入ff1ush语句来解决这个问题。我们需要做的是将一个伪终端放到两个进程之间,诱使协同进程认为它是由终端驱动的,而非另一个进程</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255094556754.jpg" alt=""></p>
<blockquote>
<p>观看长时间运行程序的输出</p>
</blockquote>
<p>使用任何一个标准 shell,可以将一个需要长时间运行的程序放到后台运行。但是,如果将该程序的标准输出重定向到一个文件,并且它产生的输出又不多,那么我们就不能方便地监控程序的进展,因为标准I/O库将完全缓冲它的标准输出。</p>
<p>如果有源程序,则可以加入fflush调用强制标准I/O缓冲区在某些节点冲洗或者把缓冲模式改使用 setybuf的行缓冲。然而,如果没有源程序,可以在pty程序下运行该程序,让标准I/O库认为标准输出是终端。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255095797010.jpg" alt=""></p>
<h2 id="打开伪终端设备"><a href="#打开伪终端设备" class="headerlink" title="打开伪终端设备"></a>打开伪终端设备</h2><p>PTY表现得就像物理终端设备一样,因此应用程序就无须在意它们在使用的是何种设备。各种平台打开伪终端设备的方法有所不同。posix_openpt函数提供了一种可移植的方法来打开下一个可用<strong>伪终端主设备</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; #include &lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">posix_openpt</span><span class="params">(<span class="keyword">int</span> oﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: ﬁle descriptor of next available PTY master if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>在伪终端从设备可用之前,它的权限必须设置,以便应用程序可以访问它。 grantpt函数提供这样的功能:它把从设备节点的用户ID设置为调用者的实际用户ID,设置其组ID为一非指定值,通常是可以访问该终端设备的组。权限被设置为:对个体所有者是读写,对组所有者是写(0620)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">grantpt</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlockpt</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 on success, −1 on error</span></div></pre></td></tr></table></figure>
<p>unlockpt函数用于准予对伪终端从设备的访问,从而允许应用程序打开该设备。阻止其他进程打开从设备后,建立该设备的应用程序有机会在使用主、从设备之前正确地初始化这些设备</p>
<p>注意,在 grantpt和unlockpt这两个函数中,文件描述符参数是与伪终端主设备关联的文件描述符。</p>
<p>如果给定了伪终端主设备的文件描述符,那么可以用 ptsname函数找到伪终端从设备的路径名。这使应用程序可以独立于给定平台的某种特定约定而标识从设备。注意,该函数返回的名字可能存储在静态存储中,因此后续的调用可能会覆盖它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ptsname</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to name of PTY slave if OK, NULL on error</span></div></pre></td></tr></table></figure>
<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><p>伪终端还有其他特性：</p>
<ol>
<li>打包模式</li>
</ol>
<p>打包模式(packet mode)能够使PTY主设备了解到PTY从设备的状态变化</p>
<ol>
<li>远程模式</li>
</ol>
<p>PTY主设备可以用 TIOCREMOTE ioct1命令将PTY从设备设置成远程模式</p>
<ol>
<li>窗口大小变化</li>
</ol>
<p>PTY主设备上的进程可以用 TIOCSWINSZ ioct1命令来设置从设备的窗口大小。如果新的大小和当前的大小不同, SIGWINCH信号将被发送到PTY从设备的前台进程组。</p>
<ol>
<li>信号发生</li>
</ol>
<p>读、写PTY主设备的进程可以向PTY从设备的进程组发送信号</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第19章 伪终端 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 终端I/O</title>
    <link href="https://www.liuin.cn/2018/05/05/APUE-%E7%BB%88%E7%AB%AFI-O/"/>
    <id>https://www.liuin.cn/2018/05/05/APUE-终端I-O/</id>
    <published>2018-05-05T02:53:52.000Z</published>
    <updated>2018-05-05T08:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第18章 终端I/O 笔记</p>
<a id="more"></a>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>终端I/O有两种不同的工作模式:</p>
<ol>
<li>规范模式输入处理。在这种模式中,对终端输入以行为单位进行处理。对于每个读请求终端驱动程序最多返回一行</li>
<li>非规范模式输入处理。输入字符不装配成行</li>
</ol>
<p>如果不做特殊处理,则默认模式是规范模式</p>
<p>可以认为终端设备是由通常位于内核中的终端驱动程序控制的。每个终端设备都有一个输入列和一个输出队列,如图所示：</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255055612367.jpg" alt=""></p>
<p>有以下几点说明：</p>
<ul>
<li>如果打开了回显功能,则在输入队列和输出队列之间有一个隐含的连接</li>
<li>输入队列的长度MAX_INPUT是有限值。当一个特定设备的输入队列已经填满时,系统的行为将依赖于实现。这种情况发生时大多数UNIX系统回显响铃字符。</li>
<li>图中没有显示另一个输入限制MAX_CANON。这个限制是一个规范输入行的最大字节数</li>
<li>虽然输出队列的长度通常也是有限的,但是程序并不能获得这个定义其长度的常量为当输出队列将要填满时,内核便直接使写进程休眠,直至写队列中有可用的空间。</li>
</ul>
<p>大多数UNIX系统在一个称为终端行规程(terminal linediscipline)的模块中进行全部的规范处理。可以将这个模块设想成一个盒子,<strong>位于内核通用读、写函数和实际设备驱动程序之间</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255057246778.jpg" alt=""></p>
<p>由于将规范处理分离为单独的模块,所有的终端驱动程序都能够一致地支持规范处理。</p>
<p>所有可以检测和更改的终端设备特性都包含在termios结构中。该结构定义在头文件<termios.h>中,本章使用这一头文件。</termios.h></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255057581968.jpg" alt=""></p>
<p>各个标志位的作用：</p>
<ul>
<li>输入标志通过终端设备驱动程序控制字符的输入(例如,剥除输入字节的第8位,允许输入奇偶校验)</li>
<li>输出标志则控制驱动程序输出(例如,执行输出处理、将换行符转换为CRLF)</li>
<li>控制标志影响RS232串行线(例如,忽略调制解调器的状态线、每个字符的一个或两个停止位)</li>
<li>本地标志影响驱动程序和用户之间的接口(例如,回显打开或关闭、可视地擦除字符、允许终端产生的信号以及对后台输出的作业控制停止信号</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-05-05-15255058794969.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255058823469.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255058855001.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255058879538.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255058906529.jpg" alt=""></p>
<p>与终端有关的各个函数之间的关系</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255059407734.jpg" alt=""></p>
<h2 id="特殊输入字符"><a href="#特殊输入字符" class="headerlink" title="特殊输入字符"></a>特殊输入字符</h2><p>POSIX.1定义了11个在输入时要特殊处理的字符。实现定义了另外一些特殊字符</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255061027706.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255061066356.jpg" alt=""></p>
<p>在POSIX的11个特殊字符中,其中有9个字符的值可以任意更改。不能更改的两个特殊字符是换行符和回车符(分别是\n和\r),也可能是STOP和START字符(依赖于实现)。为了更改,只需要修改termios结构中c_cc数组的相应项。该数组中的元素都用名字作为下标进行引用,每个名字都以字母V开头。</p>
<p>对各个字符的详细解释可见原书内容</p>
<h2 id="获得和设置终端属性"><a href="#获得和设置终端属性" class="headerlink" title="获得和设置终端属性"></a>获得和设置终端属性</h2><p>为了获得和设置 termios结构,可以调用 tcgetattr和 tcsetattr函数。这样就可以检测和修改各种终端选项标志和特殊字符,使终端按我们所希望的方式进行操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcgetattr</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">struct</span> termios *termptr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsetattr</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> opt, <span class="keyword">const</span> <span class="keyword">struct</span> termios *termptr)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>tcsetattr的参数opt使我们可以指定在什么时候新的终端属性才起作用。opt可以指定为下列常量中的一个:</p>
<ul>
<li>TCSANOW   更改立即发生。</li>
<li>TCSADRAIN 发送了所有输出后更改才发生。若更改输出参数则应使用此选项。</li>
<li>TCSAFLUSH 发送了所有输出后更改才发生。更进一步,在更改发生时未读的所有输入数据都被丢弃(冲洗)。</li>
</ul>
<h2 id="终端选项标志"><a href="#终端选项标志" class="headerlink" title="终端选项标志"></a>终端选项标志</h2><p>包含终端选项标志的所有的解释，具体可查看原书</p>
<h2 id="stty命令"><a href="#stty命令" class="headerlink" title="stty命令"></a>stty命令</h2><p>上节说明的所有选项都可以被检查和更改:在程序中用tcgetattr和tcsetattr函数进行检查和更改;在命令行(或shell脚本)中用stty(1)命令进行检查和更改。简单地说,stty(1)命令就是终端I/O所列的前6个函数的接口。</p>
<h2 id="波特率函数"><a href="#波特率函数" class="headerlink" title="波特率函数"></a>波特率函数</h2><p>术语波特率(baud rate)是一个历史沿用的术语,现在它指的是“位/秒”(bit per second)。虽然大多数终端设备对输入和输出使用同一波特率,但是只要硬件许可,可以将它们设置为两个不同值。</p>
<p>设置波特率函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">speed_t</span> cfgetispeed(<span class="keyword">const</span> <span class="keyword">struct</span> termios *termptr); </div><div class="line"><span class="keyword">speed_t</span> cfgetospeed(<span class="keyword">const</span> <span class="keyword">struct</span> termios *termptr); </div><div class="line"></div><div class="line"><span class="comment">// Both return: baud rate value </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cfsetispeed</span><span class="params">(<span class="keyword">struct</span> termios *termptr, <span class="keyword">speed_t</span> speed)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cfsetospeed</span><span class="params">(<span class="keyword">struct</span> termios *termptr, <span class="keyword">speed_t</span> speed)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="行控制函数"><a href="#行控制函数" class="headerlink" title="行控制函数"></a>行控制函数</h2><p>下列4个函数提供了终端设备的行控制能力：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcdrain</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcflow</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> action)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcflush</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> <span class="built_in">queue</span>)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsendbreak</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> duration)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All four return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>tcdrain函数等待所有输出都被传递。<br>tcflow函数用于对输入和输出流控制进行控制。<br>tcflush函数冲洗(抛弃)输入缓冲区(其中的数据是终端驱动程序已接收到,但用户程序尚未读取的)或输出缓冲区(其中的数据是用户程序已经写入,但尚未被传递的)。<br>tcsendbreak函数在一个指定的时间区间内发送连续的0值位流。</p>
<h2 id="终端标识"><a href="#终端标识" class="headerlink" title="终端标识"></a>终端标识</h2><p>历史上,在大多数UNIX系统版本中,控制终端的名字一直是/dev/tty。POSIX.1提供了个运行时函数,可用来确定控制终端的名字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctermid</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to name of controlling terminal on success, pointer to empty string on error</span></div></pre></td></tr></table></figure>
<p>另外还有两个UNIX系统比较感兴趣的函数: isatty和 ttyname。如果文件描述符引用个终端设备,则 isatty返回真。 ttyname返回的是在该文件描述符上打开的终端设备的路径名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">isatty</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 1 (true) if terminal device, 0 (false) otherwise</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ttyname</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to pathname of terminal, NULL on error</span></div></pre></td></tr></table></figure>
<h2 id="规范模式"><a href="#规范模式" class="headerlink" title="规范模式"></a>规范模式</h2><p>规范模式很简单:发一个读请求,<strong>当一行已经输入后,终端驱动程序即返回</strong>。以下几个条件造成读返回。</p>
<ol>
<li>所请求的字节数已读到时,读返回。无需读一个完整的行。如果读了部分行,那么也不会丢失任何信息,下一次读从前一次读的停止处开始。</li>
<li>当读到一个行定界符时,读返回。</li>
<li>如果捕捉到信号,并且该函数不再自动重启,则读也返回</li>
</ol>
<h2 id="非规范模式"><a href="#非规范模式" class="headerlink" title="非规范模式"></a>非规范模式</h2><p>可以通过关闭termios结构中c_lf1ag字段的ICANON标志来指定非规范模式。在非规范模式中,输入数据不装配成行,不处理下列特殊字符: ERASE、KILL、EOF、NLEOL、EOL2、CR、REPRINT、STATUS和 WERASE。</p>
<p>如前所述,规范模式很容易理解:系统每次至多返回一行。但在非规范模式下,系统如何知道在什么时候将数据返回给我们呢?如果它一次返回一个字节,那么系统开销就会过大。在启动读数据之前,往往不知道要读多少数据,所以系统不能总是一次返回多个字节解决方法是,当已读了指定量的数据后,或者已经超过了给定量的时间后,即通知系统返回。</p>
<p>这种技术使用了 termios结构中c_cc数组的两个变量:MIN和TIME。c_cc数组中的这两个元素的下标名为VMIN和VTIM。</p>
<p>MIN指定一个read返回前的最小字节数。TIME指定等待数据到达的分秒数(分秒为秒的1/10)。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255076147395.jpg" alt=""></p>
<h2 id="终端窗口大小"><a href="#终端窗口大小" class="headerlink" title="终端窗口大小"></a>终端窗口大小</h2><p>大多数UNⅨX系统都提供了一种跟踪当前终端窗口大小的方法,在窗口大小发生变化时,使内核通知前台进程组。内核为每个终端和伪终端都维护了一个wins1ze结构</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15255076954042.jpg" alt=""></p>
<p>提供这种功能的目的是,当窗口大小发生变化时应用程序能够得到通知(如v1编辑器)。应用程序接收此信号后,可以获取窗口大小的新值,然后重绘屏幕。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第18章 终端I/O 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 高级进程间通信</title>
    <link href="https://www.liuin.cn/2018/05/05/APUE-%E9%AB%98%E7%BA%A7%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://www.liuin.cn/2018/05/05/APUE-高级进程间通信/</id>
    <published>2018-05-05T01:37:33.000Z</published>
    <updated>2018-05-05T02:55:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第17章 高级进程间通信 笔记</p>
<a id="more"></a>
<h2 id="UNIX-域套接字"><a href="#UNIX-域套接字" class="headerlink" title="UNIX 域套接字"></a>UNIX 域套接字</h2><p>UNIX域套接字用于在同一台计算机上运行的进程之间的通信。虽然因特网域套接字可用于同一目的,但<strong>UNIX域套接字的效率更高</strong>。UNIX域套接字仅仅复制数据,它们并不执行协议处理,不需要添加或删除网络报头,无需计算校验和,不要产生顺序号,无需发送确认报文。</p>
<p>UNIX域套接字<strong>提供流和数据报两种接口</strong>。UNIX域数据报服务是可靠的,既不会丢失报文也不会传递出错。UNIX域套接字就像是套接字和管道的混合。</p>
<p>可以使用它们面向网络的域套接字接口或者使用socketpair函数来创建一对无命名的、相互连接的UNIX域套接字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> sockfd[<span class="number">2</span>])</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>虽然接口足够通用,允许socketpair用于其他域,但一般来说操作系统仅对UNIX域提供支持</p>
<p>对相互连接的UNIX域套接字可以起到<strong>全双工管道的作用</strong>:两端对读和写开放。我们将其称为fd管道( fd-pipe),以便与普通的半双工管道区分开来。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254872539788.jpg" alt=""></p>
<p>曾经提到XSI消息队列的使用存在一个问题,即不能将它们和po11或者se1ect起使用,这是因为它们不能关联到文件描述符。然而,套接字是和文件描述符相关联的,消息到达时,可以用套接字来通知。对每个消息队列使用一个线程。每个线程都会在mmsgrcv调用中阻塞。当消息到达时,线程会把它写入一个UNIX域套接字的一端。当poll指示套接字可以读取数据时,应用程序会使用这个套接字的另外一端来接收这个消息。</p>
<blockquote>
<p>命名UNIX域套接字</p>
</blockquote>
<p>虽然socketpair函数能创建一对相互连接的套接字,但是每一个套接字都没有名字。这意味着无关进程不能使用它们。恰如因特网域套接字一样,可以命名UNIX域套接字,并可将其用于告示服务。但是要注意,UNX域套接字使用的地址格式不同于因特网域套接字，套接字地址格式会随实现而变。</p>
<p>UNIX域套接字的地址由 sockaddr_un结构表示。在 Linux3.20和 Solaris10中, sockaddr_un结构在头文件<sys un.h="">中的定义</sys></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254875673064.jpg" alt=""></p>
<p>sockaddr_un结构的sun_path成员包含一个路径名。当我们将一个地址绑定到一个UNIX域套接字时,系统会用该路径名创建一个S_IFSOCK类型的文件该文件仅用于向客户进程告示套接字名字。该文件无法打开,也不能由应用程序用于通信。</p>
<p>如果我们试图绑定同一地址时,该文件已经存在,那么bind请求会失败。当关闭套接字时,并不自动删除该文件,所以必须确保在应用程序退出前,对该文件执行解除链接操作。</p>
<h2 id="唯一连接"><a href="#唯一连接" class="headerlink" title="唯一连接"></a>唯一连接</h2><p>服务器进程可以使用标准bind、listen和 accept函数,为客户进程安排一个唯一UNIX域连接。客户进程使用 connect与服务器进程联系。在服务器进程接受了connect请求后,在服务器进程和客户进程之间就存在了唯一连接。</p>
<p>下图展示了客户进程和服务器进程存在连接之前二者的情形。服务器端把它的套接字绑定到sockaddr_un的地址并监听新的连接请求。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254879207178.jpg" alt=""></p>
<p>现在，开发3个函数,使用这些函数可以在运行于同一台计算机上的两个无关进程之间创建唯一连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span> </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">serv_listen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </div><div class="line"><span class="comment">// Returns: ﬁle descriptor to listen on if OK, negative value on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">serv_accept</span><span class="params">(<span class="keyword">int</span> listenfd, <span class="keyword">uid_t</span> *uidptr)</span></span>; </div><div class="line"><span class="comment">// Returns: new ﬁle descriptor if OK, negative value on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cli_conn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </div><div class="line"><span class="comment">// Returns: ﬁle descriptor if OK, negative value on error</span></div></pre></td></tr></table></figure>
<p>服务器进程可以调用serv_listen函数声明它要在一个众所周知的名字(文件系统中的某个路径名)上监听客户进程的连接请求。当客户进程想要连接至服务器进程时,它们将使用该名字。serv_listen函数的返回值是用于接收客户进程连接请求的服务器UNIX域套接字</p>
<p>服务器进程可以使用serv_accept函数等待客户进程连接请求的到达。当个请求到达时,系统自动创建一个新的UNIX域套接字,并将它与客户端套接字连接,最后将这个新套接字返回给服务器。此外,客户进程的有效用户ID存放在 uidptr指向的存储区中客户</p>
<p>进程调用cli_conn函数连接至服务器进程。客户进程指定的name参数必须与服务器进程调用serv_listen函数时所用的名字相同</p>
<p>这三个函数的具体实现可以查看书本</p>
<h2 id="传送文件描述符"><a href="#传送文件描述符" class="headerlink" title="传送文件描述符"></a>传送文件描述符</h2><p>在两个进程之间传送打开文件描述符的技术是非常有用的。因此可以对客户进程服务器进程应用进行不同的设计。它使一个进程(通常是服务器进程)能够处理打开一个文件所要做的一切操作(包括将网络名翻译为网络地址、拨号调制解调器、协商文件锁等)以及<strong>向调用进程送回个描述符</strong>,该描述符可被用于以后的所有I/O函数。涉及打开文件或设备的所有细节对客户进程而言都是透明的。</p>
<p>一般情况下，两个进程,它们打开了同一文件。虽然它们共享同一个v节点,但每个进程都有它自己的文件表项。当一个进程向另一个进程传送一个打开文件描述符时,我们想让发送进程和接收进程共享同文件表项。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254885933315.jpg" alt=""></p>
<p>在技术上,我们是<strong>将指向一个打开文件表项的指针从一个进程发送到另外一个进程</strong>。该指针被分配存放在接收进程的第一个可用描述符项中。(注意,不要造成错觉,以为发送进程和接收进程中的描述符编号是相同的,它们通常是不同的。)两个进程共享同一个打开文件表,这与foxk之后的父进程和子进程共享打开文件表的情况完全相同。</p>
<p>当发送进程将描述符传送给接收进程后,通常会关闭该描述符。发送进程关闭该描述符并不会真的关闭该文件或设备,其原因是该描述符仍被视为由接收进程打开(即使接收进程尚未接收到该描述符)</p>
<p>下面定义用以发送和接收文件描述符的3个函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include "apue.h" </div><div class="line"></div><div class="line">int send_fd(int fd, int fd_to_send); </div><div class="line">int send_err(int fd, int status, const char *errmsg); </div><div class="line">// Both return: 0 if OK, −1 on error </div><div class="line"></div><div class="line">int recv_fd(int fd, ssize_t (*userfunc)(int, const void *, size_t)); </div><div class="line">// Returns: ﬁle descriptor if OK, negative value on error</div></pre></td></tr></table></figure>
<p>具体的实现原书代码</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第17章 高级进程间通信 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 网络IPC：套接字</title>
    <link href="https://www.liuin.cn/2018/05/05/APUE-%E7%BD%91%E7%BB%9CIPC%EF%BC%9A%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    <id>https://www.liuin.cn/2018/05/05/APUE-网络IPC：套接字/</id>
    <published>2018-05-05T00:38:42.000Z</published>
    <updated>2018-05-05T01:37:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第16章 网络IPC：套接字 笔记</p>
<a id="more"></a>
<h2 id="套接字描述"><a href="#套接字描述" class="headerlink" title="套接字描述"></a>套接字描述</h2><p>套接字是通信端点的抽象。正如使用文件描述符访问文件,应用程序用套接字描述符访问套接字。<strong>套接字描述符在UNIX系统中被当作是一种文件描述符</strong>。事实上,许多处理文件描述符的函数(如read和 write)可以用于处理套接字描述符。</p>
<p>为创建一个套接字,调用socket函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: ﬁle (socket) descriptor if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>参数 domain(域)确定通信的特性,包括地址格式</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254808968863.jpg" alt=""></p>
<p>参数type确定套接字的类型,进一步确定通信特征。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254809237060.jpg" alt=""></p>
<p>参数protocol通常是0,表示为给定的域和套接字类型选择默认协议。当对同一域和套接字类型支持多个协议时,可以使用 protocol选择一个特定协议</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254809947426.jpg" alt=""></p>
<p>对于数据报(SOCK_DGRAM)接口,两个对等进程之间通信时不需要逻辑连接。只需要向对等进程所使用的套接字送出一个报文。字节流(SOCK_STREAM)要求在交换数据之前,在本地套接字和通信的对等进程的套接字之间建立一个逻辑连接。</p>
<p>调用socket与调用open相类似。在两种情况下,均可获得用于I/O的文件描述符。当不再需要该文件描述符时,调用c1ose来关闭对文件或套接字的访问,并且释放该描述符以便重新使用虽然套接字描述符本质上是一个文件描述符,但不是所有参数为文件描述符的函数都可以接受套接字描述符。</p>
<h2 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h2><p>在学习用套接字做一些有意义的事情之前,需要知道如何标识一个目标通信进程。进程标识由两部分组成。一部分是<strong>计算机的网络地址</strong>,它可以帮助标识网络上我们想与之通信的计算机;另一部分是该<strong>计算机上用端口号</strong>表示的服务,它可以帮助标识特定的进程。</p>
<h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>字节序是一个处理器架构特性用于指示像整数这样的大数据类型内部的字节如何排序。</p>
<p>如果处理器架构支持大端(big-endian)字节序,那么<strong>最大字节地址出现在最低有效字节</strong>( Least Significant Byte,LSB)上，小端(little-endian)字节序则相反:<strong>最低有效字节包含最小字节地址</strong>。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254815015116.jpg" alt=""></p>
<p>网络协议指定了字节序,因此异构计算机系统能够交换协议信息而不会被字节序所混淆。TCPP协议栈使用大端字节序。应用程序交换格式化数据时,字节序问题就会出现</p>
<p>对于TCPP应用程序,有4个用来在处理器字节序和网络字节序之间实施转换的函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostint32);</div><div class="line"><span class="comment">// Returns: 32-bit integer in network byte order</span></div><div class="line"></div><div class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostint16);</div><div class="line"><span class="comment">// Returns: 16-bit integer in network byte order</span></div><div class="line"></div><div class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netint32);</div><div class="line"></div><div class="line"><span class="comment">// Returns: 32-bit integer in host byte order</span></div><div class="line"></div><div class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> netint16);</div><div class="line"></div><div class="line"><span class="comment">// Returns: 16-bit integer in host byte order</span></div></pre></td></tr></table></figure>
<p>h表示“主机”字节序,n表示“网络”字节序。1表示“长”(即4字节)整数,s表示“短”</p>
<h3 id="地址格式"><a href="#地址格式" class="headerlink" title="地址格式"></a>地址格式</h3><p>一个地址标识一个特定通信域的套接字端点,地址格式与这个特定的通信域相关。为使不同格式地址能够传入到套接字函数,地址会被<strong>强制转换</strong>成一个通用的地址结构sockaddr</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254817776056.jpg" alt=""></p>
<p>不同的系统实现可能会不一样</p>
<p>因特网地址定义在<netinet in.h="">头文件中。在IPv4因特网域(AF_INET)中,套接字地址用结构 sockaddr_in表示</netinet></p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254818310427.jpg" alt=""></p>
<p>有时,需要打印出能被人理解而不是计算机所理解的地址格式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> addr, <span class="keyword">char</span> *<span class="keyword">restrict</span> str, <span class="keyword">socklen_t</span> size)</span></span>;</div><div class="line"><span class="comment">// Returns: pointer to address string on success, NULL on error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> str, <span class="keyword">void</span> *<span class="keyword">restrict</span> addr)</span></span>;</div><div class="line"><span class="comment">// Returns: 1 on success, 0 if the format is invalid, or −1 on error</span></div></pre></td></tr></table></figure>
<p>函数inet_ntop将网络字节序的二进制地址转换成文本字符串格式。inet_pton将文本字符串格式转换成网络字节序的二进制地址。</p>
<h3 id="将套接字和地址关联"><a href="#将套接字和地址关联" class="headerlink" title="将套接字和地址关联"></a>将套接字和地址关联</h3><p>将一个客户端的套接字关联上一个地址没有多少新意,可以让系统选一个默认的地址。然而,<strong>对于服务器,需要给一个接收客户端请求的服务器套接字关联上一个众所周知的地址</strong>。客户端应有一种方法来发现连接服务器所需要的地址,最简单的方法就是服务器保留一个地址并且注册在/etc/services或者某个名字服务中。</p>
<p>使用bind函数来关联地址和套接字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>对于使用的地址有以下一些限制:</p>
<ul>
<li>在进程正在运行的计算机上,指定的地址必须有效，不能指定一个其他机器的地址。</li>
<li>地址必须和创建套接字时的地址族所支持的格式相匹配。</li>
<li>地址中的端口号必须不小于1024,除非该进程具有相应的特权(即超级用户)</li>
<li>一般只能将一个套接字端点绑定到一个给定地址上,尽管有些协议允许多重绑定</li>
</ul>
<p>可以调用 getsockname函数来发现绑定到套接字上的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> alenp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>调用 getsockname之前,将 alenp设置为一个指向整数的指针,该整数指定缓冲区sockaddr的长度。返回时,该整数会被设置成返回地址的大小。如果地址和提供的缓冲区长</p>
<p>如果套接字已经和对等方连接,可以调用 getpeername函数来找到对方的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> alenp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>如果要处理一个面向连接的网络服务(SOCK_STREAM或SOCK_SEQPACKET),那么在开始交换数据以前,需要在请求服务的进程套接字(客户端)和提供服务的进程套接字(服务器)之间建立一个连接。使用connect函数来建立连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>在connect中指定的地址是我们想与之通信的服务器地址。如果 sockfd没有绑定到一个地址, connect会给调用者绑定一个默认地址。</p>
<p>服务器调用listen函数来宣告它愿意接受连接请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>一旦服务器调用了listen,所用的套接字就能接收连接请求。使用accept函数获得连接请求并建立连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> len)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: ﬁle (socket) descriptor if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>函数accept所返回的文件描述符是套接字描述符,该描述符连接到调用connect的客户端。这个新的套接字描述符和原始套接字(sockfd)具有相同的套接字类型和地址族。传给accept原始套接字没有关联到这个连接,而是继续保持可用状态并接收其他连接请求。</p>
<p>如果服务器调用accept,并且当前没有连接请求,服务器会阻塞直到一个请求到来。另外服务器可以使用poll或se1ect来等待一个请求的到来。在这种情况下,一个带有等待连接请求的套接字会以可读的方式出现</p>
<h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>既然一个套接字端点表示为一个文件描述符,那么只要建立连接,就可以使用read和 write来通过套接字通信。</p>
<p>尽管可以通过read和write交换数据,但这就是这两个函数所能做的一切。如果想指定选项,从多个客户端接收数据包,或者发送带外数据,就需要使用6个为数据传递而设计的套接字函数中的一个</p>
<p>3个函数用来发送数据,3个用于接收数据。首先,考查用于发送数据的函数。最简单的是send,它和 write很像,但是可以指定标志来改变处理传输数据的方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> send(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> ﬂags);</div><div class="line"></div><div class="line"><span class="comment">// Returns: number of bytes sent if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>前面3个参数和write参数一样，不同的是第4个参数flags：</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254833405785.jpg" alt=""></p>
<p>即使send成功返回,也并不表示连接的另一端的进程就一定接收了数据。我们所能保证的只是当send成功返回时,数据已经被无错误地发送到网络驱动程序上</p>
<p>函数 sendto和send很类似。区别在于sendto可以在无连接的套接字上指定一个目标地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> ﬂags, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *destaddr, <span class="keyword">socklen_t</span> destlen); </div><div class="line"></div><div class="line"><span class="comment">// Returns: number of bytes sent if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>对于面向连接的套接字,目标地址是被忽略的,因为连接中隐含了目标地址。对于无连接的套接字,除非先调用 connect设置了目标地址,否则不能使用send。 sendto提供了发送报文的另一种方式</p>
<p>通过套接字发送数据时,还有一个选择。可以调用带有msghdr结构的sendmsg来指定多重缓冲区传输数据,这和 writev函数很相似</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> sendmsg(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="keyword">int</span> ﬂags);</div><div class="line"></div><div class="line"><span class="comment">// Returns: number of bytes sent if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>与发送数据相对应的，接受数据也有三个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> recv(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> ﬂags);</div><div class="line"></div><div class="line"><span class="comment">// Returns: length of message in bytes, 0 if no messages are available and peer has done an orderly shutdown, or −1 on error</span></div></pre></td></tr></table></figure>
<p><img src="https://data2.liuin.cn/2018-05-05-15254835445782.jpg" alt=""></p>
<p>如果有兴趣定位发送者,可以使用 recvfrom来得到数据发送者的源地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> ﬂags, <span class="keyword">struct</span> sockaddr *<span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> addrlen); </div><div class="line"></div><div class="line"><span class="comment">// Returns: length of message in bytes, 0 if no messages are available and peer has done an orderly shutdown, or −1 on error</span></div></pre></td></tr></table></figure>
<p>为了将接收到的数据送入多个缓冲区,类似于 readv,或者想接收辅助数据,可以使用 recvmso</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> recvmsg(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="keyword">int</span> ﬂags);</div><div class="line"></div><div class="line"><span class="comment">// Returns: length of message in bytes, 0 if no messages are available and peer has done an orderly shutdown, or −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h2><p>套接字机制提供了两个套接字选项接口来控制套接字行为。一个接口用来设置选项,另一个接口可以查询选项的状态。可以获取或设置以下3种选项</p>
<ol>
<li>通用选项,工作在所有套接字类型上</li>
<li>在套接字层次管理的选项,但是依赖于下层协议的支持</li>
<li>特定于某协议的选项,每个协议独有的</li>
</ol>
<p>可以使用 setsockopt函数来设置套接字选项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option, <span class="keyword">const</span> <span class="keyword">void</span> *val, <span class="keyword">socklen_t</span> len)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>参数 level标识了选项应用的协议。</p>
<p><img src="https://data2.liuin.cn/2018-05-05-15254838324441.jpg" alt=""></p>
<p>参数val根据选项的不同指向一个数据结构或者一个整数。一些选项是on/off开关。如果整数非0,则启用选项。如果整数为0,则禁止选项。参数len指定了val指向的对象的大小</p>
<p>可以使用getsockopt来查看选项的当前值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option, <span class="keyword">void</span> *<span class="keyword">restrict</span> val, <span class="keyword">socklen_t</span> *<span class="keyword">restrict</span> lenp)</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="带外数据"><a href="#带外数据" class="headerlink" title="带外数据"></a>带外数据</h2><p>带外数据( out-of-band data)是一些通信协议所支持的可选功能,与普通数据相比,它允许更高优先级的数据传输。带外数据先行传输,即使传输队列已经有数据。TCP支持带外数据,但是UDP不支持。套接字接口对带外数据的支持很大程度上受TCP带外数据具体实现的影响。TCP将带外数据称为紧急数据( urgent data)。</p>
<p>TCP仅支持一个字节的紧急数据,但是允许紧急数据在普通数据传递机制数据流之外传输。</p>
<h2 id="非阻塞和异步I-O"><a href="#非阻塞和异步I-O" class="headerlink" title="非阻塞和异步I/O"></a>非阻塞和异步I/O</h2><p>在基于套接字的异步LO中,当从套接字中读取数据时,或者当套接字写队列中空间变得可用时,可以安排要发送的信号 SIGIO。</p>
<p>启用异步IO是一个两步骤的过程</p>
<ol>
<li>建立套接字所有权,这样信号可以被传递到合适的进程</li>
<li>通知套接字当IO操作不会阻塞时发信号</li>
</ol>
<p>可以使用3种方式来完成第一个步骤</p>
<ul>
<li>在fcnt1中使用 F_SETOWN命令</li>
<li>在ioct1中使用 FIOSETOWN命令</li>
<li>在ioctl中使用 SIOCSPGRP命令</li>
</ul>
<p>要完成第二个步骤,有两个选择</p>
<ul>
<li>在fcnt1中使用F_SETFL命令并且启用文件标志O_ASYNO</li>
<li>在ioctl中使用FI命令</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第16章 网络IPC：套接字 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 进程间通信</title>
    <link href="https://www.liuin.cn/2018/05/04/APUE-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://www.liuin.cn/2018/05/04/APUE-进程间通信/</id>
    <published>2018-05-04T06:00:08.000Z</published>
    <updated>2018-05-04T13:42:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第15章 进程间通信 笔记</p>
<a id="more"></a>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道是UNX系统IPC的最古老形式,所有UNX系统都提供此种通信机制。</p>
<p>管道有以下两种局限性：</p>
<ol>
<li>历史上,它们是半双工的(即数据只能在一个方向上流动)。现在,某些系统提供全双工管道,但是为了最佳的可移植性,我们决不应预先假定系统支持全双工管道</li>
<li>管道只能在具有公共祖先的两个进程之间使用。通常,一个管道由一个进程创建,在进程调用fork之后,这个管道就能在父进程和子进程之间使用了。</li>
</ol>
<p>每当在管道中键入一个命令序列,让shell执行时,shell都会为每一条命令单独创建一个进程,然后用管道将前一条命令进程的标准输出与后一条命令的标准输入相连接。</p>
<p>管道是通过调用pipe函数创建的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</div><div class="line"></div><div class="line">Returns: <span class="number">0</span> <span class="keyword">if</span> OK, −<span class="number">1</span> on error</div></pre></td></tr></table></figure>
<p>经由参数fd返回两个文件描述符:fd[0]为读而打开,fd[1]为写而打开。fd[1]的输出是fd[0]的输入。</p>
<p>单个进程中的管道几乎没有任何用处。通常,进程会先调用pipe,接着调用fork,从而创建从父进程到子进程的IPC通道,反之亦然</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254214499352.jpg" alt=""></p>
<h2 id="函数popen和pclose"><a href="#函数popen和pclose" class="headerlink" title="函数popen和pclose"></a>函数popen和pclose</h2><p>常见的操作是创建一个连接到另一个进程的管道,然后读其输出或向其输入端发送数据,为此,标准I/O库提供了两个函数 popen和 pclose。这两个函数实现的操作是:创建一个管道,fork一个子进程,关闭未使用的管道端,执行一个shell运行命令,然后等待命令终止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">`<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function">FILE *<span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</div><div class="line"><span class="comment">// Returns: ﬁle pointer if OK, NULL on error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *fp)</span></span>; </div><div class="line"><span class="comment">// Returns: termination status of cmdstring, or −1 on error</span></div></pre></td></tr></table></figure>
<p>函数 popen先执行fork,然后调用exec执行cstring,并且返回一个标准I/O文件指针。如果type是”r”,则文件指针连接到cstring的标准输出。如果type是”w”,则文件指针连接到 cmdstring的标准输入，表示写FILE中的东西</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254216672075.jpg" alt=""></p>
<p>可以将最后一个参数的使用方法和fopen类比，如果type是”r”,则返回的文件指针是可读的,如果type是”w”,则是可写的</p>
<h2 id="协同进程"><a href="#协同进程" class="headerlink" title="协同进程"></a>协同进程</h2><p>UNIX系统过滤程序从标准输入读取数据,向标准输出写数据。几个过滤程序通常在shell管道中线性连接。当一个过滤程序既产生某个过滤程序的输入,又读取该过滤程序的输出时,它就变成了协同进程(coprocess)。</p>
<p>协同进程通常在shell的后台运行,其标准输入和标准输出通过管道连接到另一个程序。</p>
<p>popen只提供连接到另一个进程的标准输入或标准输出的一个单向管道,而协同进程则有连接到另一个进程的两个单向管道:一个接到其标准输入,另一个则来自其标准输出。</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254220325027.jpg" alt=""></p>
<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>FIFO有时被称为命名管道。未命名的管道只能在两个相关的进程之间使用,而且这两个相关的进程还要有一个共同的创建了它们的祖先进程。但是,通过FIFO,不相关的进程也能交换数据。</p>
<p>FIFO是一种文件类型。通过stat结构的st<em>mode成员的编码可以知道文件是否是FIFO类型。可以用S</em> ISFTEO宏对此进行测试。</p>
<p>创建FIFO类似于创建文件。确实,FIFO的路径名存在于文件系统中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>当我们用 mkfifo或者 mkfifoat创建FIFO时,要用open来打开它。设置非阻塞以及对错误的处理和普通文件的处理是一样的。</p>
<p>FIFO有以下两种用途</p>
<ul>
<li>shell命令使用FIFO将数据从一条管道传送到另一条时,无需创建中间临时文件</li>
<li>客户进程服务器进程应用程序中,FIFO用作汇聚点,在客户进程和服务器进程二者之间传递数据</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-05-04-15254224287657.jpg" alt=""></p>
<h2 id="XSI-IPC"><a href="#XSI-IPC" class="headerlink" title="XSI IPC"></a>XSI IPC</h2><p>有3种称作XSI IPC的IPC:消息队列、信号量以及共享存储器。它们之间有很多相似之处</p>
<h3 id="标识符与键"><a href="#标识符与键" class="headerlink" title="标识符与键"></a>标识符与键</h3><p>每个内核中的IPC结构(消息队列、信号量或共享存储段)都用一个非负整数的标识符(identifier)加以引|用。</p>
<p>标识符是IPC对象的内部名。为使多个合作进程能够在同一IPC对象上汇聚,需要提供一个外部命名方案。为此,每个IPC对象都与一个键(key)相关联,将这个键作为该对象的外部名。键的数据结构是<code>key_t</code></p>
<p>有多种方法使客户进程和服务器进程在同一IPC结构上汇聚：</p>
<ol>
<li>服务器进程可以指定键IPC_PRIVATE创建一个新IPC结构,将返回的标识符存放在某处(如一个文件)以便客户进程取用。</li>
<li>可以在一个公用头文件中定义一个客户进程和服务器进程都认可的键。</li>
<li>客户进程和服务器进程认同一个路径名和项目ID，接着调用函数ftok将这两个值变成一个键</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">key_t</span> ftok(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> id);</div><div class="line"></div><div class="line"><span class="comment">// Returns: key if OK, (key_t)−1 on error</span></div></pre></td></tr></table></figure>
<h3 id="权限结构"><a href="#权限结构" class="headerlink" title="权限结构"></a>权限结构</h3><p>XSI IPC为每一个IPC结构关联了一个ipc_perm结构。该结构规定了权限和所有者,它至少包括下列成员:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct ipc_perm &#123; </div><div class="line">    uid_t uid; /* owner’s effective user ID */ </div><div class="line">    gid_t gid; /* owner’s effective group ID */ </div><div class="line">    uid_t cuid; /* creator’s effective user ID */ </div><div class="line">    gid_t cgid; /* creator’s effective group ID */ </div><div class="line">    mode_t mode; /* access modes */ </div><div class="line">    .</div><div class="line">    .</div><div class="line">    .</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在创建IPC结构时,对所有字段都赋初值。对于任何IPC结构都不存在执行权限</p>
<h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><p>XSI IPC的一个基本问题是:<strong>IPC结构是在系统范围内起作用的,没有引用计数</strong>。例如,如果进程创建了一个消息队列,并且在该队列中放入了几则消息,然后终止,那么该消息队列及其内容不会被删除。它们会一直留在系统中直至发生下列动作为止:由某个进程调用 msgrcv或msct1读消息或删除消息队列;或某个进程执行 ipcri(1)命令删除消息队列;或正在自举的系统删除消息队列。</p>
<p>将此与管道相比,当最后一个引用管道的进程终止时,管道就被完全地删除了。对于FIFO而言,在最后一个引用FIFO的进程终止时,虽然FIFO的名字仍保留在系统中,直至被显式地删除,但是留在FIFO中的数据已被删除了</p>
<p>XSI IPC的另一个问题是:这些IPC结构在文件系统中没有名字，为了支持这些IPC对象，系统增加了许多的系统调用</p>
<p>因为这些形式的IPC不使用文件描述符,所以<strong>不能对它们使用多路转接I/O函数</strong></p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是消息的链接表,存储在内核中,由消息队列标识符标识。</p>
<p><code>msgget</code>用于创建一个新队列或打开一个现有队列。<code>msgsnd</code>将新消息添加到队列尾端。每个消息包含一个正的长整型类型的字段、一个非负的长度以及实际数据字节数(对应于长度),所有这些都在将消息添加到队列时,传送给<code>msgsnd</code>。 <code>msgrcv</code>用于从队列中取消息。我们并不定要以先进先出次序取消息,也可以按消息的类型字段取消息。</p>
<p>每个队列有一个msqid_ds结构与其相关联</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254293881565.jpg" alt=""></p>
<p>创建一个队列或者打开一个现有队列函数<code>msgget</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: message queue ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>msgctl函数对队列执行多种操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf )</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>cmd参数指定对msqid队列要执行的命令：</p>
<ul>
<li>IPC_STAT  获取此队列的msqid_ds结构</li>
<li>IPC_SET  设置队列结构</li>
<li>IPC_RMID  从系统中删除该消息队列以及仍在该消息队列中的所有数据</li>
</ul>
<p>调用msgsnd将数据放到消息队列中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>消息类型结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> mymesg &#123; </div><div class="line">    <span class="keyword">long</span> mtype; <span class="comment">/* positive message type */</span> </div><div class="line">    <span class="keyword">char</span> mtext[<span class="number">512</span>]; <span class="comment">/* message data, of length nbytes */</span> </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>msgrcv从队列中取用消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> msgrcv(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes, <span class="keyword">long</span> type, <span class="keyword">int</span> ﬂag); </div><div class="line"></div><div class="line"><span class="comment">// Returns: size of data portion of message if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量与已经介绍过的IPC机构(管道、FIFO以及消息列队)不同。它是一个计数器,用于为多个进程提供对共享数据对象的访问</p>
<p>为了正确地实现信号量,信号量值的测试及减1操作应当是原子操作。为此,信号量通常是在内核中实现的</p>
<p>常用的信号量形式被称为二元信号量(binary semaphore)。它控制单个资源,其初始值为1。但是,一般而言,信号量的初值可以是任意一个正值,该值表明有多少个共享资源单位可供共享应用。</p>
<p>下面3个特性造成了XSI信号量比较复杂：</p>
<ol>
<li>信号量并非是单个非负值,而必需定义为含有一个或多个信号量值的集合。</li>
<li>信号量的创建(semget)是独立于它的初始化(sectl)的。这是一个致命的缺点,因为不能原子地创建一个信号量集合,并且对该集合中的各个信号量值赋初值。</li>
<li>即使没有进程正在使用各种形式的XSI IPO,它们仍然是存在的。有的程序在终止时并没有释放已经分配给它的信号量,所以我们不得不为这种程序担心。</li>
</ol>
<p>当我们想使用XSI信号量时,首先需要通过调用函数 semget来获得一个信号量ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: semaphore ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>semctl函数包含对信号量的各种操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ... <span class="comment">/* union semun arg */</span> )</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: (see following)</span></div></pre></td></tr></table></figure></p>
<p>函数semop自动执行信号集合上面的操作数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">struct</span> sembuf semoparray[], <span class="keyword">size_t</span> nops)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>参数 semoparray是一个指针,它指向一个由 sembuf结构表示的信号量操作数组:</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254305267397.jpg" alt=""></p>
<h2 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h2><p>共享存储允许两个或多个进程共享一个给定的存储区。因为数据不需要在客户进程和服务器进程之间复制,所以这是最快的一种IPC。使用共享存储时要掌握的唯一窍门是,在多个进程之间同步访问一个给定的存储区。若服务器进程正在将数据放入共享存储区,则在它做完这一操作之前,客户进程不应当去取这些数据。通常,信号量用于同步共享存储访问。</p>
<p>我们已经看到了共享存储的一种形式,就是在多个进程将同一个文件映射到它们的地址空间的时候。XSI共享存储和内存映射的文件的不同之处在于,前者没有相关的文件。XSI共享存储段是内存的匿名段</p>
<p>内核为每一个共享存储段维护一个结构，包含以下成员：</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254405323155.jpg" alt=""></p>
<p>使用函数shmgget获取一个共享存储标识符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: shared memory ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>函数shmctl对共享存储段执行多种操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf )</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>一旦创建了一个共享存储段,进程就可调用 shmat将其连接到它的地址空间中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to shared memory segment if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>共享存储段连接到调用进程的哪个地址上与addr参数以及flag中是否指定SHM_RND位有关</p>
<ul>
<li>如果addr为0,则此段连接到由内核选择的第一个可用地址上。这是推荐的使用方式。</li>
<li>如果add非0,并且没有指定 SHM_RND,则此段连接到addr所指定的地址上。</li>
<li>如果add非0,并且指定了 SHM_RND,则此段连接到(addr-( addr mod SHMLBA))所表示的地址上。 SHM_RND命令的意思是“取整”。 SHMLBA的意思是“低边界地址倍数”,它总是2的乘方。该算式是将地址向下取最近1个 SHMLBA的倍数。</li>
</ul>
<p>当对共享存储段的操作已经结束时,则调用 shmdt与该段分离。注意,这<strong>并不从系统中删除其标识符以及其相关的数据结构</strong>。该标识符仍然存在,直至某个进程(一般是服务器进程)带IPC_RMID命令的调用shmctl特地删除它为止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *addr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>回忆一下mmap函数,它可将一个文件的若干部分映射至进程地址空间。这在概念上类似于用 shmat XSI IPC函数连接一个共享存储段。两者之间的主要区别是,用mmap映射的存储段是与文件相关联的,而XSI共享存储段则并无这种关联。</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254410116645.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第15章 进程间通信 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 高级I/O</title>
    <link href="https://www.liuin.cn/2018/05/04/APUE-%E9%AB%98%E7%BA%A7I-O/"/>
    <id>https://www.liuin.cn/2018/05/04/APUE-高级I-O/</id>
    <published>2018-05-04T02:25:32.000Z</published>
    <updated>2018-05-04T05:45:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第14章 高级I/O 笔记</p>
<a id="more"></a>
<h2 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h2><p>将系统调用分成两类:“低速”系统调用和其他。低速系统调用是可能会<strong>使进程永远阻塞的一类系统调用</strong>,包括:</p>
<ul>
<li>如果某些文件类型(如读管道、终端设备和网络设备)的数据并不存在,读操作可能会使调用者永远阻塞;</li>
<li>如果数据不能被相同的文件类型立即接受(如管道中无空间、网络流控制),写操作可能会使调用者永远阻塞</li>
<li>在某种条件发生之前打开某些文件类型可能会发生阻塞(如要打开一个终端设备,需要先等待与之连接的调制解调器应答,又如若以只写模式打开FIFO,那么在没有其他进程已用读模式打开该FIFO时也要等待)</li>
<li>对已经加上强制性记录锁的文件进行读写</li>
<li>某些ioctl操作;</li>
<li>某些进程间通信函数</li>
</ul>
<p>虽然读写磁盘文件会暂时阻塞调用者,但并不能将与磁盘I/O有关的系统调用视为“低速”。</p>
<p>非阻塞IO使我们可以发出open、read和 write这样的IO操作,并使这些操作不会永远阻塞。如果这种操作不能完成,则调用立即出错返回,表示该操作如继续执行将阻塞。</p>
<p>对于一个给定的描述符,有两种为其指定非阻塞I/O的方法。</p>
<ol>
<li>如果调用open获得描述符,则可指定<code>O_NONBLOCK</code>标志</li>
<li>对于已经打开的一个描述符,则可调用<code>fcntl</code>,由该函数打开<code>O_NONBLOCK</code>文件状态标志</li>
</ol>
<h2 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h2><p>记录锁(record locking)的功能是：当第一个进程正在读或修改文件的某个部分时,使用记录锁可以阻止其他进程修改同一文件区。对于UNIX系统而言,“记录”这个词是一种误用,因为UNIX系统内核根本没有使用文件记录这种概念。一个更适合的术语可能是字节范围锁(byte-range locking),因为它锁定的只是文件中的一个区域(也可能是整个文件)</p>
<p>设置记录锁的方法是使用fcntl函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* struct flock *ﬂockptr */</span> )</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: depends on cmd if OK (see following), −1 on error</span></div></pre></td></tr></table></figure></p>
<p>对于记录锁,cmd是<code>F_GETLK</code>、<code>F_SELK</code>或<code>F_SETLKW</code>。第三个参数(我们将调用<code>flockptr</code>)是一个指向flock结构的指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct flock &#123; </div><div class="line">    short l_type; /* F_RDLCK, F_WRLCK, or F_UNLCK */ </div><div class="line">    short l_whence; /* SEEK_SET, SEEK_CUR, or SEEK_END */ </div><div class="line">    off_t l_start; /* offset in bytes, relative to l_whence */ </div><div class="line">    off_t l_len; /* length, in bytes; 0 means lock to EOF */ </div><div class="line">    pid_t l_pid; /* returned with F_GETLK */ </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>flock结构说明如下：</p>
<ul>
<li>所希望的锁类型:<code>F_RDLCK</code>(共享读锁)、<code>F_WRLCK</code>(独占性写锁)或<code>F_UNLCK</code>(解锁个区域)。</li>
<li>要加锁或解锁区域的起始字节偏移量(<code>l_start</code>和<code>l_whence</code>)。</li>
<li>区域的字节长度(1_1en)。</li>
<li>进程的ID(l_pid)持有的锁能阻塞当前进程(仅由F_GETLK返回)</li>
</ul>
<p>上面提到了两种类型的锁:共享读锁和独占性写锁。基本规则是:任意多个进程在一个给定的字节上可以有一把共享的读锁,但是在一个给定字节上只能有一个进程有把独占写锁。</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254024702844.jpg" alt=""></p>
<p>在设置或释放文件上的一把锁时,系统按要求组合或分裂相邻区。其中一个部分解锁的时候进程分裂，再次将这个区域加锁的时候进行合并。</p>
<blockquote>
<p>锁的隐含继承和释放</p>
</blockquote>
<p>关于记录锁的自动继承和释放有3条规则：</p>
<ol>
<li>锁与进程和文件两者相关联。这有两重含义:第一重很明显,当一个进程终止时,它所建立的锁全部释放;第二重则不太明显,无论一个描述符何时关闭,<strong>该进程通过这一描述符引用的文件上的任何一把锁都会释放</strong>(这些锁都是该进程设置的)。</li>
<li>由fork产生的子进程不继承父进程所设置的锁</li>
<li>在执行exec后,新程序可以继承原执行程序的锁。但是注意,如果对一个文件描述符设置了执行时关闭标志,那么当作为exec的一部分关闭该文件描述符时,将释放相应文件的所有锁。</li>
</ol>
<blockquote>
<p>FreeBSD实现</p>
</blockquote>
<p><img src="https://data2.liuin.cn/2018-05-04-15254027539830.jpg" alt=""></p>
<h2 id="I-O多路转接"><a href="#I-O多路转接" class="headerlink" title="I/O多路转接"></a>I/O多路转接</h2><p>有的时候我们需要从多个文件描述符读的时候，我们不能在任一个描述符上进行阻塞读(read),否则可能会因为被阻塞在一个描述符的读操作上而导致另一个描述符即使有数据也无法处理。</p>
<p>一种比较好的技术是使用I/O多路转接(I/O multiplexing)。为了使用这种技术,先构造一张我们感兴趣的描述符(通常都不止一个)的列表,然后调用一个函数,直到这些描述符中的一个已准备好进行I/O时,该函数才返回。</p>
<h3 id="函数select和pselect"><a href="#函数select和pselect" class="headerlink" title="函数select和pselect"></a>函数select和pselect</h3><p>在所有POSIX兼容的平台上, select函数使我们可以执行I/O多路转接。传给se1ect的参数告诉内核:</p>
<ul>
<li>我们所关心的描述符:</li>
<li>对于每个描述符我们所关心的条件(是否想从一个给定的描述符读,是否想写一个给定的描述符,是否关心一个给定描述符的异常条件)</li>
<li>愿意等待多长时间(可以永远等待、等待一个固定的时间或者根本不等待)</li>
<li>从se1ect返回时,内核告诉我们已准备好的描述符的总数量</li>
<li>对于读、写或异常这3个条件中的每一个,哪些描述符已准备好</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *<span class="keyword">restrict</span> readfds, fd_set *<span class="keyword">restrict</span> writefds, fd_set *<span class="keyword">restrict</span> exceptfds, <span class="keyword">struct</span> timeval *<span class="keyword">restrict</span> tvptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, −1 on error</span></div></pre></td></tr></table></figure>
<p>中间3个参数 readfds、 writefds和exceptfds是指向描述符集的指针。这3个描述符集说明了我们关心的可读、可写或处于异常条件的描述符集合。每个描述符集存储在一个<code>fd_set</code>数据类型中。这个数据类型是由实现选择的,它可以为每一个可能的描述符保持一位。</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254037628736.jpg" alt=""></p>
<p>对于<code>fd_set</code>数据类型,唯一可以进行的处理是:分配一个这种类型的变量,将这种类型的一个变量值赋给同类型的另一个变量,或对这种类型的变量使用下列4个函数中的一个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</div><div class="line"><span class="comment">// Returns: nonzero if fd is in set, 0 otherwise</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;</div></pre></td></tr></table></figure>
<p>另外一个select函数的变体pselect：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pselect</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *<span class="keyword">restrict</span> readfds, fd_set *<span class="keyword">restrict</span> writefds, fd_set *<span class="keyword">restrict</span> exceptfds, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> sigmask)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, −1 on error</span></div></pre></td></tr></table></figure>
<p>和select的不同点在于：</p>
<ul>
<li>超时使用的数据结构不一样，能够提供更加精准的超时时间</li>
<li>超时值被声明为const，保证了pselect不会改变这一个值</li>
<li>可使用可选信号屏蔽字</li>
</ul>
<h3 id="函数poll"><a href="#函数poll" class="headerlink" title="函数poll"></a>函数poll</h3><p>poll函数和select差不多，就是函数的接口不一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd fdarray[], <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: count of ready descriptors, 0 on timeout, −1 on error</span></div></pre></td></tr></table></figure>
<p>与 select不同,pol1不是为每个条件(可读性、可写性和异常条件)构造一个描述符集,而是构造一个po11fd结构的数组,每个数组元素指定一个描述符编号以及我们对该描述符感兴趣的条件。</p>
<h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h2><p>在用异步I/O的时候,要通过选择来灵活处理多个并发操作,这会使应用程序的设计复杂化。更简单的做法可能是使用多线程,使用同步模型来编写程序,并让这些线程以异步的方式运行。</p>
<p>使用POSIX异步I/O接口，会带来这些麻烦：</p>
<ul>
<li>每个异步操作有3处可能产生错误的地方:一处在操作提交的部分,一处在操作本身的结果,还有一处在用于决定异步操作状态的函数中。</li>
<li>设计大量额外的设置和处理规则</li>
<li>从错误中恢复会比较困难</li>
</ul>
<h2 id="函数readv和writev"><a href="#函数readv和writev" class="headerlink" title="函数readv和writev"></a>函数readv和writev</h2><p>readv和 writev函数用于在一次函数调用中读、写多个非连续缓冲区。有时也将这两个函数称为散布读(scatter read)和聚集写(gather write)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> readv(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">struct</span> iovec *iov, <span class="keyword">int</span> iovcnt);</div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> writev(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">struct</span> iovec *iov, <span class="keyword">int</span> iovcnt);</div><div class="line"></div><div class="line"><span class="comment">// Both return: number of bytes read or written, −1 on error</span></div></pre></td></tr></table></figure>
<p>其中中间参数的数据结构iov如下：</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254044988663.jpg" alt=""></p>
<h2 id="函数readn和writen"><a href="#函数readn和writen" class="headerlink" title="函数readn和writen"></a>函数readn和writen</h2><p>管道、FIFO以及某些设备(特别是终端和网络)有下列两种性质</p>
<ol>
<li>一次read操作所返回的数据可能少于所要求的数据,即使还没达到文件尾端也可能是这样。这不是一个错误,应当继续读该设备。</li>
<li>一次 write操作的返回值也可能少于指定输出的字节数。</li>
</ol>
<p>下面两个函数 readn和 writen的功能分别是读、写指定的N字节数据,并处理返回值可能小于要求值的情况。这两个函数只是按需多次调用xead和 write直至读、写了N字节数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span> </span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); </div><div class="line"><span class="keyword">ssize_t</span> writen(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); </div><div class="line"></div><div class="line"><span class="comment">// Both return: number of bytes read or written, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="存储映射I-O"><a href="#存储映射I-O" class="headerlink" title="存储映射I/O"></a>存储映射I/O</h2><p>存储映射I/O(memory-mapped I/O)能<strong>将一个磁盘文件映射到存储空间中的一个缓冲区上</strong>。于是,当从缓冲区中取数据时,就相当于读文件中的相应字节。与此类似,将数据存入缓冲区时相应字节就自动写入文件。这样,就可以在不使用read和 write的情况下执行I/O。</p>
<p>为了使用这种功能,应首先告诉内核将一个给定的文件映射到一个存储区域中。这是由mmap函数实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> ﬂag, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> off )</span></span>; </div><div class="line"><span class="comment">// Returns: starting address of mapped region if OK, MAP_FAILED on error</span></div></pre></td></tr></table></figure>
<p>addr参数用于指定映射存储区的起始地址。通常将其设置为0,这表示由系统选择该映射区的起始地址。此函数的返回值是该映射区的起始地址。</p>
<p>fd参数是指定要被映射文件的描述符。在文件映射到地址空间之前,必须先打开该文件。len参数是映射的字节数,off是要映射字节在文件中的起始偏移量</p>
<p>prot参数指定了映射存储区的保护要求</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254123464536.jpg" alt=""></p>
<p>存储映射文件的基本情况</p>
<p><img src="https://data2.liuin.cn/2018-05-04-15254124013724.jpg" alt=""></p>
<p>flag参数可以使用的属性：</p>
<ul>
<li>MAP_FIXED  返回值必须等于addr。因为这不利于可移植性,所以不鼓励使用此标志。</li>
<li>MAP_SHARED  这一标志描述了本进程对映射区所进行的存储操作的配置。此标志指定存储操作修改映射文件,也就是,存储操作相当于对该文件的 write</li>
<li>MAP_PRIVATE  本标志说明,对映射区的存储操作导致创建该映射文件的一个私有副本</li>
</ul>
<p>off的值和addr的值(如果指定了 MAP_FIXED)通常被要求是系统虚拟存储页长度的倍数</p>
<p>与映射区相关的信号有 SIGSEGV和 SIGBUS:</p>
<ul>
<li>信号 SIGSEGV通常用于指示进程试图访问对它不可用的存储区。如果映射存储区被map指定成了只读的,那么进程试图将数据存入这个映射存储区的时候,也会产生此信号。</li>
<li>如果映射区的某个部分在访问时已不存在,则产生 SIGBUS信号。例如,假设用文件长度映射了一个文件,但在引用该映射区之前,另一个进程已将该文件截断。此时,如果进程试图访问对应于该文件已截去部分的映射区,将会接收到 SIGBUS信号</li>
</ul>
<p><strong>子进程能通过fork继承存储映射区</strong>(因为子进程复制父进程地址空间,而存储映射区是该地址空间的一个部分），新程序则不能通过exec继承存储映射区</p>
<p>调用mprotect可以更改一个现有映射的权限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>如果共享映射中的页已修改,那么可以调用 msync将该页冲洗到被映射的文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> ﬂags)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>如果映射是私有的,那么不修改被映射的文件。与其他存储映射函数一样,地址必须与页边界对齐。</p>
<p>当进程终止时,会自动解除存储映射区的映射,或者直接调用 munmap函数也可以解除映射区。关闭映射存储区时使用的文件描述符并不解除映射区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第14章 高级I/O 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 守护进程</title>
    <link href="https://www.liuin.cn/2018/05/04/APUE-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
    <id>https://www.liuin.cn/2018/05/04/APUE-守护进程/</id>
    <published>2018-05-04T01:06:24.000Z</published>
    <updated>2018-05-04T01:35:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第13章 守护进程 笔记</p>
<a id="more"></a>
<p>守护进程(daemon)是生存期长的一种进程。它们常常在系统引导装入时启动,仅在系统关闭时才终止。因为它们没有控制终端,所以说它们是在后台运行的。UNIX系统有很多守护进程,它们执行日常事务活动。</p>
<h2 id="守护进程的特征"><a href="#守护进程的特征" class="headerlink" title="守护进程的特征"></a>守护进程的特征</h2><p>系统进程依赖于操作系统实现。父进程ID为0的各进程通常是内核进程,它们作为系统引导装入过程的一部分而启动。(init是个例外,它是一个由内核在引导装入时启动的用户层次的命令。)内核进程是特殊的,通常存在于系统的整个生命期中。它们以超级用户特权运行,无控制终端,无命令行。</p>
<p>对于需要在进程上下文执行工作但却不被用户层进程上下文调用的每一个内核组件,通常有它自己的内核守护进程。例如,在Linux中</p>
<ul>
<li><code>kswapd</code>守护进程也称为内存换页守护进程。它支持虚拟内存子系统在经过一段时间后将脏页面慢慢地写回磁盘来回收这些页面</li>
<li><code>f1ush</code>守护进程在可用内存达到设置的最小阅值时将脏页面冲洗至磁盘。它也定期地将脏页面冲洗回磁盘来减少在系统出现故障时发生的数据丢失。多个冲洗守护进程可以同时存在,每个写回的设备都有一个冲洗守护进程。</li>
<li><code>sync_supers</code>守护进程定期将文件系统元数据冲洗至磁盘。</li>
<li><code>jbd</code>守护进程帮助实现了ext4文件系统中的日志功能。</li>
<li><code>cron</code>守护进程在定期安排的日期和时间执行命令。许多系统管理任务是通过<code>cron</code>每隔一段固定的时间就运行相关程序而得以实现的。</li>
<li><code>atd</code>守护进程与cron类似,它允许用户在指定的时间执行任务,但是每个任务它只执行一次,而非在定期安排的时间反复执行。</li>
<li><code>cupsa</code>守护进程是个打印假脱机进程,它处理对系统提出的各个打印请求。</li>
<li><code>sshd</code>守护进程提供了安全的远程登录和执行设施注意,大多数守护进程都以超级用户(root)特权运行。所有的守护进程都没有控制终端其终端名设置为问号。</li>
</ul>
<p>内核守护进程以无控制终端方式启动。用户层守护进程缺少控制终端可能是守护进程调用了 setid的结果。</p>
<h2 id="编程规则"><a href="#编程规则" class="headerlink" title="编程规则"></a>编程规则</h2><p>在编写守护进程程序时需遵循一些基本规则,以防止产生不必要的交互作用。下面先说明这些规则,</p>
<ol>
<li>首先要做的是调用<code>umask</code>将文件模式创建屏蔽字设置为一个已知值(通常是0)。由继承得来的文件模式创建屏蔽字可能会被设置为拒绝某些权限。如果守护进程要创建文件,那么它可能要设置特定的权限。</li>
<li>调用fork,然后使父进程exit。这样做实现了下面几点。第一,如果该守护进程是作为一条简单的shell命令启动的,那么父进程终止会让shell认为这条命令已经执行完毕。第二,虽然子进程继承了父进程的进程组ID,但获得了一个新的进程ID,这就保证了子进程不是一个进程组的组长进程。这是下面将要进行的setid调用的先决条件。</li>
<li>调用setid创建一个新会话，执行3步：成为新会话的首进程、成为新进程组的组长进程、没有控制终端</li>
<li>将当前工作目录更改为根目录</li>
<li>关闭不再需要的文件描述符</li>
<li>某些守护进程打开<code>/dev/null</code>使其具有文件描述符0、1和2,这样,任何一个试图读标准输入、写标准输出或标准错误的库例程都不会产生任何效果。因为守护进程并不与终端设备相关联所以其输出无处显示,也无处从交互式用户那里接收输入。</li>
</ol>
<h2 id="出错记录"><a href="#出错记录" class="headerlink" title="出错记录"></a>出错记录</h2><p>守护进程存在的一个问题是如何处理出错消息。因为它本就不应该有控制终端,所以不能只是简单地写到标准错误上。我们不希望所有守护进程都写到控制台设备上,因为在很多工作站上控制台设备都运行着一个窗口系统。我们也不希望每个守护进程将它自己的出错消息写到一个单独的文件中。对任何一个系统管理人员而言,如果要关心哪一个守护进程写到哪一个记录文件中并定期地检查这些文件,那么一定会使他感到头痛。所以,需要有一个集中的守护进程出错记录设施。</p>
<p>BSD的<code>sys1og</code>设施得到了广泛的应用。大多数守护进程都使用这一设施</p>
<p>有下面3种产生日志消息的方法：</p>
<ol>
<li>内核例程可以调用log函数</li>
<li>大多数用户进程(守护进程)调用sys1og(3)函数来产生日志消息</li>
<li>无论一个用户进程是在此主机上,还是在通过TCP/IP网络连接到此主机的其他主机上,都可将日志消息发向UDP端口514。</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-05-04-15253968653919.jpg" alt=""></p>
<p>通常, syslogd守护进程读取所有3种格式的日志消息。此守护进程在启动时读一个配置文件,其文件名一般为<code>/etc/sys1og.conf</code>,该文件决定了不同种类的消息应送向何处。例如,紧急消息可发送至系统管理员(若已登录),并在控制台上打印,而警告消息则可记录到一个文件中。</p>
<p>该设施的接口是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">openlog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ident, <span class="keyword">int</span> option, <span class="keyword">int</span> facility)</span></span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">(<span class="keyword">void</span>)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setlogmask</span><span class="params">(<span class="keyword">int</span> maskpri)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: previous log priority mask value</span></div></pre></td></tr></table></figure></p>
<h2 id="单实例守护进程"><a href="#单实例守护进程" class="headerlink" title="单实例守护进程"></a>单实例守护进程</h2><p>为了正常运作,某些守护进程会实现为,在任一时刻只运行该守护进程的一个副本。例如,这种守护进程可能需要排它地访问一个设备。对cron守护进程而言,如果同时有多个实例运行,那么每个副本都可能试图开始某个预定的操作,于是造成该操作的重复执行,这很可能导致出错。</p>
<p>文件和记录锁机制为一种方法提供了基础,该方法保证一个守护进程只有一个副本在运行。</p>
<h2 id="守护进程的惯例"><a href="#守护进程的惯例" class="headerlink" title="守护进程的惯例"></a>守护进程的惯例</h2><p>在UNIX系统中,守护进程遵循下列通用惯例：</p>
<ol>
<li>若守护进程使用锁文件,那么该文件通常存储在<code>/var/run</code>目录中</li>
<li>若守护进程支持配置选项,那么配置文件通常存放在<code>/etc</code>目录中</li>
<li>守护进程可用命令行启动,但通常它们是由系统初始化脚本之一(<code>/etc/rc*</code>或<code>etc/init.d/*</code>)启动的。如果在守护进程终止时,应当自动地重新启动它,则我们可在<code>/etc/inittab</code>中为该守护进程包括 respawn记录项,这样,init就将重新启动该守护进程。</li>
<li>若一个守护进程有一个配置文件,那么当该守护进程启动时会读该文件,但在此之后般就不会再查看它。若某个管理员更改了配置文件,那么该守护进程可能需要被停止,然后再启动,以使配置文件的更改生效。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第13章 守护进程 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 线程控制</title>
    <link href="https://www.liuin.cn/2018/05/02/APUE-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://www.liuin.cn/2018/05/02/APUE-线程控制/</id>
    <published>2018-05-02T09:15:42.000Z</published>
    <updated>2018-05-03T13:33:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第12章 线程控制 笔记</p>
<a id="more"></a>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>pthread接口允许我们通过设置每个对象关联的不同属性来细调线程和同步对象的行为。通常,管理这些属性的函数都遵循相同的模式</p>
<ul>
<li>每个对象与它自己类型的属性对象进行关联</li>
<li>有一个初始化函数,把属性设置为默认值。</li>
<li>还有一个销毁属性对象的函数。</li>
<li>每个属性都有一个从属性对象中获取属性值的函数</li>
<li>每一个属性都有一个设置属性值的函数</li>
</ul>
<p>可以使用<code>pthread_attr_t</code>结构修改线程默认属性,并把这些属性与创建的线程联系起来。可以使用 <code>pthread_attr_init</code>函数初始化<code>pthread_attr_t</code>结构。在调用<code>pthread_attr_init</code>以后, <code>pthread_attr_t</code>结构所包含的就是操作系统实现支持的所有线程属性的默认值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>POSIX.1定义的线程属性：</p>
<p><img src="https://data2.liuin.cn/2018-05-02-15252530369029.jpg" alt=""></p>
<p>对<code>detachstate</code>属性进行管理的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *detachstate)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> detachstate)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>对线程栈属性进行管理的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstack</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">void</span> **<span class="keyword">restrict</span> stackaddr, <span class="keyword">size_t</span> *<span class="keyword">restrict</span> stacksize)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstack</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *stackaddr, <span class="keyword">size_t</span> stacksize)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>对于进程来说,虚地址空间的大小是固定的。因为进程中只有一个栈,所以它的大小通常不是问题。但对于线程来说,同样大小的虚地址空间必须被所有的线程栈共享。如果应用程序使用了许多线程,以致这些线程栈的累计大小超过了可用的虚地址空间,就需要减少默认的线程栈大小。</p>
<p>另一方面,如果线程调用的函数分配了大量的自动变量,或者调用的函数涉及许多很深的栈帧(stack frame),那么需要的栈大小可能要比默认的大。</p>
<p>如果线程栈的虚地址空间都用完了,那可以使用ma1loc或者mnap来为可替代的栈分配空间,并用<code>pthread _attr__setstack</code>函数来改变新建线程的栈位置。</p>
<p>管理线程属性<code>stacksize</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstacksize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">size_t</span> *<span class="keyword">restrict</span> stacksize)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstacksize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> stacksize)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>如果希望改变默认的栈大小,但又不想自己处理线程栈的分配问题,这时使用 <code>pthread_attr_setstacksize</code>函数就非常有用。</p>
<p>管理线程属性<code>guardsize</code>属性的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getguardsize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">size_t</span> *<span class="keyword">restrict</span> guardsize)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setguardsize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> guardsize)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h2 id="同步属性"><a href="#同步属性" class="headerlink" title="同步属性"></a>同步属性</h2><h3 id="互斥量属性"><a href="#互斥量属性" class="headerlink" title="互斥量属性"></a>互斥量属性</h3><p>互斥量属性是用<code>pthread_mutexattr_t</code>结构表示的，其初始化和销毁函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>值得注意的3个属性是:进程共享属性、健壮属性以及类型属性</p>
<p>存在这样的机制:允许相互独立的多个进程把同一个内存数据块映射到它们各自独立的地址空间中。就像多个线程访问共享数据一样,多个进程访问共享数据通常也需要同步。如果进程共享互斥量属性设置为<code>PTHREAD_PROCESS_SHARED</code>,从多个进程彼此之间共享的内存数据块中分配的互斥量就可以用于这些进程的同步</p>
<p>获得和修改进程共享属性的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>进程共享互斥量属性设置为<code>PTHREAD_PROCESS_PRIVATE</code>时,允许pthread线程库提供更有效的互斥量实现,这在多线程应用程序中是默认的情况。在多个进程共享多个互斥量的情况下,pthread线程库可以限制开销较大的互斥量实现。</p>
<p>互斥量健壮属性与在多个进程间共享的互斥量有关。这意味着,当持有互斥量的进程终止时需要解决互斥量状态恢复的问题。这种情况发生时,互斥量处于锁定状态,恢复起来很困难。</p>
<p>获取和设置互斥量健壮属性的函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getrobust</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> robust)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setrobust</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> robust)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure></p>
<h3 id="读写锁属性"><a href="#读写锁属性" class="headerlink" title="读写锁属性"></a>读写锁属性</h3><p>读写锁和互斥量类似，都有属性，用数据结构<code>pthread_rwlockattr_t</code>表示，初始化和反初始化函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_init</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_destroy</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>读写锁支持的唯一属性是进程共享属性。它与互斥量的进程共享属性是相同的。有一对函数用于读取和设置读写锁的进程共享属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_setpshared</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="条件变量属性"><a href="#条件变量属性" class="headerlink" title="条件变量属性"></a>条件变量属性</h3><p>目前定义了条件变量的两个属性:<strong>进程共享属性和时钟属性</strong>，用数据结构<code>pthread_condattr_t</code>表示，初始化和反初始化函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_init</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_destroy</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>获取和设置进程共享属性的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_setpshared</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>时钟属性控制计算<code>pthread_cond_timedwait</code>函数的超时参数(sp)时采用的是哪个时钟，相关函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_getclock</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">clockid_t</span> *<span class="keyword">restrict</span> clock_id)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_setclock</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr, <span class="keyword">clockid_t</span> clock_id)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="屏障属性"><a href="#屏障属性" class="headerlink" title="屏障属性"></a>屏障属性</h3><p>初始化和反初始化函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_init</span><span class="params">(<span class="keyword">pthread_barrierattr_t</span> *attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_destroy</span><span class="params">(<span class="keyword">pthread_barrierattr_t</span> *attr)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>目前定义的屏障属性只有进程共享属性,它控制着屏障是可以被多进程的线程使用,还是只能被初始化屏障的进程内的多线程使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_barrierattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrierattr_setpshared</span><span class="params">(<span class="keyword">pthread_barrierattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h2 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h2><p>多个控制线程在相同的时间有可能调用相同的函数。如果一个函数在相同的时间点可以被多个线程安全地调用,就称该函数是线程安全的。</p>
<p>如果一个函数对多个线程来说是可重入的,就说这个函数就是线程安全的。但这并不能说明对信号处理程序来说该函数也是可重入的。如果函数对异步信号处理程序的重入是安全的,那么就可以说函数是异步信号安全的。</p>
<h2 id="线程特定数据"><a href="#线程特定数据" class="headerlink" title="线程特定数据"></a>线程特定数据</h2><p>线程特定数据( thread-specific data),也称为<strong>线程私有数据</strong>( thread-private data.),是存储和查询某个特定线程相关数据的一种机制。我们把这种数据称为线程特定数据或线程私有数据的原因是,我们希望每个线程可以访问它自己单独的数据副本,而不需要担心与其他线程的同步访问问题</p>
<p>设置线程私有数据的原因：</p>
<ol>
<li>有时候需要维护基于每线程(per-thread)的数据，即使线程ID确实是小而连续的整数,我们可能还希望有一些额外的保护,防止某个线程的数据与其他线程的数据相混淆。</li>
<li>它提供了让基于进程的接口适应多线程环境的机制。一个很明显的例子就是errno，以前的接口(线程出现以前)把errno定义为进程上下文中全局可访问的整数。系统调用和库例程在调用或执行失败时设置把它作为操作失败时的附属结果。为了让线程也能够使用那些原本基于进程的系统调用和库例程, errno被重新定义为线程私有数据。这样,一个线程做了重置 errno的操作也不会影响进程中其他线程的 errno值。</li>
</ol>
<p>在分配线程特定数据之前,需要创建与该数据关联的键。这个键将用于获取对线程特定数据的访问。使用 <code>pthread_key_create</code>创建一个键</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt; </div><div class="line"></div><div class="line">int pthread_key_create(pthread_key_t *keyp, void (*destructor)(void *)); </div><div class="line"></div><div class="line">// Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
<p>创建的键存储在keyp指向的内存单元中,这个键可以被进程中的所有线程使用,但<strong>每个线程把这个键与不同的线程特定数据地址进行关联</strong>。创建新键时,每个线程的数据地址设为空值。</p>
<p>除了创建键以外, pthread<em>key</em> create可以为该键关联一个可选择的析构函数。当这个线程退出时,如果数据地址已经被置为非空值,那么析构函数就会被调用,它唯一的参数就是该数据地址。如果传入的析构函数为空,就表明没有析构函数与这个键关联。</p>
<p>线程通常使用malloc为线程特定数据分配内存。析构函数通常释放已分配的内存。如果线程在没有释放内存之前就退出了,那么这块内存就会丢失,即线程所属进程就出现了内存泄漏。</p>
<p>线程退出时,线程特定数据的析构函数将按照操作系统实现中定义的顺序被调用。析构函数可能会调用另一个函数,该函数可能会创建新的线程特定数据,并且把这个数据与当前的键关联起来。当所有的析构函数都调用完成以后,系统会检查是否还有非空的线程特定数据值与键关联,如果有的话,再次调用析构函数。</p>
<p>对所有的线程,我们都可以通过调用<code>pthread_key_de1ete</code>来取消键与线程特定数据值之间的关联关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_delete</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>上述函数不会激活与键关联的析构函数</p>
<p>需要确保分配的键并不会由于在初始化阶段的竞争而发生变动。解决这种竞争的方法是使用<code>pthread_once</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line"></div><div class="line">pthread_once_t initﬂag = PTHREAD_ONCE_INIT;</div><div class="line"></div><div class="line">int pthread_once(pthread_once_t *initﬂag, void (*initfn)(void));</div><div class="line"></div><div class="line">// Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
<p>initflag必须是一个非本地变量(如全局变量或静态变量),而且必须初始化为<code>PTHREAD_ONCE_INIT</code>。如果每个线程都调用 pthread_once,系统就能保证初始化例程initfn只被调用一次,即系统首次调用 pthread_once时。</p>
<p>键一旦创建以后,就可以通过调用<code>pthread_setspecific</code>函数把键和线程特定数据关联起来。可以通过 <code>pthread_ getspecific</code>函数获得线程特定数据的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: thread-speciﬁc data value or NULL if no value has been associated with the key</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key, <span class="keyword">const</span> <span class="keyword">void</span> *value)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h2 id="取消选项"><a href="#取消选项" class="headerlink" title="取消选项"></a>取消选项</h2><p>有两个线程属性并没有包含在<code>pthread_attr_t</code>结构中,它们是可取消状态和可取消类型。这两个属性影响着线程在响应<code>pthread_ cancel</code>函数调用时所呈现的行为</p>
<p>可取消状态属性可以是<code>PTHREAD_CANCEL_ENABLE</code>,也可以是<code>PTHREAD_CANCEL_DISABLE</code>，线程可以通过调用`pthread_setcancel_state修改它的可取消状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcancelstate</span><span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span> *oldstate)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p><code>pthread_setcancel_state</code>把当前的可取消状态设置为state,把原来的可取消状态存储在由oldstate指向的内存单元,<strong>这两步是一个原子操作</strong>。</p>
<p><code>pthread_cancel</code>调用并不等待线程终止。在默认情况下,线程在取消请求发出以后还是继续运行,直到线程到达某个取消点。取消点是线程检查它是否被取消的一个位置,如果取消了,则按照请求行事。</p>
<p>线程启动时默认的可取消状态是<code>PTHREAD_CANCEL_ENABLE</code>。当状态设为<code>PTHREAD_CANCEL_DISABLE</code>时,对<code>pthread_cancel</code>的调用并不会杀死线程。相反,取消请求对这个线程来说还处于挂起状态,当取消状态变为<code>PTHREAD_CANCEL_ENABLE</code>时,线程将在下一个取消点上对所有挂起的取消请求进行处理</p>
<p>可以调用<code>pthread_testcancel</code>函数在程序中添加自己的取消点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_testcancel</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>默认的取消类型也称为推迟取消。调用<code>pthread_cancel</code>以后,在线程到达取消点之前,并不会出现真正的取消。可以通过调用<code>pthread_setcanceltype</code>来修改取消类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> *oldtype)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>有两种取消类型：推迟取消和异步取消，异步取消与推迟取消不同,因为使用异步取消时,线程可以在任意时间撤消,不是非得遇到取消点才能被取消</p>
<h2 id="线程和信号"><a href="#线程和信号" class="headerlink" title="线程和信号"></a>线程和信号</h2><p>每个线程都有自己的信号屏蔽字,但是信号的处理是进程中所有线程共享的。这意味着单个线程可以阻止某些信号,但当某个线程修改了与某个给定信号相关的处理行为以后,所有的线程都必须共享这个处理行为的改变。这样,如果一个线程选择忽略某个给定信号,那么另一个线程就可以通过以下两种方式撤消上述线程的信号选择:恢复信号的默认处理行为,或者为信号设置个新的信号处理程序</p>
<p>进程使用<code>sigprocmask</code>函数来阻止信号发送。线程使用的函数是<code>pthread_sigmask</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_sigmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> oset)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>pthread_sigmask函数与sigprocmask函数基本相同,不过pthread_sigmask工作在线程中,而且失败时返回错误码,不再像sigprocmask中那样设置errno并返回-1。set参数包含线程用于修改信号屏蔽字的信号集。how参数可以取下列3个值之一: SIG_BLOCK,把信号集添加到线程信号屏蔽字中, SIG_SETMASK,用信号集替换线程的信号屏蔽字;SIG_UNBLOCK,从线程信号屏蔽字中移除信号集。如果oset参数不为空,线程之前的信号屏蔽字就存储在它指向的siget_t结构中。线程可以通过把set参数设置为NULL,并把oser参数设置为si gset_t结构的地址,来获取当前的信号屏蔽字。这种情况中的how参数会被忽略</p>
<p>线程可以通过调用sigwait等待一个或多个信号的出现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigwait</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">int</span> *<span class="keyword">restrict</span> signop)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>set参数指定了线程等待的信号集。返回时, signop指向的整数将包含发送信号的数量</p>
<p>为了避免错误行为发生,线程在调用sigwait之前,必须阻塞那些它正在等待的信号</p>
<p>sigwait函数会原子地取消信号集的阻塞状态,直到有新的信号被递送</p>
<p>要把信号发送给进程,可以调用ki11。要把信号发送给线程,可以调用 pthread_kill<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_kill</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">int</span> signo)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure></p>
<h2 id="线程和fork"><a href="#线程和fork" class="headerlink" title="线程和fork"></a>线程和fork</h2><p>当线程调用fork时，就为子进程创建整个进程地址空间的副本</p>
<p>子进程通过继承整个地址空间的副本,还从父进程那儿继承了每个互斥量、读写锁和条件变量的状态。如果父进程包含一个以上的线程,子进程在fork返回以后,如果紧接着不是马上调用exec的话,就需要清理锁状态</p>
<p>在子进程内部,只存在一个线程,它是由父进程中调用fork的线程的副本构成的。</p>
<p>在多线程的进程中,为了避免不一致状态的问题, POSIX.1声明,在fork返回和子进程调用其中一个exec函数之间,子进程只能调用异步信号安全的函数。这就限制了在调用exec之前子进程能做什么,但不涉及子进程中锁状态的问题。</p>
<p>要清除锁状态，可以通过调用pthread_atfork函数建立fork处理程序</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt; </div><div class="line"></div><div class="line">int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void)); </div><div class="line"></div><div class="line">// Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
<p>用pthread_atfork函数最多可以安装3个帮助清理锁的函数。 <code>prepare_fork</code>处理程序由父进程在fork创建子进程前调用。这个fork处理程序的任务是<strong>获取父进程定义的所有锁</strong>。 <code>parent_fork</code>处理程序是在fork创建子进程以后、返回之前在父进程上下文中调用的。这个fok处理程序的任务是对<code>prepare_fork</code>处理程序获取的所有锁进行解锁。<code>child_fork</code>处理程序在fork返回之前在子进程上下文中调用。与 <code>parent_fork</code>处理程序一样, <code>child_fork</code>处理程序也必须释放<code>prepare_fork</code>处理程序获取的所有锁</p>
<h2 id="线程和I-O"><a href="#线程和I-O" class="headerlink" title="线程和I/O"></a>线程和I/O</h2><p>在多线程环境下，使用的都是pread和pwrite函数，这些函数都是源自操作，使得多线程下所有线程可以共享相同的文件描述符。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第12章 线程控制 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 线程</title>
    <link href="https://www.liuin.cn/2018/05/02/APUE-%E7%BA%BF%E7%A8%8B/"/>
    <id>https://www.liuin.cn/2018/05/02/APUE-线程/</id>
    <published>2018-05-02T06:34:59.000Z</published>
    <updated>2018-05-02T07:35:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第11章 线程 笔记</p>
<a id="more"></a>
<h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p>在程序设计时就可以把进程设计成在某一时刻能够做不止一件事,每个线程处理各自独立的任务。这种方法有很多好处。</p>
<ul>
<li>通过为每种事件类型分配单独的处理线程,可以简化处理异步事件的代码。每个线程在进行事件处理时可以采用同步编程模式,同步编程模式要比异步编程模式简单得多。</li>
<li>多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享，而多个线程自动地可以访问相同的存储地址空间和文件描述符</li>
<li>有些问题可以分解从而提高整个程序的吞吐量。在只有一个控制线程的情况下,一个单线程进程要完成多个任务,只需要把这些任务串行化。但有多个控制线程时,相互独立的任务的处理就可以交叉进行,此时只需要为每个任务分配一个单独的线程。</li>
<li>交互的程序同样可以通过使用多线程来改善响应时间,多线程可以把程序中处理用户输入输出的部分与其他部分分开。</li>
</ul>
<p>处理器的数量并不影响程序结构,所以不管处理器的个数多少,程序都可以通过使用线程得以简化。</p>
<p>每个线程都包含有表示执行环境所必需的信息,其中包括进程中标识线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、 errno变量以及线程私有数据</p>
<p>一个进程的所有信息对该进程的所有线程都是共享的,包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符</p>
<h2 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h2><p>就像每个进程有一个进程ID一样,每个线程也有一个线程ID。进程ID在整个系统中是唯一的,但线程ID不同,线程ID只有在它所属的进程上下文中才有意义。</p>
<p>线程ID是用pthread_t数据类型来表示的,实现的时候可以用一个结构来代表pthread_t数据类型,所以可移植的操作系统实现不能把它作为整数处理。因此必须使用一个函数来对两个线程ID进行比较:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> tid1, <span class="keyword">pthread_t</span> tid2)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: nonzero if equal, 0 otherwise</span></div></pre></td></tr></table></figure>
<p>线程可以通过调用 pthread_se1f函数获得自身的线程ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: the thread ID of the calling thread</span></div></pre></td></tr></table></figure>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>新增的线程可以通过调用 pthread_create函数创建。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt; </div><div class="line"></div><div class="line">int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(*start_rtn)(void *), void *restrict arg); </div><div class="line"></div><div class="line">// Returns: 0 if OK, error number on failure</div></pre></td></tr></table></figure>
<p>当pthread_create成功返回时,新创建线程的线程ID会被设置成<code>tidp</code>指向的内存单元，<code>attr</code>参数用于定制各种不同的线程属性。新创建的线程从<code>start_rtn</code>函数的地址开始运行,该函数只有一个无类型指针参数<code>arg</code>。如果需要向<code>start_run</code>函数传递的参数有一个以上,那么需要把这些参数放到一个结构中,然后把这个结构的地址作为<code>arg</code>参数传入</p>
<p>线程创建时并不能保证哪个线程会先运行:是新创建的线程,还是调用线程。新创建的线程可以访问进程的地址空间,并且继承调用线程的浮点环境和信号屏蔽字,但是该线程的挂起信号集会被清除。</p>
<p>注意, pthread函数在调用失败时通常会返回错误码,它们并不像其他的 POSIX函数一样设置 errno。每个线程都提供 errno的副本,这只是为了与使用 errno的现有函数兼容。</p>
<h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>单个线程可以通过3种方式退出,因此可以在不终止整个进程的情况下,停止它的控制流。</p>
<ol>
<li>线程可以简单地从启动例程中返回,返回值是线程的退出码。</li>
<li>线程可以被同一进程中的其他线程取消。</li>
<li>线程调用 pthread_ex1t</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *rval_ptr)</span></span>;</div></pre></td></tr></table></figure>
<p><code>rval_ptr</code>参数是一个无类型指针,与传给启动例程的单个参数类似。进程中的其他线程也可以通过调用 <code>pthread_join</code>函数访问到这个指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **rval_ptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>调用线程将一直阻塞,直到指定的线程调用<code>pthread_exit</code>，从启动例程中返回或者被取消。如果线程简单地从它的启动例程返回, <code>rval_ptr</code>就包含返回码。如果线程被取消,由<code>rval_ pir</code>指定的内存单元就设置为<code>PTHREAD_CANCELED</code></p>
<p>可以通过调用<code>pthread_join</code>自动把线程置于分离状态(马上就会讨论到),这样资源就可以恢复。如果线程已经处于分离状态, <code>pthread_join</code>调用就会失败,返回<code>EINVAL</code>,尽管这种行为是与具体实现相关的。</p>
<p>如果对线程的返回值并不感兴趣,那么可以把 rval_ptr设置为NULL。在这种情况下,调用pthread_join函数可以等待指定的线程终止,但并不获取线程的终止状态。</p>
<p>线程可以通过调用<code>pthread_cancel</code>函数来请求取消同一进程中的其他线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>线程可以安排它退出时需要调用的函数,这与进程在退出时可以用<code>atexit</code>函数安排退出是类似的。这样的函数称为线程清理处理程序( thread cleanup handler)。一个线程可以建立多个清理处理程序。处理程序记录在栈中,也就是说,它们的<strong>执行顺序与它们注册时相反</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line"></div><div class="line">void pthread_cleanup_push(void (*rtn)(void *), void *arg);</div><div class="line"></div><div class="line">void pthread_cleanup_pop(int execute);</div></pre></td></tr></table></figure>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当一个线程可以修改的变量,其他线程也可以读取或者修改的时候,我们就需要对这些线程进行同步,确保它们在访问变量的存储内容时不会访问到无效的值。</p>
<p>当一个线程修改变量时,其他线程在读取这个变量时可能会看到一个不一致的值。在变量修改时间多于一个存储器访问周期的处理器结构中,当存储器读与存储器写这两个周期交叉时,这种不一致就会出现。</p>
<p>为了解决这个问题,线程不得不使用锁,同一时间只允许一个线程访问该变量</p>
<p><img src="https://data2.liuin.cn/2018-05-02-15252443887056.jpg" alt=""></p>
<p>两个或多个线程试图在同一时间修改同一变量时,也需要进行同步</p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>可以使用 pthread的互斥接口来保护数据,确保同一时间只有一个线程访问数据。<strong>互斥量(mutex)</strong>从本质上说是一把锁,在访问共享资源前对互斥量进行设置(加锁),在访问完成后释放(解锁)互斥量。</p>
<p>互斥变量是用<code>pthread_mutex_t</code>数据类型表示的，使用互斥量之前必须要初始化，动态分配的互斥量在释放内存之前要调用<code>pthread_mutex_destory</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>要用默认的属性初始化互斥量,只需把attr设为NULL。</p>
<p>对互斥量进行加锁,需要调用<code>pthread_mutex_lock</code>。如果互斥量已经上锁,调用线程将阻塞直到互斥量被解锁。对互斥量解锁,需要调用<code>pthread_mutex_un1ock</code>。</p>
<p>如果线程不希望被阻塞,它可以使用<code>pthread_mutex_try1ock</code>尝试对互斥量进行加锁。如果调用 <code>pthread_mutex_try1ock</code>时互斥量处于未锁住状态,那么<code>pthread_mutex_try1ock</code>将锁住互斥量,不会出现阻塞直接返回0,否则<code>pthread_mutex_try1ock</code>就会失败,不能锁住互斥量,返回 EBUSY。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>如果线程试图对同一个互斥量加锁两次,那么它自身就会陷入死锁状态,可以通过仔细控制互斥量加锁的顺序来避免死锁的发生。例如,假设需要对两个互斥量A和B同时加锁。如果所有线程总是在对互斥量B加锁之前锁住互斥量A,那么使用这两个互斥量就不会产生死锁(当然在其他的资源上仍可能出现死锁)。</p>
<p>采用顺序加锁的形式避免死锁。</p>
<h3 id="函数pthread-mutex-timelock"><a href="#函数pthread-mutex-timelock" class="headerlink" title="函数pthread_mutex_timelock"></a>函数pthread_mutex_timelock</h3><p>当线程试图获取一个已加锁的互斥量时,<code>pthread_mutex_timedlock</code>互斥量原语允许绑定线程阻塞时间。 <code>pthread_mutex_timedlock</code>函数与<code>pthread_mutex_timedlock</code>是基本等价的,但是在达到超时时间值时,<code>pthread_mutex_timedlock</code>不会对互斥量进行加锁,而是返回错误码 ETIME_DOUT。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; #include &lt;time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_timedlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁( reader-writer lock)与互斥量类似,不过读写锁允许更高的并行性。互斥量要么是锁住状态,要么就是不加锁状态,而且一次只有一个线程可以对其加锁。读写锁可以有3种状态:读模式下加锁状态,写模式下加锁状态,不加锁状态。一次只有一个线程可以占有写模式的读写锁,但是多个线程可以同时占有读模式的读写锁</p>
<p>读写锁非常适合于对数据结构读的次数远大于写的情况。读写锁也叫做共享互斥锁( shared-exclusive lock)。</p>
<p>初始化和销毁读写锁的函数和互斥量类似<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure></p>
<p>要在读模式下锁定读写锁,需要调用<code>pthread_rwlock_rdlock</code>。要在写模式下锁定读写锁,需要调用 <code>pthread_rwlock_wrlock</code>。不管以何种方式锁住读写锁,都可以调用<code>pthread_rw1ock_unlock</code>进行解锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>读写锁原语的条件版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="带有超时的读写锁"><a href="#带有超时的读写锁" class="headerlink" title="带有超时的读写锁"></a>带有超时的读写锁</h3><p>与互斥量一样，读写锁也有带有超时条件的加锁函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; #include &lt;time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedwrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量是线程可用的另一种同步机制。条件变量给多个线程提供了一个会合的场所。条件变量与互斥量一起使用时,允许线程以无竞争的方式等待特定的条件发生。</p>
<p>条件本身是由互斥量保护的。<strong>线程在改变条件状态之前必须首先锁住互斥量</strong>。</p>
<p>条件变量使用的数据结构<code>pthread_cond_t</code>，同理也有初始化和销毁的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>我们使用<code>pthread_cond_wait</code>等待条件变量变为真。如果在给定的时间内条件不能满足那么会生成一个返回错误码的变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>有两个函数可以用于通知线程条件已经满足。<code>pthread_cond_signa1</code>函数至少能唤醒一个等待该条件的线程,而<code>pthread_cond_broadcast</code>函数则能唤醒等待该条件的所有线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁与互斥量类似,但它不是通过休眠使进程阻塞,而是在获取锁之前一直处于忙等(自旋)阻塞状态。自旋锁可用于以下情况:锁被持有的时间短,而且线程并不希望在重新调度上花费太多的成本</p>
<p>自旋锁通常作为底层原语用于实现其他类型的锁。</p>
<p>当自旋锁用在非抢占式内核中时是非常有用的:除了提供互斥机制以外,它们会阻塞中断这样中断处理程序就不会让系统陷入死锁状态,因为它需要获取已被加锁的自旋锁(把中断想成是另一种抢占)。在这种类型的内核中,中断处理程序不能休眠,因此它们能用的同步原语只能是自旋锁。</p>
<p>初始化和销毁函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_init</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock, <span class="keyword">int</span> pshared)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_destroy</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>加锁解锁函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_lock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_trylock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_unlock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>屏障(barrier)是用户<strong>协调多个线程并行工作的同步机制</strong>。屏障允许每个线程等待,直到所有的合作线程都到达某一点,然后从该点继续执行。我们已经看到一种屏障,<code>pthread_jo1n</code>函数就是一种屏障,允许一个线程等待,直到另一个线程退出。</p>
<p>但是屏障对象的概念更广,它们允许任意数量的线程等待,直到所有的线程完成处理工作而线程不需要退出。所有线程达到屏障后可以接着工作。</p>
<p>初始化和销毁函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_init</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *<span class="keyword">restrict</span> barrier, <span class="keyword">const</span> <span class="keyword">pthread_barrierattr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_destroy</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>初始化屏障时,可以使用<code>count</code>参数指定在允许所有线程继续运行之前,必须到达屏障的线程数目。使用<code>attr</code>参数指定屏障对象的属性,设置atmr为NULL,用默认属性初始化屏障。</p>
<p>可以使用<code>pthread_barrier_wait</code>函数来表明,线程已完成工作,准备等所有其他线程赶上来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_wait</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 or PTHREAD_BARRIER_SERIAL_THREAD if OK, error number on failure</span></div></pre></td></tr></table></figure>
<p>一旦达到屏障计数值,而且线程处于非阻塞状态,屏障就可以被重用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第11章 线程 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 进程关系</title>
    <link href="https://www.liuin.cn/2018/05/01/APUE-%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB/"/>
    <id>https://www.liuin.cn/2018/05/01/APUE-进程关系/</id>
    <published>2018-05-01T02:55:38.000Z</published>
    <updated>2018-05-01T06:28:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第9章 进程关系 笔记</p>
<a id="more"></a>
<h2 id="终端登录"><a href="#终端登录" class="headerlink" title="终端登录"></a>终端登录</h2><p>我们现在描述的过程用于经由终端登录至UNIX系统。该过程几乎与所使用的终端类型无关,所使用的终端可以是基于字符的终端、仿真基于字符终端的图形终端,或者运行窗口系统的图形终端。</p>
<ol>
<li>BSD终端登录</li>
</ol>
<p>系统管理者创建通常名为/etc/ttys的文件,其中,每个终端设备都有一行,每一行说明设备名和传到 getty程序的参数。</p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251450557245.jpg" alt=""></p>
<p>1ogin能处理多项工作。因为它得到了用户名,所以能调用<code>getpwnam</code>取得相应用户的口令文件登录项。然后调用<code>getpass</code>以显示提示“ Password:”,接着读用户键入的口令(自然,禁止回显用户键入的口令)。它调用 <code>crypt</code>将用户键入的口令加密,并与该用户在阴影口令文件中登录项的<code>pw_passwd</code>字段相比较。如果用户几次键入的口令都无效,则<code>1ogin</code>以参数1调用<code>exit</code>表示登录过程失败。父进程(init)了解到子进程的终止情况后,将再次调用<code>fork</code>,其后又执行了<code>getty</code>,对此终端重复上述过程。</p>
<p>如果用户正确登录，login就将完成如下工作：</p>
<ol>
<li>将当前工作目录更改为该用户的起始目录(chdir)。</li>
<li>调用 chown更改该终端的所有权,使登录用户成为它的所有者。将对该终端设备的访问权限改变成“用户读和写”。</li>
<li>调用setgid及initgroups设置进程的组ID</li>
<li>用login得到的所有信息初始化环境:起始目录(HOME)、shell(SHEL)用户名(USER和 LOGNAME)以及一个系统默认路径(PATH)。</li>
<li>1ogin进程更改为登录用户的用户ID( setuid)并调用该用户的登录 shell</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-05-01-15251453247541.jpg" alt=""></p>
<h2 id="网络登录"><a href="#网络登录" class="headerlink" title="网络登录"></a>网络登录</h2><p>通过串行终端登录至系统和经由网络登录至系统两者之间的主要(物理上的)区别是:网络登录时,在终端和计算机之间的连接不再是点到点的。在网络登录情况下,1ogin仅仅是一种可用的服务,这与其他网络服务(如FIP或SMIP)的性质相同</p>
<p>为使同一个软件既能处理终端登录,又能处理网络登录,系统使用了一种称为伪终端( pseudo terminal)的软件驱动程序,它仿真串行终端的运行行为,并将终端操作映射为网络操作,反之亦然。</p>
<ol>
<li>BSD网络登录</li>
</ol>
<p>作为系统启动的一部分,init调用一个 shell,,使其执行shell脚本/etc/rc。由此shell脚本启动一个守护进程 inetd。一旦此shell脚本终止, inetd的父进程就变成init。 inetd等待TCP/IP连接请求到达主机,而当一个连接请求到达时,它执行一次fork,然后生成的子进程exec适当的程序。</p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251533208482.jpg" alt=""></p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251534277316.jpg" alt=""></p>
<p>当通过终端或网络登录时,我们得到一个登录shell,其标准输入、标准输出和标准错误要么连接到一个终端设备,要么连接到一个伪终端设备上。</p>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><p>进程组是一个或多个进程的集合。通常,它们是在同一作业中结合起来的,同一进程组中的各进程接收来自同一终端的各种信号。每个进程组有一个唯一的进程组ID。进程组ID类似于进程ID——它是一个正整数,并可存放在pid_t数据类型中。函数 getpgrp返回调用进程的进程组ID。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getpgrp(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: process group ID of calling process</span></div></pre></td></tr></table></figure>
<p>getpgid函数返回指定进程所在的进程组ID：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getpgid(<span class="keyword">pid_t</span> pid);</div><div class="line"></div><div class="line"><span class="comment">// Returns: process group ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>每个进程组有一个组长进程。组长进程的进程组ID等于其进程ID。</p>
<p>进程组组长可以创建一个进程组、创建该组中的进程,然后终止。<strong>只要在某个进程组中有个进程存在,则该进程组就存在,这与其组长进程是否终止无关</strong>。从进程组创建开始到其中最后一个进程离开为止的时间区间称为进程组的生命期。某个进程组中的最后一个进程可以终止,也可以转移到另一个进程组</p>
<p>进程调用setpgid可以加入一个现有的进程组或者创建一个新进程组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>一个进程只能为它自己或它的子进程设置进程组ID。在它的子进程调用了exec后,它就不再更改该子进程的进程组ID</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话( session)是一个或多个进程组的集合</p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251538207763.jpg" alt=""></p>
<p>通常是由shell管道将几个进程编成一组的。</p>
<p>进程调用setsid函数建立一个新会话</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> setsid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: process group ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>如果调用此函数的进程不是一个进程组的组长,则此函数创建个新会话。具体会发生以下3件事。</p>
<ol>
<li>进程变成新会话的会话首进程( session leader,会话首进程是创建该会话的进程)。此时,该进程是新会话中的唯一进程</li>
<li>该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID。</li>
<li>该进程没有控制终端(下一节讨论控制终端)。如果在调用 setid之前该进程有一个控制终端,那么这种联系也被切断。</li>
</ol>
<p>如果该调用进程已经是一个进程组的组长,则此函数返回出错。为了保证不处于这种情况,通常先调用fork,然后使其父进程终止,而子进程则继续。因为子进程继承了父进程的进程组ID,而其进程ID则是新分配的,两者不可能相等,这就保证了子进程不是一个进程组的组长</p>
<p>会话首进程是具有唯一进程ID的单个进程,所以可以将会话首进程的进程ID视为会话ID</p>
<p>getsid函数返回会话首进程的进程组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getsid(<span class="keyword">pid_t</span> pid); </div><div class="line"></div><div class="line"><span class="comment">// Returns: session leader’s process group ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>如若pid是0, getsid返回调用进程的会话首进程的进程组ID。出于安全方面的考虑些实现有如下限制:如若pid并不属于调用者所在的会话,那么调用进程就不能得到该会话首进程的进程组ID</p>
<h2 id="控制终端"><a href="#控制终端" class="headerlink" title="控制终端"></a>控制终端</h2><p>会话和进程组还有一些其他特性</p>
<ul>
<li>一个会话可以有一个控制终端(controlling terminal)。这通常是终端设备(在终端登录情况下)或伪终端设备(在网络登录情况下)。</li>
<li>建立与控制终端连接的会话首进程被称为控制进程(controlling process)</li>
<li>一个会话中的几个进程组可被分成一个前台进程组(foreground process group)以及一个或多个后台进程组(background process group)</li>
<li>如果一个会话有一个控制终端,则它有一个前台进程组,其他进程组为后台进程组</li>
<li>无论何时键入终端的中断键(常常是Delete或Ctrl+C),都会将中断信号发送至前台进程组的所有进程。</li>
<li>无论何时键入终端的退出键(常常是Ctrl+),都会将退出信号发送至前台进程组的所有进程。</li>
<li>如果终端接口检测到调制解调器(或网络)已经断开连接,则将挂断信号发送至控制进程〔会话首进程)</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-05-01-15251544917844.jpg" alt=""></p>
<p>有时不管标准输入、标准输出是否重定向,程序都要与控制终端交互作用。保证程序能与控制终端对话的方法是open文件/dev/tty。在内核中,此特殊文件是控制终端的同义语。自然地,如果程序没有控制终端,则对于此设备的open将失败。</p>
<h2 id="函数tcgetpgrp、tcsetpgrp和tcgetsid"><a href="#函数tcgetpgrp、tcsetpgrp和tcgetsid" class="headerlink" title="函数tcgetpgrp、tcsetpgrp和tcgetsid"></a>函数tcgetpgrp、tcsetpgrp和tcgetsid</h2><p>需要有一种方法来通知内核哪一个进程组是前台进程组,这样,终端设备驱动程序就能知道将终端输入和终端产生的信号发送到何处</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> tcgetpgrp(<span class="keyword">int</span> fd); </div><div class="line"></div><div class="line"><span class="comment">// Returns: process group ID of foreground process group if OK, −1 on error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsetpgrp</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">pid_t</span> pgrpid)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>函数tcgetpgrp返回前台进程组ID,它与在fd上打开的终端相关联</p>
<p>如果进程有一个控制终端,则该进程可以调用 tcsetpgrp将前台进程组ID设置为pergid值应当是在同一会话中的一个进程组的ID。fd必须引用该会话的控制终端。</p>
<p>给出控制TTY的文件描述符,通过 tcgetsid函数,应用程序就能获得会话首进程的进程组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> tcgetsid(<span class="keyword">int</span> fd); </div><div class="line"></div><div class="line"><span class="comment">// Returns: session leader’s process group ID if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h2><p>作业控制允许<strong>在一个终端上启动多个作业(进程组)</strong>，它控制哪一个作业可以访问该终端以及哪些作业在后台运行。作业控制要求以下3种形式的支持。</p>
<ol>
<li>支持作业控制的 shell</li>
<li>内核中的终端驱动程序必须支持作业控制。</li>
<li>内核必须提供对某些作业控制信号的支持。</li>
</ol>
<p>从 shell使用作业控制功能的角度观察,用户可以在前台或后台启动一个作业。一个作业只是几个进程的集合,通常是一个进程管道。</p>
<p>当启动一个后台作业时，shell赋予其一个作业标识符，并打印一个或者多个进程ID，如下图所示：</p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251551733307.jpg" alt=""></p>
<p>我们可以键入一个影响前台作业的特殊字符—挂起键(通常采用Ctrl+z),与终端驱动程序进行交互作用。键入此字符使终端驱动程序将信号SIGTSTP发送至前台进程组中的所有进程,后台进程组作业则不受影响。实际上有3个特殊字符可使终端驱动程序产生信号,并将它们发送至前台进程组，他们是：</p>
<ul>
<li>中断字符(一般采用Delete或Ctrl+C)产生 SIGINT</li>
<li>退出字符(一般采用Ctrl+)产生 SIGQUIT</li>
<li>挂起字符(一般采用Ctrl+Z)产生 SIGTSTE。</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-05-01-15251552824446.jpg" alt=""></p>
<p>是否需要作业控制是一个有争议的问题。作业控制是在窗口终端广泛得到应用之前设计和实现的。很多人认为设计得好的窗口系统已经免除了对作业控制的需要。某些人抱怨作业控制的实现要求得到内核、终端驱动程序、 shell以及某些应用程序的支持,是吃力不讨好的事情。</p>
<h2 id="shell-执行程序"><a href="#shell-执行程序" class="headerlink" title="shell 执行程序"></a>shell 执行程序</h2><p><img src="https://data2.liuin.cn/2018-05-01-15251555962605.jpg" alt=""></p>
<h2 id="孤儿进程组"><a href="#孤儿进程组" class="headerlink" title="孤儿进程组"></a>孤儿进程组</h2><p>我们曾提及,一个其父进程己终止的进程称为孤儿进程( orphan process),这种进程由init进程“收养”。现在我们要说明整个进程组也可成为“孤儿”,以及POSIX.1如何处理它。</p>
<p>POSIX.1将孤儿进程组( orphaned process group)定义为:该组中每个成员的父进程要么是该组的一个成员,要么不是该组所属会话的成员。对孤儿进程组的另一种描述可以是:一个进程组不是孤儿进程组的条件是——该组中有一个进程,其父进程在属于同一会话的另一个组中。如果进程组不是孤儿进程组那么在属于同一会话的另一个组中的父进程就有机会重新启动该组中停止的进程。在这里,进程组中每一个进程的父进程(例如,进程6100的父进程是进程1)都属于另一个会话。所以此进程组是孤儿进程组</p>
<p>父进程终止后,进程组包含一个停止的进程,进程组成为孤儿进程组,POSIX.1要求向新孤儿进程组中处于停止状态的每一个进程发送挂断信号( SIGHUP),接着又向其发送继续信号( SIGCONT)。</p>
<p>在处理了挂断信号后,子进程继续。对挂断信号的系统默认动作是终止该进程,为此必须提供一个信号处理程序以捕捉该信号。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第9章 进程关系 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 进程控制</title>
    <link href="https://www.liuin.cn/2018/04/30/APUE-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://www.liuin.cn/2018/04/30/APUE-进程控制/</id>
    <published>2018-04-30T08:07:20.000Z</published>
    <updated>2018-05-01T02:38:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第8章 进程控制 笔记</p>
<a id="more"></a>
<h2 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h2><p>每个进程都有一个非负整型表示的唯一进程ID。因为进程ID标识符总是唯一的,常将其用作其他标识符的一部分以保证其唯一性。</p>
<p>虽然是唯一的,但是<strong>进程ID是可复用的</strong>。当一个进程终止后,其进程ID就成为复用的候选者。大多数UNIX系统实现延迟复用算法,使得赋予新建进程的DD不同于最近终止进程所使用的ID。这防止了将新进程误认为是使用同一ID的某个已终止的先前进程。</p>
<p>系统中有一些专用进程,但具体细节随实现而不同。<strong>ID为0的进程通常是调度进程,常常被称为交换进程</strong>(swapper)。该进程是内核的一部分,它并不执行任何磁盘上的程序,因此也被称为系统进程。</p>
<p>进程ID为1通常是init进程,在自举过程结束时由内核调用。该进程的程序文件在UNIX的早期版本中是/etc/init,在较新版本中是/sbin/init。此进程负责在自举内核后启动一个UNIX系统。init通常读取与系统有关的初始化文件(/etc/rc*文件或/etc/inittab文件,以及在/etc/init.d中的文件),并将系统引导到一个状态(如多用户)。init进程决不会终止。它是一个普通的用户进程(与交换进程不同,它不是内核中的系统进程),但是它以超级用户特权运行。</p>
<p>每个UNIX系统实现都有它自己的一套提供操作系统服务的内核进程,例如,在某些UNIX的虚拟存储器实现中,进程ID2是页守护进程( page daemon),此进程负责支持虚拟存储器系统的分页操作。</p>
<p>返回进程标识符的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: process ID of calling process</span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> getppid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: parent process ID of calling process</span></div><div class="line"></div><div class="line"><span class="keyword">uid_t</span> getuid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: real user ID of calling process</span></div><div class="line"></div><div class="line"><span class="keyword">uid_t</span> geteuid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: effective user ID of calling process</span></div><div class="line"></div><div class="line"><span class="keyword">gid_t</span> getgid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: real group ID of calling process</span></div><div class="line"></div><div class="line"><span class="keyword">gid_t</span> getegid(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: effective group ID of calling process</span></div></pre></td></tr></table></figure>
<h2 id="函数fork"><a href="#函数fork" class="headerlink" title="函数fork"></a>函数fork</h2><p>一个现有进程调用fork函数创建一个新的进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 in child, process ID of child in parent, −1 on error</span></div></pre></td></tr></table></figure>
<p>由fork创建的新进程被称为子进程( child process) fork函数被调用一次,但返回两次。两次返回的区别是子进程的返回值是0,而父进程的返回值则是新建子进程的进程ID。</p>
<p>将子进程ID返回给父进程的理由是:因为一个进程的子进程可以有多个,<strong>并且没有一个函数使一个进程可以获得其所有子进程的进程ID</strong>。fork使子进程得到返回值0的理由是:一个进程只会有一个父进程,所以子进程总是可以调用 getppid以获得其父进程的进程ID(进程ID0总是由内核交换进程使用,所以一个子进程的进程ID不可能为0)</p>
<p>子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。</p>
<p>由于在fork之后经常跟随着exec,所以现在的很多实现并不执行一个父进程数据段栈和堆的完全副本。作为替代,使用了<strong>写时复制</strong>( copy-on-write,COW)技术。这些区域由父进程和子进程共享,而且内核将它们的访问权限改变为只读。如果父进程和子进程中的任一个试图修改这些区域,则内核只为修改区域的那块内存制作一个副本,通常是虚拟存储系统中的一“页”。</p>
<p>一般来说,在fork之后是父进程先执行还是子进程先执行是不确定的,这取决于内核所使用的调度算法。如果要求父进程和子进程之间相互同步,则要求某种形式的进程间通信。</p>
<blockquote>
<p>strlen 和 sizeof 的区别</p>
</blockquote>
<p>str1en计算不包含终止nul字节的字符串长度,而sizeof则计算包括终止nul字节的缓冲区长度。两者之间的另一个差别是,使用strlen需进行一次函数调用,而对于sizeof而言,因为缓冲区已用已知字符串进行初始化,其长度是固定的,所以 sizeof是在编译时计算缓冲区长度。</p>
<blockquote>
<p>文件共享</p>
</blockquote>
<p>fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中。我们说“复制”是因为对每个文件描述符来说,就好像执行了dup函数。<strong>父进程和子进程每个相同的打开描述符共享一个文件表项</strong>，因此他们共享的是一个文件偏移量。</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250766871953.jpg" alt=""></p>
<p>如果父进程和子进程写同一描述符指向的文件,但又没有任何形式的同步(如使父进程等待子进程),那么它们的输出就会相互混合(假定所用的描述符是在foxk之前打开的)。</p>
<p>在fork之后处理文件描述符有以下两种情况：</p>
<ol>
<li>父进程等待子进程完成</li>
<li>父进程和子进程各自执行不同的程序段</li>
</ol>
<p>除了打开文件之外,<strong>子进程继承父进程的属性</strong>有：</p>
<ul>
<li>实际用户ID、实际组ID、有效用户ID、有效组ID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>会话ID</li>
<li>控制终端</li>
<li>设置用户ID标志和设置组ID标志</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字</li>
<li>信号屏蔽和安排</li>
<li>对任一打开文件描述符的执行时关闭( close-on-exec)标志</li>
<li>环境</li>
<li>连接的共享存储段</li>
<li>存储映像</li>
<li>资源限制</li>
</ul>
<p>父进程和子进程的区别如下：</p>
<ul>
<li>fork的返回值不同</li>
<li>进程ID不同</li>
<li>这两个进程的父进程ID不同:子进程的父进程ID是创建它的进程的ID,而父进程的父进程ID则不变。</li>
<li>进程的 tms_utime、 tms_stime、 tms_cutime和tms_ultime的值设置为0</li>
<li>子进程不继承父进程设置的文件锁</li>
<li>子进程的未处理闹钟被清除</li>
<li>子进程的未处理信号集设置为空集</li>
</ul>
<p>使fork失败的原因主要有以下几个：</p>
<ol>
<li>系统中已经有了太多的进程</li>
<li>该实际用户ID的进程总数超过了系统限制</li>
</ol>
<p>fork有如下两种用法：</p>
<ol>
<li>一个父进程希望复制自己,使父进程和子进程同时执行不同的代码段</li>
<li>一个进程要执行一个不同的程序</li>
</ol>
<h2 id="函数vfork"><a href="#函数vfork" class="headerlink" title="函数vfork"></a>函数vfork</h2><p>vfork函数的调用序列和返回值与fork相同,但两者的语义不同</p>
<p>vfork函数用于创建一个新进程,而该新进程的目的是exec一个新程序。但是它并不将父进程的地址空间完全复制到子进程中,因为子进程会立即调用exec(或exit),于是也就<strong>不会引用该地址空间</strong>。不过在子进程调用exec或exit之前,它在父进程的空间中运行。这种优化工作方式在某些UNIX系统的实现中提高了效率,但如果子进程修改数据(除了用于存放 vfork返回值的变量)、进行函数调用、或者没有调用exec或exit就返回都可能会带来未知的结果。(就像上一节中提及的,实现采用写时复制技术以提高fork之后跟随exec操作的效率,但是不复制比部分复制还是要快一些)</p>
<p>vfork和fork之间的另一个区别是: vfork保证子进程先运行,在它调用exec或exit之后父进程才可能被调度运行,当子进程调用这两个函数中的任意一个时,父进程会恢复运行。</p>
<h2 id="函数exit"><a href="#函数exit" class="headerlink" title="函数exit"></a>函数exit</h2><p>进程有5种正常终止和3种异常终止的方式，5种正常终止的方式如下：</p>
<ol>
<li>从main返回</li>
<li>调用exit</li>
<li>调用_exit或_Exit</li>
<li>最后一个线程从其启动例程返回</li>
<li>从最后一个线程调用 pthread_exit</li>
</ol>
<p>3种异常终止方式：</p>
<ol>
<li>调用 abort</li>
<li>接到一个信号</li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<p>不管进程如何终止,最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开描述符,释放它所使用的存储器等。</p>
<p>对上述任意一种终止情形,我们都希望终止进程能够通知其父进程它是如何终止的。对于3个终止函数(exit、_exit和_Exit),实现这一点的方法是,将其退出状态( exit status)作为参数传送给函数。在异常终止情况,内核(不是进程本身)<strong>产生一个指示其异常终止原因的终止状态</strong>( termination status)。在任意一种情况下,该终止进程的父进程都能用wait或wa1tpid函数(将在下一节说明)取得其终止状态。</p>
<p>上面说明了子进程将其终止状态返回给其父进程，但是如果父进程在子进程之前终止,又将如何呢?其回答是:<strong>对于父进程已经终止的所有进程,它们的父进程都改变为init进程</strong>。我们称这些进程由init进程收养。其操作过程大致是:在一个进程终止时,内核逐个检查所有活动进程,以判断它是否是正要终止进程的子进程,如果是,则该进程的父进程ID就更改为1(init进程的ID)。这种处理方法保证了每个进程有一个父进程。</p>
<p>如果子进程在父进程之前终止,那么父进程又如何能在做相应检查时得到子进程的终止状态呢?如果子进程完全消失了,父进程在最终准备好检查子进程是否终止时是无法获取它的终止状态的。内核为每个终止子进程保存了一定量的信息,所以当终止进程的父进程调用wait或 waitpid时,可以得到这些信息。</p>
<p>在UNIX术语中,一个已经终止、但是其父进程尚未对其进行善后处理(获取终止子进程的有关信息、释放它仍占用的资源)的进程被称为<strong>僵死进程</strong>( zombie.)。Ps()命令将僵死进程的状态打印为Z。如果编写一个长期运行的程序,它fork了很多子进程,那么除非父进程等待取得子进程的终止状态,不然这些子进程终止后就会变成僵死进程</p>
<p>最后一个要考虑的问题是:一个由init进程收养的进程终止时会发生什么?它会不会变成一个僵死进程?对此问题的回答是“否”,因为init被编写成无论何时只要有一个子进程终止,init就会调用一个wait函数取得其终止状态。这样也就防止了在系统中塞满僵死进程。</p>
<h2 id="函数wait-和-waitpid"><a href="#函数wait-和-waitpid" class="headerlink" title="函数wait 和 waitpid"></a>函数wait 和 waitpid</h2><p>当一个进程正常或异常终止时,内核就向其父进程发送 SIGCHLD信号。因为子进程终止是个异步事件(这可以在父进程运行的任何时候发生),所以这种信号也是内核向父进程发的异步通知。父进程可以选择忽略该信号,或者提供一个该信号发生时即被调用执行的函数(信号处理程序)。对于这种信号的系统默认动作是忽略它。</p>
<p>现在我们要知道的是调用wait和waitpid时进程都发生什么：</p>
<ul>
<li>如果其所有子进程都还在运行,则阻塞。</li>
<li>如果一个子进程已终止,正等待父进程获取其终止状态,则取得该子进程的终止状态立即返回</li>
<li>如果它没有任何子进程,则立即出错返回。</li>
</ul>
<p>如果进程由于接收到 SIGCHLD信号而调用wait,我们期望wait会立即返回。但是如果在间点调用wait,则进程可能会阻塞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *statloc); </div><div class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options); </div><div class="line"></div><div class="line"><span class="comment">// Both return: process ID if OK, 0 (see later), or −1 on error</span></div></pre></td></tr></table></figure>
<p>两个函数的区别如下：</p>
<ul>
<li>在一个子进程终止前,wait使其调用者阻塞,而 waitpid有一选项,可使调用者不阻塞</li>
<li>waitpid并不等待在其调用之后的第一个终止子进程,它有若千个选项,可以控制它所等待的进程</li>
</ul>
<p>这两个函数的参数statloc是一个整型指针。如果statloc不是一个空指针,则终止进程的终止状态就存放在它所指向的单元内。如果不关心终止状态,则可将该参数指定为空指针</p>
<p>对于waitpid函数中pid参数的作用解释如下。</p>
<ul>
<li>pid == -1  等待任一子进程。此种情况下, waitpid与wait等效</li>
<li>pid &gt; 0  等待进程ID与pid相等的子进程</li>
<li>pid == 0  等待组ID等于调用进程组ID的任一子进程。</li>
<li>pid &lt; -1  等待组ID等于pid绝对值的任一子进程</li>
</ul>
<p>waitpid函数返回终止子进程的进程ID,并将该子进程的终止状态存放在由saoc指向的存储单元中。</p>
<p>options参数可以使我们能够进一步控制waitpid函数的操作</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250876888707.jpg" alt=""></p>
<h2 id="函数waitid"><a href="#函数waitid" class="headerlink" title="函数waitid"></a>函数waitid</h2><p>另一个取得进程终止状态的函数waited,此函数类似于 waitpid,但提供了更多的灵活性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">waitid</span><span class="params">(<span class="keyword">idtype_t</span> idtype, <span class="keyword">id_t</span> id, <span class="keyword">siginfo_t</span> *infop, <span class="keyword">int</span> options)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>与 waitpid相似, waitid允许一个进程指定要等待的子进程。但它使用两个单独的参数表示要等待的子进程所属的类型,而不是将此与进程DD或进程组ID组合成一个参数。</p>
<p>idtype参数：</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250878149783.jpg" alt=""></p>
<p>options参数：</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250878305949.jpg" alt=""></p>
<h2 id="函数wait3和wait4"><a href="#函数wait3和wait4" class="headerlink" title="函数wait3和wait4"></a>函数wait3和wait4</h2><p>wait3和wait4提供的功能比上面的函数多一个，该参数允许内核返回由终止进程及其所有子进程使用的资源概况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> wait3(<span class="keyword">int</span> *statloc, <span class="keyword">int</span> options, <span class="keyword">struct</span> rusage *rusage);</div><div class="line"></div><div class="line"><span class="keyword">pid_t</span> wait4(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statloc, <span class="keyword">int</span> options, <span class="keyword">struct</span> rusage *rusage);</div><div class="line"></div><div class="line"><span class="comment">// Both return: process ID if OK, 0, or −1 on error</span></div></pre></td></tr></table></figure>
<p>资源统计信息包括用户CPU时间总量、系统CPU时间总量、缺页次数、接收到信号的次数等。</p>
<h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><p>当多个进程都企图对共享数据进行某种处理,而最后的结果又取决于进程运行的顺序时,我们认为发生了竞争条件(race condition)。如果在fork之后的某种逻辑显式或隐式地依赖于在fork之后是父进程先运行还是子进程先运行,那么fork函数就会是竞争条件活跃的滋生地</p>
<p>如果一个进程希望等待一个子进程终止,则它必须调用wait函数中的一个。如果一个进程要等待其父进程终止,则可使用下列形式的循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">while</span>(getppid() != <span class="number">1</span>)</div><div class="line">    sleep(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>这种形式的循环称为轮询( polling),它的问题是浪费了CPU时间,因为调用者每隔1s都被唤醒,然后进行条件测试</p>
<p>为了避免竞争条件和轮询,在多个进程之间需要有某种形式的信号发送和接收的方法。在UNIX中可以使用信号机制。各种形式的进程间通信(IPC)也可使用。</p>
<h2 id="函数exec"><a href="#函数exec" class="headerlink" title="函数exec"></a>函数exec</h2><p>用fork函数创建新的子进程后,子进程往往要调用一种exec函数以执行另个程序。当进程调用一种exec函数时,该进程执行的程序完全替换为新程序,而新程序则从其main函数开始执行。因为调用exec并不创建新进程,所以前后的进程ID并未改变。<strong>exec只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段</strong>。</p>
<p>有7中不同的exec函数可以使用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span> )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ...<span class="comment">/* (char *)0, char *const envp[] */</span> )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ﬁlename, <span class="keyword">const</span> <span class="keyword">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span> )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ﬁlename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fexecve</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All seven return: −1 on error, no return on success</span></div></pre></td></tr></table></figure></p>
<p>这些函数之间的第一个区别是前4个函数取路径名作为参数,后两个函数则取文件名作为参数,最后一个取文件描述符作为参数。</p>
<p>第二个区别与参数表的传递有关(1表示列表list,v表示矢量vector)。函数exec1、exec1p和 execle要求将新程序的每个命令行参数都说明为一个单独的参数。这种参数表以空指针结尾。对于另外4个函数( execv、 execvp、execve和 fexecve),则应先构造一个指向各参数的指针数组,然后将该数组地址作为这4个函数的参数。</p>
<p>最后一个区别与向新程序传递环境表相关。以e结尾的3个函数(eXec1e、 execve和 fexecve)可以传递一个指向环境字符串指针数组的指针。其他4个函数则使用调用进程中的 environ变量为新程序复制现有的环境</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15251006856272.jpg" alt=""></p>
<p>前面曾提及,在执行exec后,进程ID没有改变。但新程序从调用进程继承了的下列属性:</p>
<ul>
<li>进程ID和父进程ID</li>
<li>实际用户ID和实际组ID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>会话ID</li>
<li>控制终端</li>
<li>闹钟尚余留的时间</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字</li>
<li>文件锁</li>
<li>进程信号屏蔽</li>
<li>未处理信号</li>
<li>资源限制</li>
<li>nice值</li>
<li>tms_utime、tms_stime、tms_cutime以及tms_ctime值</li>
</ul>
<p>在很多UNIX实现中,这7个函数中只有<code>execve</code>是内核的系统调用。另外6个只是库函数它们最终都要调用该系统调用。</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15251008959267.jpg" alt=""></p>
<h2 id="更改用户ID和更改组ID"><a href="#更改用户ID和更改组ID" class="headerlink" title="更改用户ID和更改组ID"></a>更改用户ID和更改组ID</h2><p>在UNIX系统中,特权(如能改变当前日期的表示法)以及访问控制(如熊否读、写一个特定文件),是基于用户ID和组ID的。当程序需要增加特权,或需要访问当前并不允许访问的资源时,我们需要更换自己的用户ID或组ID,使得新ID具有合适的特权或访问权限。与此类似当程序需要降低其特权或阻止对某些资源的访问时,也需要更换用户ID或组ID,新ID不具有相应特权或访问这些资源的能力</p>
<p>在设计应用时,我们总是试图使用<strong>最小特权( least privilege)模型</strong>。依照此模型我们的程序应当只具有为完成给定任务所需的最小特权。这降低了由恶意用户试图哄骗我们的程序以未预料的方式使用特权造成的安全性风险</p>
<p>设置用户ID和组ID的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>使用时注意如下：</p>
<ul>
<li>若进程具有超级用户特权,则 setuid函数将实际用户ID、有效用户ID以及保存的设置用户ID设置为uid</li>
<li>若进程没有超级用户特权,但是uid等于实际用户ID或保存的设置用户ID,则 setid只将有效用户ID设置为uid。不更改实际用户ID和保存的设置用户ID</li>
<li>如果上面两个条件都不满足,则 errno设置为 EPERM,并返回-1</li>
</ul>
<p>关于内核所维护的3个ID，需要注意的事项如下：</p>
<ul>
<li>只有超级用户才可以更改实际用户ID，通常,实际用户ID是在用户登录时,由1ogin(1)程序设置的,而且决不会改变它。</li>
<li>仅当对程序文件设置了设置用户ID位时,exec函数才设置有效用户ID</li>
<li>保存的设置用户ID是由exec复制有效用户ID而得到的</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-04-30-15251013810789.jpg" alt=""></p>
<ol>
<li>函数setreuid和setregid</li>
</ol>
<p>其功能是交换实际用户ID和有效用户ID的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setreuid</span><span class="params">(<span class="keyword">uid_t</span> ruid, <span class="keyword">uid_t</span> euid)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setregid</span><span class="params">(<span class="keyword">gid_t</span> rgid, <span class="keyword">gid_t</span> egid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<ol>
<li>函数seteuid和setegid</li>
</ol>
<p>它们类似于 setuid和 setgid,但只更改有效用户ID和有效组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>各个函数之间的区别</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15251015827722.jpg" alt=""></p>
<h2 id="解释器文件"><a href="#解释器文件" class="headerlink" title="解释器文件"></a>解释器文件</h2><p>所有现今的UNIX系统都支持解释器文件(interpreter file)。这种文件是文本文件,其起始行的形式是：</p>
<p><code>#! pathname [optional-argument]</code></p>
<p>最常见的如下：</p>
<p><code>#! /bin/sh</code></p>
<p>对这种文件的识别是由内核作为exec系统调用处理的一部分来完成的。内核使调用exec函数的进程<strong>实际执行的并不是该解释器文件,而是在该解释器文件第一行中 pathname所指定的文件</strong>。一定要将解释器文件(文本文件,它以#!开头)和解释器(由该解释器文件第一行中的 pathname指定)区分开来</p>
<p>当内核exec解释器(/home/sar/bin/echoarg)时,argv[0]是该解释器的 pathname,argv[1]是解释器文件中的可选参数</p>
<h2 id="函数system"><a href="#函数system" class="headerlink" title="函数system"></a>函数system</h2><p>ISO C定义了system函数,但是其操作对系统的依赖性很强</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: (see below)</span></div></pre></td></tr></table></figure>
<p>如果 cmdstring是一个空指针,则仅当命令处理程序可用时, system返回非0值,这一特征可以确定在一个给定的操作系统上是否支持 system函数。在UNIX中, system总是可用的。</p>
<p>因为 system在其实现中调用了fork、exec和 waitpid,因此有3种返回值<br>(1)fork失败或者 waitpid返回除 EINTR之外的出错,则 system返回-1,并且设置errno以指示错误类型。<br>(2)如果 exec失败(表示不能执行shel1),则其返回值如同 shell执行了exit(127)一样<br>(3)否则所有3个函数(fork、exec和 waitpid)都成功,那么 system的返回值是 shell的终止状态,其格式已在 waitpid中说明。</p>
<p>使用 system而不是直接使用fork和exec的优点是: system进行了所需的各种出错处理以及各种信号处理</p>
<h2 id="进程会计"><a href="#进程会计" class="headerlink" title="进程会计"></a>进程会计</h2><p>大多数UNIX系统提供了一个选项以进行进程会计( process accounting)处理。启用该选项后,每当进程结束时内核就写一个会计记录。典型的会计记录包含总量较小的二进制数据,一般包括命令名、所使用的CPU时间总量、用户ID和组ID、启动时间等。</p>
<p>一个至今没有说明的函数(acct)启用和禁用进程会计。唯一使用这一函数的是 accton(8)命令(这是在几种平台上都类似的少数几条命令中的一条)。超级用户执行一个带路径名参数的accton命令启用会计处理。会计记录写到指定的文件中</p>
<p>会计记录结构定义在头文件<sys acct.h="">中，每个系统都有不同，但是基本样式如下：</sys></p>
<p><img src="https://data2.liuin.cn/2018-05-01-15251417041152.jpg" alt=""></p>
<p>会计记录所需的各个数据(各CPU时间、传输的字符数等)都由内核保存在进程表中,并在个新进程被创建时初始化(如fork之后在子进程中)。进程终止时写一个会计记录。</p>
<p>这产生两个后果:</p>
<p>第一,我们不能获取永远不终止的进程的会计记录。像init这样的进程在系统生命周期中直在运行,并不产生会计记录。这也同样适合于内核守护进程,它们通常不会终止<br>第二,在会计文件中记录的顺序对应于进程终止的顺序,而不是它们启动的顺序。</p>
<h2 id="用户标识"><a href="#用户标识" class="headerlink" title="用户标识"></a>用户标识</h2><p>任一进程都可以得到其实际用户ID和有效用户ID及组ID。但是,我们有时希望找到运行该程序用户的登录名。</p>
<p>系统通常记录用户登录时使用的名字(见68节),用get1ogin函数可以获取此登录名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getlogin</span><span class="params">(<span class="keyword">void</span>)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to string giving login name if OK, NULL on error</span></div></pre></td></tr></table></figure>
<p>如果调用此函数的进程没有连接到用户登录时所用的终端,则函数会失败。通常称这些进程为守护进程(daemon)</p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>UNX系统历史上对进程提供的只是基于调度优先级的粗粒度的控制。调度策略和调度优先级是由内核确定的。<strong>进程可以通过调整nice值选择以更低优先级运行</strong>(通过调整nice值降低它对CPU的占有,因此该进程是“友好的”)。只有特权进程允许提高调度权限</p>
<p>Single UNIX Specification中nice值的范围在0~(2*NZERO)-1之间,有些实现支持0~2*NERO。nice值越小,优先级越高。虽然这看起来有点倒退,但实际上是有道理的:你越友好,你的调度优先级就越低。 NERO是系统默认的nice值。</p>
<p>进程可以通过nice函数获取或更改它的nice值。使用这个函数,进程只能影响自己的nce值,不能影响任何其他进程的nice值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">nice</span><span class="params">(<span class="keyword">int</span> incr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: new nice value − NZERO if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>getpriority函数可以像nice函数那样用于获取进程的nice值,但是 getpriority还可以获取一组相关进程的nice值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: nice value between −NZERO and NZERO−1 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>setpriority函数可用于为进程、进程组和属于特定用户ID的所有进程设置优先级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who, <span class="keyword">int</span> value)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h2><p>我们可以度量的3个时间:墙上时钟时间、用户CPU时间和系统CPU时间。任一进程都可调用 times函数获得它自己以及已终止子进程的土述值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">clock_t</span> times(<span class="keyword">struct</span> tms *buf );</div><div class="line"></div><div class="line"><span class="comment">// Returns: elapsed wall clock time in clock ticks if OK, −1 on error</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第8章 进程控制 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 进程环境</title>
    <link href="https://www.liuin.cn/2018/04/29/APUE-%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83/"/>
    <id>https://www.liuin.cn/2018/04/29/APUE-进程环境/</id>
    <published>2018-04-29T10:30:25.000Z</published>
    <updated>2018-04-30T08:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第7章 进程环境 笔记</p>
<a id="more"></a>
<h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>C程序总是从main函数开始执行，main函数的原型是：</p>
<p><code>int main(int argc, char *argv);</code></p>
<p>其中，argc是命令行参数的数目，argv是指向参数的各个指针所构成的数组</p>
<p>当内核执行C程序时(使用一个exec函数),在调用main前先调用一个特殊的启动例程。可执行程序文件将此启动例程指定为程序的起始地址—这是由连接编辑器设置的,而连接编辑器则由C编译器调用。启动例程从内核取得命令行参数和环境变量值,然后为按上述方式调用main函数做好安排。</p>
<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>有8种方法使得进程终止(termination)，其中5种为正常终止：</p>
<ol>
<li>从main返回</li>
<li>调用exit</li>
<li>调用_exit或_Exit</li>
<li>最后一个线程从其启动例程返回</li>
<li>从最后一个线程调用 pthread_exit</li>
</ol>
<p>异常终止有3种方式,它们是:</p>
<ol>
<li>调用 abort</li>
<li>接到一个信号</li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<blockquote>
<p>退出函数</p>
</blockquote>
<p>3个函数用于正常终止一个程序:_exit和_Exit立即进入内核,exit则先执行一些清理处理,然后返回内核。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>; </div><div class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</div></pre></td></tr></table></figure>
<p><code>exit</code>函数总是执行一个标准I/O库的清理关闭操作:对于所有打开流调用fc1ose函数。这造成输出缓冲中的所有数据都被冲洗(写到文件上)</p>
<p>3个退出函数都带一个整型参数,称为终止状态(或退出状态, exit status)。大多数UNIX系统 shell都提供检查进程终止状态的方法。</p>
<blockquote>
<p>函数atexit</p>
</blockquote>
<p>按照ISO C的规定,一个进程可以登记多至32个函数,这些函数将由exit自动调用。我们称这些函数为终止处理程序( exit handler),并调用 atexit函数来登记这些函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">int atexit(void (*func)(void));</div><div class="line"></div><div class="line">// Returns: 0 if OK, nonzero on error</div></pre></td></tr></table></figure>
<p>其中, <code>atexit</code>的参数是一个函数地址,当调用此函数时无需向它传递任何参数,也不期望它返回一个值。exit调用这些函数的顺序与它们登记时候的顺序相反。同一函数如若登记多次也会被调用多次。</p>
<p>exit首先调用各终止程序，然后关闭（通过fclose）所有打开的流</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250569958373.jpg" alt=""></p>
<p>注意,内核使程序执行的唯一方法是调用一个eXec函数。进程自愿终止的唯一方法是显式或隐式地(通过调用exit)调用exit或Exit。进程也可非自愿地由一个信号使其终止</p>
<p>atexit函数有点像析构函数的意思</p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>当执行一个程序时,调用exec的进程可将命令行参数传递给该新程序。</p>
<p>ISO C和POSIX.1都要求argv[argc]是一个空指针。这就使我们可以将参数处理循环改写为</p>
<p><code>for(i = 0; argv[i] != NULL; i++)</code></p>
<h2 id="环境表"><a href="#环境表" class="headerlink" title="环境表"></a>环境表</h2><p>每个程序都接收到一张环境表。与参数表一样,<strong>环境表也是一个字符指针数组</strong>,其中每个指针包含一个以null结束的C字符串的地址。全局变量 environ则包含了该指针数组的地址</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250572321583.jpg" alt=""></p>
<h2 id="C程序的存储空间布局"><a href="#C程序的存储空间布局" class="headerlink" title="C程序的存储空间布局"></a>C程序的存储空间布局</h2><p>C程序一直由以下几个部分组成：</p>
<ul>
<li>正文段。这是由CPU执行的机器指令部分。通常,正文段是可共享的</li>
<li>初始化数据段。通常将此段称为数据段,它包含了程序中需明确地赋初值的变量</li>
<li>未初始化数据段。通常将此段称为bss段,这一名称来源于早期汇编程序一个操作符,意思是“由符号开始的块”( block started by symbol),在程序开始执行之前,<strong>内核将此段中的数据初始化为0或空指针</strong>。</li>
<li>栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。</li>
<li>堆。通常在堆中进行动态存储分配。</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-04-30-15250574049036.jpg" alt=""></p>
<p>栈顶和堆顶的虚拟地址空间很大。</p>
<p>未初始化数据段的内容并不存放在磁盘程序文件中。其原因是,内核在程序开始运行前将它们都设置为0。需要存放在磁盘程序文件中的段只有正文段和初始化数据段</p>
<h2 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h2><p>共享库使得<strong>可执行文件中不再需要包含公用的库函数</strong>,而只需在所有进程都可引用的存储区中保存这种库例程的一个副本。程序第一次执行或者第一次调用某个库函数时,<strong>用动态链接方法将程序与共享库函数相链接</strong>。这减少了每个可执行文件的长度,但增加了一些运行时间开销。这种时间开销发生在该程序第一次被执行时,或者每个共享库函数第一次被调用时。共享库的另一个优点是<strong>可以用库函数的新版本代替老版本而无需对使用该库的程序重新连接编辑</strong>(假定参数的数目和类型都没有发生改变)</p>
<h2 id="存储空间分配"><a href="#存储空间分配" class="headerlink" title="存储空间分配"></a>存储空间分配</h2><p>ISO C说明了3个用于存储空间动态分配的函数</p>
<ol>
<li>ma11oc,分配指定字节数的存储区。此存储区中的初始值不确定。</li>
<li>cal1oc,为指定数量指定长度的对象分配存储空间。该空间中的每一位(bit)都初始化为0</li>
<li>rea11oc,增加或减少以前分配区的长度。当增加长度时,可能需将以前分配区的内容移到另一个足够大的区域,以便在尾端提供增加的存储区,而新增区域内的初始值则不确定。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nobj, <span class="keyword">size_t</span> size)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> newsize)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All three return: non-null pointer if OK, NULL on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</div></pre></td></tr></table></figure>
<p>这3个分配函数所返回的指针一定是适当对齐的,使其可用于任何数据对象。</p>
<p>函数free释放ptr指向的存储空间。被释放的空间通常被送入可用存储区池,以后,可在用上述3个分配函数时再分配。</p>
<p>这些分配例程通常用sbrk(2)系统调用实现。该系统调用扩充(或缩小)进程的堆。</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境字符串的形式是 <code>name=value</code></p>
<p>UNIX内核并不查看这些字符串,它们的解释完全取决于各个应用程序。</p>
<p>可以使用getenv函数获得环境变量的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to value associated with name, NULL if not found</span></div></pre></td></tr></table></figure>
<p>此函数返回一个指针,它指向<code>name=value</code>字符串中的 value。</p>
<p>设置环境变量的三个函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, nonzero on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> rewrite)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>用法：</p>
<ul>
<li>putenv取形式为<code>name=value</code>的字符串,将其放到环境表中。如果name已经存在,则先删除其原来的定义。</li>
<li>setenv将name设置为value。</li>
<li>unsetenv删除name的定义</li>
</ul>
<h2 id="函数setjmp和longjmp"><a href="#函数setjmp和longjmp" class="headerlink" title="函数setjmp和longjmp"></a>函数setjmp和longjmp</h2><p>在C中,goto语句是不能跨越函数的,而执行这种类型跳转功能的是函数 setjmp和1ongjmp两个函数对于处理发生在很深层嵌套函数调用中的出错情况是非常有用的</p>
<p>setjmp和1ongjmp函数可以看成一个非局部goto函数。非局部指的是这不是由普通的C语言goto语句在一个函数内实施的跳转,而是在栈上跳过若于调用帧,返回到当前函数调用路径上的某一个函数中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if called directly, nonzero if returning from a call to longjmp</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="函数getrlimit和setrlimit"><a href="#函数getrlimit和setrlimit" class="headerlink" title="函数getrlimit和setrlimit"></a>函数getrlimit和setrlimit</h2><p>每个进程都有一组资源限制,其中一些可以用getrlimit和 setrlimit函数查询和更改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">struct</span> rlimit *rlptr)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> <span class="keyword">struct</span> rlimit *rlptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第7章 进程环境 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 系统数据文件和信息</title>
    <link href="https://www.liuin.cn/2018/04/28/APUE-%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%92%8C%E4%BF%A1%E6%81%AF/"/>
    <id>https://www.liuin.cn/2018/04/28/APUE-系统数据文件和信息/</id>
    <published>2018-04-28T11:26:36.000Z</published>
    <updated>2018-04-30T08:06:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第6章 系统数据文件和信息 笔记</p>
<a id="more"></a>
<h2 id="口令文件"><a href="#口令文件" class="headerlink" title="口令文件"></a>口令文件</h2><p>UNX系统口令文件(POSX1则将其称为用户数据库)包含了如下图所示的各字段,这些字段包含在<pwd.h>中定义的 passwd结构中。</pwd.h></p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250520434469.jpg" alt=""></p>
<p>由于历史原因,口令文件是<code>/etc/passwd</code>,而且是一个ASCII文件。字段之间用冒号分隔。</p>
<p>关于这些信息有以下这些注意事项：</p>
<ul>
<li>通常有一个用户名为root的登录项,其用户ID是0(超级用户）</li>
<li>加密口令包含一个字段，现在出于安全的考虑把加密口令存放在另一个文件中</li>
<li>口令文件项中的某些字段可能是空。如果加密口令字段为空,这通常就意味着该用户没有口令(不推荐这样做)。 </li>
<li>shel字段包含了一个可执行程序名,它被用作该用户的登录 shell.若该字段为空,则取系统默认值,通常是<code>/bin/sh</code>。</li>
<li>为了阻止一个特定用户登录系统,除使用/dev/nu11外,还有若干种替代方法。</li>
</ul>
<p>有两个获取口令文件项的函数。在给出用户登录名或数值用户ID后,这两个函数就能查看相关项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> passwd *<span class="title">getpwuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> passwd *<span class="title">getpwnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
<p>如果想要查看整个口令文件，下面3个函数可以用于此目的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> passwd *<span class="title">getpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer if OK, NULL on error or end of ﬁle</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">endpwent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>调用<code>getpwent</code>时,它返回口令文件中的下一个记录项。函数<code>setpwent</code>反绕它所使用的文件（倒回到所有口令文件的开始）, <code>endpwent</code>则关闭这些文件</p>
<h2 id="阴影口令"><a href="#阴影口令" class="headerlink" title="阴影口令"></a>阴影口令</h2><p>加密口令是经单向加密算法处理过的用户口令副本。因为此算法是单向的,所以不能从加密口令猜测到原来的口令。</p>
<p>现在,某些系统将加密口令存放在另个通常称为阴影口令( shadow password)的文件中。该文件至少要包含用户名和加密囗令。</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250527613967.jpg" alt=""></p>
<p>阴影口令文件不应是一般用户可以读取的。仅有少数几个程序需要访问加密口令,如1ogin(1)和 passwd(1),这些程序常常是设置用户ID为root的程序。</p>
<h2 id="组文件"><a href="#组文件" class="headerlink" title="组文件"></a>组文件</h2><p>UNIX组文件中包含如下的字段，这些字段在<grp.h>所定义的group的数据结构中</grp.h></p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250528423155.jpg" alt=""></p>
<p>查看组名或数值组ID：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> group *<span class="title">getgrgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>; </div><div class="line"><span class="function"><span class="keyword">struct</span> group *<span class="title">getgrnam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
<p>和用户信息一样查看所有组文件函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> group *<span class="title">getgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>; </div><div class="line"><span class="comment">// Returns: pointer if OK, NULL on error or end of ﬁle</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">endgrent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="附属组ID"><a href="#附属组ID" class="headerlink" title="附属组ID"></a>附属组ID</h2><p>我们不仅可以属于口令文件记录项中组ID所对应的组,也可属于多至16个另外的组。文件访问权限检查相应被修改为:不仅将进程的有效组ID与文件的组ID相比较,而且也将所有附属组ID与文件的组ID进行比较</p>
<p>使用附属组ID的优点是不必再显式地经常更改组。一个用户会参与多个项目,因此也就要同时属于多个组,此类情况是常有的。</p>
<p>以下3个函数用于获取和设置附属组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getgroups</span><span class="params">(<span class="keyword">int</span> gidsetsize, <span class="keyword">gid_t</span> grouplist[])</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: number of supplementary group IDs if OK, −1 on error</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt; /* on Linux */ </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; /* on FreeBSD, Mac OS X, and Solaris */ </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgroups</span><span class="params">(<span class="keyword">int</span> ngroups, <span class="keyword">const</span> <span class="keyword">gid_t</span> grouplist[])</span></span>; </div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt; /* on Linux and Solaris */ </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; /* on FreeBSD and Mac OS X */ </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">initgroups</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *username, <span class="keyword">gid_t</span> basegid)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p><code>getgroups</code>将进程所属用户的各附属组ID填写到数组<code>grouplist</code>中,填写入该数组的附属组ID数最多为 <code>gidsetsize</code>个。实际填写到数组中的附属组ID数由函数返回。</p>
<p><code>setgroups</code>可由超级用户调用以便为调用进程设置附属组ID表。<code>grouplist</code>是组ID数组,而 <code>ngroups</code>说明了数组中的元素数。 <code>ngroups</code>的值不能大于 NGROUPS_MAX.</p>
<h2 id="登录账户记录"><a href="#登录账户记录" class="headerlink" title="登录账户记录"></a>登录账户记录</h2><p>大多数UNIX系统都提供下列两个数据文件:utmp文件记录当前登录到系统的各个用户;wtmp文件跟踪各个登录和注销事件。</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250533552178.jpg" alt=""></p>
<h2 id="系统标识"><a href="#系统标识" class="headerlink" title="系统标识"></a>系统标识</h2><p>有一个uname函数,它返回与主机和操作系统有关的信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/utsname.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">uname</span><span class="params">(<span class="keyword">struct</span> utsname *name)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: non-negative value if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="时间和日期例程"><a href="#时间和日期例程" class="headerlink" title="时间和日期例程"></a>时间和日期例程</h2><p>由UNIX内核提供的基本时间服务是计算自协调世界时公元1970年1月1日00：00：00这一特定时间以来经过的秒数。</p>
<p>用数据结构<code>time_t</code>表示，据类型 time_t表示的,我们称它们为日历时间。日历时间包括时间和日期。UNIX在这方面与其他操作系统的区别是:(a)以协调统一时间而非本地时间计时;(b)可自动进行转换,如变换到夏令时;(c)将时间和日期作为一个量值保存。</p>
<p><code>time</code>函数返回当前时间和日期</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">time_t</span> time(<span class="keyword">time_t</span> *calptr);</div><div class="line"></div><div class="line"><span class="comment">// Returns: value of time if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>时间值作为函数值返回。如果参数非空,则时间值也存放在由calptr指向的单元内</p>
<p>关于日期和时间，有许多相关的函数，以下列出其中一些函数的关系：</p>
<p><img src="https://data2.liuin.cn/2018-04-30-15250538112744.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第6章 系统数据文件和信息 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 标准I/O库</title>
    <link href="https://www.liuin.cn/2018/04/27/APUE-%E6%A0%87%E5%87%86I-O%E5%BA%93/"/>
    <id>https://www.liuin.cn/2018/04/27/APUE-标准I-O库/</id>
    <published>2018-04-27T15:31:13.000Z</published>
    <updated>2018-04-29T11:05:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第5章 标准I/O库 笔记</p>
<a id="more"></a>
<h2 id="流和FILE对象"><a href="#流和FILE对象" class="headerlink" title="流和FILE对象"></a>流和FILE对象</h2><p>之前所描述的所有I/O函数都是围绕文件描述符的。当打开一个文件时,即返回一个文件描述符,然后该文件描述符就用于后续的I/O操作。而对于标准I/O库,它们的操作是围绕流(stream)进行。当标准I/O库打开或者创建一个文件时，我们已使一个流与一个文件相关联</p>
<p>对于ASCI字符集,一个字符用一个字节表示。对于国际字符集,一个字符可用多个字节表示。标准IO文件流可用于单字节或多字节(“宽”)字符集。流的定向( stream’s orientation)决定了所读、写的字符是单字节还是多字节的。fwide函数用于设置流的定向</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE *fp, <span class="keyword">int</span> mode)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: positive if stream is wide oriented, negative if stream is byte oriented, or 0 if stream has no orientation</span></div></pre></td></tr></table></figure>
<p><code>mode</code>参数设置为负时为字节定向、为正时为宽定向、为0时不设置流的定向、但是返回该流定向的值</p>
<p>当打开一个流时,标准IO函数 fopen返回一个指向FILE对象的指针。为了引用一个流，需将FILE指针作为参数传给每个标准I/O函数。</p>
<h2 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h2><p>对一个进程预定义了3个流,并且这3个流可以自动地被进程使用,它们是:标准输入、标准输出和标准错误。这些流引用的文件与文件描述符 STDIN_FILENO、 STDOUT_FILENO和STDERR_FILENO所引用的相同。</p>
<h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>标准I/O库提供缓冲的目的是尽可能减少使用read和write调用的次数。标准I/O库最令人迷人的也是其缓冲：</p>
<p>标准I/O提供了以下3种类型的缓冲：</p>
<ol>
<li>全缓冲。在这种情况下,在填满标准I/O缓冲区后才进行实际I/O操作。</li>
</ol>
<p>术语冲洗(flush)说明标准I/O缓冲区的写操作。缓冲区可由标准I/O例程自动地冲洗,或者可以调用函数ff1ush冲洗一个流。</p>
<ol>
<li>行缓冲，在这种情况下,当在输入和输出中遇到换行符时,标准I/O库执行I/O操作。当流涉及一个终端时(如标准输入和标准输出),通常使用行缓冲。</li>
</ol>
<p>对于行缓冲有两个限制。第一,因为标准/O库用来收集每一行的缓冲区的长度是固定的,所以只要填满了缓冲区,那么即使还没有写一个换行符,也进行O操作。第二,任何时候只要通过标准I/O库要求从(a)一个不带缓冲的流,或者(b)一个行缓冲的流(它从内核请求需要数据)得到输入数据,那么就会冲洗所有行缓冲输出流。</p>
<ol>
<li>不带缓冲。标准I/O库不对字符进行缓冲存储。</li>
</ol>
<p>对任何一个给定的流,如果我们并不喜欢这些系统默认,则可调用下列两个函数中的一个更改缓冲类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf )</span></span>;   <span class="comment">// 打开或者关闭缓冲机制</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, nonzero on error</span></div></pre></td></tr></table></figure>
<p>使用setvbuf，我们可以精确说明所需的缓冲类型。这是用<code>mode</code>参数实现的：_IOFBF 全缓冲  _IOLBF  行缓冲  _IONBF  不带缓冲</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247582189497.jpg" alt=""></p>
<p>任何时候，我们可以强制冲洗一个流：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, EOF on error</span></div></pre></td></tr></table></figure></p>
<h2 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h2><p>下列3个函数打开一个标准I/O流</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>; </div><div class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type, FILE *<span class="keyword">restrict</span> fp)</span></span>; </div><div class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All three return: ﬁle pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
<p>3个函数的区别如下：</p>
<ol>
<li>fopen函数打开路径名为pathname的一个指定的文件。</li>
<li>freopen函数在一个指定的流上打开一个指定的文件,如若该流已经打开,则先关闭该流。若该流已经定向,则使用 freopen清除该定向。此函数一般用于将一个指定的文件打开为一个预定义的流:标准输入、标准输出或标准错误。</li>
<li>fopen函数取一个已有的文件描述符，并使一个标准的I/O流与改描述符相结合</li>
</ol>
<p><code>type</code>参数指定对该流的读写方式</p>
<p><img src="https://data2.liuin.cn/2018-04-29-15249858189861.jpg" alt=""></p>
<p>使用字符b作为type的部分,这使得标准I/O系统可以区分文本文件和二进制文件。因为UNIX内核并不对这两种文件进行区分,所以在UNIX系统环境下指定字符b作为type的部分实际上并无作用。</p>
<p>调用<code>fclose</code>关闭一个打开的流：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, EOF on error</span></div></pre></td></tr></table></figure>
<h2 id="读和写流"><a href="#读和写流" class="headerlink" title="读和写流"></a>读和写流</h2><p>一旦打开了流,则可在3种不同类型的非格式化I/O中进行选择,对其进行读、写操作：</p>
<ol>
<li>每次一个字符I/O</li>
<li>每次一行I/O</li>
<li>直接I/O</li>
</ol>
<blockquote>
<p>输入函数</p>
</blockquote>
<p>以下3个函数可以用于一次读一个字符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All three return: next character if OK, EOF on end of ﬁle or error</span></div></pre></td></tr></table></figure>
<p>函数getchar等同于getc(stdin)。前两个函数的区别是，getc可以被实现为宏，而fgetc不能被实现为宏</p>
<p>注意,不管是出错还是到达文件尾端,这3个函数都返回同样的值。为了区分这两种不同的情况,必须调用 ferror或feof。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: nonzero (true) if condition is true, 0 (false) otherwise </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *fp)</span></span>;</div></pre></td></tr></table></figure>
<p>大多数情况下，每一个流的FILE对象中都维护了两个标志：出错标志和文件结束标志。调用clearerr可以清楚这些标志。</p>
<p>从流中读取数据以后,可以调用 ungetc将字符再压送回流中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: c if OK, EOF on error</span></div></pre></td></tr></table></figure>
<blockquote>
<p>输出函数</p>
</blockquote>
<p>对应于上面每一个输入函数都有一个输出函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All three return: c if OK, EOF on error</span></div></pre></td></tr></table></figure>
<h2 id="每一行-I-O"><a href="#每一行-I-O" class="headerlink" title="每一行 I/O"></a>每一行 I/O</h2><p>以下两个函数提供每次输入一行的功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> n, FILE *<span class="keyword">restrict</span> fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *buf )</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: buf if OK, NULL on end of ﬁle or error</span></div></pre></td></tr></table></figure>
<p>这两个函数都指定了缓冲区的地址,读入的行将送入其中。gets从标准输入读,而fgets从指定的流读</p>
<p>对于 fgets,必须指定缓冲的长度n。此函数一直读到下一个换行符为止,但是不超过n个字符,读入的字符被送入缓冲区。</p>
<p>gets是一个不推荐使用的函数。其问题是调用者在使用qets时不能指定缓冲区的长度。这样就可能造成缓冲区溢出(如若该行长于缓冲区长度),写到缓冲区之后的存储空间中,从而产生不可预料的后果。这种缺陷可以被利用制作蠕虫病毒。</p>
<p>fputs和puts提供每次输出一行的功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> str, FILE *<span class="keyword">restrict</span> fp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: non-negative value if OK, EOF on error</span></div></pre></td></tr></table></figure>
<p>函数 fputs将一个以nul字节终止的字符串写到指定的流,尾端的终止符nu不写出。</p>
<h2 id="二进制I-O"><a href="#二进制I-O" class="headerlink" title="二进制I/O"></a>二进制I/O</h2><p>之前提到的I/O函数函数以一次一个字符或一次一行的方式进行操作。如果进行二进制I/O操作,那么我们更愿意一次读或写一个完整的结构。</p>
<p>有下面两个函数提供二进制的I/O操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp);</div><div class="line"></div><div class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE *<span class="keyword">restrict</span> fp);</div><div class="line"></div><div class="line"><span class="comment">// Both return: number of objects read or written</span></div></pre></td></tr></table></figure>
<p>这些函数有两个用法：</p>
<ol>
<li>读写二进制数组</li>
<li>读写自定义的一个结构体</li>
</ol>
<p>其中参数<code>nobj</code>表示要读写的对象的个数</p>
<p>使用二进制I/O的基本问题是,它只能用于读在同一系统上已写的数据。这样就导致了一个问题：在一个系统写的数据要在另一个系统上进行处理。在这种环境下,这两个函数可能就不能正常工作,其原因是:</p>
<ol>
<li>在一个结构中,同一成员的偏移量可能随编译程序和系统的不同而不同(由于不同的对齐要求)。</li>
<li>用来存储多字节整数和浮点值的二进制格式在不同的系统结构间也可能不同</li>
</ol>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>在UNIX中,标准I/O库最终都要调用I/O例程来实现（read、write）。每个标准I/O流都有一个与其相关联的文件描述符,可以对一个流调用<code>fi1eno</code>函数以获得其描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: the ﬁle descriptor associated with the stream</span></div></pre></td></tr></table></figure>
<h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><p>标准I/O库提供两个函数来创建临时文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer to unique pathname</span></div><div class="line"></div><div class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: ﬁle pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
<p>tmpnam函数产生一个与现有文件名不同的一个有效路径名字符串。每次调用它时,都产生个不同的路径名,最多调用次数是 TMP_MAX</p>
<p>若ptr是NULL,则所产生的路径名存放在一个静态区中,指向该静态区的指针作为函数值返回。</p>
<p>tmpfile创建一个临时二进制文件(类型wb+),在关闭该文件或程序结束时将自动删除这种文件</p>
<p>tmpfi1e函数经常使用的标准UNIX技术是先调用 tmpnam产生一个唯一的路径名,然后用该路径名创建一个文件,并立即un1ink它。</p>
<h2 id="内存流"><a href="#内存流" class="headerlink" title="内存流"></a>内存流</h2><p>标准I/O库把数据缓存在内存中,因此每次一字符和每次一行的I/O更有效。我们也可以通过调用 setbuf或 setvbuf函数让IO库使用我们自己的缓冲区。</p>
<p>有3个函数可以用于内存流的创建，第一个函数是fmemopen函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function">FILE *<span class="title">fmemopen</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: stream pointer if OK, NULL on error</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第5章 标准I/O库 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE 文件和目录</title>
    <link href="https://www.liuin.cn/2018/04/26/APUE-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
    <id>https://www.liuin.cn/2018/04/26/APUE-文件和目录/</id>
    <published>2018-04-26T06:08:38.000Z</published>
    <updated>2018-04-26T08:17:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第4章 文件和目录 笔记</p>
<a id="more"></a>
<h2 id="函数stat、fstat、fstatat和lstat"><a href="#函数stat、fstat、fstatat和lstat" class="headerlink" title="函数stat、fstat、fstatat和lstat"></a>函数stat、fstat、fstatat和lstat</h2><p>返回文件信息的主要有4个函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">struct</span> stat *buf )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname,<span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// All four return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>一旦给出pathname：</p>
<ul>
<li>stat将返回与此命名文件有关的信息结构：</li>
<li>fstat函数获得已在描述符fd上打开文件的有关信息</li>
<li>1stat函数类似于stat,但是当命名的文件是一个符号链接时,1stat返回该符号链接的有关信息,而不是由该符号链接引用的文件的信息。</li>
<li>fstatat函数为一个相对于当前打开目录(由fd参数指向)的路径名返回文件统计信息。</li>
</ul>
<p>第二个参数buf是一个指针，其指向一个我们必须提供的结构。函数来填充由buf指向的结构。其基本格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> stat &#123; </div><div class="line">    <span class="keyword">mode_t</span> st_mode; <span class="comment">/* file type &amp; mode (permissions) */</span> </div><div class="line">    <span class="keyword">ino_t</span> st_ino; <span class="comment">/* i-node number (serial number) */</span> </div><div class="line">    <span class="keyword">dev_t</span> st_dev; <span class="comment">/* device number (file system) */</span> </div><div class="line">    <span class="keyword">dev_t</span> st_rdev; <span class="comment">/* device number for special files */</span> </div><div class="line">    <span class="keyword">nlink_t</span> st_nlink; <span class="comment">/* number of links */</span> </div><div class="line">    <span class="keyword">uid_t</span> st_uid; <span class="comment">/* user ID of owner */</span> </div><div class="line">    <span class="keyword">gid_t</span> st_gid; <span class="comment">/* group ID of owner */</span> </div><div class="line">    <span class="keyword">off_t</span> st_size; <span class="comment">/* size in bytes, for regular files */</span> </div><div class="line">    <span class="keyword">struct</span> timespec st_atim; <span class="comment">/* time of last access */</span> </div><div class="line">    <span class="keyword">struct</span> timespec st_mtim; <span class="comment">/* time of last modification */</span> </div><div class="line">    <span class="keyword">struct</span> timespec st_ctim; <span class="comment">/* time of last file status change */</span> </div><div class="line">    <span class="keyword">blksize_t</span> st_blksize; <span class="comment">/* best I/O block size */</span> </div><div class="line">    <span class="keyword">blkcnt_t</span> st_blocks; <span class="comment">/* number of disk blocks allocated */</span> </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>UNIX系统的大多数文件是普通文件或目录,但是也有另外一些文件类型。文件类型包括如下几种：</p>
<ol>
<li>普通文件（regular file）文本文件或者二进制文件</li>
<li>目录文件（directory file），对一个目录文件具有读权限的任一进程都可以读该目录的内容,但只有内核可以直接写目录文件。</li>
<li>块特殊文件（block special file），这种类型的文件提供对设备(如磁盘)带缓冲的访问,</li>
<li>字符特殊文件(character special file)。这种类型的文件提供对设备不带缓冲的访问</li>
<li>FIFO，用于进程间通信的命名管道</li>
<li>套接字（socket），用于网络间进程通信</li>
<li>符号链接（symbol link），这种类型的文件指向另一个文件</li>
</ol>
<p>文件类型信息包含在stat结构的 st_mode成员中。也可以使用自带的宏确定的文件类型</p>
<h2 id="设置用户ID和设置组ID"><a href="#设置用户ID和设置组ID" class="headerlink" title="设置用户ID和设置组ID"></a>设置用户ID和设置组ID</h2><p>和一个进程相关联的ID有6个：</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247249639065.jpg" alt=""></p>
<ul>
<li>实际用户ID和实际组ID标识我们究竟是谁。这两个字段在登录时取自口令文件中的登录项。通常,在一个登录会话期间这些值并不改变,但是超级用户进程有办法改变</li>
<li>有效用户ID、有效组IDD以及附属组ID决定了我们的文件访问权限</li>
<li>保存的设置用户ID和保存的设置组ID在执行一个程序时包含了有效用户ID和有效组ID的副本</li>
</ul>
<p>通常,有效用户ID等于实际用户ID,有效组ID等于实际组ID</p>
<p>每个文件有一个所有者和组所有者,所有者由stat结构中的<code>st_uid</code>指定,组所有者则由<code>st_gid</code>指定</p>
<h2 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a>文件访问权限</h2><p>st_mode值也包含了对文件的访问权限位。当提及文件时,指的是前面所提到的任何类型的文件。所有文件类型(目录、字符特别文件等)都有访问权限( access permission)。</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247252761376.jpg" alt=""></p>
<p>3类访问权限的使用方式如下：</p>
<ul>
<li>我们用名字打开任一类型的文件时,对该名字中包含的每一个目录,包括它可能隐含的当前工作目录都应具有执行权限。这就是为什么对于目录其执行权限位常被称为搜索位的原因</li>
<li>对于一个文件的读权限决定了我们是否能够打开现有文件进行读操作</li>
<li>对于一个文件的写权限决定了我们是否能够打开现有文件进行写操作</li>
<li>为了在open函数中对一个文件指定O_TRUNC标志,必须对该文件具有写权限</li>
<li>为了在一个目录中创建一个新文件,必须对该目录具有写权限和执行权限</li>
<li>为了删除一个现有文件,必须对包含该文件的目录具有写权限和执行权限。</li>
</ul>
<p>进程每次打开、创建或者删除一个文件的时候，内核就对文件进行访问权限测试。</p>
<p>内核测试的具体内容：</p>
<ol>
<li>若进程的有效用户ID是0(超级用户),则允许访问。这给予了超级用户对整个文件系统进行处理的最充分的自由</li>
<li>若进程的有效用户ID等于文件的所有者ID(也就是进程拥有此文件),那么如果所有者适当的访问权限位被设置,则允许访问;否则拒绝访问。</li>
<li>若进程的有效组ID或进程的附属组ID之一等于文件的组ID,那么如果组适当的访问权限位被设置,则允许访问;否则拒绝访问。</li>
<li>若其他用户适当的访问权限位被设置,则允许访问;否则拒绝访问</li>
</ol>
<h2 id="新文件和目录的所有权"><a href="#新文件和目录的所有权" class="headerlink" title="新文件和目录的所有权"></a>新文件和目录的所有权</h2><p>新文件的用户ID设置为进程的有效用户ID。</p>
<p>关于组ID，POSIX实现有两种方案：</p>
<ul>
<li>进程有效组ID</li>
<li>所在目录的组ID</li>
</ul>
<h2 id="函数access和faccessat"><a href="#函数access和faccessat" class="headerlink" title="函数access和faccessat"></a>函数access和faccessat</h2><p>正如前面所说,当用open函数打开一个文件时,内核以进程的有效用户ID和有效组ID为基础执行其访问权限测试。有时,进程也希望按其实际用户ID和实际组ID来测试其访问能力。</p>
<p><code>access</code>和 <code>faccessat</code>函数是按实际用户ID和实际组ID进行访问权限测试的。(该测试也分成4步）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccessat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p><code>flag</code>参数可以用于改变<code>faccessat</code>的行为,如果<code>fag</code>设置为<code>AT_EACCESS</code>,访问检查用的是调用进程的有效用户ID和有效组D,而不是实际用户ID和实际组ID</p>
<h2 id="函数umask"><a href="#函数umask" class="headerlink" title="函数umask"></a>函数umask</h2><p><code>umask</code>函数为进程设置文件模式创建屏蔽字,并返回之前的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">mode_t</span> umask(<span class="keyword">mode_t</span> cmask);</div><div class="line"></div><div class="line"><span class="comment">// Returns: previous ﬁle mode creation mask</span></div></pre></td></tr></table></figure>
<p><code>cmask</code>是9个权限访问为常量（S_IRUSR、S_IWUSR）的若干个或组成的</p>
<p>在进程创建一个新文件或新目录时,就一定会使用文件模式创建屏蔽字</p>
<p>UNX系统的大多数用户从不处理他们的 umask值。通常在登录时,由 shell的启动文件设置一次,然后,再不改变。</p>
<p>用户可以设置 umask值以控制他们所创建文件的默认权限。该值表示成八进制数,一位代表一种要屏蔽的权限,这示于图4-10中。设置了相应位后,它所对应的权限就会被拒绝常用的几种 umask值是002、022和027。002阻止其他用户写入你的文件,022阻止同组成员和其他用户写入你的文件,027阻止同组成员写你的文件以及其他用户读、写或执行你的文件。</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247265122569.jpg" alt=""></p>
<h2 id="函数chmod、fchmod和fchmodat"><a href="#函数chmod、fchmod和fchmodat" class="headerlink" title="函数chmod、fchmod和fchmodat"></a>函数chmod、fchmod和fchmodat</h2><p>chmod、fchmod和fchmodat这3个函数使我们可以更改现有文件的访问权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmodat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode, <span class="keyword">int</span> ﬂag)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All three return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>chmod函数在指定的文件上进行操作,而fchmod函数则对已打开的文件进行操作。fchmodat函数与chmod函数在下面两种情况下是相同的:一种是 pathname参数为绝对路径另一种是/参数取值为 AT_FDCWD而 pathname参数为相对路径。</p>
<p>为了改变一个文件的权限位,进程的有效用户ID必须等于文件的所有者ID,或者该进程必须具有超级用户权限。</p>
<h2 id="粘着位"><a href="#粘着位" class="headerlink" title="粘着位"></a>粘着位</h2><p>在UNIX尚未使用请求分页式技术的早期版本中, S_ISVTX位被称为粘着位( sticky bit)。如果一个可执行程序文件的这一位被设置了,那么当该程序第一次被执行,在其终止时,程序正文部分的一个副本仍被保存在交换区(程序的正文部分是机器指令)。这使得下次执行该程序时能较快地将其装载入内存。</p>
<p>后来的UNIX版本称它为保存正文位( saved-text bit),因此也就有了常量S_ISVTX。现今较新的UNX系统大多数都配置了虚拟存储系统以及快速文件系统,所以不再需要使用这种技术</p>
<p>现在粘着位的使用方法是：<br>如果对一个目录设置了粘着位,只有对该目录具有写权限的用户并且满足下列条件之一,才能删除或重命名该目录下的文件</p>
<ul>
<li>拥有此文件</li>
<li>拥有此目录</li>
<li>是超级用户</li>
</ul>
<h2 id="函数chown、fchown、fchownat和lchown"><a href="#函数chown、fchown、fchownat和lchown" class="headerlink" title="函数chown、fchown、fchownat和lchown"></a>函数chown、fchown、fchownat和lchown</h2><p>下面几个chown函数可用于更改文件的用户ID和组ID。如果两个参数 owner或 group中的任意一个是-1,则对应的ID不变</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchownat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>; All four <span class="keyword">return</span>: </div><div class="line"></div><div class="line"><span class="comment">// 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>基于BSD的系统一直规定只有超级用户才能更改一个文件的所有者这样做的原因是防止用户改变其文件的所有者从而摆脱磁盘空间限额对他们的限制。 System V则允许任一用户更改他们所拥有的文件的所有者。</p>
<h2 id="文件长度"><a href="#文件长度" class="headerlink" title="文件长度"></a>文件长度</h2><p><code>stat</code>结构成员<code>st_size</code>表示以字节为单位的文件的长度。此字段只对普通文件、目录文件和符号链接有意义。</p>
<p>对于普通文件,其文件长度可以是0；对于目录,文件长度通常是一个数(如16或512)的整倍数；对于符号链接,文件长度是在文件名中的实际字节数。</p>
<p>现今,大多数现代的UNIⅨ系统提供字段stb1ks1ze和st_b1ocks。其中,第一个是对文件I/O较合适的块长度,第二个是所分配的实际512字节块块数。</p>
<blockquote>
<p>文件空洞</p>
</blockquote>
<p>空洞是由所设置的文件偏移量超过文件尾端，并写入了某些数据造成的。</p>
<h2 id="文件截断"><a href="#文件截断" class="headerlink" title="文件截断"></a>文件截断</h2><p>有时我们需要在文件尾端处截去一些数据以缩短文件。将一个文件的长度截断为0是一个特例,在打开文件时使用 O_TRUNC标志可以做到这一点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">off_t</span> length)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>这两个函数将一个现有文件长度截断为 length。如果该文件以前的长度大于 length,则超过length以外的数据就不再能访问。如果以前的长度小于 length,文件长度将增加,在以前的文件尾端和新的文件尾端之间的数据将读作0(也就是可能在文件中创建了一个空洞)</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>目前,正在使用的UNIX文件系统有多种实现。例如, Solaris支持多种不同类型的磁盘文件系统:传统的基于BSD的UNIX文件系统(称为UFS),读、写DOS格式软盘的文件系统(称为PCFS),以及读CD的文件系统(称为HSFS)。</p>
<p>我们可以把一个磁盘分成一个或多个分区。每个分区可以包含一个文件系统，i节点是固定长度的记录项,它包含有关文件的大部分信息。</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247278022212.jpg" alt=""></p>
<p>更仔细地观察一个柱面组的i节点和数据块部分：</p>
<p><img src="https://data2.liuin.cn/2018-04-26-15247278729393.jpg" alt=""></p>
<p>在图中有两个目录项指向同一个i节点。每个i节点中都有一个链接计数,其值是指向该i节点的目录项数。只有当链接计数减少至0时,才可删除该文件(也就是可以释放该文件占用的数据块)。这就是为什么“解除对一个文件的链接”操作并不总是意味着“释放该文件占用的磁盘块”的原因。这也是为什么删除一个目录项的函数被称之为<code>un1ink</code></p>
<p>另外一种链接类型称为符号链接( symbolic link)。符号链接文件的实际内容(在数据块中)包含了该符号链接所指向的文件的名字。</p>
<p>节点包含了文件有关的所有信息:文件类型、文件访问权限位、文件长度和指向文件数据块的指针等。stat结构中的大多数信息都取自i节点。只有两项重要数据存放在目录项中:文件名和节点编号。</p>
<p>因为目录项中的i节点编号指向同一文件系统中的相应i节点,<strong>一个目录项不能指向另个文件系统的i节点</strong>。这就是为什么1n(1)命令不能跨越文件系统的原因</p>
<p>当在不更换文件系统的情况下为一个文件重命名时,该文件的实际内容并未移动,只需构造一个指向现有i节点的新目录项,并删除老的目录项。链接计数不会改变。</p>
<p>我们说明了普通文件链接计数的概念，对于目录的链接计数相关方法如下：</p>
<p>任何一个叶目录(不包含任何其他目录的目录)的链接计数总是2,数值2来自于命名该目录( testdir)的目录项以及在该目录中的.项。在父目录中的每一个子目录都使该父目录的链接计数增加1</p>
<h2 id="函数link、linkat、unlink、unlinkat和remove"><a href="#函数link、linkat、unlink、unlinkat和remove" class="headerlink" title="函数link、linkat、unlink、unlinkat和remove"></a>函数link、linkat、unlink、unlinkat和remove</h2><p>创建一个指向现有文件的链接的方法是使用linke或者linkat函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">linkat</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">int</span> nfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>这两个函数创建一个新目录项<code>newpath</code>,它引用现有文件 <code>existingpath</code></p>
<p>为了删除一个现有的目录项、可以调用unlink函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlinkat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>这两个函数删除目录项,并将由pathname所引用文件的链接计数减1。如果对该文件还有其他链接,则仍可通过其他链接访问该文件的数据。如果出错,则不对该文件做任何更改。</p>
<p>我们在前面已经提及,为了解除对文件的链接,必须对包含该目录项的目录具有写和执行权限。如果对该目录设置了粘着位,则对该目录必须具有写权限,并且具备下面三个条件之一:拥有该文件、拥有该目录或者具有超级用户权限</p>
<p>只有当链接计数达到0时,该文件的内容才可被删除。另一个条件也会阻止删除文件的内容——<strong>只要有进程打开了该文件,其内容也不能删除</strong>。关闭一个文件时,内核首先检查打开该文件的进程个数;如果这个计数达到0,内核再去检查其链接计数;如果计数也是0,那么就删除该文件的内容。</p>
<p>ulink的这种特性经常被程序用来确保即使是在程序崩溃时,它所创建的临时文件也不会遗留下来。进程用open或 creat创建一个文件,然后立即调用 unlink,因为该文件仍旧是打开的,所以不会将其内容删除。只有当进程关闭该文件或终止时，该文件的内容才被删除。</p>
<p>我们也可以用<code>remove</code>函数解除对一个文件或目录的链接。对于文件,<code>remove</code>的功能与<code>unlink</code>相同。对于目录,<code>remove</code>的功能与<code>rmdir</code>相同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="函数rename和renameat"><a href="#函数rename和renameat" class="headerlink" title="函数rename和renameat"></a>函数rename和renameat</h2><p>文件或目录可以用 rename函数或者 renameat函数进行重命名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">renameat</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">int</span> newfd,<span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2><p>符号链接是对一个文件的间接指针,它与上一节所述的硬链接有所不同,硬链接直接指向文件的i节点。引入符号链接的原因是为了避开硬链接的一些限制：</p>
<ul>
<li>硬链接通常要求链接和文件位于同一文件系统中。</li>
<li>只有超级用户才能创建指向目录的硬链接(在底层文件系统支持的情况下)。</li>
</ul>
<p>对符号链接以及它指向何种对象并无任何文件系统限制,任何用户都可以创建指向目录的符号链接。符号链接一般用于将一个文件或整个目录结构移到系统中另一个位置</p>
<h2 id="创建和读取符号链接"><a href="#创建和读取符号链接" class="headerlink" title="创建和读取符号链接"></a>创建和读取符号链接</h2><p>可以用symlink或symlikat函数创建一个符号链接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlinkat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>因为open函数跟随符号链接,所以需要有一种方法打开该链接本身,并读该链接中的名字read1ink和 readlinkat函数提供了这种功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> readlink(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize); </div><div class="line"><span class="keyword">ssize_t</span> readlinkat(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize); </div><div class="line"></div><div class="line"><span class="comment">// Both return: number of bytes read if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="文件的时间"><a href="#文件的时间" class="headerlink" title="文件的时间"></a>文件的时间</h2><p>每个文件属性所保存的实际精度依赖于文件系统的实现。对于把时间戳记录在秒级的文件系统来说,纳秒这个字段就会被填充为0。对于时间戳的记录精度高于秒级的文件系统来说,不足秒的值被转换成纳秒并记录在纳秒这个字段中。</p>
<p>每个文件维护3个时间字段：<br><img src="https://data2.liuin.cn/2018-04-26-15247296049968.jpg" alt=""></p>
<p>注意修改时间( st_mtim)和状态更改时间( st_ctim)之间的区别。修改时间是文件内容最后一次被修改的时间。状态更改时间是该文件的i节点最后一次被修改的时间。系统并不维护对一个i节点的最后一次访问时间,所以 access和stat函数并不更改这3个时间中的任一个。</p>
<h2 id="函数futimens、utimensat和utimes"><a href="#函数futimens、utimensat和utimes" class="headerlink" title="函数futimens、utimensat和utimes"></a>函数futimens、utimensat和utimes</h2><p>一个文件的访问和修改时间可以用以下几个函数更改。<code>futimens</code>和<code>utimensat</code>函数可以指定纳秒级精度的时间戳。用到的数据结构是与stat函数族相同的timespec结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimens</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>])</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimensat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>], <span class="keyword">int</span> ﬂag)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="函数mkdir、mkdirat和rmdir"><a href="#函数mkdir、mkdirat和rmdir" class="headerlink" title="函数mkdir、mkdirat和rmdir"></a>函数mkdir、mkdirat和rmdir</h2><p>用 mkdir和 mkdirat函数创建目录,用rmdir函数删除目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdirat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>这两个函数创建一个新的空目录。其中,.和..目录项是自动创建的。所指定的文件访问权限mode由进程的文件模式创建屏蔽字修改。</p>
<p>用 <code>rmdir</code>函数可以删除一个空目录。空目录是只包含.和..这两项的目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="读目录"><a href="#读目录" class="headerlink" title="读目录"></a>读目录</h2><p>对某个目录具有访问权限的任一用户都可以读该目录,但是,为了防止文件系统产生混乱只有内核才能写目录。</p>
<p>读目录相关的系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>; </div><div class="line"><span class="function">DIR *<span class="title">fdopendir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: pointer if OK, NULL on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> dirent *<span class="title">readdir</span><span class="params">(DIR *dp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: pointer if OK, NULL at end of directory or error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dp)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">telldir</span><span class="params">(DIR *dp)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: current location in directory associated with dp </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekdir</span><span class="params">(DIR *dp, <span class="keyword">long</span> loc)</span></span>;</div></pre></td></tr></table></figure>
<h2 id="函数chdir、fchdir和getcwd"><a href="#函数chdir、fchdir和getcwd" class="headerlink" title="函数chdir、fchdir和getcwd"></a>函数chdir、fchdir和getcwd</h2><p>每个进程都有一个当前工作目录,此目录是搜索所有相对路径名的起点(不以斜线开始的路径名为相对路径名)。当用户登录到UNIX系统时,其当前工作目录通常是口令文件(/etc/ passwd)中该用户登录项的第6个字段——用户的起始目录( home directory)。当前工作目录是进程的一个属性,起始目录则是登录名的一个属性</p>
<p>进程调用chdir和fchdir函数可以改变当前工作目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchdir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>我们需要一个函数,它从当前工作目录(.)开始,用.找到其上一级目录,然后读其目录项,直到该目录项中的i节点编号与工作目录i节点编号相同,这样地就找到了其对应的文件名按照这种方法,逐层上移,直到遇到根,这样就得到了当前工作目录完整的绝对路径名。很幸运,函数 getcwd就提供了这种功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: buf if OK, NULL on error</span></div></pre></td></tr></table></figure>
<h2 id="文件访问权限位小结"><a href="#文件访问权限位小结" class="headerlink" title="文件访问权限位小结"></a>文件访问权限位小结</h2><p><img src="https://data2.liuin.cn/2018-04-26-15247306715849.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第4章 文件和目录 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>I/O多路复用之Select、Poll和Epoll</title>
    <link href="https://www.liuin.cn/2018/04/20/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8BSelect%E3%80%81Poll%E5%92%8CEpoll/"/>
    <id>https://www.liuin.cn/2018/04/20/I-O多路复用之Select、Poll和Epoll/</id>
    <published>2018-04-20T12:45:23.000Z</published>
    <updated>2018-04-21T08:10:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期写一个在线聊天室的时候接触到epoll，加上之前腾讯面试的时候面试官有问到这一题。这里就对select、poll和epoll做一个总结，目的是让自己更加深入地理解，大部分内容来自网上，可能存在错误，欢迎大家指正。</p>
<a id="more"></a>
<h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p>之前在讲阻塞/非阻塞和同步/异步的理解的时候讲到，在Unix网络I/O中，有三种同步I/O方式：阻塞式I/O、非阻塞式I/O和I/O复用。</p>
<p>I/O多路复用简单来说就是对多个文件进行操作，<strong>通过一种机制一个进程能同时等待多个文件描述符</strong>，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回</p>
<p>select，poll，epoll都是I/O多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>
<h2 id="Linux内核的wakeup-callback机制"><a href="#Linux内核的wakeup-callback机制" class="headerlink" title="Linux内核的wakeup callback机制"></a>Linux内核的wakeup callback机制</h2><p>Linux内核的wakeup callback机制是I/O多路复用存在的本质。Linux内核通过睡眠队列来组织所有等待某个事件的task，而wakeup机制则可以异步唤醒整个睡眠队列上的task，每一个睡眠队列上的节点都拥有一个callback，wakeup逻辑在唤醒睡眠队列时，会遍历该队列链表上的每一个节点，调用每一个节点的callback，如果遍历过程中遇到某个节点是排他节点，则终止遍历，不再继续遍历后面的节点。</p>
<p>总体有两个逻辑：（1）睡眠等待逻辑；（2）唤醒逻辑。</p>
<blockquote>
<p>睡眠等待逻辑</p>
</blockquote>
<ul>
<li>select、poll、epoll_wait陷入内核，判断监控的fd是否有关心的事件发生了，如果没，则为当前task构建一个wait_entry节点，然后插入到监控fd的sleep_list</li>
<li>进入循环的schedule直到关心的事件发生了</li>
<li>关心的事件发生后，将当前task的wait_entry节点从socket的sleep_list中删除</li>
</ul>
<blockquote>
<p>唤醒逻辑</p>
</blockquote>
<ul>
<li>fd监听的事件发生了，然后fd顺序遍历其睡眠队列，依次调用每个wait_entry节点的callback函数</li>
<li>直到完成队列的遍历或遇到某个wait_entry节点是排他的才停止</li>
<li>一般情况下callback包含两个逻辑：1.wait_entry自定义的私有逻辑；2.唤醒的公共逻辑，主要用于将该wait_entry的task放入CPU的就绪队列，让CPU随后可以调度其执行。</li>
</ul>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</div></pre></td></tr></table></figure>
<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。nfds表示所有监视的文件描述符中最高的数+1，同时可以定义时间timeout，超过时间将返回0。</p>
<p>调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>当用户进程调用select的时候，select会将需要监控的readfds集合拷贝到内核空间（假设监控的仅仅是fd可读），然后遍历自己监控的fd_sk，挨个调用sk的poll逻辑以便检查该sk是否有可读事件，遍历完所有的sk后，如果没有任何一个sk可读，那么select会调用schedule_timeout进入schedule循环，使得process进入睡眠。如果在timeout时间内某个sk上有数据可读了，或者等待timeout了，则调用select的process会被唤醒，接下来select就是遍历监控的sk集合，挨个收集可读事件并返回给用户了</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。</p>
<p>但是通过上面实现的分析，select还存在的问题是：</p>
<ul>
<li>被监控的fds需要从用户空间拷贝到内核空间。为了减少数据拷贝带来的性能损坏，内核对被监控的fds集合大小做了限制，并且这个是通过宏控制的，大小不可改变(限制为1024)。</li>
<li>被监控的fds集合中，只要有一个有数据可读，整个socket集合就会被遍历一次调用sk的poll函数收集可读事件。由于当初的需求是朴素，仅仅关心是否有数据可读这样一个事件，当事件通知来的时候，由于数据的到来是异步的，我们不知道事件来的时候，有多少个被监控的socket有数据可读了，于是，只能挨个遍历每个socket来收集可读事件，但是我们希望的是能够从通知中得到有可读事件的fds列表，而不是需要遍历整个fds来收集</li>
</ul>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div></pre></td></tr></table></figure>
<p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的数组实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> pollfd &#123;</div><div class="line">   <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></div><div class="line">   <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span></div><div class="line">   <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>fd表示检测的文件描述符，要测试的条件由 events成员指定,函数在相应的 revents成员中返回该描述符的状态。和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>
<p>poll虽然解决了fds集合大小1024的限制问题，但是，它并没改变大量描述符数组被整体复制于用户态和内核态的地址空间之间，以及个别描述符就绪触发整体描述符集合的遍历的低效问题。poll随着监控的socket集合的增加性能线性下降，poll不适合用于大并发场景。</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>epoll含有的接口有三个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;   </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span></span></div><div class="line">                      <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout);</div></pre></td></tr></table></figure>
<blockquote>
<p>epoll_create</p>
</blockquote>
<p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</p>
<p>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽</p>
<blockquote>
<p>epoll_ctl</p>
</blockquote>
<p>对由<code>epfd</code>所引用的epoll实例进行操作，其中<code>op</code>表示操作类型(包含增删改)，<code>fd</code>表示操作的目标文件描述符，<code>event</code>和文件描述符相关联表示具体监听什么事件，以下是<code>event</code>的具体数据结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</div><div class="line">   <span class="keyword">void</span>        *ptr;</div><div class="line">   <span class="keyword">int</span>          fd;</div><div class="line">   <span class="keyword">uint32_t</span>     u32;</div><div class="line">   <span class="keyword">uint64_t</span>     u64;</div><div class="line">&#125; <span class="keyword">epoll_data_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> epoll_event &#123;</div><div class="line">   <span class="keyword">uint32_t</span>     events;      <span class="comment">/* 监听的事件属性，通常包含：读、写、出错、挂断等等 */</span></div><div class="line">   <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* 事件信息 */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>epoll_wait</p>
</blockquote>
<p>等待<code>epfd</code>所引用的epoll实例上的I/O就绪，同时用<code>events</code>来获得从内核得到的事件集合、<code>maxevents</code>表示传入的events有多少</p>
<p>函数返回以后可以遍历event数组，对已经就绪的I/O进行处理。</p>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>在每个事件的属性中可以设置对文件描述符的工作模式，有两种模式：水平触发LT（level trigger）和边沿出发ET（edge trigger）。LT模式是默认模式。两种模式的区别如下：</p>
<p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序可以不立即处理该事件</strong>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p>
<p>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序必须立即处理该事件</strong>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<p>对于可读事件而言，在ET模式下，如果某个socket有新的数据到达，那么该sk就会被排入epoll的ready_list，从而epoll_wait就一定能收到可读事件的通知(调用sk的poll逻辑一定能收集到可读事件)。于是，我们通常理解的缓冲区状态变化(从无到有)的理解是不准确的，准确的理解应该是是否有新的数据达到缓冲区。</p>
<p>而在LT模式下，某个sk被探测到有数据可读，那么该sk会被重新加入到read_list，那么在该sk的数据被全部取走前，下次调用epoll_wait就一定能够收到该sk的可读事件(调用sk的poll逻辑一定能收集到可读事件)，从而epoll_wait就能返回。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><blockquote>
<p>fds集合拷贝问题的解决</p>
</blockquote>
<p>细看select或poll的函数原型，我们会发现，每次调用select或poll都在重复地准备(集中处理)整个需要监控的fds集合。然而对于频繁调用的select或poll而言，fds集合的变化频率要低得多，我们没必要每次都重新准备(集中处理)整个fds集合。</p>
<p>于是，epoll引入了epoll_ctl系统调用，将高频调用的epoll_wait和低频的epoll_ctl隔离开。同时，epoll_ctl通过(EPOLL_CTL_ADD、EPOLL_CTL_MOD、EPOLL_CTL_DEL)三个操作来分散对需要监控的fds集合的修改，做到了有变化才变更，将select或poll高频、大块内存拷贝(集中处理)变成epoll_ctl的低频、小块内存的拷贝(分散处理)，避免了大量的内存拷贝。同时，对于高频epoll_wait的可读就绪的fd集合返回的拷贝问题，epoll通过内核与用户空间mmap(内存映射)同一块内存来解决。mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址（不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理地址），使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。</p>
<p>另外，epoll通过epoll_ctl来对监控的fds集合来进行增、删、改，那么必须涉及到fd的快速查找问题，于是，一个低时间复杂度的增、删、改、查的数据结构来组织被监控的fds集合是必不可少的了。在linux 2.6.8之前的内核，epoll使用hash来组织fds集合，于是在创建epoll fd的时候，epoll需要初始化hash的大小。于是epoll_create(int size)有一个参数size，以便内核根据size的大小来分配hash的大小。在linux 2.6.8以后的内核中，epoll使用红黑树来组织监控的fds集合，于是epoll_create(int size)的参数size实际上已经没有意义了。</p>
<blockquote>
<p>按需遍历就绪的fds集合</p>
</blockquote>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)</p>
<p>其优点主要有如下几点：</p>
<ul>
<li>监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于1024</li>
<li>IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>监视事件数量</p>
</blockquote>
<p>select受限于1024（依据系统而定），poll虽然数量上没有收到限制，但是因为需要轮询数量非常大的时候性能会下降，epoll在数量和性能上面都没有限制</p>
<blockquote>
<p>实现方式</p>
</blockquote>
<p>select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用 epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在 epoll_wait中进入睡眠的进程<br>虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的 时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间，这就是回调机制带来的性能提升。</p>
<blockquote>
<p>开销</p>
</blockquote>
<p>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内 部定义的等待队列），这也能节省不少的开销</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Unix网络编程》</li>
<li><a href="https://segmentfault.com/a/1190000003063859#articleHeader9" target="_blank" rel="external">https://segmentfault.com/a/1190000003063859#articleHeader9</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1005481" target="_blank" rel="external">https://cloud.tencent.com/developer/article/1005481</a></li>
<li><a href="http://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="external">http://www.cnblogs.com/Anker/p/3265058.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期写一个在线聊天室的时候接触到epoll，加上之前腾讯面试的时候面试官有问到这一题。这里就对select、poll和epoll做一个总结，目的是让自己更加深入地理解，大部分内容来自网上，可能存在错误，欢迎大家指正。&lt;/p&gt;
    
    </summary>
    
      <category term="开发随笔" scheme="https://www.liuin.cn/categories/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Unix" scheme="https://www.liuin.cn/tags/Unix/"/>
    
  </entry>
  
  <entry>
    <title>《Effective C++》 笔记</title>
    <link href="https://www.liuin.cn/2018/04/19/%E3%80%8AEffective-C-%E3%80%8B-%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.liuin.cn/2018/04/19/《Effective-C-》-笔记/</id>
    <published>2018-04-19T08:18:10.000Z</published>
    <updated>2018-05-19T01:33:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>《Effective C++》的副标题是改善程序与设计的55个具体做法。这本书用比较多的示例展示了很多改善C++程序的方法，值得一读。</p>
<a id="more"></a>
<h2 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h2><h3 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款01：视C++为一个语言联邦</h3><p>C++高效编程守则视状况而变化,取决于你使用C++的哪一部分。</p>
<h3 id="条款02：尽量以const，enum，inline替换-define"><a href="#条款02：尽量以const，enum，inline替换-define" class="headerlink" title="条款02：尽量以const，enum，inline替换#define"></a>条款02：尽量以const，enum，inline替换#define</h3><p>“宁可以编译器替换预处理器”</p>
<p>使用<code>#define</code>时在编译之前所有的常量都被替换成了数字，如果在编译的时候产生错误，那么追溯错误产生的源头将是一件非常困难的事情。使用<code>const</code>就不一样，其变量一定会被编译器看到，当然就会引入<code>symbol table</code>中</p>
<p>当我们以常量替换<code>#defines</code>,有两种特殊情况值得说说。第一是定义常量指针( constant pointers)。由于常量定义式通常被放在头文件内(以便被不同的源码含入),因此有必要将指针(而不只是指针所指之物)声明为<code>const</code></p>
<p>第二个值得注意的是<code>class</code>专属常量。为了将常量的作用域(scope)限制于<code>class</code>内,你必须让它成为 class一个成员(member);而为确保此常量至多只有一份实体,你必须让它成为一个<code>static</code>成员:</p>
<blockquote>
<p>重点</p>
<ul>
<li>对于单纯常量,最好以 const对象或 enums替换#defines</li>
<li>对于形似函数的宏( macros),最好改用 inline函数替换#defines</li>
</ul>
</blockquote>
<h3 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h3><p>const的一件奇妙的事情是，它允许你指定一个语义约束，而编译器会强制执行这项约束。</p>
<p>const语法虽然变化多端,但并不莫测高深。如果关键字const出现在星号左边,表示被指物是常量(底层const)；如果出现在星号右边,表示指针自身是常量(顶层const);如果出现在星号两边,表示被指物和指针两者都是常量。</p>
<p>const最具威力的用法是面对函数声明时的应用。在一个函数声明式内, const可以和函数返回值、各参数、函数自身(如果是成员函数)产生关联。</p>
<blockquote>
<p>const 成员函数</p>
</blockquote>
<p>将 const实施于成员函数的目的,是为了确认该成员函数可作用于 const对象身上。这一类成员函数之所以重要,基于两个理由。第一,它们使 class接口比较容易被理解。这是因为,得知哪个函数可以改动对象内容而哪个函数不行,很是重要。第二,它们使“操作 const对象”成为可能。</p>
<blockquote>
<p>重点</p>
<ul>
<li>将某些东西声明为 const可帮助编译器侦测出错误用法。 const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体</li>
<li>当 const和non- const成员函数有着实质等价的实现时,令non- const版本调用 const版本可避免代码重复。</li>
</ul>
</blockquote>
<h3 id="条款04：确认对象使用前已被初始化"><a href="#条款04：确认对象使用前已被初始化" class="headerlink" title="条款04：确认对象使用前已被初始化"></a>条款04：确认对象使用前已被初始化</h3><p>在某些语境下x保证被初始化(为0),但在其他语境中却不保证。<strong>读取未初始化的值会导致不明确行为</strong></p>
<p>对于内置类型之外的东西，初始化的任务落在了构造函数的身上。我们要确保每一个构造函数都将对象的每一个成员初始化。但是我们很容易混淆复制和初始化的而例子，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; b);</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> thea;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> theb;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">A::A(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; b)</div><div class="line">&#123;</div><div class="line">    thea = a;   <span class="comment">// 这些都是赋值，而非初始化</span></div><div class="line">    theb = b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>C++规定,对象的成员变量的初始化动作发生在进入构造函数本体之前。所以构造函数最好使用成员初值列进行初始化。</p>
<blockquote>
<p>重点</p>
<ul>
<li>为内置型对象进行手工初始化,因为C++不保证初始化它们。</li>
<li>构造函数最好使用成员初值列( member initialization list),而不要在构造函数本体内使用赋值操作( assignment)。初值列列出的成员变量,其排列次序应该和它们在 class中的声明次序相同。</li>
</ul>
</blockquote>
<h2 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h2><h3 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款05：了解C++默默编写并调用哪些函数</h3><p>如果你自己没声明,编译器就会为它声明(编译器版本的)一个copy构造函数、一个 copy assignment操作符和一个析构函数。此外如果你没有声明任何构造函数,编译器也会为你声明一个 default构造函数。所有这些函数都是 public且in1ine。</p>
<p>default构造函数和析构函数主要是给编译器一个地方用来放置“藏身幕后”的代码,像是调用 base classes和non-static成员变量的构造函数和析构函数。</p>
<p>至于copy构造函数和 copy assignment操作符,编译器创建的版本只是单纯地将来源对象的每一个non- static成员变量拷贝到目标对象。</p>
<blockquote>
<p>重点</p>
<ul>
<li>编译器可以暗自为 class创建default构造函数、copy构造函数、 copy assignment操作符,以及析构函数。</li>
</ul>
</blockquote>
<h3 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>如果你不希望 class支持某一特定机能,只要不声明对应函数就是了。但这个策略对copy构造函数和copy assignment操作符却不起作用</p>
<p>所有编译器产出的函数都是 public.为阻止这些函数被创建出来,你得自行声明它们,但这里并没有什么需求使你必须将它们声明为 public。因此你可以将cory构造函数或 copy assignment操作符声明为 private。藉由明确声明一个成员函数,你阻止了编译器暗自创建其专属版本;而令这些函数为 private,使你得以成功组织别人调用他</p>
<blockquote>
<p>重点</p>
<ul>
<li>为驳回编译器自动(暗自)提供的机能,可将相应的成员函数声明为 private并且不予实现。</li>
</ul>
</blockquote>
<h3 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h3><p>C++明白指出,当 derived class对象经由一个base class指针被删除,而该 base class带着一个non- virtual析构函数,其结果未有定义实际执行时通常发生的是对象的 derived成分没被销毁。</p>
<p>消除这个问题的做法很简单:给 base class一个 virtua析构函数</p>
<blockquote>
<p>重点</p>
<ul>
<li>polymorphic(带多态性质的) base classes应该声明一个 virtual析构函数。如果class带有任何 virtual函数,它就应该拥有一个 virtual析构函数。</li>
</ul>
</blockquote>
<h3 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h3><p>C++并不禁止析构函数吐出异常,但它不鼓励你这样做。理由是当有多个（比如在vector中）对象需要销毁的时候，第一个对象和第二个对象析构是都抛出异常，这种情况下程序不是结束执行就是导致未定义行为。</p>
<blockquote>
<p>重点</p>
<ul>
<li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常,析构函数应该捕捉任何异常,然后吞下它们(不传播)或结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应,那么 class应该提供一个普通函数(而非在析构函数中)执行该操作。</li>
</ul>
</blockquote>
<h3 id="条款09：绝不要在构造函数和析构函数中调用virtual函数"><a href="#条款09：绝不要在构造函数和析构函数中调用virtual函数" class="headerlink" title="条款09：绝不要在构造函数和析构函数中调用virtual函数"></a>条款09：绝不要在构造函数和析构函数中调用virtual函数</h3><p>在base class构造期间，virtual函数不是virtual函数。</p>
<blockquote>
<p>重点</p>
<ul>
<li>在构造和析构期间不要调用 virtual函数,因为这类调用从不下降至 derived class(比起当前执行构造函数和析构函数的那层)</li>
</ul>
</blockquote>
<h3 id="条款10：令operator-返回一个-reference-to-this"><a href="#条款10：令operator-返回一个-reference-to-this" class="headerlink" title="条款10：令operator= 返回一个 reference to *this"></a>条款10：令operator= 返回一个 reference to *this</h3><p>复制可以写成连锁形式：</p>
<p><code>x = y = z = 15;</code></p>
<p>同时赋值采用右结合律,所以上述连锁赋值被解析为:</p>
<p><code>x = (y = (z = 15));</code></p>
<p>为了实现“连锁赋值”,赋值操作符必须返回一个 reference指向操作符的左侧实参。</p>
<blockquote>
<p>重点</p>
<ul>
<li>令赋值( assignment)操作符返回一个 reference to *this。</li>
</ul>
</blockquote>
<h3 id="条款11：在operator-中处理“自我赋值”"><a href="#条款11：在operator-中处理“自我赋值”" class="headerlink" title="条款11：在operator= 中处理“自我赋值”"></a>条款11：在operator= 中处理“自我赋值”</h3><p>“自我赋值“发生在对象赋值给自己时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Widget &#123; ... &#125; ;</div><div class="line">Widget w;</div><div class="line">...</div><div class="line">w = w;</div></pre></td></tr></table></figure>
<p>这看起来有点愚蠢,但它合法,所以不要认定客户绝不会那么做。</p>
<p>自我赋值可能出现的一个问题是, operator=函数内的*this(赋值的目的端)和rhs有可能是同一个对象。果真如此 delete就不只是销毁当前对象的 bitmap,它也销毁rhs的 bitmap。</p>
<p>欲阻止这种错误,传统做法是藉由 operator=最前面的一个“证同测试( identitytest)”达到“自我赋值”的检验目的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>重点</p>
<ul>
<li>确保当对象自我赋值时 operator=有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及 copy-and-swap。</li>
<li>确定任何函数如果操作一个以上的对象,而其中多个对象是同一个对象时,其行为仍然正确。</li>
</ul>
</blockquote>
<h3 id="条款12：复制对象时勿忘其每一个成分"><a href="#条款12：复制对象时勿忘其每一个成分" class="headerlink" title="条款12：复制对象时勿忘其每一个成分"></a>条款12：复制对象时勿忘其每一个成分</h3><blockquote>
<p>重点</p>
<ul>
<li>Copying函数应该确保复制“对象内的所有成员变量”及“所有 base class成分”。</li>
<li>不要尝试以某个 copying函数实现另一个 copying函数。应该将共同机能放进第三个函数中,并由两个 coping函数共同调用。</li>
</ul>
</blockquote>
<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h3 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h3><p>有的时候我们我们使用工厂函数获得某个特定的对象的指针的时候，在使用完毕时候需要将其占用的空间释放，尽管我们有这个意识，但是在实际开发中，如果中间出现异常或者return可能会造成内存泄漏的现象。</p>
<p>为了确保使用工厂函数返回的资源总是被释放,我们需要将资源放进对象内,当控制流离开f,<strong>该对象的析构函数会自动释放那些资源</strong>。实际上这正是隐身于本条款背后的半边想法:把资源放进对象内,我们便可倚赖C++的“析构函数自动调用机制”确保资源被释放。(稍后讨论另半边想法。)</p>
<blockquote>
<p>重点</p>
<ul>
<li>为防止资源泄漏,请使用RAII对象,它们在构造函数中获得资源并在析构函数中释放资源</li>
<li>两个常被使用的 RAII classes分别是trl::shared_ptr和 auto_ptr。前者通常是较佳选择,因为其copy行为比较直观。若选择 auto_ptr,复制动作会使它(被复制物)指向null</li>
</ul>
</blockquote>
<h3 id="条款14：在资源管理类中小心coping行为"><a href="#条款14：在资源管理类中小心coping行为" class="headerlink" title="条款14：在资源管理类中小心coping行为"></a>条款14：在资源管理类中小心coping行为</h3><p>我们使用C API管理一个互斥对象的时候，有lock和unlock两个函数可以用；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(Mutex* pm)</span></span>;     <span class="comment">// 锁定</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(Mutex* pm)</span></span>;   <span class="comment">// 解锁</span></div></pre></td></tr></table></figure>
<p>为了确保不会忘记解锁一个互斥量，我们可以使用上一个条款的建议，创建一个对象来管理这个互斥量，使得“资源在构造期间获得，在析构期间释放”</p>
<p>但是如果这个对象发生复制的时候怎么办？大多时候有以下两种可行的方案：</p>
<ul>
<li>禁止复制</li>
<li>对底层资源祭出“引用计数法”（reference-count）</li>
</ul>
<blockquote>
<p>重点</p>
<ul>
<li>复制RAII对象必须一并复制它所管理的资源,所以资源的copying行为决定RAII对象的copying行为。</li>
<li>普遍而常见的 Rail class copying行为是:抑制 copying、施行引用计数法( reference counting)。不过其他行为也都可能被实现</li>
</ul>
</blockquote>
<h3 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h3><p>资源管理类( resource-managing classes)很棒。它们是你对抗资源泄漏的堡垒。排除此等泄漏是良好设计系统的根本性质。在一个完美世界中你将倚赖这样的classes来处理和资源之间的所有互动,而不是玷污双手直接处理原始资源(rawresources)。但这个世界并不完美。许多APIs直接指涉资源,所以除非你发誓(这其实是一种少有实际价值的举动)永不录用这样的APls,否则只得绕过资源管理对象( resource-managing objects)直接访问原始资源( raw resources)。</p>
<p>由于有时候还是必须取得RAI对象内的原始资源,某些 RAII class设计者于是联想到“将油脂涂在滑轨上”,做法是提供一个显示转换函数或者隐式转换函数。</p>
<blockquote>
<p>重点</p>
<ul>
<li>APIs往往要求访问原始资源( raw resources),所以每一个 RAII class应该提供一个“取得其所管理之资源”的办法。</li>
<li>对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全,但隐式转换对客户比较方便。</li>
</ul>
</blockquote>
<h3 id="条款16：成对使用new和delete时要采取相同格式"><a href="#条款16：成对使用new和delete时要采取相同格式" class="headerlink" title="条款16：成对使用new和delete时要采取相同格式"></a>条款16：成对使用new和delete时要采取相同格式</h3><p>当你使用new(也就是通过new动态生成一个对象),有两件事发生。第内存被分配出来(通过名为 operator new的函数)。第二,针对此内存会有一个(或更多)构造函数被调用。</p>
<p>当你使用 delete,也有两件事发生:针对此内存会有一个(或更多)析构函数被调用,然后内存才被释放(通过名为 operator delete的函数)。</p>
<p>delete的最大问题在于:即将被删除的内存之内究竟存有多少对象?这个问题的答案决定了有多少个析构函数必须被调用起来。实际上这个问题可以更简单些:即将被删除的那个指针,所指的是单一对象或对象数组?这是个必不可缺的问题,因为单一对象的内存布局一般而言不同于数组的内存布局。</p>
<p>所以在成对使用new和delete的时候要采取相同的形式</p>
<blockquote>
<p>重点</p>
<ul>
<li>如果你在new表达式中使用[],必须在相应的de1ete表达式中也使用[]。如果你在new表达式中不使用[],一定不要在相应的 delete表达式中使用[]</li>
</ul>
</blockquote>
<h3 id="条款17：以独立语句将newed对象置入智能指针"><a href="#条款17：以独立语句将newed对象置入智能指针" class="headerlink" title="条款17：以独立语句将newed对象置入智能指针"></a>条款17：以独立语句将newed对象置入智能指针</h3><blockquote>
<p>重点</p>
<ul>
<li>以独立语句将 newed对象存储于(置入)智能指针内。如果不这样做,一旦异常被抛出,有可能导致难以察觉的资源泄漏。</li>
</ul>
</blockquote>
<h2 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h2><h3 id="条款18：让接口容易被正确使用，不容易被误用"><a href="#条款18：让接口容易被正确使用，不容易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不容易被误用"></a>条款18：让接口容易被正确使用，不容易被误用</h3><p>欲开发一个“容易被正确使用,不容易被误用”的接口,首先必须考虑客户可能做出什么样的错误。</p>
<p>预防客户错误的另一个办法是,限制类型内什么事可做,什么事不能做。常见的限制是加上 const。例如，以const修饰operator* 的返回类型可以阻止客户因“用户自定义类型”而犯错：</p>
<p><code>if( a * b = c ) ...</code>原意应该为做一次比较动作</p>
<p>下面是另一个一般性准则“让 types容易被正确使用,不容易被误用”的表现形式“除非有好理由,否则应该尽量令你的 types的行为与内置 types一致”。客户已经知道像int这样的type有些什么行为,所以你应该努力让你的 types在合样合理的前提下也有相同表现。</p>
<blockquote>
<p>重点</p>
<ul>
<li>好的接口很容易被正确使用,不容易被误用。你应该在你的所有接口中努力达成这些性质。</li>
<li>“促进正确使用”的办法包括接口的一致性,以及与内置类型的行为兼容。</li>
<li>“阻止误用”的办法包括建立新类型、限制类型上的操作,束缚对象值,以及消除客户的资源管理责任</li>
</ul>
</blockquote>
<h3 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款19：设计class犹如设计type</h3><p>设计优秀的 classes是一项艰巨的工作,因为设计好的 types是一项艰巨的工作。好的 types有自然的语法,直观的语义,以及一或多个高效实现品。在C++中,一个不良规划下的 class定义恐怕无法达到上述任何一个目标。甚至 class的成员函数的效率都有可能受到它们“如何被声明”的影响。</p>
<p>设计一个class需要思考如下的一些问题：</p>
<ul>
<li>新type的对象应该如何被创建和销毁?这会影响到你的 class的构造函数和析构函数以及内存分配函数和释放函数( operator new, operator new[], operator delete和 operator delete[])的设计,当然前提是如果你打算撰写它们。</li>
<li>对象的初始化和对象的赋值该有什么样的差别?这个答案决定你的构造函数和赋值操作符的行为,以及其间的差异。</li>
<li>新type的对象如果被 passed by value(以值传递),意味着什么?记住,copy构造函数用来定义一个type的 pass-by-value该如何实现。</li>
<li>什么是新“type”的合法值</li>
<li>你的新type需要配合某个继承图系( inheritance graph)吗?</li>
</ul>
<h3 id="条款20：宁以pass-by-reference-to-const-替换-pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const-替换-pass-by-value" class="headerlink" title="条款20：宁以pass-by-reference-to-const 替换 pass-by-value"></a>条款20：宁以pass-by-reference-to-const 替换 pass-by-value</h3><p>一般情况下，使用pass-by-reference-to-const能够调用更少的构造函数和析构函数，从而使得程序更加高效。</p>
<p>以by reference方式传递参数也可以避免 slicing(对象切割)问题。当一个 derived class对象以 by value方式传递并被视为一个 base class对象, base class的copy构造函数会被调用,而“造成此对象的行为像个 derived class对象”的那些特化性质全被切割掉了,仅仅留下一个 base class对象。</p>
<p>但是如果你有个对象属于内置类型(例如int), pass by value往往比 pass by reference的效率高些。对内置类型而言,当你有机会选择采用 pass-by-value或 pass-by-reference-to-const时,选择 pass-by-value并非没有道理。这个忠告也适用于STL的迭代器和函数对象,因为习惯上它们都被设计为passed by value。迭代器和函数对象的实践者有责任看看它们是否高效且不受切割问题</p>
<blockquote>
<p>重点</p>
<ul>
<li>尽量以 pass-by-reference-to-const替换 pass-by-value。前者通常比较高效,并可避免切割问题( slicing problem)</li>
<li>以上规则并不适用于内置类型,以及STL的迭代器和函数对象。对它们而言,pas- by-value往往比较适当。</li>
</ul>
</blockquote>
<h3 id="条款21：必须返回对象的时，别妄想返回其reference"><a href="#条款21：必须返回对象的时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象的时，别妄想返回其reference"></a>条款21：必须返回对象的时，别妄想返回其reference</h3><p>所谓 reference只是个名称,代表某个既有对象。任何时候看到一个 reference声明式,你都应该立刻问自己,它的另一个名称是什么?因为它一定是某物的另一个名称。</p>
<p>有的时候我们在返回引用的时候，其引用的对象如果一个局部变量，而这个局部变量在退出前就销毁了，所以不能够使用引用；如果所引用的对象是通过动态创建内存的方式创建的，这种情况下由谁来实施delete是一个问题。</p>
<blockquote>
<p>重点</p>
<ul>
<li>绝不要返回 pointer或 reference指向一个 local stack对象,或返回 reference指向个 heap-allocated对象,或返回 pointer或 reference指向一个 local static对象而有可能同时需要多个这样的对象。</li>
</ul>
</blockquote>
<h3 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h3><p>如果成员变量不是 public,客户唯一能够访问对象的办法就是通过成员函数。如果 public接口内的每样东西都是函数,客户就不需要在打算访问 class成员时迷惑地试着记住是否该使用小括号(圆括号)。他们只要做就是了,因为每样东西都是函数。就生命而言,这至少可以省下许多搔首弄耳的时间</p>
<p>使用函数可以让你对成员变量的处理有更精确的控制。如果你令成员变量为 public,每个人都可以读写它,但如果你以函数取得或设定其值,你就可以实现出“不准访问”、“只读访问”以及“读写访问”。</p>
<p>还是不够说服你?是端出大口径武器的时候了:封装啦。如果你通过函数访问成员变量,日后可改以某个计算替换这个成员变量,而 class客户一点也不会知道 class的内部实现已经起了变化。</p>
<blockquote>
<p>重点</p>
<ul>
<li>切记将成员变量声明为 private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证,并提供 class作者以充分的实现弹性。</li>
<li>protected并不比 public更具封装性。</li>
</ul>
</blockquote>
<h3 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款23：宁以non-member、non-friend替换member函数</h3><p>面向对象守则要求,数据以及操作数据的那些函数应该被捆绑在一块,这意味它建议 member函数是较好的选择。不幸的是这个建议不正确。这是基于对面向对象真实意义的一个误解。面向对象守则要求数据应该尽可能被封装,然而与直观相反地,member函数带来的封装性比non-member函数低。</p>
<p>让我们从封装开始讨论。如果某些东西被封装,它就不再可见。<strong>愈多东西被封装愈少人可以看到它。而愈少人看到它,我们就有愈大的弹性去变化它</strong>,因为我们的改变仅仅直接影响看到改变的那些人事物。因此,愈多东西被封装,我们改变那些东西的能力也就愈大。这就是我们首先推崇封装的原因:<strong>它使我们能够改变事物而只影响有限客户</strong>。</p>
<p>现在考虑对象内的数据。愈少代码可以看到数据(也就是访问它),愈多的数据可被封装,而我们也就愈能自由地改变对象数据,例如改变成员变量的数量、类型等等。</p>
<blockquote>
<p>重点</p>
<ul>
<li>宁可拿non-member non-friend函数替换 member函数。这样做可以增加封装性、包裹弹性(packaging flexibility)和机能扩充性。 </li>
</ul>
</blockquote>
<h3 id="条款24：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆需类型转换，请为此采用non-member函数"></a>条款24：若所有参数皆需类型转换，请为此采用non-member函数</h3><p>只有当参数被列于参数列(parameter list)内,这个参数才是隐式类型转换的合格参与者。地位相当于“被调用之成员函数所隶属的那个对象”一一即this对象—的那个隐喻参数,绝不是隐式转换的合格参与者。</p>
<blockquote>
<p>重点</p>
<ul>
<li>如果你需要为某个函数的所有参数(包括被this指针所指的那个隐喻参数)进行类型转换,那么这个函数必须是个non-member</li>
</ul>
</blockquote>
<h3 id="条款25：考虑写出一个不抛异常的swap函数"><a href="#条款25：考虑写出一个不抛异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛异常的swap函数"></a>条款25：考虑写出一个不抛异常的swap函数</h3><p>如果swap的缺省实现码对你的 class或 class template提供可接受的效率,你不需要额外做任何事。任何尝试置换(swap)那种对象的人都会取得缺省版本,而那将有良好的运作。</p>
<p>其次,如果swap缺省实现版的效率不足(那几乎总是意味你的 class或 template使用了某种pmpl手法),试着做以下事情</p>
<ul>
<li>提供一个 public swap成员函数,让它高效地置换你的类型的两个对象值。这个函数绝不该抛出异常。</li>
<li>在你的cass或 template所在的命名空间内提供一个non-member swap,并令它调用上述swap成员函数。</li>
<li>如果你正编写一个cass而非 class template),为你的clas特化stc并令它调用你的swap成员函数。</li>
</ul>
<p>唯一还未明确的是我的劝告:成员版swap绝不可抛出异常。那是因为swap的个最好的应用是帮助 classes(和 class templates)提供强烈的异常安全性(exception-safety)保障。</p>
<p>高效率的swap几乎总是基于对内置类型的操作(例如pmpl手法的底层指针),而内置类型上的操作绝不会抛出异常。</p>
<blockquote>
<p>重点</p>
<ul>
<li>当std::swap对你的类型效率不高时,提供一个swap成员函数,并确定这个函数不抛出异常。</li>
<li>如果你提供一个member swap,也该提供一个non-member swap用来调用前者。对于 classes(而非 templates),也请特化std::swap。</li>
<li>调用swap时应针对std::swap使用 using声明式,然后调用swap并且不带任何“命名空间资格修饰”</li>
<li>为“用户定义类型”进行std templates全特化是好的,但千万不要尝试在std内加入某些对std而言全新的东西</li>
</ul>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="条款26：尽可能延后变量定义式出现的时间"><a href="#条款26：尽可能延后变量定义式出现的时间" class="headerlink" title="条款26：尽可能延后变量定义式出现的时间"></a>条款26：尽可能延后变量定义式出现的时间</h3><p>只要你定义了一个变量而其类型带有一个构造函数或析构函数,那么当程序的控制流( control flow)到达这个变量定义式时,你便得承受构造成本;当这个变量离开其作用域时,你便得承受析构成本。即使这个变量最终并未被使用,仍需耗费这些成本,所以你应该尽可能避免这种情形。</p>
<blockquote>
<p>重点</p>
<ul>
<li>尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。</li>
</ul>
</blockquote>
<h3 id="条款27：尽量减少转型动作"><a href="#条款27：尽量减少转型动作" class="headerlink" title="条款27：尽量减少转型动作"></a>条款27：尽量减少转型动作</h3><p>C++提供四种新式转型：<br><code>const_cast&lt;T&gt;( expression )</code><br><code>dynamic_cast&lt;T&gt;( expression )</code><br><code>reinterpret_cast&lt;T&gt;( expression )</code><br><code>static_cast&lt;T&gt;(expression )</code></p>
<ul>
<li>const_cast通常被用来将对象的常量性转除</li>
<li>dynamic_cast主要用来执行“安全向下转型”(safe downcasting),也就是用来决定某对象是否归属继承体系中的某个类型。</li>
<li>reinterpret_cast意图执行低级转型,实际动作(及结果)可能取决于编译器这也就表示它不可移植。</li>
<li>static_cast用来强迫隐式转换</li>
</ul>
<p>许多程序员相信,转型其实什么都没做,只是告诉编译器把某种类型视为另一种类型。这是错误的观念。任何一个类型转换(不论是通过转型操作而进行的显式完成的隐式转换〕往往真的令编译器编译出运行期间执行的码。</p>
<blockquote>
<p>重点</p>
<ul>
<li>如果可以,尽量避免转型,特别是在注重效率的代码中避免 dynamic casts如果有个设计需要转型动作,试着发展无需转型的替代设计。</li>
<li>如果转型是必要的,试着将它<strong>隐藏于某个函数背后</strong>。客户随后可以调用该函数,而不需将转型放进他们自已的代码内。</li>
<li>宁可使用C++-style(新式)转型,不要使用旧式转型。前者很容易辨识出来,而且也比较有着分门别类的职掌。</li>
</ul>
</blockquote>
<h3 id="条款28：避免返回handles指向对象内部部分"><a href="#条款28：避免返回handles指向对象内部部分" class="headerlink" title="条款28：避免返回handles指向对象内部部分"></a>条款28：避免返回handles指向对象内部部分</h3><p>第一,成员变量的封装性最多只等于“返回其reference”的函数的访问级别。第二,如果 const成员函数传出一个 reference,后者所指数据与对象自身有关联,而它又被存储于对象之外,那么这个函数的调用者可以修改那笔数据。</p>
<blockquote>
<p>重点</p>
<ul>
<li>避免返回 handles(包括 references、指针、迭代弋器)指向对象内部。遵守这个条可增加封装性,帮助 const成员函数的行为像个 const,并将发生“虚吊号码牌”( dangling handles)的可能性降至最低。</li>
</ul>
</blockquote>
<h3 id="条款29：为“异常安全”而努力是值得的"><a href="#条款29：为“异常安全”而努力是值得的" class="headerlink" title="条款29：为“异常安全”而努力是值得的"></a>条款29：为“异常安全”而努力是值得的</h3><p>当异常抛出时，带有异常安全性的函数会：</p>
<ol>
<li>不泄露任何资源</li>
<li>不允许数据破坏</li>
</ol>
<p>异常安全函数提供下面三个保证之一：</p>
<ul>
<li>基本承诺:如果异常被抛出,程序内的任何事物仍然保持在有效状态下。没有任何对象或数据结构会因此而败坏,所有对象都处于一种内部前后一致的状态</li>
<li>强烈保证:如果异常被抛出,程序状态不改变。调用这样的函数需有这样的认知:如果函数成功,就是完全成功,如果函数失败,程序会回复到“调用函数之前”的状态。</li>
<li>不抛掷( nothrow)保证,承诺绝不抛出异常,因为它们总是能够完成它们原先承诺的功能。作用于内置类型(例如ints,指针等等)身上的所有操作都提供nothrow保证。这是异常安全码中一个必不可少的关键基础材料。</li>
</ul>
<blockquote>
<p>重点</p>
<ul>
<li>异常安全函数( exception-safe functions)即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证:基本型、强烈型、不抛异常型。</li>
<li>强烈保证”往往能够以 copy-and-swap实现出来,但“强烈保证”并非对所有函数都可实现或具备现实意义</li>
<li>函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。</li>
</ul>
</blockquote>
<h3 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款30：透彻了解inlining的里里外外</h3><p>编译器最优化机制通常被设计用来浓缩那些“不含函数调用”的代码,所以当你 inline某个函数,或许编译器就因此有能力对它(函数本体)执行语境相关最优化。然而编写程序就像现实生活一样,没有白吃的午餐。 inline函数也不例外。 inline函数背后的整体观念是,将“对此函数的每一个调用”都以函数本体替换之。首先这样会增加你的目标代码的大小</p>
<p>Inline函数通常一定被置于头文件内,因为大多数建置环境( build environments)在编译过程中进行 inlining,而为了将一个“函数调用”替换为“被调用函数的本体”,编译器必须知道那个函数长什么样子。</p>
<p>程序库设计者必须评估“将函数声明为 inline”的冲击: inline函数无法随着程序库的升级而升级。换句话说如果f是程序库内的一个 inline函数,客户将“f函数本体”编进其程序中,<strong>一旦程序库设计者决定改变f,所有用到f的客户端程序都必须重新编译</strong>。这往往是大家不愿意见到的。</p>
<blockquote>
<p>重点</p>
<ul>
<li>将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级( binary upgradability)更容易,也可使潜在的代码膨胀问题最小化,使程序的速度提升机会最大化。</li>
<li>不要只因为function templates出现在头文件,就将它们声明为inline</li>
</ul>
</blockquote>
<h3 id="条款31：将文件间的编译依存关系将至最低"><a href="#条款31：将文件间的编译依存关系将至最低" class="headerlink" title="条款31：将文件间的编译依存关系将至最低"></a>条款31：将文件间的编译依存关系将至最低</h3><p>问题出在C++并没有把“将接口从实现中分离”这事做得很好。 Class的定义式不只详细叙述了clas接口,还包括十足的实现细目。如果一个类定义中有编译依赖的其他文件中的类，那么修改所依赖的类的定义会导致现在的文件需要重新编译。这样的连串编译依存关系( cascading compilation dependencies)会对许多项目造成难以形容的灾难</p>
<p>上述的东西的一种解决方案是“前置声明每一件东西”，但是这个存在两个问题：第一，对于模板的前置声明比较复杂；第二、编译器必须在编译期间知道对象的大小，知道其大小就必须知道class中是如何实现的</p>
<blockquote>
<p>重点</p>
<ul>
<li>支持“编译依存性最小化”的一般构想是:相依于声明式,不要相依于定义式。基于此构想的两个手段是 Handle classes和 Interface classes</li>
<li>程序库头文件应该以“完全且仅有声明式”( full and declaration- only forms)的形式存在。这种做法不论是否涉及 templates都适用。</li>
</ul>
</blockquote>
<h2 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h2><h3 id="条款32：确定你的public继承塑模出is-a关系"><a href="#条款32：确定你的public继承塑模出is-a关系" class="headerlink" title="条款32：确定你的public继承塑模出is-a关系"></a>条款32：确定你的public继承塑模出is-a关系</h3><p>以C++进行面向对象编程,最重要的一个规则是: public inheritance(公开继承)意味”is-a”(是一种)的关系。把这个规则牢牢地烙印在你的心中吧!</p>
<p>ls-a并非是唯一存在于 classes之间的关系。另两个常见的关系是has-a(有个)和is-implemented-in- terms-of(根据某物实现出)。</p>
<blockquote>
<p>重点</p>
<ul>
<li>“public继承”意味ls-a。适用于base classes身上的每一件事情一定也适用于derived classes身上,因为每一个derived class对象也都是一个 base class对象。</li>
</ul>
</blockquote>
<h3 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h3><p>当编译器处于someFunc的作用域内并遭遇名称x时,它在 local作用域内查找是否有什么东西带着这个名称。如果找到就不再找其他作用域。C++的名称遮掩规则( name-hiding rules)所做的唯一事情就是:遮掩名称。至于名称是否应和相同或不同的类型,并不重要。</p>
<p>现在导入继承。我们知道,当位于一个derived class成员函数内指涉( refer to)base class内的某物(也许是个成员函数、 typedef、或成员变量)时,编译器可以找出我们所指涉的东西,因为 derived classes继承了声明于 base classes内的所有东西。实际运作方式是, derived class作用域被嵌套在 base class作用域内</p>
<p>有时候你并不想继承 base classes的所有函数,这是可以理解的。在 public继承下,这绝对不可能发生,因为它违反了 public继承所暗示的“base和 derived classes之间的is-a关系”。</p>
<blockquote>
<p>重点</p>
<ul>
<li>derived classes内的名称会遮掩 base classes内的名称。在public继承下从来没有人希望如此。</li>
<li>为了让被遮掩的名称再见天日,可使用using声明式或转交函数( forwardingfunctions)。</li>
</ul>
</blockquote>
<h3 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h3><p>表面上直截了当的 public继承概念,经过更严密的检查之后,发现它由两部分组成:函数接日( function interfaces)继承和函数实现( function implementations.)继承。这两种继承的差异,很像本书导读所讨论的函数声明与函数定义之间的差异。</p>
<p>pure virtual函数有两个最突出的特性:它们必须被任何“继承了它们”的具体对象class重新声明,而且它们在抽象 class中通常没有定义。把这两个性质摆在一起,你就会明白:<strong>声明一个 pure virtual函数的目的是为了让 derived classes只继承函数接口</strong>。</p>
<p>简朴的 impure virtual函数背后的故事和 pure virtual函数有点不同。一如往常,derived classes继承其函数接口,但 impure virtual函数会提供一份实现代码, derived classes可能覆写( override)它。稍加思索,你就会明白:<strong>声明简朴的(非纯) impure virtual函数的目的,是让 derived classes继承该函数的接口和缺省实现</strong></p>
<p>如果成员函数是个non-virtual函数,意味是它并不打算在 derived classes中有不同的行为。实际上一个 non-virtual成员函数所表现的不变性( invariant)凌驾其特异性( specialization),因为它表示不论 derived class变得多么特异化,它的行为都不可以改变。就其自身而言:<strong>声明non-virtual函数的目的是为了令 derived classes继承函数的接口及一份强制性实现</strong>。</p>
<p>pure virtual函数、 simple (impure)vmal函数、 non-virtual函数之间的差异,使你得以精确指定你想要 derived classes继承的东西:只继承接口,或是继承接口和一份缺省实现,或是继承接口和一份强制实现。由于这些不同类型的声明意味根本意义并不相同的事情,当你声明你的成员函数时,必须谨慎选择。</p>
<p>如果你确实履行,应该能够避免经验不足的 class设计者最常犯的两个错误：</p>
<ul>
<li>第一个错误是将所有函数声明为non-virtual这使得 derived classes没有余裕空间进行特化工作</li>
<li>另一个常见错误是将所有成员函数声明为 virtual</li>
</ul>
<blockquote>
<p>重点</p>
<ul>
<li>接口继承和实现继承不同在 public继承之下, derived classes总是继承 base class的接口。</li>
<li>pure virtual函数只具体指定接口继承。</li>
<li>简朴的(非纯) impure virtual函数具体指定接口继承及缺省实现继承。</li>
<li>non-virtual函数具体指定接口继承以及强制性实现继承。</li>
</ul>
</blockquote>
<h3 id="条款35：考虑virtual函数以外的其他选择"><a href="#条款35：考虑virtual函数以外的其他选择" class="headerlink" title="条款35：考虑virtual函数以外的其他选择"></a>条款35：考虑virtual函数以外的其他选择</h3><p>当你为解决问题而寻找某个设计方法时,不妨考虑virtual函数的替代方案。</p>
<ol>
<li>使用non-virtual interface(NVI)手法,那是Template Method设计模式的一种特殊形式。它以 public non-virtual成员函数包裹较低访问性( private或 protected)的 virtua函数。</li>
<li>将 virtual函数替换为“函数指针成员变量”,这是 Strategy设计模式的一种分解表现形式。</li>
<li>以tr1:: function成员变量替换 virtual函数,因而允许使用任何可调用物( callable entit!y)搭配一个兼容于需求的签名式。这也是 Strategy设计模式的某种形式。</li>
<li>将继承体系内的 virtual函数替换为另一个继承体系内的 virtual函数。这是Strategy设计模式的传统实现手法。</li>
</ol>
<p>以上并未彻底而详尽地列出 virtual函数的所有替换方案,但应该足够让你知道的确有不少替换方案。此外,它们各有其相对的优点和缺点,你应该把它们全部列入考虑</p>
<h3 id="条款36：绝不重新定义继承而来的non-virtual函数"><a href="#条款36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36：绝不重新定义继承而来的non-virtual函数"></a>条款36：绝不重新定义继承而来的non-virtual函数</h3><p>对于D继承B以及non-virtual成员函数B::mf身上：</p>
<ul>
<li>适用于B对象的每一件事,也适用于D对象,因为每个D对象都是一个B对象;</li>
<li>B的 derived classes一定会继承mf的接口和实现,因为mf是B的一个non-virtual函数。</li>
</ul>
<p>现在,如果b重新定义mf,你的设计便出现矛盾。如果D真有必要实现出与B不同的mf,并且如果每一个B对象——不管多么特化—一真的必须使用B所提供的mf实现码,那么“每个D都是一个B”就不为真。既然如此D就不该以 public形式继承B。另一方面,如果D真的必须以 public方式继承B,并且如果D真有需要实现出与B不同的mf,那么mf就无法为B反映出“不变性凌驾特异性”的性质。既然这样mf应该声明为 virtual函数。最后,如果每个D真的是一个B,并且如果mf真的为B反映出“不变性凌驾特异性”的性质,那么D便不需要重新定义mf,而且它也不应该尝试这样做。</p>
<blockquote>
<p>重点</p>
<ul>
<li>绝对不要重新定义继承而来的 non-virtua函数</li>
</ul>
</blockquote>
<h3 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款37：绝不重新定义继承而来的缺省参数值</h3><p>让我们一开始就将讨论简化。你只能继承两种函数: virtual和 non-virtual函数。然而重新定义一个继承而来的non-virtual函数永远是错误的(见条款36),所以我们可以安全地将本条款的讨论局限于“继承一个带有缺省参数值的 virtual函数”。</p>
<p>这种情况下,本条款成立的理由就非常直接而明确了: <strong>virtual函数系动态绑定( dynamically bound),而缺省参数值却是静态绑定( statically bound)</strong>。</p>
<p>为什么C++坚持以这种乖张的方式来运作呢?答案在于运行期效率。如果缺省参数值是动态绑定,编译器就必须有某种办法在运行期为 virtua函数决定适当的参数缺省值。这比目前实行的“在编译期决定”的机制更慢而且更复杂。为了程序的执行速度和编译器实现上的简易度,C++做了这样的取舍,其结果就是你如今所享受的执行效率。但如果你没有注意本条款所揭示的忠告,很容易发生混淆。</p>
<blockquote>
<p>重点</p>
<ul>
<li>绝对不要重新定义一个继承而来的缺省参数值,因为缺省参数值都是静态绑定,而 virtual函数—你唯一应该覆写的东西—却是动态绑定。</li>
</ul>
</blockquote>
<h3 id="条款38：通过复合塑模出has-a或”根据某物实现出”"><a href="#条款38：通过复合塑模出has-a或”根据某物实现出”" class="headerlink" title="条款38：通过复合塑模出has-a或”根据某物实现出”"></a>条款38：通过复合塑模出has-a或”根据某物实现出”</h3><p>复合( composition)是类型之间的一种关系,当某种类型的对象内含它种类型的对象,便是这种关系。</p>
<p>条款32曾说,“public继承”带有is-a(是一种)的意义。复合也有它自己的意义实际上它有两个意义。复合意味has-a(有一个)或 is-implemented-in-terms-of(根据某物实现出)。</p>
<blockquote>
<p>重点</p>
<ul>
<li>复合( composition)的意义和 public继承完全不同</li>
<li>在应用域( application domain),复合意味has-a(有一个)。在实现域( implementation domain),复合意味 is-implemented- in-terms-of(根据某物实现出)</li>
</ul>
</blockquote>
<h3 id="条款39：明智而审慎得使用private继承"><a href="#条款39：明智而审慎得使用private继承" class="headerlink" title="条款39：明智而审慎得使用private继承"></a>条款39：明智而审慎得使用private继承</h3><p>统御 private继承的首要规则你刚才已经见过了:如果classes之间的继承关系是 private,编译器不会自动将一个 derived class对象(例如Student)转换为一个 base class对象(例如 Person)。这和 public继承的情况不同。第二条规则是,由 private base class继承而来的所有成员,在 derived class中都会变成 private属性,纵使它们在base class中原本是 protected或 public属性。</p>
<p>Private继承意味 implemented-in-terms-of(根据某物实现出)。如果你让 class D以 private形式继承 class B,你的用意是为了采用 class B内已经备妥的某些特性,不是因为B对象和D对象存在有任何观念上的关系。 private继承纯粹只是一种实现技术(这就是为什么继承自一个 private baseclass的每样东西在你的clas内都是 private:因为它们都只是实现枝节而已)。借用条款34提出的术语, <strong>private继承意味只有实现部分被继承,接口部分应略去</strong>。</p>
<blockquote>
<p>重点</p>
<ul>
<li>Private继承意味 is-implemented-in-terms-of(根据某物实现出)。它通常比复合( composition)的级别低。但是当 derived clas需要访问 protected base class的成员,或需要重新定义继承而来的 virtua函数时,这么设计是合理的。</li>
<li>和复合( composition)不同, private继承可以造成 empty base最优化。这对致力于“对象尺寸最小化”的程序库开发者而言,可能很重要。</li>
</ul>
</blockquote>
<h3 id="条款40：明智而审慎得使用多重继承"><a href="#条款40：明智而审慎得使用多重继承" class="headerlink" title="条款40：明智而审慎得使用多重继承"></a>条款40：明智而审慎得使用多重继承</h3><p>当派生类继承的多个基类中都有某个同名成员函数的时候，可能会产生歧义。这个时候C++处理的方法与C++用来解析( resolving)重载函数调用的规则相符:在看到是否有个函数可取用之前,C++首先确认这个函数对此调用之言是最佳匹配。找出最佳匹配函数后才检验其可取用性。</p>
<p>从正确行为的观点看, public继承应该总是 virtuale。如果这是唯一一个观点,规则很简单:任何时候当你使用 public继承,请改用 virtual public继承。但是,啊呀,正确性并不是唯一观点。为避免继承得来的成员变量重复,编译器必须提供若干幕后戏法,而其后果是:使用 virtual继承的那些 classes所产生的对象往往比使用non- virtual继承的兄弟们体积大,访问 virtual base classes的成员变量时,也比访问non- virtual base classes的成员变量速度慢。种种细节因编译器不同而异,但基本重点很清楚:你得为 virtual继承付出代价。</p>
<blockquote>
<p>重点</p>
<ul>
<li>多重继承比单一继承复杂。它可能导致新的歧义性,以及对 virtual继承的需要。</li>
<li>virtual继承会增加大小、速度、初始化(及赋值)复杂度等等成本。如果 virtual base classes不带任何数据,将是最具实用价值的情况。</li>
<li>多重继承的确有正当用途。其中一个情节涉及“ public继承某个 Interface class”和“ private继承某个协助实现的 class”的两相组合。</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Effective C++》的副标题是改善程序与设计的55个具体做法。这本书用比较多的示例展示了很多改善C++程序的方法，值得一读。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C/C++" scheme="https://www.liuin.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>APUE 信号</title>
    <link href="https://www.liuin.cn/2018/04/18/APUE-%E4%BF%A1%E5%8F%B7/"/>
    <id>https://www.liuin.cn/2018/04/18/APUE-信号/</id>
    <published>2018-04-18T13:37:51.000Z</published>
    <updated>2018-04-19T01:28:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第10章 信号 笔记</p>
<a id="more"></a>
<p>信号是软件中断。很多比较重要的应用程序都需处理信号。信号提供了一种<strong>处理异步事件</strong>的方法,例如,终端用户键入中断键,会通过信号机制停止一个程序,或及早终止管道中的下一个程序。</p>
<h2 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h2><p>每个信号都有一个名字，这些名字都以3个字符SIG开头，比如：SIGINT中断信号、SIGABRT夭折信号、SIGALRM闹钟信号。</p>
<p>产生信号的条件：</p>
<ul>
<li>当用户按某些终端键时,引发终端产生的信号。</li>
<li>硬件异常产生信号:除数为0、无效的内存引用等。</li>
<li>进程调用ki11(2)函数可将任意信号发送给另一个进程或进程组。</li>
<li>用户可用ki11(1)命令将信号发送给其他进程</li>
<li>当检测到某种软件条件已经发生,并应将其通知有关进程时也产生信号</li>
</ul>
<p>信号是异步事件的经典实例。产生信号的事件对进程而言是随机出现的。进程不能简单地测试一个变量(如 errno)来判断是否发生了一个信号,而是必须告诉内核“在此信号发生时,请执行下列操作”。</p>
<p>在某个信号出现时,可以告诉内核按下列3种方式之一进行处理,我们称之为信号的处理或与信号相关的动作：</p>
<ul>
<li>忽略此信号，有两种信号不能被忽略，它们是 SIGKILL和 SIGSTOP。这两种信号不能被忽略的原因是:它们向内核和超级用户提供了使进程终止或停止的可靠方法。</li>
<li>捕捉信号，通知内核在某种信号发生时,调用一个用户函数。在用户函数中,可执行用户希望对这种事件进行的处理。</li>
<li>执行系统默认操作</li>
</ul>
<p><img src="https://data2.liuin.cn/2018-04-18-15240592901538.jpg" alt=""></p>
<h2 id="函数signal"><a href="#函数signal" class="headerlink" title="函数signal"></a>函数signal</h2><p>UNX系统信号机制最简单的接口是 signa1函数，其用于捕获信号，并捕获以后发生什么事情。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> signo, <span class="keyword">void</span> (*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>); </div><div class="line"></div><div class="line"><span class="comment">//Returns: previous disposition of signal (see following) if OK, SIG_ERR on error</span></div></pre></td></tr></table></figure>
<p><code>signo</code>参数是信号名。<code>func</code>的值是常量SIG_IGN、常量SIG_DEL或当接到此信号后要调用的函数的地址。<code>SIG_IGN</code>表示向内核表示忽略此信号(记住有两个信号 SIGKILI和 SIGSTOP不能忽略)。SIG_DEL表示接到此信号后的动作是系统默认动作。</p>
<p>当指定函数地址时，则在信号发生时，调用该函数，我们称这种处理为捕获该信号，称此函数为信号处理程序( signal handler)或信号捕捉函数 (signal-catching function)</p>
<blockquote>
<p>程序启动</p>
</blockquote>
<p>当执行一个程序时,所有信号的状态都是系统默认或忽略。通常所有信号都被设置为它们的默认动作,除非调用exec的进程忽略该信号。确切地讲,<strong>exec函数将原先设置为要捕捉的信号都更改为默认动作</strong>,其他信号的状态则不变(一个进程原先要捕捉的信号,当其执行一个新程序后,就不能再捕捉了,因为信号捕捉函数的地址很可能在所执行的新程序文件中已无意义)。</p>
<blockquote>
<p>进程创建</p>
</blockquote>
<p>当一个进程调用fork时,其子进程继承父进程的信号处理方式。因为子进程在开始时复制了父进程内存映像,所以信号捕捉函数的地址在子进程中是有意义的</p>
<h2 id="不可靠信号"><a href="#不可靠信号" class="headerlink" title="不可靠信号"></a>不可靠信号</h2><p>在早期的UNX版本中(如V7),信号是不可靠的。不可靠在这里指的是,信号可能会丢失。一个信号发生了,但进程却可能一直不知道这一点。同时,进程对信号的控制能力也很差,它能捕捉信号或忽略它。有时用户希望通知内核阻塞某个信号:不要忽略该信号,在其发生时记住它然后在进程做好了准备时再通知它。这种阻塞信号的能力当时并不具备</p>
<p>这些早期版本的另一个问题是:在进程不希望某种信号发生时,它不能关闭该信号。进程能做的一切就是忽略该信号。</p>
<h2 id="中断的系统调用"><a href="#中断的系统调用" class="headerlink" title="中断的系统调用"></a>中断的系统调用</h2><p>早期UNX系统的一个特性是:如果进程在执行一个低速系统调用而阻塞期间捕捉到一个信号,则该系统调用就被中断不再继续执行。该系统调用返回出错,其erno设置为EINTR。</p>
<p>为了支持这种特性,将系统调用分成两类:低速系统调用和其他系统调用。低速系统调用是可能会使进程永远阻塞的类系统调用。</p>
<p>可以用中断系统调用这种方法来处理的一个例子是:一个进程启动了读终端操作,而使用该终端设备的用户却离开该终端很长时间。在这种情况下,进程可能处于阻塞状态几个小时甚至数天,除非系统停机,否则一直如此</p>
<h2 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h2><p>进程捕捉到信号并对其进行处理时,进程正在执行的正常指令序列就被信号处理程序临时中断,它首先执行该信号处理程序中的指令。如果从信号处理程序返回,则继续执行在捕捉到信号时进程正在执行的正常指令序列(这类似于发生硬件中断时所做的)。但在信号处理程序中,<strong>不能判断捕捉到信号时进程执行到何处</strong>。</p>
<p>在信号处理函数中保证调用安全的函数（可以被安全中断的函数），这些函数是<strong>可重入的</strong>并被称之为<strong>异步信号安全的</strong></p>
<p>大多数函数是不可重入的,因为<br>(a)已知它们使用静态数据结构;<br>(b)它们调用mal1oc或free;<br>(c)它们是标准I/O函数。标准IO库的很多实现都以不可重入方式使用全局数据结构</p>
<h2 id="可靠信号术语与语义"><a href="#可靠信号术语与语义" class="headerlink" title="可靠信号术语与语义"></a>可靠信号术语与语义</h2><p>我们需要先定义一些在讨论信号时会用到的术语。首先,当造成信号的事件发生时,为进程产生一个信号(或向一个进程发送一个信号)。事件可以是硬件异常(如除以0)、软件条件(如a1arm定时器超时)、终端产生的信号或调用ki11函数。当一个信号产生时,<strong>内核通常在进程表中以某种形式设置一个标志</strong>。</p>
<p>当对信号采取了这种动作时,我们说向进程递送了一个信号。在信号产生(generation)和递送(delivery)之间的时间间隔内,称信号是<strong>未决的</strong>(pending)</p>
<p>进程可以选用“阻塞信号递送”。如果为进程产生了一个阻塞的信号,而且对该信号的动作是系统默认动作或捕捉该信号,则为该进程将此信号保持为未决状态,直到该进程对此信号解除了阻塞,或者将对此信号的动作更改为忽略。内核在递送一个原来被阻塞的信号给进程时(而不是在产生该信号时),才决定对它的处理方式。于是进程在信号递送给它之前仍可改变对该信号的动作。进程调用<code>sigpending</code>函数来判定哪些信号是设置为阻塞并处于未决状态的。</p>
<p>每个进程都有一个信号屏蔽字( signal mask.),它规定了当前要阻塞递送到该进程的信号集。对于每种可能的信号,该屏蔽字中都有一位与之对应。对于某种信号,若其对应位已设置,则它当前是被阻塞的。进程可以调用 <code>sigprocmask</code>来检测和更改其当前信号屏蔽字。</p>
<h2 id="函数kill和raise"><a href="#函数kill和raise" class="headerlink" title="函数kill和raise"></a>函数kill和raise</h2><p>ki11函数将信号发送给进程或进程组。 ralse函数则允许进程向自身发送信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signo)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> signo)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Both return: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>进程将信号发送给其他进程需要权限。超级用户可将信号发送给任一进程。对于非超级用户,其基本规则是发送者的实际用户DD或有效用户ID必须等于接收者的实际用户ID或有效用户ID。</p>
<h2 id="函数alarm和pause"><a href="#函数alarm和pause" class="headerlink" title="函数alarm和pause"></a>函数alarm和pause</h2><p>使用alarm函数可以设置一个定时器(闹钟时间),在将来的某个时刻该定时器会超时。当定时器超时时,产生 SIGALRM信号。如果忽略或不捕捉此信号,则其默认动作是终止调用该a1arm函数的进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 or number of seconds until previously set alarm</span></div></pre></td></tr></table></figure>
<p>每个进程只能有一个闹钟时间。如果在调用a1arm时,之前已为该进程注册的闹钟时间还没有超时,则该闹钟时间的余留值作为本次a1arm函数调用的值返回。以前注册的闹钟时间则被新值代替。</p>
<p>如果有以前注册的尚未超过的闹钟时间,而且本次调用的 seconds值是0,则取消以前的闹钟时间,其余留值仍作为a1arm函数的返回值</p>
<p>pause函数使调用进程挂起直至捕捉到一个信号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: −1 with errno set to EINTR</span></div></pre></td></tr></table></figure>
<p>只有执行了一个信号处理程序并返回时，pause才返回</p>
<h2 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h2><p>我们需要有一个能表示多个信号—信号集(signal set)的数据类型。我们将在sigprocmask类函数中使用这种数据类型,以便告诉内核不允许发生该信号集中的信号。不同的信号的编号可能超过一个整型量所包含的位数,所以一般而言,不能用整型量中的一位代表一种信号,也就是不能用一个整型量表示信号集。POSIX 定义数据类型sigset_t以包含一个信号集,并且定义了下列5个处理信号集的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// All four return: 0 if OK, −1 on error int sigismember(const sigset_t *set, int signo); Returns: 1 if true, 0 if false, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="函数sigprocmask"><a href="#函数sigprocmask" class="headerlink" title="函数sigprocmask"></a>函数sigprocmask</h2><p>调用函数<code>sigprocmask</code>可以检测或更改,或同时进行检测和更改进程的信号屏蔽字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">sigset_t</span> *<span class="keyword">restrict</span> oset)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>如果oset为是非空指针，则进程当前的信号屏蔽字通过oset返回<br>其次,若ser是一个非空指针,则参数how指示如何修改当前信号屏蔽字。主要的操作有并集、交集、替代</p>
<p>在调用<code>sigprocmask</code>后如果有任何未决的、不再阻塞的信号,则在<code>sigprocmask</code>返回前至少将其中之一递送给该进程</p>
<h2 id="函数sigpending"><a href="#函数sigpending" class="headerlink" title="函数sigpending"></a>函数sigpending</h2><p><code>sigpending</code>函数返回一信号集,对于调用进程而言,其中的各信号是阻塞不能递送的,因而也一定是当前未决的。该信号集通过set参数返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<h2 id="函数sigaction"><a href="#函数sigaction" class="headerlink" title="函数sigaction"></a>函数sigaction</h2><p><code>sigaction</code>函数的功能是检查或修改(或检查并修改)与指定信号相关联的处理动作。此函数取代了UNX早期版本使用的 signa1函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> <span class="keyword">struct</span> sigaction *<span class="keyword">restrict</span> act, <span class="keyword">struct</span> sigaction *<span class="keyword">restrict</span> oact)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>参数signo是要检测或修改其具体动作的信号编号。若act指针非空,则要修改其动作。如果oact指针非空,则系统经由oact指针返回该信号的上一个动作。</p>
<h2 id="函数abort"><a href="#函数abort" class="headerlink" title="函数abort"></a>函数abort</h2><p>abort函数的功能是使程序异常终止，此函数将 SIGABRT信号发送给调用进程(进程不应忽略此信号)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// This function never returns</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第10章 信号 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>Unix 进程间通信</title>
    <link href="https://www.liuin.cn/2018/04/13/Unix-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://www.liuin.cn/2018/04/13/Unix-进程间通信/</id>
    <published>2018-04-13T14:52:23.000Z</published>
    <updated>2018-04-18T13:34:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结Unix下进程间通信的几种方式及其特点</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="进程同步和进程通信的区别"><a href="#进程同步和进程通信的区别" class="headerlink" title="进程同步和进程通信的区别"></a>进程同步和进程通信的区别</h3><p>关于这个问题，网络和很多书籍上把这两者混为一谈，对于这两者的区别，说法也有很多种。</p>
<p>其中一种说法是：</p>
<blockquote>
<p>进程互斥、同步与通信的关系：进程竞争资源时要实施互斥，互斥是一种特殊的同步，实质上需要解决好进程同步问题，进程同步是一种进程通信，由此看来，进程互斥、同步都可以看做进程的通信</p>
</blockquote>
<p>个人比较认同是以下这种说法：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行</li>
<li>进程通信：进程间传输信息</li>
</ul>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<p>在进程同步中介绍的信号量也属于进程通信的一种方式，但是属于低级别的进程通信，因为它传输的信息非常小。</p>
<h3 id="消息传递与共享内存"><a href="#消息传递与共享内存" class="headerlink" title="消息传递与共享内存"></a>消息传递与共享内存</h3><p>消息传递提供一种机制以允许进程不必通过共享地址空间来实现通信和同步，消息传递工具提供至少两种操作:发送(消息)和接收(消息)。由进程发送的消息可以是定长的或变长的。</p>
<p>操作系统提供用于通信的通道，进程通过读写这个通道进行通信。</p>
<p>Unix中基于消息传递实现的IPC有：管道、FIFO、消息队列以及网络间的Socket通信</p>
<p>共享内存的进程间通信需要通信进程建立共享内存区域。通常,一块共享内存区域驻留在生成共享内存段进程的地址空间。其他希望使用这个共享内存段进行通信的进程必须将此放到它们自己的地址空间上。</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道用于有亲缘关系的两个进程（父子进程）进行通信，写进程在管道的尾端写入数据，读进程在管道的首端读出数据。管道提供了简单的流控制机制，进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。</p>
<p>通常,一个管道由一个进程创建,在进程调用fork之后,这个管道就能在父进程和子进程之间使用了。</p>
<p>管道存在以下这些局限性：</p>
<ol>
<li>历史上,它们是半双工的(即数据只能在一个方向上流动)。现在,某些系统提供全双工管道,但是为了最佳的可移植性,我们决不应预先假定系统支持全双工管道</li>
<li>管道只能在具有公共祖先的两个进程之间使用。</li>
</ol>
<p>在Unix中管道是通过调用<code>pipe</code>函数创建的。对于一个从子进程到父进程的管道,父进程关闭fd[1],子进程关闭fd[0]。</p>
<p><img src="https://data2.liuin.cn/2018-04-18-15240546357016.jpg" alt=""></p>
<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>FIFO有时被称为命名管道。未命名的管道只能在两个相关的进程之间使用,而且这两个相关的进程还要有一个共同的创建了它们的祖先进程。但是,通过FIFO,不相关的进程也能交换数据。</p>
<p>在Unix中使用<code>mkfifo</code>或者<code>mkfifoat</code>创建FIFO，使用<code>open</code>打开，使用正常文件的I/O函数对FIFO进行读写操作实现进程间通信的目的。</p>
<p>使用FIFO实现两进程间通信的例子：</p>
<p><img src="https://data2.liuin.cn/2018-04-18-15240551859039.jpg" alt=""></p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是消息的链接表,存储在内核中,由消息队列标识符标识。</p>
<p>在Unix中使用<code>msgget</code>用于创建一个新队列或打开一个现有队列、<code>msgsnd</code>将新消息添加到队列尾端。<code>mmsgrcv</code>用于从队列中取消息。我们并不定要以先进先出次序取消息,也可以按消息的类型字段取消息。<br>每个消息包含一个正的长整型类型的字段、一个非负的长度以及实际数据字节数(对应于长度),所有这些都在将消息添加到队列时,传送给 msgsna。</p>
<p>消息队列相比于其他方式有很多优点：它提供有格式的字节流，减少了开发人员的工作量；消息具有类型（system V）或优先级（posix）</p>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>Socket 是网络进程间通信的一种，我们将描述套接字网络进程间通信接口,进程用该接口能够和其他进程通信,无论它们是在同一台计算机上还是在不同的计算机上。实际上,这正是套接字接口的设计目标之一。</p>
<p>Socket自身携带同步机制，不需要额外的方式来辅助实现同步。</p>
<p>在Unix中使用<code>socket</code>、<code>bind</code>、<code>connect</code>、<code>listen</code>、<code>accept</code>等一系列系统调用建立连接并进行通信。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量是一个计数器，用于多进程提供对共享数据对象的访问。</p>
<p>为了获得共享资源,进程需要执行下列操作。</p>
<ol>
<li>测试控制该资源的信号量</li>
<li>若此信号量的值为正,则进程可以使用该资源。在这种情况下,进程会将信号量值减1,表示它使用了一个资源单位。</li>
<li>否则,若此信号量的值为0,则进程进入休眠状态,直至信号量值大于0。进程被唤醒后,它返回至步骤(1)。</li>
</ol>
<p>当进程不再使用由一个信号量控制的共享资源时,该信号量值增1。如果有进程正在休眠等待此信号量,则唤醒它们。</p>
<p>为了正确地实现信号量,信号量值的测试及减1操作应当是原子操作。为此,信号量通常是在内核中实现的。</p>
<p>因为只能传递简单的数据，所以信号量常常只是用来进行进程间的同步。</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享存储允许两个或多个进程共享一个给定的存储区。因为数据不需要在客户进程和服务器进程之间复制,所以这是最快的一种IPC。</p>
<p>不过使用共享内存的时候要注意保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>管道</td>
<td>创建简单</td>
<td>容量有限、速度慢、只能用于父子进程通讯、半双工通信方式</td>
</tr>
<tr>
<td>FIFO</td>
<td>克服了管道没有名字的限制、允许无亲缘关系进程间的通信</td>
<td>速度慢</td>
</tr>
<tr>
<td>消息队列</td>
<td>承载信息量比较多、能够承载有格式的字节流</td>
<td>容量受到系统限制</td>
</tr>
<tr>
<td>Socket</td>
<td>能够实现网络间进程的通信</td>
<td>实现比较复杂</td>
</tr>
<tr>
<td>信号量</td>
<td>能够比较好地解决同步问题</td>
<td>传递的信息较少，只能用于同步</td>
</tr>
<tr>
<td>共享内存</td>
<td>速度快</td>
<td>要解决线程安全的问题</td>
</tr>
</tbody>
</table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Unix环境高级编程》</li>
<li>《Unix-Linux编程实践教程》</li>
<li>《操作系统概念》</li>
<li><a href="http://www.cnblogs.com/youngforever/p/3250270.html" target="_blank" rel="external">http://www.cnblogs.com/youngforever/p/3250270.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结Unix下进程间通信的几种方式及其特点&lt;/p&gt;
    
    </summary>
    
      <category term="开发随笔" scheme="https://www.liuin.cn/categories/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
</feed>
