<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sixzeroo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.liuin.cn/"/>
  <updated>2018-03-08T07:03:48.000Z</updated>
  <id>https://www.liuin.cn/</id>
  
  <author>
    <name>Sixzeroo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 题解——Median of Two Sorted Arrays</title>
    <link href="https://www.liuin.cn/2018/03/08/LeetCode-%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94Median-of-Two-Sorted-Arrays/"/>
    <id>https://www.liuin.cn/2018/03/08/LeetCode-题解——Median-of-Two-Sorted-Arrays/</id>
    <published>2018-03-08T06:42:12.000Z</published>
    <updated>2018-03-08T07:03:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 题解——Median of Two Sorted Arrays</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定两个有序数组，求这两个有序数组中所有数的中位数</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先理解什么是中位数，中位数把这两个数组中的所有的数有序放到一起，排在中间的那一个数（或者两个数）就是中位数，我们也可以从另外一个角度去看，中位数作为边界把这些数分割成两半。这两边的数的个数是相等的。</p>
<p>对于这两个数组就相当于每个数组都有一个数把这个数组分割成两半：</p>
<p><img src="https://data2.liuin.cn/2018-03-08-15204918440445.jpg" alt=""></p>
<p>这里考虑使用二分法求解，对于两个数组，两边的数的个数是相等的。由此，考虑一种分割情况，我们可以假设A数组从i点分割，这样因为两边的数的个数相等很容易算得B数组的分割点<code>j=(n+m+1)/2-i</code>，对于每一种分割有三种情况：</p>
<ol>
<li><code>A[i]&gt;=B[j-1] &amp;&amp; B[j]&gt;=A[i-1]</code>这种情况下，刚好取得中位数</li>
<li><code>A[i]&lt;B[j-1]</code> 这种情况下，表示我们选取的i点过小，可以通过二分进一步缩减范围</li>
<li><code>B[j]&lt;A[i-1]</code> 这种情况下，表示我们选取的i点过大，可以通过二分进一步缩减范围</li>
</ol>
<p>除此之外另外还要注意几点：</p>
<ol>
<li>我们选取的i要从数组数量较小的那个数组中选取，因为如果从数组数量大的数组中选取的话，可能导致选取的i较小，使得计算出的j值大于B数组中的元素个数</li>
<li>存在一些特殊情况在端点分割的特殊情况，比如i=0，i=n，j=0，j=m的这些情况。在这样的情况下，我们可以只需要计算左边数的最大值，和右边数的最小值即可。</li>
<li>最后的结果要对总数是奇数还是偶数进行讨论，如果是奇数的话，表示中位数是左边那一堆中的最大值；如果是偶数的话，中位数中左边一堆数的最大值和右边一堆书的最小值的平均值。</li>
</ol>
<h2 id="代码（C-）"><a href="#代码（C-）" class="headerlink" title="代码（C++）"></a>代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = nums1.size(), m = nums2.size();</div><div class="line">        <span class="comment">// 对小的数组进行分割</span></div><div class="line">        <span class="keyword">if</span>(n &gt; m)</div><div class="line">        &#123;</div><div class="line">            swap(nums1, nums2);</div><div class="line">            swap(n,m);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 二分法确定两个界限</span></div><div class="line">        <span class="keyword">int</span> i, j, iMin = <span class="number">0</span>, iMax = n;</div><div class="line">        <span class="keyword">while</span>(iMin &lt;= iMax)</div><div class="line">        &#123;</div><div class="line">            i = (iMin + iMax)/<span class="number">2</span> ;</div><div class="line">            j = (m+n+<span class="number">1</span>)/<span class="number">2</span> - i;</div><div class="line">            <span class="comment">// i的取值过大</span></div><div class="line">            <span class="keyword">if</span>(i &gt; iMin &amp;&amp; nums1[i<span class="number">-1</span>] &gt; nums2[j])</div><div class="line">            &#123;</div><div class="line">                iMax = i - <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// i的取值过小的情况</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; iMax &amp;&amp; nums1[i] &lt; nums2[j<span class="number">-1</span>]) </div><div class="line">            &#123;</div><div class="line">                iMin = i + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 找到中位数</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">int</span> left = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) left = nums2[j<span class="number">-1</span>];</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) left = nums1[i<span class="number">-1</span>];</div><div class="line">                <span class="keyword">else</span> left = max(nums1[i<span class="number">-1</span>], nums2[j<span class="number">-1</span>]);</div><div class="line">                <span class="comment">// 总数是奇数的时候</span></div><div class="line">                <span class="keyword">if</span> ( (m + n) % <span class="number">2</span>) <span class="keyword">return</span> left;</div><div class="line">                </div><div class="line">                <span class="keyword">int</span> right = <span class="number">0</span>;</div><div class="line">                <span class="keyword">if</span>(i == n) right = nums2[j];</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == m) right = nums1[i];</div><div class="line">                <span class="keyword">else</span> right = min(nums1[i], nums2[j]);</div><div class="line">                <span class="keyword">return</span> (left + right)/<span class="number">2.0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 题解——Median of Two Sorted Arrays&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.liuin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://www.liuin.cn/tags/LeetCode/"/>
    
      <category term="二分" scheme="https://www.liuin.cn/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>APUE 文件I/O</title>
    <link href="https://www.liuin.cn/2018/03/06/APUE-%E6%96%87%E4%BB%B6I-O/"/>
    <id>https://www.liuin.cn/2018/03/06/APUE-文件I-O/</id>
    <published>2018-03-06T10:49:20.000Z</published>
    <updated>2018-03-07T03:29:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第2章 文件I/O 笔记</p>
<a id="more"></a>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>UNX系统中的大多数文件只需用到5个函数:open、read、 write、 lseek以及c1ose。</p>
<p>本章描述的函数经常被称为不带缓冲的I/O( unbuffered I/O,与将在第5章中说明的标准I/O函数相对照)。术语不带缓冲指的是每个read和 write都调用内核中的一个系统调用。</p>
<p>只要涉及在多个进程间共享资源,原子操作的概念就变得非常重要。我们将通过文件IO和open函数的参数来讨论此概念。</p>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>对于内核而言,<strong>所有打开的文件都通过文件描述符引用</strong>。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时,内核向进程返回一个文件描述符。</p>
<p>按照惯例,UNIX系统shell把<strong>文件描述符0与进程的标准输入关联,文件描述符1与标准输出关联,文件描述符2与标准错误关联</strong>。这是各种shel以及很多应用程序使用的惯例.</p>
<h2 id="函数open和openat"><a href="#函数open和openat" class="headerlink" title="函数open和openat"></a>函数open和openat</h2><p>用于打开或者创建一个文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oﬂag, ... <span class="comment">/* mode_t mode */</span> )</span></span>; </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oﬂag, ... <span class="comment">/* mode_t mode */</span> )</span></span>; </div><div class="line"><span class="comment">//Both return: ﬁle descriptor if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>我们将最后一个参数写为…,ISO C用这种方法表明余下的参数的数量及其类型是可变的。对于open函数而言,仅当创建新文件时才使用最后这个参数(稍后将对此进行说明)。</p>
<p>path参数是要打开或创建文件的名字。oflag参数可用来说明此函数的多个选项。用一个或者多个常量“或”运算构成oflag参数</p>
<p>使用的常量可以参考原书</p>
<h2 id="函数create"><a href="#函数create" class="headerlink" title="函数create"></a>函数create</h2><p>可以调用create函数创建一个文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>; </div><div class="line"></div><div class="line"><span class="comment">//Returns: ﬁle descriptor opened for write-only if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>此函数等效于<code>open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);</code></p>
<p>creat的一个不足之处是它以只写方式打开所创建的文件。</p>
<h2 id="函数close"><a href="#函数close" class="headerlink" title="函数close"></a>函数close</h2><p>调用close函数关闭一个打开的文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//Returns: 0 if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>关闭一个文件时还会释放该进程加在该文件上的所有记录锁。</p>
<p>当一个进程终止时,内核自动关闭它所有的打开文件。很多程序都利用了这一功能而不显式地用c1ose关闭打开文件。</p>
<h2 id="函数lseek"><a href="#函数lseek" class="headerlink" title="函数lseek"></a>函数lseek</h2><p>每个打开文件都有一个与其相关联的“<strong>当前文件偏移量</strong>”( current file offset)。它通常是一个非负整数,用以度量从文件开始处计算的字节数。</p>
<p>调用1seek显式地为一个打开文件设置偏移量：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</div><div class="line"></div><div class="line"><span class="comment">//Returns: new ﬁle offset if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>对参数offet的解释与参数 whence的值有关。</p>
<ul>
<li>若 whence是 SEEK_SET,则将该文件的偏移量设置为距文件开始处 offset个字节。</li>
<li>若 whence是 SEEK_CUR,则将该文件的偏移量设置为其当前值加 offset, offset可为正或负。</li>
<li>若 whence是 SEEK_END,则将该文件的偏移量设置为文件长度加 offset, offset可正可负。</li>
</ul>
<p>通常,文件的当前偏移量应当是一个非负整数,但是,某些设备也可能允许负的偏移量。但对于普通文件,其偏移量必须是非负值。</p>
<p>1seek仅将当前的文件偏移量记录在内核中,它并不引起任何IO操作。然后,该偏移量用于下一个读或写操作。</p>
<p>文件偏移量可以大于文件的当前长度,在这种情况下,对该文件的下一次写将加长该文件,并在文件中构成一个空洞,这一点是允许的。位于文件中但没有写过的字节都被读为0</p>
<p><strong>文件中的空洞并不要求在磁盘上占用存储区</strong>。具体处理方式与文件系统的实现有关,当定位到超出文件尾端之后写时,对于新写的数据需要分配磁盘块,但是对于原文件尾端和新开始写位置之间的部分则不需要分配磁盘块。</p>
<p>创建一个具有空洞的文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">char</span>	buf1[] = <span class="string">"abcdefghij"</span>;</div><div class="line"><span class="keyword">char</span>	buf2[] = <span class="string">"ABCDEFGHIJ"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span>		fd;</div><div class="line"></div><div class="line">	<span class="comment">// 创建文件</span></div><div class="line">	<span class="keyword">if</span> ((fd = creat(<span class="string">"file.hole"</span>, FILE_MODE)) &lt; <span class="number">0</span>)</div><div class="line">		err_sys(<span class="string">"creat error"</span>);</div><div class="line"></div><div class="line">	<span class="comment">// 写入a-j，此时文件偏移量为10</span></div><div class="line">	<span class="keyword">if</span> (write(fd, buf1, <span class="number">10</span>) != <span class="number">10</span>)</div><div class="line">		err_sys(<span class="string">"buf1 write error"</span>);</div><div class="line">	<span class="comment">/* offset now = 10 */</span></div><div class="line"></div><div class="line">	<span class="comment">// 改变文件偏移量到16384</span></div><div class="line">	<span class="keyword">if</span> (lseek(fd, <span class="number">16384</span>, SEEK_SET) == <span class="number">-1</span>)</div><div class="line">		err_sys(<span class="string">"lseek error"</span>);</div><div class="line">	<span class="comment">/* offset now = 16384 */</span></div><div class="line"></div><div class="line">	<span class="comment">// 在新的文件偏移量下写入A-J</span></div><div class="line">	<span class="keyword">if</span> (write(fd, buf2, <span class="number">10</span>) != <span class="number">10</span>)</div><div class="line">		err_sys(<span class="string">"buf2 write error"</span>);</div><div class="line">	<span class="comment">/* offset now = 16394 */</span></div><div class="line"></div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为1seek使用的偏移量是用off_t类型表示的,所以允许具体实现根据各自特定的平台自行选择大小合适的数据类型。</p>
<h2 id="函数read"><a href="#函数read" class="headerlink" title="函数read"></a>函数read</h2><p>调用read函数从打开文件中读数据<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); </div><div class="line"></div><div class="line"><span class="comment">//Returns: number of bytes read, 0 if end of ﬁle, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>如read成功,则返回读到的字节数。如已到达文件的尾端,则返回0。</p>
<p>有多种情况可使实际读到的字节数少于要求读的字节数</p>
<ul>
<li>读普通文件时,在读到要求字节数之前已到达了文件尾端。</li>
<li>当从终端设备读时,通常一次最多读一行。</li>
<li>当从网络读时,网络中的缓冲机制可能造成返回值小于所要求读的字节数</li>
<li>当从管道或FIFO读时,如若管道包含的字节少于所需的数量,那么read将只返回实际可用的字节数</li>
<li>当从某些面向记录的设备(如磁带)读时,一次最多返回一个记录。</li>
<li>当一信号造成中断,而已经读了部分数据量时。</li>
</ul>
<h2 id="函数write"><a href="#函数write" class="headerlink" title="函数write"></a>函数write</h2><p>调用write函数想打开文件写数据<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes); </div><div class="line"></div><div class="line"><span class="comment">//Returns: number of bytes written if OK, −1 on error</span></div></pre></td></tr></table></figure></p>
<p>其返回值通常与参数 nbytes的值相同,否则表示出错。 write出错的一个常见原因是磁盘已写满,或者超过了一个给定进程的文件长度限制</p>
<h2 id="I-O效率"><a href="#I-O效率" class="headerlink" title="I/O效率"></a>I/O效率</h2><p>BUFFSIZE 一般选取与磁盘块相同大小的字节数，大多数情况问4096</p>
<p>大多数文件系统为改善性能都采用某种预读( read ahead)技术。当检测到正进行顺序读取时,系统就试图读入比应用所要求的更多数据,并假想应用很快就会读这些数据。</p>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>UNIX系统支持在不同进程间共享打开文件。在介绍dup函数之前,先要说明这种共享。为此先介绍内核用于所有I/O的数据结构。</p>
<p>内核使用3种数据结构表示打开文件,它们之间的关系决定了在文件共享方面一个进程对另个进程可能产生的影响。</p>
<ol>
<li><strong>每个进程在进程表中都有一个记录项,记录项中包含一张打开文件描述符表</strong>,可将其视为一个矢量,每个描述符占用一项。与每个文件描述符相关联的是文件描述符标志和指向一个文件表项的指针。</li>
<li><strong>内核为所有打开文件维持一张文件表</strong>。每个文件表项包含文件状态标志(读、写、添写、同步和非阻塞等)、当前文件偏移量、指向该文件v节点表项的指针</li>
<li>每个打开文件(或设备)都有一个v节点( v-node)结构。v节点包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件,v节点还包含了该文件的i节点(i-node,索引节点)。</li>
</ol>
<p><img src="https://data2.liuin.cn/2018-03-07-15203821021363.jpg" alt=""></p>
<blockquote>
<p>创建v节点结构的目的是对在一个计算机系统上的多文件系统类型提供支持。把与文件系统无关的i节点部分称为v节点。Linux没有将相关数据结构分为i节点和ⅴ节点,而是采用了一个与文件系统相关的i节点和个与文件系统无关的i节点。</p>
</blockquote>
<p>两个独立进程打开同一个文件</p>
<p><img src="https://data2.liuin.cn/2018-03-07-15203822136634.jpg" alt=""></p>
<p>文件描述符标志和文件状态标志在作用范围方面的区别,前者只用于一个进程的一个描述符,而后者则应用于指向该给定文件表项的任何进程中的所有描述符。</p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><ol>
<li>追加到一个文件</li>
</ol>
<p>多个进程同时使用这种方法将数据追加写到同一文件,则会产生问题</p>
<p>问题出在逻辑操作“先定位到文件尾端,然后写”,它使用了两个分开的函数调用。解决问题的方法是使这两个操作对于其他进程而言成为一个原子操作。</p>
<ol>
<li>函数pread和pwrite</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset); </div><div class="line"></div><div class="line"><span class="comment">//Returns: number of bytes read, 0 if end of ﬁle, −1 on error</span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> pwrite(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset); </div><div class="line"></div><div class="line"><span class="comment">//Returns: number of bytes written if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>调用 pread相当于调用1seek后调用read,但是 pread又与这种顺序调用有下列重要区别:1. 调用 pread时,无法中断其定位和读操作。2. 不更新当前文件偏移量。</p>
<p>调用pwrite相当于调用1seek后调用 write,但也与它们有类似的区别。</p>
<h2 id="函数dup和dup2"><a href="#函数dup和dup2" class="headerlink" title="函数dup和dup2"></a>函数dup和dup2</h2><p>下面两个用来复制一个文件描述符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//Both return: new ﬁle descriptor if OK, −1 on error</span></div></pre></td></tr></table></figure>
<p>由dup返回的新文件描述符一定是当前可用文件描述符中的最小数值。对于dup2,可以用fd2参数指定新描述符的值。如果fd2已经打开,则先将其关闭。如若fd等于fd2,则dup2返回fd2,而不关闭它。否则,fd2的 FD_CLOEXEO文件描述符标志就被清除,这样fd2在进程调用exec时是打开状态</p>
<p>dup(1)以后的内核数据结构：<br><img src="https://data2.liuin.cn/2018-03-07-15203828993104.jpg" alt=""></p>
<h2 id="函数sync、-fsync和-fdatasync"><a href="#函数sync、-fsync和-fdatasync" class="headerlink" title="函数sync、 fsync和 fdatasync"></a>函数sync、 fsync和 fdatasync</h2><p>传统的UNⅨ系统实现在内核中设有缓冲区高速缓存或页高速缓存,大多数磁盘I/O都通过缓冲区进行。当我们向文件写入数据时,内核通常先将数据复制到缓冲区中,然后排入队列,晚些时候再写入磁盘。这种方式被称为<strong>延迟写</strong>( delayed write)</p>
<p>通常,当内核需要重用缓冲区来存放其他磁盘块数据时,它会把所有延迟写数据块写入磁盘为了保证磁盘上实际文件系统与缓冲区中内容的一致性,UNIX系统提供了sync、 fsync和Edatasync三个函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//Returns: 0 if OK, −1 on error</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>sync只是将所有修改过的块缓冲区排入写队列,然后就返回,它并不等待实际写磁盘操作结束。</p>
<p>fsync函数只对由文件描述符/指定的一个文件起作用,并且等待写磁盘操作结束才返回fsync可用于数据库这样的应用程序,这种应用程序需要确保修改过的块立即写到磁盘上。</p>
<p>fdatasync函数类似于 sync,但它只影响文件的数据部分。而除数据外, fsync还会同步更新文件的属性。</p>
<h2 id="函数fcntl"><a href="#函数fcntl" class="headerlink" title="函数fcntl"></a>函数fcntl</h2><p>fcntl函数可以改变已经打开文件的属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* int arg */</span> )</span></span>; </div><div class="line"></div><div class="line"><span class="comment">//Returns: depends on cmd if OK (see following), −1 on error</span></div></pre></td></tr></table></figure>
<p>fcnt1函数有以下5种功能</p>
<ol>
<li>复制一个已有的描述符(cmd= F_DUPFD或 F_DUPFD_CLOEXEC)。</li>
<li>获取/设置文件描述符标志(cmd= E_GETED或 F_SETED)。</li>
<li>获取/设置文件状态标志(cmd= F_GETEL或 F_SETEL)</li>
<li>获取/设置异步IO所有权(cmd= F_GETOWN或F_SETOWN)。</li>
<li>获取/设置记录锁(cmd= F_GETLK、 F_SETLK或 F_SETLKW)</li>
</ol>
<p>在修改文件描述符标志或文件状态标志时必须谨慎,先要获得现在的标志值,然后按照期望修改它,最后设置新标志值。不能只是执行 F_SETED或 E_SETEL命令,这样会关闭以前设置的标志位。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">set_fl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span> <span class="comment">/* flags are file status flags to turn on */</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span>		val;</div><div class="line"></div><div class="line">	<span class="comment">// 获取现在的文件标志位</span></div><div class="line">	<span class="keyword">if</span> ((val = fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</div><div class="line">		err_sys(<span class="string">"fcntl F_GETFL error"</span>);</div><div class="line"></div><div class="line">	<span class="comment">// 计算新的标志值</span></div><div class="line">	val |= flags;		<span class="comment">/* turn on flags */</span></div><div class="line">         </div><div class="line">	<span class="comment">// 设置新的标志值</span></div><div class="line">	<span class="keyword">if</span> (fcntl(fd, F_SETFL, val) &lt; <span class="number">0</span>)</div><div class="line">		err_sys(<span class="string">"fcntl F_SETFL error"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="函数ioctl"><a href="#函数ioctl" class="headerlink" title="函数ioctl"></a>函数ioctl</h2><p>每个设备驱动程序可以定义它自己专用的一组ioct1命令,系统则为不同种类的设备提供通用的 ioctl命令。</p>
<h2 id="dev-fd"><a href="#dev-fd" class="headerlink" title="/dev/fd"></a>/dev/fd</h2><p>较新的系统都提供名为/aev/fd的目录,其目录项是名为0、1、2等的文件。打开文件/dev/fd/n等效于复制描述符n(假定描述符n是打开的)。</p>
<p>大多数系统忽略它所指定的mode,而另外一些系统则要求mode必须是所引用的文件(在这里是标准输入)初始打开时所使用的打开模式的一个子集。</p>
<p>某些系统提供路径名/dev/ stdin、/dev/stdoυt和/dev/ stderr,这些等效于dev/fd/0、/dev/fd/1和/dev/fd/2。</p>
<p>dev/fd文件主要由shell使用,它允许使用路径名作为调用参数的程序,能用处理其他路径名的相同方式处理标准输入和输出。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第2章 文件I/O 笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》笔记 C++标准库部分</title>
    <link href="https://www.liuin.cn/2018/03/04/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-C-%E6%A0%87%E5%87%86%E5%BA%93%E9%83%A8%E5%88%86/"/>
    <id>https://www.liuin.cn/2018/03/04/《C-Primer》笔记-C-标准库部分/</id>
    <published>2018-03-04T02:58:33.000Z</published>
    <updated>2018-03-08T02:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》笔记 C++基础部分</p>
<a id="more"></a>
<h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><p>大部分的I/O库设施：</p>
<ul>
<li>istream(输入流)类型,提供输入操作。</li>
<li>ostream(输出流)类型,提供输出操作。</li>
<li>cin，一个 istream对象,从标准输入读取数据。</li>
<li>cout,一个 ostream对象,向标准输出写入数据。</li>
<li>cerr,一个 ostream对象,通常用于输出程序错误消息,写入到标准错误・</li>
<li>>&gt;运算符,用来从一个istream对象读取输入数据。</li>
<li>&lt;&lt;运算符,用来向一个ostream对象写入输出数据。</li>
<li>getline函数,从一个给定的 istream读取一行数据,存入一个给定的 string对象中。</li>
</ul>
<h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><p>我们已经使用过的IO类型和对象都是操纵char数据的。默认情况下,这些对象都是关联到用户的控制台窗口的。</p>
<p>为了支持这些不同种类的IO处理操作,在 istream和ostream之外,标准库还定义了其他一些IO类型:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518671687211.jpg" alt="enter description here"></p>
<p>为了支持宽字符的语言，标准库定义了一组类型和对象来操纵wchat_t类型的数据。宽字符版本的类型和函数的名字以一个w开始。</p>
<blockquote>
<p>IO类型之间的关系</p>
</blockquote>
<p>标准库使我们能忽略这些不同类型的流之间的差异,这是通过<strong>继承机制</strong>( inheritance)实现的。利用模板,我们可以使用具有继承关系的类,而不必了解继承机制如何工作的细节。简单地说,继承机制使我们可以声明一个特定的类继承自另一个类。我们通常可以将一个派生类(继承类)对象当作其基类(所继承的类)对象来使用</p>
<h3 id="IO对象无拷贝或赋值"><a href="#IO对象无拷贝或赋值" class="headerlink" title="IO对象无拷贝或赋值"></a>IO对象无拷贝或赋值</h3><p>我们不能拷贝或者对IO对象赋值，由于不能拷贝IO对象，因此我们也不能将形参或者函数返回类型设置为流类型。进行IO操作的函数通常以引用的方式传递和返回流。</p>
<p>读取或者返回一个IO对象会改变其状态，因此传递和引用不能是const的</p>
<h3 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h3><blockquote>
<p>查询流状态</p>
</blockquote>
<p>IO库定义了一个与机器无关的 iostate类型,它提供了表达流状态的完整功能。这个类型应作为一个位集合来使用</p>
<blockquote>
<p>管理条件状态</p>
</blockquote>
<p>流对象的 rdstate 成员返回一个iostate值,对应流的当前状态。 setstate操作将给定条件位置位,表示发生了对应错误。clear成员是一个重載的成员:它有一个不接受参数的版本,而另一个版本接受一个 iostate类型型的参数。</p>
<h3 id="管理输出缓存"><a href="#管理输出缓存" class="headerlink" title="管理输出缓存"></a>管理输出缓存</h3><p>每一个输出流都管理一个缓冲区，用来保存程序读写的数据。</p>
<p>文本串可能立即打印出来,但也有可能被操作系统保存在缓冲区中,随后再打印。有了缓冲机制,操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很耗时,<strong>允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升</strong>。</p>
<p>导致缓冲刷新(即,数据真正写到输出设备或文件)的原因有很多：</p>
<ul>
<li>程序正常结束,作为main函数的 return操作的一部分,缓冲冲刷新被执行。</li>
<li>缓冲区满时,需要刷新缓冲,而后新的数据才能继续写入缓冲区。</li>
<li>我们可以使用操纵符如endl来显式刷新缓冲区。</li>
<li>在每个输出操作之后,我们可以用操纵符unitbuf设置流的内部状态,来清空缓冲区。</li>
<li>一个输出流可能被关联到另一个流。在这种情况下,当读写被关联的流时,关联到的流的缓冲区会被刷新。</li>
</ul>
<blockquote>
<p>刷新输出缓冲区</p>
</blockquote>
<p>我们已经使用过操纵符endl,它完成换行并刷新缓冲区的工作。IO库中还有两个类似的操纵符:flush和ends。flush刷新缓冲区,但不输出任何额外的字符;ends向缓冲区插入一个空字符,然后刷新缓冲区</p>
<blockquote>
<p>uintbuf操作符</p>
</blockquote>
<p>如果想在每次输出操作后都刷新缓冲区,我们可以使用 unitbuf操纵符。它告诉流在接下来的每次写操作之后都进行一次=flush操作。而 nounitbuf操纵符则重置流,使其恢复使用正常的系统管理的缓冲区刷新机制:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518672433805.jpg" alt="enter description here"></p>
<h2 id="文件的输入输出"><a href="#文件的输入输出" class="headerlink" title="文件的输入输出"></a>文件的输入输出</h2><p>头文件 fstream定义了三个类型来支持文件IO: ifstream从一个给定文件读取数据,ofstream向一个给定文件写入数据,以及 fstream可以读写给定文件。</p>
<p>除了继承自 iostream类型的行为之外, fstream中定义的类型还增加了一些新的成员来管理与流关联的文件</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518672783415.jpg" alt="enter description here"></p>
<h3 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h3><p>当我们想要读写一个文件时,可以定义一个文件流对象,并将对象与文件关联起来。每个文件流类都定义了一个名为open的成员函数,它完成一些系统相关的操作,来定位给定的文件,并视情况打开为读或写模式。</p>
<blockquote>
<p>成员函数open和close</p>
</blockquote>
<p>如果我们定义一个空文件流对象，随后我们可以调用open来将它与文件关联起来。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518672886373.jpg" alt="enter description here"></p>
<p>如果调用open失败, failbit会被置位。因为调用open可能失败,进行open是否成功的检测通常是一个好习惯</p>
<h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><p>每一个流都有一个关联的<strong>文件模式</strong>（file mode），用来指出如何使用文件。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518672976516.jpg" alt="enter description here"></p>
<p>无论用哪种方式打开文件,我们都可以指定文件模式,调用open打开文件时可以,用一个文件名初始化流来隐式打开文件时也可以。</p>
<blockquote>
<p>以out模式打开文件会丢弃</p>
</blockquote>
<p>已有数据默认情况下,当我们打开一个 ofstream时,文件的内容会被丢弃。阻止一个ofstream清空给定文件内容的方法是同时指定aap模式:</p>
<h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><p>sstream头文件定义了三个类型来支持内存IO,这些类型可以向 string写入数据,从string读取数据,就像string是一个IO流一样。</p>
<p>istringstream从 string读取数据，ostringstream向 string写入数据,而头文件 stringstream既可从 string读数据也可向 string写数据。与fstream类型类似,头文件 sstream中定义的类型都继承自我们已经使用过的 iostream头文件中定义的类型。除了继承得来的操作, sstream中定义的类型还增加了一些成员来管理与流相关联的string。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518676701978.jpg" alt="enter description here"></p>
<h3 id="使用istringstream"><a href="#使用istringstream" class="headerlink" title="使用istringstream"></a>使用istringstream</h3><p>当我们的某些工作室对整行的文本进行处理，而其他的一些工作是处理行内的单个单词时，通常可以使用istringstream</p>
<h3 id="使用ostringstream"><a href="#使用ostringstream" class="headerlink" title="使用ostringstream"></a>使用ostringstream</h3><p>当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>C++使用标准库类来处理面向流的输入和输出:</p>
<ol>
<li>iostream处理控制台</li>
<li>fstream处理命名文件</li>
<li>stringstream完成内存string的IO</li>
</ol>
<hr>
<h1 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h1><p>一个容器就是一些特定类型对象的集合。<strong>顺序容器</strong>( sequential container)为程序员提供了<strong>控制元素存储和访问顺序的能力</strong>。这种顺序<strong>不依赖于元素的值,而是与元素加入容器时的位置相对应</strong>。与之相对的,我们将在第11章介绍的有序和无序关联容器,则根据关键字的值来存储元素。</p>
<h2 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_16_1518790789624.jpg" alt="enter description here"></p>
<p>以上就是标准库中的顺序容器了，所有顺序容器提供快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：</p>
<ul>
<li>向容器添加或从容器中删除元素的代价</li>
<li>非顺序访问容器中元素的代价</li>
</ul>
<p>除了固定大小的的 array外,其他容器都提供高效、灵活的内存管理。</p>
<p>list和 forward_list 两个容器的设计目的是<strong>令容器任何位置的添加和删除操作都很快速</strong>。作为代价,这两个容器不支持元素的随机访问:为了访问一个元素,我们只能遍历整个容器。而且,与 vector、 deque和 array相比,这两个容器的额外内存开销也很大。</p>
<p>deque是一个更为复杂的数据结构。与string和 vector类似, deque支持快速的随机访问。与 string和 vector一样,在 deque的中间位置添加或删除元素的代价(可能)很高。但是,<strong>在 deque的两端添加或删除元素都是很快的</strong>,与list或forward_list添加删除元素的速度相当。</p>
<p>以下是选择容器的基本原则：</p>
<ul>
<li>除非你有很好的理由选择其他容器,否则应使用 vector。</li>
<li>如果你的程序有很多小的的元素,且空间的额外开销很重要,则不要使用list或forward_list。</li>
<li>如果程序要求随机访问元素,应使用 vector或 deque如果程序要求在容器的中间插入或删除元素,应使用list或forward_list。</li>
<li>如果程序需要在头尾位置插入或删除元素,但不会在中间位置进行插入或删除操作,则使用 deque</li>
<li>如果程序只有在读取输入时才需要在容器中间位置插入元素,随后需要随机访问元素,则：首先，确定是否真的需要在容器中间添加元素；如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的额内容拷贝到一个vector 中</li>
</ul>
<h2 id="容器库概览"><a href="#容器库概览" class="headerlink" title="容器库概览"></a>容器库概览</h2><p>容器类型上形成了一种层次：</p>
<ul>
<li>某些操作是所有容器类型都提供的</li>
<li>另外一些操作仅针对顺序容器、关联容器或无序容器</li>
<li>还有一些操作只适用于一小部分容器</li>
</ul>
<p>本节我们介绍所有容器都适用的操作</p>
<p>一般来说，每个容器都定义在一个头文件中，文件名与类型名相同；顺序容器几乎可以保存任意类型的元素。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_16_1518793115931.jpg" alt="enter description here"></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>与容器一样,迭代器有着公共的接口:如果一个迭代器提供某个操作,那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。</p>
<p>一个迭代器范围( iterator range)由一对迭代器表示,两个迭代器分别指向同一个容器中的元素或者是<strong>尾元素之后的位置</strong>( one past the last element)。这两个迭代器通常被称为 begin和end,或者者是 first和laste(可能有些误导),它们标记了容器中元素的个范围</p>
<p>这种元素范围被称为<strong>左闭合区间</strong>( left-inclusive interval),其标准数学描述为<code>[begin, end)</code></p>
<h3 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h3><p>反向迭代器就是一种反向遍历容器的迭代器,与正向迭代器相比,各种操作的含义也都发生了颠倒</p>
<p>,通过类型别名,我们可以在不了解容器中元素类型的情况下使用它。如果需要元素类型,可以使用容器的value_type。如果需要元素类型的一个引用,可以使用 reference或 const_reference。这些元素相关的类型别名在泛型编程中非常有用</p>
<h3 id="begin-和-end成员"><a href="#begin-和-end成员" class="headerlink" title="begin 和 end成员"></a>begin 和 end成员</h3><p>begin和end操作生成指向容器中第一个元素和尾元素之后位置的迭代器。这两个迭代器最常见的用途是形成一个包含容器中所有元素的迭代器范围</p>
<h3 id="容器定义和初始化"><a href="#容器定义和初始化" class="headerlink" title="容器定义和初始化"></a>容器定义和初始化</h3><p>每个容器类型都定义了一个默认构造函数。除 array之外,其他容器的默认构造函数都会创建一个指定类型的空容器,且都可以接受指定容器大小和元素初始值的参数。</p>
<blockquote>
<p>将一个容器初始化为另一个容器的拷贝</p>
</blockquote>
<p>将一个新容器创建为另一个容器的拷贝的方法有两种:可以直接拷贝整个容器,或者( array除外)拷贝由一个迭代器对指定的元素范围。为了创建一个容器为另一个容器的拷贝,两个容器的类型及其元素类型必须匹配。不过,当传递迭代器参数来拷贝一个范围时,就不要求容器类型是相同的了。而且,新容器和原容器中的元素类型也可以不同,只要能将要拷贝的元素转换</p>
<blockquote>
<p>与顺序容器大小相关的构造函数</p>
</blockquote>
<p>除了与关联容器相同的构造函数外,顺序容器( array除外)还提供另一个构造函数,它接受一个容器大小和一个(可选的)元素初始值。</p>
<h3 id="赋值与swap"><a href="#赋值与swap" class="headerlink" title="赋值与swap"></a>赋值与swap</h3><p>赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝。</p>
<blockquote>
<p>使用assign</p>
</blockquote>
<p>顺序容器( array除外)还定义了一个名为 assign的成员,允许我们从一个不同但相容的类型赋值,或者从容器的一个子序列赋值。assign操作用参数所指定的元素(的拷贝)替换左边容器中的所有元素。例如,我们可以用 assign实现将一个 vector中的一段char*值赋予一个list中的 string：<br><img src="https://data2.liuin.cn/story-writer/2018_2_16_1518794438240.jpg" alt="enter description here"></p>
<blockquote>
<p>使用swap</p>
</blockquote>
<p>除 array外,交换两个容器内容的操作保证会很快——元素本身并未交换,swap只是交換了两个容器的内部数据结构。</p>
<p>元素不会被移动的事实意味着,除string外,指向容器的迭代器、引用和指针在swap操作之后都不会失效。它们仍指向swap操作之前所指向的那些元素。但是,在swap之后,这些元素已经属于不同的容器了。</p>
<p>与其他容器不同,swap两个 array会真正交换它们的元素。因此,交換两个 array所需的时间与 array中元素的数目成正比。</p>
<h3 id="容器大小操作"><a href="#容器大小操作" class="headerlink" title="容器大小操作"></a>容器大小操作</h3><p>除了一个例外,每个容器类型都有三个与大小相关的操作：</p>
<ul>
<li>成员函数size，返回容器中元素的数目; </li>
<li>empty当size为0时返回布尔值true,否则返回回false</li>
<li>max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。</li>
</ul>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符左右两边的运算对象必须是相同类型的容器,且必须保存相同类型的元素。</p>
<p>比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与string的关系运算类似:</p>
<ul>
<li>如果两个容器具有相同大小且所有元素都两两对应相等,则这两个容器相等;否则两个容器不等</li>
<li>如果两个容器大小不同,但较小容器中每个元素都等于较大容器中的对应元素,则则较小容器小于较大容器。</li>
<li>如果两个容器都不是另一个容器的前缀子序列,则它们的比较结果取決于第一个不相等的元素的比较结果。</li>
</ul>
<h2 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h2><h3 id="向顺序容器添加元素"><a href="#向顺序容器添加元素" class="headerlink" title="向顺序容器添加元素"></a>向顺序容器添加元素</h3><p>除 array外,所有标准库容器都提供灵活的内存管理。在运行时可以动态添加或刑除元素来改变容器大小。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518833554118.jpg" alt="enter description here"></p>
<p>在一个 vector或 string的尾部之外的任何位置,或是一个 deque的首尾之外的任何位置添加元素,都需要移动元素。而且,向一个 vector或 string添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存,并将元素从旧的空间移动到新的空间中。</p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>包括 array在内的每个顺序容器都有一个 front成员函数,而除 forward_list之外的所有顺序容器都有一个back成员函数。这两个操作分别返回首元素和尾元素的引用</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518833711199.jpg" alt="enter description here"></p>
<blockquote>
<p>下标操作和安全的随机访问</p>
</blockquote>
<p>提供快速随机访问的容器( string、 vector、 deque和 array)也都提供下标运算符。就像我们已经看到的那样,下标运算符接受一个下标参数,返回容器中该位置的元素的引用。<strong>给定下标必须“在范围内”</strong>(即,大于等于0,且小于容器的大小)。保证下标有效是程序员的责任,下标运算符并不检査下标是否在合法范围内。<strong>使用越界的下标是一种严重的程序设计错误</strong>,而且编译器并不检査这种错误。</p>
<p>如果我们希望确保下标是合法的,可以使用at成员函数。at成员函数类似下标运算,但如果下标越界,at会地出一个out of range异常:</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518834076074.jpg" alt="enter description here"></p>
<h3 id="特殊的forward-list操作"><a href="#特殊的forward-list操作" class="headerlink" title="特殊的forward_list操作"></a>特殊的forward_list操作</h3><p>在一个单向链表中,没有简单的方法来获取一个元素的前驱。出于这个原因,在一个 forward_list中添加或删除元素的操作是通过改变给定元素之后的元素来完成的</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518834143966.jpg" alt="enter description here"></p>
<h3 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h3><p>我们可以用rsize来增大或缩小容器・与往常一样, array不支持 resize。如果当前大小大于所要求的大小,容器后部的元素会被別除:如果当前大小小于新大小,会将新元素添加到容器后部:</p>
<h3 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h3><p>向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误,很可能引起与使用未初始化指针一样的问题</p>
<p>当你使用迭代器(或指向容器元素的引用或指针)时,最小化要求迭代器必须保持有效的程序片段是一个好的方法。</p>
<p>程序必须保证每个循环中都更新迭代器、引用或指针</p>
<blockquote>
<p>不要保存end返回的迭代器</p>
</blockquote>
<p>当我们添加删除 vector或 string的元素后,或在 deque中首元素之外任何位置添加删除元素后,原来end返回的迭代器总是会失效。因此,<strong>添加或删除元素的循环程序必须反复调用end,而不能在循环之前保存end返回的迭代器</strong>,一直当作容器末尾使用。通常C++标准库的实现中end()操作都很快,部分就是因为这个原因。</p>
<h2 id="vector对象是如何增长的"><a href="#vector对象是如何增长的" class="headerlink" title="vector对象是如何增长的"></a>vector对象是如何增长的</h2><p>为了支持快速随机访问，vector将元素连续存储——每个元素紧挨着前一个元素存储。</p>
<p>假定容器中元素是连续存储的,且容器的大小是可变的,考虑向 vector或string中添加元素会发生什么:如果没有空间容纳新元素,容器不可能简单地将它添加到内存中其他位置一一因为元素必须连续存储。容器必须分配新的内存空间来保存已有元素和新元素,将已有元素从旧位置移动到新空间中,然后添加新元素,释放旧存储空间。如如果我们每添加一个新元素, vector就执行一次这样的内存分配和释放操作,性能会慢到不可</p>
<p>为了避免这种代价,标准库实现者采用了可以减少容器空间重新分配次数的策略。当不得不获取新的内存空间时, vector和 string的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用,可用来保存更多的新元素。</p>
<p>vector 在每次重新分配内存的时候都要移动所有元素</p>
<blockquote>
<p>管理容量的成员函数</p>
</blockquote>
<p> capacity操作告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素。 reserve操作允许我们通知容器它应该准备保存多少个元素。</p>
<blockquote>
<p>capacity和size</p>
</blockquote>
<p>理解 capacity和size的区别非常重要。容器的size是指它已经保存的元素的数目;而 capacity则是在不分配新的内存空间的前提下它最多可以保存多少元素。</p>
<h2 id="额外的string操作"><a href="#额外的string操作" class="headerlink" title="额外的string操作"></a>额外的string操作</h2><h3 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861676844.jpg" alt="enter description here"></p>
<blockquote>
<p>substr操作</p>
</blockquote>
<p>substr操作返回一个str1ng,它是原始 string的一部分或全部的拷贝。可以传递给 substr一个可选的开始位置和计数值:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861736953.jpg" alt="enter description here"></p>
<h3 id="改变string的其他方法"><a href="#改变string的其他方法" class="headerlink" title="改变string的其他方法"></a>改变string的其他方法</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861803653.jpg" alt="enter description here"></p>
<h3 id="string搜索操作"><a href="#string搜索操作" class="headerlink" title="string搜索操作"></a>string搜索操作</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861836971.jpg" alt="enter description here"></p>
<h3 id="compare函数"><a href="#compare函数" class="headerlink" title="compare函数"></a>compare函数</h3><p>除了关系运算符外,标准准库str1ng类型还提供了一组compare函数,这些函数与C标准库的 strcmp函数很相似。类似 strcmp,据据s是等于、大于还是小于参数指定的字符串,s. compare返回回0、正数或负数。</p>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518861942715.jpg" alt="enter description here"></p>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>除了顺序容器外,标准库还定义了三个顺序容器适配器: stack、 queue和priority_queue。<strong>适配器</strong>( adaptor)是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上,<strong>一个适配器是一种机制,能使某种事物的行为看起来像另外一种事物一样</strong>。一个容器适配器接受一种已有的容器类型,使其行为看起来像一种不同的类型。</p>
<blockquote>
<p>定义一个适配器</p>
</blockquote>
<p>每个适配器都定义两个构造函数:默认构造函数创建一个空对象,接受一个容器的构造函数拷贝该容器来初始化适配器。</p>
<p>默认情况下, stack和 queue是基于 deque实现的,priority_queue是在 vector之上实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第三个类型参数,来重载默认容器类型。</p>
<p>对于一个给定的适配器,可以使用哪些容器是有限制的。所有适配器都要求容器具有添加和删除元素的能力。因此,适配器不能构造在aray之上。类似的,我们也不能用forward_list来构造适配器,因为所有适配器都要求容器具有添加、删除以及访间尾元素的能力。 stack只要求 push_back、 pop_back和back操作,因此可以使用除 array</p>
<blockquote>
<p>栈适配器<br><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518862439794.jpg" alt="enter description here"></p>
</blockquote>
<p>每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作。我们只可以使用适配器操作,而不能使用底层容器类型的操作。</p>
<blockquote>
<p>队列适配器</p>
</blockquote>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518862492187.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_17_1518862504010.jpg" alt="enter description here"></p>
<p>标准库queue使用一种先进先出（first-in，first-out，FIFO）的存储和访问策略</p>
<p>priority_queue 允许我们为队列中的元素建立优先级，新加入的元素会排在所有优先级比它低的已有元素之前。</p>
<hr>
<h1 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h1><p>标准库容器定义的操作集合惊人得小。标准库并未给每个容器添加大量功能,而是提供了一组算法,这些算法中的大多数都独立于任何特定的容器。这些算法是通用的( generic,或称泛型的):它们可用于不同类型的容器和不同类型的元素。</p>
<p>顺序容器只定义了很少的一些操作，我们可以想象用户可能还希望做其他很多有用的操作:查找特定元素、替換或別除二个特定值、重排元素顺序等。</p>
<p>标准库并未给每个容器都定义成员函数来实现这些操作,而是定义了一组<strong>泛型算法</strong>( generic algorithm):称它们为“算法”,是因为它们实现了一些经典算法的公共接接口,如排序和搜索;称它们是“泛型的”,是因为它们可以用于不同类型的元素和多种容器类型</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一般情况下,泛型算法并不直接操作容器,而是遍历由两个迭代器指定的一个元素范围来进行操作。</p>
<p><strong>迭代器令算法不依赖于容器，但是算法依赖于容器的操作类型</strong>。虽然迭代器的使用令算法不依赖于容器类型,但大多数算法都使用了一个(或多个)元素类型上的操作。</p>
<p>泛型算法本身不会执行容器的操作，它们只会运行于迭代器上，执行迭代器的操作。</p>
<h2 id="初始泛型算法"><a href="#初始泛型算法" class="headerlink" title="初始泛型算法"></a>初始泛型算法</h2><h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p>一些算法只会读取其输入范围内的元素,而从不改变元素。find就是这样一种算法</p>
<p>另一个只读算法是 accumulate,它定义在头文件 numeric i中。 accumulate函数接受三个参数,前两个指出了需要求和的元素的范围,第三个参数是和的初值。accumulate将第三个参数作为求和起点,这蕴含着一个编程假定:将元素类型加到和的类型上的操作必须是可行的。即,序列中元素的类型必须与第三个参数匹配,或者能够转换为第三个参数的类型。</p>
<p>另一个只读算法是equal，用于确定两个序列是否保存相同的值。</p>
<h3 id="写容器元素的算法"><a href="#写容器元素的算法" class="headerlink" title="写容器元素的算法"></a>写容器元素的算法</h3><p>一些算法将新值赋予序列中的元素。当我们使用这类算法时,必须注意<strong>确保序列原大小至少不小于我们要求算法写入的元素数目</strong>。记住,<strong>算法不会执行容器操作,因此它们身不可能改变容器的大小</strong>。</p>
<p>一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素,该序列从目的位置迭代器指向的元素开始。</p>
<blockquote>
<p>介绍back_inserter</p>
</blockquote>
<p>一种保证算法有足够元素空间来容纳输出数据的方法是使用<strong>插入迭代器</strong>( InsertIterator)。插入送代器是一种向容器中添加元素的迭代器。通常情况,当我们通过一个送代器向容器元素赋值时,值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时,一个与赋值号右側值相等的元素被添加到容器中。</p>
<p>back_inserter接受一个指向容器的引用,返回一个与该容器绑定的插入迭代器当我们通过此迭代器赋值时,赋值运算符会调用 push_back将一个具有给定值的元素添加到容器中</p>
<blockquote>
<p>拷贝算法</p>
</blockquote>
<p>拷贝(copy)算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器,前两个表示一个输入范围,第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。</p>
<h3 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h3><p>某些算法会重排容器中元素的顺序,一个明显的例子是sort。调用sort会重排输入序列中的元素,使之有序,它是利用元素类型的运算符来实现排序的</p>
<blockquote>
<p>清除重复单词</p>
</blockquote>
<p>我们就可以使用另一个称为unique的标准库算法来重排ⅴector,使得不重复的元素出现在ⅴector的开始部分。由于算法不能执行容器的操作,我们将使用 vector的 erase成员来完成真正的删除操作</p>
<h2 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h2><p>很多算法都会比较输入序列中的元素。默认情况下,这类算法使用元素类型的&lt;或=运算符完成比较。标准库还为这些算法定义了额外的版本,允许<strong>我们提供自己定义的操作来代替默认运算符</strong>。</p>
<h3 id="向算法传递参数"><a href="#向算法传递参数" class="headerlink" title="向算法传递参数"></a>向算法传递参数</h3><blockquote>
<p>谓词</p>
</blockquote>
<p>谓词是一个可调用的表达式,其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类:一元谓词( unary predicate,意味着它们只接受单一参数)和二元谓词binary predicate,,意味着它们有两个参数)。接受谓词参数的算法对输入序列中的元素调用谓词。因此,元素类型必须能转换为谓词的参数类型。接受一个二元谓词参数的sOrt版本用这个谓词代替&lt;来比较元素。</p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>根据算法接受一元谓词还是二元谓词,我们传递给算法的谓词必须严格接受一个或两个参数。但是,有时我们希望进行的操作需要更多参数,超出了算法对谓词的限制。</p>
<blockquote>
<p>介绍lambda</p>
</blockquote>
<p>我们可以向一个算法传递任何类别的<strong>可调用对象</strong>( callable object)。对于一个对象或一个表达式,如果可以对其使用调用运算符,则称它为可调用的。即,如果e是一个可调用的表达式,则我们可以编写代码e(args),其中args是个逗号分隔的一个或多个参数的列表</p>
<p>到目前为止,<strong>我们使用过的仅有的两种可调用对象是函数和函数指针</strong>。还有其他两种可调用对象:重载了函数调用运算符的类,,以及 lambda表达式( lambda expression)</p>
<p>一个 lambda表达达式表示一个可调用的代码单元。我们们可以将其理解为一个未命名的内联函数。与任何函数类似似,一个 lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同, lambda可能定义在函数内部。一个 lambda表达式具有如下形式：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_18_1518953656030.jpg" alt="enter description here"></p>
<blockquote>
<p>向lambda传递参数</p>
</blockquote>
<p>与一个普通函数调用类似,调用一个 lambda时给定的实参被用来初始化 lambda的形参。通常,实参和形参的类型必须匹配。但与普通函数不同, <strong>lambda不能有默认参数</strong>。因此,一个 lambda调用的实参数目永远与形参数目相等。</p>
<blockquote>
<p>使用捕获列表</p>
</blockquote>
<p>虽然一个 lambda可以出现在一个函数中,使用其局部变量,但它只能使用那些明确指明的变量。<strong>一个 lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量</strong>。捕获列表指引 lambda在其内部包含访问局部变量所需的信息。</p>
<h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>当定义一个 lambda时,编译器生成一个与 lambda对应的新的(未命名的)类类型。目前,可以这样理解,当向个函数传递一个 lambda时,同时定义了一个新类型和该类型的一个对象:传递的参数就是此编译器生成的类类型的未命名对象。类似的,当使用auto定义一个用 lambda初始化的变量时,定义了一个从 lambda生成的类型的对象。</p>
<p>默认情況下,从 lambda生成的类都包含一个对应该 lambda 所捕获的変量的数据成员。类似任何普通类的数据成员, lambda的数据成员也在 lambda对象创建时被初始化。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_18_1518954256455.jpg" alt="enter description here"></p>
<blockquote>
<p>值捕获</p>
</blockquote>
<p>类似参数传递，变量的捕获方式也可以是值或引用。与传值参数类似,采用值捕获的前提是变量可以拷贝。与参数不同,被捕获的变量的值是在 lambda创建时拷贝,而不是调用时拷贝</p>
<blockquote>
<p>引用捕获</p>
</blockquote>
<p>一个以引用方式捕获的变量与其他任何类型的引用的行为类似。当我们在 lambda 函数体内使用此变量时,实际上使用用的是引用所绑定的对象。</p>
<blockquote>
<p>隐式捕获</p>
</blockquote>
<p>除了显式列出我们希望使用的来自所在函数的变量之外,还可以让编译器根据 lambda体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表,应在捕获列表中写一个&amp;或=。&amp;告诉编译器采用捕获引用方式,=则表示采用值捕获方式。</p>
<p>当我们混合使用隐式捕获和显式捕获时,捕获列表中的第一个元素必须是一个&amp;或=。此符号指定了默认捕获方式为引用或值。</p>
<p>当混合使用隐式捕获和显式捕获时,显式捕获的变量必须使用与隐式捕获不同的方式。即,如果隐式捕获是引用方式(使用了&amp;),则则显式捕获命名变量必须采用值方式,因此不能在其名字前使用&amp;。类似的,如如果隐式捕获采用的是值方式(使用了=),则显式捕获命名变量必须采用引用方式,即,在名字前使用&amp;。</p>
<blockquote>
<p>可变lambda</p>
</blockquote>
<p>默认情况下,对于一个值被拷贝的变量, lambda不会改变其值。如果我们希望能改变个被捕获的变量的值,就必须在参数列表首加上关键键字 mutale。</p>
<blockquote>
<p>指定的lambda返回类型</p>
</blockquote>
<p>默认情况下,如果一个 lambda体包含 return之外的任何语句,则编译器假定此 lambda返回void。与其他返回void的函数类似,被推断返回void的 lambda不能返回值。</p>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>对于那种只在一两个地方使用的简单操作, lambda表达式是最有用的。如果我们需要在很多地方使用相同的操作,通常应该定义一个函数,而不是多次编写相同的 lambda表达式。类似的,如果一个操作需要很多语句才能完成,通通常使用函数更好。</p>
<p>如果lambda的捕获列表为空，通常可以用函数来替代它。</p>
<p>但是,对于捕获局部变量的 lambda,用函数来替换它就不是那么容易了。</p>
<blockquote>
<p>标准bind函数</p>
</blockquote>
<p>我们可以解决向 check_size传递递一个长度参数的问题,方法是使用一个新的名为bind的标准库函数,它定义在头文件 functiona1中。可以将bind函数看作一个通用的函数适配记器,它接受一个可调用对象,生成一个新的可调用对象来“适应”原对象的参数列表</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_18_1518954580235.jpg" alt="enter description here"></p>
<h2 id="再探迭代器"><a href="#再探迭代器" class="headerlink" title="再探迭代器"></a>再探迭代器</h2><p>除了为每个容器定义的迭代器之外,标准库还定义了额外几种迭代器。这些迭代器包括以下几种</p>
<ul>
<li>插入迭代器( Insert iterator):这些迭代器被绑定到一个容器上,可用来向容器插入元素</li>
<li>流迭代器( stream Iterator):这些迭代器被绑定到输入或输出流上,可用来遍历所关联的IO流。</li>
<li>反向迭代器( reverse Iterator):这些迭代器向后而不是向前移动。除了forward1ist之外的标准库容器都有反向迭代器。</li>
<li>移动迭代器( move iterator):这些专用的迭代器不是拷贝其中的元素,而是移动它们。我们将在13.6.2节(第480页)介绍移动迭代器</li>
</ul>
<h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><p>插入器是一种迭代器适配器,它接受一个容器,生成一个迭代器,能实现向给定容器添加元素。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519893284405.jpg" alt="enter description here"></p>
<p>插入器有三种类型，其差异在于元素插入的位置：</p>
<ul>
<li>back_inserter创建一个使用 push_back的迭代器</li>
<li>front_inserter创建一个使用 push_front的迭代器</li>
<li>inserter创建一个使用 insert的迭代器。此函数接受第二个参数,这个参数必须是一个指向给定容器的迭代器。<strong>元素将被插入到给定迭代器所表示的元素之前</strong>。</li>
</ul>
<h3 id="iostream-迭代器"><a href="#iostream-迭代器" class="headerlink" title="iostream 迭代器"></a>iostream 迭代器</h3><p>虽然 iostream类型不是容器,但标准库定义了可以用于这些IO类型对象的迭代器。istream iterator读取输入流,ostream iterator向一个输出流写数据。<strong>这些迭代器将它们对应的流当作一个特定类型的元素序列来处理</strong>。通过使用流迭代器,我们可以用泛型算法从流对象读取数据以及向其写入数据。</p>
<blockquote>
<p>istream_iterator 允许使用懒惰求值</p>
</blockquote>
<p>当我们将一个 istream_iterator绑定到一个流时,标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据,直到我们使用迭代器时才真正读取。标准库中的实现所保证的是,<strong>在我们第一次解引用迭代器之前,从流中读取数据的操作已经完成了</strong>。对于大多数程序来说,立即读取还是推迟读取没什么差别。</p>
<h3 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h3><p>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器,递增(以及递减)操作的含义会颠倒过来。递增一个反向迭代器(++it)会移动到前一个元素;递减一个迭代器(–it)会移动到下一个元素。</p>
<p>除了 forwardlist之外,其他容器都支持反向迭代器。</p>
<h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><p>任何算法的最基本的特性是它要求其迭代器提供哪些操作。算法所要求的迭代器操作可以分为5个迭代器类别( Iterator category)。每个算法都会对它的每个迭代器参数指明须提供哪类迭代器。</p>
<p>算法还共享了一组参数传递规范和一组命名规范</p>
<h3 id="5类迭代器"><a href="#5类迭代器" class="headerlink" title="5类迭代器"></a>5类迭代器</h3><p>类似容器,迭代器也定义了一组公共操作。一些操作所有迭代器都支持,另外一些只有特定类别的迭代器才支持。例如, ostream_iterator只支持递增、解引用和赋值。vector、 string和 deque的迭代器除了这些操作外,还支持递减、关系和算术运算。</p>
<p>C++标准指明了泛型和数值算法的每个迭代器参数的最小类别。例如,find算法在一个序列上进行一遍扫描,对元素进行只读操作,因此至少需要输入迭代器。 </p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519894770101.jpg" alt="enter description here"></p>
<h3 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h3><p>在任何其他算法分类之上,还有一组参数规范。理解这些参数规范对学习新算法很有帮助—通过理解参数的含义,你可以将注意力集中在算法所做的操作上。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519894916626.jpg" alt="enter description here"></p>
<h3 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h3><p>除了参数规范,算法还遵循一套命名和重载规范。这些规范处理诸如:如何提供一个操作代替默认的&lt;或==运算符以及算法是将输出数据写入输入序列还是一个分离的目的位置等问题。</p>
<h2 id="特定容器算法"><a href="#特定容器算法" class="headerlink" title="特定容器算法"></a>特定容器算法</h2><p>与其他容器不同,链表类型list和forward_list定义了几个成员函数形式的算法。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519895023511.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_1_1519895035177.jpg" alt="enter description here"></p>
<hr>
<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>关联容器和顺序容器有着根本的不同:关联容器中的元素是按关键字来保存和访问的。与之相对,顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p>
<p>关联容器支持高效的关键字查找和访问。两个主要的<strong>关联容器</strong>( associative container)类型是map和set。map中的元素是一些关键字-值( key-value)对:关键字起到索引的作用,值则表示与索引相关联的数据。set中每个元素只包含一个关键字;set支持高效的关键字查询操作——检查一个给定关键字是否在set中。</p>
<p>标准库提供8个关联容器,。这8个容器间的不同体现在三个维度上:每个容器<br>(1)<strong>或者是一个set,或者是一个map</strong>;<br>(2)<strong>或者要求不重复的关键字,或者允许重复关键字</strong>;<br>(3)<strong>按顺序保存元素,或无序保存</strong></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519989186109.jpg" alt="enter description here"></p>
<h2 id="使用关联容器"><a href="#使用关联容器" class="headerlink" title="使用关联容器"></a>使用关联容器</h2><p>map是关键字值对的集合。例如,可以将一个人的名字作为关键字,将其电话号码作为值。我们称这样的数据结构为“将名字映射到电话号码”。map类型通常被称为关联数组( associative array)。关联数组与“正常”数组类似,不同之处在于其下标不必是整数。</p>
<p>与之相对,set就是关键字的简单集合。当只是想知道一个值是否存在时,set是最有用的。</p>
<h2 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h2><p>关联容器不支持顺序容器的位置相关的操作,例如 push_front或 push_back。原因是<strong>关联容器中元素是根据关键字存储的,这些操作对关联容器没有意义</strong>。而且,关联容器也<strong>不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作</strong>。</p>
<h3 id="定义关联容器"><a href="#定义关联容器" class="headerlink" title="定义关联容器"></a>定义关联容器</h3><p>当定义一个map时,必须既指明关键字类型又指明值类型;而定义一个set时,只需指明关键字类型,因为set中没有值。</p>
<p>map的初始化：<br><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519990637584.jpg" alt="enter description here"></p>
<h3 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h3><p>对于有序容器—map、 multimap、set以及 multiset,<strong>关键字类型必须定义元素比较的方法</strong>。默认情况下,标准库使用关键字类型的&lt;运算符来比较两个关键字。</p>
<blockquote>
<p>有序容器的关键字类型</p>
</blockquote>
<p>可以向一个算法提供我们自己定义的比较操作,与之类似也可以提供自己定义的操作来代替关键字上的&lt;运算符。所提供的操作必须在关键字类型上定义一个<strong>严格弱序</strong>( strict weak ordering)。</p>
<blockquote>
<p>使用关键字类型的比较函数</p>
</blockquote>
<p>用来组织一个容器中元素的操作的类型也是该容器类型的一部分。<strong>为了指定使用自定义的操作,必须在定义关联容器类型时提供此操作的类型</strong>。如前所述,用尖括号指出要定义哪种类型的容器,自定义的操作类型必须在尖括号中紧跟着元素类型给出</p>
<p>此处,我们使用 decltype来指出自定义操作的类型。记住,当用 decltype来获得一个函数指针类型时,必须加上一个*来指出我们要使用一个给定函数类型的指针</p>
<h3 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h3><p>在介绍关联容器操作之前,我们需要了解名为pair的标准库类型,它定义在头文件utility中。</p>
<p>一个pair保存两个数据成员。类似容器,pair是一个用来生成特定类型的模板当创建一个pair时,我们必须提供两个类型名,pa1r的数据成员将具有对应的类型。两个类型不要求一样:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519991091913.jpg" alt="enter description here"></p>
<p>与其他标准库类型不同,pair的数据成员是public的。两个成员分别命名为 first和 second。我们用普通的成员访问符号来访问它们</p>
<h2 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a>关联容器操作</h2><p>关联容器还定义了一些表示容器关键字和值的类型</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992027517.jpg" alt="enter description here"></p>
<h3 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h3><p>当解引用一个关联容器迭代器时,我们会得到一个类型为容器的value_type的值的引用。对map而言,value_type是一个pair类型,其 first成员保存 const的关键字, second成员保存值</p>
<blockquote>
<p>set 的迭代器是const的</p>
</blockquote>
<p>虽然set类型同时定义了 iterator和 const_iterator类型,但两种类型都只允许只读访问set中的元素。与不能改变一个map元素的关键字一样,一个set中的关键字也是 const的。可以用一个set迭代器来读取元素的值,但不能修改:</p>
<blockquote>
<p>遍历关联容器</p>
</blockquote>
<p>map和set类型都支持 begin和end操作。与往常一样我们可以用这些函数获取迭代器,然后用迭代器来遍历容器。</p>
<blockquote>
<p>关联容器和算法</p>
</blockquote>
<p>我们通常不对关联容器使用泛型算法。关键字是 const这一特性意味着<strong>不能将关联容器传递给修改或重排容器元素的算法</strong>,因为这类算法需要向元素写入值,而set类型中的元素是cnst的,map中的元素是pair,其第一个成员是 const的。</p>
<p>关联容器可用于只读取元素的算法。</p>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>关联容器的 insert成员向容器中添加一个元素或一个元素范围。由于map和set(以及对应的无序类型)包含不重复的关键字,因此插入一个已存在的元素对容器没有任何影响</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992536522.jpg" alt="enter description here"></p>
<blockquote>
<p>向map添加元素</p>
</blockquote>
<p>对一个map进行 insert操作时,必须记住元素类型是pair。通常,对于想要插入的数据,并没有一个现成的pair对象。可以在 insert的参数列表中创建一个pair</p>
<blockquote>
<p>检测insert的返回值</p>
</blockquote>
<p>insert(或emplace)返回的值依赖于容器类型和参数。对于不包含重复关键字的容器,添加单一元素的 insert和 emplace版本返回一个pair,告诉我们插入操作是否成功。pair的 first成员是一个迭代器,指向具有给定关键字的元素; second成员是一个bool值,指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中</p>
<h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992521248.jpg" alt="enter description here"></p>
<h3 id="map的下标操作"><a href="#map的下标操作" class="headerlink" title="map的下标操作"></a>map的下标操作</h3><p>map和 unordered_map容器提供了下标运算符和一个对应的at函数。set类型不支持下标,因为set中没有与关键字相关联的“值”。元素本身就是关键字,因此“获取与一个关键字相关联的值”的操作就没有意义了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992604789.jpg" alt="enter description here"></p>
<h3 id="访问元素-1"><a href="#访问元素-1" class="headerlink" title="访问元素"></a>访问元素</h3><p>关联容器提供多种查找一个指定元素的方法</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_2_1519992681370.jpg" alt="enter description here"></p>
<blockquote>
<p>对map使用find代替下标操作</p>
</blockquote>
<p>对map和 unordered map类型,下标运算符提供了最简单的提取元素的方法。但是如我们所见,使用下标操作有一个严重的副作用:如果关键字还未在map中,下标操作会插入一个具有给定关键字的元素。这种行为是否正确完全依赖于我们的预期是什么。</p>
<h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p>新标准定义了4个<strong>无序关联容器</strong>( unordered associative container)。这些容器不是使用比较运算符来组织元素,而是使用一个哈希函数( hash function)和关键字类型==运算符。在关键字类型的元素没有明显的序关系的情况下,无序容器是非常有用的。</p>
<blockquote>
<p>使用无序容器</p>
</blockquote>
<p>除了哈希管理操作之外,无序容器还提供了与有序容器相同的操作(find、 insert）</p>
<blockquote>
<p>管理桶</p>
</blockquote>
<p>无序容器在存储上组织为一组桶,每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素,容器首先计算元素的哈希值,它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字,所有具有相同关键字的元素也都会在同一个桶中。因此,无序容器的性能依赖于哈希函数的质量和桶的数量和大小。</p>
<hr>
<h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><p>动态对象的正确释放被证明是编程中极其容易出错的地方。为了更安全地使用动态对象,标准库定义了两个智能指针类型来管理动态分配的对象。<strong>当一个对象应该被释放时,指向它的智能指针可以确保自动地释放它</strong>。</p>
<p>除了静态内存和栈内存,每个程序还拥有一个内存池。这部分内存被称作<strong>自由空间</strong>( free store)或<strong>堆</strong>(heap)。程序用堆来存储动态分配( dynamically allocate)的对象——即那些在程序运行时分配的对象。</p>
<h2 id="动态内存和智能指针"><a href="#动态内存和智能指针" class="headerlink" title="动态内存和智能指针"></a>动态内存和智能指针</h2><p>在++中,动态内存的管理是通过一对运算符来完成的:new,在动态内存中为对象分配空间并返回一个指向该对象的指针,我们可以选择对对象进行初始化; delete,接受一个动态对象的指针,销毁该对象,并释放与之关联的内存</p>
<p>为了更容易(同时也更安全)地使用动态内存,新的标准库提供了两种智能指针( smartpointer.)类型来管理动态对象。智能指针的行为类似常规指针,重要的区别是它<strong>负责自动释放所指向的对象</strong>。新标准库提供的这两种智能指针的区别在于管理底层指针的方式shared_ptr允许多个指针指向同一个对于象; unique_ptr则“独占”所指向的对象。标准库还定义了一个名为 weak_ptr的伴随类,它是一种弱引用,指向 shared_ptr所管理的对象。这三种类型都定义在 memory头文件中。</p>
<h3 id="share-ptr类"><a href="#share-ptr类" class="headerlink" title="share_ptr类"></a>share_ptr类</h3><p>类似 vector,智能指针也是模板。因此,当我们创建一个智能指针十时,必须提供额外的信息—指针可以指向的类型。智能指针的使用方式与普通指针类似。解引用一个智能指针返回它指向的对象。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520129716802.jpg" alt="enter description here"></p>
<blockquote>
<p>make_shared 函数</p>
</blockquote>
<p>最安全的分配和使用动态内存的方法是调用一个名为 make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它,返回指向此对象的 shared_ptr。</p>
<p>当要用 make_shared时,必须指定想要创建的对象的类型。定义方式与模板类相同在函数名之后跟一个尖括号,在其中给出类型</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520129795731.jpg" alt="enter description here"></p>
<blockquote>
<p>shared_ptr 的拷贝和赋值</p>
</blockquote>
<p>我们可以认为每个 shared_ptr都有一个关联的计数器,通常称其为<strong>引用计数</strong>( reference count)。无论何时我们拷贝一个 shared_ptr,计数器都会递增。一旦一个 shared_ptr的计数器变为0,它就会自动释放自己所管理的对象</p>
<blockquote>
<p>shared_ptr 自动销毁所管理的对象</p>
</blockquote>
<p>当指向一个对象的最后一个 shared_ptr被销毁时, shared_ptr类会自动销毁此对象。它是通过另一个特殊的成员函数——析构函数( destructor)完成销毁工作的。</p>
<blockquote>
<p>使用动态生存期的资源的类</p>
</blockquote>
<p>程序使用动态内存出于以下三种原因之一：</p>
<ul>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个资源之间共享数据</li>
</ul>
<h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><p>C++语言定义了两个运算符来分配和释放动态内存。运算符new分配内存, delete释放new分配的内存。</p>
<blockquote>
<p>使用new动态分配和初始化对象</p>
</blockquote>
<p>在自由空间分配的内存是无名的,因此new无法为其分配的对象命名,而是返回一个指向该对象的指针。</p>
<p>默认情况下,动态分配的对象是默认初始化的,这意味着内置类型或组合类型的对象的值将是未定义的,而类类型对象将用默认构造函数进行初始化</p>
<blockquote>
<p>内存耗尽</p>
</blockquote>
<p>一旦一个程序用光了它所有可用的内在,new表达式就会失败。默认情况下,加果new不能分配所要求的内存空间,它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常:</p>
<p>动态内存管理的时候非常容易出错：</p>
<ol>
<li>忘记delete内存</li>
<li>使用已经释放掉的对象</li>
<li>同一块内存释放两次</li>
</ol>
<blockquote>
<p>delete 之后重置指针</p>
</blockquote>
<p>当我们 delete一个指针后,指针值就变为无效了。虽然指针已经无效,但在很多机器上指针仍然保存着(已经释放了的)动态内存的地址。在 delete之后,指针就变成了人们所说的<strong>空悬指针</strong>( dangling pointer),即<strong>指向一块曾经保存数据对象但现在已经无效的内存的指针</strong>。</p>
<p>未初始化指针的所有缺点空悬指针也都有。有一种方法可以避免空悬指针的问题:在指针即将要离开其作用域之前释放掉它所关联的内存。</p>
<h3 id="share-ptr和new结合使用"><a href="#share-ptr和new结合使用" class="headerlink" title="share_ptr和new结合使用"></a>share_ptr和new结合使用</h3><p>如果我们不初始化一个智能指针，那么这个指针就会被初始化为一个空指针。</p>
<p>接受指针参数的智能指针构造函数是explicit的（禁止隐式转换）。因此,我们不能将一个内置指针隐式转换为一个智能指针,必须使用直接初始化形式</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520130371151.jpg" alt="enter description here"></p>
<h3 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h3><p>如果使用智能指针,即使程序块过早结束,智能指针类也能确保在内存不再需要时将其释放</p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>个 unique_ptr“拥有”它所指向的对象。与 shared_ptr不同,某个时刻只能有一个 unique_ptr指向一个给定对象。当 unique_ptr被销毁时,它所指向的对象也被销毁。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520130502646.jpg" alt="enter description here"></p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr是一种不控制所指向对象生存期的智能指针,它指向由一个shared_ptr管理的对象。将一个 weak_ptr绑定到一个 shared_ptr不会改变shared_ptr的引用计数。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520130696044.jpg" alt="enter description here"></p>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>new和 delete运算符一次分配释放一个对象,但某些应用需要一次为很多对象分配内存的功能。</p>
<p>为了支持这种需求,C++语言和标准库提供了两种一次分配一个对象数组的方法。C+语言定义了另一种new表达式语法,可以分配并初始化一个对象数组。标准库中包含个名为allocator的类,允许我们们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力</p>
<h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h3><p>为了让new分配一个对象数组,我们要在类型名之后跟一对方括号,在其中指明要分配的对象的数目。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span> [get_size()]; <span class="comment">// pia指向第一个int</span></div></pre></td></tr></table></figure>
<p>虽然我们]通常称newT[]分配的内存为“动态数组”,但这种叫法某种程度上有些误导。当用new分配一个数组时,我们并未得到一个数组类型的对象,而是得到一个数组元素类型的指针。不能对动态数组调用begin和end。</p>
<blockquote>
<p>释放动态数组</p>
</blockquote>
<p>为了释放动态数组,我们使用一种特殊形式的 delete—在指针前加上一个空方括号对:</p>
<blockquote>
<p>智能指针和动态数组</p>
</blockquote>
<p>标准库提供了一个可以管理new分配的数组的 unique_ptr版本。为了用一个unique_ptr管理动态数组,我们必须在对象类型后面跟一对空方括号:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_3_4_1520132049585.jpg" alt="enter description here"></p>
<h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>new有一些灵活性上的局限,其中一方面表现在它将内存分配和对象构造组合在了起。类似的, delete将对象析构和内存释放组合在了一起。我们分配单个对象时,通常希望将内存分配和对象初始化组合在一起。因为在这种情况下,我们几乎肯定知道对象应有什么值。</p>
<p>标准库allocator类定义在头文件 memory中,它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法,它分配的内存是原始的、未构造的。allocator是一个模板。</p>
<blockquote>
<p>allocator 分配未构造的内存</p>
</blockquote>
<p>allocator分配的内存是未构造的( unconstructed)。我们按需要在此内存中构造对象。在新标准库中, construct成员函数接受一个指针和零个或多个额外参数,在给定位置构造一个元素。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》笔记 C++基础部分&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C/C++" scheme="https://www.liuin.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker部署Hexo博客</title>
    <link href="https://www.liuin.cn/2018/03/02/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>https://www.liuin.cn/2018/03/02/使用Docker部署Hexo博客/</id>
    <published>2018-03-02T09:39:37.000Z</published>
    <updated>2018-03-02T09:47:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文展示使用Docker部署Hexo博客（当然也可以是其他的服务）在服务器上的一种方案，主要用到是webhook来触发git pull操作。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之前部署Hexo博客的时候好像配置蛮久的，想着能不能把这些东西都放进Docker里面，以后换服务器以后部署也方面，于是便有了这波操作。</p>
<p>这里使用的是<a href="https://github.com/adnanh/webhook" target="_blank" rel="external">webhook</a>这个轮子来实现持续集成的。</p>
<p>工作示意图：<br>本地编辑—-git push—-&gt;Github—-webhook—-&gt;server—-get pull—-&gt;内容更新</p>
<p>使用到两个Docker：</p>
<ol>
<li><code>webhook</code>:  当push新的commit到GitHub（或其他平台）时解析GitHub发过来的webhook执行脚本更新网站内容</li>
<li><code>nginx</code>: Web服务器，展示网站内容</li>
</ol>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx容器的配置比较简单,只需要修改<code>nginx.conf</code>配置，监听80端口就行了。（如果需要需要https，则需要配置要证书以及配置监听443端口）。</p>
<p>这里贴出我的<code>docker-compose.yml</code>文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">version: &apos;3&apos;</div><div class="line">services:</div><div class="line">    web:</div><div class="line">        image: nginx</div><div class="line">        volumes:</div><div class="line">            - ./nginx.conf:/etc/nginx/nginx.conf</div><div class="line">            - ./sites-enabled:/etc/nginx/sites-enabled</div><div class="line">            - /path-to-your-content:/var/www</div><div class="line">            - ./ssl:/ssl</div><div class="line">        ports:</div><div class="line">            - &quot;80:80&quot;</div><div class="line">            - &quot;443:443&quot;</div></pre></td></tr></table></figure></p>
<p>ssl文件夹中的是证书，<code>path-to-your-content</code>是你静态页面的路径。</p>
<h2 id="Webhook"><a href="#Webhook" class="headerlink" title="Webhook"></a>Webhook</h2><p>Webhook任务是解析发过来的请求，然后执行脚本来从远程仓库中拉取更新。</p>
<p>首先是构建镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">FROM golang</div><div class="line">MAINTAINER sixzeroo &lt;sixzeroo60@gmail.com&gt;</div><div class="line"></div><div class="line">RUN mkdir -p /code/webhook \</div><div class="line">    &amp;&amp; touch /code/webhook/hook.json \</div><div class="line">    &amp;&amp; go get github.com/adnanh/webhook</div><div class="line"></div><div class="line">WORKDIR /code/webhook</div><div class="line"></div><div class="line">ENTRYPOINT /go/bin/webhook -hooks /code/webhook/hooks.json -verbose</div></pre></td></tr></table></figure></p>
<p>成品：<a href="https://hub.docker.com/r/sixzeroo/webhook/" target="_blank" rel="external">sixzeroo/webhook</a></p>
<p>之后就可以使用webhook来创建钩子任务了，其中配置文件在<code>hooks.json</code>中：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  &#123;</div><div class="line">    <span class="attr">"id"</span>: <span class="string">"your-id"</span>,</div><div class="line">    <span class="attr">"execute-command"</span>: <span class="string">"/code/webhook/work.sh"</span>,</div><div class="line">    <span class="attr">"command-working-directory"</span>: <span class="string">"/code/webhook"</span></div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>执行的脚本就是从GitHub中拉取更新而已，<code>work.sh</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#! /bin/sh</div><div class="line"></div><div class="line">cd /var/www &amp;&amp; git pull</div><div class="line"></div><div class="line">curtime=`date +&quot;%Y%m%d%H%M%S&quot;`</div><div class="line"></div><div class="line">if [ $? -eq 0 ];then</div><div class="line">    echo &quot;$curtime pull success!&quot; &gt;&gt; /code/webhook/git.log</div><div class="line">else</div><div class="line">    echo &quot;$curtime pull fail!&quot; &gt;&gt; /code/webhook/git.log</div><div class="line">fi</div></pre></td></tr></table></figure></p>
<p>最后配置整个服务，<code>docker-compose.yml</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">version: &quot;3&quot;</div><div class="line">services:</div><div class="line"></div><div class="line">    webhook:</div><div class="line">        image: sixzeroo/webhook</div><div class="line">        volumes:</div><div class="line">         - ./:/code/webhook</div><div class="line">         - /path-to-your-content:/var/www</div><div class="line">         - /key-path:/root/.ssh</div><div class="line">        ports:</div><div class="line">         - &quot;9000:9000&quot;</div></pre></td></tr></table></figure></p>
<p>其中<code>key-path</code>是你ssh文件夹路径</p>
<p>最后启动两个服务就可以工作了，设置GitHub当有push的时候发送<code>http://your-host:9000/hooks/your-id</code>这样的webhook就行了。</p>
<p>这里不把两个容器放到一个服务里面的原因是Nginx容器之后会有新的服务部署，里面会做一些修改。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文展示使用Docker部署Hexo博客（当然也可以是其他的服务）在服务器上的一种方案，主要用到是webhook来触发git pull操作。&lt;/p&gt;
    
    </summary>
    
      <category term="开发随笔" scheme="https://www.liuin.cn/categories/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Docker" scheme="https://www.liuin.cn/tags/Docker/"/>
    
      <category term="Hexo" scheme="https://www.liuin.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Docker Swarm 简介</title>
    <link href="https://www.liuin.cn/2018/02/28/Docker-Swarm-%E7%AE%80%E4%BB%8B/"/>
    <id>https://www.liuin.cn/2018/02/28/Docker-Swarm-简介/</id>
    <published>2018-02-28T07:36:04.000Z</published>
    <updated>2018-02-28T07:37:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>Docker Swarm 为Docker 提供容器集群服务，是 Docker 官 方对容器云生态进行支持的核心方案。</p>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Swarm 是使用 SwarmKit 构建的 Docker 引擎内置（原生）的集群管理和编排工具。 Swarm 集群之前需要了解以下几个概念。</p>
<h3 id="什么是swarm"><a href="#什么是swarm" class="headerlink" title="什么是swarm"></a>什么是swarm</h3><p>嵌入在Docker Engine中的集群管理和编排功能是通过swarmkit构建的。 Swarmkit是一个独立的项目，它实现了Docker的编排层，并直接在Docker中使用。</p>
<p>一个群由多个Docker主机组成，这些主机以群模式运行并充当管理者（管理成员资格和委派）和工作者（运行群集服务）。 给定的Docker主机可以是管理员，工作者或执行这两种角色。 当您创建服务时，您可以定义其理想状态（副本数量，可用的网络和存储资源，将服务暴露给外部世界等等）。 Docker的工作是维持这个理想的状态。 例如，如果工作者节点变得不可用，Docker会在其他节点上调度该节点的任务。 任务是一个正在运行的容器，它是swarm服务的一部分，由swarm管理器管理，而不是独立的容器。</p>
<p>群集服务相对于独立容器的主要优势之一是可以修改服务的配置，其中包括连接的网络和卷，而无需手动重新启动服务。 Docker将更新配置，停止使用过时配置的服务任务，并创建与所需配置相匹配的新服务。</p>
<p>当Docker以群集模式运行时，您仍然可以在参与群集的任何Docker主机以及群集服务上运行独立容器。 独立容器和群集服务之间的一个主要区别是，只有群集管理员可以管理群集，而独立容器可以在任何守护进程上启动。 Docker守护进程可以作为管理者，工作者或两者参与群体。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>与Docker Engine集成的集群管理</li>
<li>分散设计：Docker Engine在部署时不需要处理节点角色之间的差异，而是在运行时处理这些特殊的东西</li>
<li>声明式服务模式：Docker Engine使用声明性方法来让您在应用程序堆栈中定义各种服务的所需状态。</li>
<li>伸缩服务</li>
<li>理想状态调整</li>
<li>多主机联网</li>
<li>服务发现</li>
</ul>
<h3 id="节点（Nodes）"><a href="#节点（Nodes）" class="headerlink" title="节点（Nodes）"></a>节点（Nodes）</h3><p>节点是参与群体的Docker引擎的一个实例。 您也可以将其视为Docker节点。 您可以在单台物理计算机或云服务器上运行一个或多个节点，但生产群部署通常包括分布在多台物理机和云计算机上的Docker节点。</p>
<p>节点分为管理( manager)节点和工作( wor ker)节点。</p>
<p>管理节点用于 Swarm集群的管理, <code>docker swarm</code>命令基本只能在管理节点执行(节点退出集群命令 docker swarm leave可以在工作节点执行)。一个 Swarm集群可以有多个管理节点,但只有一个管理节点可以成为 <code>leader</code> ,<code>leader</code>通过<code>raft</code>协议实现。</p>
<p>工作节点是任务执行节点,管理节点将服务( servlce)下发至工作节点执行。管理节点默认也作为工作节点。你也可以通过配置让服务只运行在管理节点</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_28_1519799540229.jpg" alt="enter description here"></p>
<h3 id="服务（Services）和任务（Tasks）"><a href="#服务（Services）和任务（Tasks）" class="headerlink" title="服务（Services）和任务（Tasks）"></a>服务（Services）和任务（Tasks）</h3><p>服务（Services）是要在管理器或工作节点上执行的任务的定义。它是群体系统的中心结构，也是群体与用户互动的主要根源。</p>
<p>任务（Task）包含一个Docker容器和在容器内运行的命令。它是swarm的原子调度单位。</p>
<p>服务有两种模式：</p>
<ul>
<li><code>replicated services</code> 按照一定规则在各个工作节点上运行指定个数的任务</li>
<li><code>global services</code>每个工作节点上运行一个任务</li>
</ul>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_28_1519799982888.jpg" alt="enter description here"></p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="初始化-swarm-init"><a href="#初始化-swarm-init" class="headerlink" title="初始化 (swarm init)"></a>初始化 (swarm init)</h3><p>使用<code>docker swarm init</code>来在本机初始化一个swarm集群</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ docker swarm init --advertise-addr 192.168.99.100</div><div class="line">Swarm initialized: current node (dxn1zf6l61qsb1josjja83ngz) is now a manager.</div><div class="line"></div><div class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</div><div class="line"></div><div class="line">    docker swarm join \</div><div class="line">    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \</div><div class="line">    192.168.99.100:2377</div><div class="line"></div><div class="line">To add a manager to this swarm, run <span class="string">'docker swarm join-token manager'</span> and follow the instructions.</div></pre></td></tr></table></figure>
<p>如果你的 Docker 主机有多个网卡，拥有多个 IP，必须使用 <code>--advertise-addr</code>指定 IP。</p>
<p>执行 docker swarm init 命令的节点自动成为管理节点。</p>
<h3 id="添加节点-swarm-join"><a href="#添加节点-swarm-join" class="headerlink" title="添加节点 (swarm join)"></a>添加节点 (swarm join)</h3><p>向集群中添加一个工作节点/管理节点</p>
<p>格式： <code>docker swarm join [OPTIONS] HOST:PORT</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker@worker1:~$ docker swarm join \</div><div class="line">    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \</div><div class="line">    192.168.99.100:2377</div></pre></td></tr></table></figure>
<h3 id="查看节点-node-ls"><a href="#查看节点-node-ls" class="headerlink" title="查看节点 (node ls)"></a>查看节点 (node ls)</h3><p>使用 <code>docker node ls</code> 查看集群</p>
<h3 id="新建服务-service-create"><a href="#新建服务-service-create" class="headerlink" title="新建服务 (service create)"></a>新建服务 (service create)</h3><p>命令格式：<code>docker service create [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker service create --replicas 3 -p 80:80 --name nginx nginx:1.13.7-alpine</div></pre></td></tr></table></figure></p>
<p><code>--replicas</code> 表示创建多少任务</p>
<h3 id="查看服务信息-service-ls"><a href="#查看服务信息-service-ls" class="headerlink" title="查看服务信息 (service ls)"></a>查看服务信息 (service ls)</h3><p>使用 <code>docker service ls</code> 来查看当前 Swarm 集群运行的服务</p>
<p>想要查看其中某一个服务的详细信息，可以使用 <code>service inspect</code>命令: <code>docker service inspect [OPTIONS] SERVICE [SERVICE...]</code></p>
<h3 id="查看服务中的任务详情-service-ps"><a href="#查看服务中的任务详情-service-ps" class="headerlink" title="查看服务中的任务详情 (service ps)"></a>查看服务中的任务详情 (service ps)</h3><p>使用 <code>docker service ps</code> 来查看某个服务中的任务(Task)的详情 <code>docker service ps [OPTIONS] SERVICE [SERVICE...]</code></p>
<h3 id="查看服务日志-service-logs"><a href="#查看服务日志-service-logs" class="headerlink" title="查看服务日志 (service logs)"></a>查看服务日志 (service logs)</h3><p>使用 <code>docker service logs</code> 来查看某个服务的日志</p>
<h3 id="删除服务-service-rm"><a href="#删除服务-service-rm" class="headerlink" title="删除服务 (service rm)"></a>删除服务 (service rm)</h3><p>使用 <code>docker service rm</code> 来从 Swarm 集群移除某个服务。</p>
<h3 id="服务伸缩-service-scale"><a href="#服务伸缩-service-scale" class="headerlink" title="服务伸缩 (service scale)"></a>服务伸缩 (service scale)</h3><p>使用 <code>docker service scale</code>调整服务中的任务数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker service scale backend=10</div></pre></td></tr></table></figure>
<h2 id="使用Stack部署服务"><a href="#使用Stack部署服务" class="headerlink" title="使用Stack部署服务"></a>使用Stack部署服务</h2><p>Stack是一组相互关联的服务，它们可以共享依赖关系，并且可以进行协调和缩放。 单个Stack能够定义和协调整个应用程序的功能（尽管非常复杂的应用程序可能需要使用多个Stack）</p>
<p>正如之前使用 docker-compose.yml 来一次配置、启动多个容器，在 Swarm 集群中也可以使用 compose 文件 （docker-compose.yml） 来配置、启动多个服务。</p>
<p>我们使用 docker service create 一次只能部署一个服务，使用 docker-compose.yml 我们可以一次启动多个关联的服务。我们在此以 Swarm 集群中部署 WordPress 为例进行说明。</p>
<p>docker-compose.yml 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">version: &quot;3&quot;</div><div class="line"></div><div class="line">services:</div><div class="line">  wordpress:</div><div class="line">    image: wordpress</div><div class="line">    ports:</div><div class="line">      - 80:80</div><div class="line">    networks:</div><div class="line">      - overlay</div><div class="line">    environment:</div><div class="line">      WORDPRESS_DB_HOST: db:3306</div><div class="line">      WORDPRESS_DB_USER: wordpress</div><div class="line">      WORDPRESS_DB_PASSWORD: wordpress</div><div class="line">    deploy:</div><div class="line">      mode: replicated</div><div class="line">      replicas: 3</div><div class="line"></div><div class="line">  db:</div><div class="line">    image: mysql</div><div class="line">    networks:</div><div class="line">       - overlay</div><div class="line">    volumes:</div><div class="line">      - db-data:/var/lib/mysql</div><div class="line">    environment:</div><div class="line">      MYSQL_ROOT_PASSWORD: somewordpress</div><div class="line">      MYSQL_DATABASE: wordpress</div><div class="line">      MYSQL_USER: wordpress</div><div class="line">      MYSQL_PASSWORD: wordpress</div><div class="line">    deploy:</div><div class="line">      placement:</div><div class="line">        constraints: [node.role == manager]</div><div class="line"></div><div class="line">  visualizer:</div><div class="line">    image: dockersamples/visualizer:stable</div><div class="line">    ports:</div><div class="line">      - &quot;8080:8080&quot;</div><div class="line">    stop_grace_period: 1m30s</div><div class="line">    volumes:</div><div class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</div><div class="line">    deploy:</div><div class="line">      placement:</div><div class="line">        constraints: [node.role == manager]</div><div class="line"></div><div class="line">volumes:</div><div class="line">  db-data:</div><div class="line">networks:</div><div class="line">  overlay:</div></pre></td></tr></table></figure></p>
<p>在 Swarm 集群管理节点新建该文件，其中的 visualizer 服务提供一个可视化页面，我们可以从浏览器中很直观的查看集群中各个服务的运行节点。</p>
<h3 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h3><p>部署服务使用 <code>docker stack deploy</code>，其中 -c 参数指定 compose 文件名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker stack deploy -c docker-compose.yml wordpress</div></pre></td></tr></table></figure></p>
<h3 id="查看服务"><a href="#查看服务" class="headerlink" title="查看服务"></a>查看服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker stack ls</div><div class="line">NAME                SERVICES</div><div class="line">wordpress           3</div></pre></td></tr></table></figure>
<h3 id="移除服务"><a href="#移除服务" class="headerlink" title="移除服务"></a>移除服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">要移除服务，使用 docker stack down</div><div class="line"></div><div class="line">$ docker stack down wordpress</div><div class="line">Removing service wordpress_db</div><div class="line">Removing service wordpress_visualizer</div><div class="line">Removing service wordpress_wordpress</div><div class="line">Removing network wordpress_overlay</div><div class="line">Removing network wordpress_default</div></pre></td></tr></table></figure>
<p>该命令不会移除服务所使用的 数据卷，如果你想移除数据卷请使用 docker volume rm</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://0x9.me/WYIcD" target="_blank" rel="external">https://0x9.me/WYIcD</a></li>
<li><a href="https://0x9.me/Woidc" target="_blank" rel="external">https://0x9.me/Woidc</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker Swarm 为Docker 提供容器集群服务，是 Docker 官 方对容器云生态进行支持的核心方案。&lt;/p&gt;
    
    </summary>
    
      <category term="运维" scheme="https://www.liuin.cn/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Docker" scheme="https://www.liuin.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Next Permutation 题解</title>
    <link href="https://www.liuin.cn/2018/02/25/LeetCode-Next-Permutation-%E9%A2%98%E8%A7%A3/"/>
    <id>https://www.liuin.cn/2018/02/25/LeetCode-Next-Permutation-题解/</id>
    <published>2018-02-25T01:27:43.000Z</published>
    <updated>2018-03-02T13:53:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode Next Permutation 题解</p>
<a id="more"></a>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题目的意思就是求给定序列的下一个字典序</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们要了解什么是字典序，这里参考wiki的解释：</p>
<blockquote>
<p>设想一本英语字典里的单词，何者在前何者在后？</p>
<p>显然的做法是先按照第一个字母、以 a、b、c……z 的顺序排列；如果第一个字母一样，那么比较第二个、第三个乃至后面的字母。如果比到最后两个单词不一样长（比如，sigh 和 sight），那么把短者排在前。</p>
<p>通过这种方法，我们可以给本来不相关的单词强行规定出一个顺序。“单词”可以看作是“字母”的字符串，而把这一点推而广之就可以认为是给对应位置元素所属集合分别相同的各个有序多元组规定顺序</p>
</blockquote>
<p>我的理解是：<strong>把一组数的所有排列情况按照字母顺序进行一次排序得到的就是一个字典序</strong></p>
<p>在这道题中要求给定排列的下一个字典序，可以知道把一个大一点的数往前移动这个序列的字典序一定会变大，那么就要从后往前找到第一个能变大的数（变大指和它后面的某个数互换以后），找到这个数以后把他和比他大的“第一个”数互换获得最小的增量，然后把这个数后面的数字按照从小到大的顺序重新排列。</p>
<p>举个例子：</p>
<p><img src="https://leetcode.com/media/original_images/31_Next_Permutation.gif" alt="enter description here"></p>
<h2 id="代码-C"><a href="#代码-C" class="headerlink" title="代码(C++)"></a>代码(C++)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int first = nums.size(), len = nums.size();</div><div class="line">        // 倒序查找第一个升序数</div><div class="line">        for(int i=len-1; i&gt;0;--i)</div><div class="line">        &#123;</div><div class="line">            if(nums[i] &gt; nums[i-1])</div><div class="line">            &#123;</div><div class="line">                first = i-1;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if(first == len)</div><div class="line">            reverse(nums.begin(), nums.end());</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            int second = len-1;</div><div class="line">            // 在后面找一个刚好比这个数大一点的数和其互换</div><div class="line">            for(int i=first + 1;i&lt;len;++i)</div><div class="line">            &#123;</div><div class="line">                if(nums[i]&lt;=nums[first])</div><div class="line">                &#123;</div><div class="line">                    second = i-1;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            swap(nums[first], nums[second]);</div><div class="line">            // 反转后面的部分</div><div class="line">            reverse(nums.begin()+first+1, nums.end());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>更多LeetCode题解，欢迎查看我的<a href="https://github.com/Sixzeroo/LeetCode" target="_blank" rel="external">GitHub项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode Next Permutation 题解&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://www.liuin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://www.liuin.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Docker Machine 简介</title>
    <link href="https://www.liuin.cn/2018/02/16/Docker-Machine-%E7%AE%80%E4%BB%8B/"/>
    <id>https://www.liuin.cn/2018/02/16/Docker-Machine-简介/</id>
    <published>2018-02-16T11:08:04.000Z</published>
    <updated>2018-02-23T04:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 继续探索</p>
<a id="more"></a>
<h2 id="什么是Docker-Machine"><a href="#什么是Docker-Machine" class="headerlink" title="什么是Docker Machine"></a>什么是Docker Machine</h2><p>Docker Machine 是一种可让您在虚拟主机上安装 <code>Docker Engine</code> 并使用docker-machine命令管理主机的工具。你能使用Docker Machine 工具在你的本地 Mac 或 Windows boxs，公司网络，数据中心或 Azure 提供商（如 Azure，AWS 或 Digital Ocean）上创建 Docker 主机。</p>
<p>使用 <code>docker-machine</code> 命令，你能够开始、插入、停止和重启一个你所管理的主机、更新Docker的客户端和守护进程、并配置Docker配置以便和主机进行通信。</p>
<p>将Machine CLI指向一个正在运行并且托管的主机，你能够直接使用<code>docker</code>直接命令该主机。比如说，运行<code>docker-machine env default</code>指向一个名为<code>defaule</code>的主机，按照屏幕上的指令完成<code>env</code>的配置，并运行<code>docker ps</code> ，<code>docker run hello-world</code>等等</p>
<p>在Docker v1.12版本之前，Machine是在Mac和Window上运行Docker的唯一方法。从 Beta 版程序和 Docker v1.12 开始，Docker for Mac 和 Docker for Windows 可作为本地应用程序使用，并且是在在较新的台式机和笔记本电脑上的更好选择。我们鼓励您尝试这些新应用。 Docker for Mac 和Docker for Windows 的安装程序包括 Docker Machine，以及 Docker Compose。</p>
<h2 id="在什么情况下使用Docker-Machine"><a href="#在什么情况下使用Docker-Machine" class="headerlink" title="在什么情况下使用Docker Machine"></a>在什么情况下使用Docker Machine</h2><p>Docker Machine提供一种在各种各样的Linux主机上配置Docker的解决方案。此外Machine能够让你在老的的Mac和Windows上像上面一样运行Docker。</p>
<p>Docker有两个基本的应用场景：</p>
<ol>
<li>我有一个旧的桌面系统，并且想在Mac和Windows上运行Docker</li>
</ol>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518682583374.jpg" alt="enter description here"></p>
<p>如果你的主要工作环境是在一台旧的Mac或者Windows笔记本电脑或者台式机上，这些主机无法满足新的<code>Docker for Mac</code>和<code>Docker for Windows</code>的配置要求，那么你可以使用Docker Machine来在本地使用Docker Engine。</p>
<p>使用 Docker Toolbox 安装程序在 Mac 或 Windows box 上安装 Docker Machine 可以使用 Docker Engine 配置本地虚拟机，使您可以连接它并运行 docker 命令。</p>
<ol>
<li>我想在远程系统中配置Docker主机</li>
</ol>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518682822569.jpg" alt="enter description here"></p>
<p>Docker Engine在Linux系统上本机运行。如果有一个Linux box作为你的主系统，并且向运行<code>docker</code>命令，你需要的东西就是下载并安装Docker Engine。但是你想用一种高效的方式在网络、云端甚至本地配置多个Docker主机，你就需要Docker Machine</p>
<p>不管你的主系统是Linux、Max还是Windows，你都能够安装Docker Machine并且使用<code>docker-machine</code>去配置并管理大量的Docker主机。它会自动创建主机、安装Docker Engine并且配置docker 客户端。每个托管主机（“machine”）是 Docker 主机和配置的客户端的组合。</p>
<h2 id="Docker-Engine-和-Docker-Machine的区别"><a href="#Docker-Engine-和-Docker-Machine的区别" class="headerlink" title="Docker Engine 和 Docker Machine的区别"></a>Docker Engine 和 Docker Machine的区别</h2><p>当人们说“Docker”时，他们通常意味着 Docker Engine，即由 Docker 守护程序组成的客户端-服务器应用程序，指定用于与守护程序进行交互的接口的 REST API 以及与守护程序（通过 REST API 包装器）通信的命令行界面（CLI）客户端。<code>Docker Engine</code> 从 CLI 接受<code>docker</code>命令，例如<code>docker run &lt;image&gt;</code>，<code>docker ps</code>列出运行的容器，<code>docker images</code>以列出镜像等。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518683627228.jpg" alt="enter description here"></p>
<p>Docker Machine 是一种用于配置和管理 Docker 化的主机（Docker Engine的主机）的工具。通常，您在本地系统上安装 Docker Machine。Docker Machine 有自己的命令行客户端docker-machine和 Docker Engine 客户端docker。您可以使用 Machine 在一个或多个虚拟系统上安装 Docker Engine。这些虚拟系统可以是本地的（如当您使用 Machine 在 Mac 或 Windows 上的 VirtualBox 中安装和运行 Docker Engine）或远程（当您使用 Machine 在云提供商上配置 Docker 化主机时）。Docker 化主机本身可以被认为是有时被称为托管的“machines”。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518683773491.jpg" alt="enter description here"></p>
<h2 id="安装-Docker-Machine"><a href="#安装-Docker-Machine" class="headerlink" title="安装 Docker Machine"></a>安装 Docker Machine</h2><p>安装Docker Machine的前提是你已经安装好Docker</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -L https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-`uname <span class="_">-s</span>`-`uname -m` &gt;/usr/<span class="built_in">local</span>/bin/docker-machine &amp;&amp; \</div><div class="line"> chmod +x /usr/<span class="built_in">local</span>/bin/docker-machine</div></pre></td></tr></table></figure>
<h3 id="maxOS"><a href="#maxOS" class="headerlink" title="maxOS"></a>maxOS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> curl -L https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-`uname <span class="_">-s</span>`-`uname -m` &gt;/tmp/docker-machine &amp;&amp; \</div><div class="line">sudo install /tmp/docker-machine /usr/<span class="built_in">local</span>/bin/docker-machine</div></pre></td></tr></table></figure>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>使用GIt Bash工具安装，并且这个工具支持像<code>chmod</code>这样的Linux命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> if [[ ! -d &quot;$HOME/bin&quot; ]]; then mkdir -p &quot;$HOME/bin&quot;; fi &amp;&amp; \</div><div class="line">curl -L https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-Windows-x86_64.exe &gt; &quot;$HOME/bin/docker-machine.exe&quot; &amp;&amp; \</div><div class="line">chmod +x &quot;$HOME/bin/docker-machine.exe&quot;</div></pre></td></tr></table></figure></p>
<h2 id="普通情况使用Docker-Machine创建Machine"><a href="#普通情况使用Docker-Machine创建Machine" class="headerlink" title="普通情况使用Docker Machine创建Machine"></a>普通情况使用Docker Machine创建Machine</h2><p>假设我现在有两个主机：主机1运行Docker Machine，创建主机2为Docker 主机</p>
<h3 id="配置免交互认证登录"><a href="#配置免交互认证登录" class="headerlink" title="配置免交互认证登录"></a>配置免交互认证登录</h3><p>将主机1的公钥放入主机2的<code>~/.ssh/authorized_keys</code>文件中</p>
<p>或者使用<code>ssh-copy-id</code>完成上面的操作</p>
<h3 id="修改sudoers文件"><a href="#修改sudoers文件" class="headerlink" title="修改sudoers文件"></a>修改sudoers文件</h3><p>在主机2中的<code>/etc/sudoers</code>文件中添加<code>Defaults  visiblepw</code>一行（或者把<code>!visiblepw</code>改为<code>visiblepw</code>）</p>
<h3 id="创建一个Docker主机"><a href="#创建一个Docker主机" class="headerlink" title="创建一个Docker主机"></a>创建一个Docker主机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine create --driver generic--generic-ip-address=192.168.1.111 Ubuntu-004</div></pre></td></tr></table></figure>
<p>使用docker-machinecreate创建machine时，会检测主机是否已经安装docker，如果安装就简单做相应的检查动作即可，如果未安装，则会安装最新版的docker</p>
<h2 id="在云服务提供商平台使用Docker-Machine"><a href="#在云服务提供商平台使用Docker-Machine" class="headerlink" title="在云服务提供商平台使用Docker Machine"></a>在云服务提供商平台使用Docker Machine</h2><p>Docker Machine支持几个流行的云平台，如Digital Ocean、Amazon Web Services（AWS）、Microsoft Azure、Google Cloud Computing及其它等等，所以我们可以在不同的平台使用相同的接口来部署Docker。这里我们使用Digital Ocean驱动在Digital Ocean的服务器上部署Docker，运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker-machine create --driver digitalocean --digitalocean-access-token &lt;API-Token&gt; Linux-test</div><div class="line"></div><div class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(docker-machine env Linux-test)</span>"</span></div></pre></td></tr></table></figure>
<p><code>--driver</code>选项指定digitalocean驱动，<code>--digitalocean-access-token</code>选项指定<a href="https://cloud.digitalocean.com/settings/applications" target="_blank" rel="external">Digital Ocean Control Panel</a>提供的API Token，命令最后的是我们创建的Docker虚拟机的机器名。</p>
<p>返回的信息如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Creating CA: /root/.docker/machine/certs/ca.pem</div><div class="line">Creating client certificate: /root/.docker/machine/certs/cert.pem</div><div class="line">Running pre-create checks...</div><div class="line">Creating machine...</div><div class="line">(Linux-test) Creating SSH key...</div><div class="line">(Linux-test) Creating Digital Ocean droplet...</div><div class="line">(Linux-test) Waiting <span class="keyword">for</span> IP address to be assigned to the Droplet...</div><div class="line">Waiting <span class="keyword">for</span> machine to be running, this may take a few minutes...</div><div class="line">Detecting operating system of created instance...</div><div class="line">Waiting <span class="keyword">for</span> SSH to be available...</div><div class="line">Detecting the provisioner...</div><div class="line">Provisioning with ubuntu(systemd)...</div><div class="line">Installing Docker...</div><div class="line">Copying certs to the <span class="built_in">local</span> machine directory...</div><div class="line">Copying certs to the remote machine...</div><div class="line">Setting Docker configuration on the remote daemon...</div><div class="line">Checking connection to Docker...</div><div class="line">Docker is up and running!</div><div class="line">To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env Linux-test</div></pre></td></tr></table></figure></p>
<p>运行如上命令后，我们可以在Digital Ocean Droplet Panel中看到一个新的具有默认配置的droplet已经被创建出来了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_15_1518684941619.jpg" alt="enter description here"></p>
<p>简便起见，docker-machine会使用默认配置来部署Droplet。我们可以通过增加选项来定制我们的Droplet。这里是一些digitalocean相关的选项，我们可以使用它们来覆盖Docker Machine所使用的默认配置。</p>
<ul>
<li>–digitalocean-image “ubuntu-14-04-x64” 用于选择Droplet的镜像</li>
<li>–digitalocean-ipv6 enable 启用IPv6网络支持</li>
<li>–digitalocean-private-networking enable 启用专用网络</li>
<li>–digitalocean-region “nyc3” 选择部署Droplet的区域</li>
<li>–digitalocean-size “512mb” 选择内存大小和部署的类型</li>
</ul>
<p>如果你想在其他云服务使用docker-machine，并且想覆盖默认的配置，可以运行如下命令来获取Docker Mackine默认支持的对每种平台适用的参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine create -h</div></pre></td></tr></table></figure></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="查看主机"><a href="#查看主机" class="headerlink" title="查看主机"></a>查看主机</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine ls</div></pre></td></tr></table></figure>
<p>ACTIVE一列有“*”标记的是活跃主机，同时可以用<code>docker-machine active</code>命令来标记其他的主机为活跃主机</p>
<h3 id="使用Docker容器"><a href="#使用Docker容器" class="headerlink" title="使用Docker容器"></a>使用Docker容器</h3><p>创建主机成功后，可以通过 env 命令来让后续操作对象都是目标主机。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker-machine env <span class="built_in">test</span></div></pre></td></tr></table></figure></p>
<p>后续根据提示在命令行输入命令之后就可以操作 test 主机。</p>
<p>也可以通过 SSH 登录到主机：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker-machine ssh <span class="built_in">test</span></div><div class="line"></div><div class="line">docker@<span class="built_in">test</span>:~$ docker --version</div><div class="line">Docker version 17.10.0-ce, build f4ffd25</div></pre></td></tr></table></figure></p>
<p>连接到主机之后你就可以在其上使用 Docker 了。</p>
<h3 id="删除主机"><a href="#删除主机" class="headerlink" title="删除主机"></a>删除主机</h3><p>删除在运行的主机以及它的所有镜像和容器，我们可以使用<code>docker-machine rm</code>命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-machine rm linux-dev</div></pre></td></tr></table></figure></p>
<p>运行完以后，本地和与远端的都将删除，在云平台上的实例也会被删除</p>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><ul>
<li>active 查看活跃的 Docker 主机</li>
<li>config 输出连接的配置信息</li>
<li>create 创建一个 Docker 主机</li>
<li>env 显示连接到某个主机需要的环境变量</li>
<li>inspect 输出主机更多信息</li>
<li>ip 获取主机地址</li>
<li>kill 停止某个主机</li>
<li>ls 列出所有管理的主机</li>
<li>provision 重新设置一个已存在的主机</li>
<li>regenerate-certs 为某个主机重新生成 TLS 认证信息</li>
<li>restart 重启主机</li>
<li>rm 删除某台主机</li>
<li>ssh SSH 到主机上执行命令</li>
<li>scp 在主机之间复制文件</li>
<li>mount 挂载主机目录到本地</li>
<li>start 启动一个主机</li>
<li>status 查看主机状态</li>
<li>stop 停止一个主机</li>
<li>upgrade 更新主机 Docker 版本为最新</li>
<li>url 获取主机的 URL</li>
<li>version 输出 docker-machine 版本信息</li>
<li>help 输出帮助信息</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 继续探索&lt;/p&gt;
    
    </summary>
    
      <category term="运维" scheme="https://www.liuin.cn/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Docker" scheme="https://www.liuin.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》笔记 C++基础部分</title>
    <link href="https://www.liuin.cn/2018/02/15/%E3%80%8AC-Primer%E3%80%8B%E7%AC%94%E8%AE%B0-C-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/"/>
    <id>https://www.liuin.cn/2018/02/15/《C-Primer》笔记-C-基础部分/</id>
    <published>2018-02-15T13:15:06.000Z</published>
    <updated>2018-02-23T04:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》笔记 C++基础部分</p>
<a id="more"></a>
<h1 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h1><h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><h3 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h3><p>类型char和类型signed char并不一样。尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。</p>
<p>当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）</p>
<p>与一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。把int转换成无符号数的过程和把int直接赋给无符号数—样。</p>
<h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517231165506.jpg" alt="enter description here"></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>初始化不是赋值，初始化的含义是创建一个变量的时候赋予其一个初始值，而赋值的含义是把对象的当前值删除，而以一个新值来代替</p>
<p>默认初始化：如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将不被初始化(uninitialized)。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。</p>
<p>使用未初始化的值将带来无法预计的后果</p>
<h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>变量能且只能被定义一次，但可以被声明多次</p>
<h3 id="标识符（identifier）"><a href="#标识符（identifier）" class="headerlink" title="标识符（identifier）"></a>标识符（identifier）</h3><h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>建议：当你第一次使用变量的时候再定义它</p>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用（reference）为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。</p>
<p>一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定（bind)在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此<strong>引用必须初始化</strong>。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_29_1517232990644.jpg" alt="enter description here"></p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针必须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，将拥有一个不确定的值。</p>
<p>指针的他（即地址）应属下列4种状态之一:</p>
<ol>
<li>指向一个对象。</li>
<li>指叫紧邻对象所占空间的下一个位置。</li>
<li>空指针，意味着指针没有指向任何对象。</li>
<li>无效指针，也就是上述情况之外的其他值。</li>
</ol>
<p>访问无效指针和空指针或者未知指针的后果无法预计</p>
<p><code>void*</code>指针时一种特殊的指针类型，可用于存放任意对象的地址。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象做哪些操作。</p>
<h3 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h3><p>引用本身不是对象，因此不能定义指向引用的指针。但是指针是对象，所以存在对指针的引用。</p>
<h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p>const对象被设定为仅在文件内有效</p>
<p>对const的引用可能引用一个并非const的对象：常量引用仅对引用可参与的操作做出了限定，对于引用对象本身是不是一个常量未作限定。</p>
<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p>用名词<strong>顶层const</strong>(top-levelconst)表示指针本身是个常量，而用名词<strong>底层const</strong>(low-levelconst)表示指针所指的对象是一个常量。</p>
<h3 id="constexpr-和常量表达式"><a href="#constexpr-和常量表达式" class="headerlink" title="constexpr 和常量表达式"></a>constexpr 和常量表达式</h3><p>常量表达式（constexpression)是指值不会改变而且在编译过程就能得到汁算结果的表达式。当然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。</p>
<p>C++11标准规定，允许将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量表达式。</p>
<h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h3><p>编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，C++11新标准引入了auto类型说明符，用它就能让编译器帮我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如double)不同，auto让编译器通始值来推算变量的类型。显然，auto定义的变量必须有初始值：</p>
<p>auto一般会忽略顶层const，同时底层const则会保留下来</p>
<h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h3><p>有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变蛩。为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数椐类型。在此过程中，编译器分忻表达式并得到它的类型，却不实际汁算表达式的值:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">decltype</span>(f()) sum = x;   <span class="comment">// sum的类型就是函数f的返回类型</span></div></pre></td></tr></table></figure>
<p>decltype 处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）</p>
<hr>
<h1 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a>字符串、向量和数组</h1><h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p>如果提供一个字符串字面值，则该字面值中除了最后那个空字符外其他所有字符都被拷贝新建的string对象中。</p>
<blockquote>
<p>直接初始化和拷贝初始化</p>
</blockquote>
<p>如果使用等号（=）初始化一个变量，实际上执行的是<strong>拷贝初始化</strong>（copy initialization），编译器将等号右侧的初始值拷贝到新创建的对象中去。<br>与之相反，不使用等号，则执行的是<strong>直接初始化</strong>（direct initialization）</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517572296753.jpg" alt="enter description here"></p>
<blockquote>
<p>string:size_type 类型</p>
</blockquote>
<p>string类及其他大多数标准库类型都定义了几种配套的类型。这些配套体现了标准库类型与机器无关的特性，类型size_type即是其中的一种。在具体使用的时候，通过作用域操作符表明名字size_type是在类string中定义的。</p>
<blockquote>
<p>字面值和string对象相加</p>
</blockquote>
<p>当把string对象和字符字面值以及字符串字面值混在一条语句中使用的时候，必须保证每个加法运算符的两侧至少有一个是string对象</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517572788565.jpg" alt="enter description here"></p>
<h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p>如果循环体内部包含有向 vector对象添加元元素的语句,则不能使用范 围for循环</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517659028911.jpg" alt="enter description here"></p>
<p>不能用下标形式添加元素：vector对象(以及 string对象)的下标运算符可用于访问已存在的元素, 而不能用于添加元素。</p>
<h2 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h2><p>所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符</p>
<p>类似于指针类型,迭代器也<strong>提供了对对象的间接访问</strong>。就迭代器而言,其对对象是容器中的元素或者者 string对象中的字符。使用迭代器可以访问某 个元素,迭代器也能从一个元素移动到另外一个元素。迭代器有有效和无效之分,这一点 和指针差不多。<strong>有效的迭代器或者指向某个元素,或者指向容器中尾元素的下一位置</strong>，其他所有情况都属于无效。</p>
<h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>end成员负责返回指向容器(或 string对象)“尾元素的下一位置( one past the end) 的迭代器,也就是说,该迭代器指示的是容器的一个本不存在的“尾后( off the end)”元 素。这样的迭代器没什么实际含义,仅是个标记而已,表示我们已经处理完了容器中的所 有元素。end成员返回的迭代器常被称作尾后迭代器( off-the- end iterator)或者简称为尾 迭代器( end iterator)。特殊情况下如果容器为空,则beg1n和end返回的是同一个迭 代器。（都是尾后迭代器）</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517659661001.jpg" alt="enter description here"></p>
<p>迭代器运算符</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517659702856.jpg" alt="enter description here"></p>
<blockquote>
<p>迭代器类型</p>
</blockquote>
<p>就像不知道 string和 vector的 size type成员员到底是什么类型一样,一般来说我们也不知道(其实是无须知道)迭代器的精确类型。而实际上, 那些拥有迭代器的标准库类型使用 iterator和 const iterator来表示迭代器的类型</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517659938792.jpg" alt="enter description here"></p>
<blockquote>
<p>某些对vector对象的操作会使迭代器失效</p>
</blockquote>
<p>不能在for循环范围内向vector对象添加元素；任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效</p>
<h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><p>迭代器的递增运算令迭代器每次移动一个元素,所有的标准库容器都有支持递增运算 的迭代器。类似的,也能用=和!=对任意标准库类型的两个有效迭代器进行比较</p>
<p>vector和string迭代器支持更多的迭代器运算</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517660460874.jpg" alt="enter description here"></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>不允许拷贝和赋值</p>
</blockquote>
<p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值</p>
<blockquote>
<p>理解复杂的数组声明</p>
</blockquote>
<p>类型修饰符从右向左依次绑定，就数组而言，由内向外阅读比从右向左好很多</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517660778235.jpg" alt="enter description here"></p>
<blockquote>
<p>访问数组元素</p>
</blockquote>
<p>在使用数组下标的时候,通常将其定义为size_t类型。size_t是一种机器相关的 无符号类型,它被设计得足够大以便能表示内存中任意对象的大小。</p>
<blockquote>
<p>标准库函数</p>
</blockquote>
<p>尽管能计算得到尾后指针,但这种用法极易出错。为了让指针的使用更简单、更安全, C++11新标准引引入了两个名为 begin和end的函数。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517661137672.jpg" alt="enter description here"></p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>严格来说，C++语言中没有多维数组，通常所说的的多维数组其实是数组的数组。</p>
<hr>
<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p>重载运算符</p>
</blockquote>
<p>C++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时,用户可以自行定义其含义义。因为这种自定义的过程事实 上是为已存在的运算符赋予了另外一层含义,所以称之为<strong>重載运算符</strong>( overloaded operator)。</p>
<blockquote>
<p>左值和右值</p>
</blockquote>
<p>C++的表达式要不然是右值( rvalue,读作“are- value”),要不然就是左值( lvalue, 读作“ ell-value”)。这两个名词是从C语言继承过来的,原本是为了帮助记忆:左值可以 位于赋值语句的左侧,右值则不能。</p>
<p>在C++语言中,二者的区别就没那么简单了。一个左值表达式的求值结果是一个对象 或者一个函数,然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对 象。此外,虽然某些表达式的求值结果是对象,但它们是右值而非左值。可以做一个简单 的归纳:<strong>当一个对象被用作右值的时候,用的是对象的值(内容);当对象被用作左值的 时候,用用的是对象的身份(在内存中的位置)。</strong> </p>
<p>不同的运算符对运算对象的要求各不相同,有的需要左值运算对象、有的需要右值运 算对象:返回值也有差异,有的得到左值结果、有的得到右值结果。一个重要的原则是：<strong>在需要右值的地方可以用左值来代替,但 是不能把右值当成左值(也就是位置)使用</strong>。 当一个左值被当成右值使用时,实际使用的 是它的内容(值)。</p>
<h3 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h3><p>对于那些没有指定执行顺序的运算符来说,如果表达式指向并修改了同一个对象,将会引发错误并产生<strong>未定义的行为</strong>。</p>
<p>举个简单的例子,&lt;&lt;运算符 没有明确规定何时以及如何对运算对象求值,因此下面的输出表达式是末定义的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"+"</span> &lt;&lt; ++i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 未定义的</span></div></pre></td></tr></table></figure></p>
<p>C++语言没有明确规定大多数二元运算符的求值顺序,给编译器优化留下了 余地。这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡.</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517751109803.jpg" alt="enter description here"></p>
<p>算术运算符能作用域任何算术类型以及任意能转化为算术类型的类型。</p>
<p>算术表达式有可能产生未定义的结果。一部分原因是数学性质本身:例如除数是0 的情况;另外一部分则源于计算机的特点:例如溢出,当计算的结果超出该类型所能表 示的范围时就会产生溢出。</p>
<blockquote>
<p>除法和取模运算</p>
</blockquote>
<p>在除法运算中,如果两个运算对象的符号相同则商为正(如果不为0的话),否则商 为负。C++语言的早期版本允许结果为负值的商向上或向下取整,C++11新标准则规定商 律向0取整(即直接切除小数部分) </p>
<p>根据取余运算的定义,如果m和n是整数且n非0,则表达式(m/n)*n+m%n的求值 结果与m相等。隐含的意思是,如果m%n不等于0,则它的符号和m相同。C++语言的早 期版本允许m%n的符号匹配n的符号,而且商向负无穷一侧取整,这一方式在新标准中 已经被禁止使用了。除了-m导致溢出的特殊情况,其他时候(-m)/n和m/(-n)都等于 (m/n),m%(-n)等于m%n,(-m)%n等于-(m%n)。</p>
<p>具体示例如下:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517751057230.jpg" alt="enter description here"></p>
<h2 id="逻辑运算符和关系运算符"><a href="#逻辑运算符和关系运算符" class="headerlink" title="逻辑运算符和关系运算符"></a>逻辑运算符和关系运算符</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517751134864.jpg" alt="enter description here"></p>
<p>逻辑与运算符和逻辑或运算符都是先求左側运算对象的值再求右侧运算对象的值,当 且仅当左側运算对象无法确定表达式的结果时オ会计算右侧运算对象的值。这种种策略称为 短路求值( short- circuit evaluation)。</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符的左侧运算对象必须是一个可修改的左值</p>
<h2 id="递增运算符和递减运算符"><a href="#递增运算符和递减运算符" class="headerlink" title="递增运算符和递减运算符"></a>递增运算符和递减运算符</h2><p>递增和递减运算符有两种形式:前置版本和后置版本。前置递增运算符首先将运算对象加1(或减1),然后将改变后的对象作为求 值结果。后置版本也会将运算对象加1(或减1),但是求值结果是运算对象改变之前那个 值的副本</p>
<p>建议:除非必须,否则不用递增递减运算符的后置版本：<br>有C语言背景的读者可能对优先使用前置版本递增运算符有所疑间问,其实原因非常 简单:前置版本的递增运算符避免了不必要的工作,它把值加1后直接返回改变了的运 算对象。与之相比,后置版本需要将原始值存储下来以便于返回这个未修改的内容。如 果我们不需要修改前的值,那么后置版本的操作就是一种浪费。</p>
<h2 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h2><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律,其所得得的值是一个size_t类型</p>
<p>运算符的运算对象有两种形式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">sizeof</span>(type)</div><div class="line"><span class="keyword">sizeof</span> expr</div></pre></td></tr></table></figure></p>
<p>在第二种形式中，sizeof返回的是表达式结果类型的大小。与众不同的一点是，sizeof并不实际计算其运算对象的值：</p>
<p>因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中的元素个数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(ia)/<span class="keyword">sizeof</span>(*ia);</div><div class="line"><span class="keyword">int</span> arr2[sz]; <span class="comment">// ok sizeof returns a constant expression</span></div></pre></td></tr></table></figure></p>
<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p>逗号运算符( comma operator)含有两个运算对象,按照从左向右的顺序依次求值 和逻辑与、逻辑或以及条件运算符一样,逗号运算符也规定了运算对象求值的顺序。 对于逗号运算符来说,首先对左侧的表达式求值,然后将求值结果丢弃掉。逗号运算符真正的结果是右側表达式的值。如果右侧运算对象是左值,那么最终的求值结果也是左值。</p>
<h2 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="其他隐式类型转换"><a href="#其他隐式类型转换" class="headerlink" title="其他隐式类型转换"></a>其他隐式类型转换</h3><p>数组转换为指针：在大多数用到数组的表达式中，数组自动转换为指向数组首元素的指针</p>
<p>指针的转换:C++还规定了几种其他的指针转换方式,包括常量整数值0或者者字面值 nu11ptr能转换成任意指针类型:指向任意非常量的指针能转换成void<em>;指向任意对 象的指针能转换成 const void</em>。</p>
<p>转换为布尔类型：存在一种从算术类型或指针类型向布尔类型自动转换的机制</p>
<p>转换为常量：允许将指向非常量类型的指针转换成为相应常量类型的指针，对于引用也是这样。</p>
<h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p>待整理</p>
<h2 id="运算符优先级表"><a href="#运算符优先级表" class="headerlink" title="运算符优先级表"></a>运算符优先级表</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517752932745.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517752958321.jpg" alt="enter description here"></p>
<hr>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><blockquote>
<p>悬垂else</p>
</blockquote>
<p>当一个if语句嵌套在另一个if语句内部时,很可能if分支会多于else分支。事实上,之前那个成绩转换的程序就有4个if分支,而只有2个else分支。这时候问题 出现了:我们怎么知道某个给定的else是和和哪个if匹配呢? 这个问题通常称作<strong>悬垂else</strong>( dangling else),在那些既有if语句又有if else语句的编程语言中是个普遍存在的问题。不同语言解决该问题的思路也不同,就就C++而言, 它规定else与离它最近的尚未匹配的if匹配,从而消除了程序的的二义性。</p>
<blockquote>
<p>case标签</p>
</blockquote>
<p>case关键字和它对应的值一起被称为case标签( case label)。case标签签必须是整 型常量表达式</p>
<blockquote>
<p>switch内部的变量定义</p>
</blockquote>
<p>如前所述, switch的执行流程有可能会跨过某些case标标签。如果程序跳转到了某个特定的case,则switch结构中该该case标签之前的部分会被忽略掉。这种忽略掉一 部分代码的行为引出了一个有趣的问题:如果被略过的代码中含有变量的定义该怎么办? 答案是:<strong>如果在某处一个带有初值的变量位于作用域之外,在另一处该变量位于作用域之内,则从前一处跳转到后一处的行为是非法行为。</strong></p>
<h2 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h2><h3 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h3><p>C++11新标准引入了一种更简单的for语句,这种语句可以遍历容器或其他序列的 所有元素。范围for语句( range for statement）的语法形式是: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (declaration expression) </div><div class="line">statement</div></pre></td></tr></table></figure>
<p>expression表示的必须是一个序列,比如用花括号括起来的初始值列表、数组或者 vector或string等类型的对象,这些类型的共同特点是拥有能返回迭代器的 begin和end成员。 </p>
<p>declaration定义一个变量,序列中的每个元素都得能转换成该变量的类型。确保类型相容最简单的办法是使用auto类型说明符,这个关键字可以令编译器帮助我们指定合适的类型。</p>
<p>如果需要对序列中的元素执行写操作,循环变量必须声明成引用类型 每次迭代都会重新定义循环控制变量,并将其初始化成序列中的下一个值,之后オ会 执行 statement。像往常一样, statement可以是一条单独的语句也可以是一个块。所有元素 都处理完毕后循环终止。</p>
<h2 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h2><p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。当程序的某部分检测到一个他无法处理的问题的时候，需要用到异常处理。</p>
<p>异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持。在C++语言 中,异常处理包括 </p>
<ul>
<li>throw表达式( throw expression),异常检测部分使用 throw表达式来表示它遇到 了无法处理的问题。我们说 throw引发( raise)了异常。 </li>
<li>ty语句块( try block),异常处理部分使用try语句块处理异常。try语句块以 关键字try开始,并以一个或多个 catch子句( catch clause)结束。try语句块 中代码抛出的异常通常会被某个 catch子句处理。因为 catch子句“处理”异常, 所以它们也被称作异常处理代码( exception handler)。 </li>
<li>套异常类( exception class),用于在 throw表达式和相关的 catch子句之间传 递异常的具体信息。</li>
</ul>
<h3 id="标注异常"><a href="#标注异常" class="headerlink" title="标注异常"></a>标注异常</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_7_1518014704271.jpg" alt="enter description here"></p>
<hr>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>我们通过<strong>调用运算符</strong>( call operator)来执行函数。调用运算符的形式是一对圆括물 它作用于一个表达式,该表达式是函数或者指向函数的指针:圆括号之内是一个用逗号隔 开的实参( argument)列列表,我们用实参初始化函数的形参。调调用表达式的类型就是函数 的返回类型。</p>
<p>函数的调用完成两项工作:一是用实参初始化函数对应的形参,二是将控制权转移给被调 用函数。此时,主调调函数( calling function)的执行被暂时中断,被调函数( called function) 开始执行。</p>
<blockquote>
<p>形参和实参</p>
</blockquote>
<p>实参是形参的初始值。尽管实参和形参存在对应关系，但是并没有规定实参的求值顺序。编译器能以任意可行的顺序对实参求值。</p>
<h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><p>名字有作用域，对象有生命周期（lifetime）：名字的作用域是程序文本的一部分，名字在其中可见；对象的生命周期是程序执行过程中该对象存在的一段时间。</p>
<p>如果局部静态变量没有显式的初始值，它将执行初始化：内置类型的局部静态变量初始化为0</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数的声明不包含函数体，所以也不需要形参的名字，但是加上名字能够让使用者更好地理解函数的功能。</p>
<h3 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h3><p>分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译</p>
<p>编译以后，如果我们修改了其中一个源文件，那么只需要重新编译那个改动的文件即可</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>当形参是引用类型时,我们说它对应的实参被<strong>引用传递</strong>( Dassed by reference )或者函 数被传引用週用( called by reference)。和其他引用一样,引用形参也是它绑定的对象的别 名;也就是说,引用形参是它对应的实参的别名。 </p>
<p>当实参的值被拷贝给形参时,形参和实参是两个相互独立的对象。我们们说这样的实参 被<strong>值传递</strong>( passed by value)或者者函数被传值调用( called by value)</p>
<blockquote>
<p>使用引用避免拷贝</p>
</blockquote>
<p>拷贝大的类类型对象或者容器对象比较低效,甚至有的类类型(包括括1O类型在内) 根本就不支持拷贝操作。当某种类型不支持拷贝操作时,函数只能通过引用形参访问该类 型的对象。</p>
<p>如果函数无需改变引用形参的值，最好将其声明为常量引用</p>
<h3 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h3><p><strong>当形参时const时，其为顶层const，顶层const作用于对象本身。</strong></p>
<p>和其他初始化过程一样,当用实参初始化形参时会忽略掉顶层 const。换句话说,形参的顶层 const被忽略掉了。当形参有顶层 const时,传给它常量对象或者非常量对象都是 可以的:</p>
<h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p>数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响,这两个性质分别 是:<strong>不允许拷贝数组</strong>以及<strong>使用数组时(通常)会将其转换成 指针</strong>。因为不能拷贝数组,所以我们<strong>无法以值传递的方式使用 数组参数</strong>。因为数组会被转换成指针,所以当我们为函数传递一个数组时,实际上传递的 是指向数组首元素的指针。</p>
<p>为了程序的可读性，我们可以把形参写成类似数组的形式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">( <span class="keyword">const</span> *<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">( <span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">( <span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;  <span class="comment">// 这里的维度表示我们期望有多少元素，实际不一定</span></div></pre></td></tr></table></figure></p>
<p>管理指针形参的三种常用技术：</p>
<ul>
<li>使用标记指定数组长度，要求数组本身包含一个结束标记</li>
<li>使用标准库规范，传递指向数组首元素和数组尾元素的指针</li>
<li>显式传递一个表示数组大小的形参</li>
</ul>
<blockquote>
<p>传递多维数组</p>
</blockquote>
<p>和所有数组一样,当将多维数组传递给函数时,真正传递的是指向数组首元素的指针 。因为我们处理的是数组的数组,所以首元素本身就是一个数组, 指针就是一个指向数组的指针。<strong>数组第二维(以及后面所有维度)的大小都是数组类型的 部分,不能省略</strong>:</p>
<h3 id="含有可变形参的参数"><a href="#含有可变形参的参数" class="headerlink" title="含有可变形参的参数"></a>含有可变形参的参数</h3><p>为了编写能处理不同数量实参的函数,C++11新标准提供了两种主要的方法:如如果所 有的实参类型相同,可以传递一个名为initializer_list的标准库类型:如果实参的 类型不同,我们可以编写一种特殊的函数,也就是所谓的可变参数模板,</p>
<blockquote>
<p>initializer_list 形参</p>
</blockquote>
<p>如果函数的实参数量未知但是全部实参的类型都相同,我们可以使用initializer_listt类型的形参。initializer_list是一种标准库类型,用于表示 某种特定类型的值的数组</p>
<blockquote>
<p>省略符形参</p>
</blockquote>
<p>省略符形参是为了便于C++程序访访问某些特殊的C代码而设置的,这些们代码使用了名 为 varargs的C标准库功能。</p>
<p>省略符形参只能出现在形参列表的最后一个位置,它的形式无外乎以下两种: </p>
<ul>
<li>void foo(parm list, …);</li>
<li>void foo(…)</li>
</ul>
<p>第一种形式指定了foo函数的部分形参的类型,对应于这些形参的实参将会执行正常的 类型检査。省略符形参所对应的实参无须类型检査。在第一种形式中,形参声明后面的逗 号是可选的。</p>
<h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h2><blockquote>
<p>不要返回局部对象的引用或指针</p>
</blockquote>
<p>函数完成后,它所占用的存储空间也随之被释放掉。因此, 函数终止意味着局部变量的引用将指向不再有效的内存区域。会引发未定义行为</p>
<blockquote>
<p>引用返回左值</p>
</blockquote>
<p>调用一个返回引用的函数返回左值，返回其他类型得到右值</p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>不允许两个函数除了返回类型外其他所有的要素都相同</p>
<p>一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来</p>
<blockquote>
<p>调用重载函数</p>
</blockquote>
<p>定义了一组重载函数后,我们需要以合理的实参调用它们。<strong>函数匹配</strong>( functionmatching)是指一个过程,在这个过程中我们把函数调用与一组重载函数中的某一个关联起来,函数匹配也叫做<strong>重载确定</strong>( overload resolution)。编编译器首先将调用的实参与重载集合中每一个函数的形参进行比较,然后根据比较的结果决定到底调用哪个函数。</p>
<h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><p>某些函数有这样一种形参,在函数的很多次调用中它们都被赋予一个相同的值,此时,我们把这个反复出现的值称为函数的<strong>默认实参</strong>( default argument)。调调用含有默认实参的函数时,可以包含该实参,也可以省略该实参。</p>
<p>一旦某个形参被赋予了默认值，后面所有的额形参都要赋予默认值。所以当设计含有默认实参的函数时,其中一项任务是合理设置形参的顺序,尽量让不怎么使用默认值的形参出现在前面,而让那些经常使用默认值的形参出现在后面</p>
<p>在给定的作用域中一个形参只能被赋予一次默认实参。换句句话说,函数的后续声明只能为之前那些没有默认值的形参添加默认实参,而且该形参右侧的所有形参必须都有默认值。</p>
<p>局部变量不能作为默认实参。除此之外,只要表达式的类型能转换成形参所需的类型,该表达式就能作为默认实参:</p>
<h3 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h3><p>在大多数机器上,一次次函数调用其实包含着一系列工作:调用前要先保存寄存器,并在返回时恢复;可能需要拷贝实参;程序转向一个新的位置继续执行。</p>
<h4 id="内联函数可以避免函数调用的开销"><a href="#内联函数可以避免函数调用的开销" class="headerlink" title="内联函数可以避免函数调用的开销"></a>内联函数可以避免函数调用的开销</h4><p>将函数定义为内联函数（inline），通常就是把它在每一个调用点上“内联地”展开。函数返回类型前面加上关键字inline，这样就可以将它声明为内联函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="built_in">string</span> &amp; <span class="title">shortString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> s1.size() &lt;= s2.size() ? s1 : s2;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>一般来说,内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数,而而且一个75行的函数也不大可能在调用点内联地展开。</p>
<h4 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h4><p>constexpr函数( constexpr function)是指能用于常量表达式的函数。定义 constexpr函数的方法与其他函数类似,不过要遵循几项约定:函数的返回类型及所有形参的类型都得是字面值类型,而且函数体中必须有且只有一条 return语句:</p>
<p>把內联函数和 constexpr函数放在头文件内和其他函数不一样,内联函数和 constexpr函数可以在程序中多次定义。毕竟,编译器要想展开函数仅有函数声明是不够的,还需要函数的定义。不过,对于某个给定的内联函数或者 constexpr函数来说,它的多个定义必须完全一致。基于这个原因,内联函数和 constexpr函数通常定义在头文件中。</p>
<h3 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h3><p>程序可以包含一些用于调试的代码,但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时,要先屏蔽掉调试代码。这种方法用到两项预处理功能: assert和 NDEBUG</p>
<h4 id="assert-预处理宏"><a href="#assert-预处理宏" class="headerlink" title="assert 预处理宏"></a>assert 预处理宏</h4><p>assert是一种<strong>预处理宏</strong>( preprocessor marco)。所谓预处理宏其实是一个预处理变量,它的行为有点类似于内联函数。 assert宏使用一个表达式作为它的条件:<code>assert(expr)</code> </p>
<p>首先对expr求值,如如果表达式为假(即0), assert输出信息并终止程序的执行。如果表达式为真(即非0), assert什么也不做。</p>
<p>assert宏定义在 assert头文件中。如我们所知,预处理名字由预处理器而非编译器管理,因此我们可以直接使用预处理名字而无须提供uS1ng明。也就是说,我们应该使用 assert而不是std:: assert,也不需要为 assert提供using声明。</p>
<h4 id="NDEBUG-预处理变量"><a href="#NDEBUG-预处理变量" class="headerlink" title="NDEBUG 预处理变量"></a>NDEBUG 预处理变量</h4><p>assert的行为依赖于一个名为 NDEBUG的预处理变量的状态。如果定义了 NDEBUG,则 assert什么也不做。默认状态下没有定义 NDEBUG,此时 assert将执行运行时检查。我们可以使用一个# define语句定义 NDEBUG,从而关闭调试状态。同时,很多编译器都提供了一个命令行选项使我们可以定义预处理变量</p>
<h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><h3 id="确定候选函数和可行函数"><a href="#确定候选函数和可行函数" class="headerlink" title="确定候选函数和可行函数"></a>确定候选函数和可行函数</h3><p>函数匹配的第一步是选定本次调用对应的重载函数集,集合中的函数称为<strong>候选函数</strong>( candidate function)。候选函数具备两个特征:一是与被调用的函数同名,二是其声明在调用点可见。</p>
<p>第二步考察本次调用提供的实参,然后从候选函数中选出能被这组实参调用的函数,这些新选出的函数称为<strong>可行函数数</strong>( viable function)。可行函数也有两个特征:一是其形参数量与本次调用提供的实参数量相等,二是每个实参的类型与对应的形参类型相同,或者能转换成形参的类型。</p>
<blockquote>
<p>寻找最佳匹配</p>
</blockquote>
<p>函数匹配的第三步是从可行函数中选择与本次调用最匹配的函数。实参类型与形参类型越接近，他们匹配得越好。</p>
<blockquote>
<p>含有多个形参的函数匹配</p>
</blockquote>
<p>当实参的数量有两个或更多时,函数匹配就比较复杂了。编译器依次检査每个实参以确定哪个函数是最佳匹配。如如果有且只有个函数满足下列条件,则匹配成功・该该函数每个实参的匹配都不劣于其他可行函数需要的匹配至少有一个实参的匹配优于其他可行函数提供的匹配。如果在检査了所有实参之后没有任何一个函数脱颖而出,则则该调用是错误的。</p>
<h3 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h3><p>为了确定最佳匹配,编译器将实参类型到形参类型的转換划分成儿个等级,具体排序如</p>
<ol>
<li>精确匹配,包括以下情况:实参类型和形参类型相同・实参从数组类型或函数类型转换成对应的指针类型。向实参添加顶层 const或者从实参中删除顶层 const</li>
<li>通过 const转换实现的匹配</li>
<li>通过过类型提升实现的匹配</li>
<li>通过算术类型转换或指针转换实现的匹配。</li>
<li>通过类类型转换实现的匹配配(参见14.9节</li>
</ol>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向的是函数而非对象。和其他指针一样,函数指针指向某种特定类型，函数的类型由它的返回类型和形参类型共同决定,与函数名无关。</p>
<p>想要声明一个可以指向该函数的指针，只需要用指针替换函数名即可</p>
<p>当我们把函数名作为一个值使用时，该函数自动地转换成指针。</p>
<p>此外,我们们还能直接使用指向函数的指针调用该函数,无须提前解引用指针</p>
<blockquote>
<p>函数指针形参</p>
</blockquote>
<p>和数组类似,虽然不能定义函数类型的形参,但是形参可以是指向函数的指针。此时,形参看起来是函数类型,实际上却是当成指针使用:</p>
<blockquote>
<p>返回指向函数的指针</p>
</blockquote>
<p>和数组类似,虽然不能返回一个函数,但是能返回指向函数类型的指针。然而,我们们必须把返回类型写成指针形式,编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样,要想声明一个返回函数指针的函数,最简单的办法是使用类型别名</p>
<hr>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类的基本思想是<strong>数据抽象</strong>( data abstraction)和<strong>封装</strong>( encapsulation)。<strong>数据抽象是二种依赖于接口( interface)和实现( implementation)分离的编程程(以及设计)技术。</strong>类的接口包括用户所能执行的操作;类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。</p>
<p><strong>封装实现了类的接口和实现的分离</strong>。封装后的类隐藏了它的实现细节,也就是说,类的用户只能使用接口而无法访问实现部分。</p>
<h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><h3 id="定义类的基本"><a href="#定义类的基本" class="headerlink" title="定义类的基本"></a>定义类的基本</h3><h4 id="引入-this"><a href="#引入-this" class="headerlink" title="引入 this"></a>引入 this</h4><p>成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时,用请求该函数的对象地址初始化this</p>
<p>对于我们来说,this形参是隐式定义的。实际上,任何自定义名为this的参数或变量的行为都是非法的。我们们可以在成员函数体内部使用this因此尽管没有必要,但我们还是能把isbn定义成如下的形式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; &#125;</div></pre></td></tr></table></figure>
<h4 id="引入const-成员函数"><a href="#引入const-成员函数" class="headerlink" title="引入const 成员函数"></a>引入const 成员函数</h4><p>上面的ibsn函数的另一个关键之处是紧随参数列表之后的 const关键字,这里, const的作用是修改隐式this指针的类型。</p>
<p>默认情况下,<strong>this的类型是指向类类型非常量版本的常量指针</strong>。尽管this是隐式的,但它仍然需要遵循初始化规则,意味着(在默认情况下)我们不能把this绑定到一个常量对象上。</p>
<p>C++语言的做法是允许<strong>把 const关键字放在成员函数的参数列表之后</strong>,此时,紧跟在参数列表后面的 const表示this是一个指向常量的指针。像这样使用 const的成员函数被称作<strong>常量成员函数</strong>( const member function)。</p>
<h4 id="类作用域和成员函数"><a href="#类作用域和成员函数" class="headerlink" title="类作用域和成员函数"></a>类作用域和成员函数</h4><p>编译器分两步处理类:首先编译成员的声明,然后才轮到成员函数体(如果有的话)。因此,成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p>
<h4 id="在类外部定义成员函数"><a href="#在类外部定义成员函数" class="headerlink" title="在类外部定义成员函数"></a>在类外部定义成员函数</h4><p>当我们在类的外部定义成员函数时,成员函数的定义必须与它的声明匹配。也就是说,返回类型、参数列表和函数名都得与类内部的声明保持一致。如果<strong>成员被声明成常量成员函数,那么它的定义也必须在参数列表后明确指定 const属性</strong>。同时,类外部定义的成员的名字必须包含它所属的类名</p>
<h4 id="定义一个返回this对象的函数"><a href="#定义一个返回this对象的函数" class="headerlink" title="定义一个返回this对象的函数"></a>定义一个返回this对象的函数</h4><p>一般来说,当我们定义的函数类似于某个内置运算符时,应该令该函数的行为尽量模仿这个运算符。内置的赋值运算符把它的左側运算对象当成左值返回,因此为了与它保持一致,combine函数必须返回引用类型。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>每个类都分别定义了它的对象被初始化的方式,类通过一个或几个特殊的成员函数来控制其对象的初始化过程,这些函数叫做构造函数( constructor)。<strong>构造函数的任务是初始化类对象的数据成员,无论何时只要类的对象被创建,就会执行构造函数</strong>。</p>
<p>构造函数的名字和类名相同。和其他函数不一样的是,构造函数没有返回类型;除此之外类似于其他的函数,构造函数也有一个(可能为空的)参数列表和一个(可能为空的)函数体。类可以包含多个构造函数,和其他重载函数差不多,不同的构造函数之间必须在参数数量或参数类型上有所区别。</p>
<p>不同于其他成员函数,构造函数不能被声明成 const的</p>
<h4 id="合成的默认构造函数"><a href="#合成的默认构造函数" class="headerlink" title="合成的默认构造函数"></a>合成的默认构造函数</h4><p>我们没有为这些对象提供初始值,因此我们知道它们执行了默认初始化。<strong>类通过一个特殊的构造函数来控制默认初始化过程,这个函数叫做默认构造函数( default constructor）</strong>默认构造函数无须任何实参。</p>
<p>如我们所见,默认构造函数在很多方面都有其特殊性。其中之一是,<strong>如果我们的类没有显式地定义构造函数,那么编译器就会为我们隐式地定义一个默认构造函数</strong>。编译器创建的构造函数又被称为合成的默认构造函数( synthesized defaultconstructor)。对于大多数类来说,这个合成的默认构造函数将按照如下规则初始化类的数据成员:</p>
<ul>
<li>如果存在类内的初始值,用它来初始化成员</li>
<li>否则,默认初始化该成员。</li>
</ul>
<h4 id="某些类不能依赖于合成的默认构造函数"><a href="#某些类不能依赖于合成的默认构造函数" class="headerlink" title="某些类不能依赖于合成的默认构造函数"></a>某些类不能依赖于合成的默认构造函数</h4><p>对于一个普通的类来说,必须定义它自己的默认构造函数,原因有三:</p>
<p>第一个原因也是最容易理解的一个原因就是编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。</p>
<p>第二个原因是对于某些类来说,<strong>合成的默认构造函数可能执行错误的操作</strong>。回忆我们之前介绍过的,如果定义在块中的内置类型或复合类型(比如数组和指针)的对象被默认初始化,则它们的值将是未定义的。该准则则同样适用于默认初始化的内置类型成员。因此,含有内置类型或复合类型成员的类应该在类的内部初始化这些成员,或者定义一个自己的默认构造函数。否则,用户在创建类的对象时就可能得到未定义的值。</p>
<p>第三个原因是有的时候编译器不能为某些类合成默认的构造函数</p>
<h4 id="default的含义"><a href="#default的含义" class="headerlink" title="=default的含义"></a>=default的含义</h4><p>在C++11标准中，如果我们需要默认行为，那么可以通过在参数列表后面写上<code>=default</code>来要求编译器生成构造函数</p>
<h4 id="构造函数的初始值列表"><a href="#构造函数的初始值列表" class="headerlink" title="构造函数的初始值列表"></a>构造函数的初始值列表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>: <span class="built_in">string</span> &amp;s): bookno(s) &#123; &#125; ;</div><div class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>: <span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p):bookno(s), units_sold(n), revenue(p*n) &#123; &#125; ;</div></pre></td></tr></table></figure>
<p>这两个定义中出现了新的部分,即冒号以及冒号和花括号之间的代码,其中花括号定义了函数体。我们把新出现的部分称为<strong>构造函数初始值列表</strong>( constructor initialize list),它负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表,每个名学后面紧跟括号括起来的(或者在花括号内的)成员初始值。不同成员的初始化通过逗号分隔开来</p>
<h3 id="拷贝、赋值和析构"><a href="#拷贝、赋值和析构" class="headerlink" title="拷贝、赋值和析构"></a>拷贝、赋值和析构</h3><h4 id="某些类不能依赖于合成的版本"><a href="#某些类不能依赖于合成的版本" class="headerlink" title="某些类不能依赖于合成的版本"></a>某些类不能依赖于合成的版本</h4><p>尽管编译器能替我们合成拷贝、赋值和销毁的操作,但是必须要清楚的一点是,对于某些类来说合成的版本无法正常工作。特別是,<strong>当类需要分配类对象之外的资源时,合成的版本常常会失效</strong>。</p>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>定义在public说明符之后的成员在整个程序内可被访问,public成员定义类的接口。</p>
<p>定义在 private说明符之后的成员可以被类的成员函数访问,但是不能被使用该类的代码访问, private部分封装了(即隐藏了)类的实现细节。</p>
<blockquote>
<p>使用class 和struct关键字</p>
</blockquote>
<p>我们可以使用class和struct这两个关键字中的任何一个定义类。唯一的一点区别是, struct和class的默认访问权限不太一样。类可以在它的第一个访问说明符之前定义成员,对这种成员的访问权限依赖于类定义。<strong>如果我们使用 struct关键字,则定义在第一个访问说明符之前的成员是public的</strong>;相反,如果<strong>我们使用class关键字,则这些成员是private的</strong>。</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类可以允许其他类或者函数访问它的非公有成员,方法是令其他类或者函数成为它的友元( friend)。如果类想把一个函数作为它的友元,只需要增加一条以friend关键字开始的函数声明语句即可:</p>
<p>友元的声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类成员也不受它所在区域访问控制级别的约束</p>
<blockquote>
<p>封装有两个重要的优点<br>确保用户代码不会无意间破坏封装对象的状态。<br>被封装的类的具体实现细节可以随时改变,而无须调整用户级别的代码。</p>
</blockquote>
<p>友元的声明仅仅指定了访问的权限,而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数,那么我们就必须在友元声明之外再专门对函数进行一次声明</p>
<h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><h3 id="类成员再探"><a href="#类成员再探" class="headerlink" title="类成员再探"></a>类成员再探</h3><p>除了定义数据和函数成员之外,类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制,可以是public或者private中的一种</p>
<blockquote>
<p>令成员函数作为内联函数</p>
</blockquote>
<p>在类中,常有一些规模较小的函数适合于被声明成内联函数。如我们之前所见的,定义在类内部的成员函数是自动inline的。</p>
<p>我们可以在类的内部把inline作为声明的一部分显式地声明成员函数,同样的,也能在类的外部用inline关键字修饰函数的定义</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_13_1518491517567.jpg" alt="enter description here"></p>
<blockquote>
<p>可变数据成员</p>
</blockquote>
<p>有时(但并不频繁)会发生这样一种情况,我们希望能<strong>修改类的某个数据成员</strong>,即使是在一个 const成员函数内。可以通过在变量的声明中加入 mutable关键字做到这点</p>
<p>一个<strong>可変数据成员</strong>( mutable data member)永远不会是 const,即使它是 const对象的成员。因此,一个 const成员函数可以改变一个可变成员的值。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_13_1518491662122.jpg" alt="enter description here"></p>
<h3 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回*this的成员函数</h3><p>返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本</p>
<blockquote>
<p>基于const的重载</p>
</blockquote>
<p>通过区分成员函数是否是 const的,我们可以对其进行重载,其原因与我们之前根据指针参数是否指向 const而重载函数的原因差不多。具体说</p>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>每个类定义了唯一的类型。对于两个类来说,即使它们的成员完全一样,这两个类也是两个不同的类型。</p>
<blockquote>
<p>类的声明</p>
</blockquote>
<p>就像可以把函数的声明和定义分离开来一样,我们也能仅仅声明类而暂时不定义它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Screen;   // screen类的声明</div></pre></td></tr></table></figure></p>
<p>这种声明有时被称作<strong>前向声明</strong>( forward declaration),它向程序中引入了名字 Screen并且指明 Screen是一种类类型。对于类型 Screen来说,在它声明之后定义之前是一个不完全类型( incomplete type),也就是说,此时我们已知 Screen是一个类型,但是不清楚它到底包含哪些成员。</p>
<p>不完全类型只能在非常有限的情景下使用:可以定义指向这种类型的指针或引用,也可以声明(但是不能定义)以不完全类型作为参数或者返回类型的函数。</p>
<h3 id="友元再探"><a href="#友元再探" class="headerlink" title="友元再探"></a>友元再探</h3><p>类还可以把其他的类定义成友元,也可以把其他类(之前已定义过的)的成员函数定义成友元。此外,友元函数能定义在类的内部,这样的函数是隐式内联的。</p>
<p>如果一个类定义了友元类，则友元类的成员函数可以访问此类包括非公有函数在内的所有成员。</p>
<p><strong>友元不具备传递性</strong></p>
<blockquote>
<p>令成员函数作为友元</p>
</blockquote>
<p>除了令整个Window mgr作为友元之外, Screen还可以只为clear提供访问权限。当把一个成员函数声明成友元时,我们必须明确指出该成员函数属于哪个类:</p>
<blockquote>
<p>函数重载和友元</p>
</blockquote>
<p>尽管重载函数的名字相同,但它们仍然是不同的函数。因此,如果一个类想把一组重载函数声明成它的友元,它需要对这组函数中的每一个分别声明:</p>
<blockquote>
<p>友元声明和作用域</p>
</blockquote>
<p>类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在个友元声明中时,我们隐式地假定该名字在当前作用域中是可见的。</p>
<h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><p>每个类都会定义它自己的作用域。<strong>在类的作用域之外,普通的数据和函数成员只能由对象、引用用或者指针使用成员访问运算符来访问</strong>。对于类类型成员则使用作用域运算符访问。不论哪种情况,跟在运算符之后的名字都必须是对应类的成员</p>
<blockquote>
<p>作用域和定义在类外部的成员</p>
</blockquote>
<p>在类的外部,成员的名字被隐藏起来了。一旦遇到了类名,定义的剩余部分就在类的作用域之内了,这里的剩余部分包括参数列表和函数体。结果就是,我们可以直接使用类的其他成员而无须再次授权了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518603468039.jpg" alt="enter description here"></p>
<p>另一方面,函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时,返回类型中使用的名字都位于类的作用域之外。这时,返回类型必须指明它是哪个类的成员。</p>
<h3 id="名字查找和类的作用域"><a href="#名字查找和类的作用域" class="headerlink" title="名字查找和类的作用域"></a>名字查找和类的作用域</h3><p><strong>名字查找( name lookup)</strong>(寻找与所用名字最匹配的声明的过程)的过程比较直截了当:</p>
<ul>
<li>首先,在名字所在的块中寻找其声明语句,只考虑在名字的使用之前出现的声明。</li>
<li>如果没找到,继续查找外层作用域。</li>
<li>如果最终没有找到匹配的声明,则程序报错。</li>
</ul>
<p>一般来说,内层作用域可以重新定义外层作用域中的名字,即使该名字已经在内层作用域中使用过。然而在类中,如果成员使用了外层作用域中的某个名字,而该名字代表种类型,则类不能在之后重新定义该名字:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518603659447.jpg" alt="enter description here"></p>
<h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><blockquote>
<p>构造函数的初始值有时必不可少</p>
</blockquote>
<p>有时我们可以忽略数据成员初始化和赋值之间的差异,但并非总能这样。<strong>如果成员是const或者是引用的话,必须将其初始化</strong>。类似的,当成员属于某种类类型且该类没有定义默认构造函数时,也必须将这个成员初始化。</p>
<p>一些数据成员必须初始化，建议养成使用构造函数初始化值的习惯</p>
<blockquote>
<p>成员初始化的顺序</p>
</blockquote>
<p>构造函数初始值列表只说明用于初始化成员的值,而不限定初始化的具体执行顺序。</p>
<p><strong>成员的初始化顺序与它们在类定义中的出现顺序一致</strong>:第一个成员先被初始化,然后第二个,以此类推。<strong>构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序</strong>。</p>
<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>C++11新标准扩展了构造函数初始值的功能,使得我们可以定义所谓的<strong>委托构造函数</strong>( delegating constructor)。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程,或者说它把它自自己的一些(或者全部)职责委托给了其他构造函数。</p>
<p>和其他构造函数一样,一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数内,成员初始值列表只有一个唯一的入口,就是类名本身。和其他成员初始值一样,类名后面紧跟圆括号括起来的参数列表,参数列表必须与类中另外一个构造函数匹配。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518610183005.jpg" alt="enter description here"></p>
<h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><p>我们能为类定义隐式转换规则。如果<strong>构造函数只接受一个实参,则它实际上定义了转换为此类类型的隐式转换机制</strong>,有时我们]把这种构造函数称作<strong>转换构造函数</strong></p>
<blockquote>
<p>抑制构造函数定义的隐式转换</p>
</blockquote>
<p>在要求隐式转换的程序上下文中,我们们可以通过将构造函数声明为explicit加以阻止:</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518610514067.jpg" alt="enter description here"></p>
<h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p>聚合类( aggregate class)使得用户可以直接访问其成员,并且具有特殊的初始化语法形式。当一个类满足如下条件时,我们说它是聚合的:</p>
<ul>
<li>所有成员都是public的</li>
<li>没有定义任何构造函数。</li>
<li>没有类内初始值</li>
<li>没有基类,也没有 virtual函数,关于这部分知识我们将在第15章详细介绍</li>
</ul>
<h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><p><strong>数据成员都是字面值类型的聚合类</strong>是字面值常量类。如果一个类不是聚合类,但它符合下述要求,则它也是一个字面值常量类</p>
<ul>
<li>数据成员都必须是字面值类型。</li>
<li>类必须至少含有一个 constexpr构造造函数。</li>
<li>如果一个数据成员含有类内初始值,则内置类型成员的初始值必须是一条常量表达式;或者如果成员属于某种类类型,则初始值必须使用成员自己的 constexpr构造函数</li>
<li>类必须使用析构函数的默认定义,该成员负责销毀类的对象</li>
</ul>
<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。</p>
<blockquote>
<p>声明静态成员</p>
</blockquote>
<p>我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员样,静态成员可以是 public的或 private的。静态数据成员的类型可以是常量、引用、指针、类型等</p>
<p>我们使用作用域运算符直接访问静态成员：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> r;</div><div class="line">r = Account::rate();</div></pre></td></tr></table></figure></p>
<blockquote>
<p>定义静态成员</p>
</blockquote>
<p>和其他的成员函数一样,我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时,不能重复 static关键字,该关键字只出现在类内部的声明语句:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Account::rate( <span class="keyword">double</span> newRate)</div><div class="line">&#123;</div><div class="line">	interesRate = newRate;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>我们不能在类的内部初始化静态成员。相反的,必须在类的外部定义和初始化每个静态成员。</p>
<blockquote>
<p>静态成员的类内初始化</p>
</blockquote>
<p>通常情况下・类的静态成员不应该在类的内部初始化。然而,我们可以为静态成员提供 const整数类型的类内初始值,不过要求静态成员必须是字面值常量类型的constexpr</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》笔记 C++基础部分&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C/C++" scheme="https://www.liuin.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 配置反向代理</title>
    <link href="https://www.liuin.cn/2018/02/14/Nginx-%E9%85%8D%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>https://www.liuin.cn/2018/02/14/Nginx-配置反向代理/</id>
    <published>2018-02-14T05:26:06.000Z</published>
    <updated>2018-02-23T04:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>近段时间遇到一个问题：有多个服务要放在一个主机上，但是想用域名来区分这些服务而不是端口号（就像IP地址一样，没有人愿意记端口号）。后面找到了Nginx配置反向代理这个解决方案，这里总结一下。</p>
<a id="more"></a>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>一个Web应用的基本通信流程是：客户端（client）发送一个请求（request）给服务器（server），然后服务器根据请求返回相应的响应（response）给客户端。</p>
<p>那么代理的作用就是让一个机器来替我们发送请求或者返回响应，在客户端替我们发送请求的代理称为正向代理；在服务器替我们接受请求返回响应的代理称为反向代理。</p>
<p>正向代理：client —(send request)—&gt; clinet proxy –(send request)—&gt; server<br>反向代理：clinet –(send request)–&gt; server proxy –(send request)–&gt;other server</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_14_1518583313864.jpg" alt="正向代理和反向代理示意图"></p>
<h2 id="Nginx-配置反向代理"><a href="#Nginx-配置反向代理" class="headerlink" title="Nginx 配置反向代理"></a>Nginx 配置反向代理</h2><p>使用Nginx配置反向代理需要用到的配置模块有http模块、server模块、location模块、upstream模块</p>
<h3 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h3><p>http模块负责<strong>HTTP服务器相关属性的配置</strong>，它里面有server和upstream子模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">	# include用来设定文件的mime类型,类型在配置文件目录下的mime.type文件定义，来告诉nginx来识别文件类型。</div><div class="line">    include mime.types;</div><div class="line">    </div><div class="line">	# default_type 设定了默认的类型为二进制流，也就是当文件类型未定义时使用这种方式</div><div class="line">	default_type application/octet-stream;</div><div class="line">	</div><div class="line">	# log_format 用于设置日志的格式，和记录哪些参数</div><div class="line">    log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</div><div class="line">                    &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</div><div class="line">                    &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</div><div class="line">					</div><div class="line">	# 纪录每次的访问日志的文件地址，后面的main是日志的格式样式，对应于log_format的main。</div><div class="line">    access_log /usr/local/var/log/nginx/access.log  main;</div><div class="line">	</div><div class="line">	# sendfile开启高效文件传输模式。将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞。</div><div class="line">    sendfile on;</div><div class="line">    tcp_nopush on;</div><div class="line">    tcp_nodelay on;</div><div class="line">	</div><div class="line">	# keepalive设置客户端连接保持活动的超时时间。在超过这个时间之后，服务器会关闭该连接。</div><div class="line">    keepalive_timeout 10;</div><div class="line">    #gzip on;</div><div class="line">    upstream myproject &#123;</div><div class="line">        .....</div><div class="line">    &#125;</div><div class="line">    server &#123;</div><div class="line">        ....</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="server模块"><a href="#server模块" class="headerlink" title="server模块"></a>server模块</h3><p>为http模块的子模块，定义一个虚拟主机。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">	# listen 指定虚拟主机监听的服务端口</div><div class="line">    listen 8080;</div><div class="line">	</div><div class="line">	# server_name 用来指定IP地址或者域名，多个域名之间用空格分开</div><div class="line">    server_name localhost 192.168.12.10 www.yangyi.com;</div><div class="line">    </div><div class="line">	# 全局定义，如果都是这一个目录，这样定义最简单。</div><div class="line">    # root 表示在这整个server虚拟主机内，全部的root web根目录。</div><div class="line">	root   /Users/yangyi/www;</div><div class="line">	# index 全局定义访问的默认首页地址。</div><div class="line">    index  index.php index.html index.htm; </div><div class="line">	# charset 用于设置网页的默认编码格式。</div><div class="line">    charset utf-8;</div><div class="line">	# access_log 用来指定此虚拟主机的访问日志存放路径，最后的main用于指定访问日志的输出格式。</div><div class="line">    access_log  usr/local/var/log/host.access.log  main;</div><div class="line">    error_log  usr/local/var/log/host.error.log  error;</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="upstream模块"><a href="#upstream模块" class="headerlink" title="upstream模块"></a>upstream模块</h3><p>负责负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">upstream iyangyi.com&#123;</div><div class="line">    ip_hash;</div><div class="line">    server 192.168.12.1:80;</div><div class="line">    server 192.168.12.2:80 down;</div><div class="line">    server 192.168.12.3:8080  max_fails=3  fail_timeout=20s;</div><div class="line">    server 192.168.12.4:8080;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>通过upstream指令指定了一个负载均衡器的名称iyangyi.com。这个名称可以任意指定，在后面需要的地方直接调用即可。</li>
<li>ip_hash这是其中的一种负载均衡调度算法，下面会着重介绍。</li>
<li>紧接着就是各种服务器了。用server关键字表识，后面接ip。</li>
</ul>
<p>Nginx负载均衡模块支持的4种调度算法：</p>
<ul>
<li><strong>weight 轮询</strong>（默认）。每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。weight。指定轮询权值，weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。</li>
<li><strong>ip_hash</strong>。每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。</li>
<li><strong>fair（第三方）</strong>。比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。</li>
<li><strong>url_hash（第三方）</strong>。按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx的hash软件包。</li>
</ul>
<h3 id="location模块"><a href="#location模块" class="headerlink" title="location模块"></a>location模块</h3><p>location模块使用来定位URL、解析URL的，指明定位到的URL的功能是什么。提供了强大的正则匹配功能，也支持条件判断匹配，用户可以通过location指令实现Nginx对动、静态网页进行过滤处理。</p>
<p>最简单的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    root   /Users/yangyi/www;</div><div class="line">    index  index.php index.html index.htm;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>location / 表示匹配根目录</li>
<li>root 指令用于指定访问根目录时，虚拟主机的web目录</li>
<li>index 用于设定我们只输入域名后访问的默认首页地址</li>
</ul>
<p>当我们需要进行反向代理的时候，主要配置也是在这里的，其使用的是location模块下的proxy_pass选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">	proxy_pass          https://gist.github.com;</div><div class="line">	proxy_cache_valid   200 302 1h;</div><div class="line">	proxy_cache_valid   404 1m;</div><div class="line">	proxy_cache_use_stale error timeout invalid_header updating</div><div class="line">		http_500 http_502 http_503 http_504;</div><div class="line">	proxy_set_header    Accept-Encoding &quot;&quot;;</div><div class="line">	proxy_set_header    Accept-Language &quot;zh-CN&quot;;</div><div class="line">	proxy_set_header    User-Agent $http_user_agent;</div><div class="line">	sub_filter  https://gist-assets.github.com/ http://gist.example.com;</div><div class="line">	sub_filter  https://gist.github.com/ http://gist.example.com;</div><div class="line">	sub_filter_once     off;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>proxy_pass 指定反向代理的地址</li>
<li>proxy_set_header 设置 HTTP 请求头，Accept-Encoding “” 表示拒绝任何压缩，这保证了服务器返回给反向代理的内容是未经压缩的，以便进行 URL 替换</li>
<li>proxy_set_header 设置 HTTP 请求头，语言设置</li>
<li>proxy_set_header 设置 HTTP 请求头，设置 UA</li>
<li>sub_filter URL 替换</li>
<li>sub_filter_once 被关闭，替换所有可替换的内容</li>
</ul>
<h2 id="反向代理作用"><a href="#反向代理作用" class="headerlink" title="反向代理作用"></a>反向代理作用</h2><ul>
<li>保护了真实的web服务器，web服务器对外不可见，外网只能看到反向代理服务器，而反向代理服务器上并没有真实数据，因此，保证了web服务器的资源安全</li>
<li>负载均衡，最大化服务器集群的效率</li>
<li>请求的统一控制，包括设置权限、过滤规则等；</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>配置本地主机<code>gist.example.com</code>到github的<code>gist.github.com</code>的server模块配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen  80;</div><div class="line">    server_name gist.example.com;</div><div class="line">    access_log  off;</div><div class="line">    resolver    8.8.8.8;</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass          https://gist.github.com;</div><div class="line">        proxy_cache_valid   200 302 1h;</div><div class="line">        proxy_cache_valid   404 1m;</div><div class="line">        proxy_cache_use_stale error timeout invalid_header updating</div><div class="line">            http_500 http_502 http_503 http_504;</div><div class="line">        proxy_set_header    Accept-Encoding &quot;&quot;;</div><div class="line">        proxy_set_header    Accept-Language &quot;zh-CN&quot;;</div><div class="line">        proxy_set_header    User-Agent $http_user_agent;</div><div class="line">        sub_filter  https://gist-assets.github.com/ http://gist.example.com;</div><div class="line">        sub_filter  https://gist.github.com/ http://gist.example.com;</div><div class="line">        sub_filter_once     off;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>井号开头的行是注释</li>
<li>server 开始了 server 块</li>
<li>listen 表明 Nginx 将会在 80 端口监听</li>
<li>server_name 是我们给反向代理配置的域名，访问这个域名就相当于访问 Gist</li>
<li>access_log 是日志文件的配置，这里为了简化我将它关掉了</li>
<li>resolver 是 DNS 服务器</li>
<li>location 块具体配置反向代理的行为</li>
<li>proxy_pass 说明将会将请求转发至 Gist</li>
<li>proxy_cache_valid 配置缓存</li>
<li>proxy_cache_valid 同上</li>
<li>proxy_cache_use_stale 同上</li>
<li>proxy_set_header 设置 HTTP 请求头，Accept-Encoding “” 表示拒绝任何压缩，这保证了服务器返回给反向代理的内容是未经压缩的，以便进行 URL 替换</li>
<li>proxy_set_header 设置 HTTP 请求头，语言设置</li>
<li>proxy_set_header 设置 HTTP 请求头，设置 UA</li>
<li>sub_filter URL 替换</li>
<li>sub_filter 同上</li>
<li>sub_filter_once 被关闭，替换所有可替换的内容</li>
</ul>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a href="https://liam0205.me/2015/09/07/reverse-proxy-to-get-access-to-gist/" target="_blank" rel="external">https://liam0205.me/2015/09/07/reverse-proxy-to-get-access-to-gist/</a></li>
<li><a href="https://www.jianshu.com/p/bed000e1830b" target="_blank" rel="external">https://www.jianshu.com/p/bed000e1830b</a></li>
<li><a href="http://blog.csdn.net/physicsdandan/article/details/45667357" target="_blank" rel="external">http://blog.csdn.net/physicsdandan/article/details/45667357</a></li>
<li><a href="https://paste.ubuntu.com/p/jZ8tBwGYcM/" target="_blank" rel="external">nginx配置整理（含注释）</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近段时间遇到一个问题：有多个服务要放在一个主机上，但是想用域名来区分这些服务而不是端口号（就像IP地址一样，没有人愿意记端口号）。后面找到了Nginx配置反向代理这个解决方案，这里总结一下。&lt;/p&gt;
    
    </summary>
    
      <category term="运维" scheme="https://www.liuin.cn/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Nginx" scheme="https://www.liuin.cn/tags/Nginx/"/>
    
      <category term="代理" scheme="https://www.liuin.cn/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Git 内部原理</title>
    <link href="https://www.liuin.cn/2018/02/11/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/"/>
    <id>https://www.liuin.cn/2018/02/11/Git-内部原理/</id>
    <published>2018-02-11T13:39:14.000Z</published>
    <updated>2018-02-23T04:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>《Pro Git》读书笔记</p>
<a id="more"></a>
<p>从根本上来讲 Git 是一个内容寻址（content-addressable）文件系统</p>
<h2 id="底层命令和高层命令"><a href="#底层命令和高层命令" class="headerlink" title="底层命令和高层命令"></a>底层命令和高层命令</h2><p>由于 Git 最初是一套面向版本控制系统的工具集，而不是一个完整的、用户友好的版本控制系统，所以它还包含了一部分用于完成底层工作的命令。这些命令被设计成能以 UNIX 命令行的风格连接在一起，抑或藉由脚本调用，来完成工作。这部分命令一般被称作“<strong>底层（plumbing）”命令</strong>，而那些更友好的命令则被称作“高层（porcelain）”命令。</p>
<p>当在一个新目录或已有目录执行 git init 时，Git 会创建一个 .git 目录。这个目录包含了几乎所有 Git 存储和操作的对象。如若想备份或复制一个版本库，只需把这个目录拷贝至另一处即可。</p>
<p>目录结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ ls -F1</div><div class="line">index				# 保存暂存区信息</div><div class="line">HEAD				# 指示目前被检出的分支</div><div class="line">config*				# 包含项目特有的配置项</div><div class="line">description			# 仅供GitWeb使用</div><div class="line">hooks/				# 包含hook钩子脚本</div><div class="line">info/				# 包含全局性排除（global exclude）文件</div><div class="line">objects/			# 存储所有的数据内容</div><div class="line">refs/				# 存储指向数据（分支）的提交对象的指针</div></pre></td></tr></table></figure></p>
<h2 id="Git-对象"><a href="#Git-对象" class="headerlink" title="Git 对象"></a>Git 对象</h2><p>Git 是一个内容寻址文件系统。Git 的核心部分是一个简单的键值对数据库（key-value data store）。你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。</p>
<h3 id="树对象"><a href="#树对象" class="headerlink" title="树对象"></a>树对象</h3><p>树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起。Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。所有内容均以树对象和数据对象的形式存储，其中<strong>树对象对应了 UNIX 中的目录项</strong>，<strong>数据对象则大致上对应了 inodes 或文件内容</strong>。一个树对象包含了一条或多条树对象记录（tree entry），<strong>每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息</strong>。</p>
<p>通常，Git 根据某一时刻暂存区（即 index 区域，下同）所表示的状态创建并记录一个对应的树对象，如此重复便可依次记录（某个时间段内）一系列的树对象。因此，为创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。</p>
<h3 id="提交对象"><a href="#提交对象" class="headerlink" title="提交对象"></a>提交对象</h3><p>提交对象的格式很简单：它先指定一个顶层树对象，代表当前项目快照；然后是作者/提交者信息（依据你的user.name 和 user.email 配置来设定，外加一个时间戳）；留空一行，最后是提交注释</p>
<p>每次我们运行 git add 和 git commit 命令时， Git 所做的实质工作——<strong>将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。</strong>这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 .git/objects 目录下。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_11_1518354037927.jpg" alt="enter description here"></p>
<h3 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h3><p>在存储内容时，会有个头部信息一并被保存。让我们略花些时间来看看 Git 是如何存储其对象的。</p>
<p>所有的 Git 对象均以这种方式存储，区别仅在于类型标识——另两种对象类型的头部信息以字符串“commit”或“tree”开头，而不是“blob”。另外，虽然数据对象的内容几乎可以是任何东西，但提交对象和树对象的内容却有各自固定的格式。</p>
<h2 id="Git-引用"><a href="#Git-引用" class="headerlink" title="Git 引用"></a>Git 引用</h2><p>为了能遍历那段历史从而找到所有相关对象，你仍须记住 1a410e 是最后一个提交。我们需要一个文件来保存 SHA-1 值，并<strong>给文件起一个简单的名字，然后用这个名字指针来替代原始的 SHA-1 值</strong>。在 Git 里，这样的文件被称为“引用（references，或缩写为 refs）”；你可以在 .git/refs 目录下找到这类含有 SHA-1 值的文件。</p>
<p> <strong>Git 分支的本质：一个指向某一系列提交之首的指针或引用</strong>。</p>
<h3 id="HEAD引用"><a href="#HEAD引用" class="headerlink" title="HEAD引用"></a>HEAD引用</h3><p> HEAD 文件是一个符号引用（symbolic reference），指向目前所在的分支。所谓符号引用，意味着它并不像普通引用那样包含一个 SHA-1 值——它是一个<strong>指向其他引用的指针</strong>。</p>
<p>当我们执行 git commit 时，该命令会创建一个提交对象，并用 HEAD 文件中那个引用所指向的 SHA-1 值设置其父提交字段</p>
<h3 id="标签引用"><a href="#标签引用" class="headerlink" title="标签引用"></a>标签引用</h3><p>前文我们刚讨论过 Git 的三种主要对象类型，事实上还有第四种。标签对象（tag object）非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。主要的区别在于，<strong>标签对象通常指向一个提交对象，而不是一个树对象</strong>。它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。</p>
<p>存在两种类型的标签：附注标签和轻量标签。轻量标签的全部内容——一个固定的引用。一个附注标签则更复杂一些。若要创建一个附注标签，Git 会创建一个标签对象，并记录一个引用来指向该标签对象，而不是直接指向提交对象。</p>
<h3 id="远程引用"><a href="#远程引用" class="headerlink" title="远程引用"></a>远程引用</h3><p>第三种引用类型是远程引用（remote reference）。如果你添加了一个远程版本库并对其执行过推送操作，Git 会记录下最近一次推送操作时每一个分支所对应的值，并保存在 refs/remotes 目录下</p>
<p>远程引用和分支（位于 refs/heads 目录下的引用）之间最主要的区别在于，远程引用是只读的。虽然可以git checkout 到某个远程引用，但是 Git 并不会将 HEAD 引用指向该远程引用。</p>
<h2 id="包文件"><a href="#包文件" class="headerlink" title="包文件"></a>包文件</h2><p>Git 最初向磁盘中存储对象时所使用的格式被称为<strong>“松散（loose）”对象格式</strong>。但是，Git 会时不时地<strong>将多个这些对象打包成一个称为“包文件（packfile）</strong>”的二进制文件，以节省空间和提高效率。当版本库中有太多的松散对象，或者你手动执行 git gc 命令，或者你向远程服务器执行推送时，Git 都会这样做。</p>
<p>包文件包含了刚才从文件系统中移除的所有对象的内容。索引文件包含了包文件的偏移信息，我们通过索引文件就可以快速定位任意一个指定对象。</p>
<p>同样有趣的地方在于，最新版本完整保存了文件内容，而原始的版本反而是以差异方式保存的——这是因为大部分情况下需要快速访问文件的最新版本。</p>
<h2 id="引用规格"><a href="#引用规格" class="headerlink" title="引用规格"></a>引用规格</h2><p>我们已经使用过一些诸如远程分支到本地引用的简单映射方式，但这种映射可以更复杂。</p>
<p>添加一个远程版本库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[remote &quot;origin&quot;]</div><div class="line">url = https://github.com/schacon/simplegit-progit</div><div class="line">fetch = +refs/heads/*:refs/remotes/origin/*</div></pre></td></tr></table></figure></p>
<p>引用规格的格式由一个可选的 + 号和紧随其后的 \<src>:\<dst> 组成，其中 \<src> 是一个模式（pattern），代表远程版本库中的引用；\<dst> 是那些远程引用在本地所对应的位置。+ 号告诉 Git 即使在不能快进的情况下也要（强制）更新引用</dst></src></dst></src></p>
<h3 id="引用规格推送"><a href="#引用规格推送" class="headerlink" title="引用规格推送"></a>引用规格推送</h3><p>如果 QA 团队想把他们的 master 分支推送到远程服务器的 qa/master 分支上，可以运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin master:refs/heads/qa/master</div></pre></td></tr></table></figure></p>
<p>如果他们希望 Git 每次运行 git push origin 时都像上面这样推送，可以在他们的配置文件中添加一条 push值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[remote &quot;origin&quot;]</div><div class="line">url = https://github.com/schacon/simplegit-progit</div><div class="line">fetch = +refs/heads/*:refs/remotes/origin/*</div><div class="line">push = refs/heads/master:refs/heads/qa/master</div></pre></td></tr></table></figure></p>
<h3 id="删除引用"><a href="#删除引用" class="headerlink" title="删除引用"></a>删除引用</h3><p>你还可以借助类似下面的命令通过引用规格从远程服务器上删除引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin :topic</div></pre></td></tr></table></figure></p>
<p>因为引用规格（的格式）是 \<src>:\<dst>，所以上述命令把 \<src> 留空，意味着把远程版本库的 topic 分支<br>定义为空值，也就是删除它。</src></dst></src></p>
<h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h2><p>Git 可以通过两种主要的方式在版本库之间传输数据：“哑（dumb）”协议和“智能（smart）”协议。</p>
<h3 id="哑协议"><a href="#哑协议" class="headerlink" title="哑协议"></a>哑协议</h3><p>如果你正在架设一个基于 HTTP 协议的只读版本库，一般而言这种情况下使用的就是哑协议。</p>
<h3 id="智能协议"><a href="#智能协议" class="headerlink" title="智能协议"></a>智能协议</h3><p>智能协议是更常用的传送数据的方法，但它需要在服务端运行一个进程，而这也是 Git 的智能之处——它可以读取本地数据，理解客户端有什么和需要什么，并为它生成合适的包文件。总共有两组进程用于传输数据，它们分别负责上传和下载数据。</p>
<h2 id="维护与数据恢复"><a href="#维护与数据恢复" class="headerlink" title="维护与数据恢复"></a>维护与数据恢复</h2><h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><p>Git 会不定时地自动运行一个叫做 “auto gc” 的命令。大多数时候，这个命令并不会产生效果。然而，如果有太多松散对象（不在包文件中的对象）或者太多包文件，Git 会运行一个完整的 git gc 命令。“gc” 代表垃圾回收，这个命令会做以下事情：收集所有松散对象并将它们放置到包文件中，将多个包文件合并为一个大的包文件，移除与任何提交都不相关的陈旧对象。</p>
<h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>在你使用 Git 的时候，你可能会意外丢失一次提交。通常这是因为你强制删除了正在工作的分支，但是最后却发现你还需要这个分支；亦或者硬重置了一个分支，放弃了你想要的提交。如果这些事情已经发生，该如何找回你的提交呢？</p>
<p>最方便，也是最常用的方法，是使用一个名叫 <code>git reflog</code> 的工具。当你正在工作时，Git 会默默地记录每一次你改变 HEAD 时它的值。每一次你提交或改变分支，引用日志都会被更新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Pro Git》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="https://www.liuin.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>自定义 Git</title>
    <link href="https://www.liuin.cn/2018/02/10/%E8%87%AA%E5%AE%9A%E4%B9%89-Git/"/>
    <id>https://www.liuin.cn/2018/02/10/自定义-Git/</id>
    <published>2018-02-10T06:08:31.000Z</published>
    <updated>2018-02-23T04:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>《Pro Git》读书笔记</p>
<a id="more"></a>
<h2 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h2><p>Git使用一系列配置来保存你自定义的行为：</p>
<ul>
<li>它首先会查找 /etc/gitconfig 文件，该文件含有系统里每位用户及他们所拥有的仓库的配置值。如果你传递 –system 选项给 git config，它就会读写该文件</li>
<li>接下来 Git 会查找每个用户的 ~/.gitconfig 文件（或者 ~/.config/git/config 文件）。你可以传递–global 选项让 Git 读写该文件。</li>
<li>最后 Git 会查找你正在操作的版本库所对应的 Git 目录下的配置文件（.git/config）。这个文件中的值只对该版本库有效。</li>
</ul>
<p>以上三个层次中每层的配置（系统、全局、本地）都会覆盖掉上一层次的配置，所以 .git/config 中的值会覆盖掉 /etc/gitconfig 中所对应的值。</p>
<h3 id="客户端基本配置"><a href="#客户端基本配置" class="headerlink" title="客户端基本配置"></a>客户端基本配置</h3><ul>
<li>core.editor</li>
</ul>
<p>默认情况下，Git 会调用环境变量（$VISUAL 或 $EDITOR）设置的任意文本编辑器，如果没有设置，会调用 vi来创建和编辑你的提交以及标签信息。你可以使用 core.editor 选项来修改默认的编辑器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global core.editor emacs</div></pre></td></tr></table></figure></p>
<ul>
<li>commit.tmplate</li>
</ul>
<p>如果把此项指定为你的系统上某个文件的路径，当你提交的时候， Git 会使用该文件的内容作为提交的默认信息。</p>
<ul>
<li>core.pager</li>
</ul>
<p>该配置项指定 Git 运行诸如 log 和 diff 等命令所使用的分页器。你可以把它设置成用 more 或者任何你喜欢的分页器（默认用的是 less），当然也可以设置成空字符串，关闭该选项</p>
<ul>
<li>user.signingkey</li>
</ul>
<p>如果你要创建经签署的含附注的标签（正如 签署工作 所述），那么把你的 GPG 签署密钥设置为配置项会更好。</p>
<ul>
<li>core.excludesfile</li>
</ul>
<p>正如 忽略文件 所述，你可以在你的项目的 .gitignore 文件里面规定无需纳入 Git 管理的文件的模板，这样它们既不会出现在未跟踪列表，也不会在你运行 git add 后被暂存。不过有些时候，你想要在你所有的版本库中忽略掉某一类文件。</p>
<ul>
<li>help.autocorrect</li>
</ul>
<p>Git 会尝试猜测你的意图，但是它不会越俎代庖。如果你把 help.autocorrect 设置成 1，那么只要有一个命令被模糊匹配到了，Git 会自动运行该命令。</p>
<blockquote>
<p>Git 中的着色</p>
</blockquote>
<p>Git 充分支持对终端内容着色，对你凭肉眼简单、快速分析命令输出有很大帮助。你可以设置许多的相关选项来满足自己的偏好。</p>
<ul>
<li>color.ui </li>
</ul>
<p>Git 会自动着色大部分输出内容，但如果你不喜欢花花绿绿，也可以关掉。这个设置的默认值是 auto。</p>
<ul>
<li>color.*</li>
</ul>
<p>要想具体到哪些命令输出需要被着色以及怎样着色，你需要用到和具体命令有关的颜色配置选项。它们都能被置为 true、false 或 always：</p>
<blockquote>
<p>格式化和多余空白字符</p>
</blockquote>
<p>格式化与多余的空白字符是许多开发人员在协作时，特别是在跨平台情况下，不时会遇到的令人头疼的琐碎的问题。由于编辑器的不同或者文件行尾的换行符在 Windows 下被替换了，一些细微的空格变化会不经意地混入提交的补丁或其它协作成果中。不用怕，Git 提供了一些配置项来帮助你解决这些问题。</p>
<ul>
<li>core.autocrlf</li>
</ul>
<p>Git 可以在你提交时自动地把回车和换行转换成换行，而在检出代码时把换行转换成回车和换行。你可以用core.autocrlf 来打开此项功能。如果是在 Windows 系统上，把它设置成 true，这样在检出代码时，换行会被转换成回车和换行：</p>
<p>如果使用以换行作为行结束符的 Linux 或 Mac，你不需要 Git 在检出文件时进行自动的转换；然而当一个以回车加换行作为行结束符的文件不小心被引入时，你肯定想让 Git 修正。你可以把 core.autocrlf 设置成 input 来告诉 Git 在提交时把回车和换行转换成换行，检出时不转换：</p>
<ul>
<li>core.whitespace</li>
</ul>
<p>Git 预先设置了一些选项来探测和修正多余空白字符问题。它提供了六种处理多余空白字符的主要选项 —— 其中三个默认开启，另外三个默认关闭，不过你可以自由地设置它们。</p>
<p>默认被打开的三个选项是：blank-at-eol，查找行尾的空格；blank-at-eof，盯住文件底部的空行；space-before-tab，警惕行头 tab 前面的空格。</p>
<p>默认被关闭的三个选项是：indent-with-non-tab，揪出以空格而非 tab 开头的行（你可以用 tabwidth 选项控制它）；tab-in-indent，监视在行头表示缩进的 tab；cr-at-eol，告诉 Git 忽略行尾的回车。</p>
<h3 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h3><ul>
<li>receive.fsckObjects</li>
</ul>
<p>Git 能够确认每个对象的有效性以及 SHA-1 检验和是否保持一致。但 Git 不会在每次推送时都这么做。设置 receive.fsckObjects 为 true 来强迫它这么做</p>
<ul>
<li>receive.denyNonFastForwards</li>
</ul>
<p>如果你变基已经被推送的提交，继而再推送，又或者推送一个提交到远程分支，而这个远程分支当前指向的提交不在该提交的历史中，这样的推送会被拒绝。这通常是个很好的策略，但有时在变基的过程中，你确信自己需要更新远程分支，可以在 push 命令后加 -f 标志来强制更新（force-update）。</p>
<p>要禁用这样的强制更新推送（force-pushes），可以设置 receive.denyNonFastForwards：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --system receive.denyNonFastForwards true</div></pre></td></tr></table></figure></p>
<ul>
<li>receive.denyDeletes</li>
</ul>
<p>有一些方法可以绕过 denyNonFastForwards 策略。其中一种是先删除某个分支，再连同新的引用一起推送回该分支。把 receive.denyDeletes 设置为 true 可以把这个漏洞补上：</p>
<h2 id="Git-属性"><a href="#Git-属性" class="headerlink" title="Git 属性"></a>Git 属性</h2><p>你也可以针对特定的路径配置某些设置项，这样 Git 就只对特定的子目录或子文件集运用它们。这些基于路径的设置项被称为 Git 属性，可以在你的目录下的 .gitattributes 文件内进行设置（通常是你的项目的根目录）。如果不想让这些属性文件与其它文件一同提交，你也可以在 .git/info/attributes 文件中进行设置。</p>
<p>通过使用属性，你可以对项目中的文件或目录单独定义不同的合并策略，让 Git 知道怎样比较非文本文件，或者让 Git 在提交或检出前过滤内容。</p>
<h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><p>你可以用 Git 属性让 Git 知道哪些是二进制文件（以防它没有识别出来），并指示其如何处理这些文件。</p>
<blockquote>
<p>识别二进制文件</p>
</blockquote>
<p>要让 Git 把所有 pbxproj 文件当成二进制文件，在 .gitattributes 文件中如下设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*.pbxproj binary</div></pre></td></tr></table></figure></p>
<p>现在，Git 不会尝试转换或修正回车换行（CRLF）问题，当你在项目中运行 git show 或 git diff 时，Git 也不会比较或打印该文件的变化</p>
<blockquote>
<p>比较二进制文件</p>
</blockquote>
<p>可以使用 Git 属性来有效地比较两个二进制文件。秘诀在于，告诉 Git 怎么把你的二进制文件转化为文本格式，从而能够使用普通的 diff 方式进行对比。</p>
<p>把下面这行文本加到你的 .gitattributes 文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*.docx diff=word</div></pre></td></tr></table></figure></p>
<p>这告诉 Git 当你尝试查看包含变更的比较结果时，所有匹配 .docx 模式的文件都应该使用“word”过滤器。“word”过滤器是什么？我们现在就来设置它。我们会对 Git 进行配置，令其能够借助 docx2txt 程序将Word 文档转为可读文本文件，这样不同的文件间就能够正确比较了。</p>
<h3 id="关键字展开"><a href="#关键字展开" class="headerlink" title="关键字展开"></a>关键字展开</h3><p>Git 属性提供了另一种方法：我们可以编写自己的过滤器来实现文件提交或检出时的关键字替换。</p>
<h3 id="导出版本库"><a href="#导出版本库" class="headerlink" title="导出版本库"></a>导出版本库</h3><p>当归档的时候，可以设置 Git 不导出某些文件和目录。如果你不想在归档中包含某个子目录或文件，但想把它们纳入项目的版本管理中，你可以在 export-ignore 属性中指定它们。</p>
<p>例如，假设你在 test/ 子目录下有一些测试文件，不希望它们被包含在项目导出的压缩包（tarball）中。你可以增加下面这行到 Git 属性文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test/ export-ignore</div></pre></td></tr></table></figure>
<h3 id="合并策略"><a href="#合并策略" class="headerlink" title="合并策略"></a>合并策略</h3><p>你还能对项目中的特定文件指定不同的合并策略。一个非常有用的选项就是，告诉 Git 当特定文件发生冲突时不要尝试合并它们，而是直接使用你这边的内容</p>
<h2 id="Git-钩子"><a href="#Git-钩子" class="headerlink" title="Git 钩子"></a>Git 钩子</h2><p>Git 能在<strong>特定的重要动作发生时触发自定义脚本</strong>。有两组这样的钩子：客户端的和服务器端的。客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。</p>
<h3 id="安装一个钩子"><a href="#安装一个钩子" class="headerlink" title="安装一个钩子"></a>安装一个钩子</h3><p>钩子都被存储在 Git 目录下的 hooks 子目录中。也即绝大部分项目中的 .git/hooks 。当你用 git init 初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。这些脚本除了本身可以被调用外，它们还透露了被触发时所传入的参数。所有的示例都是 shell 脚本，其中一些还混杂了 Perl 代码，不过，<strong>任何正确命名的可执行脚本都可以正常使用</strong> —— 你可以用 Ruby 或 Python，或其它语言编写它们。这些示例的名字都是以.sample 结尾，如果你想启用它们，得先移除这个后缀</p>
<p>把一个正确命名且可执行的文件放入 Git 目录下的 hooks 子目录中，即可激活该钩子脚本。</p>
<h3 id="客户端钩子"><a href="#客户端钩子" class="headerlink" title="客户端钩子"></a>客户端钩子</h3><p>克隆某个版本库时，它的客户端钩子 并不 随同复制。如果需要靠这些脚本来强制维持某种策略，建议你在服务器端实现这一功能。</p>
<h4 id="提交工作流钩子"><a href="#提交工作流钩子" class="headerlink" title="提交工作流钩子"></a>提交工作流钩子</h4><p><code>pre-commit</code> 钩子在<strong>键入提交信息前运行</strong>。它用于检查即将提交的快照，例如，检查是否有所遗漏，确保测试运行，以及核查代码。如果该钩子以非零值退出，Git 将放弃此次提交，不过你可以用 git commit –no-verify 来绕过这个环节。你可以利用该钩子，来检查代码风格是否一致（运行类似 lint 的程序）、尾随空白字符是否存在（自带的钩子就是这么做的），或新方法的文档是否适当。</p>
<p><code>prepare-commit-msg</code>钩子在<strong>启动提交信息编辑器之前，默认信息被创建之后运行</strong>。它允许你编辑提交者所看到的默认信息。该钩子接收一些选项：存有当前提交信息的文件的路径、提交类型和修补提交的提交的 SHA-1校验。它对一般的提交来说并没有什么用；然而对那些会自动产生默认信息的提交，如提交信息模板、合并提交、压缩提交和修订提交等非常实用。你可以结合提交模板来使用它，动态地插入信息。</p>
<p><code>commit-msg</code> 钩子接收一个参数，此参数即上文提到的，存有当前提交信息的临时文件的路径。如果该钩子脚本以非零值退出，Git 将放弃提交，因此，可以用来在提交通过前验证项目状态或提交信息。在本章的最后一节，我们将展示如何使用该钩子来核对提交信息是否遵循指定的模板。</p>
<p><code>post-commit</code> 钩子在<strong>整个提交过程完成后运行</strong>。它不接收任何参数，但你可以很容易地通过运行 git log -1HEAD 来获得最后一次的提交信息。该钩子一般用于通知之类的事情。</p>
<h4 id="电子邮件工作流钩子"><a href="#电子邮件工作流钩子" class="headerlink" title="电子邮件工作流钩子"></a>电子邮件工作流钩子</h4><p>可以给电子邮件工作流设置三个客户端钩子。它们都是由 git am 命令调用的</p>
<p>第一个运行的钩子是 <code>applypatch-msg</code> 。它接收单个参数：包含请求合并信息的临时文件的名字。如果脚本返回非零值，Git 将放弃该补丁。你可以用该脚本来确保提交信息符合格式，或直接用脚本修正格式错误。</p>
<p>下一个在 git am 运行期间被调用的是 <code>pre-applypatch</code> 。有些难以理解的是，它正好运行于应用补丁 之后，产生提交之前，所以你可以用它在提交前检查快照。你可以用这个脚本运行测试或检查工作区。如果有什么遗漏，或测试未能通过，脚本会以非零值退出，中断 git am 的运行，这样补丁就不会被提交。</p>
<p><code>post-applypatch</code> 运行于提交产生之后，是在 git am 运行期间最后被调用的钩子。你可以用它把结果通知给一个小组或所拉取的补丁的作者。但你没办法用它停止打补丁的过程。</p>
<h4 id="其他钩子"><a href="#其他钩子" class="headerlink" title="其他钩子"></a>其他钩子</h4><p><code>pre-rebase</code> 钩子运行于变基之前，以非零值退出可以中止变基的过程。你可以使用这个钩子来禁止对已经推送的提交变基。Git 自带的 pre-rebase 钩子示例就是这么做的，</p>
<p><code>post-rewrite</code> 钩子被那些会<strong>替换提交记录的命令调用</strong>，比如 git commit –amend 和 git rebase（不过不包括 git filter-branch）。它唯一的参数是触发重写的命令名，同时从标准输入中接受一系列重写的提交记录。这个钩子的用途很大程度上跟 post-checkout 和 post-merge 差不多。</p>
<p>在 git checkout 成功运行后，<code>post-checkout</code> 钩子会被调用。你可以根据你的项目环境用它调整你的工作目录。其中包括放入大的二进制文件、自动生成文档或进行其他类似这样的操作。</p>
<p>在 git merge 成功运行后，<code>post-merge</code> 钩子会被调用。你可以用它恢复 Git 无法跟踪的工作区数据，比如权限数据。这个钩子也可以用来验证某些在 Git 控制之外的文件是否存在，这样你就能在工作区改变时，把这些文件复制进来。</p>
<p><code>pre-push</code> 钩子会在 git push 运行期间， 更新了远程引用但尚未传送对象时被调用。它接受远程分支的名字和位置作为参数，同时从标准输入中读取一系列待更新的引用。你可以在推送开始之前，用它验证对引用的更新操作（一个非零的退出码将终止推送过程）。</p>
<p>Git 的一些日常操作在运行时，偶尔会调用 git gc –auto 进行垃圾回收。<code>pre-auto-gc</code> 钩子会在垃圾回收开始之前被调用，可以用它来提醒你现在要回收垃圾了，或者依情形判断是否要中断回收。</p>
<h3 id="服务端钩子"><a href="#服务端钩子" class="headerlink" title="服务端钩子"></a>服务端钩子</h3><ul>
<li>pre-receive</li>
</ul>
<p>处理来自客户端的推送操作时，最先被调用的脚本是 pre-receive。它从标准输入获取一系列被推送的引用。如果它以非零值退出，所有的推送内容都不会被接受。你可以用这个钩子阻止对引用进行非快进（non-fastforward）的更新，或者对该推送所修改的所有引用和文件进行访问控制。</p>
<ul>
<li>update</li>
</ul>
<p>update 脚本和 pre-receive 脚本十分类似，不同之处在于它会为每一个准备更新的分支各运行一次。假如推送者同时向多个分支推送内容，pre-receive 只运行一次，相比之下 update 则会为每一个被推送的分支各运行一次。</p>
<ul>
<li>post-receive</li>
</ul>
<p>post-receive 挂钩在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。它接受与 prereceive 相同的标准输入数据。它的用途包括给某个邮件列表发信，通知持续集成（continous integration）的服务器，或者更新问题追踪系统（ticket-tracking system） —— 甚至可以通过分析提交信息来决定某个问题（ticket）是否应该被开启，修改或者关闭。该脚本无法终止推送进程，不过客户端在它结束运行之前将保持连接状态，所以如果你想做其他操作需谨慎使用它，因为它将耗费你很长的一段时间。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Pro Git》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="https://www.liuin.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git 工具</title>
    <link href="https://www.liuin.cn/2018/02/08/Git-%E5%B7%A5%E5%85%B7/"/>
    <id>https://www.liuin.cn/2018/02/08/Git-工具/</id>
    <published>2018-02-08T12:05:51.000Z</published>
    <updated>2018-02-23T04:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>《Pro Git》读书笔记</p>
<a id="more"></a>
<h2 id="选择修改版本"><a href="#选择修改版本" class="headerlink" title="选择修改版本"></a>选择修改版本</h2><p>Git 允许你通过几种方法来指明特定的或者一定范围内的提交。</p>
<h3 id="单个修订版本"><a href="#单个修订版本" class="headerlink" title="单个修订版本"></a>单个修订版本</h3><p>Git 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交，当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义</p>
<blockquote>
<p>分支引用</p>
</blockquote>
<p>指明一次提交最直接的方法是有一个指向它的分支引用。这样你就可以在任意一个 Git 命令中使用这个分支名来代替对应的提交对象或者 SHA-1 值。</p>
<blockquote>
<p>引用日志</p>
</blockquote>
<p>当你在工作时， Git 会在后台保存一个引用日志(reflog)，引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史。</p>
<p>你可以使用 git reflog 来查看引用日志</p>
<p>详情可以查看<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%80%89%E6%8B%A9%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC" target="_blank" rel="external">这里</a></p>
<blockquote>
<p>祖先引用</p>
</blockquote>
<p>祖先引用是另一种指明一个提交的方式。如果你在引用的尾部加上一个 ^， Git 会将其解析为该引用的上一个提交。</p>
<p>另一种指明祖先提交的方法是 ~。同样是指向第一父提交，因此 HEAD~ 和 HEAD^ 是等价的</p>
<h3 id="提交区间"><a href="#提交区间" class="headerlink" title="提交区间"></a>提交区间</h3><p>最常用的指明提交区间语法是<strong>双点</strong>。这种语法可以让 Git 选出在一个分支中而不在另一个分支中的提交。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_7_1518003024258.jpg" alt="enter description here"></p>
<p>你想要查看 experiment 分支中还有哪些提交尚未被合并入 master 分支。你可以使用 master..experiment来让 Git 显示这些提交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log master..experiment</div></pre></td></tr></table></figure></p>
<p>双点语法很好用，但有时候你可能需要两个以上的分支才能确定你所需要的修订，比如查看哪些提交是被包含在某些分支中的一个，但是不在你当前的分支上。你想查所有被refA 或 refB 包含的但是不被 refC 包含的提交，你可以输入下面中的任意一个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git log refA refB ^refC</div><div class="line">$ git log refA refB --not refC</div></pre></td></tr></table></figure></p>
<h2 id="交互式暂存"><a href="#交互式暂存" class="headerlink" title="交互式暂存"></a>交互式暂存</h2><p>本节的几个互交命令可以帮助你将文件的特定部分组合成提交。当你修改一组文件后，希望这些改动能放到若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。</p>
<p>通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。如果运行 git add 时使用 -i 或者 –interactive 选项，Git 将会进入一个交互式终端模式</p>
<h2 id="储藏与清理"><a href="#储藏与清理" class="headerlink" title="储藏与清理"></a>储藏与清理</h2><p>有时，当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态，而这时你想要切换到另一个分支做一点别的事情。问题是，你不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交。针对这个问题的答案是 git stash 命令。</p>
<h3 id="储藏工作"><a href="#储藏工作" class="headerlink" title="储藏工作"></a>储藏工作</h3><ul>
<li>将新的储藏推送栈上：<code>git stash</code> 或者<code>git stash save</code></li>
<li>查看栈上的储藏：<code>git stash list</code></li>
<li>将栈顶的储藏应用：<code>git stash apply</code></li>
<li>丢弃指定储藏 <code>git stash drop {name}</code></li>
<li>应用栈顶储藏并弹出 <code>git stash pop</code></li>
</ul>
<h3 id="创造性储藏"><a href="#创造性储藏" class="headerlink" title="创造性储藏"></a>创造性储藏</h3><p>有几个储藏的变种可能也很有用。第一个非常流行的选项是 <code>stash save</code>命令的 <code>--keep-index</code> 选项。它告诉Git 不要储藏任何你通过 git add 命令已暂存的东西。</p>
<p>另一个经常使用储藏来做的事情是像储藏跟踪文件一样储藏未跟踪文件。默认情况下，git stash 只会储藏已经在索引中的文件。如果指定 <code>--include-untracked</code> 或 -u 标记，Git 也会储藏任何创建的未跟踪文件。</p>
<h3 id="从储藏创建一个分支"><a href="#从储藏创建一个分支" class="headerlink" title="从储藏创建一个分支"></a>从储藏创建一个分支</h3><p>如果储藏了一些工作，将它留在那儿了一会儿，然后继续在储藏的分支上工作，在重新应用工作时可能会有问题。如果应用尝试修改刚刚修改的文件，你会得到一个合并冲突并不得不解决它。如果想要一个轻松的方式来再次测试储藏的改动，可以运行 <code>git stash branch</code> 创建一个新分支，检出储藏工作时所在的提交，重新在那应用工作，然后在应用成功后扔掉储藏</p>
<h3 id="清理工作目录"><a href="#清理工作目录" class="headerlink" title="清理工作目录"></a>清理工作目录</h3><p>对于工作目录中一些工作或文件，你想做的也许不是储藏而是移除。git clean 命令会帮你做这些事</p>
<h2 id="签署工作"><a href="#签署工作" class="headerlink" title="签署工作"></a>签署工作</h2><p>Git 虽然是密码级安全的，但它不是万无一失的。如果你从因特网上的其他人那里拿取工作，并且想要验证提交是不是真正地来自于可信来源，Git 提供了几种通过 GPG 来签署和验证工作的方式。</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>无论仓库里的代码量有多少，你经常需要查找一个函数是在哪里调用或者定义的，或者一个方法的变更历史。Git 提供了两个有用的工具来快速地从它的数据库中浏览代码和提交。</p>
<h3 id="Git-Grep"><a href="#Git-Grep" class="headerlink" title="Git Grep"></a>Git Grep</h3><p>Git 提供了一个 grep 命令，你可以很方便地从提交历史或者工作目录中查找一个字符串或者正则表达式。</p>
<p>默认情况下 Git 会查找你工作目录的文件。你可以传入 -n 参数来输出 Git 所找到的匹配行行号。你可以使用 –count 选项来使 Git 输出概述的信息，仅仅包括哪些文件包含匹配以及每个文件包含了多少个匹配。如果你想看匹配的行是属于哪一个方法或者函数，你可以传入 -p 选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ git grep -n gmtime_r</div><div class="line">compat/gmtime.c:3:#undef gmtime_r</div><div class="line">compat/gmtime.c:8: return git_gmtime_r(timep, &amp;result);</div><div class="line">compat/gmtime.c:11:struct tm *git_gmtime_r(const time_t *timep, struct tm</div><div class="line">*result)</div><div class="line">compat/gmtime.c:16: ret = gmtime_r(timep, result);</div><div class="line">compat/mingw.c:606:struct tm *gmtime_r(const time_t *timep, struct tm</div><div class="line">*result)</div><div class="line">compat/mingw.h:162:struct tm *gmtime_r(const time_t *timep, struct tm</div><div class="line">*result);</div><div class="line">date.c:429: if (gmtime_r(&amp;now, &amp;now_tm))</div><div class="line">date.c:492: if (gmtime_r(&amp;time, tm)) &#123;</div><div class="line">    git-compat-util.h:721:struct tm *git_gmtime_r(const time_t *, struct tm</div><div class="line">    *);</div><div class="line">    git-compat-util.h:723:#define gmtime_r git_gmtime_r</div></pre></td></tr></table></figure>
<h3 id="Git-日志搜索"><a href="#Git-日志搜索" class="headerlink" title="Git 日志搜索"></a>Git 日志搜索</h3><p>或许你不想知道某一项在 哪里 ，而是想知道是什么 时候 存在或者引入的。git log 命令有许多强大的工具可以通过提交信息甚至是 diff 的内容来找到某个特定的提交。</p>
<p>例如，如果我们想找到 ZLIB_BUF_MAX 常量是什么时候引入的，我们可以使用 -S 选项来显示新增和删除该字符串的提交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git log -SZLIB_BUF_MAX --oneline</div><div class="line">e01503b zlib: allow feeding more than 4GB in one go</div><div class="line">ef49a7a zlib: zlib can only process 4GB at a time</div></pre></td></tr></table></figure></p>
<h2 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重写历史</h2><p>许多时候，在使用 Git 时，可能会因为某些原因想要修正提交历史。Git 很棒的一点是它允许你在最后时刻做决定。你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 stash 命令来决定不与某些内容工作，也可以重写已经发生的提交就像它们以另一种方式发生的一样。</p>
<h3 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h3><p>修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。对于你的最近一次提交，你往往想做两件事情：修改提交信息，或者修改你添加、修改和移除的文件的快照。</p>
<p>如果，你只是想修改最近一次提交的提交信息，那么很简单：<code>git commit --amend</code></p>
<h3 id="修改多个提交信息"><a href="#修改多个提交信息" class="headerlink" title="修改多个提交信息"></a>修改多个提交信息</h3><p>Git 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 HEAD 而不是将其移动到另一个新的上面。可以通过给 git rebase 增加 -i选项来交互式地运行变基。<code>git rebase -i HEAD~3</code></p>
<blockquote>
<p>重新排序提交</p>
</blockquote>
<p>修改交互式变基中的各个提交的顺序即可</p>
<blockquote>
<p>压缩提交</p>
</blockquote>
<p>通过交互式变基工具，也可以将一连串提交压缩成一个单独的提交。在变基信息中脚本给出了有用的指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Commands:</div><div class="line"># p, pick = use commit</div><div class="line"># r, reword = use commit, but edit the commit message</div><div class="line"># e, edit = use commit, but stop for amending</div><div class="line"># s, squash = use commit, but meld into previous commit</div><div class="line"># f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</div><div class="line"># x, exec = run command (the rest of the line) using shell</div></pre></td></tr></table></figure></p>
<h3 id="核武器级选项：filter-branch"><a href="#核武器级选项：filter-branch" class="headerlink" title="核武器级选项：filter-branch"></a>核武器级选项：filter-branch</h3><p>有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它 - 例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。这个命令是 filter-branch，它可以改写历史中大量的提交，<strong>除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，你不应当使用它</strong>。</p>
<blockquote>
<p>从每一个提交移除一个文件</p>
</blockquote>
<p>这经常发生。有人粗心地通过 git add . 提交了一个巨大的二进制文件，你想要从所有地方删除它。然而你想要开源项目。filter-branch 是一个可能会用来擦洗整个提交历史的工具。为了从整个提交历史中移除一个叫做 passwords.txt 的文件，可以使用 –tree-filter 选项给filter-branch：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git filter-branch --tree-filter &apos;rm -f passwords.txt&apos; HEAD</div></pre></td></tr></table></figure></p>
<p><code>--tree-filter</code> 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。</p>
<blockquote>
<p>使一个子目录做为新的根目录</p>
</blockquote>
<p>假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（trunk、tags 等等）。如果想要让trunk 子目录作为每一个提交的新的项目根目录，filter-branch 也可以帮助你那么做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git filter-branch --subdirectory-filter trunk HEAD</div></pre></td></tr></table></figure></p>
<h2 id="重置揭秘"><a href="#重置揭秘" class="headerlink" title="重置揭秘"></a>重置揭秘</h2><p>这里将讨论reset与checkout</p>
<h3 id="三棵树"><a href="#三棵树" class="headerlink" title="三棵树"></a>三棵树</h3><p>理解 reset 和 checkout 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。“树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构</p>
<p>Git 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：<br>| 树 | 用途 |<br>| – | – |<br>| HEAD | 上一次提交的快照，下一次提交的父结点|<br>| Index| 预期的下一次提交的快照|<br>|Working Directory| 沙盒|</p>
<blockquote>
<p>HEAD</p>
</blockquote>
<p>HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。这表示 HEAD 将是下一次提交的父结点。通常，理解 HEAD 的最简方式，就是将它看做 <strong>你的上一次提交</strong> 的快照。</p>
<blockquote>
<p>Index</p>
</blockquote>
<p>索引是你的 <strong>预期的下一次提交</strong>。我们也会将这个概念引用为 Git 的 “暂存区域”，这就是当你运行 git commit 时 Git 看起来的样子。</p>
<blockquote>
<p>工作流程</p>
</blockquote>
<p>参考<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86" target="_blank" rel="external">这里</a></p>
<h3 id="重置的作用（reset）"><a href="#重置的作用（reset）" class="headerlink" title="重置的作用（reset）"></a>重置的作用（reset）</h3><ul>
<li>第一步：移动HEAD</li>
<li>第二步：更新索引（–mixed）</li>
<li>第三步：更新工作目录（–hard）</li>
</ul>
<p>reset 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：</p>
<ol>
<li>移动 HEAD 分支的指向 （若指定了 –soft，则到此停止）</li>
<li>使索引看起来像 HEAD   （默认执行到这一步）</li>
<li>使工作目录看起来像索引  （指定了 –hard ，才执行这一步）</li>
</ol>
<blockquote>
<p>通过路径来重置</p>
</blockquote>
<p>若指定了一个路径，reset 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。</p>
<blockquote>
<p>压缩</p>
</blockquote>
<p>我们来看看如何利用这种新的功能来做一些有趣的事情 - 压缩提交</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git reset --soft HEAD~2</div><div class="line"> git commit</div></pre></td></tr></table></figure>
<h3 id="检出（checkout）"><a href="#检出（checkout）" class="headerlink" title="检出（checkout）"></a>检出（checkout）</h3><pre><code>运行 `git checkout [branch] `与运行` git reset --hard [branch] `非常相似，它会更新所有三棵树使其看起来像 \[branch\]，不过有两点重要的区别。

 首先不同于 reset --hard，checkout 对工作目录是安全的，它会通过检查来确保不会将已更改的文件吹走。其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有_还未修改过的_文件都会被更新。而 reset --hard 则会不做检查就全面地替换所有东西。

 第二个重要的区别是如何更新 HEAD。reset 会移动 HEAD 分支的指向，而 checkout 只会移动 HEAD 自身来指向另一个分支。

 &gt; 带路径情况

 运行 checkout 的另一种方式就是指定一个文件路径，这会像 reset 一样不会移动 HEAD。它就像是 `git reset --hard [branch] file`（如果 reset 允许你这样运行的话）- 这样对工作目录并不安全，它也不会移动 HEAD。
</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_7_1518007500384.jpg" alt="enter description here"></p>
<h2 id="高级合并"><a href="#高级合并" class="headerlink" title="高级合并"></a>高级合并</h2><p>Git 并不会尝试过于聪明的合并冲突解决方案。Git的哲学是聪明地决定无歧义的合并方案，但是如果有冲突，它不会尝试智能地自动解决它。</p>
<h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><p>首先，在做一次可能有冲突的合并前尽可能保证工作目录是干净的。</p>
<p>在遇到冲突的时候，你可以有以下几种解决方案：</p>
<blockquote>
<p>中断一次合并</p>
</blockquote>
<p>你可能不想处理冲突这种情况，完全可以通过 <code>git merge --abort</code> 来简单地退出合并。他会会尝试恢复到你运行合并前的状态。但当运行命令前，在工作目录中有未储藏、未提交的修改时它不能完美处理，除此之外它都工作地很好。</p>
<blockquote>
<p>忽略空白</p>
</blockquote>
<p>如果你看到在一次合并中有大量的空白问题，你可以简单地中止它并重做一次，这次使用<code>-Xignore-all-space</code>或 <code>-Xignore-space-change</code>选项。第一个选项忽略任意 数量 的已有空白的修改，第二个选项忽略所有空白修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge -Xignore-space-change whitespace</div></pre></td></tr></table></figure></p>
<blockquote>
<p>手动文件再合并</p>
</blockquote>
<p>首先，我们进入到了合并冲突状态。然后我们想要我的版本的文件，他们的版本的文件（从我们将要合并入的分支）和共同的版本的文件（从分支叉开时的位置）的拷贝。</p>
<p>然后我们想要修复任何一边的文件，并且为这个单独的文件重试一次合并。获得这三个文件版本实际上相当容易。Git 在索引中存储了所有这些版本，在 “stages” 下每一个都有一个数字与它们关联。Stage 1 是它们共同的祖先版本，stage 2 是你的版本，stage 3 来自于 MERGE_HEAD，即你将要合并入的版本（“theirs”）</p>
<p>如果你想要在最终提交前看一下我们这边与另一边之间实际的修改，你可以使用 <code>git diff</code></p>
<p>要在合并前比较结果与在你的分支上的内容，换一句话说，看看合并引入了什么，可以运行 <code>git diff --ours</code> ； 如果我们想要查看合并的结果与他们那边有什么不同，可以运行 <code>git diff --theirs</code></p>
<h3 id="子树合并"><a href="#子树合并" class="headerlink" title="子树合并"></a>子树合并</h3><p>子树合并的思想是你有两个项目，并且其中一个映射到另一个项目的一个子目录，或者反过来也行。</p>
<p>我们希望将 Rack 项目拉到 master 项目中作为一个子目录。我们可以在 Git 中执行 <code>git read-tree</code> 来实现。它会读取一个分支的根目录树到当前的暂存区和工作目录里。先切回你的 master 分支，将 rack_back 分支拉取到我们项目的 master 分支中的 rack 子目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git read-tree --prefix=rack/ -u rack_branch</div></pre></td></tr></table></figure></p>
<p>当 Rack 项目有更新时，我们可以切换到那个分支来拉取上游的变更。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout rack_branch</div><div class="line">git pull</div></pre></td></tr></table></figure></p>
<p>接着，我们可以将这些变更合并回我们的 master 分支。使用 –squash 选项和使用 -Xsubtree 选项（它采用递归合并策略），都可以用来可以拉取变更并且预填充提交信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line">git merge --squash -s recursive -Xsubtree=rack rack_branch</div></pre></td></tr></table></figure></p>
<h2 id="Rerere"><a href="#Rerere" class="headerlink" title="Rerere"></a>Rerere</h2><p>git rerere 功能是一个隐藏的功能。正如它的名字 “reuse recorded resolution” 所指，它允许你<strong>让 Git 记住解决一个块冲突的方法，这样在下一次看到相同冲突时，Git 可以为你自动地解决它</strong>。</p>
<p>有几种情形下这个功能会非常有用。在文档中提到的一个例子是如果你想要保证一个长期分支会干净地合并，但是又不想要一串中间的合并提交。将 rerere 功能打开后偶尔合并，解决冲突，然后返回到合并前。如果你持续这样做，那么最终的合并会很容易，因为 rerere 可以为你自动做所有的事情。</p>
<p>可以将同样的策略用在维持一个变基的分支时，这样就不用每次解决同样的变基冲突了。或者你将一个分支合并并修复了一堆冲突后想要用变基来替代合并 - 你可能并不想要再次解决相同的冲突。</p>
<p>另一个情形是当你偶尔将一堆正在改进的特性分支合并到一个可测试的头时，就像 Git 项目自身经常做的。如果测试失败，你可以倒回合并之前然后在去除导致测试失败的那个特性分支后重做合并，而不用再次重新解决所有的冲突。</p>
<p>启用rerere功能的方法：</p>
<ol>
<li><code>git config --global rerere.enabled true</code></li>
<li>在特定的仓库中创建<code>.git/rr-cache</code>目录</li>
</ol>
<p>更多使用方法可以查看<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-Rerere" target="_blank" rel="external">这里</a></p>
<h2 id="Git-调试"><a href="#Git-调试" class="headerlink" title="Git 调试"></a>Git 调试</h2><p>Git 提供两个工具来辅助你调试项目中的问题</p>
<h3 id="文件标注"><a href="#文件标注" class="headerlink" title="文件标注"></a>文件标注</h3><p><strong>如果你在追踪代码中的一个 bug，并且想知道是什么时候以及为何会引入，文件标注通常是最好用的工具。它</strong>展示了文件中每一行最后一次修改的提交。所以，如果你在代码中看到一个有问题的方法，你可以使用 gitblame 标注这个文件，查看这个方法每一行的最后修改时间以及是被谁修改的。这个例子使用 -L 选项来限制输出范围在第12至22行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git blame -L 12,22 simplegit.rb</div></pre></td></tr></table></figure>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>当你知道问题是在哪里引入的情况下文件标注可以帮助你查找问题。如果你不知道哪里出了问题，并且自从上次可以正常运行到现在已经有数十个或者上百个提交，这个时候你可以使用 git bisect 来帮助查找。bisect命令会<strong>对你的提交历史进行二分查找来帮助你尽快找到是哪一个提交引入了问题</strong>。</p>
<p>首先执行 <code>git bisect start</code> 来启动，接着执行<code>git bisect bad</code>来告诉系统当前你所在的提交是有问题的。然后你必须告诉 bisect 已知的最后一次正常状态是哪次提交，使用<code>git bisect good [good_commit]</code></p>
<p>在测试过程中可以通过 <code>git bisect good</code> 来告诉 Git 当前的提交没有问题，通过<code>git bisect bad</code>来告诉Git当前的提交有问题</p>
<h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><p>子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。</p>
<h3 id="开始使用子模块"><a href="#开始使用子模块" class="headerlink" title="开始使用子模块"></a>开始使用子模块</h3><p>你可以通过在 git submodule add 命令后面加上想要跟踪的项目 URL 来添加新的子模块。在本例中，我们将会添加一个名为 “DbConnector” 的库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git submodule add https://github.com/chaconinc/DbConnector</div></pre></td></tr></table></figure></p>
<p>Git首先会生成新的 <code>.gitmodules</code>文件。该置文件保存了项目 URL 与已经拉取的本地目录之间的映射。如果有多个子模块，该文件中就会有多条记录。要重点注意的是，该文件也像 .gitignore 文件一样受到（通过）版本控制。它会和该项目的其他部分一同被拉取推送。</p>
<h3 id="克隆含有子模块的项目"><a href="#克隆含有子模块的项目" class="headerlink" title="克隆含有子模块的项目"></a>克隆含有子模块的项目</h3><p>你必须运行两个命令：<code>git submodule init</code>用来初始化本地配置文件，而 <code>git submodule update</code> 则从该项目中抓取所有数据并检出父项目中列出的合适的提交。</p>
<p>如果给 git clone 命令传递 –recursive 选项，它就会自动初始化并更新仓库中的每一个子模块。</p>
<h3 id="在包含子模块的项目上工作"><a href="#在包含子模块的项目上工作" class="headerlink" title="在包含子模块的项目上工作"></a>在包含子模块的项目上工作</h3><p>在项目中使用子模块的最简模型，就是只使用子项目并不时地获取更新，而并不在你的检出中进行任何更改。</p>
<p>当我们运行 git submodule update 从子模块仓库中抓取修改时，Git 将会获得这些改动并更新子目录中的文件，但是会将子仓库留在一个称作 “游离的 HEAD” 的状态。</p>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>Git 可以将它的数据 “打包” 到一个文件中。这在许多场景中都很有用。有可能你的网络中断了，但你又希望将你的提交传给你的合作者们。可能你不在办公网中并且出于安全考虑没有给你接入内网的权限。</p>
<p>bundle 命令会<strong>将 git push 命令所传输的所有内容打包成一个二进制文件</strong>，你可以将这个文件通过邮件或者闪存传给其他人，然后解包到其他的仓库中。</p>
<p>如果你想把这个仓库发送给其他人但你没有其他仓库的权限，或者就是懒得新建一个仓库，你就可以用 gitbundle create 命令来打包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git bundle create repo.bundle HEAD master</div></pre></td></tr></table></figure></p>
<p>然后你就会有一个名为 repo.bundle 的文件，该文件包含了所有重建该仓库 master 分支所需的数据。</p>
<p>假设别人传给你一个 repo.bundle 文件并希望你在这个项目上工作。你可以从这个二进制文件中克隆出一个目录，就像从一个 URL 克隆一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone repo.bundle repo</div></pre></td></tr></table></figure></p>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>Git 对象是不可改变的，但它提供一种有趣的方式来用其他对象假装替换数据库中的 Git 对象。</p>
<p><code>replace</code>命令可以让你在 Git 中指定一个对象并可以声称“每次你遇到这个 Git 对象时，假装它是其他的东西”。在你用一个不同的提交替换历史中的一个提交时，这会非常有用。</p>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E6%9B%BF%E6%8D%A2" target="_blank" rel="external">详情</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Pro Git》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="https://www.liuin.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>服务器上的Git &amp;&amp; 分布式Git</title>
    <link href="https://www.liuin.cn/2018/02/07/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84Git-%E5%88%86%E5%B8%83%E5%BC%8FGit/"/>
    <id>https://www.liuin.cn/2018/02/07/服务器上的Git-分布式Git/</id>
    <published>2018-02-07T13:12:35.000Z</published>
    <updated>2018-02-23T04:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>《Pro Git》读书笔记</p>
<a id="more"></a>
<h1 id="服务器上的Git"><a href="#服务器上的Git" class="headerlink" title="服务器上的Git"></a>服务器上的Git</h1><p>一个远程仓库通常只是一个裸仓库（bare repository）— 即一个没有当前工作目录的仓库。因为该仓库仅仅作为合作媒介，不需要从磁碟检查快照；存放的只有 Git 的资料。简单的说，裸仓库就是你专案目录内的 .git 子目录内容，不包含其他资料</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>Git 可以使用四种主要的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git协议。</p>
<h3 id="本地协议"><a href="#本地协议" class="headerlink" title="本地协议"></a>本地协议</h3><p>最基本的就是 本地协议（Local protocol） ，其中的<strong>远程版本库就是硬盘内的另一个目录</strong>。这常见于团队每一个成员都对一个共享的文件系统（例如一个挂载的 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。后者并不理想，因为你的所有代码版本库如果长存于同一台电脑，更可能发生灾难性的损失。</p>
<p>优点</p>
<ul>
<li>简单，并且直接使用了现有的文件权限和网络访问权限</li>
</ul>
<p>缺点：</p>
<ul>
<li>通常共享文件系统比较难配置，并且比起基本的网络连接访问，这不方便从多个位置访问</li>
<li>在同一个服务器上，如果允许 Git 访问本地硬盘，一般的通过 NFS 访问版本库要比通过 SSH 访问慢。</li>
<li>这个协议并不保护仓库避免意外的损坏。每一个用户都有“远程”目录的完整 shell 权限，没有方法可以阻止他们修改或删除 Git 内部文件和损坏仓库。</li>
</ul>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>智能” HTTP 协议的运行方式和 SSH 及 Git 协议类似，只是运行在标准的 HTTP/S 端口上并且可以使用各种HTTP 验证机制，这意味着使用起来会比 SSH 协议简单的多，比如可以使用 HTTP 协议的用户名／密码的基础授权，免去设置 SSH 公钥。</p>
<p>哑 HTTP 协议里 web 服务器仅把裸版本库当作普通文件来对待，提供文件服务。哑 HTTP 协议的优美之处在于设置起来简单。基本上，只需要把一个裸版本库放在 HTTP 跟目录，设置一个叫做 post-update 的挂钩就可以了</p>
<p>优点（只关注智能“HTTP”协议）：</p>
<ul>
<li>不同的访问方式只需要一个 URL 以及服务器只在需要授权时提示输入授权信息，这两个简便性让终端用户使用Git 变得非常简单。</li>
<li>可以在 HTTPS 协议上提供只读版本库的服务，如此你在传输数据的时候就可以加密数据；或者，你甚至可以让客户端使用指定的 SSL 证书。</li>
<li>HTTP/S 协议被广泛使用，一般的企业防火墙都会允许这些端口的数据通过。</li>
</ul>
<p>缺点：</p>
<ul>
<li>在一些服务器上，架设 HTTP/S 协议的服务端会比 SSH 协议的棘手一些</li>
</ul>
<h3 id="SSH协议"><a href="#SSH协议" class="headerlink" title="SSH协议"></a>SSH协议</h3><p>架设 Git 服务器时常用 SSH 协议作为传输协议。因为大多数环境下已经支持通过 SSH 访问 —— 即时没有也比较很容易架设。SSH 协议也是一个验证授权的网络协议；并且，因为其普遍性，架设和使用都很容易。</p>
<p>优点：</p>
<ul>
<li>SSH 架设相对简单 —— SSH 守护进程很常见，多数管理员都有使用经验，并且多数操作系统都包含了它及相关的管理工具。</li>
<li>通过 SSH 访问是安全的 —— 所有传输数据都要经过授权和加密。</li>
<li>与 HTTP/S 协议、Git 协议及本地协议一样，SSH 协议很高效，在传输前也会尽量压缩数据。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能通过他实现匿名访问。即便只要读取数据，使用者也要有通过 SSH 访问你的主机的权限，这使得 SSH 协议不利于开源的项目。</li>
</ul>
<h3 id="Git协议"><a href="#Git协议" class="headerlink" title="Git协议"></a>Git协议</h3><p>包含在 Git 里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于 SSH服务，但是访问无需任何授权。</p>
<p>优点：</p>
<ul>
<li>Git 协议是 Git 使用的网络传输协议里最快的。</li>
</ul>
<p>缺点：</p>
<ul>
<li>缺乏授权机制。把 Git 协议作为访问项目版本库的唯一手段是不可取的</li>
</ul>
<h2 id="在服务器上搭建Git"><a href="#在服务器上搭建Git" class="headerlink" title="在服务器上搭建Git"></a>在服务器上搭建Git</h2><h3 id="SSH连接"><a href="#SSH连接" class="headerlink" title="SSH连接"></a>SSH连接</h3><p>如果你有一台所有开发者都可以用 SSH 连接的服务器，架设你的第一个仓库就十分简单了，因为你几乎什么都不用做（正如我们上一节所说的）。如果你想在你的仓库上设置更复杂的访问控制权限，只要使用服务器操作系统的普通的文件系统权限就行了。</p>
<p>如果需要团队里的每个人都对仓库有写权限，又不能给每个人在服务器上建立账户，那么提供 SSH 连接就是唯一的选择了。一下提供几种方法：</p>
<ul>
<li>第一个就是给团队里的每个人创建账号，这种方法很直接但也很麻烦。或许你不会想要为每个人运行一次 adduser 并且设置临时密码。</li>
<li>第二个办法是在主机上建立一个 git 账户，让每个需要写权限的人发送一个 SSH 公钥，然后将其加入 git 账户的~/.ssh/authorized_keys 文件。这样一来，所有人都将通过 git 账户访问主机。这一点也不会影响提交的数据——访问主机用的身份不会影响提交对象的提交者信息。</li>
<li>另一个办法是让 SSH 服务器通过某个 LDAP 服务，或者其他已经设定好的集中授权机制，来进行授权。只要每个用户可以获得主机的 shell 访问权限，任何 SSH 授权机制你都可视为是有效的。</li>
</ul>
<h2 id="GitWeb"><a href="#GitWeb" class="headerlink" title="GitWeb"></a>GitWeb</h2><p>如果你对项目有读写权限或只读权限，你可能需要建立起一个基于网页的简易查看器。Git 提供了一个叫做GitWeb 的 CGI 脚本来做这项工作</p>
<p>如果你想要查看 GitWeb 如何展示你的项目，并且在服务器上安装了轻量级网络服务器比如 lighttpd 或webrick， Git 提供了一个命令来让你启动一个临时的服务器。在 Linux 系统的电脑上，lighttpd 通常已经安装了，所以你只需要在项目目录里执行 git instaweb 命令即可。</p>
<h1 id="分布式Git"><a href="#分布式Git" class="headerlink" title="分布式Git"></a>分布式Git</h1><h2 id="分布式工作流程"><a href="#分布式工作流程" class="headerlink" title="分布式工作流程"></a>分布式工作流程</h2><p>在集中式系统中，每个开发者就像是连接在集线器上的节点，彼此的工作方式大体相像。而在 Git 中，<strong>每个开发者同时扮演着节点和集线器的角色</strong>——也就是说，每个开发者既可以将自己的代码贡献到其他的仓库中，同时也能维护自己的公开仓库，让其他人可以在其基础上工作并贡献代码。</p>
<h3 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="集中式工作流"></a>集中式工作流</h3><p>集中式系统中通常使用的是单点协作模型——集中式工作流。</p>
<p>这意味着如果两个开发者从中心仓库克隆代码下来，同时作了一些修改，那么只有第一个开发者可以顺利地把数据推送回共享服务器。第二个开发者在推送修改之前，必须先将第一个人的工作合并进来，这样才不会覆盖第一个人的修改。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517834128254.jpg" alt="enter description here"></p>
<h3 id="集成管理者工作流"><a href="#集成管理者工作流" class="headerlink" title="集成管理者工作流"></a>集成管理者工作流</h3><p>Git 允许多个远程仓库存在，使得这样一种工作流成为可能：每个开发者拥有自己仓库的写权限和其他所有人仓库的读权限。这种情形下通常会有个代表‘官方’’项目的权威的仓库。要为这个项目做贡献，你需要从该项目克隆出一个自己的公开仓库，然后将自己的修改推送上去。接着你可以请求官方仓库的维护者拉取更新合并到主项目。维护者可以将你的仓库作为远程仓库添加进来，在本地测试你的变更，将其合并入他们的分支并推送回官方仓库。</p>
<p>这是 GitHub 和 GitLab 等集线器式（hub-based）工具最常用的工作流程。</p>
<p>这么做最主要的优点之一是你可以持续地工作，而主仓库的维护者可以随时拉取你的修改。贡献者不必等待维护者处理完提交的更新——每一方都可以按照自己节奏工作</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517834212479.jpg" alt="enter description here"></p>
<h3 id="司令官与副官工作流"><a href="#司令官与副官工作流" class="headerlink" title="司令官与副官工作流"></a>司令官与副官工作流</h3><p>这其实是多仓库工作流程的变种。一般拥有数百位协作开发者的超大型项目才会用到这样的工作方式，例如著名的 Linux 内核项目。被称为副官（lieutenant）的各个集成管理者分别负责集成项目中的特定部分。所有这些副官头上还有一位称为司令官（dictator）的总集成管理者负责统筹。司令官维护的仓库作为参考仓库，为所有协作者提供他们需要拉取的项目代码。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517834259058.jpg" alt="enter description here"></p>
<h2 id="向一个项目贡献"><a href="#向一个项目贡献" class="headerlink" title="向一个项目贡献"></a>向一个项目贡献</h2><p>提交准则：</p>
<ul>
<li>你不会想要把空白错误提交上去</li>
<li>尝试让每一个提交成为一个逻辑上的独立变更集。</li>
<li>最后一件要牢记的事是提交信息。有一个创建优质提交信息的习惯会使 Git 的使用与协作容易的多。</li>
</ul>
<h2 id="维护项目"><a href="#维护项目" class="headerlink" title="维护项目"></a>维护项目</h2><h3 id="在特性分支中工作"><a href="#在特性分支中工作" class="headerlink" title="在特性分支中工作"></a>在特性分支中工作</h3><p>如果你想向项目中整合一些新东西，最好将这些尝试局限在特性分支——一种通常用来尝试新东西的临时分支中</p>
<h3 id="应用来自邮件的补丁"><a href="#应用来自邮件的补丁" class="headerlink" title="应用来自邮件的补丁"></a>应用来自邮件的补丁</h3><p>如果你通过电子邮件收到了一个需要整合进入项目的补丁，你需要将其应用到特性分支中进行评估。有两种应用该种补丁的方法：使用 git apply，或者使用 git am。</p>
<p>具体详情可以参考<a href="https://git-scm.com/book/zh/v2/%E5%88%86%E5%B8%83%E5%BC%8F-Git-%E7%BB%B4%E6%8A%A4%E9%A1%B9%E7%9B%AE" target="_blank" rel="external">这里</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Pro Git》读书笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="https://www.liuin.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>APUE Unix 基础知识</title>
    <link href="https://www.liuin.cn/2018/02/06/APUE-Unix-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.liuin.cn/2018/02/06/APUE-Unix-基础知识/</id>
    <published>2018-02-06T13:26:58.000Z</published>
    <updated>2018-02-23T04:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>《UNIX环境高级编程》第1章笔记</p>
<a id="more"></a>
<h2 id="Unix-体系结构"><a href="#Unix-体系结构" class="headerlink" title="Unix 体系结构"></a>Unix 体系结构</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_6_1517920273064.jpg" alt="enter description here"></p>
<p>可以将操作系统定义为一种软件，其控制计算机硬件资源，提供程序运行环境。我们通常将这种软件称为<strong>内核</strong>( kemel),因为它相对较小, 而且位于环境的核心。</p>
<p>内核的接口被称为<strong>系统调用</strong>( system call)。公用函数库构建在系统调用接口之上,应用程序既可使用公用函数库,也可使用系统调用。</p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>口令文件（通常是/etc/passwd文件）中查看登录名。口令文件中的登录项由7个以冒号分隔的字段组成,依次是:<br><code>登录名、加密口令、数字用户ID(205)、数字组TD(105)、注释字段、起始目录(/home/sar)以及 shel程序(/bin/ksh)</code></p>
<p>shell是一个命令行解释器,它读取用户输入,然后执行命令。 shell的用户输入通常来自 于终端(交互式 shell),有时则来自于文件(称为 shell i脚本)。</p>
<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>UNX文件系统是<strong>目录和文件的一种层次结构</strong>,所有东西的起点是称为根(root)的目录,这个目录的名称是一个字符“/”。 目录( directory)是一个包含目录项的文件。</p>
<h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><p>目录中的各个名字称为文件名( filename)。只有斜线线(/)和空字符这两个字符不能出现在 文件名中。斜线用来分隔构成路径名的各文件名,空字符则用来终止一个路径名。</p>
<h3 id="路径名"><a href="#路径名" class="headerlink" title="路径名"></a>路径名</h3><p>由斜线分隔的一个或多个文件名组成的序列(也可以斜线开头)构成路径名( pathname),以斜线 开头的路径名称为<strong>绝对路径名</strong>( absolute pathname),否则称为<strong>相对路径名</strong>( relative pathname)。</p>
<h3 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h3><p>每个进程都有一个工作目录( working directory),有时称其为当前工作目录( current working directory)。所有相对路径名名都从工作目录开始解释。</p>
<h3 id="起始目录"><a href="#起始目录" class="headerlink" title="起始目录"></a>起始目录</h3><p>登录时，工作目录设置为起始目录（home directory）</p>
<blockquote>
<p>ls(l) 命令的简要实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span>  <span class="comment">//用于本书各个实例 包含某些标准头文件，定义了很多常量和函数模型</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt; // 使用opendir和readdir的函数原型，以及dirent结构的定义</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></div><div class="line">&#123;</div><div class="line">	DIR				*dp;</div><div class="line">	<span class="keyword">struct</span> dirent	*dirp;</div><div class="line"></div><div class="line">	<span class="comment">// 给出的参数不符</span></div><div class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</div><div class="line">		err_quit(<span class="string">"usage: ls directory_name"</span>);</div><div class="line">	<span class="comment">// 获取命令行的第一个参数，	打开目录，返回一个DIR结构指针</span></div><div class="line">	<span class="keyword">if</span> ((dp = opendir(argv[<span class="number">1</span>])) == <span class="literal">NULL</span>)</div><div class="line">		err_sys(<span class="string">"can't open %s"</span>, argv[<span class="number">1</span>]);</div><div class="line">	<span class="comment">// 读取目录并输出目录名</span></div><div class="line">	<span class="keyword">while</span> ((dirp = readdir(dp)) != <span class="literal">NULL</span>)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, dirp-&gt;d_name);</div><div class="line">	<span class="comment">// 关闭目录</span></div><div class="line">	closedir(dp);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>文件描述符( file descriptor)通常是一个小的非负整数,内核用以标识一个特定进程正在访 问的文件。当内核打开一个现有文件或创建一个新文件时,它都返回一个文件描述符。</p>
<h3 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h3><p> 按惯例,每当运行一个新程序时,所有的 shell i都为其打开3个文件描述符,即标准输入 standard input.)、标准输出( Istandard output)以及标准錯误( standard error)</p>
<h3 id="不带缓冲I-O"><a href="#不带缓冲I-O" class="headerlink" title="不带缓冲I/O"></a>不带缓冲I/O</h3><p> 函数open、read、write、lseek以及close提供了不带缓冲的I/O</p>
<p> 复制任意Unix普通文件</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	BUFFSIZE	4096</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span>		n;</div><div class="line">	<span class="keyword">char</span>	buf[BUFFSIZE];</div><div class="line"></div><div class="line">	<span class="comment">// STDIN_FILENO 和 STDOUT_FILENO指定标准输入输出的文件描述符 在POSIX标准，他们分别是0和1</span></div><div class="line">	<span class="comment">// read函数返回读取的字节数，此值作为写入的字节数传入write函数中</span></div><div class="line">	<span class="keyword">while</span> ((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">if</span> (write(STDOUT_FILENO, buf, n) != n)</div><div class="line">			err_sys(<span class="string">"write error"</span>);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</div><div class="line">		err_sys(<span class="string">"read error"</span>);</div><div class="line"></div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h3><p> 标准U/O函数为那些不带缓冲的I/O函数提供了一个带缓冲的接口。使用标准I/O函数无需 担心如何选取最佳的缓冲区大小</p>
<h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p> 程序（program）是存储在磁盘上某个目录中的一个可执行文件</p>
<h3 id="进程和进程ID"><a href="#进程和进程ID" class="headerlink" title="进程和进程ID"></a>进程和进程ID</h3><p> 程序执行实例被称为进程（process），Unix系统确保每一个进程都有唯一一个数字标识符，称为进程ID（process ID）</p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p> 有3个用于控制进程的主要函数：fork、exec和waitpid</p>
<h3 id="线程和线程ID"><a href="#线程和线程ID" class="headerlink" title="线程和线程ID"></a>线程和线程ID</h3><blockquote>
<p>shell 基本实施程序</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span>	buf[MAXLINE];	<span class="comment">/* from apue.h */</span></div><div class="line">	<span class="keyword">pid_t</span>	pid;</div><div class="line">	<span class="keyword">int</span>		status;</div><div class="line"></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%% "</span>);	<span class="comment">/* print prompt (printf requires %% to print %) */</span></div><div class="line"></div><div class="line">	<span class="comment">// 用标准I/O函数fgets从标准输入中读取一行</span></div><div class="line">	<span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</div><div class="line">		<span class="comment">// 因为fgets返回的每一行中都以换行符终止，但是execlp函数要求参数以null结束，所以用null替代每一行后面的换行符</span></div><div class="line">		<span class="keyword">if</span> (buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">'\n'</span>)</div><div class="line">			buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">/* replace newline with null */</span></div><div class="line"></div><div class="line">		<span class="comment">// fork创建子进程失败</span></div><div class="line">		<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</div><div class="line">			err_sys(<span class="string">"fork error"</span>);</div><div class="line">			<span class="comment">// 子进程处理：调用execlp从命令行输入读入命令，用新的程序文件替换子进程原来执行的程序文件</span></div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;		<span class="comment">/* child */</span></div><div class="line">			execlp(buf, buf, (<span class="keyword">char</span> *)<span class="number">0</span>);</div><div class="line">			err_ret(<span class="string">"couldn't execute: %s"</span>, buf);</div><div class="line">			<span class="built_in">exit</span>(<span class="number">127</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">/* parent */</span></div><div class="line">		<span class="comment">// 父进程通过waitpid等待子进程终止，指定等待的进程为参数</span></div><div class="line">		<span class="keyword">if</span> ((pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span>)</div><div class="line">			err_sys(<span class="string">"waitpid error"</span>);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%% "</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h2><p>当UINX系统函数出错时,通常会返回一个负值,而且整型变量 errno通常被设置为具有特定 信息的值。</p>
<p>对于 errno应应当注意两条规则<br>第一条规则是:如果没有出错,其值不会被例程清除。因此,仅当函数的返回值指明出错时,才检验其值。<br>第二条规则是:任何函数都不会将errn值设置为0,而且在&lt; errno.h&gt;中定义的所有常量都不为0</p>
<p>出错恢复</p>
<p>可将在&lt; errno.h&gt;中定义的各种出错分成两类:<strong>致命性的和非致命性的</strong>。对于致命性的错误, 无法执行恢复动作。最多能做的是在用户屏幕上打印出一条出错消息或者将一条出错消息写入日 志文件中,然后退出。对于非致命性的出错,有时可以较妥善地进行处理。大多数非致命性出错 是暂时的(如资源短缺),当系统中的活动较少时,这种出错很可能不会发生。</p>
<h2 id="用户标识"><a href="#用户标识" class="headerlink" title="用户标识"></a>用户标识</h2><h3 id="用户ID"><a href="#用户ID" class="headerlink" title="用户ID"></a>用户ID</h3><p>向系统标识各个不同的用户，用户ID为0的用户为根用户（root）或者超级用户（superuser）</p>
<h3 id="组ID"><a href="#组ID" class="headerlink" title="组ID"></a>组ID</h3><p>口令文件登录项包括用户的组ID（group ID），为一个数值。</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号( signal)用于通知进程发生了某种情况。进程有以下3种处理信号的方式。<br>(1)忽略信号。有些信号表示硬件异常,例如,除以0或访问进程地址空间以外的存储单元 等,因为这些异常产生的后果不确定,所所以不推荐使用这种处理方式。<br>(2)按系统狀认方式处理。对于除数为0,系统默认方式是终止该进程。<br>(3)提供一个函数,信号发生时调用该函数,这被称为捕捉该信号。通过提供自编的函数, 我们就能知道什么时候产生了信号,并按期望的方式处理它。</p>
<p>很多情况都会产生信号。终端键盘上有两种产生信号的方法,分别称为中断健( interrupt 通常是 Delete键或Ctl+C)和退出键( quit key,通常是Curl+4),它们被用于中断当前运行的进程。 另一种产生信号的方法是调用kill函数。在一个进程中调用此函数就可向另一个进程发送一个信 号。当然这样做也有些限制:当向一个进程发送信号时,我们必须是那个进程的所有者或者是超级 用户。</p>
<blockquote>
<p>能够处理终端的shell实例</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>	<span class="title">sig_int</span><span class="params">(<span class="keyword">int</span>)</span></span>;		<span class="comment">/* our signal-catching function */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span>	buf[MAXLINE];	<span class="comment">/* from apue.h */</span></div><div class="line">	<span class="keyword">pid_t</span>	pid;</div><div class="line">	<span class="keyword">int</span>		status;</div><div class="line"></div><div class="line">	<span class="comment">// 调用sinal函数，指定当产生SIGINT信号时，调用sig_int函数</span></div><div class="line">	<span class="keyword">if</span> (signal(SIGINT, sig_int) == SIG_ERR)</div><div class="line">		err_sys(<span class="string">"signal error"</span>);</div><div class="line"></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%% "</span>);	<span class="comment">/* print prompt (printf requires %% to print %) */</span></div><div class="line">	<span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</div><div class="line">		<span class="keyword">if</span> (buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">'\n'</span>)</div><div class="line">			buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">/* replace newline with null */</span></div><div class="line"></div><div class="line">		<span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</div><div class="line">			err_sys(<span class="string">"fork error"</span>);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;		<span class="comment">/* child */</span></div><div class="line">			execlp(buf, buf, (<span class="keyword">char</span> *)<span class="number">0</span>);</div><div class="line">			err_ret(<span class="string">"couldn't execute: %s"</span>, buf);</div><div class="line">			<span class="built_in">exit</span>(<span class="number">127</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">/* parent */</span></div><div class="line">		<span class="keyword">if</span> ((pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span>)</div><div class="line">			err_sys(<span class="string">"waitpid error"</span>);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%% "</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">sig_int</span><span class="params">(<span class="keyword">int</span> signo)</span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"interrupt\n%% "</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="时间值"><a href="#时间值" class="headerlink" title="时间值"></a>时间值</h2><p>历史上,UNIX系统使用过两种不同的时间值。<br>(1)日历时间。该值是自协调世界时( Coordinated Universal Time, UTC)1970年1月1日 00\:00:00这个特定时间以来所经过的秒数累计值(早期的手册称UTC为格林尼治标准时间)。这 些时间值可用于记录文件最近一次的修改时间等。 系统基本数据类型 time_t用于保存这种时间值<br>(2)进程时间。也被称为CPU时间,用以度量进程使用的中央处理器资源。进程时间以时钟滴答计算。每秒钟曾经取为50、60或100个时钟滴答。 系统基本数据类型clock_t保存这种时间值。</p>
<p>当度量一个进程的执行时间时,UNIX系统为一个进程维护了3个进程时间值: </p>
<ul>
<li>时钟时间 ,时钟时间又称为墙上时钟时间( wall clock time),它是进程运行的时间总量,其值与系统 中同时运行的进程数有关。</li>
<li>用户CPU时间,用户CPU时间是执行用户指令所用的时间量。</li>
<li>系统CPU时间 ，系统CPU时间是为该进程执行内核程序所经 历的时间。</li>
</ul>
<p>例如,每当一个进程执行一个系统服务时,如read或wrte,在内核内执行该服务所花费的时间就计入该进程的系统CPU时间。用户CPU时间和系统CPU时间之和常被称为CPU 时间。</p>
<h2 id="系统调用和函数库"><a href="#系统调用和函数库" class="headerlink" title="系统调用和函数库"></a>系统调用和函数库</h2><p>所有的操作系统都有提供多种服务的入口点，这些入口点被称为系统调用（system call）</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_6_1517923519865.jpg" alt="enter description here"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《UNIX环境高级编程》第1章笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="APUE" scheme="https://www.liuin.cn/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>《计算机网络——自顶向下方法》 笔记</title>
    <link href="https://www.liuin.cn/2018/02/05/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B-%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.liuin.cn/2018/02/05/《计算机网络——自顶向下方法》-笔记/</id>
    <published>2018-02-05T02:38:09.000Z</published>
    <updated>2018-02-23T04:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>阅读《计算机网络——自顶向下方法》过程中的笔记，持续更新中。</p>
<a id="more"></a>
<h1 id="计算机网络和因特网"><a href="#计算机网络和因特网" class="headerlink" title="计算机网络和因特网"></a>计算机网络和因特网</h1><h2 id="什么是因特网"><a href="#什么是因特网" class="headerlink" title="什么是因特网"></a>什么是因特网</h2><h3 id="具体构成描述"><a href="#具体构成描述" class="headerlink" title="具体构成描述"></a>具体构成描述</h3><p>端系统通过<strong>通信链路</strong>( communication link)和和<strong>分组交换机</strong>( packet switch)连接到一 起。</p>
<p>不同的链路能够以不同的速率传输 数据,链路的传输速率以<strong>比特/秒</strong>度量(bit/s,或bps)，当一台端系统要向另一台端系统 发送数据时,发送端系统将数据分段,并为每段加上首部字节。由此形成的信息包用计算 机网络的术语来说称为<strong>分组</strong>( packet)。</p>
<p>分组交换机从它的一条入通信链路接收到达的分组,并从它的一条出通信链路转发该分组。两种最著 名的类型是<strong>路由器</strong>( router)和<strong>链路层交换机</strong>(link- layer switch)。这两种类型的交换机朝 着最终目的地转发分组。链路层交换机通常用于接入网中,而路由器通常用于网络核心 中。</p>
<p>从发送端系统到接收端系统,一个分组所经历的一系列通信链路和分组交换机称为通 过该网络的<strong>路径</strong>( route或path)。</p>
<p>端系统通过<strong>因特网服务提供商</strong>( Internet Service Provider,SP)接人因特网,每个ISP是一个由多个分组交换机和多段通信 链路组成的网络。各ISP为端系统提供了各种不同类型的网络接入</p>
<p>端系统、分组交换机和其他因特网部件都要运行一系列协议( protocol),这些协议 控制因特网中信息的接收和发送。TCP( Transmission Control Protocol,传输控制协议) 和IP( Internet Protocol,网际协议)是因特网中两个最为重要的协议。</p>
<h3 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h3><blockquote>
<p>人类活动类比</p>
</blockquote>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517720029036.jpg" alt="enter description here"></p>
<blockquote>
<p>网络协议</p>
</blockquote>
<p>协议定义了在两个或多个通信实体之间交换的报文格式和次序,以及报文发送和/或接收一条报文或其他事件所采取的动作。</p>
<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p>通常把与因特网相连的计算机和其他设备称为端系 统。如图1-3所示,因为它们位于因特网的边缘,故而被称为端端系统。</p>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>网络核心,即由互联因特网端系统的<strong>分组交换机</strong>和<strong>链路</strong>构成的网状网络</p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>在各种网络应用中,端系统彼此交换<strong>报文</strong>( message)。为了从源端系统向目 的端系统发送一个报文,源将长报文划分为较小的数据块,称之为<strong>分组</strong>( packet)。在源和 目的之间,每个分组都通过<strong>通信链路和分组交换机</strong>( packet switch)(交换机主要有两类 路由器和链路层交换机)传送。</p>
<blockquote>
<p>存储转发传输</p>
</blockquote>
<p>多数分组交换机在链路的输入端使用<strong>存储转发传输</strong>( store-and- forward transmission ）机制。存储转发机制是指在交换机能够开始向输出链路传输该分组的第一个比特之前,必 须接收到整个分组。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517733216783.jpg" alt="enter description here"></p>
<blockquote>
<p>排队时延和分组丢失</p>
</blockquote>
<p>每个分组交换机有多条链路与之相连。对于每条相连的链路,该分组交换机具有一个 <strong>输出缓存</strong>( output buffer)(也称为输出队列 output queue),它用用于存储路由器准备发往那 条链路的分组。该输出缓存在分组交换中起着重要的作用。如果到达的分组需要传输到某 条链路,但发现该链路正忙于传输其他分组,该到达分组必须在该输出缓存中等待。</p>
<p>除了存储转发时延之外，分组还要承受输出缓存的<strong>排队时延</strong>（queue delay）</p>
<p>一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。在此情况下,将出现<strong>分组丢失(丢包)</strong>( packet lost),到达的分组或已经排队的分组之一将被丢弃。</p>
<blockquote>
<p>转发表和路由选择协议</p>
</blockquote>
<p>每台路由器具有一个<strong>转发表</strong> ( forwarding table),用于将目的地址(或目的地址的一部分)映射成为输出链路。</p>
<h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>在电路交换网络中,在端系统间通信会话期间,预留了端系统间通信沿路径所需要的 资源(缓存,链路传输速率)。在分组交换网络中,这些资源则不是预留的;会话的报文 按需使用这些资源,其后果可能是不得不等待(即    排队)接入通信线路。</p>
<blockquote>
<p>电路交换网络中的复用</p>
</blockquote>
<p>链路中的电路是通过<strong>频分复用</strong>( Frequency- Division Multiplexing,FDM)或<strong>时分复用</strong> (Time- Division Multiplexing,TDM)来实现的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517733959077.jpg" alt="enter description here"></p>
<h2 id="分组交换网中的时延、丢包和吞吐量"><a href="#分组交换网中的时延、丢包和吞吐量" class="headerlink" title="分组交换网中的时延、丢包和吞吐量"></a>分组交换网中的时延、丢包和吞吐量</h2><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><blockquote>
<p>时延类型</p>
</blockquote>
<p>处理时延+排队时延+传输时延+传播时延</p>
<h3 id="计算机网络中的吞吐量"><a href="#计算机网络中的吞吐量" class="headerlink" title="计算机网络中的吞吐量"></a>计算机网络中的吞吐量</h3><p>在任何时间瞬间 的<strong>瞬时吞吐量</strong>( instantaneous throughput)是主机B接收到该文件的速率(以bps计)。</p>
<p>如果该文件由F比特组成,主机B接收到所有F比特用去T秒,则 文件传送的<strong>平均吞吐量</strong>( average throughput)是F/Tbps。</p>
<h2 id="协议层次及其服务模型"><a href="#协议层次及其服务模型" class="headerlink" title="协议层次及其服务模型"></a>协议层次及其服务模型</h2><h3 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517734508197.jpg" alt="enter description here"></p>
<h2 id="面对攻击的网络"><a href="#面对攻击的网络" class="headerlink" title="面对攻击的网络"></a>面对攻击的网络</h2><h3 id="利用网络将有害程序放入你的计算机中"><a href="#利用网络将有害程序放入你的计算机中" class="headerlink" title="利用网络将有害程序放入你的计算机中"></a>利用网络将有害程序放入你的计算机中</h3><p>今天的多数恶意软件是<strong>自我复制</strong>(self- replicating)的:一旦它感染了一台主机,就会 从那台主机寻求进入更多的主机。</p>
<p><strong>病毒</strong>(virus)是一种需要某种形式的用户交 互来感染用户设备的恶意软件。</p>
<p><strong>蠕虫</strong>(worm)是一种无需任何明显用户交互就能进 入设备的恶意软件。</p>
<h3 id="攻击服务器和网络的基础设施"><a href="#攻击服务器和网络的基础设施" class="headerlink" title="攻击服务器和网络的基础设施"></a>攻击服务器和网络的基础设施</h3><p>另一种宽泛类型的安全性威胁称为<strong>拒绝服务攻击</strong>( Denial-of- Service(DoS) attack)。 顾名思义,DoS攻击使得网络、主机或其他基础设施部分不能由合法用户所使用。</p>
<p>大多数DOS攻击属于下列三种类型之一：</p>
<ul>
<li>弱点攻击</li>
<li>带宽洪泛</li>
<li>连接洪泛</li>
</ul>
<p>分布式DoS( Distributed Dos,DDoS)中,攻击者 控制多个源并让每个源向目标猛烈发送流量。使用这种方法,为了削弱或损坏服务器,遍 及所有受控源的聚合流量速率需要大约R的能力。</p>
<h3 id="嗅探分组"><a href="#嗅探分组" class="headerlink" title="嗅探分组"></a>嗅探分组</h3><p>记录每个流经的分组的副本的被动接收机成为<strong>分组嗅探器</strong>（packer sniffer）</p>
<hr>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><p>网络核心设备并不在应用层上 起作用,而仅在较低层起作用,特别是位于网络层及下面层次。这种基本设计,也即将应用软件限制在端系统的方法,促进了大量的网络应用程序的迅速研发和部署。</p>
<h3 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h3><p>应用程序体系结构( application architecture)由应用程序研发者设计, 规定了如何在各种端系统上组织该应用程序。在选择应用用程序体系结构时,应用程序研发 者很可能利用现代网络应用程序中所使用的两种主流体系结构之一:<strong>客户-服务器体系结 构</strong>或<strong>对等(P2P)体系结构</strong>。 </p>
<p>在客戶-服务器体系结构( client- server architecture)中,有一个总是打开的主机称为 服务器,它服务于来自许多其他称为客户的的主机的请求。一个经典的例子是Web应用程序。在一个客户-服务器应用中,常常会出现一台单独的服务器主机跟不上它所有客户请 求的情况。例如,一个流行的社交网络站点如果仅有一台服务器来处理所有请求,将很快 变得不堪重负。为此,配备大量主机的<strong>数据中心</strong>常被用于创建强大的虚拟服务器。</p>
<p>在一个P2P体系结构(P2 2 architecture)中,对位于数据中心的专用服务器有最小 的(或者没有)依赖。相反,应用程序在间断连接的主机对之间使用直接通信,这些 主机对被称为对等方。这些对等方并不为服务提供商所有,相反却为用户控制的桌面机 和膝上机所有,大多数对等方驻留在家庭、大学和办公室。P2P体系结构最引人入胜的特性之一就是他的自扩展性（self-scalability）。</p>
<p>未来P2P应用面临三个主要挑战：</p>
<ul>
<li>ISP友好。大多数住宅ISP(包括DSL和电缆ISP)已经受制于“非对称的”带宽 应用,也就是说,下载比上载要多得多。但是P2P视频流和文件分发应用改变了 从服务器到住宅ISP的上载流量,因而给ISP带来了巨大压力。</li>
<li>安全性。因为它们的高度分布和开放特性,P2P应用给安全带来挑战</li>
<li>激励。未来P2P应用的成功也取决于说服用户自愿向应用提供带宽、存储和计算 资源,这对激励设计带来挑战</li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>在操作系统的术语中,进行通信的实际上是进程( process)而不是程 序。一个进程可以被认为是运行在端系统中的一个程序。</p>
<p>在两个不同端系统上的进程,通过跨越计算机网络交换报文( message)而相互通信。 发送进程生成并向网络中发送报文;接收进程接收这些报文并可能通过将报文发送回去进 行响应。</p>
<blockquote>
<p>客户和服务器进程</p>
</blockquote>
<p>对每对通信进程, 我们通常将这两个进程之一标识为客户( cient),而另一个进程标识为服务器( server) 。</p>
<p>在P2P文件共享的某些应用中,一个进程能够既是客户又是服 务器。在P2P文件共享系统中,一个进程的确既能上载文件又能下载文件。</p>
<blockquote>
<p>进程与计算机网络之间的接口 </p>
</blockquote>
<p>多数应用程序是由通信进程对组成,每对中的两个进程互相发送报文。从 一个进程向另一个进程发送的报文必须通过下面的网络。进程通过一个称为套接字( socket) 的软件接口向网络发送报文和从网络接收报文。</p>
<p>由于该套接字是建立网络应用程序的可编程接口,因此套接字也 称为应用程序和网络之间的应用程序编程接口( Application Programming Interface,API)。</p>
<blockquote>
<p>进程寻址</p>
</blockquote>
<p>为了标识接受进程，需要两种信息：主机地址；定义在目的主机中的接收进程的标识符</p>
<p>在因特网中，主机由其IP地址标识，端口号用于标识后者。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517797198782.jpg" alt="enter description here"></p>
<h3 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h3><blockquote>
<p>可靠数据传输</p>
</blockquote>
<p>需要可靠数据传输的应用,必须做一些工作以确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端 ，如果一个协议提供了这样的确保数据交付服务,就认为提供了可靠数据传输( reliable data transfer)。</p>
<p> 当一个运输层协议不提供可靠数据传输时,由发送进程发送的某些数据可能不能够到 达接收进程。这可能能被容忍丢失的应用(los- tolerant application)所接受,最值得注意 的是多媒体应用,如交谈式音频/视频,它们能够承受一定量的数据丢失。</p>
<blockquote>
<p>吞吐量</p>
</blockquote>
<p>具有吞吐量要求的应用程序被称为 <strong>带宽敏感的应用</strong>( bandwidth- sensitive application)。许多当前的多媒体应用是带宽敏感的 尽管某些多媒体应用程序可能采用自适应编码技术对数字语音或视频以与当前可用带宽相 匹配的速率进行编码。</p>
<p>带宽敏感的应用具有特定的吞吐量要求,而而<strong>弹性应用</strong>( elastic application)能够根据 情况或多或少地利用可供使用的吞吐量。</p>
<blockquote>
<p>定时</p>
</blockquote>
<p>运输层协议能提供定时保证，</p>
<blockquote>
<p>安全性</p>
</blockquote>
<p>运输协议能够为应用程序提供一种或者多种安全性服务</p>
<h3 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h3><p>因特网(更一般的是TCP/P网络络)为应用程序 提供两个运输层协议,即UDP和TCP。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517797561137.jpg" alt="enter description here"></p>
<blockquote>
<p>TCP服务</p>
</blockquote>
<p>TCP服务模型包括面向连接服务和可靠数据传输服务：</p>
<ul>
<li>面向连接的服务:在应用层层数据报文开始流动之前,TCP让客户和服务器互相交 换运输层控制信息。这条连接是全双工的,即连接双方的进程可以在此连接 上同时进行报文收发。当应用程序结束报文发送时,必须拆除该连接。</li>
<li><p>可靠的数据传送服务:通信进程能够依靠TCP,<strong>无差错、按适当顺序交付</strong>所有发 送的数据。</p>
<p>TCP协议还具有拥塞控制机制,这种服务不一定能为通信进程带来直接好处,但能为 因特网带来整体好处。</p>
</li>
</ul>
<blockquote>
<p>TCP 安全</p>
</blockquote>
<p>无论TCP还是UDP都没有提供任何加密机制,这就是说发送进程传进其套接字的 数据,与经网络传送到目的进程的数据相同。</p>
<p>因特网界已经经研制了TCP的加强版 本,称称为安全套接字层( Secure Sockets Layer,SSL)。用SSL加强后的TCP不仅能够做 传统的TCP所能做的一切,而且提供了关键的进程到进程的安全性服务,包括加密、数 据完整性和端点鉴别。</p>
<blockquote>
<p>UDP 服务</p>
</blockquote>
<p>UDP是一种不提供不必要服务的轻量级运输协议,它仅提供最小服务。UDP是无连 接的,因此在两个进程通信前没有握手过程。UDP协议提供一种不可靠数据传送服务,也 就是说,当进程将一个报文发送进UDP套接字时,UDP协议并不保证该报文将到达接收 进程。不仅如此,到达接收进程的报文也可能是乱序到达的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517798026139.jpg" alt="enter description here"></p>
<h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p>应用层协议( application- layer protocol)定义了运行在不同 端系统上的应用程序进程如何相互传递报文。有些应用层协议是由RFC文档定义的,因此它们位于公共域中。例如,Web的应用</p>
<h2 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h2><p>Web是一个引起公众注意的因特网应用,它极大地改变了人们与工作环境内外交流的方式。它将因特网从只是很多数据网之一的地位提升为仅有的一个数据网。 也许对大多数用户来说,最具有吸引力的就是Web的按需操作。</p>
<h3 id="HTTP-概况"><a href="#HTTP-概况" class="headerlink" title="HTTP 概况"></a>HTTP 概况</h3><p>Web的应用层协议是超文本传输协议( Hypertext Transfer Protocol,HTTP),它是Web 的核心。HTTP由两个程序实现:一个客户程序和一个服务器程序。</p>
<p>HTTP使用TCP作为它的支撑运输协议 (而不是在UDP上运行)。HTTP客户首先发起 个与服务器的TCP连接。</p>
<p>因为HTP服务器并不保存关于客户的任何信息,所 以我们说HTTP是一个无状态协议议( stateless protocol)。</p>
<h3 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h3><p>每个请求/响应对是经一个单独的TCP连接发送,还是所有的请求及其响应经相同的TCP连接发送 ?采用前一种方法,该应用程序被称为使用<strong>非持续连接</strong>(non- persistent connection);采用后一种方法,该应用程序被称为使用<strong>持续连接</strong>( persistent connection)。</p>
<p>HTTP在其默认方式下使用持续连接，HTTP客户和服务器也能配置成使用非持续连接</p>
<p>非持续连接有一些缺点。首先,必须为每一个请求的对象建立和维护一个全新的对于每个这样的连接,在客户和服务器中都要分配TCP的缓冲区和保持TCP变量, 这给Web服务器带来了严重的负担,因为一台Web服务器可能同时服务于数以百计不同 的客户的请求。第二,每一个对象经受两倍RTT的交付时延, 即一个RTT用于创建TCP,另一个RTT用于请求和接收一个对象 </p>
<p>在采用持续连接的情况下,服务器在发送响应后保持该TCP连接打开。在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传送。</p>
<h3 id="HTTP-报文格式"><a href="#HTTP-报文格式" class="headerlink" title="HTTP 报文格式"></a>HTTP 报文格式</h3><blockquote>
<p>请求报文</p>
</blockquote>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517802240900.jpg" alt="enter description here"></p>
<blockquote>
<p>响应报文</p>
</blockquote>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517802525968.jpg" alt="enter description here"></p>
<h3 id="用户和服务器的交互：cookie"><a href="#用户和服务器的交互：cookie" class="headerlink" title="用户和服务器的交互：cookie"></a>用户和服务器的交互：cookie</h3><p>HTTP服务器是无状态的。这简化了服务器的设计,并且允许工程师 们去开发可以同时处理数以千计的TCP连接的高性能Web服务器。然而一个Web站点通 常希望能够识別用户,可能是因为服务器希望限制用户的访回,或者因为它希望把内容与 用户身份联系起来。为此,HTTP使用了 cookie。 它允许 站点对用户进行跟踪。目前大多数商务Web站点都使用了 cookie。</p>
<p> cookie技术有4个组件:<br> ①在HTTP响应报文中的一个 cookie首部 行;<br> ②在HTTP请求报文中的一个 cookie首部行;<br> ③在用户端系统中保留有一个 cookie文 件,并由用户的测览器进行管理;<br> ④位于Web站点的一个后端数据库。</p>
<p> <img src="https://data2.liuin.cn/story-writer/2018_2_5_1517802781498.jpg" alt="enter description here"></p>
<h3 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h3><p> Web缓存器( Web cache)也叫代理服务器( proxy server),它是能够代表 初始Web服务器来满足HTTP请求的网络实体。</p>
<p> <img src="https://data2.liuin.cn/story-writer/2018_2_5_1517802879780.jpg" alt="enter description here"></p>
<h3 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h3><p> HTTP协议有一种机制,允许缓存器证实它的对象是最新的。这种机制就是条件 GET( conditional GET)方法法。如果:①请求报文使用GET方法;并且(②请求报文中包 含一个“If- Modified- Since:”首部行。那么,这个HTTP请求报文就是一个条件GET请 求报文</p>
<h2 id="文件传输协议：FTP"><a href="#文件传输协议：FTP" class="headerlink" title="文件传输协议：FTP"></a>文件传输协议：FTP</h2><p>HTTP和FTP都是文件传输协议,并且有很多共同的特点,例如,它们都运行在TCP 上。然而,这两个应用层协议也有一些重要的区别。其中最显著的就是FTP使用了两个并行的TCP连接来传输文件,一个是<strong>控制连接</strong>( control connection),一个是<strong>数据连接</strong>(data connecton)。</p>
<p>控制连接用于在两主机之间传输控制信息,如用户标识、口令、改变远程目 录的命令以及“存放(put)”和和“获取(get)”文件的命令。数据据连接用于实际发送一个 文件。因为FTP协议使用一个独立的控制连接,所以我们也称FTP的控制信息是带外 (om-oand)传送的。</p>
<p>FTP服务器必须在整个会话期间保留用户的状态（state）</p>
<h2 id="因特网中的电子邮件"><a href="#因特网中的电子邮件" class="headerlink" title="因特网中的电子邮件"></a>因特网中的电子邮件</h2><p>因特网电子邮件系统由3个部分组成：用户代理、邮件服务器和简单邮件传输协议</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517826852365.jpg" alt="enter description here"></p>
<p>邮件服务器形成了电子邮件体系结构的核心。每个接收方(如Bob)在其中的某个邮 件服务器上有一个邮箱( mailbox)。</p>
<p>SMTP是因特网电子邮件中主要的应用层协议</p>
<h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>SMTP是因特网电子邮件应用的核心。如前所述, SMTP用于从发送方的邮件服务器发送报文到接收方的邮件服务器。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517827171046.jpg" alt="enter description here"></p>
<h3 id="与HTTP对比"><a href="#与HTTP对比" class="headerlink" title="与HTTP对比"></a>与HTTP对比</h3><p>这两个协议都用于从一台主机向另一台主机传 送文件:HTTP从Web服务器向Web客户(通常是一个测览器)传送文件(也称为对 象);SMTP从一个邮件服务器向另一个邮件服务器传送文件(即电子邮件报文)。当进行 文件传送时,持续的HTTP和SMTP都使用持续连接。因此,这两个协议有一些共同特征。 然而,两者之间也有一些重要的区别。</p>
<p>首先,<strong>HTTP主要是一个拉协议</strong>( pull protocol), 即在方便的时候,某些人在Web服务器上装载信息,用户使用HTTP从该服务器拉取这些 信息。特别是TCP连接是由想接收文件的机器发起的。另一方面,<strong>SMTP基本上是一个推 协议</strong>( push protocol),即发送邮件服务器把文件推向接收邮件服务器。特别是,这个TCP 连接是由要发送该文件的机器发起的。</p>
<p> 第二个区别就是我们前面间接地提到过的,<strong>SMTP要求每个报文(包括它们的体)使 用7比特ASC2码格式</strong>。如果某报文包含了非7比特ASCⅡ字符(如具有重音的法文 符)或二进制数据(如图形文件),则该报文必须按照7比特ASCⅡ码进行编码。HTP数 据则不受这种限制。 </p>
<p> 第三个重要区别是如何处理一个既包含文本又包含图形(也可能是其他媒体类型)的 文档。HTTP把每个对象封装到它自己的HTP响应报文中 而SMTP则把所有报文对象放在一个报文之中。</p>
<h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><p> 邮件访问使用了一种客户-服务器体系结构，即典型的用户通过在用户端系统上运行的客户程序来阅读电子邮件。</p>
<p> 目前有一些流行的的邮件访问协议,包括第三版的邮局协议( Post Offfice Protocol– Version3,POP3)、因特网邮件访问协议( Internet Mail Access Protocol,IMAP) 以及HTTP。</p>
<p> <img src="https://data2.liuin.cn/story-writer/2018_2_5_1517827622320.jpg" alt="enter description here"></p>
<h2 id="DNS：因特网的目录服务"><a href="#DNS：因特网的目录服务" class="headerlink" title="DNS：因特网的目录服务"></a>DNS：因特网的目录服务</h2><p> 因特网上的主机和人类一样,可以使用多种方式进行标识。主机的一种标识方法是用它 的<strong>主机名</strong>( hostname),这些名字便于记忆也乐于被人们接受。然而,主机名几平没有提供，况且,因为主机名可能由不定长的字母数字 组成,路由器难以处理。由于这些原因,主机也可以使用所谓<strong>IP地址</strong>( IP address)进行</p>
<h3 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h3><p>主机名到IP地址转换的目录服务——域名系统 ( Domain Name System,DNS)。</p>
<p>DNS是:</p>
<ul>
<li>①一个由分层的DNS服务器(DN server)实现的分布式数据库;</li>
<li><p>②一个使得主机能够査询分布式数据库的应用层协议。</p>
<p>DNS通常是由其他应用层协议所使用的,包括HTP、SMTP和FTP,将用户提供的主 机名解析为IP地址。</p>
<p>除了进行主机到IP地址的转换，DNS还提供了一些重要的服务：</p>
<ul>
<li>主机别名</li>
<li>邮件服务器别名</li>
<li>负载分配</li>
</ul>
</li>
</ul>
<h3 id="DNS工作原理概述"><a href="#DNS工作原理概述" class="headerlink" title="DNS工作原理概述"></a>DNS工作原理概述</h3><p>DNS的一种简单设计是在因特网上只使用一个DNS服务器,该服务器包含所有的映 射。在这种集中式设计中,客户直接将所有查询直接发往单一的DNS服务器,同时该 DNS服务器直接对所有的查询客户做出响应。尽管这种设计的简单性非常具有吸引力,但 它不适用于当今的因特网,因为因特网有着数量巨大(并持续增长)的主机这种集中式 设计的问题包括：</p>
<ul>
<li>单点故障( a single point of failure)，如果该DNS服务器崩溃,整个因特网随之 瘫痪! </li>
<li>通信容量( traffic volume)。单个DNS服务器不得不处理所有的DNS查询(用于为 上亿台主机产生的所有HTTP请求报文和电子邮件报文服务)</li>
<li>远距离的集中式数据库( distant centralized database)。单个DNS服务器不可能 “邻近”所有查询客户。如果我们将单台DNS服务器放在纽约市,那那么所有来自 澳大利亚的查询必须传播到地球的另一边边,中间也许还要经过低速和拥塞的链路。 这将导致严重的时延。</li>
<li>维护( maintenance)。单个DNS服务器将不得不为所有的因特网主机保留记录。</li>
</ul>
<p>在单一DNS服务器上运行集中式数据库完全没有可扩展能力。因此，DNS采用了分布式的设计方案：</p>
<ol>
<li>分布式，层次数据库</li>
</ol>
<p>为了处理扩展性问题,DNS使用了大量的DNS服务器,它们以层次方式组织,并且 分布在全世界范围内。没有一台DNS服务器拥有因特网上所有主机的映射。相反,该映射分布在所有的DNS服务器上。大致说来,有3种类型的DNS服务器:<strong>根DNS服务器、 顶级域DNS服务器和权威DNS服务器</strong>。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517829730009.jpg" alt="enter description here"></p>
<p>DNS查询有<strong>递归查询</strong>（recursive query）和<strong>迭代查询</strong>（iterative query）。</p>
<ol>
<li>DNS缓存</li>
</ol>
<p>为了改善时延性能并减 少在因特网上到处传输的DNS报文数量 DNS广泛使用了缓存技术。DNS缓存的原 理非常简单。在一个请求链中,当某DNS服务器接收一个DNS回答(例如,包含主 机名到IP地址的映射)时,它能将该回答 中的信息缓存在本地存储器中</p>
<p>由于主机和IP之间的映射并不是永久的，DNS服务器在一段时间将丢弃缓存信息。</p>
<h3 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h3><p>共同实现DNS分布式数据库的所有DNS服务器存储了<strong>资源记录</strong>( Resource Record, RR),RR提供了主机名到IP地址的映射。每个DNS回答报文包含了一条或多条资源记 录。</p>
<p>资源记录是一个包含了下列字段的4元组：<code>(Name, Value, Type, TTL)</code></p>
<p>TTL是该记录的生存时间,它决定了资源记录应当从缓存中删除的时间。</p>
<p>Name和 Value的值取决于Type: </p>
<ul>
<li>如果Type=A,则Name是主机名, Value是该主机名对应的P地址。因此,一条类型为A的资源记录提供了标准的主机名到IP地址的映射。</li>
<li>如果Type=NS,则Name是个域(如foo.com),而Vaue是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。</li>
<li>如果Type= CNAME,则 Value是别名为Name的主机对应的规范主机名。该记录 能够向查询的主机提供一个主机名对应的规范主机名</li>
<li>如果Type=MX,则 Value是个别名为Name的邮件服务器的规范主机名。</li>
</ul>
<blockquote>
<p>DNS 报文</p>
</blockquote>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517830574331.jpg" alt="enter description here"></p>
<h2 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h2><p>使用P2P体系结 构,对总是打开的基础设施服务器有最小的的(或者没有)依赖。与之相反,成对间歇连接 的主机(称为对等方)彼此直接通信。这些对等方并不为服务提供商所拥有,而是受用户 控制的桌面计算机和膝上计算机</p>
<h3 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h3><p>在客户-服务器文件分发中,该服务器必须向每个对等方发送该文件的一个副本,即服务 器承受了极大的负担,并且消消耗了大量的服务器带宽。在P2P文件分发中,每个对等方能 够重新分发它所有的该文件的任何部分,从而在分发过程程中协助该服务器。</p>
<p>到2012年止, 最为流行的P2P文件共享协议是 Bit Torrent。</p>
<blockquote>
<p>P2P体系结构的扩展性</p>
</blockquote>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517830919354.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_5_1517830933673.jpg" alt="enter description here"></p>
<blockquote>
<p>BitTorrent</p>
</blockquote>
<p>Bit Torrent是一种用于文件分发的流行P2P协议。用 Bittorrent的术语来 讲,参与一个特定文件分发的所有对等方的集合被称为一个<strong>洪流</strong>( torrent)。在一个洪流 中的对等方彼此下载等长度的<strong>文件块</strong>( chunk),典型的块长度为256KB。当一个对等方首次加入一个洪流时,它没有块。随着时间的流逝,它累积了越来越多的块。当它下载块 时,也为其他对等方上载了多个块。一旦某对等方获得了整个文件,它也许(自私地)离 开洪流,或(大公无私地)留在该洪流中并继续向其他对等方上载块。</p>
<p>每个洪流具有一个基础设施结点,称为<strong>追踪器</strong>( tracker)。当一个对等方加入 某洪流时,它向追踪器注册自己,并周期性地通知追踪器它仍在该洪流中。以这种方式, 追踪器跟踪正参与在洪流中的对等方。</p>
<p>对等方会周期性的询问每个邻近的对等方他们所具有的块列表。同时还要解决一些问题：第一,她应当从她的邻居请求哪些块呢?第二,她 应当向哪些向她请求块的邻居发送?</p>
<p>在决定请求哪些块的过程中,每一个对等方使用一种称为<strong>最稀缺优先</strong>( rarest first)的技术。这种技术的思路是,针对她没有的块在她的邻居中决定最 稀缺的块(最稀缺的块就是那些在她的邻居中副本数量最少的块),并首先请求那些最稀 缺的块。这样,最稀缺块得到更为迅速的重新分发,其目标是(大致地)均衡每个块在洪流中的副本数量。</p>
<h2 id="TCP-套接字编程"><a href="#TCP-套接字编程" class="headerlink" title="TCP 套接字编程"></a>TCP 套接字编程</h2><h3 id="UDP套接字编程"><a href="#UDP套接字编程" class="headerlink" title="UDP套接字编程"></a>UDP套接字编程</h3><p>发送进程为分组附上的目的地址是由目的主机的IP地址和目的套接字的端口号组成。</p>
<p>发送方的源地址也是由源主机的IP地址和源套接字的端口号组成</p>
<p>示例程序：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_7_1517978583354.jpg" alt="enter description here"></p>
<p>UDPclient.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 引入socket包，python网络通信的基础</span></div><div class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</div><div class="line"></div><div class="line"><span class="comment"># 提供IP地址（域名）和端口号</span></div><div class="line">serverName = <span class="string">'hostname'</span></div><div class="line">serverPort = <span class="number">12000</span></div><div class="line"></div><div class="line"><span class="comment"># 创建客户套接字，AF_INET表示底层网络使用IPv4，SOCK_DGRAM表示为UDP套接字</span></div><div class="line">clientSocket = socket(AF_INET, SOCK_DGRAM)</div><div class="line">message = raw_input(<span class="string">'Input lowercase sentence'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 向目的套接字发送</span></div><div class="line">clientSocket.sendto(message,(serverName,serverPort))</div><div class="line"></div><div class="line"><span class="comment"># 接收分组，取2048作为缓存输入</span></div><div class="line">modifiedMessage, serverAddress = clientSocket.recvform(<span class="number">2048</span>)</div><div class="line"></div><div class="line">print(modifiedMessage)</div><div class="line">clientSocket.close()</div></pre></td></tr></table></figure></p>
<p>UDPserver.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</div><div class="line"></div><div class="line">serverPort = <span class="number">12000</span></div><div class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</div><div class="line"></div><div class="line"><span class="comment"># 将服务器端口和套接字绑定在一起</span></div><div class="line">serverSocket.bind(<span class="string">''</span>, serverPort)</div><div class="line"></div><div class="line">print(<span class="string">"The server is ready to receive"</span>)</div><div class="line"><span class="keyword">while</span> ture:</div><div class="line">    message, clientAddress = serverSocket.recvform(<span class="number">2048</span>)</div><div class="line">    modifiedMessage = message.upper()</div><div class="line">    serverSocket.sendto(modifiedMessage, clientAddress)</div></pre></td></tr></table></figure></p>
<h3 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h3><p>与UDP不同，TCP是一个面向连接的协议。这意味着客户和服务器能够相互发送数据之前，他们要先握手创建一个TCP连接。</p>
<p>注意两点：<br>第一,与在UDP中的情况一样,TCP服务器在客户试图发起接触前必须作 为进程运行起来。<br>第二,服务器程序必须具有一扇特殊的门,更精确地说是一个特殊的套 接字,该门门欢迎来自运行在任意主机上的客户进程的某些初始接触。使用房子/门来比喻 进程/套接字,有时我们将客户的初始接触称为“敲欢迎之门”。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_7_1517979977215.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_7_1517980098223.jpg" alt="enter description here"></p>
<p>TCPclient.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</div><div class="line"></div><div class="line">serverName = <span class="string">'servername'</span></div><div class="line">serverPort = <span class="number">12000</span></div><div class="line"></div><div class="line">clientSocket = socket(AF_INET, SOCK_STREAM)</div><div class="line"><span class="comment"># 不同之处，传输数据之前要先进行连接</span></div><div class="line">clientSocket.connect((serverName, serverPort))</div><div class="line"></div><div class="line">sentence = raw_input(<span class="string">'Input lowercase sentence'</span>)</div><div class="line">clientSocket.send(sentence)</div><div class="line">modifiedSentence = clientSocket.recv(<span class="number">1024</span>)</div><div class="line"></div><div class="line">print(<span class="string">"From server:"</span>, modifiedSentence)</div><div class="line">clientSocket.close()</div></pre></td></tr></table></figure></p>
<p>TCPserver.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</div><div class="line"></div><div class="line">serverPort = <span class="number">12000</span></div><div class="line"><span class="comment"># 创建TCP套接字</span></div><div class="line">serverSocket = socket(AF_INET, SOCK_STREAM)</div><div class="line"></div><div class="line"><span class="comment"># serverSocket 是我们的欢迎套接字</span></div><div class="line">serverSocket.bind(<span class="string">''</span>, serverPort)</div><div class="line">serverSocket.lisetn(<span class="number">1</span>)</div><div class="line">print(<span class="string">"The server is ready to receive"</span>)</div><div class="line"></div><div class="line"><span class="keyword">while</span> ture:</div><div class="line">    <span class="comment"># 当客户端敲门时，创建一个服务的新套接字</span></div><div class="line">    connectionSocket ,addr = serverSocket.accept()</div><div class="line">    sentence = connectionSocket.recv(<span class="number">1024</span>)</div><div class="line">    capitalizedSentence = sentence.upper()</div><div class="line">    connectionSocket.sendto(capitalizedSentence)</div><div class="line">    connectionSocket.close()</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读《计算机网络——自顶向下方法》过程中的笔记，持续更新中。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Network" scheme="https://www.liuin.cn/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Git 分支</title>
    <link href="https://www.liuin.cn/2018/02/04/Git-%E5%88%86%E6%94%AF/"/>
    <id>https://www.liuin.cn/2018/02/04/Git-分支/</id>
    <published>2018-02-04T13:06:54.000Z</published>
    <updated>2018-02-23T04:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>《Pro Git》读书笔记</p>
<p>接触Git这个工具已经很长一段时间了，用起来也是一直是半生不熟的状态，索性寒假有时间就系统的学习一下。选择的是《Pro Git》，讲解得非常详细的。</p>
<a id="more"></a>
<hr>
<p>几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。</p>
<p>Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。</p>
<h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><p>Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。</p>
<p>首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在Git 仓库中这些校验和保存为树对象。</p>
<p>Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。</p>
<p><strong>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。</strong></p>
<p>Git 又是怎么知道当前在哪一个分支上呢？也很简单，它有一个<strong>名为 HEAD 的特殊指针</strong>。请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 HEAD 概念完全不同。在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517735734642.jpg" alt="enter description here"></p>
<blockquote>
<p>分支切换会改变你工作目录中的文件</p>
</blockquote>
<p>在切换分支时，一定要注意你工作目录里的文件会被改变。如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。</p>
<p>由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。</p>
<h2 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h2><p>在切换分支的时候，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。最好的方法是，在你切换分支之前，保持好一个干净的状态。</p>
<p>请牢记：<strong>当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。</strong></p>
<p>在合并的时候，你应该注意到了”快进（fast-forward）”这个词。由于当前 master 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。</p>
<p>另外一种更加普遍的合并情况是：Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的工作祖先（C2），做一个简单的三方合并。</p>
<h3 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h3><p>如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。此时 Git 做了合并，但是没有自动地创建一个新的合并提交。Git 会暂停下来，等待你去解决合并产生的冲突。你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并</p>
<h2 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h2><h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p>在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517736327603.jpg" alt="enter description here"></p>
<h3 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517736357963.jpg" alt="enter description here"></p>
<h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><p>在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_4_1517736500075.jpg" alt="enter description here"></p>
<p>如上图所示，提取在 C4 中引入的补丁和修改，然后在 C3 的基础上再应用一次。在 Git 中，这种操作就叫做 变基。</p>
<p>它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master）的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。</p>
<h3 id="更有趣的变基例子"><a href="#更有趣的变基例子" class="headerlink" title="更有趣的变基例子"></a>更有趣的变基例子</h3><p>在对两个分支进行变基时，所生成的“重演”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。就像 <strong>从一个特性分支里再分出一个特性分支</strong>的提交历史 中的例子这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rebase --onto master server client</div></pre></td></tr></table></figure>
<p>以上命令的意思是：“取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然后把它们在 master 分支上重演一遍”。这理解起来有一点复杂，不过效果非常酷。</p>
<p>使用 git rebase [basebranch] [topicbranch] 命令可以直接将特性分支（即本例中的 server）变基到目标分支（即 master）上。这样做能省去你先切换到server 分支，再对其执行变基命令的多个步骤。</p>
<h3 id="变基的风险"><a href="#变基的风险" class="headerlink" title="变基的风险"></a>变基的风险</h3><p>奇妙的变基也并非完美无缺，要用它得遵守一条准则：<strong>不要对在你的仓库外有副本的分支执行变基</strong>。</p>
<p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。</p>
<p>只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，你就不会有事。</p>
<h3 id="变基vs合并"><a href="#变基vs合并" class="headerlink" title="变基vs合并"></a>变基vs合并</h3><p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。它是针对历史的文档，本身就有价值，不能乱改。从这个角度看来，改变提交历史是一种亵渎，你使用<em>谎言</em>掩盖了实际发生过的事情。如果由合并产生的提交历史是一团糟怎么办？既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅</p>
<p>。另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的故事</strong>。没人会出版一本书的第一批草稿，软件维护手册也是需要反复修订才能方便使用。持这一观点的人会使用 rebase 及 filter-branch等工具来编写故事，怎么方便后来的读者就怎么写。</p>
<p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Pro Git》读书笔记&lt;/p&gt;
&lt;p&gt;接触Git这个工具已经很长一段时间了，用起来也是一直是半生不熟的状态，索性寒假有时间就系统的学习一下。选择的是《Pro Git》，讲解得非常详细的。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="https://www.liuin.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 并发编程</title>
    <link href="https://www.liuin.cn/2018/02/03/CSAPP-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.liuin.cn/2018/02/03/CSAPP-并发编程/</id>
    <published>2018-02-03T10:58:52.000Z</published>
    <updated>2018-02-23T04:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>《深入理解计算机系统》第12章笔记</p>
<a id="more"></a>
<p>如果逻辑流在时间上重叠，那么它们就是并发（concurrent）的。并发性不仅仅局限于内核，他也可以在应用中也扮演着重要的角色：</p>
<ul>
<li>在多处理器上进行并行计算</li>
<li>访问慢速I/O设备</li>
<li>与人交互</li>
<li>通过推迟工作以减少执行时间</li>
<li>服务多个网络客户端</li>
</ul>
<p>现代操作系统提供了三种基本的构造并发程序的方法：</p>
<ul>
<li>进程。用这种方法，每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显式的进程间通信(interprocess communication, IPC)机制。</li>
<li>I/O 多路复用。在这种形式的并发编程中，应用程序在一个进程的上下文中显式地调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一个状态。因为程序是一个单独的进程，所以所有的流都共享同一个地址空间。</li>
<li>线程。线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。你可以把线程看成是其他两种方式的混合体，像进程流一样由内核进行调度，而像 I/O 多路复用一样共享同一个虚拟地址空间。</li>
</ul>
<h2 id="基于线程的并发编程"><a href="#基于线程的并发编程" class="headerlink" title="基于线程的并发编程"></a>基于线程的并发编程</h2><p>构造并发程序最简单的方法就是用进程，使用那些大家都很熟悉的函数，像 fork, exec 和 waitpid。</p>
<p>对于在父、子进程间共享状态信息，进程有一个非常清晰的模型：<strong>共享文件表，但是不共享用户地址空间</strong>。进程有独立的地址空间既是优点也是缺点。这样一来，一个进程不可能不小心覆盖另一个进程的虚拟存储器，这就消除了许多令人迷惑的错误。</p>
<p>另一方面，<strong>独立的地址空间使得进程共享状态信息变得更加困难</strong>。为了共享信息，它们必须使用显式的 IPC 机制。基于进程的设计的另一个缺点是，它们往往比较慢，因为进程控制和 IPC 的开销很高。</p>
<h2 id="基于I-O多路复用的并发编程"><a href="#基于I-O多路复用的并发编程" class="headerlink" title="基于I/O多路复用的并发编程"></a>基于I/O多路复用的并发编程</h2><p>I/O 多路复用可以用作并发<strong>事件驱动</strong>(event-driven)程序的基础，在事件驱动程序中，流是因为某种事件而前进的。一般概念是将逻辑流模型化为<strong>状态机</strong>。不严格地说，一个状态机(state machine)就是一组状态(state)、输入事件(input event)和转移(transition)，其中转移就是将状态和输入事件映射到状态。每个状态都将一个(输入状态，输入事件)对映射到一个输出状态。自循环(self-loop)是同一组输入和输出状态之间的转移。通常把状态机花城有向图，其中节点表示状态，有向弧表示转移，而弧上的标号表示输入事件。一个状态机从某种初始状态开始执行。每个输入事件都会引发一个从当前状态到下一状态的转移。</p>
<p>事件驱动设计的一个优点是，它比基于进程的设计给了程序员更多的对程序行为的控制。另一个优点是在流之间共享数据变得很容易，而且事件驱动设计常常比基于进程的设计要高效得多，因为它们不需要进程上下文切换来调度新的流。</p>
<p>事件驱动设计的一个明显的缺点就是编码复杂，另一重大缺点时它们不能充分利用多核处理器。</p>
<h2 id="基于线程的并发编程-1"><a href="#基于线程的并发编程-1" class="headerlink" title="基于线程的并发编程"></a>基于线程的并发编程</h2><p>一个线程（thread）就是运行在一个进程上下文中的一个逻辑流。每个线程都有它自己的<strong>线程上下文</strong>(thread context)，包括一个唯一的整数线程ID(Thread ID, TID)、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。</p>
<p>基于线程的逻辑流结合了基于进程和基于I/O多路复用的流的特点</p>
<h3 id="线程执行模型"><a href="#线程执行模型" class="headerlink" title="线程执行模型"></a>线程执行模型</h3><p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517653797354.jpg" alt="enter description here"></p>
<h2 id="多线程程序中的共享变量"><a href="#多线程程序中的共享变量" class="headerlink" title="多线程程序中的共享变量"></a>多线程程序中的共享变量</h2><p>线程很有吸引力的一个方面就是多个线程很容易共享相同的程序变量</p>
<h3 id="线程存储器模型"><a href="#线程存储器模型" class="headerlink" title="线程存储器模型"></a>线程存储器模型</h3><p>一组并发线程运行在一个进程的上下文中。每个线程都有它自己独立的线程上下文，包括线程 ID、栈、栈指针、程序计数器、条件码和通用目的寄存器。每个线程和其他线程一个共享进程上下文的剩余部分。这包括整个用户虚拟地址空间，它是由只读文本(代码)、读/写数据、堆以及所有的共享库代码和数据区域组成的。</p>
<p>从实际操作的角度来说，让一个线程去读写另一个线程的寄存器是不可能的。寄存器不是共享的，而虚拟存储器是共享的。</p>
<h3 id="将变量映射到存储器"><a href="#将变量映射到存储器" class="headerlink" title="将变量映射到存储器"></a>将变量映射到存储器</h3><p>线程化的 C 程序中变量根据它们的存储类型被映射到虚拟存储器：</p>
<ul>
<li>全局变量：在运行时，虚拟存储器的读/写区域只包含每个全局变量的一个实例，任何线程都可以引用</li>
<li>本地自动变量：定义在函数内部但是没有 static 属性的变量。在运行时，每个线程的栈都包含它自己的所有本地自动变量的实例</li>
<li>本地静态变量：定义在函数内部并有 static 属性的变量，和全局变量一样</li>
</ul>
<h2 id="用信号量同步线程"><a href="#用信号量同步线程" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h2><p>共享变量十分方便，但是它们也引入了同步错误（synchronization error）的可能性。</p>
<h3 id="进度图"><a href="#进度图" class="headerlink" title="进度图"></a>进度图</h3><p>一个进度图( progress graph)将个并发线程的执行模型化为一条维笛卡儿空间中的轨线。 每条轴k对应于线程k的进度。每个点(1,2…,n)代表线程k(k=1,,n)已经完成了指令I(k)这一个状态</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517654269007.jpg" alt="enter description here"></p>
<p>一个进度图将指令执行模型化为一个从一种状态到另一种状态的转換( transition)。一个转换被 表示为一条从一点到相邻点的有向边。合法的转换是向右(线程1中的一条指令完成)或者向上(线 程2中的一条指令完成)的。两个指令不能在同一时刻完成一一对角线转換是不允许的。程序决不 会反向运行,所以向下或者向左移动的转换也是不合法的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517654474783.jpg" alt="enter description here"></p>
<p>环绕不安全区的轨线叫做<strong>安全轨线</strong>( safe trajectory)。相反,接触任何不安全区的轨线就叫做<strong>不安全轨线</strong>( unsafe trajectory)。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517654599444.jpg" alt="enter description here"></p>
<p>任何安全轨迹都将正确地更新共享计数器。</p>
<h3 id="利用信号量访问共享变量"><a href="#利用信号量访问共享变量" class="headerlink" title="利用信号量访问共享变量"></a>利用信号量访问共享变量</h3><p>一种经典的解决同步不同执行线程问题的方法：基于一种叫做信号量( semaphore)的特殊类型变量的。信号量s是具有非负整数值的全局变量,只能由两种特殊的操作来处理,这两种操作称为P和V。</p>
<ul>
<li>P(s):如果s是非零的,那么P将s减1,并且立即返回。如如果s为零,那么就挂起进程, 直到s变为非零,并且该进程被一个V操作重启。在重启之后,P操作将s减1,并将控制 返回给调用者。 </li>
<li>V(s):操作将s加1。如果有任何进程阻塞在P操作等待s变成非零,那么V操作会重启 这些进程中的一个,然后该进程将s减1,完成它的P操作</li>
</ul>
<p>P和和V的定义确保了一个运行程序绝不可能进入这样一种状态,也就是一个正确初始化了的信 号量有一个负值。这个属性称为信号量不变性( semaphore invariant),为控制并发程序的轨线而避 免不安全区提供了强有力的工具。 </p>
<p>基本的思想是将每个共享变量(或者相关共享变量集合)与一个信号量s(初始为1)联系起来, 然后用P(s)和W(s)操作将相应的临界区包围起来。以这种方式来保护共享变量的信号量叫做二进制 信号量( binary semaphore),因为它的值总是0或者1。</p>
<h3 id="利用信号量来调度共享资源"><a href="#利用信号量来调度共享资源" class="headerlink" title="利用信号量来调度共享资源"></a>利用信号量来调度共享资源</h3><p>信号量另一个重要的作用是调度对共享资源的访问，一个线程用信号量来通知另一个线程，程序状态中的某个量已经为真了。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517654937600.jpg" alt="enter description here"></p>
<h2 id="其他并发性问题"><a href="#其他并发性问题" class="headerlink" title="其他并发性问题"></a>其他并发性问题</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>当我们用线程编写程序时,我们必须小心地编写那些具有称为线程安全性( thread safety)属性 的函数。一个函数被称为线程安全的( thread- safe),当且仅当被<strong>多个并发线程反复地调用时,它会 一直产生正确的结果</strong>。如果一个函数不是线程安全的,我们就说它是线程不安全的( thread-unsafe)。 我们能够定义出四类(有相交的)线程不安全函数:</p>
<ul>
<li>不保护共享变量的函数</li>
<li>保持跨越多个调用的状态的函数</li>
<li>返回指向静态变量的指针函数</li>
<li>调用线程不安全函数的函数</li>
</ul>
<h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>有一类重要的线程安全函数,叫做<strong>可重入函数</strong>( reentrant function),其特点在于它们具有这样 种属性:<strong>当它们被多个线程调用时,不会引用任何共享数据。</strong></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517655306363.jpg" alt="enter description here"></p>
<h3 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h3><p>当一个程序的正确性依赖于一个线程要在另一个线程到达y点之前到达它的控制流中的x点时, 就会发生<strong>竞争</strong>(race)。通常发生竟争是因为程序员假定线程将按照某种特殊的轨线穿过执行状态空 间,而忘记了另一条准则规定定:多线程程序必须对任何可行的轨线都正确工作。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>一组线程被阻塞了，等待一个永远也不会为真的条件</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_3_1517655428227.jpg" alt="enter description here"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>无论哪种并发机制，同步对于共享数据的并发访问都是一个困难的问题。提出对信号的 P 和 V 操作就是为了帮助解决这个问题。信号量操作可以用来提供对共享数据的互斥访问，也对诸如生产者-消费者程序中有限缓冲区和读者-写者系统中的共享对象这样的资源访问进行调度。</p>
<p>并发也引入了其他一些困难的问题。被线程调用的函数必须具有一种称为线程安全的属性。竞争和死锁是并发程序中出现的另一些困难的问题。当程序员错误地假设逻辑流该如何调度时，就会发生竞争。当一个流等待一个永远不会发生的事件时，就会产生死锁。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《深入理解计算机系统》第12章笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSAPP" scheme="https://www.liuin.cn/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 网络编程</title>
    <link href="https://www.liuin.cn/2018/02/02/CSAPP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.liuin.cn/2018/02/02/CSAPP-网络编程/</id>
    <published>2018-02-02T03:27:46.000Z</published>
    <updated>2018-02-23T04:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>《深入理解计算机系统》第11章笔记</p>
<a id="more"></a>
<p>网络应用随处可见。有趣的是，所有的网络应用都是基于相同的基本编程模型，有着相似的整体逻辑结构，并且一来相同的编程接口。</p>
<p>网络应用依赖于很多在系统研究正已经学习过的概念，例如，进程、信号、字节顺序、存储器映射以及动态存储分配，都扮演着重要的角色。</p>
<h2 id="客户端-服务器编程模型"><a href="#客户端-服务器编程模型" class="headerlink" title="客户端-服务器编程模型"></a>客户端-服务器编程模型</h2><p>每一个网络应用都是基于<code>客户端-服务器模型</code>的，采用这个模型，一个应用是由一个服务器进程和一个或者多个客户端进程组成。服务器管理某种资源，并且通过操作这种资源来为它的客户端提供某种服务。</p>
<p>客户端-服务器模型中的基本操作时<strong>事务（ttansaction）</strong>。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540316932.jpg" alt="enter description here"></p>
<p>认识到客户端和服务器是进程，而不是机器或者主机，这一点很重要。</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>客户端和服务器通常运行在不同的主机上，并且通过<strong>计算机网络</strong>的硬件和软件资源来通信。对于一台主机而言，网络只是又一种 I/O 设备，作为数据源和数据接收方，如下图所示。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540421619.jpg" alt="enter description here"></p>
<p>物理上而言，网络是一个按照地理远近组成的层次系统。最底层是 LAN(Local Area Network, 局域网)，在一个建筑或者校园范围内。迄今为止，最流行的局域网技术是以太网(Ethernet)。</p>
<p>每个以太网适配器都有一个全球唯一的 48 位地址，一台主机可以发送一段位，称为帧(frame)，到这个网段内的其他任何主机。每个帧包括一些固定数量的头部(header)位，用来标识此帧的源和目的地址以及此帧的长度，伺候紧随的就是数据位的有效载荷。每个主机适配器都能看到这个帧，但是只有目的主机实际读取它。</p>
<p>使用一些电缆和叫做网桥(bridge)的小盒子，多个以太网段可以连接成较大的局域网，称为<strong>桥接以太网</strong>(bridged Ethernet)，如下图所示：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540470497.jpg" alt="enter description here"></p>
<p>在层次更高的级别中，多个不兼容的局域网可以通过叫做<strong>路由器</strong>(router)的忒书计算机连接起来，组成一个internet(互联网络)。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540536223.jpg" alt="enter description here"></p>
<p>internet（互联网络）至关重要的特性是，它能采用完全不同和不兼容技术的各种局域网和广域网组成。</p>
<p>在互联网中，数据是如何从一台主机传送到另一台主机的：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540792401.jpg" alt="enter description here"></p>
<h2 id="全球IP因特网"><a href="#全球IP因特网" class="headerlink" title="全球IP因特网"></a>全球IP因特网</h2><p>协议软件消除了不同网络之间的差异，必须具备两种基本能力：命名机制和传送机制。</p>
<p>每台因特网主机都运行实现 <strong>TCP/IP 协议</strong>(Transmission Control Protocol/Internet Protocol)的软件，几乎每个现代计算机系统都支持这个协议。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540858886.jpg" alt="enter description here"></p>
<p>TCP/IP 实际上是一个协议族，其中每一个都提供不同的功能。从程序员角度，我们可以把因特网看做一个世界范围的主机集合，满足以下特性：</p>
<ul>
<li>主机集合被映射为一组 32 位的 IP 地址</li>
<li>这组 IP 地址被映射为一组称为因特网域名(Internet domain name)的标识符</li>
<li>因特网主机上的进程能够通过连接(connection)和任何其他因特网主机上的进程通信</li>
</ul>
<h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p> 一个 IP 地址就是一个 32 位无符号整数。IP 地址通常是以一种称为点分十进制表示法来表示的，这里，每个字节由它的十进制值表示，并且用句点和其他字节间分开。</p>
<h3 id="因特网域名"><a href="#因特网域名" class="headerlink" title="因特网域名"></a>因特网域名</h3><p>域名集合形成了一个层次结构，每个域名编码了它在这个层次中的位置。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517540938762.jpg" alt="enter description here"></p>
<p>因特网定义了域名集合和IP地址集合之间的映射，这个映射是通过分布世界范围内的数据库——DNS（域名系统）来维护的。</p>
<h3 id="因特网连接"><a href="#因特网连接" class="headerlink" title="因特网连接"></a>因特网连接</h3><p>因特网客户端和服务器通过在连接上发送和接收字节流来通信。从连接一对进程的意义上而言，连接是点对点的。从数据可以同时双向流动的角度来说，它是全双工的。并且由源进程发出的字节流最终被目的进程以它发出的顺序收到它的角度来说，它是可靠的。</p>
<p><strong>一个套接字是连接的一个端点</strong>。每个套接字都有相应的套接字地址，是由一个因特网地址和一个 16 位的整数端口组成的，用地址:端口来表示。当客户端发起一个连接请求时，客户端套接字地址中的端口是由内核自动分配的，称为临时端口(ephemeral port)。然而，服务器套接字地址中的端口通常是某个知名的端口，是和这个服务相对应的。例如，Web 服务器通常使用端口 80，而电子邮件服务器使用端口 25。在 Unix 机器上，文件 /etc/services 包含一张这台机器提供的服务以及它们的知名端口号的综合列表。</p>
<p>一个连接由它两端的套接字地址唯一确定。这对套接字地址叫做套接字对(socket pair)，由下列元组来表示：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517541075440.jpg" alt="enter description here"></p>
<h2 id="套接字接口"><a href="#套接字接口" class="headerlink" title="套接字接口"></a>套接字接口</h2><p><strong>套接字接口</strong>(socket interface)是一组函数，它们和 Unix I/O 函数结合起来，用以创建网络应用。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517541130564.jpg" alt="enter description here"></p>
<h2 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h2><h3 id="Web基础"><a href="#Web基础" class="headerlink" title="Web基础"></a>Web基础</h3><p>Web 客户端和服务器之间的交互用的是一个基于文本的应用级协议，叫做 HTTP(Hypertext Transfer Protocol)。HTTP 是一个简单的协议。一个 Web客户端打开一个到服务器的因特网连接，并且请求某些内容。服务器响应所请求的内容，然后关闭连接。浏览器读取这些内容，并把它显示在屏幕上。</p>
<h3 id="Web内容"><a href="#Web内容" class="headerlink" title="Web内容"></a>Web内容</h3><p>对于 Web 客户端和服务器而言，内容是一个与 MIME(Multipurpose Internet Mail Extensions)类型相关的字节序列。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_2_1517541249812.jpg" alt="enter description here"></p>
<p>Web 服务器以两种不同的方式向客户端提供内容：</p>
<ul>
<li>取一个磁盘文件，并将它的内容返回给客户端。磁盘文件称为静态内容(static content)，而返回文件给客户端的过程称为服务静态内容(serving static content)。</li>
<li>运行一个可执行文件，并将它的输出返回给客户端。运行时可执行文件产生的输出称为动态内容(dynamic content)，而运行程序并返回它的输出到客户端的过程称为服务动态内容(serving dynamic content)。</li>
</ul>
<p>每条由 Web 服务器返回的内容都是和它管理的某个文件相关联的。这些文件中的每一个都有一个唯一的名字，叫做 URL(Universal Resource Locator)。</p>
<p>关于服务器如何解释一个 URL 的后缀，以下几点需要理解：</p>
<ul>
<li>确定一个 URL 指向的是静态内容还是动态内容没有标准的规则。每个服务器对它所管理的文件都有自己的规则。一种常见方法是，确定一组目录，例如 cgi-bin，所有的可执行文件都必须存放这些目录中。</li>
<li>后缀中的最开始的那个 / 不表示 Unix 的根目录。相反，它表示的是被请求内容类型的主目录。例如，可以将一个服务器配置成这样：所有的静态内容存放在目录 /usr/httpd/html 下。</li>
<li>最小的 URL 后缀是 / 字符，所有服务器将其扩展为某个默认的主页，例如 /index.html。这解释了为什么在浏览器中键入一个域名就可以取出一个网站的主页。浏览器在 URL 后添加缺失的 /，之后服务器把 / 扩展到某个默认的文件名。</li>
</ul>
<h3 id="HTTP事务"><a href="#HTTP事务" class="headerlink" title="HTTP事务"></a>HTTP事务</h3><p>因为 HTTP 是基于在因特网连接上传送的文本行的，我们可以使用 Unix 的 TELNET 程序来和因特网上的任何 Web 服务器执行事务。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Web 服务器使用 HTTP 协议和它们的客户端彼此通信。浏览器向服务器请求静态或者动态内容。CGI 标准提供了一组规则，来管理客户端如何将程序参数传递给服务器，服务器如何将这些参数以及其他信息传递给子进程，以及子进程如何将它的输出发送会客户端</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《深入理解计算机系统》第11章笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSAPP" scheme="https://www.liuin.cn/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 系统级I/O</title>
    <link href="https://www.liuin.cn/2018/02/01/CSAPP-%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O/"/>
    <id>https://www.liuin.cn/2018/02/01/CSAPP-系统级I-O/</id>
    <published>2018-02-01T10:19:48.000Z</published>
    <updated>2018-02-23T04:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>《深入理解计算机系统》第10章笔记</p>
<a id="more"></a>
<p>输入/输出（I/O）是在主存（memory）和外部设备之间拷贝数据的过程。输入数据是从I/O设备拷贝数据到主存，输出数据是从主存拷贝数据到I/O设备。</p>
<h2 id="Unix-I-O"><a href="#Unix-I-O" class="headerlink" title="Unix I/O"></a>Unix I/O</h2><p>所有的的I/O设备都模型化为文件，而所有的输入和输出都当作相应文件的读和写来执行。</p>
<p>所有的输入输出都以一种统一且一致的方式来执行：</p>
<ul>
<li>打开文件</li>
<li>改变当前的文件位置</li>
<li>读写文件</li>
<li>关闭文件</li>
</ul>
<h2 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h2><p>open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符</p>
<h2 id="读和写文件"><a href="#读和写文件" class="headerlink" title="读和写文件"></a>读和写文件</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_1_1517479720893.jpg" alt="enter description here"></p>
<p><code>read</code>函数从描述符为fd的当前文件位置拷贝至多n个字节到存储器位置buf。</p>
<p><code>write</code> 函数从存储器位置拷贝至多n个字节到描述符fd的当前文件位置</p>
<p>通过调用<code>lseek</code>函数，应用程序能够显式地修改当前文件的位置</p>
<h2 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h2><p>可以用许多不同的方式来共享 Unix 文件。内核用三个相关的数据结构来表示打开的文件：</p>
<ul>
<li><strong>描述符表</strong>(descriptor table)。每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表指向文件表中的一个表项。</li>
<li><strong>文件表</strong>(file table)。打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项包括当前的文件位置、引用计数(reference count)，以及一个指向 v-node 表中对应表项的指针。</li>
<li><strong>v-node 表</strong>(v-node table)。同文件表一样，所有的进程共享这张表。每个表项包含 stat 结构中的大多数信息。</li>
</ul>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_1_1517479945102.jpg" alt="典型的打开文件的内核数据结构"></p>
<p>多个描述符也可以通过不同的文件表表项来引用同一个文件</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_1_1517480013346.jpg" alt="enter description here"></p>
<p>子进程继承父进程打开文件</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_2_1_1517480058326.jpg" alt="enter description here"></p>
<h2 id="I-O重定向"><a href="#I-O重定向" class="headerlink" title="I/O重定向"></a>I/O重定向</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_1_1517480099251.jpg" alt="enter description here"></p>
<h2 id="我们该使用哪些I-O函数"><a href="#我们该使用哪些I-O函数" class="headerlink" title="我们该使用哪些I/O函数"></a>我们该使用哪些I/O函数</h2><p><img src="https://data2.liuin.cn/story-writer/2018_2_1_1517480139110.jpg" alt="enter description here"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Unix 提供了少量的系统级函数，它们允许应用程序打开、关闭、读和写文件，提取文件的元数据，以及执行 I/O 重定向。 Unix 的读和写操作会出现不足值，应用程序必须能正确地预计和处理这种情况。应用程序不应直接调用 Unix I/O 函数，而应该使用 RIO 包，RIO 包通过反复执行读写操作，直到传送完所有的请求数据，自动处理不足值。</p>
<p>Unix 内核使用三个相关的数据结构来表示打开的文件。描述符表中的表项指向打开文件表中的表项，而打开文件表中的表项又指向 v-node 表中的表项。</p>
<p>标准 I/O 库是基于 Unix I/O 实现的，并提供了一组强大的高级 I/O 例程。对于大多数应用程序而言，标准 I/O 更简单，是优于 Unix I/O 的选择。然而，因为对标准 I/O 和网络文件的一些相互不兼容的限制，Unix I/O 比标准 I/O 更适用于网络应用程序。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《深入理解计算机系统》第10章笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSAPP" scheme="https://www.liuin.cn/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 虚拟存储器</title>
    <link href="https://www.liuin.cn/2018/01/31/CSAPP-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <id>https://www.liuin.cn/2018/01/31/CSAPP-虚拟存储器/</id>
    <published>2018-01-31T13:51:20.000Z</published>
    <updated>2018-02-23T04:05:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>《深入理解计算机系统》第9章笔记</p>
<a id="more"></a>
<p>一个系统中的进程是与其他进程共享 CPU 和主存资源的。然而，共享主存会形成一些特殊的挑战。随着对 CPU 需求的增长，进程以某种合理的平滑方式慢了下来。但是如果太多的进程需要太多的存储器，那么它们中的一些就根本无法运行。当一个程序没有空间可用时，那就是它运气不好了。存储器还很容易被破坏。如果某个进程不小心写了另一个进程使用的存储器，它就可能以某种完全和程序逻辑无关的令人迷惑的方式失败。</p>
<p>为了更加有效地管理存储器并且少出错，现代系统提供了一种对主存的抽象概念，叫做<strong>虚拟存储器</strong>(VM)。虚拟存储器是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟存储器提供了三个重要的能力：1）它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。2）它为每个进程提供了一致的地址空间，从而简化了存储器管理。3）它保护了每个进程的地址空间不被其他进程破坏。</p>
<p>虚拟存储器是计算机系统最重要的概念之一。它成功的一个主要原因就是因为它是沉默地、自动地工作的，不需要应用程序员的任何干涉。</p>
<h2 id="物理和虚拟寻址"><a href="#物理和虚拟寻址" class="headerlink" title="物理和虚拟寻址"></a>物理和虚拟寻址</h2><p>计算机系统的主存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的<strong>物理地址</strong>(Physical Address, PA)。第一个字节的地址为 0，接下来的字节地址为 1，再下一个为 2，以此类推。给定这种简单的结构，CPU 访问存储器的最自然的方式就是使用物理地址。我们把这种方式称为<strong>物理寻址</strong>(physical addressing)。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403129993.jpg" alt="enter description here"></p>
<p>现代处理器使用的是一种称为<strong>虚拟寻址</strong>(virtual addressing)的寻址形式</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403182759.jpg" alt="enter description here"></p>
<h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p><strong>地址空间</strong>(address space)是一个非负整数地址的有序集合：{0, 1, 2, …}。如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间(linear address space)。</p>
<p>地址空间的概念是很重要的，因为它清楚地区分了数据对象(字节)和它们的属性(地址)。</p>
<p>允许每个数据对象有多个独立的地址，其中每一个地址都选自一个不同的地址空间。这就是虚拟存储器的基本思想</p>
<h2 id="虚拟存储器作为缓存的工具"><a href="#虚拟存储器作为缓存的工具" class="headerlink" title="虚拟存储器作为缓存的工具"></a>虚拟存储器作为缓存的工具</h2><p>概念上而言，虚拟存储器(VM)被组织为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，这个唯一的虚拟地址是作为到数组的索引的。VM 系统通过将虚拟存储器分割为虚拟页(Virtual Page, VP)的大小固定的块来处理这个问题。每个虚拟页的大小为 P=2^p 字节。类似地，物理存储器被分割为物理页(Physical Page, PP)，大小也为 P 字节(物理页也称为页帧(page frame))。</p>
<p>在任意时刻，虚拟页面的集合部分都分为三个不相交的子集：</p>
<ul>
<li>未分配的：VM 系统还未分配(或者创建)的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。</li>
<li>缓存的：当前缓存在物理存储器中的已分配页。</li>
<li>未缓存的：没有缓存在物理存储器中的已分配页。</li>
</ul>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403393083.jpg" alt="enter description here"></p>
<h3 id="DRAM高速缓存的组织结构"><a href="#DRAM高速缓存的组织结构" class="headerlink" title="DRAM高速缓存的组织结构"></a>DRAM高速缓存的组织结构</h3><p>在存储层次结构中，DRAM缓存的位置对于他的组织结构有很大的影响。DRAM 缓存的组织结构完全是由巨大的不命中开销驱动的。因为大的不命中处罚和访问第一字节的开销，虚拟页往往很大，典型地是4KB-2MB。由于大的不命中处罚，DRAM 缓存是全相连的，也就是说，任何虚拟页都可以放置在任何的物理页中。不命中时的替换策略也很重要，因为替换错了虚拟页的出发也非常高。因此，与硬件对 SRAM 缓存相比，操作系统对 DRAM 缓存使用了更复杂精密的替换算法。最后，因为对磁盘的访问时间很长，DRAM 缓存总是使用写回(write back)，而不是直写。</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>同任何缓存一样，虚拟存储器系统必须有某种方法来判定一个虚拟页是否存放在 DRAM 中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理存储器中选择一个牺牲页，并将虚拟页从磁盘拷贝到 DRAM 中，替换这个牺牲页。</p>
<p>这些功能是由许多软硬件联合提供的，包括操作系统软、MMU(存储器管理单元)中的地址翻译硬件和一个存放在物理存储器中叫做<strong>页表</strong>(page table)的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时都会读取页表。操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。</p>
<p>下图展示了一个页表的基本组织结构。页表就是一个页表条目(Page Table Entry, PTE)的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403685361.jpg" alt="enter description here"></p>
<h3 id="页命中"><a href="#页命中" class="headerlink" title="页命中"></a>页命中</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403740507.jpg" alt="enter description here"></p>
<h3 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h3><p>在虚拟存储器的习惯说法中，DRAM不命中称为<strong>缺页</strong>（page fault）。缺页异常调用内核中缺页异常处理程序，该程序会选择一个牺牲页。在磁盘和存储器之间传送页的活动叫做<strong>交换</strong>(swapping)或者<strong>页面调度</strong>(paging)。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403893776.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403911509.jpg" alt="enter description here"></p>
<h3 id="分配页面"><a href="#分配页面" class="headerlink" title="分配页面"></a>分配页面</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517403947855.jpg" alt="enter description here"></p>
<h3 id="局部性再次搭救"><a href="#局部性再次搭救" class="headerlink" title="局部性再次搭救"></a>局部性再次搭救</h3><p>尽管在整个运行过程中程序引用的不同页面的总数可能超出物理存储器总的大小，但是局部性原则保证了在任意时刻，程序往往在一个较小的活动页面(active page)集合上工作，这个集合叫做<strong>工作集</strong>(working set)或者<strong>常驻集</strong>(resident set)。</p>
<p>如果工作集的大小超出了物理存储器的大小，那么程序将产生一种不幸的状态，叫做颠簸（thrashing），这时页面将不断的换进换出。</p>
<h2 id="虚拟存储器作为存储管理的工具"><a href="#虚拟存储器作为存储管理的工具" class="headerlink" title="虚拟存储器作为存储管理的工具"></a>虚拟存储器作为存储管理的工具</h2><p>OS为每个进程提供一个独立的页表，就是一个独立的虚拟地址空间。多个虚拟页面可以映射到同一个共享物理页面上。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404196815.jpg" alt="enter description here"></p>
<h2 id="虚拟存储器作为存储器保护的工具"><a href="#虚拟存储器作为存储器保护的工具" class="headerlink" title="虚拟存储器作为存储器保护的工具"></a>虚拟存储器作为存储器保护的工具</h2><p>任何现代计算机系统都必须为操作系统提供手段来控制对存储器系统的访问。提供独立地址空间使得分离不同进程私有存储器变得容易。地址翻译机制可以以一种自然的方式扩展到提供更好的访问控制。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404420646.jpg" alt="enter description here"></p>
<h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>地址翻译的基础知识：</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404559355.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404669578.jpg" alt="enter description here"></p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404692161.jpg" alt="enter description here"></p>
<h3 id="结合高速缓存和虚拟存储器"><a href="#结合高速缓存和虚拟存储器" class="headerlink" title="结合高速缓存和虚拟存储器"></a>结合高速缓存和虚拟存储器</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404781626.jpg" alt="enter description here"></p>
<h3 id="利用TLB加速地址翻译"><a href="#利用TLB加速地址翻译" class="headerlink" title="利用TLB加速地址翻译"></a>利用TLB加速地址翻译</h3><p>TLB是一个小的、虚拟地址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常有高度的相连性。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404914871.jpg" alt="enter description here"></p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517404952385.jpg" alt="enter description here"></p>
<h2 id="存储器映射"><a href="#存储器映射" class="headerlink" title="存储器映射"></a>存储器映射</h2><p>Linux通过将一个 虚拟存储器区域与一个磁盘上的对象关联起来，以初始化这个虚拟存储器区域的内容，这个过程叫存储器映射（memory mapping）<br>虚拟存储器区域可以映射到两种类型的对象：</p>
<ol>
<li>Unix文件系统的普通文件</li>
<li>匿名文件</li>
</ol>
<h3 id="再看共享对象"><a href="#再看共享对象" class="headerlink" title="再看共享对象"></a>再看共享对象</h3><p>存储器映射的概念来源于一个聪明的发现：如果虚拟存储器系统可以集成到传统的文件系统中，那么就能提供一种简单而高效的把程序和数据加载到存储器中的方法。</p>
<p>一个对象可以被映射到虚拟存储器中的一个区域，要么作为共享对象，要么作为私有对象。另一个方面，对于一个映射到私有对象的区域所做的改变，对于其他进程来说是不可见的，而且进程对这个区域所做的任何写操作都不会反映在磁盘的对象中。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517405449818.jpg" alt="enter description here"></p>
<p>私有对象是使用一种写时拷贝（copy-on-write）的巧妙技巧被映射虚拟存储器中的。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517405536089.jpg" alt="enter description here"></p>
<h2 id="动态存储器分配"><a href="#动态存储器分配" class="headerlink" title="动态存储器分配"></a>动态存储器分配</h2><p>一个动态存储器分配器维护着一个进程的虚拟存储器区域，称为堆（heap）。</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517405624725.jpg" alt="enter description here"></p>
<p>显式分配器要求应用显式地释放任何已经分配的块</p>
<p>隐式分配器要求检测何时一个已分配块不再被使用，然后就释放这个块。隐式分配器也叫做垃圾收集器（garbage collector）</p>
<h3 id="为什么要使用动态存储器分配"><a href="#为什么要使用动态存储器分配" class="headerlink" title="为什么要使用动态存储器分配"></a>为什么要使用动态存储器分配</h3><p>经常直到程序运行时，才知道某些数据结构的大小</p>
<h3 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h3><p>造成堆利用率低的主要原因是碎片（fragmentation），当虽然有未使用的存储器但是不能用来满足分配请求时，就发生这种现象。有两种碎片形式：<strong>内部碎片</strong>（internal fragmentation）和<strong>外部碎片</strong>（external fragmentation）：</p>
<ul>
<li>内部碎片是在一个已分配块比有效载荷大时发生的。</li>
<li>外部碎片是当空闲存储器合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生的。</li>
</ul>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>垃圾收集器（garbage collector）是一种动态存储分配器，它自动释放程序不在需要的已分配块。</p>
<h3 id="垃圾收集器的基本要素"><a href="#垃圾收集器的基本要素" class="headerlink" title="垃圾收集器的基本要素"></a>垃圾收集器的基本要素</h3><p>垃圾收集器将存储器视为一张有向可达图（reachability graph）</p>
<p><img src="https://data2.liuin.cn/story-writer/2018_1_31_1517406251592.jpg" alt="enter description here"></p>
<h2 id="C程序中常见的与存储器相关的错误"><a href="#C程序中常见的与存储器相关的错误" class="headerlink" title="C程序中常见的与存储器相关的错误"></a>C程序中常见的与存储器相关的错误</h2><ul>
<li>间接引用坏指针</li>
<li>读未初始化的存储器</li>
<li>允许栈缓冲区溢出</li>
<li>假设指针和他们指向的对象是相同大小的</li>
<li>造成错位错误</li>
<li>引用指针而不是他们指向的对象</li>
<li>误解指针运算</li>
<li>引用不存在的变量</li>
<li>引用空闲堆块中的数据</li>
<li>引起存储器泄露</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虚拟存储器是对主存的一个抽象，支持虚拟存储器的处理器通过一种叫做虚拟寻址的间接引用来引用主存</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《深入理解计算机系统》第9章笔记&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://www.liuin.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSAPP" scheme="https://www.liuin.cn/tags/CSAPP/"/>
    
  </entry>
  
</feed>
